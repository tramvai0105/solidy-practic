LavaPack.loadBundle([
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\metamask-controller.js", {"../../shared/constants/app":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\app.ts","../../shared/constants/hardware-wallets":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\hardware-wallets.ts","../../shared/constants/keyring":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\keyring.ts","../../shared/constants/metametrics":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\metametrics.ts","../../shared/constants/network":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\network.ts","../../shared/constants/permissions":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\permissions.ts","../../shared/constants/swaps":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\swaps.ts","../../shared/constants/test-flags":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\test-flags.js","../../shared/constants/time":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\time.ts","../../shared/constants/tokens":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\tokens.js","../../shared/constants/transaction":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\transaction.ts","../../shared/lib/metamask-controller-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\lib\\metamask-controller-utils.js","../../shared/lib/token-util.ts":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\lib\\token-util.ts","../../shared/modules/conversion.utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\conversion.utils.ts","../../shared/modules/mv3.utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\mv3.utils.js","../../shared/modules/string-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\string-utils.ts","../../shared/modules/transaction.utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\transaction.utils.js","../../shared/notifications":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\notifications\\index.js","./account-import-strategies":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\account-import-strategies\\index.js","./controllers/alert":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\controllers\\alert.js","./controllers/app-state":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\controllers\\app-state.js","./controllers/backup":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\controllers\\backup.js","./controllers/cached-balances":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\controllers\\cached-balances.js","./controllers/decrypt-message":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\controllers\\decrypt-message.ts","./controllers/detect-tokens":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\controllers\\detect-tokens.js","./controllers/encryption-public-key":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\controllers\\encryption-public-key.ts","./controllers/ens":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\controllers\\ens\\index.js","./controllers/incoming-transactions":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\controllers\\incoming-transactions.js","./controllers/metametrics":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\controllers\\metametrics.js","./controllers/network":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\controllers\\network\\index.ts","./controllers/onboarding":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\controllers\\onboarding.js","./controllers/permissions":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\controllers\\permissions\\index.js","./controllers/preferences":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\controllers\\preferences.js","./controllers/swaps":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\controllers\\swaps.js","./controllers/transactions":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\controllers\\transactions\\index.js","./detect-multiple-instances":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\detect-multiple-instances.js","./lib/ComposableObservableStore":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\lib\\ComposableObservableStore.js","./lib/account-tracker":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\lib\\account-tracker.js","./lib/createDupeReqFilterMiddleware":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\lib\\createDupeReqFilterMiddleware.js","./lib/createLoggerMiddleware":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\lib\\createLoggerMiddleware.js","./lib/createMetaRPCHandler":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\lib\\createMetaRPCHandler.js","./lib/createMetamaskMiddleware":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\lib\\createMetamaskMiddleware.js","./lib/createOnboardingMiddleware":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\lib\\createOnboardingMiddleware.js","./lib/createOriginMiddleware":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\lib\\createOriginMiddleware.js","./lib/createRPCMethodTrackingMiddleware":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\lib\\createRPCMethodTrackingMiddleware.js","./lib/createTabIdMiddleware":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\lib\\createTabIdMiddleware.js","./lib/rpc-method-middleware":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\lib\\rpc-method-middleware\\index.js","./lib/security-provider-helpers":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\lib\\security-provider-helpers.ts","./lib/seed-phrase-verifier":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\lib\\seed-phrase-verifier.js","./lib/segment":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\lib\\segment\\index.js","./lib/stream-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\lib\\stream-utils.js","./lib/util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\lib\\util.ts","@keystonehq/metamask-airgapped-keyring":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\index.js","@metamask/address-book-controller":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\address-book-controller\\dist\\index.js","@metamask/announcement-controller":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\announcement-controller\\dist\\index.js","@metamask/approval-controller":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\approval-controller\\dist\\index.js","@metamask/assets-controllers":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\assets-controllers\\dist\\index.js","@metamask/base-controller":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\base-controller\\dist\\index.js","@metamask/controller-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\controller-utils\\dist\\index.js","@metamask/eth-json-rpc-middleware":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\index.js","@metamask/eth-keyring-controller":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-keyring-controller\\index.js","@metamask/eth-ledger-bridge-keyring":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\index.js","@metamask/eth-trezor-keyring":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-trezor-keyring\\index.js","@metamask/gas-fee-controller":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\gas-fee-controller\\dist\\index.js","@metamask/obs-store":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\obs-store\\dist\\index.js","@metamask/obs-store/dist/asStream":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\obs-store\\dist\\asStream.js","@metamask/permission-controller":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\permission-controller\\dist\\index.js","@metamask/phishing-controller":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\phishing-controller\\dist\\index.js","@metamask/signature-controller":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\signature-controller\\dist\\index.js","@metamask/smart-transactions-controller":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\smart-transactions-controller\\dist\\index.js","@metamask/subject-metadata-controller":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\subject-metadata-controller\\dist\\index.js","@sentry/browser":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@sentry\\browser\\dist\\index.js","await-semaphore":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\await-semaphore\\index.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js","eth-json-rpc-filters":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\eth-json-rpc-filters\\index.js","eth-json-rpc-filters/subscriptionManager":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\eth-json-rpc-filters\\subscriptionManager.js","eth-lattice-keyring":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\eth-lattice-keyring\\index.js","eth-query":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\eth-query\\index.js","eth-rpc-errors":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\eth-rpc-errors\\dist\\index.js","events":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\events\\events.js","json-rpc-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-rpc-engine\\dist\\index.js","json-rpc-middleware-stream":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-rpc-middleware-stream\\dist\\index.js","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js","loglevel":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\loglevel\\lib\\loglevel.js","nanoid":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\nanoid\\index.browser.js","pump":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pump\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmetamask-controller.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.METAMASK_CONTROLLER_EVENTS = void 0;
var _events = _interopRequireDefault(require("events"));
var _pump = _interopRequireDefault(require("pump"));
var _obsStore = require("@metamask/obs-store");
var _asStream = require("@metamask/obs-store/dist/asStream");
var _jsonRpcEngine = require("json-rpc-engine");
var _jsonRpcMiddlewareStream = require("json-rpc-middleware-stream");
var _ethJsonRpcMiddleware = require("@metamask/eth-json-rpc-middleware");
var _lodash = require("lodash");
var _ethKeyringController = require("@metamask/eth-keyring-controller");
var _ethJsonRpcFilters = _interopRequireDefault(require("eth-json-rpc-filters"));
var _subscriptionManager = _interopRequireDefault(require("eth-json-rpc-filters/subscriptionManager"));
var _ethRpcErrors = require("eth-rpc-errors");
var _awaitSemaphore = require("await-semaphore");
var _loglevel = _interopRequireDefault(require("loglevel"));
var _ethTrezorKeyring = _interopRequireDefault(require("@metamask/eth-trezor-keyring"));
var _ethLedgerBridgeKeyring = _interopRequireDefault(require("@metamask/eth-ledger-bridge-keyring"));
var _ethLatticeKeyring = _interopRequireDefault(require("eth-lattice-keyring"));
var _metamaskAirgappedKeyring = require("@keystonehq/metamask-airgapped-keyring");
var _ethQuery = _interopRequireDefault(require("eth-query"));
var _nanoid = _interopRequireDefault(require("nanoid"));
var _browser = require("@sentry/browser");
var _addressBookController = require("@metamask/address-book-controller");
var _approvalController = require("@metamask/approval-controller");
var _baseController = require("@metamask/base-controller");
var _assetsControllers = require("@metamask/assets-controllers");
var _phishingController = require("@metamask/phishing-controller");
var _announcementController = require("@metamask/announcement-controller");
var _gasFeeController = require("@metamask/gas-fee-controller");
var _permissionController = require("@metamask/permission-controller");
var _subjectMetadataController = require("@metamask/subject-metadata-controller");
var _smartTransactionsController = _interopRequireDefault(require("@metamask/smart-transactions-controller"));
var _signatureController = require("@metamask/signature-controller");
var _controllerUtils = require("@metamask/controller-utils");
var _transaction = require("../../shared/constants/transaction");
var _swaps = require("../../shared/constants/swaps");
var _network = require("../../shared/constants/network");
var _hardwareWallets = require("../../shared/constants/hardware-wallets");
var _keyring = require("../../shared/constants/keyring");
var _permissions = require("../../shared/constants/permissions");
var _notifications = require("../../shared/notifications");
var _time = require("../../shared/constants/time");
var _app = require("../../shared/constants/app");
var _metametrics = require("../../shared/constants/metametrics");
var _tokenUtil = require("../../shared/lib/token-util.ts");
var _stringUtils = require("../../shared/modules/string-utils");
var _transaction2 = require("../../shared/modules/transaction.utils");
var _tokens = require("../../shared/constants/tokens");
var _metamaskControllerUtils = require("../../shared/lib/metamask-controller-utils");
var _mv = require("../../shared/modules/mv3.utils");
var _conversion = require("../../shared/modules/conversion.utils");
var _testFlags = require("../../shared/constants/test-flags");
var _detectMultipleInstances = require("./detect-multiple-instances");
var _ComposableObservableStore = _interopRequireDefault(require("./lib/ComposableObservableStore"));
var _accountTracker = _interopRequireDefault(require("./lib/account-tracker"));
var _createDupeReqFilterMiddleware = _interopRequireDefault(require("./lib/createDupeReqFilterMiddleware"));
var _createLoggerMiddleware = _interopRequireDefault(require("./lib/createLoggerMiddleware"));
var _rpcMethodMiddleware = require("./lib/rpc-method-middleware");
var _createOriginMiddleware = _interopRequireDefault(require("./lib/createOriginMiddleware"));
var _createTabIdMiddleware = _interopRequireDefault(require("./lib/createTabIdMiddleware"));
var _createOnboardingMiddleware = _interopRequireDefault(require("./lib/createOnboardingMiddleware"));
var _streamUtils = require("./lib/stream-utils");
var _ens = _interopRequireDefault(require("./controllers/ens"));
var _network2 = require("./controllers/network");
var _preferences = _interopRequireDefault(require("./controllers/preferences"));
var _appState = _interopRequireDefault(require("./controllers/app-state"));
var _cachedBalances = _interopRequireDefault(require("./controllers/cached-balances"));
var _alert = _interopRequireDefault(require("./controllers/alert"));
var _onboarding = _interopRequireDefault(require("./controllers/onboarding"));
var _backup = _interopRequireDefault(require("./controllers/backup"));
var _incomingTransactions = _interopRequireDefault(require("./controllers/incoming-transactions"));
var _decryptMessage = _interopRequireDefault(require("./controllers/decrypt-message"));
var _transactions = _interopRequireDefault(require("./controllers/transactions"));
var _detectTokens = _interopRequireDefault(require("./controllers/detect-tokens"));
var _swaps2 = _interopRequireDefault(require("./controllers/swaps"));
var _accountImportStrategies = _interopRequireDefault(require("./account-import-strategies"));
var _seedPhraseVerifier = _interopRequireDefault(require("./lib/seed-phrase-verifier"));
var _metametrics2 = _interopRequireDefault(require("./controllers/metametrics"));
var _segment = require("./lib/segment");
var _createMetaRPCHandler = _interopRequireDefault(require("./lib/createMetaRPCHandler"));
var _util = require("./lib/util");
var _createMetamaskMiddleware = _interopRequireDefault(require("./lib/createMetamaskMiddleware"));
var _encryptionPublicKey = _interopRequireDefault(require("./controllers/encryption-public-key"));
var _permissions2 = require("./controllers/permissions");
var _createRPCMethodTrackingMiddleware = _interopRequireDefault(require("./lib/createRPCMethodTrackingMiddleware"));
var _securityProviderHelpers = require("./lib/security-provider-helpers");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const METAMASK_CONTROLLER_EVENTS = {
  // Fired after state changes that impact the extension badge (unapproved msg count)
  // The process of updating the badge happens in app/scripts/background.js.
  UPDATE_BADGE: 'updateBadge',
  // TODO: Add this and similar enums to the `controllers` repo and export them
  APPROVAL_STATE_CHANGE: 'ApprovalController:stateChange'
};

// stream channels
exports.METAMASK_CONTROLLER_EVENTS = METAMASK_CONTROLLER_EVENTS;
const PHISHING_SAFELIST = 'metamask-phishing-safelist';
class MetamaskController extends _events.default {
  /**
   * @param {object} opts
   */
  constructor(opts) {
    var _initState$AccountTra;
    super();
    _defineProperty(this, "removePermissionsFor", subjects => {
      try {
        this.permissionController.revokePermissions(subjects);
      } catch (exp) {
        if (!(exp instanceof _permissionController.PermissionsRequestNotFoundError)) {
          throw exp;
        }
      }
    });
    _defineProperty(this, "rejectPermissionsRequest", requestId => {
      try {
        this.permissionController.rejectPermissionsRequest(requestId);
      } catch (exp) {
        if (!(exp instanceof _permissionController.PermissionsRequestNotFoundError)) {
          throw exp;
        }
      }
    });
    _defineProperty(this, "acceptPermissionsRequest", request => {
      try {
        this.permissionController.acceptPermissionsRequest(request);
      } catch (exp) {
        if (!(exp instanceof _permissionController.PermissionsRequestNotFoundError)) {
          throw exp;
        }
      }
    });
    _defineProperty(this, "resolvePendingApproval", (id, value) => {
      try {
        this.approvalController.accept(id, value);
      } catch (exp) {
        if (!(exp instanceof _approvalController.ApprovalRequestNotFoundError)) {
          throw exp;
        }
      }
    });
    _defineProperty(this, "rejectPendingApproval", (id, error) => {
      try {
        this.approvalController.reject(id, new _ethRpcErrors.EthereumRpcError(error.code, error.message, error.data));
      } catch (exp) {
        if (!(exp instanceof _approvalController.ApprovalRequestNotFoundError)) {
          throw exp;
        }
      }
    });
    const {
      isFirstMetaMaskControllerSetup
    } = opts;
    this.defaultMaxListeners = 20;
    this.sendUpdate = (0, _lodash.debounce)(this.privateSendUpdate.bind(this), _time.MILLISECOND * 200);
    this.opts = opts;
    this.extension = opts.browser;
    this.platform = opts.platform;
    this.notificationManager = opts.notificationManager;
    const initState = opts.initState || {};
    const version = this.platform.getVersion();
    this.recordFirstTimeInfo(initState);

    // this keeps track of how many "controllerStream" connections are open
    // the only thing that uses controller connections are open metamask UI instances
    this.activeControllerConnections = 0;
    this.getRequestAccountTabIds = opts.getRequestAccountTabIds;
    this.getOpenMetamaskTabsIds = opts.getOpenMetamaskTabsIds;
    this.controllerMessenger = new _baseController.ControllerMessenger();

    // instance of a class that wraps the extension's storage local API.
    this.localStoreApiWrapper = opts.localStore;

    // observable state store
    this.store = new _ComposableObservableStore.default({
      state: initState,
      controllerMessenger: this.controllerMessenger,
      persist: true
    });

    // external connections by origin
    // Do not modify directly. Use the associated methods.
    this.connections = {};

    // lock to ensure only one vault created at once
    this.createVaultMutex = new _awaitSemaphore.Mutex();
    this.extension.runtime.onInstalled.addListener(details => {
      if (details.reason === 'update' && version === '8.1.0') {
        this.platform.openExtensionInBrowser();
      }
    });

    // next, we will initialize the controllers
    // controller initialization order matters

    this.approvalController = new _approvalController.ApprovalController({
      messenger: this.controllerMessenger.getRestricted({
        name: 'ApprovalController'
      }),
      showApprovalRequest: opts.showUserConfirmation,
      typesExcludedFromRateLimiting: [_controllerUtils.ApprovalType.EthSign, _controllerUtils.ApprovalType.PersonalSign, _controllerUtils.ApprovalType.EthSignTypedData, _controllerUtils.ApprovalType.Transaction, _controllerUtils.ApprovalType.WatchAsset, _controllerUtils.ApprovalType.EthGetEncryptionPublicKey, _controllerUtils.ApprovalType.EthDecrypt]
    });
    const networkControllerMessenger = this.controllerMessenger.getRestricted({
      name: 'NetworkController',
      allowedEvents: Object.values(_network2.NetworkControllerEventType)
    });
    this.networkController = new _network2.NetworkController({
      messenger: networkControllerMessenger,
      state: initState.NetworkController,
      infuraProjectId: opts.infuraProjectId,
      trackMetaMetricsEvent: (...args) => this.metaMetricsController.trackEvent(...args)
    });
    this.networkController.initializeProvider();
    this.provider = this.networkController.getProviderAndBlockTracker().provider;
    this.blockTracker = this.networkController.getProviderAndBlockTracker().blockTracker;
    const tokenListMessenger = this.controllerMessenger.getRestricted({
      name: 'TokenListController'
    });
    this.tokenListController = new _assetsControllers.TokenListController({
      chainId: (0, _conversion.hexToDecimal)(this.networkController.store.getState().providerConfig.chainId),
      preventPollingOnNetworkRestart: initState.TokenListController ? initState.TokenListController.preventPollingOnNetworkRestart : true,
      onNetworkStateChange: cb => {
        this.networkController.store.subscribe(networkState => {
          const modifiedNetworkState = {
            ...networkState,
            providerConfig: {
              ...networkState.providerConfig,
              chainId: (0, _conversion.hexToDecimal)(networkState.providerConfig.chainId)
            }
          };
          return cb(modifiedNetworkState);
        });
      },
      messenger: tokenListMessenger,
      state: initState.TokenListController
    });
    this.preferencesController = new _preferences.default({
      initState: initState.PreferencesController,
      initLangCode: opts.initLangCode,
      onInfuraIsBlocked: networkControllerMessenger.subscribe.bind(networkControllerMessenger, _network2.NetworkControllerEventType.InfuraIsBlocked),
      onInfuraIsUnblocked: networkControllerMessenger.subscribe.bind(networkControllerMessenger, _network2.NetworkControllerEventType.InfuraIsUnblocked),
      tokenListController: this.tokenListController,
      provider: this.provider
    });
    this.tokensController = new _assetsControllers.TokensController({
      onPreferencesStateChange: this.preferencesController.store.subscribe.bind(this.preferencesController.store),
      onNetworkStateChange: cb => this.networkController.store.subscribe(networkState => {
        const modifiedNetworkState = {
          ...networkState,
          providerConfig: {
            ...networkState.providerConfig
          }
        };
        return cb(modifiedNetworkState);
      }),
      config: {
        provider: this.provider
      },
      state: initState.TokensController,
      messenger: this.controllerMessenger.getRestricted({
        name: 'TokensController',
        allowedActions: [`${this.approvalController.name}:addRequest`, `${this.approvalController.name}:acceptRequest`, `${this.approvalController.name}:rejectRequest`]
      })
    });
    this.assetsContractController = new _assetsControllers.AssetsContractController({
      onPreferencesStateChange: listener => this.preferencesController.store.subscribe(listener),
      // This handler is misnamed, and is a known issue that will be resolved
      // by planned refactors. It should be onNetworkDidChange which happens
      // AFTER the provider in the network controller is updated to reflect
      // the new state of the network controller. In #18041 we changed this
      // handler to be triggered by the change in the network state because
      // that is what the handler name implies, but this triggers too soon
      // causing the provider of the AssetsContractController to trail the
      // network provider by one update.
      onNetworkStateChange: cb => networkControllerMessenger.subscribe(_network2.NetworkControllerEventType.NetworkDidChange, () => {
        const networkState = this.networkController.store.getState();
        const modifiedNetworkState = {
          ...networkState,
          providerConfig: {
            ...networkState.providerConfig,
            chainId: (0, _conversion.hexToDecimal)(networkState.providerConfig.chainId)
          }
        };
        return cb(modifiedNetworkState);
      })
    }, {
      provider: this.provider
    }, initState.AssetsContractController);
    this.nftController = new _assetsControllers.NftController({
      onPreferencesStateChange: this.preferencesController.store.subscribe.bind(this.preferencesController.store),
      onNetworkStateChange: cb => this.networkController.store.subscribe(networkState => {
        const modifiedNetworkState = {
          ...networkState,
          providerConfig: {
            ...networkState.providerConfig,
            chainId: (0, _conversion.hexToDecimal)(networkState.providerConfig.chainId)
          }
        };
        return cb(modifiedNetworkState);
      }),
      getERC721AssetName: this.assetsContractController.getERC721AssetName.bind(this.assetsContractController),
      getERC721AssetSymbol: this.assetsContractController.getERC721AssetSymbol.bind(this.assetsContractController),
      getERC721TokenURI: this.assetsContractController.getERC721TokenURI.bind(this.assetsContractController),
      getERC721OwnerOf: this.assetsContractController.getERC721OwnerOf.bind(this.assetsContractController),
      getERC1155BalanceOf: this.assetsContractController.getERC1155BalanceOf.bind(this.assetsContractController),
      getERC1155TokenURI: this.assetsContractController.getERC1155TokenURI.bind(this.assetsContractController),
      onNftAdded: ({
        address,
        symbol,
        tokenId,
        standard,
        source
      }) => this.metaMetricsController.trackEvent({
        event: _metametrics.MetaMetricsEventName.NftAdded,
        category: _metametrics.MetaMetricsEventCategory.Wallet,
        properties: {
          token_contract_address: address,
          token_symbol: symbol,
          asset_type: _transaction.AssetType.NFT,
          token_standard: standard,
          source
        },
        sensitiveProperties: {
          tokenId
        }
      })
    }, {}, initState.NftController);
    this.nftController.setApiKey(null);
    this.nftDetectionController = new _assetsControllers.NftDetectionController({
      onNftsStateChange: listener => this.nftController.subscribe(listener),
      onPreferencesStateChange: this.preferencesController.store.subscribe.bind(this.preferencesController.store),
      onNetworkStateChange: cb => this.networkController.store.subscribe(networkState => {
        const modifiedNetworkState = {
          ...networkState,
          providerConfig: {
            ...networkState.providerConfig,
            chainId: (0, _conversion.hexToDecimal)(networkState.providerConfig.chainId)
          }
        };
        return cb(modifiedNetworkState);
      }),
      getOpenSeaApiKey: () => this.nftController.openSeaApiKey,
      getBalancesInSingleCall: this.assetsContractController.getBalancesInSingleCall.bind(this.assetsContractController),
      addNft: this.nftController.addNft.bind(this.nftController),
      getNftState: () => this.nftController.state
    });
    this.metaMetricsController = new _metametrics2.default({
      segment: _segment.segment,
      preferencesStore: this.preferencesController.store,
      onNetworkDidChange: networkControllerMessenger.subscribe.bind(networkControllerMessenger, _network2.NetworkControllerEventType.NetworkDidChange),
      getNetworkIdentifier: () => {
        const {
          type,
          rpcUrl
        } = this.networkController.store.getState().providerConfig;
        return type === _network.NETWORK_TYPES.RPC ? rpcUrl : type;
      },
      getCurrentChainId: () => this.networkController.store.getState().providerConfig.chainId,
      version: this.platform.getVersion(),
      environment: "development",
      extension: this.extension,
      initState: initState.MetaMetricsController,
      captureException: _browser.captureException
    });
    this.on('update', update => {
      this.metaMetricsController.handleMetaMaskStateUpdate(update);
    });
    const gasFeeMessenger = this.controllerMessenger.getRestricted({
      name: 'GasFeeController'
    });
    const gasApiBaseUrl = false ? _swaps.GAS_DEV_API_BASE_URL : _swaps.GAS_API_BASE_URL;
    this.gasFeeController = new _gasFeeController.GasFeeController({
      state: initState.GasFeeController,
      interval: 10000,
      messenger: gasFeeMessenger,
      clientId: _swaps.SWAPS_CLIENT_ID,
      getProvider: () => this.networkController.getProviderAndBlockTracker().provider,
      // NOTE: This option is inaccurately named; it should be called
      // onNetworkDidChange
      onNetworkStateChange: networkControllerMessenger.subscribe.bind(networkControllerMessenger, _network2.NetworkControllerEventType.NetworkDidChange),
      getCurrentNetworkEIP1559Compatibility: this.networkController.getEIP1559Compatibility.bind(this.networkController),
      getCurrentAccountEIP1559Compatibility: this.getCurrentAccountEIP1559Compatibility.bind(this),
      legacyAPIEndpoint: `${gasApiBaseUrl}/networks/<chain_id>/gasPrices`,
      EIP1559APIEndpoint: `${gasApiBaseUrl}/networks/<chain_id>/suggestedGasFees`,
      getCurrentNetworkLegacyGasAPICompatibility: () => {
        const {
          chainId
        } = this.networkController.store.getState().providerConfig;
        return false || chainId === _network.CHAIN_IDS.MAINNET;
      },
      getChainId: () => {
        return false ? _network.CHAIN_IDS.MAINNET : this.networkController.store.getState().providerConfig.chainId;
      }
    });
    this.qrHardwareKeyring = new _metamaskAirgappedKeyring.MetaMaskKeyring();
    this.appStateController = new _appState.default({
      addUnlockListener: this.on.bind(this, 'unlock'),
      isUnlocked: this.isUnlocked.bind(this),
      initState: initState.AppStateController,
      onInactiveTimeout: () => this.setLocked(),
      preferencesStore: this.preferencesController.store,
      qrHardwareStore: this.qrHardwareKeyring.getMemStore(),
      messenger: this.controllerMessenger.getRestricted({
        name: 'AppStateController',
        allowedActions: [`${this.approvalController.name}:addRequest`, `${this.approvalController.name}:acceptRequest`]
      })
    });
    const currencyRateMessenger = this.controllerMessenger.getRestricted({
      name: 'CurrencyRateController'
    });
    this.currencyRateController = new _assetsControllers.CurrencyRateController({
      includeUsdRate: true,
      messenger: currencyRateMessenger,
      state: {
        ...initState.CurrencyController,
        nativeCurrency: this.networkController.store.getState().providerConfig.ticker
      }
    });
    this.phishingController = new _phishingController.PhishingController({}, initState.PhishingController);
    this.phishingController.maybeUpdateState();
    if (false) {
      this.phishingController.setHotlistRefreshInterval(5 * _time.SECOND);
      this.phishingController.setStalelistRefreshInterval(30 * _time.SECOND);
    }
    const announcementMessenger = this.controllerMessenger.getRestricted({
      name: 'AnnouncementController'
    });
    this.announcementController = new _announcementController.AnnouncementController({
      messenger: announcementMessenger,
      allAnnouncements: _notifications.UI_NOTIFICATIONS,
      state: initState.AnnouncementController
    });

    // token exchange rate tracker
    this.tokenRatesController = new _assetsControllers.TokenRatesController({
      onTokensStateChange: listener => this.tokensController.subscribe(listener),
      onCurrencyRateStateChange: listener => this.controllerMessenger.subscribe(`${this.currencyRateController.name}:stateChange`, listener),
      onNetworkStateChange: cb => this.networkController.store.subscribe(networkState => {
        const modifiedNetworkState = {
          ...networkState,
          providerConfig: {
            ...networkState.providerConfig,
            chainId: (0, _conversion.hexToDecimal)(networkState.providerConfig.chainId)
          }
        };
        return cb(modifiedNetworkState);
      })
    }, {
      disabled: !this.preferencesController.store.getState().useCurrencyRateCheck
    }, initState.TokenRatesController);
    this.preferencesController.store.subscribe((0, _util.previousValueComparator)((prevState, currState) => {
      const {
        useCurrencyRateCheck: prevUseCurrencyRateCheck
      } = prevState;
      const {
        useCurrencyRateCheck: currUseCurrencyRateCheck
      } = currState;
      if (currUseCurrencyRateCheck && !prevUseCurrencyRateCheck) {
        this.currencyRateController.start();
        this.tokenRatesController.configure({
          disabled: false
        }, false, false);
      } else if (!currUseCurrencyRateCheck && prevUseCurrencyRateCheck) {
        this.currencyRateController.stop();
        this.tokenRatesController.configure({
          disabled: true
        }, false, false);
      }
    }, this.preferencesController.store.getState()));
    this.ensController = new _ens.default({
      provider: this.provider,
      getCurrentChainId: () => this.networkController.store.getState().providerConfig.chainId,
      onNetworkDidChange: networkControllerMessenger.subscribe.bind(networkControllerMessenger, _network2.NetworkControllerEventType.NetworkDidChange)
    });
    this.onboardingController = new _onboarding.default({
      initState: initState.OnboardingController
    });
    this.incomingTransactionsController = new _incomingTransactions.default({
      blockTracker: this.blockTracker,
      onNetworkDidChange: networkControllerMessenger.subscribe.bind(networkControllerMessenger, _network2.NetworkControllerEventType.NetworkDidChange),
      getCurrentChainId: () => this.networkController.store.getState().providerConfig.chainId,
      preferencesController: this.preferencesController,
      onboardingController: this.onboardingController,
      initState: initState.IncomingTransactionsController
    });

    // account tracker watches balances, nonces, and any code at their address
    this.accountTracker = new _accountTracker.default({
      provider: this.provider,
      blockTracker: this.blockTracker,
      getCurrentChainId: () => this.networkController.store.getState().providerConfig.chainId,
      getNetworkIdentifier: () => {
        const {
          type,
          rpcUrl
        } = this.networkController.store.getState().providerConfig;
        return type === _network.NETWORK_TYPES.RPC ? rpcUrl : type;
      },
      preferencesController: this.preferencesController,
      onboardingController: this.onboardingController,
      initState: _mv.isManifestV3 && isFirstMetaMaskControllerSetup === false && (_initState$AccountTra = initState.AccountTracker) !== null && _initState$AccountTra !== void 0 && _initState$AccountTra.accounts ? {
        accounts: initState.AccountTracker.accounts
      } : {
        accounts: {}
      }
    });

    // start and stop polling for balances based on activeControllerConnections
    this.on('controllerConnectionChanged', activeControllerConnections => {
      const {
        completedOnboarding
      } = this.onboardingController.store.getState();
      if (activeControllerConnections > 0 && completedOnboarding) {
        this.triggerNetworkrequests();
      } else {
        this.stopNetworkRequests();
      }
    });
    this.onboardingController.store.subscribe((0, _util.previousValueComparator)(async (prevState, currState) => {
      const {
        completedOnboarding: prevCompletedOnboarding
      } = prevState;
      const {
        completedOnboarding: currCompletedOnboarding
      } = currState;
      if (!prevCompletedOnboarding && currCompletedOnboarding) {
        this.triggerNetworkrequests();
      }
    }, this.onboardingController.store.getState()));
    this.cachedBalancesController = new _cachedBalances.default({
      accountTracker: this.accountTracker,
      getCurrentChainId: () => this.networkController.store.getState().providerConfig.chainId,
      initState: initState.CachedBalancesController
    });
    let additionalKeyrings = [(0, _ethKeyringController.keyringBuilderFactory)(_metamaskAirgappedKeyring.MetaMaskKeyring)];
    if (this.canUseHardwareWallets()) {
      var _this$opts$overrides;
      const keyringOverrides = (_this$opts$overrides = this.opts.overrides) === null || _this$opts$overrides === void 0 ? void 0 : _this$opts$overrides.keyrings;
      const additionalKeyringTypes = [(keyringOverrides === null || keyringOverrides === void 0 ? void 0 : keyringOverrides.trezor) || _ethTrezorKeyring.default, (keyringOverrides === null || keyringOverrides === void 0 ? void 0 : keyringOverrides.ledger) || _ethLedgerBridgeKeyring.default, (keyringOverrides === null || keyringOverrides === void 0 ? void 0 : keyringOverrides.lattice) || _ethLatticeKeyring.default, _metamaskAirgappedKeyring.MetaMaskKeyring];
      additionalKeyrings = additionalKeyringTypes.map(keyringType => (0, _ethKeyringController.keyringBuilderFactory)(keyringType));
    }
    this.keyringController = new _ethKeyringController.KeyringController({
      keyringBuilders: additionalKeyrings,
      initState: initState.KeyringController,
      encryptor: opts.encryptor || undefined,
      cacheEncryptionKey: _mv.isManifestV3
    });
    this.keyringController.memStore.subscribe(state => this._onKeyringControllerUpdate(state));
    this.keyringController.on('unlock', () => this._onUnlock());
    this.keyringController.on('lock', () => this._onLock());
    const getIdentities = () => this.preferencesController.store.getState().identities;
    this.permissionController = new _permissionController.PermissionController({
      messenger: this.controllerMessenger.getRestricted({
        name: 'PermissionController',
        allowedActions: [`${this.approvalController.name}:addRequest`, `${this.approvalController.name}:hasRequest`, `${this.approvalController.name}:acceptRequest`, `${this.approvalController.name}:rejectRequest`, `SnapController:getPermitted`, `SnapController:install`, `SubjectMetadataController:getSubjectMetadata`]
      }),
      state: initState.PermissionController,
      caveatSpecifications: (0, _permissions2.getCaveatSpecifications)({
        getIdentities
      }),
      permissionSpecifications: {
        ...(0, _permissions2.getPermissionSpecifications)({
          getIdentities,
          getAllAccounts: this.keyringController.getAccounts.bind(this.keyringController),
          captureKeyringTypesWithMissingIdentities: (identities = {}, accounts = []) => {
            const accountsMissingIdentities = accounts.filter(address => !identities[address]);
            const keyringTypesWithMissingIdentities = accountsMissingIdentities.map(address => {
              var _this$keyringControll;
              return (_this$keyringControll = this.keyringController.getKeyringForAccount(address)) === null || _this$keyringControll === void 0 ? void 0 : _this$keyringControll.type;
            });
            const identitiesCount = Object.keys(identities || {}).length;
            const accountTrackerCount = Object.keys(this.accountTracker.store.getState().accounts || {}).length;
            (0, _browser.captureException)(new Error(`Attempt to get permission specifications failed because their were ${accounts.length} accounts, but ${identitiesCount} identities, and the ${keyringTypesWithMissingIdentities} keyrings included accounts with missing identities. Meanwhile, there are ${accountTrackerCount} accounts in the account tracker.`));
          }
        })
      },
      unrestrictedMethods: _permissions2.unrestrictedMethods
    });
    this.permissionLogController = new _permissions2.PermissionLogController({
      restrictedMethods: new Set(Object.keys(_permissions.RestrictedMethods)),
      initState: initState.PermissionLogController
    });
    this.subjectMetadataController = new _subjectMetadataController.SubjectMetadataController({
      messenger: this.controllerMessenger.getRestricted({
        name: 'SubjectMetadataController',
        allowedActions: [`${this.permissionController.name}:hasPermissions`]
      }),
      state: initState.SubjectMetadataController,
      subjectCacheLimit: 100
    });
    this.detectTokensController = new _detectTokens.default({
      preferences: this.preferencesController,
      tokensController: this.tokensController,
      assetsContractController: this.assetsContractController,
      network: this.networkController,
      keyringMemStore: this.keyringController.memStore,
      tokenList: this.tokenListController,
      trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.addressBookController = new _addressBookController.AddressBookController(undefined, initState.AddressBookController);
    this.alertController = new _alert.default({
      initState: initState.AlertController,
      preferencesStore: this.preferencesController.store
    });
    this.backupController = new _backup.default({
      preferencesController: this.preferencesController,
      addressBookController: this.addressBookController,
      networkController: this.networkController,
      trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.txController = new _transactions.default({
      initState: initState.TransactionController || initState.TransactionManager,
      getPermittedAccounts: this.getPermittedAccounts.bind(this),
      getProviderConfig: () => this.networkController.store.getState().providerConfig,
      getCurrentNetworkEIP1559Compatibility: this.networkController.getEIP1559Compatibility.bind(this.networkController),
      getCurrentAccountEIP1559Compatibility: this.getCurrentAccountEIP1559Compatibility.bind(this),
      getNetworkId: () => this.networkController.store.getState().networkId,
      getNetworkStatus: () => this.networkController.store.getState().networkStatus,
      onNetworkStateChange: listener => {
        let previousNetworkId = this.networkController.store.getState().networkId;
        this.networkController.store.subscribe(state => {
          if (previousNetworkId !== state.networkId) {
            listener();
            previousNetworkId = state.networkId;
          }
        });
      },
      getCurrentChainId: () => this.networkController.store.getState().providerConfig.chainId,
      preferencesStore: this.preferencesController.store,
      txHistoryLimit: 60,
      signTransaction: this.keyringController.signTransaction.bind(this.keyringController),
      provider: this.provider,
      blockTracker: this.blockTracker,
      createEventFragment: this.metaMetricsController.createEventFragment.bind(this.metaMetricsController),
      updateEventFragment: this.metaMetricsController.updateEventFragment.bind(this.metaMetricsController),
      finalizeEventFragment: this.metaMetricsController.finalizeEventFragment.bind(this.metaMetricsController),
      getEventFragmentById: this.metaMetricsController.getEventFragmentById.bind(this.metaMetricsController),
      trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController),
      getParticipateInMetrics: () => this.metaMetricsController.state.participateInMetaMetrics,
      getEIP1559GasFeeEstimates: this.gasFeeController.fetchGasFeeEstimates.bind(this.gasFeeController),
      getExternalPendingTransactions: this.getExternalPendingTransactions.bind(this),
      getAccountType: this.getAccountType.bind(this),
      getDeviceModel: this.getDeviceModel.bind(this),
      getTokenStandardAndDetails: this.getTokenStandardAndDetails.bind(this),
      securityProviderRequest: this.securityProviderRequest.bind(this),
      messenger: this.controllerMessenger.getRestricted({
        name: 'TransactionController',
        allowedActions: [`${this.approvalController.name}:addRequest`, `${this.approvalController.name}:acceptRequest`, `${this.approvalController.name}:rejectRequest`]
      })
    });
    this.txController.on(`tx:status-update`, async (txId, status) => {
      if (status === _transaction.TransactionStatus.confirmed || status === _transaction.TransactionStatus.failed) {
        const txMeta = this.txController.txStateManager.getTransaction(txId);
        let rpcPrefs = {};
        if (txMeta.chainId) {
          const {
            networkConfigurations
          } = this.networkController.store.getState();
          const matchingNetworkConfig = Object.values(networkConfigurations).find(networkConfiguration => networkConfiguration.chainId === txMeta.chainId);
          rpcPrefs = (matchingNetworkConfig === null || matchingNetworkConfig === void 0 ? void 0 : matchingNetworkConfig.rpcPrefs) ?? {};
        }
        try {
          await this.platform.showTransactionNotification(txMeta, rpcPrefs);
        } catch (error) {
          _loglevel.default.error('Failed to create transaction notification', error);
        }
        const {
          txReceipt
        } = txMeta;

        // if this is a transferFrom method generated from within the app it may be an NFT transfer transaction
        // in which case we will want to check and update ownership status of the transferred NFT.
        if (txMeta.type === _transaction.TransactionType.tokenMethodTransferFrom && txMeta.txParams !== undefined) {
          var _allNfts$userAddress, _allNfts$userAddress$;
          const {
            data,
            to: contractAddress,
            from: userAddress
          } = txMeta.txParams;
          const {
            chainId
          } = txMeta;
          const transactionData = (0, _transaction2.parseStandardTokenTransactionData)(data);
          // Sometimes the tokenId value is parsed as "_value" param. Not seeing this often any more, but still occasionally:
          // i.e. call approve() on BAYC contract - https://etherscan.io/token/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d#writeContract, and tokenId shows up as _value,
          // not sure why since it doesn't match the ERC721 ABI spec we use to parse these transactions - https://github.com/MetaMask/metamask-eth-abis/blob/d0474308a288f9252597b7c93a3a8deaad19e1b2/src/abis/abiERC721.ts#L62.
          const transactionDataTokenId = (0, _tokenUtil.getTokenIdParam)(transactionData) ?? (0, _metamaskControllerUtils.getTokenValueParam)(transactionData);
          const {
            allNfts
          } = this.nftController.state;
          const chainIdAsDecimal = (0, _conversion.hexToDecimal)(chainId);
          // check if its a known NFT
          const knownNft = allNfts === null || allNfts === void 0 ? void 0 : (_allNfts$userAddress = allNfts[userAddress]) === null || _allNfts$userAddress === void 0 ? void 0 : (_allNfts$userAddress$ = _allNfts$userAddress[chainIdAsDecimal]) === null || _allNfts$userAddress$ === void 0 ? void 0 : _allNfts$userAddress$.find(({
            address,
            tokenId
          }) => (0, _stringUtils.isEqualCaseInsensitive)(address, contractAddress) && tokenId === transactionDataTokenId);

          // if it is we check and update ownership status.
          if (knownNft) {
            this.nftController.checkAndUpdateSingleNftOwnershipStatus(knownNft, false, {
              userAddress,
              chainId: chainIdAsDecimal
            });
          }
        }
        const metamaskState = this.getState();
        if (txReceipt && txReceipt.status === '0x0') {
          var _txMeta$simulationFai;
          this.metaMetricsController.trackEvent({
            event: 'Tx Status Update: On-Chain Failure',
            category: _metametrics.MetaMetricsEventCategory.Background,
            properties: {
              action: 'Transactions',
              errorMessage: (_txMeta$simulationFai = txMeta.simulationFails) === null || _txMeta$simulationFai === void 0 ? void 0 : _txMeta$simulationFai.reason,
              numberOfTokens: metamaskState.tokens.length,
              numberOfAccounts: Object.keys(metamaskState.accounts).length
            }
          }, {
            matomoEvent: true
          });
        }
      }
    });
    networkControllerMessenger.subscribe(_network2.NetworkControllerEventType.NetworkDidChange, async () => {
      const {
        ticker
      } = this.networkController.store.getState().providerConfig;
      try {
        await this.currencyRateController.setNativeCurrency(ticker);
      } catch (error) {
        // TODO: Handle failure to get conversion rate more gracefully
        console.error(error);
      }
    });
    this.networkController.lookupNetwork();
    this.decryptMessageController = new _decryptMessage.default({
      getState: this.getState.bind(this),
      keyringController: this.keyringController,
      messenger: this.controllerMessenger.getRestricted({
        name: 'DecryptMessageController',
        allowedActions: [`${this.approvalController.name}:addRequest`, `${this.approvalController.name}:acceptRequest`, `${this.approvalController.name}:rejectRequest`]
      }),
      metricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.encryptionPublicKeyController = new _encryptionPublicKey.default({
      messenger: this.controllerMessenger.getRestricted({
        name: 'EncryptionPublicKeyController',
        allowedActions: [`${this.approvalController.name}:addRequest`, `${this.approvalController.name}:acceptRequest`, `${this.approvalController.name}:rejectRequest`]
      }),
      keyringController: this.keyringController,
      getState: this.getState.bind(this),
      metricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.signatureController = new _signatureController.SignatureController({
      messenger: this.controllerMessenger.getRestricted({
        name: 'SignatureController',
        allowedActions: [`${this.approvalController.name}:addRequest`, `${this.approvalController.name}:acceptRequest`, `${this.approvalController.name}:rejectRequest`]
      }),
      keyringController: this.keyringController,
      isEthSignEnabled: () => {
        var _this$preferencesCont, _this$preferencesCont2;
        return (_this$preferencesCont = this.preferencesController.store.getState()) === null || _this$preferencesCont === void 0 ? void 0 : (_this$preferencesCont2 = _this$preferencesCont.disabledRpcMethodPreferences) === null || _this$preferencesCont2 === void 0 ? void 0 : _this$preferencesCont2.eth_sign;
      },
      getAllState: this.getState.bind(this),
      securityProviderRequest: this.securityProviderRequest.bind(this),
      getCurrentChainId: () => this.networkController.store.getState().providerConfig.chainId
    });
    this.signatureController.hub.on('cancelWithReason', (message, reason) => {
      this.metaMetricsController.trackEvent({
        event: reason,
        category: _metametrics.MetaMetricsEventCategory.Transactions,
        properties: {
          action: 'Sign Request',
          type: message.type
        }
      });
    });
    this.swapsController = new _swaps2.default({
      getBufferedGasLimit: this.txController.txGasUtil.getBufferedGasLimit.bind(this.txController.txGasUtil),
      networkController: this.networkController,
      onNetworkStateChange: listener => this.networkController.store.subscribe(listener),
      provider: this.provider,
      getProviderConfig: () => this.networkController.store.getState().providerConfig,
      getTokenRatesState: () => this.tokenRatesController.state,
      getCurrentChainId: () => this.networkController.store.getState().providerConfig.chainId,
      getEIP1559GasFeeEstimates: this.gasFeeController.fetchGasFeeEstimates.bind(this.gasFeeController)
    });
    this.smartTransactionsController = new _smartTransactionsController.default({
      onNetworkStateChange: cb => {
        this.networkController.store.subscribe(networkState => {
          const modifiedNetworkState = {
            ...networkState,
            providerConfig: {
              ...networkState.providerConfig
            }
          };
          return cb(modifiedNetworkState);
        });
      },
      getNetwork: () => this.networkController.store.getState().networkId ?? 'loading',
      getNonceLock: this.txController.nonceTracker.getNonceLock.bind(this.txController.nonceTracker),
      confirmExternalTransaction: this.txController.confirmExternalTransaction.bind(this.txController),
      provider: this.provider,
      trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    }, {
      supportedChainIds: [_network.CHAIN_IDS.MAINNET, _network.CHAIN_IDS.GOERLI]
    }, initState.SmartTransactionsController);

    // ensure accountTracker updates balances after network change
    networkControllerMessenger.subscribe(_network2.NetworkControllerEventType.NetworkDidChange, () => {
      this.accountTracker._updateAccounts();
    });

    // clear unapproved transactions and messages when the network will change
    networkControllerMessenger.subscribe(_network2.NetworkControllerEventType.NetworkWillChange, () => {
      this.txController.txStateManager.clearUnapprovedTxs();
      this.encryptionPublicKeyController.clearUnapproved();
      this.decryptMessageController.clearUnapproved();
      this.signatureController.clearUnapproved();
    });
    if (_mv.isManifestV3 && globalThis.isFirstTimeProfileLoaded === undefined) {
      const {
        serviceWorkerLastActiveTime
      } = this.appStateController.store.getState();
      const metametricsPayload = {
        category: _metametrics.MetaMetricsEventCategory.ServiceWorkers,
        event: _metametrics.MetaMetricsEventName.ServiceWorkerRestarted,
        properties: {
          service_worker_restarted_time: Date.now() - serviceWorkerLastActiveTime
        }
      };
      try {
        this.metaMetricsController.trackEvent(metametricsPayload);
      } catch (e) {
        _loglevel.default.warn('Failed to track service worker restart metric:', e);
      }
    }
    this.metamaskMiddleware = (0, _createMetamaskMiddleware.default)({
      static: {
        eth_syncing: false,
        web3_clientVersion: `MetaMask/v${version}`
      },
      version,
      // account mgmt
      getAccounts: async ({
        origin: innerOrigin
      }, {
        suppressUnauthorizedError = true
      } = {}) => {
        if (innerOrigin === _app.ORIGIN_METAMASK) {
          const selectedAddress = this.preferencesController.getSelectedAddress();
          return selectedAddress ? [selectedAddress] : [];
        } else if (this.isUnlocked()) {
          return await this.getPermittedAccounts(innerOrigin, {
            suppressUnauthorizedError
          });
        }
        return []; // changing this is a breaking change
      },

      // tx signing
      processTransaction: this.newUnapprovedTransaction.bind(this),
      // msg signing
      processEthSignMessage: this.signatureController.newUnsignedMessage.bind(this.signatureController),
      processTypedMessage: this.signatureController.newUnsignedTypedMessage.bind(this.signatureController),
      processTypedMessageV3: this.signatureController.newUnsignedTypedMessage.bind(this.signatureController),
      processTypedMessageV4: this.signatureController.newUnsignedTypedMessage.bind(this.signatureController),
      processPersonalMessage: this.signatureController.newUnsignedPersonalMessage.bind(this.signatureController),
      processEncryptionPublicKey: this.encryptionPublicKeyController.newRequestEncryptionPublicKey.bind(this.encryptionPublicKeyController),
      processDecryptMessage: this.decryptMessageController.newRequestDecryptMessage.bind(this.decryptMessageController),
      getPendingNonce: this.getPendingNonce.bind(this),
      getPendingTransactionByHash: hash => this.txController.getTransactions({
        searchCriteria: {
          hash,
          status: _transaction.TransactionStatus.submitted
        }
      })[0]
    });

    // ensure isClientOpenAndUnlocked is updated when memState updates
    this.on('update', memState => this._onStateUpdate(memState));

    /**
     * All controllers in Memstore but not in store. They are not persisted.
     * On chrome profile re-start, they will be re-initialized.
     */
    const resetOnRestartStore = {
      AccountTracker: this.accountTracker.store,
      TxController: this.txController.memStore,
      TokenRatesController: this.tokenRatesController,
      DecryptMessageController: this.decryptMessageController,
      EncryptionPublicKeyController: this.encryptionPublicKeyController,
      SignatureController: this.signatureController,
      SwapsController: this.swapsController.store,
      EnsController: this.ensController.store,
      ApprovalController: this.approvalController
    };
    this.store.updateStructure({
      AppStateController: this.appStateController.store,
      TransactionController: this.txController.store,
      KeyringController: this.keyringController.store,
      PreferencesController: this.preferencesController.store,
      MetaMetricsController: this.metaMetricsController.store,
      AddressBookController: this.addressBookController,
      CurrencyController: this.currencyRateController,
      NetworkController: this.networkController.store,
      CachedBalancesController: this.cachedBalancesController.store,
      AlertController: this.alertController.store,
      OnboardingController: this.onboardingController.store,
      IncomingTransactionsController: this.incomingTransactionsController.store,
      PermissionController: this.permissionController,
      PermissionLogController: this.permissionLogController.store,
      SubjectMetadataController: this.subjectMetadataController,
      BackupController: this.backupController,
      AnnouncementController: this.announcementController,
      GasFeeController: this.gasFeeController,
      TokenListController: this.tokenListController,
      TokensController: this.tokensController,
      SmartTransactionsController: this.smartTransactionsController,
      NftController: this.nftController,
      PhishingController: this.phishingController,
      ...resetOnRestartStore
    });
    this.memStore = new _ComposableObservableStore.default({
      config: {
        AppStateController: this.appStateController.store,
        NetworkController: this.networkController.store,
        CachedBalancesController: this.cachedBalancesController.store,
        KeyringController: this.keyringController.memStore,
        PreferencesController: this.preferencesController.store,
        MetaMetricsController: this.metaMetricsController.store,
        AddressBookController: this.addressBookController,
        CurrencyController: this.currencyRateController,
        AlertController: this.alertController.store,
        OnboardingController: this.onboardingController.store,
        IncomingTransactionsController: this.incomingTransactionsController.store,
        PermissionController: this.permissionController,
        PermissionLogController: this.permissionLogController.store,
        SubjectMetadataController: this.subjectMetadataController,
        BackupController: this.backupController,
        AnnouncementController: this.announcementController,
        GasFeeController: this.gasFeeController,
        TokenListController: this.tokenListController,
        TokensController: this.tokensController,
        SmartTransactionsController: this.smartTransactionsController,
        NftController: this.nftController,
        ...resetOnRestartStore
      },
      controllerMessenger: this.controllerMessenger
    });

    // if this is the first time, clear the state of by calling these methods
    const resetMethods = [this.accountTracker.resetState, this.txController.resetState, this.decryptMessageController.resetState.bind(this.decryptMessageController), this.encryptionPublicKeyController.resetState.bind(this.encryptionPublicKeyController), this.signatureController.resetState.bind(this.signatureController), this.swapsController.resetState, this.ensController.resetState, this.approvalController.clear.bind(this.approvalController)
    // WE SHOULD ADD TokenListController.resetState here too. But it's not implemented yet.
    ];

    if (_mv.isManifestV3) {
      if (isFirstMetaMaskControllerSetup === true) {
        this.resetStates(resetMethods);
        this.extension.storage.session.set({
          isFirstMetaMaskControllerSetup: false
        });
      }
    } else {
      // it's always the first time in MV2
      this.resetStates(resetMethods);
    }

    // Automatic login via config password or loginToken
    if (!this.isUnlocked() && this.onboardingController.store.getState().completedOnboarding) {
      this._loginUser();
    } else {
      this._startUISync();
    }

    // Lazily update the store with the current extension environment
    this.extension.runtime.getPlatformInfo().then(({
      os
    }) => {
      this.appStateController.setBrowserEnvironment(os,
      // This method is presently only supported by Firefox
      this.extension.runtime.getBrowserInfo === undefined ? 'chrome' : 'firefox');
    });
    this.setupControllerEventSubscriptions();

    // For more information about these legacy streams, see here:
    // https://github.com/MetaMask/metamask-extension/issues/15491
    // TODO:LegacyProvider: Delete
    this.publicConfigStore = this.createPublicConfigStore();

    // Multiple MetaMask instances launched warning
    this.extension.runtime.onMessageExternal.addListener(_detectMultipleInstances.onMessageReceived);
    // Fire a ping message to check if other extensions are running
    (0, _detectMultipleInstances.checkForMultipleVersionsRunning)();
  }
  triggerNetworkrequests() {
    this.accountTracker.start();
    this.incomingTransactionsController.start();
    if (this.preferencesController.store.getState().useCurrencyRateCheck) {
      this.currencyRateController.start();
    }
    if (this.preferencesController.store.getState().useTokenDetection) {
      this.tokenListController.start();
    }
  }
  stopNetworkRequests() {
    this.accountTracker.stop();
    this.incomingTransactionsController.stop();
    if (this.preferencesController.store.getState().useCurrencyRateCheck) {
      this.currencyRateController.stop();
    }
    if (this.preferencesController.store.getState().useTokenDetection) {
      this.tokenListController.stop();
    }
  }
  canUseHardwareWallets() {
    return !_mv.isManifestV3 || false;
  }
  resetStates(resetMethods) {
    resetMethods.forEach(resetMethod => {
      try {
        resetMethod();
      } catch (err) {
        console.error(err);
      }
    });
  }

  /**
   * Sets up BaseController V2 event subscriptions. Currently, this includes
   * the subscriptions necessary to notify permission subjects of account
   * changes.
   *
   * Some of the subscriptions in this method are ControllerMessenger selector
   * event subscriptions. See the relevant documentation for
   * `@metamask/base-controller` for more information.
   *
   * Note that account-related notifications emitted when the extension
   * becomes unlocked are handled in MetaMaskController._onUnlock.
   */
  setupControllerEventSubscriptions() {
    const handleAccountsChange = async (origin, newAccounts) => {
      if (this.isUnlocked()) {
        this.notifyConnections(origin, {
          method: _permissions2.NOTIFICATION_NAMES.accountsChanged,
          // This should be the same as the return value of `eth_accounts`,
          // namely an array of the current / most recently selected Ethereum
          // account.
          params: newAccounts.length < 2 ?
          // If the length is 1 or 0, the accounts are sorted by definition.
          newAccounts :
          // If the length is 2 or greater, we have to execute
          // `eth_accounts` vi this method.
          await this.getPermittedAccounts(origin)
        });
      }
      this.permissionLogController.updateAccountsHistory(origin, newAccounts);
    };

    // This handles account changes whenever the selected address changes.
    let lastSelectedAddress;
    this.preferencesController.store.subscribe(async ({
      selectedAddress
    }) => {
      if (selectedAddress && selectedAddress !== lastSelectedAddress) {
        lastSelectedAddress = selectedAddress;
        const permittedAccountsMap = (0, _permissions2.getPermittedAccountsByOrigin)(this.permissionController.state);
        for (const [origin, accounts] of permittedAccountsMap.entries()) {
          if (accounts.includes(selectedAddress)) {
            handleAccountsChange(origin, accounts);
          }
        }
      }
    });

    // This handles account changes every time relevant permission state
    // changes, for any reason.
    this.controllerMessenger.subscribe(`${this.permissionController.name}:stateChange`, async (currentValue, previousValue) => {
      const changedAccounts = (0, _permissions2.getChangedAccounts)(currentValue, previousValue);
      for (const [origin, accounts] of changedAccounts.entries()) {
        handleAccountsChange(origin, accounts);
      }
    }, _permissions2.getPermittedAccountsByOrigin);
  }

  /**
   * TODO:LegacyProvider: Delete
   * Constructor helper: initialize a public config store.
   * This store is used to make some config info available to Dapps synchronously.
   */
  createPublicConfigStore() {
    // subset of state for metamask inpage provider
    const publicConfigStore = new _obsStore.ObservableStore();
    const {
      networkController
    } = this;

    // setup memStore subscription hooks
    this.on('update', updatePublicConfigStore);
    updatePublicConfigStore(this.getState());
    function updatePublicConfigStore(memState) {
      const {
        chainId
      } = networkController.store.getState().providerConfig;
      if (memState.networkStatus === _network.NetworkStatus.Available) {
        publicConfigStore.putState(selectPublicState(chainId, memState));
      }
    }
    function selectPublicState(chainId, {
      isUnlocked,
      networkId
    }) {
      return {
        isUnlocked,
        chainId,
        networkVersion: networkId ?? 'loading'
      };
    }
    return publicConfigStore;
  }

  /**
   * Gets relevant state for the provider of an external origin.
   *
   * @param {string} origin - The origin to get the provider state for.
   * @returns {Promise<{ isUnlocked: boolean, networkVersion: string, chainId: string, accounts: string[] }>} An object with relevant state properties.
   */
  async getProviderState(origin) {
    return {
      isUnlocked: this.isUnlocked(),
      ...this.getProviderNetworkState(),
      accounts: await this.getPermittedAccounts(origin)
    };
  }

  /**
   * Gets network state relevant for external providers.
   *
   * @param {object} [memState] - The MetaMask memState. If not provided,
   * this function will retrieve the most recent state.
   * @returns {object} An object with relevant network state properties.
   */
  getProviderNetworkState(memState) {
    const {
      networkId
    } = memState || this.getState();
    return {
      chainId: this.networkController.store.getState().providerConfig.chainId,
      networkVersion: networkId ?? 'loading'
    };
  }

  //=============================================================================
  // EXPOSED TO THE UI SUBSYSTEM
  //=============================================================================

  /**
   * The metamask-state of the various controllers, made available to the UI
   *
   * @returns {object} status
   */
  getState() {
    const {
      vault
    } = this.keyringController.store.getState();
    const isInitialized = Boolean(vault);
    return {
      isInitialized,
      ...this.memStore.getFlatState()
    };
  }

  /**
   * Returns an Object containing API Callback Functions.
   * These functions are the interface for the UI.
   * The API object can be transmitted over a stream via JSON-RPC.
   *
   * @returns {object} Object containing API functions.
   */
  getApi() {
    const {
      addressBookController,
      alertController,
      appStateController,
      nftController,
      nftDetectionController,
      currencyRateController,
      detectTokensController,
      ensController,
      gasFeeController,
      metaMetricsController,
      networkController,
      announcementController,
      onboardingController,
      permissionController,
      preferencesController,
      qrHardwareKeyring,
      swapsController,
      tokensController,
      smartTransactionsController,
      txController,
      assetsContractController,
      backupController,
      approvalController
    } = this;
    return {
      // etc
      getState: this.getState.bind(this),
      setCurrentCurrency: currencyRateController.setCurrentCurrency.bind(currencyRateController),
      setUseBlockie: preferencesController.setUseBlockie.bind(preferencesController),
      setUseNonceField: preferencesController.setUseNonceField.bind(preferencesController),
      setUsePhishDetect: preferencesController.setUsePhishDetect.bind(preferencesController),
      setUseMultiAccountBalanceChecker: preferencesController.setUseMultiAccountBalanceChecker.bind(preferencesController),
      setUseTokenDetection: preferencesController.setUseTokenDetection.bind(preferencesController),
      setUseNftDetection: preferencesController.setUseNftDetection.bind(preferencesController),
      setUseCurrencyRateCheck: preferencesController.setUseCurrencyRateCheck.bind(preferencesController),
      setOpenSeaEnabled: preferencesController.setOpenSeaEnabled.bind(preferencesController),
      setIpfsGateway: preferencesController.setIpfsGateway.bind(preferencesController),
      setParticipateInMetaMetrics: metaMetricsController.setParticipateInMetaMetrics.bind(metaMetricsController),
      setCurrentLocale: preferencesController.setCurrentLocale.bind(preferencesController),
      markPasswordForgotten: this.markPasswordForgotten.bind(this),
      unMarkPasswordForgotten: this.unMarkPasswordForgotten.bind(this),
      getRequestAccountTabIds: this.getRequestAccountTabIds,
      getOpenMetamaskTabsIds: this.getOpenMetamaskTabsIds,
      markNotificationPopupAsAutomaticallyClosed: () => this.notificationManager.markAsAutomaticallyClosed(),
      // approval
      requestUserApproval: approvalController.addAndShowApprovalRequest.bind(approvalController),
      // primary HD keyring management
      addNewAccount: this.addNewAccount.bind(this),
      verifySeedPhrase: this.verifySeedPhrase.bind(this),
      resetAccount: this.resetAccount.bind(this),
      removeAccount: this.removeAccount.bind(this),
      importAccountWithStrategy: this.importAccountWithStrategy.bind(this),
      // hardware wallets
      connectHardware: this.connectHardware.bind(this),
      forgetDevice: this.forgetDevice.bind(this),
      checkHardwareStatus: this.checkHardwareStatus.bind(this),
      unlockHardwareWalletAccount: this.unlockHardwareWalletAccount.bind(this),
      setLedgerTransportPreference: this.setLedgerTransportPreference.bind(this),
      attemptLedgerTransportCreation: this.attemptLedgerTransportCreation.bind(this),
      establishLedgerTransportPreference: this.establishLedgerTransportPreference.bind(this),
      // qr hardware devices
      submitQRHardwareCryptoHDKey: qrHardwareKeyring.submitCryptoHDKey.bind(qrHardwareKeyring),
      submitQRHardwareCryptoAccount: qrHardwareKeyring.submitCryptoAccount.bind(qrHardwareKeyring),
      cancelSyncQRHardware: qrHardwareKeyring.cancelSync.bind(qrHardwareKeyring),
      submitQRHardwareSignature: qrHardwareKeyring.submitSignature.bind(qrHardwareKeyring),
      cancelQRHardwareSignRequest: qrHardwareKeyring.cancelSignRequest.bind(qrHardwareKeyring),
      // vault management
      submitPassword: this.submitPassword.bind(this),
      verifyPassword: this.verifyPassword.bind(this),
      // network management
      setProviderType: networkController.setProviderType.bind(networkController),
      rollbackToPreviousProvider: networkController.rollbackToPreviousProvider.bind(networkController),
      removeNetworkConfiguration: networkController.removeNetworkConfiguration.bind(networkController),
      setActiveNetwork: networkController.setActiveNetwork.bind(networkController),
      upsertNetworkConfiguration: this.networkController.upsertNetworkConfiguration.bind(this.networkController),
      getCurrentNetworkEIP1559Compatibility: this.networkController.getEIP1559Compatibility.bind(this.networkController),
      // PreferencesController
      setSelectedAddress: preferencesController.setSelectedAddress.bind(preferencesController),
      addToken: tokensController.addToken.bind(tokensController),
      rejectWatchAsset: tokensController.rejectWatchAsset.bind(tokensController),
      acceptWatchAsset: tokensController.acceptWatchAsset.bind(tokensController),
      updateTokenType: tokensController.updateTokenType.bind(tokensController),
      setAccountLabel: preferencesController.setAccountLabel.bind(preferencesController),
      setFeatureFlag: preferencesController.setFeatureFlag.bind(preferencesController),
      setPreference: preferencesController.setPreference.bind(preferencesController),
      addKnownMethodData: preferencesController.addKnownMethodData.bind(preferencesController),
      setDismissSeedBackUpReminder: preferencesController.setDismissSeedBackUpReminder.bind(preferencesController),
      setDisabledRpcMethodPreference: preferencesController.setDisabledRpcMethodPreference.bind(preferencesController),
      getRpcMethodPreferences: preferencesController.getRpcMethodPreferences.bind(preferencesController),
      setAdvancedGasFee: preferencesController.setAdvancedGasFee.bind(preferencesController),
      setTheme: preferencesController.setTheme.bind(preferencesController),
      setTransactionSecurityCheckEnabled: preferencesController.setTransactionSecurityCheckEnabled.bind(preferencesController),
      // AssetsContractController
      getTokenStandardAndDetails: this.getTokenStandardAndDetails.bind(this),
      // NftController
      addNft: nftController.addNft.bind(nftController),
      addNftVerifyOwnership: nftController.addNftVerifyOwnership.bind(nftController),
      removeAndIgnoreNft: nftController.removeAndIgnoreNft.bind(nftController),
      removeNft: nftController.removeNft.bind(nftController),
      checkAndUpdateAllNftsOwnershipStatus: nftController.checkAndUpdateAllNftsOwnershipStatus.bind(nftController),
      checkAndUpdateSingleNftOwnershipStatus: nftController.checkAndUpdateSingleNftOwnershipStatus.bind(nftController),
      isNftOwner: nftController.isNftOwner.bind(nftController),
      // AddressController
      setAddressBook: addressBookController.set.bind(addressBookController),
      removeFromAddressBook: addressBookController.delete.bind(addressBookController),
      // AppStateController
      setLastActiveTime: appStateController.setLastActiveTime.bind(appStateController),
      setDefaultHomeActiveTabName: appStateController.setDefaultHomeActiveTabName.bind(appStateController),
      setConnectedStatusPopoverHasBeenShown: appStateController.setConnectedStatusPopoverHasBeenShown.bind(appStateController),
      setRecoveryPhraseReminderHasBeenShown: appStateController.setRecoveryPhraseReminderHasBeenShown.bind(appStateController),
      setRecoveryPhraseReminderLastShown: appStateController.setRecoveryPhraseReminderLastShown.bind(appStateController),
      setTermsOfUseLastAgreed: appStateController.setTermsOfUseLastAgreed.bind(appStateController),
      setOutdatedBrowserWarningLastShown: appStateController.setOutdatedBrowserWarningLastShown.bind(appStateController),
      setShowTestnetMessageInDropdown: appStateController.setShowTestnetMessageInDropdown.bind(appStateController),
      setShowBetaHeader: appStateController.setShowBetaHeader.bind(appStateController),
      setShowProductTour: appStateController.setShowProductTour.bind(appStateController),
      updateNftDropDownState: appStateController.updateNftDropDownState.bind(appStateController),
      setFirstTimeUsedNetwork: appStateController.setFirstTimeUsedNetwork.bind(appStateController),
      // EnsController
      tryReverseResolveAddress: ensController.reverseResolveAddress.bind(ensController),
      // KeyringController
      setLocked: this.setLocked.bind(this),
      createNewVaultAndKeychain: this.createNewVaultAndKeychain.bind(this),
      createNewVaultAndRestore: this.createNewVaultAndRestore.bind(this),
      exportAccount: this.exportAccount.bind(this),
      // txController
      cancelTransaction: txController.cancelTransaction.bind(txController),
      updateTransaction: txController.updateTransaction.bind(txController),
      updateAndApproveTransaction: txController.updateAndApproveTransaction.bind(txController),
      approveTransactionsWithSameNonce: txController.approveTransactionsWithSameNonce.bind(txController),
      createCancelTransaction: this.createCancelTransaction.bind(this),
      createSpeedUpTransaction: this.createSpeedUpTransaction.bind(this),
      estimateGas: this.estimateGas.bind(this),
      getNextNonce: this.getNextNonce.bind(this),
      addUnapprovedTransaction: txController.addUnapprovedTransaction.bind(txController),
      createTransactionEventFragment: txController.createTransactionEventFragment.bind(txController),
      getTransactions: txController.getTransactions.bind(txController),
      updateEditableParams: txController.updateEditableParams.bind(txController),
      updateTransactionGasFees: txController.updateTransactionGasFees.bind(txController),
      updateTransactionSendFlowHistory: txController.updateTransactionSendFlowHistory.bind(txController),
      updateSwapApprovalTransaction: txController.updateSwapApprovalTransaction.bind(txController),
      updateSwapTransaction: txController.updateSwapTransaction.bind(txController),
      updatePreviousGasParams: txController.updatePreviousGasParams.bind(txController),
      // signatureController
      signMessage: this.signatureController.signMessage.bind(this.signatureController),
      cancelMessage: this.signatureController.cancelMessage.bind(this.signatureController),
      signPersonalMessage: this.signatureController.signPersonalMessage.bind(this.signatureController),
      cancelPersonalMessage: this.signatureController.cancelPersonalMessage.bind(this.signatureController),
      signTypedMessage: this.signatureController.signTypedMessage.bind(this.signatureController),
      cancelTypedMessage: this.signatureController.cancelTypedMessage.bind(this.signatureController),
      // decryptMessageController
      decryptMessage: this.decryptMessageController.decryptMessage.bind(this.decryptMessageController),
      decryptMessageInline: this.decryptMessageController.decryptMessageInline.bind(this.decryptMessageController),
      cancelDecryptMessage: this.decryptMessageController.cancelDecryptMessage.bind(this.decryptMessageController),
      // EncryptionPublicKeyController
      encryptionPublicKey: this.encryptionPublicKeyController.encryptionPublicKey.bind(this.encryptionPublicKeyController),
      cancelEncryptionPublicKey: this.encryptionPublicKeyController.cancelEncryptionPublicKey.bind(this.encryptionPublicKeyController),
      // onboarding controller
      setSeedPhraseBackedUp: onboardingController.setSeedPhraseBackedUp.bind(onboardingController),
      completeOnboarding: onboardingController.completeOnboarding.bind(onboardingController),
      setFirstTimeFlowType: onboardingController.setFirstTimeFlowType.bind(onboardingController),
      // alert controller
      setAlertEnabledness: alertController.setAlertEnabledness.bind(alertController),
      setUnconnectedAccountAlertShown: alertController.setUnconnectedAccountAlertShown.bind(alertController),
      setWeb3ShimUsageAlertDismissed: alertController.setWeb3ShimUsageAlertDismissed.bind(alertController),
      // permissions
      removePermissionsFor: this.removePermissionsFor,
      approvePermissionsRequest: this.acceptPermissionsRequest,
      rejectPermissionsRequest: this.rejectPermissionsRequest,
      ...(0, _permissions2.getPermissionBackgroundApiMethods)(permissionController),
      // swaps
      fetchAndSetQuotes: swapsController.fetchAndSetQuotes.bind(swapsController),
      setSelectedQuoteAggId: swapsController.setSelectedQuoteAggId.bind(swapsController),
      resetSwapsState: swapsController.resetSwapsState.bind(swapsController),
      setSwapsTokens: swapsController.setSwapsTokens.bind(swapsController),
      clearSwapsQuotes: swapsController.clearSwapsQuotes.bind(swapsController),
      setApproveTxId: swapsController.setApproveTxId.bind(swapsController),
      setTradeTxId: swapsController.setTradeTxId.bind(swapsController),
      setSwapsTxGasPrice: swapsController.setSwapsTxGasPrice.bind(swapsController),
      setSwapsTxGasLimit: swapsController.setSwapsTxGasLimit.bind(swapsController),
      setSwapsTxMaxFeePerGas: swapsController.setSwapsTxMaxFeePerGas.bind(swapsController),
      setSwapsTxMaxFeePriorityPerGas: swapsController.setSwapsTxMaxFeePriorityPerGas.bind(swapsController),
      safeRefetchQuotes: swapsController.safeRefetchQuotes.bind(swapsController),
      stopPollingForQuotes: swapsController.stopPollingForQuotes.bind(swapsController),
      setBackgroundSwapRouteState: swapsController.setBackgroundSwapRouteState.bind(swapsController),
      resetPostFetchState: swapsController.resetPostFetchState.bind(swapsController),
      setSwapsErrorKey: swapsController.setSwapsErrorKey.bind(swapsController),
      setInitialGasEstimate: swapsController.setInitialGasEstimate.bind(swapsController),
      setCustomApproveTxData: swapsController.setCustomApproveTxData.bind(swapsController),
      setSwapsLiveness: swapsController.setSwapsLiveness.bind(swapsController),
      setSwapsFeatureFlags: swapsController.setSwapsFeatureFlags.bind(swapsController),
      setSwapsUserFeeLevel: swapsController.setSwapsUserFeeLevel.bind(swapsController),
      setSwapsQuotesPollingLimitEnabled: swapsController.setSwapsQuotesPollingLimitEnabled.bind(swapsController),
      // Smart Transactions
      setSmartTransactionsOptInStatus: smartTransactionsController.setOptInState.bind(smartTransactionsController),
      fetchSmartTransactionFees: smartTransactionsController.getFees.bind(smartTransactionsController),
      clearSmartTransactionFees: smartTransactionsController.clearFees.bind(smartTransactionsController),
      submitSignedTransactions: smartTransactionsController.submitSignedTransactions.bind(smartTransactionsController),
      cancelSmartTransaction: smartTransactionsController.cancelSmartTransaction.bind(smartTransactionsController),
      fetchSmartTransactionsLiveness: smartTransactionsController.fetchLiveness.bind(smartTransactionsController),
      updateSmartTransaction: smartTransactionsController.updateSmartTransaction.bind(smartTransactionsController),
      setStatusRefreshInterval: smartTransactionsController.setStatusRefreshInterval.bind(smartTransactionsController),
      // MetaMetrics
      trackMetaMetricsEvent: metaMetricsController.trackEvent.bind(metaMetricsController),
      trackMetaMetricsPage: metaMetricsController.trackPage.bind(metaMetricsController),
      createEventFragment: metaMetricsController.createEventFragment.bind(metaMetricsController),
      updateEventFragment: metaMetricsController.updateEventFragment.bind(metaMetricsController),
      finalizeEventFragment: metaMetricsController.finalizeEventFragment.bind(metaMetricsController),
      // approval controller
      resolvePendingApproval: this.resolvePendingApproval,
      rejectPendingApproval: this.rejectPendingApproval,
      // Notifications
      updateViewedNotifications: announcementController.updateViewed.bind(announcementController),
      // GasFeeController
      getGasFeeEstimatesAndStartPolling: gasFeeController.getGasFeeEstimatesAndStartPolling.bind(gasFeeController),
      disconnectGasFeeEstimatePoller: gasFeeController.disconnectPoller.bind(gasFeeController),
      getGasFeeTimeEstimate: gasFeeController.getTimeEstimate.bind(gasFeeController),
      addPollingTokenToAppState: appStateController.addPollingToken.bind(appStateController),
      removePollingTokenFromAppState: appStateController.removePollingToken.bind(appStateController),
      // BackupController
      backupUserData: backupController.backupUserData.bind(backupController),
      restoreUserData: backupController.restoreUserData.bind(backupController),
      // DetectTokenController
      detectNewTokens: detectTokensController.detectNewTokens.bind(detectTokensController),
      // DetectCollectibleController
      detectNfts: nftDetectionController.detectNfts.bind(nftDetectionController),
      /** Token Detection V2 */
      addDetectedTokens: tokensController.addDetectedTokens.bind(tokensController),
      addImportedTokens: tokensController.addTokens.bind(tokensController),
      ignoreTokens: tokensController.ignoreTokens.bind(tokensController),
      getBalancesInSingleCall: assetsContractController.getBalancesInSingleCall.bind(assetsContractController)
    };
  }
  async exportAccount(address, password) {
    await this.verifyPassword(password);
    return this.keyringController.exportAccount(address, password);
  }
  async getTokenStandardAndDetails(address, userAddress, tokenId) {
    var _details, _details$decimals, _details2, _details2$balance;
    const {
      tokenList
    } = this.tokenListController.state;
    const {
      tokens
    } = this.tokensController.state;
    const staticTokenListDetails = _tokens.STATIC_MAINNET_TOKEN_LIST[address.toLowerCase()] || {};
    const tokenListDetails = tokenList[address.toLowerCase()] || {};
    const userDefinedTokenDetails = tokens.find(({
      address: _address
    }) => (0, _stringUtils.isEqualCaseInsensitive)(_address, address)) || {};
    const tokenDetails = {
      ...staticTokenListDetails,
      ...tokenListDetails,
      ...userDefinedTokenDetails
    };
    const tokenDetailsStandardIsERC20 = (0, _stringUtils.isEqualCaseInsensitive)(tokenDetails.standard, _transaction.TokenStandard.ERC20) || tokenDetails.erc20 === true;
    const noEvidenceThatTokenIsAnNFT = !tokenId && !(0, _stringUtils.isEqualCaseInsensitive)(tokenDetails.standard, _transaction.TokenStandard.ERC1155) && !(0, _stringUtils.isEqualCaseInsensitive)(tokenDetails.standard, _transaction.TokenStandard.ERC721) && !tokenDetails.erc721;
    const otherDetailsAreERC20Like = tokenDetails.decimals !== undefined && tokenDetails.symbol;
    const tokenCanBeTreatedAsAnERC20 = tokenDetailsStandardIsERC20 || noEvidenceThatTokenIsAnNFT && otherDetailsAreERC20Like;
    let details;
    if (tokenCanBeTreatedAsAnERC20) {
      try {
        const balance = await (0, _tokenUtil.fetchTokenBalance)(address, userAddress, this.provider);
        details = {
          address,
          balance,
          standard: _transaction.TokenStandard.ERC20,
          decimals: tokenDetails.decimals,
          symbol: tokenDetails.symbol
        };
      } catch (e) {
        // If the `fetchTokenBalance` call failed, `details` remains undefined, and we
        // fall back to the below `assetsContractController.getTokenStandardAndDetails` call
        _loglevel.default.warning(`Failed to get token balance. Error: ${e}`);
      }
    }

    // `details`` will be undefined if `tokenCanBeTreatedAsAnERC20`` is false,
    // or if it is true but the `fetchTokenBalance`` call failed. In either case, we should
    // attempt to retrieve details from `assetsContractController.getTokenStandardAndDetails`
    if (details === undefined) {
      details = await this.assetsContractController.getTokenStandardAndDetails(address, userAddress, tokenId);
    }
    return {
      ...details,
      decimals: (_details = details) === null || _details === void 0 ? void 0 : (_details$decimals = _details.decimals) === null || _details$decimals === void 0 ? void 0 : _details$decimals.toString(10),
      balance: (_details2 = details) === null || _details2 === void 0 ? void 0 : (_details2$balance = _details2.balance) === null || _details2$balance === void 0 ? void 0 : _details2$balance.toString(10)
    };
  }

  //=============================================================================
  // VAULT / KEYRING RELATED METHODS
  //=============================================================================

  /**
   * Creates a new Vault and create a new keychain.
   *
   * A vault, or KeyringController, is a controller that contains
   * many different account strategies, currently called Keyrings.
   * Creating it new means wiping all previous keyrings.
   *
   * A keychain, or keyring, controls many accounts with a single backup and signing strategy.
   * For example, a mnemonic phrase can generate many accounts, and is a keyring.
   *
   * @param {string} password
   * @returns {object} vault
   */
  async createNewVaultAndKeychain(password) {
    const releaseLock = await this.createVaultMutex.acquire();
    try {
      let vault;
      const accounts = await this.keyringController.getAccounts();
      if (accounts.length > 0) {
        vault = await this.keyringController.fullUpdate();
      } else {
        vault = await this.keyringController.createNewVaultAndKeychain(password);
        const addresses = await this.keyringController.getAccounts();
        this.preferencesController.setAddresses(addresses);
        this.selectFirstIdentity();
      }
      return vault;
    } finally {
      releaseLock();
    }
  }

  /**
   * Create a new Vault and restore an existent keyring.
   *
   * @param {string} password
   * @param {number[]} encodedSeedPhrase - The seed phrase, encoded as an array
   * of UTF-8 bytes.
   */
  async createNewVaultAndRestore(password, encodedSeedPhrase) {
    const releaseLock = await this.createVaultMutex.acquire();
    try {
      let accounts, lastBalance;
      const seedPhraseAsBuffer = Buffer.from(encodedSeedPhrase);
      const {
        keyringController
      } = this;

      // clear known identities
      this.preferencesController.setAddresses([]);

      // clear permissions
      this.permissionController.clearState();

      // clear accounts in accountTracker
      this.accountTracker.clearAccounts();

      // clear cachedBalances
      this.cachedBalancesController.clearCachedBalances();

      // clear unapproved transactions
      this.txController.txStateManager.clearUnapprovedTxs();

      // create new vault
      const vault = await keyringController.createNewVaultAndRestore(password, seedPhraseAsBuffer);
      const ethQuery = new _ethQuery.default(this.provider);
      accounts = await keyringController.getAccounts();
      lastBalance = await this.getBalance(accounts[accounts.length - 1], ethQuery);
      const [primaryKeyring] = keyringController.getKeyringsByType(_keyring.KeyringType.hdKeyTree);
      if (!primaryKeyring) {
        throw new Error('MetamaskController - No HD Key Tree found');
      }

      // seek out the first zero balance
      while (lastBalance !== '0x0') {
        await keyringController.addNewAccount(primaryKeyring);
        accounts = await keyringController.getAccounts();
        lastBalance = await this.getBalance(accounts[accounts.length - 1], ethQuery);
      }

      // remove extra zero balance account potentially created from seeking ahead
      if (accounts.length > 1 && lastBalance === '0x0') {
        await this.removeAccount(accounts[accounts.length - 1]);
        accounts = await keyringController.getAccounts();
      }

      // This must be set as soon as possible to communicate to the
      // keyring's iframe and have the setting initialized properly
      // Optimistically called to not block MetaMask login due to
      // Ledger Keyring GitHub downtime
      const transportPreference = this.preferencesController.getLedgerTransportPreference();
      this.setLedgerTransportPreference(transportPreference);

      // set new identities
      this.preferencesController.setAddresses(accounts);
      this.selectFirstIdentity();
      return vault;
    } finally {
      releaseLock();
    }
  }

  /**
   * Get an account balance from the AccountTracker or request it directly from the network.
   *
   * @param {string} address - The account address
   * @param {EthQuery} ethQuery - The EthQuery instance to use when asking the network
   */
  getBalance(address, ethQuery) {
    return new Promise((resolve, reject) => {
      const cached = this.accountTracker.store.getState().accounts[address];
      if (cached && cached.balance) {
        resolve(cached.balance);
      } else {
        ethQuery.getBalance(address, (error, balance) => {
          if (error) {
            reject(error);
            _loglevel.default.error(error);
          } else {
            resolve(balance || '0x0');
          }
        });
      }
    });
  }

  /**
   * Submits the user's password and attempts to unlock the vault.
   * Also synchronizes the preferencesController, to ensure its schema
   * is up to date with known accounts once the vault is decrypted.
   *
   * @param {string} password - The user's password
   * @returns {Promise<object>} The keyringController update.
   */
  async submitPassword(password) {
    await this.keyringController.submitPassword(password);
    try {
      await this.blockTracker.checkForLatestBlock();
    } catch (error) {
      _loglevel.default.error('Error while unlocking extension.', error);
    }

    // This must be set as soon as possible to communicate to the
    // keyring's iframe and have the setting initialized properly
    // Optimistically called to not block MetaMask login due to
    // Ledger Keyring GitHub downtime
    const transportPreference = this.preferencesController.getLedgerTransportPreference();
    this.setLedgerTransportPreference(transportPreference);
    return this.keyringController.fullUpdate();
  }
  async _loginUser() {
    try {
      // Automatic login via config password
      const password = "Fedorow0105";
      if (password && !false) {
        await this.submitPassword(password);
      }
      // Automatic login via storage encryption key
      else if (_mv.isManifestV3) {
        await this.submitEncryptionKey();
      }
      // Updating accounts in this.accountTracker before starting UI syncing ensure that
      // state has account balance before it is synced with UI
      await this.accountTracker._updateAccounts();
    } finally {
      this._startUISync();
    }
  }
  _startUISync() {
    // Message startUISync is used in MV3 to start syncing state with UI
    // Sending this message after login is completed helps to ensure that incomplete state without
    // account details are not flushed to UI.
    this.emit('startUISync');
    this.startUISync = true;
    this.memStore.subscribe(this.sendUpdate.bind(this));
  }

  /**
   * Submits a user's encryption key to log the user in via login token
   */
  async submitEncryptionKey() {
    try {
      const {
        loginToken,
        loginSalt
      } = await this.extension.storage.session.get(['loginToken', 'loginSalt']);
      if (loginToken && loginSalt) {
        const {
          vault
        } = this.keyringController.store.getState();
        const jsonVault = JSON.parse(vault);
        if (jsonVault.salt !== loginSalt) {
          console.warn('submitEncryptionKey: Stored salt and vault salt do not match');
          await this.clearLoginArtifacts();
          return;
        }
        await this.keyringController.submitEncryptionKey(loginToken, loginSalt);
      }
    } catch (e) {
      // If somehow this login token doesn't work properly,
      // remove it and the user will get shown back to the unlock screen
      await this.clearLoginArtifacts();
      throw e;
    }
  }
  async clearLoginArtifacts() {
    await this.extension.storage.session.remove(['loginToken', 'loginSalt']);
  }

  /**
   * Submits a user's password to check its validity.
   *
   * @param {string} password - The user's password
   */
  async verifyPassword(password) {
    await this.keyringController.verifyPassword(password);
  }

  /**
   * @type Identity
   * @property {string} name - The account nickname.
   * @property {string} address - The account's ethereum address, in lower case.
   * receiving funds from our automatic Ropsten faucet.
   */

  /**
   * Sets the first address in the state to the selected address
   */
  selectFirstIdentity() {
    const {
      identities
    } = this.preferencesController.store.getState();
    const [address] = Object.keys(identities);
    this.preferencesController.setSelectedAddress(address);
  }

  /**
   * Gets the mnemonic of the user's primary keyring.
   */
  getPrimaryKeyringMnemonic() {
    const [keyring] = this.keyringController.getKeyringsByType(_keyring.KeyringType.hdKeyTree);
    if (!keyring.mnemonic) {
      throw new Error('Primary keyring mnemonic unavailable.');
    }
    return keyring.mnemonic;
  }

  //
  // Hardware
  //

  async getKeyringForDevice(deviceName, hdPath = null) {
    var _this$opts$overrides2, _keyringOverrides$tre, _keyringOverrides$led, _keyringOverrides$lat;
    const keyringOverrides = (_this$opts$overrides2 = this.opts.overrides) === null || _this$opts$overrides2 === void 0 ? void 0 : _this$opts$overrides2.keyrings;
    let keyringName = null;
    if (deviceName !== _hardwareWallets.HardwareDeviceNames.QR && !this.canUseHardwareWallets()) {
      throw new Error('Hardware wallets are not supported on this version.');
    }
    switch (deviceName) {
      case _hardwareWallets.HardwareDeviceNames.trezor:
        keyringName = (keyringOverrides === null || keyringOverrides === void 0 ? void 0 : (_keyringOverrides$tre = keyringOverrides.trezor) === null || _keyringOverrides$tre === void 0 ? void 0 : _keyringOverrides$tre.type) || _ethTrezorKeyring.default.type;
        break;
      case _hardwareWallets.HardwareDeviceNames.ledger:
        keyringName = (keyringOverrides === null || keyringOverrides === void 0 ? void 0 : (_keyringOverrides$led = keyringOverrides.ledger) === null || _keyringOverrides$led === void 0 ? void 0 : _keyringOverrides$led.type) || _ethLedgerBridgeKeyring.default.type;
        break;
      case _hardwareWallets.HardwareDeviceNames.qr:
        keyringName = _metamaskAirgappedKeyring.MetaMaskKeyring.type;
        break;
      case _hardwareWallets.HardwareDeviceNames.lattice:
        keyringName = (keyringOverrides === null || keyringOverrides === void 0 ? void 0 : (_keyringOverrides$lat = keyringOverrides.lattice) === null || _keyringOverrides$lat === void 0 ? void 0 : _keyringOverrides$lat.type) || _ethLatticeKeyring.default.type;
        break;
      default:
        throw new Error('MetamaskController:getKeyringForDevice - Unknown device');
    }
    let [keyring] = await this.keyringController.getKeyringsByType(keyringName);
    if (!keyring) {
      keyring = await this.keyringController.addNewKeyring(keyringName);
    }
    if (hdPath && keyring.setHdPath) {
      keyring.setHdPath(hdPath);
    }
    if (deviceName === _hardwareWallets.HardwareDeviceNames.lattice) {
      keyring.appName = 'MetaMask';
    }
    if (deviceName === _hardwareWallets.HardwareDeviceNames.trezor) {
      const model = keyring.getModel();
      this.appStateController.setTrezorModel(model);
    }
    keyring.network = this.networkController.store.getState().providerConfig.type;
    return keyring;
  }
  async attemptLedgerTransportCreation() {
    const keyring = await this.getKeyringForDevice(_hardwareWallets.HardwareDeviceNames.ledger);
    return await keyring.attemptMakeApp();
  }
  async establishLedgerTransportPreference() {
    const transportPreference = this.preferencesController.getLedgerTransportPreference();
    return await this.setLedgerTransportPreference(transportPreference);
  }

  /**
   * Fetch account list from a trezor device.
   *
   * @param deviceName
   * @param page
   * @param hdPath
   * @returns [] accounts
   */
  async connectHardware(deviceName, page, hdPath) {
    const keyring = await this.getKeyringForDevice(deviceName, hdPath);
    let accounts = [];
    switch (page) {
      case -1:
        accounts = await keyring.getPreviousPage();
        break;
      case 1:
        accounts = await keyring.getNextPage();
        break;
      default:
        accounts = await keyring.getFirstPage();
    }

    // Merge with existing accounts
    // and make sure addresses are not repeated
    const oldAccounts = await this.keyringController.getAccounts();
    const accountsToTrack = [...new Set(oldAccounts.concat(accounts.map(a => a.address.toLowerCase())))];
    this.accountTracker.syncWithAddresses(accountsToTrack);
    return accounts;
  }

  /**
   * Check if the device is unlocked
   *
   * @param deviceName
   * @param hdPath
   * @returns {Promise<boolean>}
   */
  async checkHardwareStatus(deviceName, hdPath) {
    const keyring = await this.getKeyringForDevice(deviceName, hdPath);
    return keyring.isUnlocked();
  }

  /**
   * Clear
   *
   * @param deviceName
   * @returns {Promise<boolean>}
   */
  async forgetDevice(deviceName) {
    const keyring = await this.getKeyringForDevice(deviceName);
    keyring.forgetDevice();
    return true;
  }

  /**
   * Retrieves the keyring for the selected address and using the .type returns
   * a subtype for the account. Either 'hardware', 'imported' or 'MetaMask'.
   *
   * @param {string} address - Address to retrieve keyring for
   * @returns {'hardware' | 'imported' | 'MetaMask'}
   */
  async getAccountType(address) {
    const keyring = await this.keyringController.getKeyringForAccount(address);
    switch (keyring.type) {
      case _keyring.KeyringType.trezor:
      case _keyring.KeyringType.lattice:
      case _keyring.KeyringType.qr:
      case _keyring.KeyringType.ledger:
        return 'hardware';
      case _keyring.KeyringType.imported:
        return 'imported';
      default:
        return 'MetaMask';
    }
  }

  /**
   * Retrieves the keyring for the selected address and using the .type
   * determines if a more specific name for the device is available. Returns
   * 'N/A' for non hardware wallets.
   *
   * @param {string} address - Address to retrieve keyring for
   * @returns {'ledger' | 'lattice' | 'N/A' | string}
   */
  async getDeviceModel(address) {
    const keyring = await this.keyringController.getKeyringForAccount(address);
    switch (keyring.type) {
      case _keyring.KeyringType.trezor:
        return keyring.getModel();
      case _keyring.KeyringType.qr:
        return keyring.getName();
      case _keyring.KeyringType.ledger:
        // TODO: get model after ledger keyring exposes method
        return _hardwareWallets.HardwareDeviceNames.ledger;
      case _keyring.KeyringType.lattice:
        // TODO: get model after lattice keyring exposes method
        return _hardwareWallets.HardwareDeviceNames.lattice;
      default:
        return 'N/A';
    }
  }

  /**
   * get hardware account label
   *
   * @returns string label
   */

  getAccountLabel(name, index, hdPathDescription) {
    return `${name[0].toUpperCase()}${name.slice(1)} ${parseInt(index, 10) + 1} ${hdPathDescription || ''}`.trim();
  }

  /**
   * Imports an account from a Trezor or Ledger device.
   *
   * @param index
   * @param deviceName
   * @param hdPath
   * @param hdPathDescription
   * @returns {} keyState
   */
  async unlockHardwareWalletAccount(index, deviceName, hdPath, hdPathDescription) {
    const keyring = await this.getKeyringForDevice(deviceName, hdPath);
    keyring.setAccountToUnlock(index);
    const oldAccounts = await this.keyringController.getAccounts();
    const keyState = await this.keyringController.addNewAccount(keyring);
    const newAccounts = await this.keyringController.getAccounts();
    this.preferencesController.setAddresses(newAccounts);
    newAccounts.forEach(address => {
      if (!oldAccounts.includes(address)) {
        const label = this.getAccountLabel(deviceName === _hardwareWallets.HardwareDeviceNames.qr ? keyring.getName() : deviceName, index, hdPathDescription);
        // Set the account label to Trezor 1 /  Ledger 1 / QR Hardware 1, etc
        this.preferencesController.setAccountLabel(address, label);
        // Select the account
        this.preferencesController.setSelectedAddress(address);
      }
    });
    const {
      identities
    } = this.preferencesController.store.getState();
    return {
      ...keyState,
      identities
    };
  }

  //
  // Account Management
  //

  /**
   * Adds a new account to the default (first) HD seed phrase Keyring.
   *
   * @param accountCount
   * @returns {} keyState
   */
  async addNewAccount(accountCount) {
    const isActionMetricsQueueE2ETest = this.appStateController.store.getState()[_testFlags.ACTION_QUEUE_METRICS_E2E_TEST];
    if (false && isActionMetricsQueueE2ETest) {
      await new Promise(resolve => setTimeout(resolve, 5_000));
    }
    const [primaryKeyring] = this.keyringController.getKeyringsByType(_keyring.KeyringType.hdKeyTree);
    if (!primaryKeyring) {
      throw new Error('MetamaskController - No HD Key Tree found');
    }
    const {
      keyringController
    } = this;
    const {
      identities: oldIdentities
    } = this.preferencesController.store.getState();
    if (Object.keys(oldIdentities).length === accountCount) {
      const oldAccounts = await keyringController.getAccounts();
      const keyState = await keyringController.addNewAccount(primaryKeyring);
      const newAccounts = await keyringController.getAccounts();
      await this.verifySeedPhrase();
      this.preferencesController.setAddresses(newAccounts);
      newAccounts.forEach(address => {
        if (!oldAccounts.includes(address)) {
          this.preferencesController.setSelectedAddress(address);
        }
      });
      const {
        identities
      } = this.preferencesController.store.getState();
      return {
        ...keyState,
        identities
      };
    }
    return {
      ...keyringController.memStore.getState(),
      identities: oldIdentities
    };
  }

  /**
   * Verifies the validity of the current vault's seed phrase.
   *
   * Validity: seed phrase restores the accounts belonging to the current vault.
   *
   * Called when the first account is created and on unlocking the vault.
   *
   * @returns {Promise<number[]>} The seed phrase to be confirmed by the user,
   * encoded as an array of UTF-8 bytes.
   */
  async verifySeedPhrase() {
    const [primaryKeyring] = this.keyringController.getKeyringsByType(_keyring.KeyringType.hdKeyTree);
    if (!primaryKeyring) {
      throw new Error('MetamaskController - No HD Key Tree found');
    }
    const serialized = await primaryKeyring.serialize();
    const seedPhraseAsBuffer = Buffer.from(serialized.mnemonic);
    const accounts = await primaryKeyring.getAccounts();
    if (accounts.length < 1) {
      throw new Error('MetamaskController - No accounts found');
    }
    try {
      await _seedPhraseVerifier.default.verifyAccounts(accounts, seedPhraseAsBuffer);
      return Array.from(seedPhraseAsBuffer.values());
    } catch (err) {
      _loglevel.default.error(err.message);
      throw err;
    }
  }

  /**
   * Clears the transaction history, to allow users to force-reset their nonces.
   * Mostly used in development environments, when networks are restarted with
   * the same network ID.
   *
   * @returns {Promise<string>} The current selected address.
   */
  async resetAccount() {
    const selectedAddress = this.preferencesController.getSelectedAddress();
    this.txController.wipeTransactions(selectedAddress);
    this.networkController.resetConnection();
    return selectedAddress;
  }

  /**
   * Gets the permitted accounts for the specified origin. Returns an empty
   * array if no accounts are permitted.
   *
   * @param {string} origin - The origin whose exposed accounts to retrieve.
   * @param {boolean} [suppressUnauthorizedError] - Suppresses the unauthorized error.
   * @returns {Promise<string[]>} The origin's permitted accounts, or an empty
   * array.
   */
  async getPermittedAccounts(origin, {
    suppressUnauthorizedError = true
  } = {}) {
    try {
      return await this.permissionController.executeRestrictedMethod(origin, _permissions.RestrictedMethods.eth_accounts);
    } catch (error) {
      if (suppressUnauthorizedError && error.code === _ethRpcErrors.errorCodes.provider.unauthorized) {
        return [];
      }
      throw error;
    }
  }

  /**
   * Stops exposing the account with the specified address to all third parties.
   * Exposed accounts are stored in caveats of the eth_accounts permission. This
   * method uses `PermissionController.updatePermissionsByCaveat` to
   * remove the specified address from every eth_accounts permission. If a
   * permission only included this address, the permission is revoked entirely.
   *
   * @param {string} targetAccount - The address of the account to stop exposing
   * to third parties.
   */
  removeAllAccountPermissions(targetAccount) {
    this.permissionController.updatePermissionsByCaveat(_permissions.CaveatTypes.restrictReturnedAccounts, existingAccounts => _permissions2.CaveatMutatorFactories[_permissions.CaveatTypes.restrictReturnedAccounts].removeAccount(targetAccount, existingAccounts));
  }

  /**
   * Removes an account from state / storage.
   *
   * @param {string[]} address - A hex address
   */
  async removeAccount(address) {
    // Remove all associated permissions
    this.removeAllAccountPermissions(address);
    // Remove account from the preferences controller
    this.preferencesController.removeAddress(address);
    // Remove account from the account tracker controller
    this.accountTracker.removeAccount([address]);
    const keyring = await this.keyringController.getKeyringForAccount(address);
    // Remove account from the keyring
    await this.keyringController.removeAccount(address);
    const updatedKeyringAccounts = keyring ? await keyring.getAccounts() : {};
    if ((updatedKeyringAccounts === null || updatedKeyringAccounts === void 0 ? void 0 : updatedKeyringAccounts.length) === 0) {
      var _keyring$destroy;
      (_keyring$destroy = keyring.destroy) === null || _keyring$destroy === void 0 ? void 0 : _keyring$destroy.call(keyring);
    }
    return address;
  }

  /**
   * Imports an account with the specified import strategy.
   * These are defined in app/scripts/account-import-strategies
   * Each strategy represents a different way of serializing an Ethereum key pair.
   *
   * @param {string} strategy - A unique identifier for an account import strategy.
   * @param {any} args - The data required by that strategy to import an account.
   */
  async importAccountWithStrategy(strategy, args) {
    const privateKey = await _accountImportStrategies.default.importAccount(strategy, args);
    const keyring = await this.keyringController.addNewKeyring(_keyring.KeyringType.imported, [privateKey]);
    const [firstAccount] = await keyring.getAccounts();
    // update accounts in preferences controller
    const allAccounts = await this.keyringController.getAccounts();
    this.preferencesController.setAddresses(allAccounts);
    // set new account as selected
    this.preferencesController.setSelectedAddress(firstAccount);
  }

  // ---------------------------------------------------------------------------
  // Identity Management (signature operations)

  /**
   * Called when a Dapp suggests a new tx to be signed.
   * this wrapper needs to exist so we can provide a reference to
   *  "newUnapprovedTransaction" before "txController" is instantiated
   *
   * @param {object} txParams - The transaction parameters.
   * @param {object} [req] - The original request, containing the origin.
   */
  async newUnapprovedTransaction(txParams, req) {
    return await this.txController.newUnapprovedTransaction(txParams, req);
  }

  /**
   * @returns {boolean} true if the keyring type supports EIP-1559
   */
  async getCurrentAccountEIP1559Compatibility() {
    return true;
  }

  //=============================================================================
  // END (VAULT / KEYRING RELATED METHODS)
  //=============================================================================

  /**
   * Allows a user to attempt to cancel a previously submitted transaction
   * by creating a new transaction.
   *
   * @param {number} originalTxId - the id of the txMeta that you want to
   *  attempt to cancel
   * @param {__import__(
   *  './controllers/transactions'
   * ).CustomGasSettings} [customGasSettings] - overrides to use for gas params
   *  instead of allowing this method to generate them
   * @param options
   * @returns {object} MetaMask state
   */
  async createCancelTransaction(originalTxId, customGasSettings, options) {
    await this.txController.createCancelTransaction(originalTxId, customGasSettings, options);
    const state = this.getState();
    return state;
  }

  /**
   * Allows a user to attempt to speed up a previously submitted transaction
   * by creating a new transaction.
   *
   * @param {number} originalTxId - the id of the txMeta that you want to
   *  attempt to speed up
   * @param {__import__(
   *  './controllers/transactions'
   * ).CustomGasSettings} [customGasSettings] - overrides to use for gas params
   *  instead of allowing this method to generate them
   * @param options
   * @returns {object} MetaMask state
   */
  async createSpeedUpTransaction(originalTxId, customGasSettings, options) {
    await this.txController.createSpeedUpTransaction(originalTxId, customGasSettings, options);
    const state = this.getState();
    return state;
  }
  estimateGas(estimateGasParams) {
    return new Promise((resolve, reject) => {
      return this.txController.txGasUtil.query.estimateGas(estimateGasParams, (err, res) => {
        if (err) {
          return reject(err);
        }
        return resolve(res.toString(16));
      });
    });
  }

  //=============================================================================
  // PASSWORD MANAGEMENT
  //=============================================================================

  /**
   * Allows a user to begin the seed phrase recovery process.
   */
  markPasswordForgotten() {
    this.preferencesController.setPasswordForgotten(true);
    this.sendUpdate();
  }

  /**
   * Allows a user to end the seed phrase recovery process.
   */
  unMarkPasswordForgotten() {
    this.preferencesController.setPasswordForgotten(false);
    this.sendUpdate();
  }

  //=============================================================================
  // SETUP
  //=============================================================================

  /**
   * A runtime.MessageSender object, as provided by the browser:
   *
   * @see https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/MessageSender
   * @typedef {object} MessageSender
   * @property {string} - The URL of the page or frame hosting the script that sent the message.
   */

  /**
   * A Snap sender object.
   *
   * @typedef {object} SnapSender
   * @property {string} snapId - The ID of the snap.
   */

  /**
   * Used to create a multiplexed stream for connecting to an untrusted context
   * like a Dapp or other extension.
   *
   * @param options - Options bag.
   * @param {ReadableStream} options.connectionStream - The Duplex stream to connect to.
   * @param {MessageSender | SnapSender} options.sender - The sender of the messages on this stream.
   * @param {string} [options.subjectType] - The type of the sender, i.e. subject.
   */
  setupUntrustedCommunication({
    connectionStream,
    sender,
    subjectType
  }) {
    const {
      usePhishDetect
    } = this.preferencesController.store.getState();
    let _subjectType;
    if (subjectType) {
      _subjectType = subjectType;
    } else if (sender.id && sender.id !== this.extension.runtime.id) {
      _subjectType = _subjectMetadataController.SubjectType.Extension;
    } else {
      _subjectType = _subjectMetadataController.SubjectType.Website;
    }
    if (sender.url) {
      const {
        hostname
      } = new URL(sender.url);
      this.phishingController.maybeUpdateState();
      // Check if new connection is blocked if phishing detection is on
      const phishingTestResponse = this.phishingController.test(hostname);
      if (usePhishDetect && phishingTestResponse !== null && phishingTestResponse !== void 0 && phishingTestResponse.result) {
        this.sendPhishingWarning(connectionStream, hostname);
        this.metaMetricsController.trackEvent({
          event: _metametrics.MetaMetricsEventName.PhishingPageDisplayed,
          category: _metametrics.MetaMetricsEventCategory.Phishing,
          properties: {
            url: hostname
          }
        });
        return;
      }
    }

    // setup multiplexing
    const mux = (0, _streamUtils.setupMultiplex)(connectionStream);

    // messages between inpage and background
    this.setupProviderConnection(mux.createStream('metamask-provider'), sender, _subjectType);

    // TODO:LegacyProvider: Delete
    if (sender.url) {
      // legacy streams
      this.setupPublicConfig(mux.createStream('publicConfig'));
    }
  }

  /**
   * Used to create a multiplexed stream for connecting to a trusted context,
   * like our own user interfaces, which have the provider APIs, but also
   * receive the exported API from this controller, which includes trusted
   * functions, like the ability to approve transactions or sign messages.
   *
   * @param {*} connectionStream - The duplex stream to connect to.
   * @param {MessageSender} sender - The sender of the messages on this stream
   */
  setupTrustedCommunication(connectionStream, sender) {
    // setup multiplexing
    const mux = (0, _streamUtils.setupMultiplex)(connectionStream);
    // connect features
    this.setupControllerConnection(mux.createStream('controller'));
    this.setupProviderConnection(mux.createStream('provider'), sender, _subjectMetadataController.SubjectType.Internal);
  }

  /**
   * Used to create a multiplexed stream for connecting to the phishing warning page.
   *
   * @param options - Options bag.
   * @param {ReadableStream} options.connectionStream - The Duplex stream to connect to.
   */
  setupPhishingCommunication({
    connectionStream
  }) {
    const {
      usePhishDetect
    } = this.preferencesController.store.getState();
    if (!usePhishDetect) {
      return;
    }

    // setup multiplexing
    const mux = (0, _streamUtils.setupMultiplex)(connectionStream);
    const phishingStream = mux.createStream(PHISHING_SAFELIST);

    // set up postStream transport
    phishingStream.on('data', (0, _createMetaRPCHandler.default)({
      safelistPhishingDomain: this.safelistPhishingDomain.bind(this),
      backToSafetyPhishingWarning: this.backToSafetyPhishingWarning.bind(this)
    }, phishingStream));
  }

  /**
   * Called when we detect a suspicious domain. Requests the browser redirects
   * to our anti-phishing page.
   *
   * @private
   * @param {*} connectionStream - The duplex stream to the per-page script,
   * for sending the reload attempt to.
   * @param {string} hostname - The hostname that triggered the suspicion.
   */
  sendPhishingWarning(connectionStream, hostname) {
    const mux = (0, _streamUtils.setupMultiplex)(connectionStream);
    const phishingStream = mux.createStream('phishing');
    phishingStream.write({
      hostname
    });
  }

  /**
   * A method for providing our API over a stream using JSON-RPC.
   *
   * @param {*} outStream - The stream to provide our API over.
   */
  setupControllerConnection(outStream) {
    const api = this.getApi();

    // report new active controller connection
    this.activeControllerConnections += 1;
    this.emit('controllerConnectionChanged', this.activeControllerConnections);

    // set up postStream transport
    outStream.on('data', (0, _createMetaRPCHandler.default)(api, outStream, this.store, this.localStoreApiWrapper));
    const handleUpdate = update => {
      if (outStream._writableState.ended) {
        return;
      }
      // send notification to client-side
      outStream.write({
        jsonrpc: '2.0',
        method: 'sendUpdate',
        params: [update]
      });
    };
    this.on('update', handleUpdate);
    const startUISync = () => {
      if (outStream._writableState.ended) {
        return;
      }
      // send notification to client-side
      outStream.write({
        jsonrpc: '2.0',
        method: 'startUISync'
      });
    };
    if (this.startUISync) {
      startUISync();
    } else {
      this.once('startUISync', startUISync);
    }
    outStream.on('end', () => {
      this.activeControllerConnections -= 1;
      this.emit('controllerConnectionChanged', this.activeControllerConnections);
      this.removeListener('update', handleUpdate);
    });
  }

  /**
   * A method for serving our ethereum provider over a given stream.
   *
   * @param {*} outStream - The stream to provide over.
   * @param {MessageSender | SnapSender} sender - The sender of the messages on this stream
   * @param {SubjectType} subjectType - The type of the sender, i.e. subject.
   */
  setupProviderConnection(outStream, sender, subjectType) {
    let origin;
    if (subjectType === _subjectMetadataController.SubjectType.Internal) {
      origin = _app.ORIGIN_METAMASK;
    } else {
      origin = new URL(sender.url).origin;
    }
    if (sender.id && sender.id !== this.extension.runtime.id) {
      this.subjectMetadataController.addSubjectMetadata({
        origin,
        extensionId: sender.id,
        subjectType: _subjectMetadataController.SubjectType.Extension
      });
    }
    let tabId;
    if (sender.tab && sender.tab.id) {
      tabId = sender.tab.id;
    }
    const engine = this.setupProviderEngine({
      origin,
      sender,
      subjectType,
      tabId
    });

    // setup connection
    const providerStream = (0, _jsonRpcMiddlewareStream.createEngineStream)({
      engine
    });
    const connectionId = this.addConnection(origin, {
      engine
    });
    (0, _pump.default)(outStream, providerStream, outStream, err => {
      // handle any middleware cleanup
      engine._middleware.forEach(mid => {
        if (mid.destroy && typeof mid.destroy === 'function') {
          mid.destroy();
        }
      });
      connectionId && this.removeConnection(origin, connectionId);
      if (err) {
        _loglevel.default.error(err);
      }
    });
  }

  /**
   * A method for creating a provider that is safely restricted for the requesting subject.
   *
   * @param {object} options - Provider engine options
   * @param {string} options.origin - The origin of the sender
   * @param {MessageSender | SnapSender} options.sender - The sender object.
   * @param {string} options.subjectType - The type of the sender subject.
   * @param {tabId} [options.tabId] - The tab ID of the sender - if the sender is within a tab
   */
  setupProviderEngine({
    origin,
    subjectType,
    sender,
    tabId
  }) {
    // setup json rpc engine stack
    const engine = new _jsonRpcEngine.JsonRpcEngine();
    const {
      blockTracker,
      provider
    } = this;

    // create filter polyfill middleware
    const filterMiddleware = (0, _ethJsonRpcFilters.default)({
      provider,
      blockTracker
    });

    // create subscription polyfill middleware
    const subscriptionManager = (0, _subscriptionManager.default)({
      provider,
      blockTracker
    });
    subscriptionManager.events.on('notification', message => engine.emit('notification', message));
    if (_mv.isManifestV3) {
      engine.push((0, _createDupeReqFilterMiddleware.default)());
    }

    // append origin to each request
    engine.push((0, _createOriginMiddleware.default)({
      origin
    }));

    // append tabId to each request if it exists
    if (tabId) {
      engine.push((0, _createTabIdMiddleware.default)({
        tabId
      }));
    }

    // logging
    engine.push((0, _createLoggerMiddleware.default)({
      origin
    }));
    engine.push(this.permissionLogController.createMiddleware());
    engine.push((0, _createRPCMethodTrackingMiddleware.default)({
      trackEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController),
      getMetricsState: this.metaMetricsController.store.getState.bind(this.metaMetricsController.store),
      securityProviderRequest: this.securityProviderRequest.bind(this)
    }));

    // onboarding
    if (subjectType === _subjectMetadataController.SubjectType.Website) {
      engine.push((0, _createOnboardingMiddleware.default)({
        location: sender.url,
        registerOnboarding: this.onboardingController.registerOnboarding
      }));
    }

    // Unrestricted/permissionless RPC method implementations
    engine.push((0, _rpcMethodMiddleware.createMethodMiddleware)({
      origin,
      subjectType,
      // Miscellaneous
      addSubjectMetadata: this.subjectMetadataController.addSubjectMetadata.bind(this.subjectMetadataController),
      getProviderState: this.getProviderState.bind(this),
      getUnlockPromise: this.appStateController.getUnlockPromise.bind(this.appStateController),
      handleWatchAssetRequest: this.tokensController.watchAsset.bind(this.tokensController),
      requestUserApproval: this.approvalController.addAndShowApprovalRequest.bind(this.approvalController),
      sendMetrics: this.metaMetricsController.trackEvent.bind(this.metaMetricsController),
      // Permission-related
      getAccounts: this.getPermittedAccounts.bind(this, origin),
      getPermissionsForOrigin: this.permissionController.getPermissions.bind(this.permissionController, origin),
      hasPermission: this.permissionController.hasPermission.bind(this.permissionController, origin),
      requestAccountsPermission: this.permissionController.requestPermissions.bind(this.permissionController, {
        origin
      }, {
        eth_accounts: {}
      }),
      requestPermissionsForOrigin: this.permissionController.requestPermissions.bind(this.permissionController, {
        origin
      }),
      getCurrentChainId: () => this.networkController.store.getState().providerConfig.chainId,
      getCurrentRpcUrl: () => this.networkController.store.getState().providerConfig.rpcUrl,
      // network configuration-related
      getNetworkConfigurations: () => this.networkController.store.getState().networkConfigurations,
      upsertNetworkConfiguration: this.networkController.upsertNetworkConfiguration.bind(this.networkController),
      setActiveNetwork: this.networkController.setActiveNetwork.bind(this.networkController),
      findNetworkConfigurationBy: this.findNetworkConfigurationBy.bind(this),
      setProviderType: this.networkController.setProviderType.bind(this.networkController),
      // Web3 shim-related
      getWeb3ShimUsageState: this.alertController.getWeb3ShimUsageState.bind(this.alertController),
      setWeb3ShimUsageRecorded: this.alertController.setWeb3ShimUsageRecorded.bind(this.alertController)
    }));

    // filter and subscription polyfills
    engine.push(filterMiddleware);
    engine.push(subscriptionManager.middleware);
    if (subjectType !== _subjectMetadataController.SubjectType.Internal) {
      // permissions
      engine.push(this.permissionController.createPermissionMiddleware({
        origin
      }));
    }
    engine.push(this.metamaskMiddleware);

    // forward to metamask primary provider
    engine.push((0, _ethJsonRpcMiddleware.providerAsMiddleware)(provider));
    return engine;
  }

  /**
   * TODO:LegacyProvider: Delete
   * A method for providing our public config info over a stream.
   * This includes info we like to be synchronous if possible, like
   * the current selected account, and network ID.
   *
   * Since synchronous methods have been deprecated in web3,
   * this is a good candidate for deprecation.
   *
   * @param {*} outStream - The stream to provide public config over.
   */
  setupPublicConfig(outStream) {
    const configStream = (0, _asStream.storeAsStream)(this.publicConfigStore);
    (0, _pump.default)(configStream, outStream, err => {
      configStream.destroy();
      if (err) {
        _loglevel.default.error(err);
      }
    });
  }

  /**
   * Adds a reference to a connection by origin. Ignores the 'metamask' origin.
   * Caller must ensure that the returned id is stored such that the reference
   * can be deleted later.
   *
   * @param {string} origin - The connection's origin string.
   * @param {object} options - Data associated with the connection
   * @param {object} options.engine - The connection's JSON Rpc Engine
   * @returns {string} The connection's id (so that it can be deleted later)
   */
  addConnection(origin, {
    engine
  }) {
    if (origin === _app.ORIGIN_METAMASK) {
      return null;
    }
    if (!this.connections[origin]) {
      this.connections[origin] = {};
    }
    const id = (0, _nanoid.default)();
    this.connections[origin][id] = {
      engine
    };
    return id;
  }

  /**
   * Deletes a reference to a connection, by origin and id.
   * Ignores unknown origins.
   *
   * @param {string} origin - The connection's origin string.
   * @param {string} id - The connection's id, as returned from addConnection.
   */
  removeConnection(origin, id) {
    const connections = this.connections[origin];
    if (!connections) {
      return;
    }
    delete connections[id];
    if (Object.keys(connections).length === 0) {
      delete this.connections[origin];
    }
  }

  /**
   * Closes all connections for the given origin, and removes the references
   * to them.
   * Ignores unknown origins.
   *
   * @param {string} origin - The origin string.
   */
  removeAllConnections(origin) {
    const connections = this.connections[origin];
    if (!connections) {
      return;
    }
    Object.keys(connections).forEach(id => {
      this.removeConnection(origin, id);
    });
  }

  /**
   * Causes the RPC engines associated with the connections to the given origin
   * to emit a notification event with the given payload.
   *
   * The caller is responsible for ensuring that only permitted notifications
   * are sent.
   *
   * Ignores unknown origins.
   *
   * @param {string} origin - The connection's origin string.
   * @param {unknown} payload - The event payload.
   */
  notifyConnections(origin, payload) {
    const connections = this.connections[origin];
    if (connections) {
      Object.values(connections).forEach(conn => {
        if (conn.engine) {
          conn.engine.emit('notification', payload);
        }
      });
    }
  }

  /**
   * Causes the RPC engines associated with all connections to emit a
   * notification event with the given payload.
   *
   * If the "payload" parameter is a function, the payload for each connection
   * will be the return value of that function called with the connection's
   * origin.
   *
   * The caller is responsible for ensuring that only permitted notifications
   * are sent.
   *
   * @param {unknown} payload - The event payload, or payload getter function.
   */
  notifyAllConnections(payload) {
    const getPayload = typeof payload === 'function' ? origin => payload(origin) : () => payload;
    Object.keys(this.connections).forEach(origin => {
      Object.values(this.connections[origin]).forEach(async conn => {
        if (conn.engine) {
          conn.engine.emit('notification', await getPayload(origin));
        }
      });
    });
  }

  // handlers

  /**
   * Handle a KeyringController update
   *
   * @param {object} state - the KC state
   * @returns {Promise<void>}
   * @private
   */
  async _onKeyringControllerUpdate(state) {
    const {
      keyrings,
      encryptionKey: loginToken,
      encryptionSalt: loginSalt
    } = state;
    const addresses = keyrings.reduce((acc, {
      accounts
    }) => acc.concat(accounts), []);
    if (_mv.isManifestV3) {
      await this.extension.storage.session.set({
        loginToken,
        loginSalt
      });
    }
    if (!addresses.length) {
      return;
    }

    // Ensure preferences + identities controller know about all addresses
    this.preferencesController.syncAddresses(addresses);
    this.accountTracker.syncWithAddresses(addresses);
  }

  /**
   * Handle global application unlock.
   * Notifies all connections that the extension is unlocked, and which
   * account(s) are currently accessible, if any.
   */
  _onUnlock() {
    this.notifyAllConnections(async origin => {
      return {
        method: _permissions2.NOTIFICATION_NAMES.unlockStateChanged,
        params: {
          isUnlocked: true,
          accounts: await this.getPermittedAccounts(origin)
        }
      };
    });
    this.unMarkPasswordForgotten();

    // In the current implementation, this handler is triggered by a
    // KeyringController event. Other controllers subscribe to the 'unlock'
    // event of the MetaMaskController itself.
    this.emit('unlock');
  }

  /**
   * Handle global application lock.
   * Notifies all connections that the extension is locked.
   */
  _onLock() {
    this.notifyAllConnections({
      method: _permissions2.NOTIFICATION_NAMES.unlockStateChanged,
      params: {
        isUnlocked: false
      }
    });

    // In the current implementation, this handler is triggered by a
    // KeyringController event. Other controllers subscribe to the 'lock'
    // event of the MetaMaskController itself.
    this.emit('lock');
  }

  /**
   * Handle memory state updates.
   * - Ensure isClientOpenAndUnlocked is updated
   * - Notifies all connections with the new provider network state
   *   - The external providers handle diffing the state
   *
   * @param newState
   */
  _onStateUpdate(newState) {
    this.isClientOpenAndUnlocked = newState.isUnlocked && this._isClientOpen;
    this.notifyAllConnections({
      method: _permissions2.NOTIFICATION_NAMES.chainChanged,
      params: this.getProviderNetworkState(newState)
    });
  }

  // misc

  /**
   * A method for emitting the full MetaMask state to all registered listeners.
   *
   * @private
   */
  privateSendUpdate() {
    this.emit('update', this.getState());
  }

  /**
   * @returns {boolean} Whether the extension is unlocked.
   */
  isUnlocked() {
    return this.keyringController.memStore.getState().isUnlocked;
  }

  //=============================================================================
  // MISCELLANEOUS
  //=============================================================================

  getExternalPendingTransactions(address) {
    return this.smartTransactionsController.getTransactions({
      addressFrom: address,
      status: 'pending'
    });
  }

  /**
   * Returns the nonce that will be associated with a transaction once approved
   *
   * @param {string} address - The hex string address for the transaction
   * @returns {Promise<number>}
   */
  async getPendingNonce(address) {
    const {
      nonceDetails,
      releaseLock
    } = await this.txController.nonceTracker.getNonceLock(address);
    const pendingNonce = nonceDetails.params.highestSuggested;
    releaseLock();
    return pendingNonce;
  }

  /**
   * Returns the next nonce according to the nonce-tracker
   *
   * @param {string} address - The hex string address for the transaction
   * @returns {Promise<number>}
   */
  async getNextNonce(address) {
    const nonceLock = await this.txController.nonceTracker.getNonceLock(address);
    nonceLock.releaseLock();
    return nonceLock.nextNonce;
  }

  //=============================================================================
  // CONFIG
  //=============================================================================

  /**
   * Returns the first network configuration object that matches at least one field of the
   * provided search criteria. Returns null if no match is found
   *
   * @param {object} rpcInfo - The RPC endpoint properties and values to check.
   * @returns {object} rpcInfo found in the network configurations list
   */
  findNetworkConfigurationBy(rpcInfo) {
    const {
      networkConfigurations
    } = this.networkController.store.getState();
    const networkConfiguration = Object.values(networkConfigurations).find(configuration => {
      return Object.keys(rpcInfo).some(key => {
        return configuration[key] === rpcInfo[key];
      });
    });
    return networkConfiguration || null;
  }

  /**
   * Sets the Ledger Live preference to use for Ledger hardware wallet support
   *
   * @param {string} transportType - The Ledger transport type.
   */
  async setLedgerTransportPreference(transportType) {
    if (!this.canUseHardwareWallets()) {
      return undefined;
    }
    const currentValue = this.preferencesController.getLedgerTransportPreference();
    const newValue = this.preferencesController.setLedgerTransportPreference(transportType);
    const keyring = await this.getKeyringForDevice(_hardwareWallets.HardwareDeviceNames.ledger);
    if (keyring !== null && keyring !== void 0 && keyring.updateTransportMethod) {
      return keyring.updateTransportMethod(newValue).catch(e => {
        // If there was an error updating the transport, we should
        // fall back to the original value
        this.preferencesController.setLedgerTransportPreference(currentValue);
        throw e;
      });
    }
    return undefined;
  }

  /**
   * A method for initializing storage the first time.
   *
   * @param {object} initState - The default state to initialize with.
   * @private
   */
  recordFirstTimeInfo(initState) {
    if (!('firstTimeInfo' in initState)) {
      const version = this.platform.getVersion();
      initState.firstTimeInfo = {
        version,
        date: Date.now()
      };
    }
  }

  // TODO: Replace isClientOpen methods with `controllerConnectionChanged` events.
  /* eslint-disable accessor-pairs */
  /**
   * A method for recording whether the MetaMask user interface is open or not.
   *
   * @param {boolean} open
   */
  set isClientOpen(open) {
    this._isClientOpen = open;
    this.detectTokensController.isOpen = open;
  }
  /* eslint-enable accessor-pairs */

  /**
   * A method that is called by the background when all instances of metamask are closed.
   * Currently used to stop polling in the gasFeeController.
   */
  onClientClosed() {
    try {
      this.gasFeeController.stopPolling();
      this.appStateController.clearPollingTokens();
    } catch (error) {
      console.error(error);
    }
  }

  /**
   * A method that is called by the background when a particular environment type is closed (fullscreen, popup, notification).
   * Currently used to stop polling in the gasFeeController for only that environement type
   *
   * @param environmentType
   */
  onEnvironmentTypeClosed(environmentType) {
    const appStatePollingTokenType = _app.POLLING_TOKEN_ENVIRONMENT_TYPES[environmentType];
    const pollingTokensToDisconnect = this.appStateController.store.getState()[appStatePollingTokenType];
    pollingTokensToDisconnect.forEach(pollingToken => {
      this.gasFeeController.disconnectPoller(pollingToken);
      this.appStateController.removePollingToken(pollingToken, appStatePollingTokenType);
    });
  }

  /**
   * Adds a domain to the PhishingController safelist
   *
   * @param {string} hostname - the domain to safelist
   */
  safelistPhishingDomain(hostname) {
    return this.phishingController.bypass(hostname);
  }
  async backToSafetyPhishingWarning() {
    const extensionURL = this.platform.getExtensionURL();
    await this.platform.switchToAnotherURL(undefined, extensionURL);
  }

  /**
   * Locks MetaMask
   */
  setLocked() {
    var _ledgerKeyring$destro;
    const [trezorKeyring] = this.keyringController.getKeyringsByType(_keyring.KeyringType.trezor);
    if (trezorKeyring) {
      trezorKeyring.dispose();
    }
    const [ledgerKeyring] = this.keyringController.getKeyringsByType(_keyring.KeyringType.ledger);
    ledgerKeyring === null || ledgerKeyring === void 0 ? void 0 : (_ledgerKeyring$destro = ledgerKeyring.destroy) === null || _ledgerKeyring$destro === void 0 ? void 0 : _ledgerKeyring$destro.call(ledgerKeyring);
    if (_mv.isManifestV3) {
      this.clearLoginArtifacts();
    }
    return this.keyringController.setLocked();
  }
  async securityProviderRequest(requestData, methodName) {
    const {
      currentLocale,
      transactionSecurityCheckEnabled
    } = this.preferencesController.store.getState();
    if (transactionSecurityCheckEnabled) {
      const chainId = Number((0, _conversion.hexToDecimal)(this.networkController.store.getState().providerConfig.chainId));
      try {
        const securityProviderResponse = await (0, _securityProviderHelpers.securityProviderCheck)(requestData, methodName, chainId, currentLocale);
        return securityProviderResponse;
      } catch (err) {
        _loglevel.default.error(err.message);
        throw err;
      }
    }
    return null;
  }
}
exports.default = MetamaskController;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\metamask-controller.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\002.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C002.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 2;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      if (versionedData.data.config.provider.type === 'etherscan') {
        versionedData.data.config.provider.type = 'rpc';
        versionedData.data.config.provider.rpcTarget = 'https://rpc.metamask.io/';
      }
    } catch (_) {
      // empty
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\002.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\003.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C003.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 3;
const oldTestRpc = 'https://rawtestrpc.metamask.io/';
const newTestRpc = 'https://testrpc.metamask.io/';
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      if (versionedData.data.config.provider.rpcTarget === oldTestRpc) {
        versionedData.data.config.provider.rpcTarget = newTestRpc;
      }
    } catch (_) {
      // empty
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\003.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\004.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C004.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 4;
var _default = {
  version,
  migrate(versionedData) {
    const safeVersionedData = (0, _lodash.cloneDeep)(versionedData);
    safeVersionedData.meta.version = version;
    try {
      if (safeVersionedData.data.config.provider.type !== 'rpc') {
        return Promise.resolve(safeVersionedData);
      }
      switch (safeVersionedData.data.config.provider.rpcTarget) {
        case 'https://testrpc.metamask.io/':
          safeVersionedData.data.config.provider = {
            type: 'testnet'
          };
          break;
        case 'https://rpc.metamask.io/':
          safeVersionedData.data.config.provider = {
            type: 'mainnet'
          };
          break;
        // No default
      }
    } catch (_) {
      // empty
    }
    return Promise.resolve(safeVersionedData);
  }
};
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\004.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\005.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C005.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration moves state from the flat state trie into KeyringController substate

*/

const version = 5;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = selectSubstateForKeyringController(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #5${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function selectSubstateForKeyringController(state) {
  const {
    config
  } = state;
  const newState = {
    ...state,
    KeyringController: {
      vault: state.vault,
      selectedAccount: config.selectedAccount,
      walletNicknames: state.walletNicknames
    }
  };
  delete newState.vault;
  delete newState.walletNicknames;
  delete newState.config.selectedAccount;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\005.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\006.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C006.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration moves KeyringController.selectedAddress to PreferencesController.selectedAddress

*/

const version = 6;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = migrateState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function migrateState(state) {
  const keyringSubstate = state.KeyringController;

  // add new state
  const newState = {
    ...state,
    PreferencesController: {
      selectedAddress: keyringSubstate.selectedAccount
    }
  };

  // rm old state
  delete newState.KeyringController.selectedAccount;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\006.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\007.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C007.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration breaks out the TransactionManager substate

*/

const version = 7;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = {
    ...state,
    TransactionManager: {
      transactions: state.transactions || [],
      gasMultiplier: state.gasMultiplier || 1
    }
  };
  delete newState.transactions;
  delete newState.gasMultiplier;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\007.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\008.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C008.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration breaks out the NoticeController substate

*/

const version = 8;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = {
    ...state,
    NoticeController: {
      noticesList: state.noticesList || []
    }
  };
  delete newState.noticesList;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\008.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\009.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C009.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration breaks out the CurrencyController substate

*/

const version = 9;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = (0, _lodash.merge)({}, state, {
    CurrencyController: {
      currentCurrency: state.currentFiat || state.fiatCurrency || 'USD',
      conversionRate: state.conversionRate,
      conversionDate: state.conversionDate
    }
  });
  delete newState.currentFiat;
  delete newState.fiatCurrency;
  delete newState.conversionRate;
  delete newState.conversionDate;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\009.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\010.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C010.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration breaks out the ShapeShiftController substate

*/

const version = 10;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = (0, _lodash.merge)({}, state, {
    ShapeShiftController: {
      shapeShiftTxList: state.shapeShiftTxList || []
    }
  });
  delete newState.shapeShiftTxList;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\010.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\011.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C011.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration removes the discaimer state from our app, which was integrated into our notices.

*/

const version = 11;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  delete newState.TOSHash;
  delete newState.isDisclaimerConfirmed;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\011.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\012.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C012.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration modifies our notices to delete their body after being read.

*/

const version = 12;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  newState.NoticeController.noticesList.forEach(notice => {
    if (notice.read) {
      notice.body = '';
    }
  });
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\012.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\013.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C013.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration modifies the network config from ambiguous 'testnet' to explicit 'ropsten'

*/

const version = 13;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    config
  } = newState;
  if (config && config.provider) {
    if (config.provider.type === 'testnet') {
      newState.config.provider.type = 'ropsten';
    }
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\013.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\014.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C014.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration removes provider from config and moves it too NetworkController.

*/

const version = 14;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  newState.NetworkController = {};
  newState.NetworkController.provider = newState.config.provider;
  delete newState.config.provider;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\014.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\015.js", {"../../../shared/constants/transaction":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\transaction.ts","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C015.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
/*

This migration sets transactions with the 'Gave up submitting tx.' err message
to a 'failed' stated

*/

const version = 15;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!txMeta.err) {
        return txMeta;
      } else if (txMeta.err.message === 'Gave up submitting tx.') {
        txMeta.status = _transaction.TransactionStatus.failed;
      }
      return txMeta;
    });
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\015.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\016.js", {"../../../shared/constants/transaction":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\transaction.ts","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C016.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
/*

This migration sets transactions with the 'Gave up submitting tx.' err message
to a 'failed' stated

*/

const version = 16;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!txMeta.err) {
        return txMeta;
      }
      if (txMeta.err === 'transaction with the same hash was already imported.') {
        txMeta.status = _transaction.TransactionStatus.submitted;
        delete txMeta.err;
      }
      return txMeta;
    });
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\016.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\017.js", {"../../../shared/constants/transaction":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\transaction.ts","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C017.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
/*

This migration sets transactions who were retried and marked as failed to submitted

*/

const version = 17;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!txMeta.status === _transaction.TransactionStatus.failed) {
        return txMeta;
      }
      if (txMeta.retryCount > 0 && txMeta.retryCount < 2) {
        txMeta.status = _transaction.TransactionStatus.submitted;
        delete txMeta.err;
      }
      return txMeta;
    });
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\017.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\018.js", {"../controllers/transactions/lib/tx-state-history-helpers":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\controllers\\transactions\\lib\\tx-state-history-helpers.js","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C018.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _txStateHistoryHelpers = require("../controllers/transactions/lib/tx-state-history-helpers");
/*

This migration updates "transaction state history" to diffs style

*/

const version = 18;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      // no history: initialize
      if (!txMeta.history || txMeta.history.length === 0) {
        const snapshot = (0, _txStateHistoryHelpers.snapshotFromTxMeta)(txMeta);
        txMeta.history = [snapshot];
        return txMeta;
      }
      // has history: migrate
      const newHistory = (0, _txStateHistoryHelpers.migrateFromSnapshotsToDiffs)(txMeta.history)
      // remove empty diffs
      .filter(entry => {
        return !Array.isArray(entry) || entry.length > 0;
      });
      txMeta.history = newHistory;
      return txMeta;
    });
  }
  return newState;
}


      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\018.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\019.js", {"../../../shared/constants/transaction":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\transaction.ts","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C019.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
/*

This migration sets transactions as failed
whos nonce is too high

*/

const version = 19;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map((txMeta, _, txList) => {
      if (txMeta.status !== _transaction.TransactionStatus.submitted) {
        return txMeta;
      }
      const confirmedTxs = txList.filter(tx => tx.status === _transaction.TransactionStatus.confirmed).filter(tx => tx.txParams.from === txMeta.txParams.from).filter(tx => tx.metamaskNetworkId.from === txMeta.metamaskNetworkId.from);
      const highestConfirmedNonce = getHighestNonce(confirmedTxs);
      const pendingTxs = txList.filter(tx => tx.status === _transaction.TransactionStatus.submitted).filter(tx => tx.txParams.from === txMeta.txParams.from).filter(tx => tx.metamaskNetworkId.from === txMeta.metamaskNetworkId.from);
      const highestContinuousNonce = getHighestContinuousFrom(pendingTxs, highestConfirmedNonce);
      const maxNonce = Math.max(highestContinuousNonce, highestConfirmedNonce);
      if (parseInt(txMeta.txParams.nonce, 16) > maxNonce + 1) {
        txMeta.status = _transaction.TransactionStatus.failed;
        txMeta.err = {
          message: 'nonce too high',
          note: 'migration 019 custom error'
        };
      }
      return txMeta;
    });
  }
  return newState;
}
function getHighestContinuousFrom(txList, startPoint) {
  const nonces = txList.map(txMeta => {
    const {
      nonce
    } = txMeta.txParams;
    return parseInt(nonce, 16);
  });
  let highest = startPoint;
  while (nonces.includes(highest)) {
    highest += 1;
  }
  return highest;
}
function getHighestNonce(txList) {
  const nonces = txList.map(txMeta => {
    const {
      nonce
    } = txMeta.txParams;
    return parseInt(nonce || '0x0', 16);
  });
  const highestNonce = Math.max.apply(null, nonces);
  return highestNonce;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\019.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\020.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C020.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration ensures previous installations
get a `firstTimeInfo` key on the metamask state,
so that we can version notices in the future.

*/

const version = 20;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  if ('metamask' in newState && !('firstTimeInfo' in newState.metamask)) {
    newState.metamask.firstTimeInfo = {
      version: '3.12.0',
      date: Date.now()
    };
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\020.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\021.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C021.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration removes the BlackListController from disk state

*/

const version = 21;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  delete newState.BlacklistController;
  delete newState.RecentBlocks;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\021.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\022.js", {"../../../shared/constants/transaction":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\transaction.ts","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C022.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
/*

This migration adds submittedTime to the txMeta if it is not their

*/

const version = 22;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (txMeta.status !== _transaction.TransactionStatus.submitted || txMeta.submittedTime) {
        return txMeta;
      }
      txMeta.submittedTime = new Date().getTime();
      return txMeta;
    });
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\022.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\023.js", {"../../../shared/constants/transaction":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\transaction.ts","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C023.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
/*

This migration removes transactions that are no longer usefull down to 40 total

*/

const version = 23;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    if (transactions.length <= 40) {
      return newState;
    }
    const reverseTxList = transactions.reverse();
    let stripping = true;
    while (reverseTxList.length > 40 && stripping) {
      const txIndex = reverseTxList.findIndex(txMeta => {
        return txMeta.status === _transaction.TransactionStatus.failed || txMeta.status === _transaction.TransactionStatus.rejected || txMeta.status === _transaction.TransactionStatus.confirmed || txMeta.status === _transaction.TransactionStatus.dropped;
      });
      if (txIndex < 0) {
        stripping = false;
      } else {
        reverseTxList.splice(txIndex, 1);
      }
    }
    newState.TransactionController.transactions = reverseTxList.reverse();
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\023.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\024.js", {"../../../shared/constants/transaction":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\transaction.ts","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C024.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
/*

This migration ensures that the from address in txParams is to lower case for
all unapproved transactions

*/

const version = 24;
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  if (!newState.TransactionController) {
    return newState;
  }
  const {
    transactions
  } = newState.TransactionController;
  newState.TransactionController.transactions = transactions.map((txMeta, _) => {
    if (txMeta.status === _transaction.TransactionStatus.unapproved && txMeta.txParams && txMeta.txParams.from) {
      txMeta.txParams.from = txMeta.txParams.from.toLowerCase();
    }
    return txMeta;
  });
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\024.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\025.js", {"../../../shared/constants/transaction":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\transaction.ts","../lib/util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\lib\\util.ts","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C025.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _util = require("../lib/util");
var _transaction = require("../../../shared/constants/transaction");
// next version number
/*

normalizes txParams on unconfirmed txs

*/

const version = 25;
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  if (newState.TransactionController) {
    if (newState.TransactionController.transactions) {
      const {
        transactions
      } = newState.TransactionController;
      newState.TransactionController.transactions = transactions.map(txMeta => {
        if (txMeta.status !== _transaction.TransactionStatus.unapproved) {
          return txMeta;
        }
        txMeta.txParams = normalizeTxParams(txMeta.txParams);
        return txMeta;
      });
    }
  }
  return newState;
}
function normalizeTxParams(txParams) {
  // functions that handle normalizing of that key in txParams
  const whiteList = {
    from: from => (0, _util.addHexPrefix)(from).toLowerCase(),
    to: () => (0, _util.addHexPrefix)(txParams.to).toLowerCase(),
    nonce: nonce => (0, _util.addHexPrefix)(nonce),
    value: value => (0, _util.addHexPrefix)(value),
    data: data => (0, _util.addHexPrefix)(data),
    gas: gas => (0, _util.addHexPrefix)(gas),
    gasPrice: gasPrice => (0, _util.addHexPrefix)(gasPrice)
  };

  // apply only keys in the whiteList
  const normalizedTxParams = {};
  Object.keys(whiteList).forEach(key => {
    if (txParams[key]) {
      normalizedTxParams[key] = whiteList[key](txParams[key]);
    }
  });
  return normalizedTxParams;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\025.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\026.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C026.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration moves the identities stored in the KeyringController
 into the PreferencesController

*/

const version = 26;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      versionedData.data = transformState(state);
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
      return Promise.reject(err);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  if (!state.KeyringController || !state.PreferencesController) {
    return state;
  }
  if (!state.KeyringController.walletNicknames) {
    return state;
  }
  state.PreferencesController.identities = Object.keys(state.KeyringController.walletNicknames).reduce((identities, address) => {
    identities[address] = {
      name: state.KeyringController.walletNicknames[address],
      address
    };
    return identities;
  }, {});
  delete state.KeyringController.walletNicknames;
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\026.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\027.js", {"../../../shared/constants/transaction":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\transaction.ts","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C027.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
// next version number
/*

normalizes txParams on unconfirmed txs

*/

const version = 27;
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  if (newState.TransactionController) {
    if (newState.TransactionController.transactions) {
      const {
        transactions
      } = newState.TransactionController;
      newState.TransactionController.transactions = transactions.filter(txMeta => txMeta.status !== _transaction.TransactionStatus.rejected);
    }
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\027.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\028.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C028.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
// next version number
/*

normalizes txParams on unconfirmed txs

*/

const version = 28;
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  if (newState.PreferencesController) {
    if (newState.PreferencesController.tokens && newState.PreferencesController.identities) {
      const {
        identities,
        tokens
      } = newState.PreferencesController;
      newState.PreferencesController.accountTokens = {};
      Object.keys(identities).forEach(identity => {
        newState.PreferencesController.accountTokens[identity] = {
          mainnet: tokens
        };
      });
      newState.PreferencesController.tokens = [];
    }
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\028.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\029.js", {"../../../shared/constants/transaction":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\transaction.ts","./fail-tx":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\fail-tx.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C029.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _transaction = require("../../../shared/constants/transaction");
var _failTx = _interopRequireDefault(require("./fail-tx"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// next version number

const version = 29;

// time
const seconds = 1000;
const minutes = 60 * seconds;
const hours = 60 * minutes;
const unacceptableDelay = 12 * hours;

/*

normalizes txParams on unconfirmed txs

*/
var _default = {
  version,
  migrate: (0, _failTx.default)(version, 'Stuck in approved state for too long.', txMeta => {
    const isApproved = txMeta.status === _transaction.TransactionStatus.approved;
    const createdTime = txMeta.submittedTime;
    const now = Date.now();
    return isApproved && now - createdTime > unacceptableDelay;
  })
};
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\029.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\030.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C030.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
// next version number
/*

removes invalid chaids from preferences and networkController for custom rpcs

*/

const version = 30;
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  if (state.PreferencesController) {
    const {
      frequentRpcListDetail
    } = newState.PreferencesController;
    if (frequentRpcListDetail) {
      frequentRpcListDetail.forEach((rpc, index) => {
        // eslint-disable-next-line radix
        if (Boolean(rpc.chainId) && Number.isNaN(parseInt(rpc.chainId))) {
          delete frequentRpcListDetail[index].chainId;
        }
      });
      newState.PreferencesController.frequentRpcListDetail = frequentRpcListDetail;
    }
  }
  if (state.NetworkController) {
    if (newState.NetworkController.network &&
    // eslint-disable-next-line radix
    Number.isNaN(parseInt(newState.NetworkController.network))) {
      delete newState.NetworkController.network;
    }
    if (newState.NetworkController.provider && newState.NetworkController.provider.chainId &&
    // eslint-disable-next-line radix
    Number.isNaN(parseInt(newState.NetworkController.provider.chainId))) {
      delete newState.NetworkController.provider.chainId;
    }
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\030.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\031.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C031.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
// next version number

const version = 31;

/*
 * The purpose of this migration is to properly set the completedOnboarding flag based on the state
 * of the KeyringController.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const {
    KeyringController,
    PreferencesController
  } = state;
  if (KeyringController && PreferencesController) {
    const {
      vault
    } = KeyringController;
    PreferencesController.completedOnboarding = Boolean(vault);
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\031.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\032.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C032.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 32;

/**
 * The purpose of this migration is to set the {@code completedUiMigration} flag based on the user's UI preferences
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const {
    PreferencesController
  } = state;
  if (PreferencesController) {
    const {
      betaUI
    } = PreferencesController.featureFlags || {};
    // Users who have been using the "beta" UI are considered to have completed the migration
    // as they'll see no difference in this version
    PreferencesController.completedUiMigration = betaUI;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\032.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\033.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C033.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
// next version number
/*

Cleans up notices and assocated notice controller code

*/

const version = 33;
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  // transform state here
  if (state.NoticeController) {
    delete newState.NoticeController;
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\033.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\034.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C034.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 34;

/**
 * The purpose of this migration is to enable the {@code privacyMode} feature flag and set the user as being migrated
 * if it was {@code false}.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const {
    PreferencesController
  } = state;
  if (PreferencesController) {
    const featureFlags = PreferencesController.featureFlags || {};
    if (!featureFlags.privacyMode && typeof PreferencesController.migratedPrivacyMode === 'undefined') {
      // Mark the state has being migrated and enable Privacy Mode
      PreferencesController.migratedPrivacyMode = true;
      featureFlags.privacyMode = true;
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\034.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\035.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C035.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
// next version number
/*

Removes the deprecated 'seedWords' state

*/

const version = 35;
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    versionedData.data = transformState(versionedData.data);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (state.PreferencesController && state.PreferencesController.seedWords !== undefined) {
    delete state.PreferencesController.seedWords;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\035.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\036.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C036.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 36;

/**
 * The purpose of this migration is to remove the {@code privacyMode} feature flag.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const {
    PreferencesController
  } = state;
  if (PreferencesController) {
    const featureFlags = PreferencesController.featureFlags || {};
    if (typeof featureFlags.privacyMode !== 'undefined') {
      delete featureFlags.privacyMode;
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\036.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\037.js", {"@metamask/controller-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\controller-utils\\dist\\index.js","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C037.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _controllerUtils = require("@metamask/controller-utils");
const version = 37;

/**
 * The purpose of this migration is to update the address book state
 * to the new schema with chainId as a key.
 * and to add the isEns flag to all entries
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (state.AddressBookController) {
    const ab = state.AddressBookController.addressBook;
    const chainIds = new Set();
    const newAddressBook = {};

    // add all of the chainIds to a set
    Object.values(ab).forEach(v => {
      chainIds.add(v.chainId);
    });

    // fill the chainId object with the entries with the matching chainId
    for (const id of chainIds.values()) {
      // make an empty object entry for each chainId
      newAddressBook[id] = {};
      for (const address in ab) {
        if (ab[address].chainId === id) {
          ab[address].isEns = false;
          if ((0, _controllerUtils.normalizeEnsName)(ab[address].name)) {
            ab[address].isEns = true;
          }
          newAddressBook[id][address] = ab[address];
        }
      }
    }
    state.AddressBookController.addressBook = newAddressBook;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\037.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\038.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C038.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 38;

/**
 * The purpose of this migration is to assign all users to a test group for the fullScreenVsPopup a/b test
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const {
    ABTestController: ABTestControllerState = {}
  } = state;
  const {
    abTests = {}
  } = ABTestControllerState;
  if (abTests.fullScreenVsPopup) {
    return state;
  }
  return {
    ...state,
    ABTestController: {
      ...ABTestControllerState,
      abTests: {
        ...abTests,
        fullScreenVsPopup: 'control'
      }
    }
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\038.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\039.js", {"../../../shared/modules/hexstring-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\hexstring-utils.ts","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C039.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _hexstringUtils = require("../../../shared/modules/hexstring-utils");
const version = 39;
const DAI_V1_CONTRACT_ADDRESS = '0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359';
const DAI_V1_TOKEN_SYMBOL = 'DAI';
const SAI_TOKEN_SYMBOL = 'SAI';
function isOldDai(token = {}) {
  return token && typeof token === 'object' && token.symbol === DAI_V1_TOKEN_SYMBOL && (0, _hexstringUtils.toChecksumHexAddress)(token.address) === DAI_V1_CONTRACT_ADDRESS;
}

/**
 * This migration renames the Dai token to Sai.
 *
 * As of 2019-11-18 Dai is now called Sai (refs https://git.io/JeooP) to facilitate
 * Maker's upgrade to Multi-Collateral Dai and this migration renames the token
 * at the old address.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const {
    PreferencesController
  } = state;
  if (PreferencesController) {
    const tokens = PreferencesController.tokens || [];
    if (Array.isArray(tokens)) {
      for (const token of tokens) {
        if (isOldDai(token)) {
          token.symbol = SAI_TOKEN_SYMBOL;
        }
      }
    }
    const accountTokens = PreferencesController.accountTokens || {};
    if (accountTokens && typeof accountTokens === 'object') {
      for (const address of Object.keys(accountTokens)) {
        const networkTokens = accountTokens[address];
        if (networkTokens && typeof networkTokens === 'object') {
          for (const network of Object.keys(networkTokens)) {
            const tokensOnNetwork = networkTokens[network];
            if (Array.isArray(tokensOnNetwork)) {
              for (const token of tokensOnNetwork) {
                if (isOldDai(token)) {
                  token.symbol = SAI_TOKEN_SYMBOL;
                }
              }
            }
          }
        }
      }
    }
  }
  return state;
}


      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\039.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\040.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C040.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 40;

/**
 * Site connections are now managed by the PermissionsController, and the
 * ProviderApprovalController is removed. This migration deletes all
 * ProviderApprovalController state.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  delete state.ProviderApprovalController;
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\040.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\041.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C041.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 41;

/**
 * PreferencesController.autoLogoutTimeLimit -> autoLockTimeLimit
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (state.PreferencesController && state.PreferencesController.preferences) {
    state.PreferencesController.preferences.autoLockTimeLimit = state.PreferencesController.preferences.autoLogoutTimeLimit;
    delete state.PreferencesController.preferences.autoLogoutTimeLimit;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\041.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\042.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C042.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 42;

/**
 * Initialize `connectedStatusPopoverHasBeenShown` to `false` if it hasn't yet been set,
 * so that existing users are introduced to the new connected status indicator
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (state.AppStateController) {
    state.AppStateController.connectedStatusPopoverHasBeenShown = false;
  } else {
    state.AppStateController = {
      connectedStatusPopoverHasBeenShown: false
    };
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\042.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\043.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C043.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 43;

/**
 * Remove unused 'currentAccountTab' state
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$PreferencesCon;
  if (state !== null && state !== void 0 && (_state$PreferencesCon = state.PreferencesController) !== null && _state$PreferencesCon !== void 0 && _state$PreferencesCon.currentAccountTab) {
    delete state.PreferencesController.currentAccountTab;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\043.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\044.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C044.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 44;

/**
 * Remove unused 'mkrMigrationReminderTimestamp' state from the `AppStateController`
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$AppStateContro;
  if (typeof (state === null || state === void 0 ? void 0 : (_state$AppStateContro = state.AppStateController) === null || _state$AppStateContro === void 0 ? void 0 : _state$AppStateContro.mkrMigrationReminderTimestamp) !== 'undefined') {
    delete state.AppStateController.mkrMigrationReminderTimestamp;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\044.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\045.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C045.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 45;

/**
 * Replaces {@code PreferencesController.ipfsGateway} with 'dweb.link' if set
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
const outdatedGateways = ['ipfs.io', 'ipfs.dweb.link'];
function transformState(state) {
  var _state$PreferencesCon;
  if (outdatedGateways.includes(state === null || state === void 0 ? void 0 : (_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.ipfsGateway)) {
    state.PreferencesController.ipfsGateway = 'dweb.link';
  }
  return state;
}


      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\045.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\046.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C046.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 46;

/**
 * Delete {@code ABTestController} state
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (typeof (state === null || state === void 0 ? void 0 : state.ABTestController) !== 'undefined') {
    delete state.ABTestController;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\046.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\047.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C047.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 47;

/**
 * Stringify the `metamaskNetworkId` property of all transactions
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$TransactionCon;
  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;
  if (Array.isArray(transactions)) {
    transactions.forEach(transaction => {
      if (typeof transaction.metamaskNetworkId === 'number') {
        transaction.metamaskNetworkId = transaction.metamaskNetworkId.toString();
      }
    });
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\047.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\048.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C048.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 48;

/**
 * 1.  Delete NetworkController.settings
 * 2a. Migrate NetworkController.provider to Rinkeby if set to type 'rpc' or
 *     'localhost'.
 * 2b. Re-key provider.rpcTarget to provider.rpcUrl
 * 3.  Add localhost network to frequentRpcListDetail.
 * 4.  Delete CachedBalancesController.cachedBalances
 * 5.  Convert transactions metamaskNetworkId to decimal if they are hex
 * 6.  Convert address book keys from decimal to hex
 * 7.  Delete localhost key in IncomingTransactionsController
 * 8.  Merge 'localhost' tokens into 'rpc' tokens
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
const hexRegEx = /^0x[0-9a-f]+$/iu;
const chainIdRegEx = /^0x[1-9a-f]+[0-9a-f]*$/iu;
function transformState(state = {}) {
  var _state$NetworkControl, _state$NetworkControl2, _state$NetworkControl3, _state$CachedBalances, _state$TransactionCon, _state$AddressBookCon, _state$IncomingTransa, _state$IncomingTransa2, _state$PreferencesCon;
  // 1. Delete NetworkController.settings
  (_state$NetworkControl = state.NetworkController) === null || _state$NetworkControl === void 0 ? true : delete _state$NetworkControl.settings;

  // 2. Migrate NetworkController.provider to Rinkeby or rename rpcTarget key
  const provider = ((_state$NetworkControl2 = state.NetworkController) === null || _state$NetworkControl2 === void 0 ? void 0 : _state$NetworkControl2.provider) || {};
  const isCustomRpcWithInvalidChainId = provider.type === 'rpc' && (typeof provider.chainId !== 'string' || !chainIdRegEx.test(provider.chainId));
  if (isCustomRpcWithInvalidChainId || provider.type === 'localhost') {
    state.NetworkController.provider = {
      type: 'rinkeby',
      rpcUrl: '',
      chainId: '0x4',
      nickname: '',
      rpcPrefs: {},
      ticker: 'ETH'
    };
  } else if ((_state$NetworkControl3 = state.NetworkController) !== null && _state$NetworkControl3 !== void 0 && _state$NetworkControl3.provider) {
    var _state$NetworkControl4, _state$NetworkControl5;
    if ('rpcTarget' in state.NetworkController.provider) {
      const rpcUrl = state.NetworkController.provider.rpcTarget;
      state.NetworkController.provider.rpcUrl = rpcUrl;
    }
    (_state$NetworkControl4 = state.NetworkController) === null || _state$NetworkControl4 === void 0 ? true : (_state$NetworkControl5 = _state$NetworkControl4.provider) === null || _state$NetworkControl5 === void 0 ? true : delete _state$NetworkControl5.rpcTarget;
  }

  // 3.  Add localhost network to frequentRpcListDetail.
  if (!state.PreferencesController) {
    state.PreferencesController = {};
  }
  if (!state.PreferencesController.frequentRpcListDetail) {
    state.PreferencesController.frequentRpcListDetail = [];
  }
  state.PreferencesController.frequentRpcListDetail.unshift({
    rpcUrl: 'http://localhost:8545',
    chainId: '0x539',
    ticker: 'ETH',
    nickname: 'Localhost 8545',
    rpcPrefs: {}
  });

  // 4.  Delete CachedBalancesController.cachedBalances
  (_state$CachedBalances = state.CachedBalancesController) === null || _state$CachedBalances === void 0 ? true : delete _state$CachedBalances.cachedBalances;

  // 5.  Convert transactions metamaskNetworkId to decimal if they are hex
  const transactions = (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;
  if (Array.isArray(transactions)) {
    transactions.forEach(transaction => {
      const metamaskNetworkId = transaction === null || transaction === void 0 ? void 0 : transaction.metamaskNetworkId;
      if (typeof metamaskNetworkId === 'string' && hexRegEx.test(metamaskNetworkId)) {
        transaction.metamaskNetworkId = parseInt(metamaskNetworkId, 16).toString(10);
      }
    });
  }

  // 6.  Convert address book keys from decimal to hex
  const addressBook = ((_state$AddressBookCon = state.AddressBookController) === null || _state$AddressBookCon === void 0 ? void 0 : _state$AddressBookCon.addressBook) || {};
  Object.keys(addressBook).forEach(networkKey => {
    if (/^\d+$/iu.test(networkKey)) {
      const chainId = `0x${parseInt(networkKey, 10).toString(16)}`;
      updateChainIds(addressBook[networkKey], chainId);
      if (addressBook[chainId]) {
        mergeAddressBookKeys(addressBook, networkKey, chainId);
      } else {
        addressBook[chainId] = addressBook[networkKey];
      }
      delete addressBook[networkKey];
    }
  });

  // 7.  Delete localhost key in IncomingTransactionsController
  (_state$IncomingTransa = state.IncomingTransactionsController) === null || _state$IncomingTransa === void 0 ? true : (_state$IncomingTransa2 = _state$IncomingTransa.incomingTxLastFetchedBlocksByNetwork) === null || _state$IncomingTransa2 === void 0 ? true : delete _state$IncomingTransa2.localhost;

  // 8.  Merge 'localhost' tokens into 'rpc' tokens
  const accountTokens = (_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.accountTokens;
  if (accountTokens) {
    Object.keys(accountTokens).forEach(account => {
      var _accountTokens$accoun, _accountTokens$accoun2;
      const localhostTokens = ((_accountTokens$accoun = accountTokens[account]) === null || _accountTokens$accoun === void 0 ? void 0 : _accountTokens$accoun.localhost) || [];
      if (localhostTokens.length > 0) {
        const rpcTokens = accountTokens[account].rpc || [];
        if (rpcTokens.length > 0) {
          accountTokens[account].rpc = mergeTokenArrays(localhostTokens, rpcTokens);
        } else {
          accountTokens[account].rpc = localhostTokens;
        }
      }
      (_accountTokens$accoun2 = accountTokens[account]) === null || _accountTokens$accoun2 === void 0 ? true : delete _accountTokens$accoun2.localhost;
    });
  }
  return state;
}

/**
 * Merges the two given keys for the given address book in place.
 *
 * @param addressBook
 * @param networkKey
 * @param chainIdKey
 */
function mergeAddressBookKeys(addressBook, networkKey, chainIdKey) {
  const networkKeyEntries = addressBook[networkKey] || {};
  // For the new entries, start by copying the existing entries for the chainId
  const newEntries = {
    ...addressBook[chainIdKey]
  };

  // For each address of the old/networkId key entries
  Object.keys(networkKeyEntries).forEach(address => {
    if (newEntries[address] && typeof newEntries[address] === 'object') {
      const mergedEntry = {};

      // Collect all keys from both entries and merge the corresponding chainId
      // entry with the networkId entry
      new Set([...Object.keys(newEntries[address]), ...Object.keys(networkKeyEntries[address] || {})]).forEach(key => {
        var _networkKeyEntries$ad;
        // Use non-empty value for the current key, if any
        mergedEntry[key] = newEntries[address][key] || ((_networkKeyEntries$ad = networkKeyEntries[address]) === null || _networkKeyEntries$ad === void 0 ? void 0 : _networkKeyEntries$ad[key]) || '';
      });
      newEntries[address] = mergedEntry;
    } else if (networkKeyEntries[address] && typeof networkKeyEntries[address] === 'object') {
      // If there is no corresponding chainId entry, just use the networkId entry
      // directly
      newEntries[address] = networkKeyEntries[address];
    }
  });
  addressBook[chainIdKey] = newEntries;
}

/**
 * Updates the chainId key values to the given chainId in place for all values
 * of the given networkEntries object.
 *
 * @param networkEntries
 * @param chainId
 */
function updateChainIds(networkEntries, chainId) {
  Object.values(networkEntries).forEach(entry => {
    if (entry && typeof entry === 'object') {
      entry.chainId = chainId;
    }
  });
}

/**
 * Merges the two given, non-empty arrays of token objects and returns a new
 * array.
 *
 * @param localhostTokens
 * @param rpcTokens
 * @returns {Array<object>}
 */
function mergeTokenArrays(localhostTokens, rpcTokens) {
  const localhostTokensMap = tokenArrayToMap(localhostTokens);
  const rpcTokensMap = tokenArrayToMap(rpcTokens);
  const mergedTokens = [];
  new Set([...Object.keys(localhostTokensMap), ...Object.keys(rpcTokensMap)]).forEach(tokenAddress => {
    mergedTokens.push({
      ...localhostTokensMap[tokenAddress],
      ...rpcTokensMap[tokenAddress]
    });
  });
  return mergedTokens;
  function tokenArrayToMap(array) {
    return array.reduce((map, token) => {
      if (token !== null && token !== void 0 && token.address && typeof (token === null || token === void 0 ? void 0 : token.address) === 'string') {
        map[token.address] = token;
      }
      return map;
    }, {});
  }
}


      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\048.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\049.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C049.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 49;

/**
 * Migrate metaMetrics state to the new MetaMetrics controller
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state = {}) {
  if (state.PreferencesController) {
    const {
      metaMetricsId,
      participateInMetaMetrics,
      metaMetricsSendCount
    } = state.PreferencesController;
    state.MetaMetricsController = state.MetaMetricsController ?? {};
    if (metaMetricsId !== undefined) {
      state.MetaMetricsController.metaMetricsId = metaMetricsId;
      delete state.PreferencesController.metaMetricsId;
    }
    if (participateInMetaMetrics !== undefined) {
      state.MetaMetricsController.participateInMetaMetrics = participateInMetaMetrics;
      delete state.PreferencesController.participateInMetaMetrics;
    }
    if (metaMetricsSendCount !== undefined) {
      state.MetaMetricsController.metaMetricsSendCount = metaMetricsSendCount;
      delete state.PreferencesController.metaMetricsSendCount;
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\049.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\050.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C050.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 50;
const LEGACY_LOCAL_STORAGE_KEYS = ['METASWAP_GAS_PRICE_ESTIMATES_LAST_RETRIEVED', 'METASWAP_GAS_PRICE_ESTIMATES', 'cachedFetch', 'BASIC_PRICE_ESTIMATES_LAST_RETRIEVED', 'BASIC_PRICE_ESTIMATES', 'BASIC_GAS_AND_TIME_API_ESTIMATES', 'BASIC_GAS_AND_TIME_API_ESTIMATES_LAST_RETRIEVED', 'GAS_API_ESTIMATES_LAST_RETRIEVED', 'GAS_API_ESTIMATES'];

/**
 * Migrate metaMetrics state to the new MetaMetrics controller
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    LEGACY_LOCAL_STORAGE_KEYS.forEach(key => {
      var _window$localStorage;
      return (_window$localStorage = window.localStorage) === null || _window$localStorage === void 0 ? void 0 : _window$localStorage.removeItem(key);
    });
    return versionedData;
  }
};
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\050.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\051.js", {"../../../shared/constants/network":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\network.ts","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C051.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _network = require("../../../shared/constants/network");
const version = 51;

/**
 * Set the chainId in the Network Controller provider data for all infura networks
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$NetworkControl, _BUILT_IN_NETWORKS$ty;
  const {
    chainId,
    type
  } = (state === null || state === void 0 ? void 0 : (_state$NetworkControl = state.NetworkController) === null || _state$NetworkControl === void 0 ? void 0 : _state$NetworkControl.provider) || {};
  const enumChainId = (_BUILT_IN_NETWORKS$ty = _network.BUILT_IN_NETWORKS[type]) === null || _BUILT_IN_NETWORKS$ty === void 0 ? void 0 : _BUILT_IN_NETWORKS$ty.chainId;
  if (enumChainId && chainId !== enumChainId) {
    state.NetworkController.provider.chainId = enumChainId;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\051.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\052.js", {"../../../shared/constants/network":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\network.ts","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C052.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _network = require("../../../shared/constants/network");
const version = 52;

/**
 * Migrate tokens in Preferences to be keyed by chainId instead of
 * providerType. To prevent breaking user's MetaMask and selected
 * tokens, this migration copies the RPC entry into *every* custom RPC
 * chainId.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state = {}) {
  if (state.PreferencesController) {
    const {
      accountTokens,
      accountHiddenTokens,
      frequentRpcListDetail
    } = state.PreferencesController;
    const newAccountTokens = {};
    const newAccountHiddenTokens = {};
    if (accountTokens && Object.keys(accountTokens).length > 0) {
      for (const address of Object.keys(accountTokens)) {
        newAccountTokens[address] = {};
        if (accountTokens[address][_network.NETWORK_TYPES.RPC]) {
          frequentRpcListDetail.forEach(detail => {
            newAccountTokens[address][detail.chainId] = accountTokens[address][_network.NETWORK_TYPES.RPC];
          });
        }
        for (const providerType of Object.keys(accountTokens[address])) {
          switch (providerType) {
            case _network.NETWORK_TYPES.MAINNET:
              newAccountTokens[address][_network.CHAIN_IDS.MAINNET] = accountTokens[address][_network.NETWORK_TYPES.MAINNET];
              break;
            case 'ropsten':
              newAccountTokens[address]['0x3'] = accountTokens[address].ropsten;
              break;
            case 'rinkeby':
              newAccountTokens[address]['0x4'] = accountTokens[address].rinkeby;
              break;
            case _network.NETWORK_TYPES.GOERLI:
              newAccountTokens[address][_network.CHAIN_IDS.GOERLI] = accountTokens[address][_network.NETWORK_TYPES.GOERLI];
              break;
            case 'kovan':
              newAccountTokens[address]['0x2a'] = accountTokens[address].kovan;
              break;
            default:
              break;
          }
        }
      }
      state.PreferencesController.accountTokens = newAccountTokens;
    }
    if (accountHiddenTokens && Object.keys(accountHiddenTokens).length > 0) {
      for (const address of Object.keys(accountHiddenTokens)) {
        newAccountHiddenTokens[address] = {};
        if (accountHiddenTokens[address][_network.NETWORK_TYPES.RPC]) {
          frequentRpcListDetail.forEach(detail => {
            newAccountHiddenTokens[address][detail.chainId] = accountHiddenTokens[address][_network.NETWORK_TYPES.RPC];
          });
        }
        for (const providerType of Object.keys(accountHiddenTokens[address])) {
          switch (providerType) {
            case _network.NETWORK_TYPES.MAINNET:
              newAccountHiddenTokens[address][_network.CHAIN_IDS.MAINNET] = accountHiddenTokens[address][_network.NETWORK_TYPES.MAINNET];
              break;
            case 'ropsten':
              newAccountHiddenTokens[address]['0x3'] = accountHiddenTokens[address].ropsten;
              break;
            case 'rinkeby':
              newAccountHiddenTokens[address]['0x4'] = accountHiddenTokens[address].rinkeby;
              break;
            case _network.NETWORK_TYPES.GOERLI:
              newAccountHiddenTokens[address][_network.CHAIN_IDS.GOERLI] = accountHiddenTokens[address][_network.NETWORK_TYPES.GOERLI];
              break;
            case 'kovan':
              newAccountHiddenTokens[address]['0x2a'] = accountHiddenTokens[address].kovan;
              break;
            default:
              break;
          }
        }
      }
      state.PreferencesController.accountHiddenTokens = newAccountHiddenTokens;
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\052.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\053.js", {"../../../shared/constants/transaction":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\transaction.ts","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C053.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
const version = 53;

/**
 * Deprecate transactionCategory and consolidate on 'type'
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$TransactionCon, _state$IncomingTransa;
  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;
  const incomingTransactions = state === null || state === void 0 ? void 0 : (_state$IncomingTransa = state.IncomingTransactionsController) === null || _state$IncomingTransa === void 0 ? void 0 : _state$IncomingTransa.incomingTransactions;
  if (Array.isArray(transactions)) {
    transactions.forEach(transaction => {
      if (transaction) {
        if (transaction.type !== _transaction.TransactionType.retry && transaction.type !== _transaction.TransactionType.cancel) {
          transaction.type = transaction.transactionCategory;
        }
        delete transaction.transactionCategory;
      }
    });
  }
  if (incomingTransactions) {
    const incomingTransactionsEntries = Object.entries(incomingTransactions);
    incomingTransactionsEntries.forEach(([key, transaction]) => {
      if (transaction) {
        delete transaction.transactionCategory;
        state.IncomingTransactionsController.incomingTransactions[key] = {
          ...transaction,
          type: _transaction.TransactionType.incoming
        };
      }
    });
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\053.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\054.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C054.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 54;
function isValidDecimals(decimals) {
  return typeof decimals === 'number' || typeof decimals === 'string' && decimals.match(/^(0x)?\d+$/u);
}

/**
 * Migrates preference tokens with decimals typed as string to number.
 * It also removes any tokens with corrupted or inconvertible decimal values.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  if (!newState.PreferencesController) {
    return newState;
  }
  const tokens = newState.PreferencesController.tokens || [];
  // Filter out any tokens with corrupted decimal values
  const validTokens = tokens.filter(({
    decimals
  }) => isValidDecimals(decimals));
  for (const token of validTokens) {
    // In the case of a decimal value type string, convert to a number.
    if (typeof token.decimals === 'string') {
      // eslint-disable-next-line radix
      token.decimals = parseInt(token.decimals);
    }
  }
  newState.PreferencesController.tokens = validTokens;
  const {
    accountTokens
  } = newState.PreferencesController;
  if (accountTokens && typeof accountTokens === 'object') {
    for (const address of Object.keys(accountTokens)) {
      const networkTokens = accountTokens[address];
      if (networkTokens && typeof networkTokens === 'object') {
        for (const network of Object.keys(networkTokens)) {
          const tokensOnNetwork = networkTokens[network] || [];
          // Filter out any tokens with corrupted decimal values
          const validTokensOnNetwork = tokensOnNetwork.filter(({
            decimals
          }) => isValidDecimals(decimals));
          // In the case of a decimal value type string, convert to a number.
          for (const token of validTokensOnNetwork) {
            if (typeof token.decimals === 'string') {
              // eslint-disable-next-line radix
              token.decimals = parseInt(token.decimals);
            }
          }
          networkTokens[network] = validTokensOnNetwork;
        }
      }
    }
  }
  newState.PreferencesController.accountTokens = accountTokens;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\054.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\055.js", {"../../../shared/constants/network":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\network.ts","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C055.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _network = require("../../../shared/constants/network");
const version = 55;

/**
 * replace 'incomingTxLastFetchedBlocksByNetwork' with 'incomingTxLastFetchedBlockByChainId'
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
const UNKNOWN_CHAIN_ID_KEY = 'UNKNOWN';
_network.BUILT_IN_NETWORKS.rinkeby = {
  networkId: '4',
  chainId: '0x4',
  ticker: 'ETH'
};
_network.BUILT_IN_NETWORKS.ropsten = {
  networkId: '3',
  chainId: '0x3',
  ticker: 'ETH'
};
_network.BUILT_IN_NETWORKS.kovan = {
  networkId: '42',
  chainId: '0x2a',
  ticker: 'ETH'
};
function transformState(state) {
  var _state$IncomingTransa;
  if (state !== null && state !== void 0 && (_state$IncomingTransa = state.IncomingTransactionsController) !== null && _state$IncomingTransa !== void 0 && _state$IncomingTransa.incomingTxLastFetchedBlocksByNetwork) {
    state.IncomingTransactionsController.incomingTxLastFetchedBlockByChainId = (0, _lodash.mapKeys)(state.IncomingTransactionsController.incomingTxLastFetchedBlocksByNetwork,
    // using optional chaining in case user's state has fetched blocks for
    // RPC network types (which don't map to a single chainId). This should
    // not be possible, but it's safer
    (_, key) => {
      var _BUILT_IN_NETWORKS$ke;
      return ((_BUILT_IN_NETWORKS$ke = _network.BUILT_IN_NETWORKS[key]) === null || _BUILT_IN_NETWORKS$ke === void 0 ? void 0 : _BUILT_IN_NETWORKS$ke.chainId) ?? UNKNOWN_CHAIN_ID_KEY;
    });
    // Now that mainnet and test net last fetched blocks are keyed by their
    // respective chainIds, we can safely delete anything we had for custom
    // networks. Any custom network that shares a chainId with one of the
    // aforementioned networks will use the value stored by chainId.
    delete state.IncomingTransactionsController.incomingTxLastFetchedBlockByChainId[UNKNOWN_CHAIN_ID_KEY];
    delete state.IncomingTransactionsController.incomingTxLastFetchedBlocksByNetwork;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\055.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\056.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C056.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 56;

/**
 * Remove tokens that don't have an address due to
 * lack of previous addToken validation.  Also removes
 * an unwanted, undefined image property
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const {
      PreferencesController
    } = versionedData.data;
    if (Array.isArray(PreferencesController === null || PreferencesController === void 0 ? void 0 : PreferencesController.tokens)) {
      PreferencesController.tokens = PreferencesController.tokens.filter(({
        address
      }) => address);
    }
    if (PreferencesController !== null && PreferencesController !== void 0 && PreferencesController.accountTokens && typeof PreferencesController.accountTokens === 'object') {
      Object.keys(PreferencesController.accountTokens).forEach(account => {
        const chains = Object.keys(PreferencesController.accountTokens[account]);
        chains.forEach(chain => {
          PreferencesController.accountTokens[account][chain] = PreferencesController.accountTokens[account][chain].filter(({
            address
          }) => address);
        });
      });
    }
    if (PreferencesController !== null && PreferencesController !== void 0 && PreferencesController.assetImages && 'undefined' in PreferencesController.assetImages) {
      delete PreferencesController.assetImages.undefined;
    }
    return versionedData;
  }
};
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\056.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\057.js", {"../../../shared/modules/random-id":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\random-id.js","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C057.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _randomId = _interopRequireDefault(require("../../../shared/modules/random-id"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const version = 57;

/**
 * replace 'incomingTxLastFetchedBlocksByNetwork' with 'incomingTxLastFetchedBlockByChainId'
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$TransactionCon;
  if (state !== null && state !== void 0 && (_state$TransactionCon = state.TransactionController) !== null && _state$TransactionCon !== void 0 && _state$TransactionCon.transactions && Array.isArray(state.TransactionController.transactions) && !state.TransactionController.transactions.some(item => typeof item !== 'object' || typeof item.txParams === 'undefined')) {
    state.TransactionController.transactions = (0, _lodash.keyBy)(state.TransactionController.transactions,
    // In case for some reason any of a user's transactions do not have an id
    // generate a new one for the transaction.
    tx => {
      if (typeof tx.id === 'undefined' || tx.id === null) {
        // This mutates the item in the array, so will result in a change to
        // the state.
        tx.id = (0, _randomId.default)();
      }
      return tx.id;
    });
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\057.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\058.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C058.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 58;

/**
 * Deletes the swapsWelcomeMessageHasBeenShown property from state
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$AppStateContro;
  (_state$AppStateContro = state.AppStateController) === null || _state$AppStateContro === void 0 ? true : delete _state$AppStateContro.swapsWelcomeMessageHasBeenShown;
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\058.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\059.js", {"../../../shared/constants/transaction":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\transaction.ts","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C059.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
const version = 59;

/**
 * Removes orphaned cancel and retry transactions that no longer have the
 * original transaction in state, which results in bugs.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$TransactionCon;
  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;
  if ((0, _lodash.isPlainObject)(transactions)) {
    const nonceNetworkGroupedObject = (0, _lodash.groupBy)(Object.values(transactions), tx => {
      var _tx$txParams;
      return `${(_tx$txParams = tx.txParams) === null || _tx$txParams === void 0 ? void 0 : _tx$txParams.nonce}-${tx.chainId ?? tx.metamaskNetworkId}`;
    });
    const withoutOrphans = (0, _lodash.pickBy)(nonceNetworkGroupedObject, group => {
      return group.some(tx => tx.type !== _transaction.TransactionType.cancel && tx.type !== _transaction.TransactionType.retry);
    });
    state.TransactionController.transactions = (0, _lodash.keyBy)((0, _lodash.concat)(...Object.values(withoutOrphans)), tx => tx.id);
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\059.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\060.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C060.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 60;
const SUPPORT_NOTIFICATION_KEY = 2;
const SUPPORT_NOTIFICATION_DATE = '2020-08-31';

/**
 * Removes the support survey notification
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$NotificationCo;
  const notifications = state === null || state === void 0 ? void 0 : (_state$NotificationCo = state.NotificationController) === null || _state$NotificationCo === void 0 ? void 0 : _state$NotificationCo.notifications;
  if ((0, _lodash.isPlainObject)(notifications)) {
    var _notifications$SUPPOR;
    if (((_notifications$SUPPOR = notifications[SUPPORT_NOTIFICATION_KEY]) === null || _notifications$SUPPOR === void 0 ? void 0 : _notifications$SUPPOR.date) === SUPPORT_NOTIFICATION_DATE) {
      delete state.NotificationController.notifications[SUPPORT_NOTIFICATION_KEY];
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\060.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\061.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C061.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 61;

/**
 * Initialize attributes related to recovery seed phrase reminder
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const currentTime = new Date().getTime();
  if (state.AppStateController) {
    state.AppStateController.recoveryPhraseReminderHasBeenShown = false;
    state.AppStateController.recoveryPhraseReminderLastShown = currentTime;
  } else {
    state.AppStateController = {
      recoveryPhraseReminderHasBeenShown: false,
      recoveryPhraseReminderLastShown: currentTime
    };
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\061.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\062.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C062.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 62;

/**
 * Removes metaMetricsSendCount from MetaMetrics controller
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (state.MetaMetricsController) {
    const {
      metaMetricsSendCount
    } = state.MetaMetricsController;
    if (metaMetricsSendCount !== undefined) {
      delete state.MetaMetricsController.metaMetricsSendCount;
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\062.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\063.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C063.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 63;

/**
 * Moves token state from preferences controller to TokensController
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$PreferencesCon, _state$PreferencesCon2, _state$PreferencesCon3, _state$PreferencesCon4, _state$PreferencesCon5, _state$PreferencesCon6, _state$PreferencesCon7, _state$PreferencesCon8;
  const accountTokens = state === null || state === void 0 ? void 0 : (_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.accountTokens;
  const accountHiddenTokens = state === null || state === void 0 ? void 0 : (_state$PreferencesCon2 = state.PreferencesController) === null || _state$PreferencesCon2 === void 0 ? void 0 : _state$PreferencesCon2.accountHiddenTokens;
  const newAllTokens = {};
  if (accountTokens) {
    Object.keys(accountTokens).forEach(accountAddress => {
      Object.keys(accountTokens[accountAddress]).forEach(chainId => {
        const tokensArray = accountTokens[accountAddress][chainId];
        if (newAllTokens[chainId] === undefined) {
          newAllTokens[chainId] = {
            [accountAddress]: tokensArray
          };
        } else {
          newAllTokens[chainId] = {
            ...newAllTokens[chainId],
            [accountAddress]: tokensArray
          };
        }
      });
    });
  }
  const newAllIgnoredTokens = {};
  if (accountHiddenTokens) {
    Object.keys(accountHiddenTokens).forEach(accountAddress => {
      Object.keys(accountHiddenTokens[accountAddress]).forEach(chainId => {
        const ignoredTokensArray = accountHiddenTokens[accountAddress][chainId];
        if (newAllIgnoredTokens[chainId] === undefined) {
          newAllIgnoredTokens[chainId] = {
            [accountAddress]: ignoredTokensArray
          };
        } else {
          newAllIgnoredTokens[chainId] = {
            ...newAllIgnoredTokens[chainId],
            [accountAddress]: ignoredTokensArray
          };
        }
      });
    });
  }
  if (state.TokensController) {
    state.TokensController.allTokens = newAllTokens;
    state.TokensController.allIgnoredTokens = newAllIgnoredTokens;
  } else {
    state.TokensController = {
      allTokens: newAllTokens,
      allIgnoredTokens: newAllIgnoredTokens
    };
  }
  state === null || state === void 0 ? true : (_state$PreferencesCon3 = state.PreferencesController) === null || _state$PreferencesCon3 === void 0 ? true : delete _state$PreferencesCon3.accountHiddenTokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon4 = state.PreferencesController) === null || _state$PreferencesCon4 === void 0 ? true : delete _state$PreferencesCon4.accountTokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon5 = state.PreferencesController) === null || _state$PreferencesCon5 === void 0 ? true : delete _state$PreferencesCon5.assetImages;
  state === null || state === void 0 ? true : (_state$PreferencesCon6 = state.PreferencesController) === null || _state$PreferencesCon6 === void 0 ? true : delete _state$PreferencesCon6.hiddenTokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon7 = state.PreferencesController) === null || _state$PreferencesCon7 === void 0 ? true : delete _state$PreferencesCon7.tokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon8 = state.PreferencesController) === null || _state$PreferencesCon8 === void 0 ? true : delete _state$PreferencesCon8.suggestedTokens;
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\063.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\064.js", {"../../../shared/constants/transaction":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\transaction.ts","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C064.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
const version = 64;
const SENT_ETHER = 'sentEther'; // the legacy transaction type being replaced in this migration with TransactionType.simpleSend

/**
 * Removes metaMetricsSendCount from MetaMetrics controller
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$TransactionCon;
  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;
  if ((0, _lodash.isPlainObject)(transactions)) {
    for (const tx of Object.values(transactions)) {
      if (tx.type === SENT_ETHER) {
        tx.type = _transaction.TransactionType.simpleSend;
      }
      if (tx.history) {
        tx.history.map(txEvent => {
          if (txEvent.type && txEvent.type === SENT_ETHER) {
            txEvent.type = _transaction.TransactionType.simpleSend;
          }
          return txEvent;
        });
      }
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\064.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\065.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C065.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 65;

/**
 * Removes metaMetricsSendCount from MetaMetrics controller
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (state.PreferencesController) {
    const {
      completedOnboarding,
      firstTimeFlowType
    } = state.PreferencesController;
    state.OnboardingController = state.OnboardingController ?? {};
    if (completedOnboarding !== undefined) {
      state.OnboardingController.completedOnboarding = completedOnboarding;
      delete state.PreferencesController.completedOnboarding;
    }
    if (firstTimeFlowType !== undefined) {
      state.OnboardingController.firstTimeFlowType = firstTimeFlowType;
      delete state.PreferencesController.firstTimeFlowType;
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\065.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\066.js", {"../../../shared/constants/hardware-wallets":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\hardware-wallets.ts","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C066.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _hardwareWallets = require("../../../shared/constants/hardware-wallets");
const version = 66;

/**
 * Changes the useLedgerLive boolean property to the ledgerTransportType enum
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$PreferencesCon;
  const defaultTransportType = window.navigator.hid ? _hardwareWallets.LedgerTransportTypes.webhid : _hardwareWallets.LedgerTransportTypes.u2f;
  const useLedgerLive = Boolean((_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.useLedgerLive);
  const newState = {
    ...state,
    PreferencesController: {
      ...(state === null || state === void 0 ? void 0 : state.PreferencesController),
      ledgerTransportType: useLedgerLive ? _hardwareWallets.LedgerTransportTypes.live : defaultTransportType
    }
  };
  delete newState.PreferencesController.useLedgerLive;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\066.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\067.js", {"../../../shared/constants/network":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\network.ts","bignumber.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\bignumber.js\\bignumber.js","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C067.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _bignumber = _interopRequireDefault(require("bignumber.js"));
var _network = require("../../../shared/constants/network");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const hexNumberIsGreaterThanZero = hexNumber => new _bignumber.default(hexNumber || '0x0', 16).gt(0);
const version = 67;

/**
 * Sets the showTestNetworks property to true if it was false or undefined, and there is evidence
 * that the user has used a test net
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$TransactionCon, _state$NetworkControl, _state$CachedBalances;
  const PreferencesController = (state === null || state === void 0 ? void 0 : state.PreferencesController) || {};
  const preferences = PreferencesController.preferences || {};
  if (preferences.showTestNetworks) {
    return state;
  }
  const transactions = (state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions) || {};
  const provider = ((_state$NetworkControl = state.NetworkController) === null || _state$NetworkControl === void 0 ? void 0 : _state$NetworkControl.provider) || {};
  const cachedBalances = ((_state$CachedBalances = state.CachedBalancesController) === null || _state$CachedBalances === void 0 ? void 0 : _state$CachedBalances.cachedBalances) || {};
  const userIsCurrentlyOnATestNet = _network.TEST_CHAINS.includes(provider === null || provider === void 0 ? void 0 : provider.chainId);
  const userHasMadeATestNetTransaction = Object.values(transactions).some(({
    chainId
  }) => _network.TEST_CHAINS.includes(chainId));
  const userHasACachedBalanceOnATestnet = _network.TEST_CHAINS.some(chainId => {
    const cachedBalancesForChain = Object.values(cachedBalances[chainId] || {});
    const userHasABalanceGreaterThanZeroOnThisChain = cachedBalancesForChain.some(hexNumberIsGreaterThanZero);
    return userHasABalanceGreaterThanZeroOnThisChain;
  });
  const userHasUsedATestnet = userIsCurrentlyOnATestNet || userHasMadeATestNetTransaction || userHasACachedBalanceOnATestnet;
  const newState = {
    ...state,
    PreferencesController: {
      ...PreferencesController,
      preferences: {
        ...preferences,
        showTestNetworks: userHasUsedATestnet
      }
    }
  };
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\067.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\068.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C068.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 68;

/**
 * Transforms the PermissionsController and PermissionsMetadata substates
 * to match the new permission system.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const {
    PermissionsController = {},
    PermissionsMetadata = {},
    ...remainingState
  } = state;
  const {
    domainMetadata = {},
    permissionsHistory = {},
    permissionsLog = []
  } = PermissionsMetadata;
  return {
    ...remainingState,
    PermissionController: getPermissionControllerState(PermissionsController),
    PermissionLogController: {
      permissionActivityLog: permissionsLog,
      permissionHistory: permissionsHistory
    },
    SubjectMetadataController: getSubjectMetadataControllerState(domainMetadata)
  };
}
function getPermissionControllerState(PermissionsController) {
  const {
    domains = {}
  } = PermissionsController;

  /**
   * Example existing domain entry. Every existing domain will have a single
   * eth_accounts permission, which simplifies the transform.
   *
   * 'https://metamask.github.io': {
   *   permissions: [
   *     {
   *       '@context': ['https://github.com/MetaMask/rpc-cap'],
   *       'caveats': [
   *         {
   *           name: 'primaryAccountOnly',
   *           type: 'limitResponseLength',
   *           value: 1,
   *         },
   *         {
   *           name: 'exposedAccounts',
   *           type: 'filterResponse',
   *           value: ['0x0c97a5c81e50a02ff8be73cc3f0a0569e61f4ed8'],
   *         },
   *       ],
   *       'date': 1616006369498,
   *       'id': '3d0bdc27-e8e4-4fb0-a24b-340d61f6a3fa',
   *       'invoker': 'https://metamask.github.io',
   *       'parentCapability': 'eth_accounts',
   *     },
   *   ],
   * },
   */

  const ETH_ACCOUNTS = 'eth_accounts';
  const NEW_CAVEAT_TYPE = 'restrictReturnedAccounts';
  const OLD_CAVEAT_NAME = 'exposedAccounts';
  const subjects = Object.entries(domains).reduce((transformed, [origin, domainEntry]) => {
    const {
      permissions: [ethAccountsPermission]
    } = domainEntry;

    // There are two caveats for each eth_accounts permission, but we only
    // need the value of one of them in the new permission system.
    const oldCaveat = ethAccountsPermission.caveats.find(caveat => caveat.name === OLD_CAVEAT_NAME);
    const newPermission = {
      ...ethAccountsPermission,
      caveats: [{
        type: NEW_CAVEAT_TYPE,
        value: oldCaveat.value
      }]
    };

    // We never used this, and just omit it in the new system.
    delete newPermission['@context'];
    transformed[origin] = {
      origin,
      permissions: {
        [ETH_ACCOUNTS]: newPermission
      }
    };
    return transformed;
  }, {});
  return {
    subjects
  };
}
function getSubjectMetadataControllerState(domainMetadata) {
  /**
   * Example existing domainMetadata entry.
   *
   * "https://www.youtube.com": {
   *   "host": "www.youtube.com",
   *   "icon": null,
   *   "lastUpdated": 1637697914908,
   *   "name": "YouTube"
   * }
   */

  const subjectMetadata = Object.entries(domainMetadata).reduce((transformed, [origin, metadata]) => {
    const {
      name = null,
      icon = null,
      extensionId = null,
      ...other
    } = metadata;

    // We're getting rid of these.
    delete other.lastUpdated;
    delete other.host;
    if (origin) {
      transformed[origin] = {
        name,
        iconUrl: icon,
        extensionId,
        ...other,
        origin
      };
    }
    return transformed;
  }, {});
  return {
    subjectMetadata
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\068.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\069.js", {"@metamask/subject-metadata-controller":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\subject-metadata-controller\\dist\\index.js","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C069.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _subjectMetadataController = require("@metamask/subject-metadata-controller");
var _lodash = require("lodash");
const version = 69;

/**
 * Adds the `subjectType` property to all subject metadata.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$SubjectMetadat;
  if (typeof (state === null || state === void 0 ? void 0 : (_state$SubjectMetadat = state.SubjectMetadataController) === null || _state$SubjectMetadat === void 0 ? void 0 : _state$SubjectMetadat.subjectMetadata) === 'object') {
    const {
      SubjectMetadataController: {
        subjectMetadata
      }
    } = state;

    // mutate SubjectMetadataController.subjectMetadata in place
    Object.values(subjectMetadata).forEach(metadata => {
      if (metadata && typeof metadata === 'object' && !Array.isArray(metadata)) {
        metadata.subjectType = metadata.extensionId ? _subjectMetadataController.SubjectType.Extension : _subjectMetadataController.SubjectType.Website;
      }
    });
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\069.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\070.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C070.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 70;

/**
 * Removes the `request` and `response` properties from
 * `PermissionLogController.permissionActivityLog` objects.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$PermissionLogC;
  if (Array.isArray(state === null || state === void 0 ? void 0 : (_state$PermissionLogC = state.PermissionLogController) === null || _state$PermissionLogC === void 0 ? void 0 : _state$PermissionLogC.permissionActivityLog)) {
    const {
      PermissionLogController: {
        permissionActivityLog
      }
    } = state;

    // mutate activity log entries in place
    permissionActivityLog.forEach(logEntry => {
      if (logEntry && typeof logEntry === 'object' && !Array.isArray(logEntry)) {
        delete logEntry.request;
        delete logEntry.response;
      }
    });
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\070.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\071.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C071.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 71;

/**
 * Renames NotificationController to AnnouncementController
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (state.NotificationController) {
    state.AnnouncementController = {
      announcements: state.NotificationController.notifications
    };
    delete state.NotificationController;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\071.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\072.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C072.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 72;

/**
 * Should empty the `knownMethodData` object in PreferencesController
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const PreferencesController = (state === null || state === void 0 ? void 0 : state.PreferencesController) || {};
  return {
    ...state,
    PreferencesController: {
      ...PreferencesController,
      knownMethodData: {}
    }
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\072.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\073.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C073.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 73;

/**
 * Should empty the `knownMethodData` object in PreferencesController
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const PreferencesController = (state === null || state === void 0 ? void 0 : state.PreferencesController) || {};
  return {
    ...state,
    PreferencesController: {
      ...PreferencesController,
      knownMethodData: {}
    }
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\073.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\074.js", {"../../../shared/constants/network":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\network.ts","bignumber.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\bignumber.js\\bignumber.js","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C074.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _bignumber = _interopRequireDefault(require("bignumber.js"));
var _network = require("../../../shared/constants/network");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const version = 74;
const hexNumberIsGreaterThanZero = hexNumber => new _bignumber.default(hexNumber || '0x0', 16).gt(0);
const DEPRECATED_TEST_NET_CHAINIDS = ['0x3', '0x2a', '0x4'];
const DEPRECATED_TEST_NET_DETAILS = {
  '0x3': {
    rpcUrl: (0, _network.getRpcUrl)({
      network: 'ropsten'
    }),
    nickname: 'Ropsten',
    ticker: 'RopstenETH'
  },
  '0x2a': {
    rpcUrl: (0, _network.getRpcUrl)({
      network: 'kovan'
    }),
    nickname: 'Kovan',
    ticker: 'KovanETH'
  },
  '0x4': {
    rpcUrl: (0, _network.getRpcUrl)({
      network: 'rinkeby'
    }),
    nickname: 'Rinkeby',
    ticker: 'RinkebyETH'
  }
};

/**
 * Migrates the user default but deprecated testnet networks to custom networks, and
 * if the current network is one such network, updates the network provider details so that it
 * will work as a custom rpc
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$TransactionCon, _state$CachedBalances;
  const PreferencesController = (state === null || state === void 0 ? void 0 : state.PreferencesController) || {};
  const preferences = PreferencesController.preferences || {};
  const NetworkController = (state === null || state === void 0 ? void 0 : state.NetworkController) || {};
  const provider = (NetworkController === null || NetworkController === void 0 ? void 0 : NetworkController.provider) || {};
  const currentlyOnDeprecatedNetwork = DEPRECATED_TEST_NET_CHAINIDS.filter(chainId => chainId === (provider === null || provider === void 0 ? void 0 : provider.chainId));

  // If the user does not want to see test networks, and if the the user is not on a deprecated test network, then
  // no need to migrate the test network data to a custom network
  if (!preferences.showTestNetworks && currentlyOnDeprecatedNetwork.length === 0) {
    return state;
  }
  const transactions = (state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions) || {};
  const cachedBalances = ((_state$CachedBalances = state.CachedBalancesController) === null || _state$CachedBalances === void 0 ? void 0 : _state$CachedBalances.cachedBalances) || {};
  const deprecatedTestnetsOnWhichTheUserHasMadeATransaction = Object.values(transactions).filter(({
    chainId
  }) => DEPRECATED_TEST_NET_CHAINIDS.includes(chainId)).map(({
    chainId
  }) => chainId);
  const deprecatedTestnetsOnWhichTheUserHasCachedBalance = DEPRECATED_TEST_NET_CHAINIDS.filter(chainId => {
    const cachedBalancesForChain = Object.values(cachedBalances[chainId] || {});
    const userHasABalanceGreaterThanZeroOnThisChain = cachedBalancesForChain.some(hexNumberIsGreaterThanZero);
    return userHasABalanceGreaterThanZeroOnThisChain;
  });
  const deprecatedTestnetsThatHaveBeenUsed = (0, _lodash.uniq)([...deprecatedTestnetsOnWhichTheUserHasCachedBalance, ...deprecatedTestnetsOnWhichTheUserHasMadeATransaction, ...currentlyOnDeprecatedNetwork]);
  const newFrequentRpcListDetail = PreferencesController.frequentRpcListDetail ?? [];
  deprecatedTestnetsThatHaveBeenUsed.forEach(chainId => {
    if (!newFrequentRpcListDetail.find(rpcDetails => rpcDetails.chainId === chainId)) {
      newFrequentRpcListDetail.unshift({
        rpcUrl: DEPRECATED_TEST_NET_DETAILS[chainId].rpcUrl,
        chainId,
        ticker: DEPRECATED_TEST_NET_DETAILS[chainId].ticker,
        nickname: DEPRECATED_TEST_NET_DETAILS[chainId].nickname,
        rpcPrefs: {}
      });
    }
  });
  if (newFrequentRpcListDetail.length) {
    PreferencesController.frequentRpcListDetail = newFrequentRpcListDetail;
  }
  if (currentlyOnDeprecatedNetwork.length) {
    const selectedNetworkChainId = currentlyOnDeprecatedNetwork[0];
    NetworkController.provider = {
      ...NetworkController.provider,
      type: 'rpc',
      rpcUrl: DEPRECATED_TEST_NET_DETAILS[selectedNetworkChainId].rpcUrl,
      chainId: selectedNetworkChainId,
      nickname: DEPRECATED_TEST_NET_DETAILS[selectedNetworkChainId].nickname,
      ticker: DEPRECATED_TEST_NET_DETAILS[selectedNetworkChainId].ticker
    };
  }
  return {
    ...state,
    PreferencesController: {
      ...PreferencesController
    },
    NetworkController: {
      ...NetworkController
    }
  };
}


      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\074.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\075.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C075.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 75;

/**
 * Delete the ThreeBoxController.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  delete state.ThreeBoxController;
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\075.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\076.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C076.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 76;

/**
 * Update to `@metamask/controllers@33.0.0` (rename "Collectible" to "NFT").
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$PreferencesCon;
  if (state.CollectiblesController) {
    const {
      allCollectibleContracts,
      allCollectibles,
      ignoredCollectibles,
      ...remainingState
    } = state.CollectiblesController;
    state.NftController = {
      ...(allCollectibleContracts ? {
        allNftContracts: allCollectibleContracts
      } : {}),
      ...(allCollectibles ? {
        allNfts: allCollectibles
      } : {}),
      ...(ignoredCollectibles ? {
        ignoredNfts: ignoredCollectibles
      } : {}),
      ...remainingState
    };
    delete state.CollectiblesController;
  }
  if ((_state$PreferencesCon = state.PreferencesController) !== null && _state$PreferencesCon !== void 0 && _state$PreferencesCon.useCollectibleDetection) {
    state.PreferencesController.useNftDetection = state.PreferencesController.useCollectibleDetection;
    delete state.PreferencesController.useCollectibleDetection;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\076.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\077.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C077.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 77;

/**
 * Prior to token detection v2 the data property in tokensChainsCache was an array,
 * in v2 we changes that to an object. In this migration we are converting the data as array to object.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const TokenListController = (state === null || state === void 0 ? void 0 : state.TokenListController) || {};
  const {
    tokensChainsCache
  } = TokenListController;
  let dataCache;
  let dataObject;
  // eslint-disable-next-line
  for (const chainId in tokensChainsCache) {
    dataCache = tokensChainsCache[chainId].data;
    dataObject = {};
    // if the data is array conver that to object
    if (Array.isArray(dataCache)) {
      for (const token of dataCache) {
        dataObject[token.address] = token;
      }
    } else if (Object.keys(dataCache)[0].toLowerCase() !== dataCache[Object.keys(dataCache)[0]].address.toLowerCase()) {
      // for the users who already updated to the recent version
      // and the dataCache is already an object keyed with 0,1,2,3 etc
      // eslint-disable-next-line
      for (const tokenAddress in dataCache) {
        dataObject[dataCache[tokenAddress].address] = dataCache[tokenAddress];
      }
    }
    tokensChainsCache[chainId].data = Object.keys(dataObject).length > 0 ? dataObject : dataCache;
  }
  TokenListController.tokensChainsCache = tokensChainsCache;
  return {
    ...state,
    TokenListController: {
      ...TokenListController
    }
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\077.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\078.ts", {"@metamask/utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\utils\\dist\\index.js","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C078.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _lodash = require("lodash");
var _utils = require("@metamask/utils");
const version = 78;

/**
 * The`@metamask/phishing-controller` state was updated in v2.0.0.
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  versionedData.data = transformState(versionedData.data);
  return versionedData;
}
function transformState(state) {
  if (!(0, _utils.hasProperty)(state, 'PhishingController') || !(0, _utils.isObject)(state.PhishingController)) {
    return state;
  }
  const {
    PhishingController
  } = state;
  delete PhishingController.phishing;
  delete PhishingController.lastFetched;
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\078.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\079.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C079.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 79;

/**
 * Remove collectiblesDropdownState and collectiblesDetectionNoticeDismissed:.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$AppStateContro, _state$metamask;
  if ((state === null || state === void 0 ? void 0 : (_state$AppStateContro = state.AppStateController) === null || _state$AppStateContro === void 0 ? void 0 : _state$AppStateContro.collectiblesDetectionNoticeDismissed) !== undefined) {
    delete state.AppStateController.collectiblesDetectionNoticeDismissed;
  }
  if ((state === null || state === void 0 ? void 0 : (_state$metamask = state.metamask) === null || _state$metamask === void 0 ? void 0 : _state$metamask.collectiblesDropdownState) !== undefined) {
    delete state.metamask.collectiblesDropdownState;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\079.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\080.js", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C080.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 80;

/**
 * The portfolio tooltip has been moved to a button on the home screen so
 * this property is no longer needed in state
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$metamask;
  if ((state === null || state === void 0 ? void 0 : (_state$metamask = state.metamask) === null || _state$metamask === void 0 ? void 0 : _state$metamask.showPortfolioTooltip) !== undefined) {
    delete state.metamask.showPortfolioTooltip;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\080.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\081.ts", {"@metamask/utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\utils\\dist\\index.js","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C081.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _lodash = require("lodash");
var _utils = require("@metamask/utils");
const version = 81;

/**
 * Prior to this migration, snap <> dapp permissions were wildcards i.e. `wallet_snap_*`.
 * Now the permission has been changed to `wallet_snap` and the current snap permissions
 * that are under wildcards will be added as caveats to a parent `wallet_snap` permission.
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  const state = versionedData.data;
  const newState = transformState(state);
  versionedData.data = newState;
  return versionedData;
}

// We return state AS IS if there is any corruption
function transformState(state) {
  if (!(0, _utils.hasProperty)(state, 'SnapController') || !(0, _utils.hasProperty)(state, 'PermissionController') || !(0, _utils.isObject)(state.PermissionController)) {
    return state;
  }
  const {
    PermissionController
  } = state;
  const {
    subjects
  } = PermissionController;
  if (!(0, _utils.isObject)(subjects)) {
    return state;
  }
  const snapPrefix = 'wallet_snap_';
  for (const [subjectName, subject] of Object.entries(subjects)) {
    if (!(0, _utils.isObject)(subject) || !(0, _utils.isObject)(subject.permissions)) {
      return state;
    }
    // We keep track of the latest permission's date and associated id
    // to assign to the wallet_snap permission after iterating through all permissions
    let date = 1;
    let id;
    const {
      permissions
    } = subject;
    // New permissions object that we use to tack on the `wallet_snap` permission
    const updatedPermissions = {
      ...permissions
    };
    for (const [permissionName, permission] of Object.entries(permissions)) {
      // check if the permission is namespaced
      if (permissionName.startsWith(snapPrefix)) {
        if (!(0, _utils.isObject)(permission) || !(0, _utils.hasProperty)(permission, 'id') || !(0, _utils.hasProperty)(permission, 'date')) {
          return state;
        }
        // We create a wallet_snap key if we already don't have one
        if (!(0, _utils.hasProperty)(updatedPermissions, 'wallet_snap')) {
          updatedPermissions.wallet_snap = {
            caveats: [{
              type: 'snapIds',
              value: {}
            }],
            invoker: subjectName,
            parentCapability: 'wallet_snap'
          };
        }

        // Check if the existing permission is valid
        if (!(0, _utils.isObject)(updatedPermissions.wallet_snap)) {
          return state;
        }
        if (!(0, _lodash.isArray)(updatedPermissions.wallet_snap.caveats)) {
          return state;
        }

        // Adding the snap name to the wallet_snap permission's caveat value
        const snapId = permissionName.slice(snapPrefix.length);
        const caveat = updatedPermissions.wallet_snap.caveats[0];
        if (!(0, _utils.isObject)(caveat)) {
          return state;
        }
        if (!(0, _utils.hasProperty)(caveat, 'type') || caveat.type !== 'snapIds' || !(0, _utils.hasProperty)(caveat, 'value') || !(0, _utils.isObject)(caveat.value)) {
          return state;
        }
        caveat.value[snapId] = {};
        if (typeof permission.date !== 'number' || typeof permission.id !== 'string') {
          return state;
        }

        // updating the date & id as we iterate through all permissions
        if (permission.date > date) {
          date = permission.date;
          id = permission.id;
        }

        // finally deleting the stale permission
        delete updatedPermissions[permissionName];
      }
    }

    // we reassign the date and id here after iterating through all permissions
    // and update the subject with the updated permissions
    if (updatedPermissions.wallet_snap) {
      updatedPermissions.wallet_snap.date = date;
      updatedPermissions.wallet_snap.id = id;
      subject.permissions = updatedPermissions;
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\081.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\082.ts", {"@metamask/utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\utils\\dist\\index.js","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js","uuid":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C082.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _lodash = require("lodash");
var _utils = require("@metamask/utils");
var _uuid = require("uuid");
const version = 82;

/**
 * Migrate the frequentRpcListDetail from the PreferencesController to the NetworkController, convert it from an array to an object
 * keyed by random uuids.
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  versionedData.data = transformState(versionedData.data);
  return versionedData;
}
function transformState(state) {
  if (!(0, _utils.hasProperty)(state, 'PreferencesController') || !(0, _utils.isObject)(state.PreferencesController) || !(0, _utils.isObject)(state.NetworkController) || !(0, _utils.hasProperty)(state.PreferencesController, 'frequentRpcListDetail') || !Array.isArray(state.PreferencesController.frequentRpcListDetail) || !state.PreferencesController.frequentRpcListDetail.every(_utils.isObject)) {
    return state;
  }
  const {
    PreferencesController,
    NetworkController
  } = state;
  const {
    frequentRpcListDetail
  } = PreferencesController;
  if (!Array.isArray(frequentRpcListDetail)) {
    return state;
  }
  const networkConfigurations = frequentRpcListDetail.reduce((networkConfigurationsAcc, {
    rpcUrl,
    chainId,
    ticker,
    nickname,
    rpcPrefs
  }) => {
    const networkConfigurationId = (0, _uuid.v4)();
    return {
      ...networkConfigurationsAcc,
      [networkConfigurationId]: {
        rpcUrl,
        chainId,
        ticker,
        rpcPrefs,
        nickname
      }
    };
  }, {});
  delete PreferencesController.frequentRpcListDetail;
  return {
    ...state,
    NetworkController: {
      ...NetworkController,
      networkConfigurations
    },
    PreferencesController: {
      ...PreferencesController
    }
  };
}


      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\082.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\083.ts", {"@metamask/utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\utils\\dist\\index.js","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C083.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _lodash = require("lodash");
var _utils = require("@metamask/utils");
const version = 83;

/**
 * Ensure that each networkConfigurations object in state.NetworkController.networkConfigurations has an
 * `id` property which matches the key pointing that object
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  versionedData.data = transformState(versionedData.data);
  return versionedData;
}
function transformState(state) {
  if (!(0, _utils.isObject)(state.NetworkController)) {
    return state;
  }
  const {
    NetworkController
  } = state;
  if (!(0, _utils.isObject)(NetworkController.networkConfigurations)) {
    return state;
  }
  const {
    networkConfigurations
  } = NetworkController;
  const newNetworkConfigurations = {};
  for (const networkConfigurationId of Object.keys(networkConfigurations)) {
    const networkConfiguration = networkConfigurations[networkConfigurationId];
    if (!(0, _utils.isObject)(networkConfiguration)) {
      return state;
    }
    newNetworkConfigurations[networkConfigurationId] = {
      ...networkConfiguration,
      id: networkConfigurationId
    };
  }
  return {
    ...state,
    NetworkController: {
      ...NetworkController,
      networkConfigurations: newNetworkConfigurations
    }
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\083.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\084.ts", {"@metamask/utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\utils\\dist\\index.js","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C084.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _lodash = require("lodash");
var _utils = require("@metamask/utils");
const version = 84;

/**
 * The `network` property in state was replaced with `networkId` and `networkStatus`.
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  versionedData.data = transformState(versionedData.data);
  return versionedData;
}
function transformState(state) {
  if (!(0, _utils.hasProperty)(state, 'NetworkController') || !(0, _utils.isObject)(state.NetworkController) || !(0, _utils.hasProperty)(state.NetworkController, 'network')) {
    return state;
  }
  const NetworkController = {
    ...state.NetworkController
  };
  if (NetworkController.network === 'loading') {
    NetworkController.networkId = null;
    NetworkController.networkStatus = 'unknown';
  } else {
    NetworkController.networkId = NetworkController.network;
    NetworkController.networkStatus = 'available';
  }
  delete NetworkController.network;
  return {
    ...state,
    NetworkController
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\084.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\085.ts", {"@metamask/utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\utils\\dist\\index.js","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C085.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _lodash = require("lodash");
var _utils = require("@metamask/utils");
const version = 85;

/**
 * Remove the now-obsolete network controller `previousProviderStore` state.
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  versionedData.data = transformState(versionedData.data);
  return versionedData;
}
function transformState(state) {
  if (!(0, _utils.isObject)(state.NetworkController)) {
    return state;
  }
  delete state.NetworkController.previousProviderStore;
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\085.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\086.ts", {"@metamask/utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\utils\\dist\\index.js","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5C086.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _utils = require("@metamask/utils");
var _lodash = require("lodash");
const version = 86;

/**
 * Rename network controller `provider` state to `providerConfig`.
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  versionedData.data = transformState(versionedData.data);
  return versionedData;
}
function transformState(state) {
  if ((0, _utils.hasProperty)(state, 'NetworkController') && (0, _utils.isObject)(state.NetworkController) && (0, _utils.hasProperty)(state.NetworkController, 'provider')) {
    const networkControllerState = state.NetworkController;
    networkControllerState.providerConfig = networkControllerState.provider;
    delete networkControllerState.provider;
    return {
      ...state,
      NetworkController: networkControllerState
    };
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\086.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\fail-tx.js", {"../../../shared/constants/transaction":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\transaction.ts","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5Cfail-tx.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = failTxsThat;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
function failTxsThat(version, reason, condition) {
  return function (originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state, condition, reason);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  };
}
function transformState(state, condition, reason) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!condition(txMeta)) {
        return txMeta;
      }
      txMeta.status = _transaction.TransactionStatus.failed;
      txMeta.err = {
        message: reason,
        note: `Tx automatically failed by migration because ${reason}`
      };
      return txMeta;
    });
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\fail-tx.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\index.js", {"./002":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\002.js","./003":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\003.js","./004":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\004.js","./005":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\005.js","./006":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\006.js","./007":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\007.js","./008":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\008.js","./009":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\009.js","./010":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\010.js","./011":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\011.js","./012":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\012.js","./013":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\013.js","./014":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\014.js","./015":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\015.js","./016":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\016.js","./017":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\017.js","./018":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\018.js","./019":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\019.js","./020":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\020.js","./021":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\021.js","./022":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\022.js","./023":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\023.js","./024":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\024.js","./025":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\025.js","./026":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\026.js","./027":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\027.js","./028":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\028.js","./029":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\029.js","./030":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\030.js","./031":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\031.js","./032":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\032.js","./033":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\033.js","./034":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\034.js","./035":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\035.js","./036":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\036.js","./037":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\037.js","./038":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\038.js","./039":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\039.js","./040":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\040.js","./041":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\041.js","./042":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\042.js","./043":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\043.js","./044":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\044.js","./045":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\045.js","./046":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\046.js","./047":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\047.js","./048":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\048.js","./049":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\049.js","./050":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\050.js","./051":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\051.js","./052":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\052.js","./053":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\053.js","./054":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\054.js","./055":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\055.js","./056":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\056.js","./057":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\057.js","./058":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\058.js","./059":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\059.js","./060":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\060.js","./061":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\061.js","./062":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\062.js","./063":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\063.js","./064":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\064.js","./065":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\065.js","./066":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\066.js","./067":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\067.js","./068":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\068.js","./069":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\069.js","./070":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\070.js","./071":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\071.js","./072":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\072.js","./073":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\073.js","./074":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\074.js","./075":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\075.js","./076":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\076.js","./077":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\077.js","./078":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\078.ts","./079":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\079.js","./080":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\080.js","./081":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\081.ts","./082":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\082.ts","./083":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\083.ts","./084":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\084.ts","./085":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\085.ts","./086":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\migrations\\086.ts"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Capp%5Cscripts%5Cmigrations%5Cindex.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _ = _interopRequireDefault(require("./002"));
var _2 = _interopRequireDefault(require("./003"));
var _3 = _interopRequireDefault(require("./004"));
var _4 = _interopRequireDefault(require("./005"));
var _5 = _interopRequireDefault(require("./006"));
var _6 = _interopRequireDefault(require("./007"));
var _7 = _interopRequireDefault(require("./008"));
var _8 = _interopRequireDefault(require("./009"));
var _9 = _interopRequireDefault(require("./010"));
var _10 = _interopRequireDefault(require("./011"));
var _11 = _interopRequireDefault(require("./012"));
var _12 = _interopRequireDefault(require("./013"));
var _13 = _interopRequireDefault(require("./014"));
var _14 = _interopRequireDefault(require("./015"));
var _15 = _interopRequireDefault(require("./016"));
var _16 = _interopRequireDefault(require("./017"));
var _17 = _interopRequireDefault(require("./018"));
var _18 = _interopRequireDefault(require("./019"));
var _19 = _interopRequireDefault(require("./020"));
var _20 = _interopRequireDefault(require("./021"));
var _21 = _interopRequireDefault(require("./022"));
var _22 = _interopRequireDefault(require("./023"));
var _23 = _interopRequireDefault(require("./024"));
var _24 = _interopRequireDefault(require("./025"));
var _25 = _interopRequireDefault(require("./026"));
var _26 = _interopRequireDefault(require("./027"));
var _27 = _interopRequireDefault(require("./028"));
var _28 = _interopRequireDefault(require("./029"));
var _29 = _interopRequireDefault(require("./030"));
var _30 = _interopRequireDefault(require("./031"));
var _31 = _interopRequireDefault(require("./032"));
var _32 = _interopRequireDefault(require("./033"));
var _33 = _interopRequireDefault(require("./034"));
var _34 = _interopRequireDefault(require("./035"));
var _35 = _interopRequireDefault(require("./036"));
var _36 = _interopRequireDefault(require("./037"));
var _37 = _interopRequireDefault(require("./038"));
var _38 = _interopRequireDefault(require("./039"));
var _39 = _interopRequireDefault(require("./040"));
var _40 = _interopRequireDefault(require("./041"));
var _41 = _interopRequireDefault(require("./042"));
var _42 = _interopRequireDefault(require("./043"));
var _43 = _interopRequireDefault(require("./044"));
var _44 = _interopRequireDefault(require("./045"));
var _45 = _interopRequireDefault(require("./046"));
var _46 = _interopRequireDefault(require("./047"));
var _47 = _interopRequireDefault(require("./048"));
var _48 = _interopRequireDefault(require("./049"));
var _49 = _interopRequireDefault(require("./050"));
var _50 = _interopRequireDefault(require("./051"));
var _51 = _interopRequireDefault(require("./052"));
var _52 = _interopRequireDefault(require("./053"));
var _53 = _interopRequireDefault(require("./054"));
var _54 = _interopRequireDefault(require("./055"));
var _55 = _interopRequireDefault(require("./056"));
var _56 = _interopRequireDefault(require("./057"));
var _57 = _interopRequireDefault(require("./058"));
var _58 = _interopRequireDefault(require("./059"));
var _59 = _interopRequireDefault(require("./060"));
var _60 = _interopRequireDefault(require("./061"));
var _61 = _interopRequireDefault(require("./062"));
var _62 = _interopRequireDefault(require("./063"));
var _63 = _interopRequireDefault(require("./064"));
var _64 = _interopRequireDefault(require("./065"));
var _65 = _interopRequireDefault(require("./066"));
var _66 = _interopRequireDefault(require("./067"));
var _67 = _interopRequireDefault(require("./068"));
var _68 = _interopRequireDefault(require("./069"));
var _69 = _interopRequireDefault(require("./070"));
var _70 = _interopRequireDefault(require("./071"));
var _71 = _interopRequireDefault(require("./072"));
var _72 = _interopRequireDefault(require("./073"));
var _73 = _interopRequireDefault(require("./074"));
var _74 = _interopRequireDefault(require("./075"));
var _75 = _interopRequireDefault(require("./076"));
var _76 = _interopRequireDefault(require("./077"));
var m078 = _interopRequireWildcard(require("./078"));
var _78 = _interopRequireDefault(require("./079"));
var _79 = _interopRequireDefault(require("./080"));
var m081 = _interopRequireWildcard(require("./081"));
var m082 = _interopRequireWildcard(require("./082"));
var m083 = _interopRequireWildcard(require("./083"));
var m084 = _interopRequireWildcard(require("./084"));
var m085 = _interopRequireWildcard(require("./085"));
var m086 = _interopRequireWildcard(require("./086"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// Migrations must start at version 1 or later.
// They are objects with a `version` number
// and a `migrate` function.
//
// The `migrate` function receives the previous
// config data format, and returns the new one.

const migrations = [_.default, _2.default, _3.default, _4.default, _5.default, _6.default, _7.default, _8.default, _9.default, _10.default, _11.default, _12.default, _13.default, _14.default, _15.default, _16.default, _17.default, _18.default, _19.default, _20.default, _21.default, _22.default, _23.default, _24.default, _25.default, _26.default, _27.default, _28.default, _29.default, _30.default, _31.default, _32.default, _33.default, _34.default, _35.default, _36.default, _37.default, _38.default, _39.default, _40.default, _41.default, _42.default, _43.default, _44.default, _45.default, _46.default, _47.default, _48.default, _49.default, _50.default, _51.default, _52.default, _53.default, _54.default, _55.default, _56.default, _57.default, _58.default, _59.default, _60.default, _61.default, _62.default, _63.default, _64.default, _65.default, _66.default, _67.default, _68.default, _69.default, _70.default, _71.default, _72.default, _73.default, _74.default, _75.default, _76.default, m078, _78.default, _79.default, m081, m082, m083, m084, m085, m086];
var _default = migrations;
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\base.js", {"./util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultibase%5Csrc%5Cbase.js
      return function (require, module, exports) {
'use strict'

const { encodeText } = require('./util')

/** @typedef {__import__('./types').CodecFactory} CodecFactory */
/** @typedef {__import__("./types").BaseName} BaseName */
/** @typedef {__import__("./types").BaseCode} BaseCode */

/**
 * Class to encode/decode in the supported Bases
 *
 */
class Base {
  /**
   * @param {BaseName} name
   * @param {BaseCode} code
   * @param {CodecFactory} factory
   * @param {string} alphabet
   */
  constructor (name, code, factory, alphabet) {
    this.name = name
    this.code = code
    this.codeBuf = encodeText(this.code)
    this.alphabet = alphabet
    this.codec = factory(alphabet)
  }

  /**
   * @param {Uint8Array} buf
   * @returns {string}
   */
  encode (buf) {
    return this.codec.encode(buf)
  }

  /**
   * @param {string} string
   * @returns {Uint8Array}
   */
  decode (string) {
    for (const char of string) {
      if (this.alphabet && this.alphabet.indexOf(char) < 0) {
        throw new Error(`invalid character '${char}' in '${string}'`)
      }
    }
    return this.codec.decode(string)
  }
}

module.exports = Base

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>uint8arrays>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\base.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\constants.js", {"./base.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\base.js","./rfc4648":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\rfc4648.js","./util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\util.js","@multiformats/base-x":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@multiformats\\base-x\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultibase%5Csrc%5Cconstants.js
      return function (require, module, exports) {
'use strict'

const baseX = require('@multiformats/base-x')
const Base = require('./base.js')
const { rfc4648 } = require('./rfc4648')
const { decodeText, encodeText } = require('./util')

/** @typedef {__import__('./types').CodecFactory} CodecFactory */
/** @typedef {__import__('./types').Codec} Codec */
/** @typedef {__import__('./types').BaseName} BaseName */
/** @typedef {__import__('./types').BaseCode} BaseCode */

/** @type {CodecFactory} */
const identity = () => {
  return {
    encode: decodeText,
    decode: encodeText
  }
}

/**
 *
 * name, code, implementation, alphabet
 *
 * @type {Array<[BaseName, BaseCode, CodecFactory, string]>}
 */
const constants = [
  ['identity', '\x00', identity, ''],
  ['base2', '0', rfc4648(1), '01'],
  ['base8', '7', rfc4648(3), '01234567'],
  ['base10', '9', baseX, '0123456789'],
  ['base16', 'f', rfc4648(4), '0123456789abcdef'],
  ['base16upper', 'F', rfc4648(4), '0123456789ABCDEF'],
  ['base32hex', 'v', rfc4648(5), '0123456789abcdefghijklmnopqrstuv'],
  ['base32hexupper', 'V', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV'],
  ['base32hexpad', 't', rfc4648(5), '0123456789abcdefghijklmnopqrstuv='],
  ['base32hexpadupper', 'T', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV='],
  ['base32', 'b', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567'],
  ['base32upper', 'B', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'],
  ['base32pad', 'c', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567='],
  ['base32padupper', 'C', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567='],
  ['base32z', 'h', rfc4648(5), 'ybndrfg8ejkmcpqxot1uwisza345h769'],
  ['base36', 'k', baseX, '0123456789abcdefghijklmnopqrstuvwxyz'],
  ['base36upper', 'K', baseX, '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'],
  ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
  ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
  ['base64', 'm', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
  ['base64pad', 'M', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
  ['base64url', 'u', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
  ['base64urlpad', 'U', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
]

/** @type {Record<BaseName,Base>} */
const names = constants.reduce((prev, tupple) => {
  prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])
  return prev
}, /** @type {Record<BaseName,Base>} */({}))

/** @type {Record<BaseCode,Base>} */
const codes = constants.reduce((prev, tupple) => {
  prev[tupple[1]] = names[tupple[0]]
  return prev
}, /** @type {Record<BaseCode,Base>} */({}))

module.exports = {
  names,
  codes
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>uint8arrays>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\constants.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\rfc4648.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultibase%5Csrc%5Crfc4648.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./types').CodecFactory} CodecFactory */

/**
 * @param {string} string
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {Uint8Array}
 */
const decode = (string, alphabet, bitsPerChar) => {
  // Build the character lookup table:
  /** @type {Record<string, number>} */
  const codes = {}
  for (let i = 0; i < alphabet.length; ++i) {
    codes[alphabet[i]] = i
  }

  // Count the padding bytes:
  let end = string.length
  while (string[end - 1] === '=') {
    --end
  }

  // Allocate the output:
  const out = new Uint8Array((end * bitsPerChar / 8) | 0)

  // Parse the data:
  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  let written = 0 // Next byte to write
  for (let i = 0; i < end; ++i) {
    // Read one character from the string:
    const value = codes[string[i]]
    if (value === undefined) {
      throw new SyntaxError('Invalid character ' + string[i])
    }

    // Append the bits to the buffer:
    buffer = (buffer << bitsPerChar) | value
    bits += bitsPerChar

    // Write out some bits if the buffer has a byte's worth:
    if (bits >= 8) {
      bits -= 8
      out[written++] = 0xff & (buffer >> bits)
    }
  }

  // Verify that we have received just enough bits:
  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {
    throw new SyntaxError('Unexpected end of data')
  }

  return out
}

/**
 * @param {Uint8Array} data
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {string}
 */
const encode = (data, alphabet, bitsPerChar) => {
  const pad = alphabet[alphabet.length - 1] === '='
  const mask = (1 << bitsPerChar) - 1
  let out = ''

  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  for (let i = 0; i < data.length; ++i) {
    // Slurp data into the buffer:
    buffer = (buffer << 8) | data[i]
    bits += 8

    // Write out as much as we can:
    while (bits > bitsPerChar) {
      bits -= bitsPerChar
      out += alphabet[mask & (buffer >> bits)]
    }
  }

  // Partial character:
  if (bits) {
    out += alphabet[mask & (buffer << (bitsPerChar - bits))]
  }

  // Add padding characters until we hit a byte boundary:
  if (pad) {
    while ((out.length * bitsPerChar) & 7) {
      out += '='
    }
  }

  return out
}

/**
 * RFC4648 Factory
 *
 * @param {number} bitsPerChar
 * @returns {CodecFactory}
 */
const rfc4648 = (bitsPerChar) => (alphabet) => {
  return {
    /**
     * @param {Uint8Array} input
     * @returns {string}
     */
    encode (input) {
      return encode(input, alphabet, bitsPerChar)
    },
    /**
     * @param {string} input
     * @returns {Uint8Array}
     */
    decode (input) {
      return decode(input, alphabet, bitsPerChar)
    }
  }
}

module.exports = { rfc4648 }

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>uint8arrays>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\rfc4648.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\util.js", {"web-encoding":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\web-encoding\\src\\lib.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultibase%5Csrc%5Cutil.js
      return function (require, module, exports) {
'use strict'

// @ts-ignore
const { TextEncoder, TextDecoder } = require('web-encoding')

const textDecoder = new TextDecoder()
/**
 * @param {ArrayBufferView|ArrayBuffer} bytes
 * @returns {string}
 */
const decodeText = (bytes) => textDecoder.decode(bytes)

const textEncoder = new TextEncoder()
/**
 * @param {string} text
 * @returns {Uint8Array}
 */
const encodeText = (text) => textEncoder.encode(text)

/**
 * Returns a new Uint8Array created by concatenating the passed Arrays
 *
 * @param {Array<ArrayLike<number>>} arrs
 * @param {number} length
 * @returns {Uint8Array}
 */
function concat (arrs, length) {
  const output = new Uint8Array(length)
  let offset = 0

  for (const arr of arrs) {
    output.set(arr, offset)
    offset += arr.length
  }

  return output
}

module.exports = { decodeText, encodeText, concat }

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>uint8arrays>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\util.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\decode.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Cnode_modules%5Cvarint%5Cdecode.js
      return function (require, module, exports) {
module.exports = read

var MSB = 0x80
  , REST = 0x7F

function read(buf, offset) {
  var res    = 0
    , offset = offset || 0
    , shift  = 0
    , counter = offset
    , b
    , l = buf.length

  do {
    if (counter >= l || shift > 49) {
      read.bytes = 0
      throw new RangeError('Could not decode varint')
    }
    b = buf[counter++]
    res += shift < 28
      ? (b & REST) << shift
      : (b & REST) * Math.pow(2, shift)
    shift += 7
  } while (b >= MSB)

  read.bytes = counter - offset

  return res
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>varint",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\decode.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\encode.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Cnode_modules%5Cvarint%5Cencode.js
      return function (require, module, exports) {
module.exports = encode

var MSB = 0x80
  , REST = 0x7F
  , MSBALL = ~REST
  , INT = Math.pow(2, 31)

function encode(num, out, offset) {
  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
    encode.bytes = 0
    throw new RangeError('Could not encode varint')
  }
  out = out || []
  offset = offset || 0
  var oldOffset = offset

  while(num >= INT) {
    out[offset++] = (num & 0xFF) | MSB
    num /= 128
  }
  while(num & MSBALL) {
    out[offset++] = (num & 0xFF) | MSB
    num >>>= 7
  }
  out[offset] = num | 0
  
  encode.bytes = offset - oldOffset + 1
  
  return out
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>varint",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\encode.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\index.js", {"./decode.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\decode.js","./encode.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\encode.js","./length.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\length.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Cnode_modules%5Cvarint%5Cindex.js
      return function (require, module, exports) {
module.exports = {
    encode: require('./encode.js')
  , decode: require('./decode.js')
  , encodingLength: require('./length.js')
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>varint",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\length.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Cnode_modules%5Cvarint%5Clength.js
      return function (require, module, exports) {

var N1 = Math.pow(2,  7)
var N2 = Math.pow(2, 14)
var N3 = Math.pow(2, 21)
var N4 = Math.pow(2, 28)
var N5 = Math.pow(2, 35)
var N6 = Math.pow(2, 42)
var N7 = Math.pow(2, 49)
var N8 = Math.pow(2, 56)
var N9 = Math.pow(2, 63)

module.exports = function (value) {
  return (
    value < N1 ? 1
  : value < N2 ? 2
  : value < N3 ? 3
  : value < N4 ? 4
  : value < N5 ? 5
  : value < N6 ? 6
  : value < N7 ? 7
  : value < N8 ? 8
  : value < N9 ? 9
  :              10
  )
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>varint",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\length.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Csrc%5Cbase-table.js
      return function (require, module, exports) {
// DO NOT CHANGE THIS FILE. IT IS GENERATED BY tools/update-table.js
/* eslint quote-props: off */
'use strict'

/**
 * @type {__import__('./generated-types').NameNumberMap}
 */
const baseTable = Object.freeze({
  'identity': 0x00,
  'cidv1': 0x01,
  'cidv2': 0x02,
  'cidv3': 0x03,
  'ip4': 0x04,
  'tcp': 0x06,
  'sha1': 0x11,
  'sha2-256': 0x12,
  'sha2-512': 0x13,
  'sha3-512': 0x14,
  'sha3-384': 0x15,
  'sha3-256': 0x16,
  'sha3-224': 0x17,
  'shake-128': 0x18,
  'shake-256': 0x19,
  'keccak-224': 0x1a,
  'keccak-256': 0x1b,
  'keccak-384': 0x1c,
  'keccak-512': 0x1d,
  'blake3': 0x1e,
  'dccp': 0x21,
  'murmur3-128': 0x22,
  'murmur3-32': 0x23,
  'ip6': 0x29,
  'ip6zone': 0x2a,
  'path': 0x2f,
  'multicodec': 0x30,
  'multihash': 0x31,
  'multiaddr': 0x32,
  'multibase': 0x33,
  'dns': 0x35,
  'dns4': 0x36,
  'dns6': 0x37,
  'dnsaddr': 0x38,
  'protobuf': 0x50,
  'cbor': 0x51,
  'raw': 0x55,
  'dbl-sha2-256': 0x56,
  'rlp': 0x60,
  'bencode': 0x63,
  'dag-pb': 0x70,
  'dag-cbor': 0x71,
  'libp2p-key': 0x72,
  'git-raw': 0x78,
  'torrent-info': 0x7b,
  'torrent-file': 0x7c,
  'leofcoin-block': 0x81,
  'leofcoin-tx': 0x82,
  'leofcoin-pr': 0x83,
  'sctp': 0x84,
  'dag-jose': 0x85,
  'dag-cose': 0x86,
  'eth-block': 0x90,
  'eth-block-list': 0x91,
  'eth-tx-trie': 0x92,
  'eth-tx': 0x93,
  'eth-tx-receipt-trie': 0x94,
  'eth-tx-receipt': 0x95,
  'eth-state-trie': 0x96,
  'eth-account-snapshot': 0x97,
  'eth-storage-trie': 0x98,
  'bitcoin-block': 0xb0,
  'bitcoin-tx': 0xb1,
  'bitcoin-witness-commitment': 0xb2,
  'zcash-block': 0xc0,
  'zcash-tx': 0xc1,
  'docid': 0xce,
  'stellar-block': 0xd0,
  'stellar-tx': 0xd1,
  'md4': 0xd4,
  'md5': 0xd5,
  'bmt': 0xd6,
  'decred-block': 0xe0,
  'decred-tx': 0xe1,
  'ipld-ns': 0xe2,
  'ipfs-ns': 0xe3,
  'swarm-ns': 0xe4,
  'ipns-ns': 0xe5,
  'zeronet': 0xe6,
  'secp256k1-pub': 0xe7,
  'bls12_381-g1-pub': 0xea,
  'bls12_381-g2-pub': 0xeb,
  'x25519-pub': 0xec,
  'ed25519-pub': 0xed,
  'bls12_381-g1g2-pub': 0xee,
  'dash-block': 0xf0,
  'dash-tx': 0xf1,
  'swarm-manifest': 0xfa,
  'swarm-feed': 0xfb,
  'udp': 0x0111,
  'p2p-webrtc-star': 0x0113,
  'p2p-webrtc-direct': 0x0114,
  'p2p-stardust': 0x0115,
  'p2p-circuit': 0x0122,
  'dag-json': 0x0129,
  'udt': 0x012d,
  'utp': 0x012e,
  'unix': 0x0190,
  'p2p': 0x01a5,
  'ipfs': 0x01a5,
  'https': 0x01bb,
  'onion': 0x01bc,
  'onion3': 0x01bd,
  'garlic64': 0x01be,
  'garlic32': 0x01bf,
  'tls': 0x01c0,
  'quic': 0x01cc,
  'ws': 0x01dd,
  'wss': 0x01de,
  'p2p-websocket-star': 0x01df,
  'http': 0x01e0,
  'json': 0x0200,
  'messagepack': 0x0201,
  'libp2p-peer-record': 0x0301,
  'sha2-256-trunc254-padded': 0x1012,
  'ripemd-128': 0x1052,
  'ripemd-160': 0x1053,
  'ripemd-256': 0x1054,
  'ripemd-320': 0x1055,
  'x11': 0x1100,
  'p256-pub': 0x1200,
  'p384-pub': 0x1201,
  'p521-pub': 0x1202,
  'ed448-pub': 0x1203,
  'x448-pub': 0x1204,
  'ed25519-priv': 0x1300,
  'kangarootwelve': 0x1d01,
  'sm3-256': 0x534d,
  'blake2b-8': 0xb201,
  'blake2b-16': 0xb202,
  'blake2b-24': 0xb203,
  'blake2b-32': 0xb204,
  'blake2b-40': 0xb205,
  'blake2b-48': 0xb206,
  'blake2b-56': 0xb207,
  'blake2b-64': 0xb208,
  'blake2b-72': 0xb209,
  'blake2b-80': 0xb20a,
  'blake2b-88': 0xb20b,
  'blake2b-96': 0xb20c,
  'blake2b-104': 0xb20d,
  'blake2b-112': 0xb20e,
  'blake2b-120': 0xb20f,
  'blake2b-128': 0xb210,
  'blake2b-136': 0xb211,
  'blake2b-144': 0xb212,
  'blake2b-152': 0xb213,
  'blake2b-160': 0xb214,
  'blake2b-168': 0xb215,
  'blake2b-176': 0xb216,
  'blake2b-184': 0xb217,
  'blake2b-192': 0xb218,
  'blake2b-200': 0xb219,
  'blake2b-208': 0xb21a,
  'blake2b-216': 0xb21b,
  'blake2b-224': 0xb21c,
  'blake2b-232': 0xb21d,
  'blake2b-240': 0xb21e,
  'blake2b-248': 0xb21f,
  'blake2b-256': 0xb220,
  'blake2b-264': 0xb221,
  'blake2b-272': 0xb222,
  'blake2b-280': 0xb223,
  'blake2b-288': 0xb224,
  'blake2b-296': 0xb225,
  'blake2b-304': 0xb226,
  'blake2b-312': 0xb227,
  'blake2b-320': 0xb228,
  'blake2b-328': 0xb229,
  'blake2b-336': 0xb22a,
  'blake2b-344': 0xb22b,
  'blake2b-352': 0xb22c,
  'blake2b-360': 0xb22d,
  'blake2b-368': 0xb22e,
  'blake2b-376': 0xb22f,
  'blake2b-384': 0xb230,
  'blake2b-392': 0xb231,
  'blake2b-400': 0xb232,
  'blake2b-408': 0xb233,
  'blake2b-416': 0xb234,
  'blake2b-424': 0xb235,
  'blake2b-432': 0xb236,
  'blake2b-440': 0xb237,
  'blake2b-448': 0xb238,
  'blake2b-456': 0xb239,
  'blake2b-464': 0xb23a,
  'blake2b-472': 0xb23b,
  'blake2b-480': 0xb23c,
  'blake2b-488': 0xb23d,
  'blake2b-496': 0xb23e,
  'blake2b-504': 0xb23f,
  'blake2b-512': 0xb240,
  'blake2s-8': 0xb241,
  'blake2s-16': 0xb242,
  'blake2s-24': 0xb243,
  'blake2s-32': 0xb244,
  'blake2s-40': 0xb245,
  'blake2s-48': 0xb246,
  'blake2s-56': 0xb247,
  'blake2s-64': 0xb248,
  'blake2s-72': 0xb249,
  'blake2s-80': 0xb24a,
  'blake2s-88': 0xb24b,
  'blake2s-96': 0xb24c,
  'blake2s-104': 0xb24d,
  'blake2s-112': 0xb24e,
  'blake2s-120': 0xb24f,
  'blake2s-128': 0xb250,
  'blake2s-136': 0xb251,
  'blake2s-144': 0xb252,
  'blake2s-152': 0xb253,
  'blake2s-160': 0xb254,
  'blake2s-168': 0xb255,
  'blake2s-176': 0xb256,
  'blake2s-184': 0xb257,
  'blake2s-192': 0xb258,
  'blake2s-200': 0xb259,
  'blake2s-208': 0xb25a,
  'blake2s-216': 0xb25b,
  'blake2s-224': 0xb25c,
  'blake2s-232': 0xb25d,
  'blake2s-240': 0xb25e,
  'blake2s-248': 0xb25f,
  'blake2s-256': 0xb260,
  'skein256-8': 0xb301,
  'skein256-16': 0xb302,
  'skein256-24': 0xb303,
  'skein256-32': 0xb304,
  'skein256-40': 0xb305,
  'skein256-48': 0xb306,
  'skein256-56': 0xb307,
  'skein256-64': 0xb308,
  'skein256-72': 0xb309,
  'skein256-80': 0xb30a,
  'skein256-88': 0xb30b,
  'skein256-96': 0xb30c,
  'skein256-104': 0xb30d,
  'skein256-112': 0xb30e,
  'skein256-120': 0xb30f,
  'skein256-128': 0xb310,
  'skein256-136': 0xb311,
  'skein256-144': 0xb312,
  'skein256-152': 0xb313,
  'skein256-160': 0xb314,
  'skein256-168': 0xb315,
  'skein256-176': 0xb316,
  'skein256-184': 0xb317,
  'skein256-192': 0xb318,
  'skein256-200': 0xb319,
  'skein256-208': 0xb31a,
  'skein256-216': 0xb31b,
  'skein256-224': 0xb31c,
  'skein256-232': 0xb31d,
  'skein256-240': 0xb31e,
  'skein256-248': 0xb31f,
  'skein256-256': 0xb320,
  'skein512-8': 0xb321,
  'skein512-16': 0xb322,
  'skein512-24': 0xb323,
  'skein512-32': 0xb324,
  'skein512-40': 0xb325,
  'skein512-48': 0xb326,
  'skein512-56': 0xb327,
  'skein512-64': 0xb328,
  'skein512-72': 0xb329,
  'skein512-80': 0xb32a,
  'skein512-88': 0xb32b,
  'skein512-96': 0xb32c,
  'skein512-104': 0xb32d,
  'skein512-112': 0xb32e,
  'skein512-120': 0xb32f,
  'skein512-128': 0xb330,
  'skein512-136': 0xb331,
  'skein512-144': 0xb332,
  'skein512-152': 0xb333,
  'skein512-160': 0xb334,
  'skein512-168': 0xb335,
  'skein512-176': 0xb336,
  'skein512-184': 0xb337,
  'skein512-192': 0xb338,
  'skein512-200': 0xb339,
  'skein512-208': 0xb33a,
  'skein512-216': 0xb33b,
  'skein512-224': 0xb33c,
  'skein512-232': 0xb33d,
  'skein512-240': 0xb33e,
  'skein512-248': 0xb33f,
  'skein512-256': 0xb340,
  'skein512-264': 0xb341,
  'skein512-272': 0xb342,
  'skein512-280': 0xb343,
  'skein512-288': 0xb344,
  'skein512-296': 0xb345,
  'skein512-304': 0xb346,
  'skein512-312': 0xb347,
  'skein512-320': 0xb348,
  'skein512-328': 0xb349,
  'skein512-336': 0xb34a,
  'skein512-344': 0xb34b,
  'skein512-352': 0xb34c,
  'skein512-360': 0xb34d,
  'skein512-368': 0xb34e,
  'skein512-376': 0xb34f,
  'skein512-384': 0xb350,
  'skein512-392': 0xb351,
  'skein512-400': 0xb352,
  'skein512-408': 0xb353,
  'skein512-416': 0xb354,
  'skein512-424': 0xb355,
  'skein512-432': 0xb356,
  'skein512-440': 0xb357,
  'skein512-448': 0xb358,
  'skein512-456': 0xb359,
  'skein512-464': 0xb35a,
  'skein512-472': 0xb35b,
  'skein512-480': 0xb35c,
  'skein512-488': 0xb35d,
  'skein512-496': 0xb35e,
  'skein512-504': 0xb35f,
  'skein512-512': 0xb360,
  'skein1024-8': 0xb361,
  'skein1024-16': 0xb362,
  'skein1024-24': 0xb363,
  'skein1024-32': 0xb364,
  'skein1024-40': 0xb365,
  'skein1024-48': 0xb366,
  'skein1024-56': 0xb367,
  'skein1024-64': 0xb368,
  'skein1024-72': 0xb369,
  'skein1024-80': 0xb36a,
  'skein1024-88': 0xb36b,
  'skein1024-96': 0xb36c,
  'skein1024-104': 0xb36d,
  'skein1024-112': 0xb36e,
  'skein1024-120': 0xb36f,
  'skein1024-128': 0xb370,
  'skein1024-136': 0xb371,
  'skein1024-144': 0xb372,
  'skein1024-152': 0xb373,
  'skein1024-160': 0xb374,
  'skein1024-168': 0xb375,
  'skein1024-176': 0xb376,
  'skein1024-184': 0xb377,
  'skein1024-192': 0xb378,
  'skein1024-200': 0xb379,
  'skein1024-208': 0xb37a,
  'skein1024-216': 0xb37b,
  'skein1024-224': 0xb37c,
  'skein1024-232': 0xb37d,
  'skein1024-240': 0xb37e,
  'skein1024-248': 0xb37f,
  'skein1024-256': 0xb380,
  'skein1024-264': 0xb381,
  'skein1024-272': 0xb382,
  'skein1024-280': 0xb383,
  'skein1024-288': 0xb384,
  'skein1024-296': 0xb385,
  'skein1024-304': 0xb386,
  'skein1024-312': 0xb387,
  'skein1024-320': 0xb388,
  'skein1024-328': 0xb389,
  'skein1024-336': 0xb38a,
  'skein1024-344': 0xb38b,
  'skein1024-352': 0xb38c,
  'skein1024-360': 0xb38d,
  'skein1024-368': 0xb38e,
  'skein1024-376': 0xb38f,
  'skein1024-384': 0xb390,
  'skein1024-392': 0xb391,
  'skein1024-400': 0xb392,
  'skein1024-408': 0xb393,
  'skein1024-416': 0xb394,
  'skein1024-424': 0xb395,
  'skein1024-432': 0xb396,
  'skein1024-440': 0xb397,
  'skein1024-448': 0xb398,
  'skein1024-456': 0xb399,
  'skein1024-464': 0xb39a,
  'skein1024-472': 0xb39b,
  'skein1024-480': 0xb39c,
  'skein1024-488': 0xb39d,
  'skein1024-496': 0xb39e,
  'skein1024-504': 0xb39f,
  'skein1024-512': 0xb3a0,
  'skein1024-520': 0xb3a1,
  'skein1024-528': 0xb3a2,
  'skein1024-536': 0xb3a3,
  'skein1024-544': 0xb3a4,
  'skein1024-552': 0xb3a5,
  'skein1024-560': 0xb3a6,
  'skein1024-568': 0xb3a7,
  'skein1024-576': 0xb3a8,
  'skein1024-584': 0xb3a9,
  'skein1024-592': 0xb3aa,
  'skein1024-600': 0xb3ab,
  'skein1024-608': 0xb3ac,
  'skein1024-616': 0xb3ad,
  'skein1024-624': 0xb3ae,
  'skein1024-632': 0xb3af,
  'skein1024-640': 0xb3b0,
  'skein1024-648': 0xb3b1,
  'skein1024-656': 0xb3b2,
  'skein1024-664': 0xb3b3,
  'skein1024-672': 0xb3b4,
  'skein1024-680': 0xb3b5,
  'skein1024-688': 0xb3b6,
  'skein1024-696': 0xb3b7,
  'skein1024-704': 0xb3b8,
  'skein1024-712': 0xb3b9,
  'skein1024-720': 0xb3ba,
  'skein1024-728': 0xb3bb,
  'skein1024-736': 0xb3bc,
  'skein1024-744': 0xb3bd,
  'skein1024-752': 0xb3be,
  'skein1024-760': 0xb3bf,
  'skein1024-768': 0xb3c0,
  'skein1024-776': 0xb3c1,
  'skein1024-784': 0xb3c2,
  'skein1024-792': 0xb3c3,
  'skein1024-800': 0xb3c4,
  'skein1024-808': 0xb3c5,
  'skein1024-816': 0xb3c6,
  'skein1024-824': 0xb3c7,
  'skein1024-832': 0xb3c8,
  'skein1024-840': 0xb3c9,
  'skein1024-848': 0xb3ca,
  'skein1024-856': 0xb3cb,
  'skein1024-864': 0xb3cc,
  'skein1024-872': 0xb3cd,
  'skein1024-880': 0xb3ce,
  'skein1024-888': 0xb3cf,
  'skein1024-896': 0xb3d0,
  'skein1024-904': 0xb3d1,
  'skein1024-912': 0xb3d2,
  'skein1024-920': 0xb3d3,
  'skein1024-928': 0xb3d4,
  'skein1024-936': 0xb3d5,
  'skein1024-944': 0xb3d6,
  'skein1024-952': 0xb3d7,
  'skein1024-960': 0xb3d8,
  'skein1024-968': 0xb3d9,
  'skein1024-976': 0xb3da,
  'skein1024-984': 0xb3db,
  'skein1024-992': 0xb3dc,
  'skein1024-1000': 0xb3dd,
  'skein1024-1008': 0xb3de,
  'skein1024-1016': 0xb3df,
  'skein1024-1024': 0xb3e0,
  'poseidon-bls12_381-a2-fc1': 0xb401,
  'poseidon-bls12_381-a2-fc1-sc': 0xb402,
  'zeroxcert-imprint-256': 0xce11,
  'fil-commitment-unsealed': 0xf101,
  'fil-commitment-sealed': 0xf102,
  'holochain-adr-v0': 0x807124,
  'holochain-adr-v1': 0x817124,
  'holochain-key-v0': 0x947124,
  'holochain-key-v1': 0x957124,
  'holochain-sig-v0': 0xa27124,
  'holochain-sig-v1': 0xa37124,
  'skynet-ns': 0xb19910
})

module.exports = { baseTable }

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\constants.js", {"./base-table":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Csrc%5Cconstants.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./generated-types').ConstantNumberMap} ConstantNumberMap */

const { baseTable } = require('./base-table')

const constants = /** @type {ConstantNumberMap} */({})

for (const [name, code] of Object.entries(baseTable)) {
  const constant = name.toUpperCase().replace(/-/g, '_')
  constants[constant] = code
}

module.exports = Object.freeze(constants)

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\constants.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\index.js", {"./constants":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\constants.js","./int-table":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\int-table.js","./print":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\print.js","./util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\util.js","./varint-table":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\varint-table.js","uint8arrays/concat":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\concat.js","varint":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Csrc%5Cindex.js
      return function (require, module, exports) {
/**
 * Implementation of the multicodec specification.
 *
 * @module multicodec
 * @example
 * const multicodec = require('multicodec')
 *
 * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)
 * // prefixedProtobuf 0x50...
 *
 */
'use strict'

/** @typedef {__import__('./generated-types').CodecName} CodecName */
/** @typedef {__import__('./generated-types').CodecNumber} CodecNumber */

const varint = require('varint')
const intTable = require('./int-table')
const codecNameToCodeVarint = require('./varint-table')
const util = require('./util')
const uint8ArrayConcat = require('uint8arrays/concat')

/**
 * Prefix a buffer with a multicodec-packed.
 *
 * @param {CodecName|Uint8Array} multicodecStrOrCode
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */
function addPrefix (multicodecStrOrCode, data) {
  let prefix

  if (multicodecStrOrCode instanceof Uint8Array) {
    prefix = util.varintUint8ArrayEncode(multicodecStrOrCode)
  } else {
    if (codecNameToCodeVarint[multicodecStrOrCode]) {
      prefix = codecNameToCodeVarint[multicodecStrOrCode]
    } else {
      throw new Error('multicodec not recognized')
    }
  }
  return uint8ArrayConcat([prefix, data], prefix.length + data.length)
}

/**
 * Decapsulate the multicodec-packed prefix from the data.
 *
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */
function rmPrefix (data) {
  varint.decode(data)
  return data.slice(varint.decode.bytes)
}

/**
 * Get the codec of the prefixed data.
 *
 * @param {Uint8Array} prefixedData
 * @returns {CodecName}
 */
function getCodec (prefixedData) {
  const code = varint.decode(prefixedData)
  const codecName = intTable.get(code)
  if (codecName === undefined) {
    throw new Error(`Code ${code} not found`)
  }
  return codecName
}

/**
 * Get the name of the codec.
 *
 * @param {CodecNumber} codec
 * @returns {CodecName|undefined}
 */
function getName (codec) {
  return intTable.get(codec)
}

/**
 * Get the code of the codec
 *
 * @param {CodecName} name
 * @returns {CodecNumber}
 */
function getNumber (name) {
  const code = codecNameToCodeVarint[name]
  if (code === undefined) {
    throw new Error('Codec `' + name + '` not found')
  }
  return varint.decode(code)
}

/**
 * Get the code of the prefixed data.
 *
 * @param {Uint8Array} prefixedData
 * @returns {CodecNumber}
 */
function getCode (prefixedData) {
  return varint.decode(prefixedData)
}

/**
 * Get the code as varint of a codec name.
 *
 * @param {CodecName} codecName
 * @returns {Uint8Array}
 */
function getCodeVarint (codecName) {
  const code = codecNameToCodeVarint[codecName]
  if (code === undefined) {
    throw new Error('Codec `' + codecName + '` not found')
  }
  return code
}

/**
 * Get the varint of a code.
 *
 * @param {CodecNumber} code
 * @returns {Array.<number>}
 */
function getVarint (code) {
  return varint.encode(code)
}

// Make the constants top-level constants
const constants = require('./constants')

// Human friendly names for printing, e.g. in error messages
const print = require('./print')

module.exports = {
  addPrefix,
  rmPrefix,
  getCodec,
  getName,
  getNumber,
  getCode,
  getCodeVarint,
  getVarint,
  print,
  ...constants
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\int-table.js", {"./base-table":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Csrc%5Cint-table.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./generated-types').CodecName} CodecName */
/** @typedef {__import__('./generated-types').CodecNumber} CodecNumber */

const { baseTable } = require('./base-table')

/**
 * @type {Map<CodecNumber,CodecName>}
 */
const nameTable = new Map()

for (const encodingName in baseTable) {
  const code = baseTable[encodingName]
  nameTable.set(code, /** @type {CodecName} */(encodingName))
}

module.exports = Object.freeze(nameTable)

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\int-table.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\print.js", {"./base-table":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Csrc%5Cprint.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./generated-types').CodecName} CodecName */
/** @typedef {__import__('./generated-types').NumberNameMap} NumberNameMap */

const { baseTable } = require('./base-table')

const tableByCode = /** @type {NumberNameMap} */({})

for (const [name, code] of Object.entries(baseTable)) {
  if (tableByCode[code] === undefined) {
    tableByCode[code] = /** @type {CodecName} **/(name)
  }
}

module.exports = /** @type {NumberNameMap} */(Object.freeze(tableByCode))

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\print.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\util.js", {"uint8arrays/from-string":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\from-string.js","uint8arrays/to-string":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\to-string.js","varint":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Csrc%5Cutil.js
      return function (require, module, exports) {
'use strict'

const varint = require('varint')
const uint8ArrayToString = require('uint8arrays/to-string')
const uint8ArrayFromString = require('uint8arrays/from-string')

module.exports = {
  numberToUint8Array,
  uint8ArrayToNumber,
  varintUint8ArrayEncode,
  varintEncode
}

function uint8ArrayToNumber (buf) {
  return parseInt(uint8ArrayToString(buf, 'base16'), 16)
}

function numberToUint8Array (num) {
  let hexString = num.toString(16)
  if (hexString.length % 2 === 1) {
    hexString = '0' + hexString
  }
  return uint8ArrayFromString(hexString, 'base16')
}

function varintUint8ArrayEncode (input) {
  return Uint8Array.from(varint.encode(uint8ArrayToNumber(input)))
}

function varintEncode (num) {
  return Uint8Array.from(varint.encode(num))
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\util.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\varint-table.js", {"./base-table":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js","./util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Csrc%5Cvarint-table.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./generated-types').NameUint8ArrayMap} NameUint8ArrayMap */

const { baseTable } = require('./base-table')
const varintEncode = require('./util').varintEncode

const varintTable = /** @type {NameUint8ArrayMap} */ ({})

for (const encodingName in baseTable) {
  const code = baseTable[encodingName]
  varintTable[encodingName] = varintEncode(code)
}

module.exports = Object.freeze(varintTable)

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\varint-table.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\base.js", {"buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cbase.js
      return function (require, module, exports) {
// @ts-check
'use strict'
const { Buffer } = require('buffer')

/**
 * @typedef {Object} Codec
 * @property {function(Uint8Array):string} encode
 * @property {function(string):Uint8Array} decode
 *
 * @typedef {function(string):Codec} CodecFactory
 */

class Base {
  /**
   * @param {string} name
   * @param {string} code
   * @param {CodecFactory} implementation
   * @param {string} alphabet
   */
  constructor (name, code, implementation, alphabet) {
    this.name = name
    this.code = code
    this.codeBuf = Buffer.from(this.code)
    this.alphabet = alphabet
    this.engine = implementation(alphabet)
  }

  /**
   * @param {Uint8Array} buf
   * @returns {string}
   */
  encode (buf) {
    return this.engine.encode(buf)
  }

  /**
   * @param {string} string
   * @returns {Uint8Array}
   */
  decode (string) {
    for (const char of string) {
      if (this.alphabet && this.alphabet.indexOf(char) < 0) {
        throw new Error(`invalid character '${char}' in '${string}'`)
      }
    }
    return this.engine.decode(string)
  }
}

module.exports = Base

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\base.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\constants.js", {"./base.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\base.js","./rfc4648":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\rfc4648.js","./util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\util.js","base-x":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\base-x\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cconstants.js
      return function (require, module, exports) {
// @ts-check
'use strict'

const baseX = require('base-x')
const Base = require('./base.js')
const rfc4648 = require('./rfc4648')
const { decodeText, encodeText } = require('./util')

const identity = () => {
  return {
    encode: decodeText,
    decode: encodeText
  }
}

/**
 * @typedef {__import__('./base').CodecFactory} CodecFactory
 *
 * name, code, implementation, alphabet
 * @type {Array<[string, string, CodecFactory, string]>}
 */
const constants = [
  ['identity', '\x00', identity, ''],
  ['base2', '0', rfc4648(1), '01'],
  ['base8', '7', rfc4648(3), '01234567'],
  ['base10', '9', baseX, '0123456789'],
  ['base16', 'f', rfc4648(4), '0123456789abcdef'],
  ['base16upper', 'F', rfc4648(4), '0123456789ABCDEF'],
  ['base32hex', 'v', rfc4648(5), '0123456789abcdefghijklmnopqrstuv'],
  ['base32hexupper', 'V', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV'],
  ['base32hexpad', 't', rfc4648(5), '0123456789abcdefghijklmnopqrstuv='],
  ['base32hexpadupper', 'T', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV='],
  ['base32', 'b', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567'],
  ['base32upper', 'B', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'],
  ['base32pad', 'c', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567='],
  ['base32padupper', 'C', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567='],
  ['base32z', 'h', rfc4648(5), 'ybndrfg8ejkmcpqxot1uwisza345h769'],
  ['base36', 'k', baseX, '0123456789abcdefghijklmnopqrstuvwxyz'],
  ['base36upper', 'K', baseX, '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'],
  ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
  ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
  ['base64', 'm', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
  ['base64pad', 'M', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
  ['base64url', 'u', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
  ['base64urlpad', 'U', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
]

const names = constants.reduce((prev, tupple) => {
  prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])
  return prev
}, {})

const codes = constants.reduce((prev, tupple) => {
  prev[tupple[1]] = names[tupple[0]]
  return prev
}, {})

module.exports = {
  names,
  codes
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\constants.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\index.js", {"./constants":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\constants.js","./util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\util.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cindex.js
      return function (require, module, exports) {
// @ts-check
/**
 * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
 *
 * @module Multibase
 */
'use strict'

const { Buffer } = require('buffer')
const constants = require('./constants')
const { decodeText, asBuffer } = require('./util')

/** @typedef {__import__("./base")} Base */

/**
 * Create a new buffer with the multibase varint+code.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Uint8Array} buf - The data to be prefixed with multibase.
 * @returns {Buffer}
 * @throws {Error} Will throw if the encoding is not supported
 */
function multibase (nameOrCode, buf) {
  if (!buf) {
    throw new Error('requires an encoded buffer')
  }
  const { name, codeBuf } = encoding(nameOrCode)
  validEncode(name, buf)

  const buffer = Buffer.alloc(codeBuf.length + buf.length)
  buffer.set(codeBuf, 0)
  buffer.set(buf, codeBuf.length)

  return buffer
}

/**
 * Encode data with the specified base and add the multibase prefix.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Uint8Array} buf - The data to be encoded.
 * @returns {Buffer}
 * @throws {Error} Will throw if the encoding is not supported
 *
 */
function encode (nameOrCode, buf) {
  const enc = encoding(nameOrCode)

  return Buffer.concat([enc.codeBuf, Buffer.from(enc.encode(buf))])
}

/**
 * Takes a Uint8Array or string encoded with multibase header, decodes it and
 * returns the decoded buffer
 *
 * @param {Uint8Array|string} data
 * @returns {Buffer}
 * @throws {Error} Will throw if the encoding is not supported
 *
 */
function decode (data) {
  if (ArrayBuffer.isView(data)) {
    data = decodeText(data)
  }
  const prefix = data[0]

  // Make all encodings case-insensitive except the ones that include upper and lower chars in the alphabet
  if (['f', 'F', 'v', 'V', 't', 'T', 'b', 'B', 'c', 'C', 'h', 'k', 'K'].includes(prefix)) {
    data = data.toLowerCase()
  }
  const enc = encoding(data[0])
  return asBuffer(enc.decode(data.substring(1)))
}

/**
 * Is the given data multibase encoded?
 *
 * @param {Uint8Array|string} data
 * @returns {false|string}
 */
function isEncoded (data) {
  if (data instanceof Uint8Array) {
    data = decodeText(data)
  }

  // Ensure bufOrString is a string
  if (Object.prototype.toString.call(data) !== '[object String]') {
    return false
  }

  try {
    const enc = encoding(data[0])
    return enc.name
  } catch (err) {
    return false
  }
}

/**
 * Validate encoded data
 *
 * @param {string} name
 * @param {Uint8Array} buf
 * @returns {void}
 * @throws {Error} Will throw if the encoding is not supported
 */
function validEncode (name, buf) {
  const enc = encoding(name)
  enc.decode(decodeText(buf))
}

/**
 * Get the encoding by name or code
 *
 * @param {string|number} nameOrCode
 * @returns {Base}
 * @throws {Error} Will throw if the encoding is not supported
 */
function encoding (nameOrCode) {
  if (constants.names[nameOrCode]) {
    return constants.names[nameOrCode]
  } else if (constants.codes[nameOrCode]) {
    return constants.codes[nameOrCode]
  } else {
    throw new Error(`Unsupported encoding: ${nameOrCode}`)
  }
}

/**
 * Get encoding from data
 *
 * @param {string|Uint8Array} data
 * @returns {Base}
 * @throws {Error} Will throw if the encoding is not supported
 */
function encodingFromData (data) {
  if (data instanceof Uint8Array) {
    data = decodeText(data)
  }

  return encoding(data[0])
}

exports = module.exports = multibase
exports.encode = encode
exports.decode = decode
exports.isEncoded = isEncoded
exports.encoding = encoding
exports.encodingFromData = encodingFromData
exports.names = Object.freeze(constants.names)
exports.codes = Object.freeze(constants.codes)

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\rfc4648.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Crfc4648.js
      return function (require, module, exports) {
// @ts-check
'use strict'

/** @typedef {__import__('./base').CodecFactory} CodecFactory */

/**
 * @param {string} string
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {Uint8Array}
 */
const decode = (string, alphabet, bitsPerChar) => {
  // Build the character lookup table:
  const codes = {}
  for (let i = 0; i < alphabet.length; ++i) {
    codes[alphabet[i]] = i
  }

  // Count the padding bytes:
  let end = string.length
  while (string[end - 1] === '=') {
    --end
  }

  // Allocate the output:
  const out = new Uint8Array((end * bitsPerChar / 8) | 0)

  // Parse the data:
  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  let written = 0 // Next byte to write
  for (let i = 0; i < end; ++i) {
    // Read one character from the string:
    const value = codes[string[i]]
    if (value === undefined) {
      throw new SyntaxError('Invalid character ' + string[i])
    }

    // Append the bits to the buffer:
    buffer = (buffer << bitsPerChar) | value
    bits += bitsPerChar

    // Write out some bits if the buffer has a byte's worth:
    if (bits >= 8) {
      bits -= 8
      out[written++] = 0xff & (buffer >> bits)
    }
  }

  // Verify that we have received just enough bits:
  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {
    throw new SyntaxError('Unexpected end of data')
  }

  return out
}

/**
 * @param {Uint8Array} data
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {string}
 */
const encode = (data, alphabet, bitsPerChar) => {
  const pad = alphabet[alphabet.length - 1] === '='
  const mask = (1 << bitsPerChar) - 1
  let out = ''

  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  for (let i = 0; i < data.length; ++i) {
    // Slurp data into the buffer:
    buffer = (buffer << 8) | data[i]
    bits += 8

    // Write out as much as we can:
    while (bits > bitsPerChar) {
      bits -= bitsPerChar
      out += alphabet[mask & (buffer >> bits)]
    }
  }

  // Partial character:
  if (bits) {
    out += alphabet[mask & (buffer << (bitsPerChar - bits))]
  }

  // Add padding characters until we hit a byte boundary:
  if (pad) {
    while ((out.length * bitsPerChar) & 7) {
      out += '='
    }
  }

  return out
}

/**
 * @param {number} bitsPerChar
 * @returns {CodecFactory}
 */
module.exports = (bitsPerChar) => (alphabet) => {
  return {
    /**
     * @param {Uint8Array} input
     * @returns {string}
     */
    encode (input) {
      return encode(input, alphabet, bitsPerChar)
    },
    /**
     * @param {string} input
     * @returns {Uint8Array}
     */
    decode (input) {
      return decode(input, alphabet, bitsPerChar)
    }
  }
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\rfc4648.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\util.js", {"buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js","web-encoding":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\web-encoding\\src\\lib.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cutil.js
      return function (require, module, exports) {
// @ts-check
'use strict'

const { Buffer } = require('buffer')
const { TextEncoder, TextDecoder } = require('web-encoding')

const textDecoder = new TextDecoder()
/**
 * @param {ArrayBufferView|ArrayBuffer} bytes
 * @returns {string}
 */
const decodeText = (bytes) => textDecoder.decode(bytes)

const textEncoder = new TextEncoder()
/**
 * @param {string} text
 * @returns {Uint8Array}
 */
const encodeText = (text) => textEncoder.encode(text)

/**
 * @param {ArrayBufferView} bytes
 * @returns {Buffer}
 */
const asBuffer = ({ buffer, byteLength, byteOffset }) =>
  Buffer.from(buffer, byteOffset, byteLength)

module.exports = { decodeText, encodeText, asBuffer }

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\util.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\constants.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultihashes%5Csrc%5Cconstants.js
      return function (require, module, exports) {
/* eslint quote-props: off */
'use strict'

const names = Object.freeze({
  'identity': 0x00,
  'sha1': 0x11,
  'sha2-256': 0x12,
  'sha2-512': 0x13,
  'sha3-512': 0x14,
  'sha3-384': 0x15,
  'sha3-256': 0x16,
  'sha3-224': 0x17,
  'shake-128': 0x18,
  'shake-256': 0x19,
  'keccak-224': 0x1a,
  'keccak-256': 0x1b,
  'keccak-384': 0x1c,
  'keccak-512': 0x1d,
  'blake3': 0x1e,
  'murmur3-128': 0x22,
  'murmur3-32': 0x23,
  'dbl-sha2-256': 0x56,
  'md4': 0xd4,
  'md5': 0xd5,
  'bmt': 0xd6,
  'sha2-256-trunc254-padded': 0x1012,
  'ripemd-128': 0x1052,
  'ripemd-160': 0x1053,
  'ripemd-256': 0x1054,
  'ripemd-320': 0x1055,
  'x11': 0x1100,
  'sm3-256': 0x534d,
  'blake2b-8': 0xb201,
  'blake2b-16': 0xb202,
  'blake2b-24': 0xb203,
  'blake2b-32': 0xb204,
  'blake2b-40': 0xb205,
  'blake2b-48': 0xb206,
  'blake2b-56': 0xb207,
  'blake2b-64': 0xb208,
  'blake2b-72': 0xb209,
  'blake2b-80': 0xb20a,
  'blake2b-88': 0xb20b,
  'blake2b-96': 0xb20c,
  'blake2b-104': 0xb20d,
  'blake2b-112': 0xb20e,
  'blake2b-120': 0xb20f,
  'blake2b-128': 0xb210,
  'blake2b-136': 0xb211,
  'blake2b-144': 0xb212,
  'blake2b-152': 0xb213,
  'blake2b-160': 0xb214,
  'blake2b-168': 0xb215,
  'blake2b-176': 0xb216,
  'blake2b-184': 0xb217,
  'blake2b-192': 0xb218,
  'blake2b-200': 0xb219,
  'blake2b-208': 0xb21a,
  'blake2b-216': 0xb21b,
  'blake2b-224': 0xb21c,
  'blake2b-232': 0xb21d,
  'blake2b-240': 0xb21e,
  'blake2b-248': 0xb21f,
  'blake2b-256': 0xb220,
  'blake2b-264': 0xb221,
  'blake2b-272': 0xb222,
  'blake2b-280': 0xb223,
  'blake2b-288': 0xb224,
  'blake2b-296': 0xb225,
  'blake2b-304': 0xb226,
  'blake2b-312': 0xb227,
  'blake2b-320': 0xb228,
  'blake2b-328': 0xb229,
  'blake2b-336': 0xb22a,
  'blake2b-344': 0xb22b,
  'blake2b-352': 0xb22c,
  'blake2b-360': 0xb22d,
  'blake2b-368': 0xb22e,
  'blake2b-376': 0xb22f,
  'blake2b-384': 0xb230,
  'blake2b-392': 0xb231,
  'blake2b-400': 0xb232,
  'blake2b-408': 0xb233,
  'blake2b-416': 0xb234,
  'blake2b-424': 0xb235,
  'blake2b-432': 0xb236,
  'blake2b-440': 0xb237,
  'blake2b-448': 0xb238,
  'blake2b-456': 0xb239,
  'blake2b-464': 0xb23a,
  'blake2b-472': 0xb23b,
  'blake2b-480': 0xb23c,
  'blake2b-488': 0xb23d,
  'blake2b-496': 0xb23e,
  'blake2b-504': 0xb23f,
  'blake2b-512': 0xb240,
  'blake2s-8': 0xb241,
  'blake2s-16': 0xb242,
  'blake2s-24': 0xb243,
  'blake2s-32': 0xb244,
  'blake2s-40': 0xb245,
  'blake2s-48': 0xb246,
  'blake2s-56': 0xb247,
  'blake2s-64': 0xb248,
  'blake2s-72': 0xb249,
  'blake2s-80': 0xb24a,
  'blake2s-88': 0xb24b,
  'blake2s-96': 0xb24c,
  'blake2s-104': 0xb24d,
  'blake2s-112': 0xb24e,
  'blake2s-120': 0xb24f,
  'blake2s-128': 0xb250,
  'blake2s-136': 0xb251,
  'blake2s-144': 0xb252,
  'blake2s-152': 0xb253,
  'blake2s-160': 0xb254,
  'blake2s-168': 0xb255,
  'blake2s-176': 0xb256,
  'blake2s-184': 0xb257,
  'blake2s-192': 0xb258,
  'blake2s-200': 0xb259,
  'blake2s-208': 0xb25a,
  'blake2s-216': 0xb25b,
  'blake2s-224': 0xb25c,
  'blake2s-232': 0xb25d,
  'blake2s-240': 0xb25e,
  'blake2s-248': 0xb25f,
  'blake2s-256': 0xb260,
  'skein256-8': 0xb301,
  'skein256-16': 0xb302,
  'skein256-24': 0xb303,
  'skein256-32': 0xb304,
  'skein256-40': 0xb305,
  'skein256-48': 0xb306,
  'skein256-56': 0xb307,
  'skein256-64': 0xb308,
  'skein256-72': 0xb309,
  'skein256-80': 0xb30a,
  'skein256-88': 0xb30b,
  'skein256-96': 0xb30c,
  'skein256-104': 0xb30d,
  'skein256-112': 0xb30e,
  'skein256-120': 0xb30f,
  'skein256-128': 0xb310,
  'skein256-136': 0xb311,
  'skein256-144': 0xb312,
  'skein256-152': 0xb313,
  'skein256-160': 0xb314,
  'skein256-168': 0xb315,
  'skein256-176': 0xb316,
  'skein256-184': 0xb317,
  'skein256-192': 0xb318,
  'skein256-200': 0xb319,
  'skein256-208': 0xb31a,
  'skein256-216': 0xb31b,
  'skein256-224': 0xb31c,
  'skein256-232': 0xb31d,
  'skein256-240': 0xb31e,
  'skein256-248': 0xb31f,
  'skein256-256': 0xb320,
  'skein512-8': 0xb321,
  'skein512-16': 0xb322,
  'skein512-24': 0xb323,
  'skein512-32': 0xb324,
  'skein512-40': 0xb325,
  'skein512-48': 0xb326,
  'skein512-56': 0xb327,
  'skein512-64': 0xb328,
  'skein512-72': 0xb329,
  'skein512-80': 0xb32a,
  'skein512-88': 0xb32b,
  'skein512-96': 0xb32c,
  'skein512-104': 0xb32d,
  'skein512-112': 0xb32e,
  'skein512-120': 0xb32f,
  'skein512-128': 0xb330,
  'skein512-136': 0xb331,
  'skein512-144': 0xb332,
  'skein512-152': 0xb333,
  'skein512-160': 0xb334,
  'skein512-168': 0xb335,
  'skein512-176': 0xb336,
  'skein512-184': 0xb337,
  'skein512-192': 0xb338,
  'skein512-200': 0xb339,
  'skein512-208': 0xb33a,
  'skein512-216': 0xb33b,
  'skein512-224': 0xb33c,
  'skein512-232': 0xb33d,
  'skein512-240': 0xb33e,
  'skein512-248': 0xb33f,
  'skein512-256': 0xb340,
  'skein512-264': 0xb341,
  'skein512-272': 0xb342,
  'skein512-280': 0xb343,
  'skein512-288': 0xb344,
  'skein512-296': 0xb345,
  'skein512-304': 0xb346,
  'skein512-312': 0xb347,
  'skein512-320': 0xb348,
  'skein512-328': 0xb349,
  'skein512-336': 0xb34a,
  'skein512-344': 0xb34b,
  'skein512-352': 0xb34c,
  'skein512-360': 0xb34d,
  'skein512-368': 0xb34e,
  'skein512-376': 0xb34f,
  'skein512-384': 0xb350,
  'skein512-392': 0xb351,
  'skein512-400': 0xb352,
  'skein512-408': 0xb353,
  'skein512-416': 0xb354,
  'skein512-424': 0xb355,
  'skein512-432': 0xb356,
  'skein512-440': 0xb357,
  'skein512-448': 0xb358,
  'skein512-456': 0xb359,
  'skein512-464': 0xb35a,
  'skein512-472': 0xb35b,
  'skein512-480': 0xb35c,
  'skein512-488': 0xb35d,
  'skein512-496': 0xb35e,
  'skein512-504': 0xb35f,
  'skein512-512': 0xb360,
  'skein1024-8': 0xb361,
  'skein1024-16': 0xb362,
  'skein1024-24': 0xb363,
  'skein1024-32': 0xb364,
  'skein1024-40': 0xb365,
  'skein1024-48': 0xb366,
  'skein1024-56': 0xb367,
  'skein1024-64': 0xb368,
  'skein1024-72': 0xb369,
  'skein1024-80': 0xb36a,
  'skein1024-88': 0xb36b,
  'skein1024-96': 0xb36c,
  'skein1024-104': 0xb36d,
  'skein1024-112': 0xb36e,
  'skein1024-120': 0xb36f,
  'skein1024-128': 0xb370,
  'skein1024-136': 0xb371,
  'skein1024-144': 0xb372,
  'skein1024-152': 0xb373,
  'skein1024-160': 0xb374,
  'skein1024-168': 0xb375,
  'skein1024-176': 0xb376,
  'skein1024-184': 0xb377,
  'skein1024-192': 0xb378,
  'skein1024-200': 0xb379,
  'skein1024-208': 0xb37a,
  'skein1024-216': 0xb37b,
  'skein1024-224': 0xb37c,
  'skein1024-232': 0xb37d,
  'skein1024-240': 0xb37e,
  'skein1024-248': 0xb37f,
  'skein1024-256': 0xb380,
  'skein1024-264': 0xb381,
  'skein1024-272': 0xb382,
  'skein1024-280': 0xb383,
  'skein1024-288': 0xb384,
  'skein1024-296': 0xb385,
  'skein1024-304': 0xb386,
  'skein1024-312': 0xb387,
  'skein1024-320': 0xb388,
  'skein1024-328': 0xb389,
  'skein1024-336': 0xb38a,
  'skein1024-344': 0xb38b,
  'skein1024-352': 0xb38c,
  'skein1024-360': 0xb38d,
  'skein1024-368': 0xb38e,
  'skein1024-376': 0xb38f,
  'skein1024-384': 0xb390,
  'skein1024-392': 0xb391,
  'skein1024-400': 0xb392,
  'skein1024-408': 0xb393,
  'skein1024-416': 0xb394,
  'skein1024-424': 0xb395,
  'skein1024-432': 0xb396,
  'skein1024-440': 0xb397,
  'skein1024-448': 0xb398,
  'skein1024-456': 0xb399,
  'skein1024-464': 0xb39a,
  'skein1024-472': 0xb39b,
  'skein1024-480': 0xb39c,
  'skein1024-488': 0xb39d,
  'skein1024-496': 0xb39e,
  'skein1024-504': 0xb39f,
  'skein1024-512': 0xb3a0,
  'skein1024-520': 0xb3a1,
  'skein1024-528': 0xb3a2,
  'skein1024-536': 0xb3a3,
  'skein1024-544': 0xb3a4,
  'skein1024-552': 0xb3a5,
  'skein1024-560': 0xb3a6,
  'skein1024-568': 0xb3a7,
  'skein1024-576': 0xb3a8,
  'skein1024-584': 0xb3a9,
  'skein1024-592': 0xb3aa,
  'skein1024-600': 0xb3ab,
  'skein1024-608': 0xb3ac,
  'skein1024-616': 0xb3ad,
  'skein1024-624': 0xb3ae,
  'skein1024-632': 0xb3af,
  'skein1024-640': 0xb3b0,
  'skein1024-648': 0xb3b1,
  'skein1024-656': 0xb3b2,
  'skein1024-664': 0xb3b3,
  'skein1024-672': 0xb3b4,
  'skein1024-680': 0xb3b5,
  'skein1024-688': 0xb3b6,
  'skein1024-696': 0xb3b7,
  'skein1024-704': 0xb3b8,
  'skein1024-712': 0xb3b9,
  'skein1024-720': 0xb3ba,
  'skein1024-728': 0xb3bb,
  'skein1024-736': 0xb3bc,
  'skein1024-744': 0xb3bd,
  'skein1024-752': 0xb3be,
  'skein1024-760': 0xb3bf,
  'skein1024-768': 0xb3c0,
  'skein1024-776': 0xb3c1,
  'skein1024-784': 0xb3c2,
  'skein1024-792': 0xb3c3,
  'skein1024-800': 0xb3c4,
  'skein1024-808': 0xb3c5,
  'skein1024-816': 0xb3c6,
  'skein1024-824': 0xb3c7,
  'skein1024-832': 0xb3c8,
  'skein1024-840': 0xb3c9,
  'skein1024-848': 0xb3ca,
  'skein1024-856': 0xb3cb,
  'skein1024-864': 0xb3cc,
  'skein1024-872': 0xb3cd,
  'skein1024-880': 0xb3ce,
  'skein1024-888': 0xb3cf,
  'skein1024-896': 0xb3d0,
  'skein1024-904': 0xb3d1,
  'skein1024-912': 0xb3d2,
  'skein1024-920': 0xb3d3,
  'skein1024-928': 0xb3d4,
  'skein1024-936': 0xb3d5,
  'skein1024-944': 0xb3d6,
  'skein1024-952': 0xb3d7,
  'skein1024-960': 0xb3d8,
  'skein1024-968': 0xb3d9,
  'skein1024-976': 0xb3da,
  'skein1024-984': 0xb3db,
  'skein1024-992': 0xb3dc,
  'skein1024-1000': 0xb3dd,
  'skein1024-1008': 0xb3de,
  'skein1024-1016': 0xb3df,
  'skein1024-1024': 0xb3e0,
  'poseidon-bls12_381-a2-fc1': 0xb401,
  'poseidon-bls12_381-a2-fc1-sc': 0xb402
})

module.exports = { names }

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\constants.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\index.js", {"./constants":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\constants.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js","multibase":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\index.js","varint":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\varint\\index.js","web-encoding":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\web-encoding\\src\\lib.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultihashes%5Csrc%5Cindex.js
      return function (require, module, exports) {
// @ts-check
/* eslint-disable guard-for-in */
/**
 * Multihash implementation in JavaScript.
 *
 * @module multihash
 */
'use strict'

const { Buffer } = require('buffer')
const multibase = require('multibase')
const varint = require('varint')
const { names } = require('./constants')
const { TextDecoder } = require('web-encoding')

const textDecoder = new TextDecoder()
const codes = {}

for (const key in names) {
  codes[names[key]] = key
}
exports.names = names
exports.codes = Object.freeze(codes)

/**
 * Convert the given multihash to a hex encoded string.
 *
 * @param {Uint8Array} hash
 * @returns {string}
 */
exports.toHexString = function toHexString (hash) {
  if (!(hash instanceof Uint8Array)) {
    throw new Error('must be passed a Uint8Array')
  }

  const buffer = Buffer.isBuffer(hash)
    ? hash
    : Buffer.from(hash.buffer, hash.byteOffset, hash.byteLength)

  return buffer.toString('hex')
}

/**
 * Convert the given hex encoded string to a multihash.
 *
 * @param {string} hash
 * @returns {Buffer}
 */
exports.fromHexString = function fromHexString (hash) {
  return Buffer.from(hash, 'hex')
}

/**
 * Convert the given multihash to a base58 encoded string.
 *
 * @param {Uint8Array} hash
 * @returns {string}
 */
exports.toB58String = function toB58String (hash) {
  if (!(hash instanceof Uint8Array)) {
    throw new Error('must be passed a Uint8Array')
  }

  return textDecoder.decode(multibase.encode('base58btc', hash)).slice(1)
}

/**
 * Convert the given base58 encoded string to a multihash.
 *
 * @param {string|Uint8Array} hash
 * @returns {Buffer}
 */
exports.fromB58String = function fromB58String (hash) {
  const encoded = hash instanceof Uint8Array
    ? textDecoder.decode(hash)
    : hash

  return multibase.decode('z' + encoded)
}

/**
 * Decode a hash from the given multihash.
 *
 * @param {Uint8Array} bytes
 * @returns {{code: number, name: string, length: number, digest: Buffer}} result
 */
exports.decode = function decode (bytes) {
  if (!(bytes instanceof Uint8Array)) {
    throw new Error('multihash must be a Uint8Array')
  }
  let buf = Buffer.isBuffer(bytes)
    ? bytes
    : Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength)

  if (buf.length < 2) {
    throw new Error('multihash too short. must be > 2 bytes.')
  }

  const code = varint.decode(buf)
  if (!exports.isValidCode(code)) {
    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)
  }
  buf = buf.slice(varint.decode.bytes)

  const len = varint.decode(buf)
  if (len < 0) {
    throw new Error(`multihash invalid length: ${len}`)
  }
  buf = buf.slice(varint.decode.bytes)

  if (buf.length !== len) {
    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`)
  }

  return {
    code,
    name: codes[code],
    length: len,
    digest: buf
  }
}

/**
 *  Encode a hash digest along with the specified function code.
 *
 * > **Note:** the length is derived from the length of the digest itself.
 *
 * @param {Uint8Array} digest
 * @param {string|number} code
 * @param {number} [length]
 * @returns {Buffer}
 */
exports.encode = function encode (digest, code, length) {
  if (!digest || code === undefined) {
    throw new Error('multihash encode requires at least two args: digest, code')
  }

  // ensure it's a hashfunction code.
  const hashfn = exports.coerceCode(code)

  if (!(digest instanceof Uint8Array)) {
    throw new Error('digest should be a Uint8Array')
  }

  if (length == null) {
    length = digest.length
  }

  if (length && digest.length !== length) {
    throw new Error('digest length should be equal to specified length.')
  }

  const hash = varint.encode(hashfn)
  const len = varint.encode(length)
  const buffer = Buffer.alloc(hash.length + len.length + digest.length)
  buffer.set(hash, 0)
  buffer.set(len, hash.length)
  buffer.set(digest, hash.length + len.length)
  return buffer
}

/**
 * Converts a hash function name into the matching code.
 * If passed a number it will return the number if it's a valid code.
 * @param {string|number} name
 * @returns {number}
 */
exports.coerceCode = function coerceCode (name) {
  let code = name

  if (typeof name === 'string') {
    if (names[name] === undefined) {
      throw new Error(`Unrecognized hash function named: ${name}`)
    }
    code = names[name]
  }

  if (typeof code !== 'number') {
    throw new Error(`Hash function code should be a number. Got: ${code}`)
  }

  if (codes[code] === undefined && !exports.isAppCode(code)) {
    throw new Error(`Unrecognized function code: ${code}`)
  }

  return code
}

/**
 * Checks wether a code is part of the app range
 *
 * @param {number} code
 * @returns {boolean}
 */
exports.isAppCode = function appCode (code) {
  return code > 0 && code < 0x10
}

/**
 * Checks whether a multihash code is valid.
 *
 * @param {number} code
 * @returns {boolean}
 */
exports.isValidCode = function validCode (code) {
  if (exports.isAppCode(code)) {
    return true
  }

  if (codes[code]) {
    return true
  }

  return false
}

/**
 * Check if the given buffer is a valid multihash. Throws an error if it is not valid.
 *
 * @param {Uint8Array} multihash
 * @returns {void}
 * @throws {Error}
 */
function validate (multihash) {
  exports.decode(multihash) // throws if bad.
}
exports.validate = validate

/**
 * Returns a prefix from a valid multihash. Throws an error if it is not valid.
 *
 * @param {Uint8Array} multihash
 * @returns {Buffer}
 * @throws {Error}
 */
exports.prefix = function prefix (multihash) {
  validate(multihash)

  return Buffer.from(multihash.buffer, multihash.byteOffset, 2)
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\concat.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cuint8arrays%5Cconcat.js
      return function (require, module, exports) {
'use strict'

/**
 * Returns a new Uint8Array created by concatenating the passed ArrayLikes
 *
 * @param {Array<ArrayLike<number>>} arrays
 * @param {Number} length
 * @returns {Uint8Array}
 */
function concat (arrays, length) {
  if (!length) {
    length = arrays.reduce((acc, curr) => acc + curr.length, 0)
  }

  const output = new Uint8Array(length)
  let offset = 0

  for (const arr of arrays) {
    output.set(arr, offset)
    offset += arr.length
  }

  return output
}

module.exports = concat

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>uint8arrays",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\concat.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\from-string.js", {"multibase/src/constants":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\constants.js","web-encoding":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\web-encoding\\src\\lib.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cuint8arrays%5Cfrom-string.js
      return function (require, module, exports) {
'use strict'

const { names } = require('multibase/src/constants')
const { TextEncoder } = require('web-encoding')
const utf8Encoder = new TextEncoder()

/**
 * Interperets each character in a string as a byte and
 * returns a Uint8Array of those bytes.
 *
 * @param {String} string The string to turn into an array
 * @returns {Uint8Array}
 */
function asciiStringToUint8Array (string) {
  const array = new Uint8Array(string.length)

  for (let i = 0; i < string.length; i++) {
    array[i] = string.charCodeAt(i)
  }

  return array
}

/**
 * Create a `Uint8Array` from the passed string
 *
 * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 *
 * @param {String} string
 * @param {String} [encoding=utf8] utf8, base16, base64, base64urlpad, etc
 * @returns {Uint8Array}
 * @see {@link https://www.npmjs.com/package/multibase|multibase} for supported encodings other than `utf8`
 */
function fromString (string, encoding = 'utf8') {
  if (encoding === 'utf8' || encoding === 'utf-8') {
    return utf8Encoder.encode(string)
  }

  if (encoding === 'ascii') {
    return asciiStringToUint8Array(string)
  }

  const codec = names[encoding]

  if (!codec) {
    throw new Error('Unknown base')
  }

  return codec.decode(string)
}

module.exports = fromString

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>uint8arrays",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\from-string.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\to-string.js", {"multibase/src/constants":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\constants.js","web-encoding":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\web-encoding\\src\\lib.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cuint8arrays%5Cto-string.js
      return function (require, module, exports) {
'use strict'

const { names } = require('multibase/src/constants')
const { TextDecoder } = require('web-encoding')
const utf8Decoder = new TextDecoder('utf8')

/**
 * Turns a Uint8Array of bytes into a string with each
 * character being the char code of the corresponding byte
 *
 * @param {Uint8Array} array The array to turn into a string
 * @returns {String}
 */
function uint8ArrayToAsciiString (array) {
  let string = ''

  for (let i = 0; i < array.length; i++) {
    string += String.fromCharCode(array[i])
  }
  return string
}

/**
 * Turns a `Uint8Array` into a string.
 *
 * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 *
 * @param {Uint8Array} array The array to turn into a string
 * @param {String} [encoding=utf8] The encoding to use
 * @returns {String}
 * @see {@link https://www.npmjs.com/package/multibase|multibase} for supported encodings other than `utf8`
 */
function toString (array, encoding = 'utf8') {
  if (encoding === 'utf8' || encoding === 'utf-8') {
    return utf8Decoder.decode(array)
  }

  if (encoding === 'ascii') {
    return uint8ArrayToAsciiString(array)
  }

  const codec = names[encoding]

  if (!codec) {
    throw new Error('Unknown base')
  }

  return codec.encode(array)
}

module.exports = toString

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>uint8arrays",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\to-string.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\src\\helpers.js", {"cids":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\cids\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Csrc%5Chelpers.js
      return function (require, module, exports) {
/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const CID = require('cids');

// Label's max length in DNS (https://tools.ietf.org/html/rfc1034#page-7)
const dnsLabelMaxLength = 63;

/**
 * Take any ipfsHash and convert it to DNS-compatible CID
 * @param {string} ipfsHash a regular ipfs hash either a cid v0 or v1
 * @return {string} the resulting ipfs hash as a cid v1
 */
const cidForWeb = (ipfsHash) => {
	let cid = new CID(ipfsHash);
	if (cid.version === 0) {
		cid = cid.toV1();
	}
  let dnsLabel = cid.toString('base32');
  if (dnsLabel.length > dnsLabelMaxLength) {
    const b36 = cid.toString('base36');
    if (b36.length <= dnsLabelMaxLength) {
      return b36;
    }
    throw new TypeError ('CID is longer than DNS limit of 63 characters and is not compatible with public gateways');
  }
	return dnsLabel;
}

exports.cidForWeb = cidForWeb;


/**
 * Take any ipfsHash and convert it to a CID v1 encoded in base32.
 * @param {string} ipfsHash a regular ipfs hash either a cid v0 or v1 (v1 will remain unchanged)
 * @return {string} the resulting ipfs hash as a cid v1
 */
const cidV0ToV1Base32 = (ipfsHash) => {
	let cid = new CID(ipfsHash);
	if (cid.version === 0) {
		cid = cid.toV1();
	}
	return cid.toString('base32');
}

exports.cidV0ToV1Base32 = cidV0ToV1Base32;

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash",file:"node_modules\\@ensdomains\\content-hash\\src\\helpers.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\src\\index.js", {"./helpers":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\src\\helpers.js","./profiles":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\src\\profiles.js","multicodec":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\index.js","multihashes":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Csrc%5Cindex.js
      return function (require, module, exports) {
/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const multiC = require('multicodec');
const multiH = require('multihashes');

const { hexStringToBuffer, profiles } = require('./profiles');
const { cidForWeb, cidV0ToV1Base32 } = require('./helpers');

module.exports = {

	//export some helpers functions
	helpers: {
		cidForWeb,
		cidV0ToV1Base32,
	},

	/**
	* Decode a Content Hash.
	* @param {string} hash an hex string containing a content hash
	* @return {string} the decoded content
	*/
	decode: function (contentHash) {
		const buffer = hexStringToBuffer(contentHash);
		const codec = multiC.getCodec(buffer);
		const value = multiC.rmPrefix(buffer);
		let profile = profiles[codec];
		if (!profile) profile = profiles['default'];
		return profile.decode(value);
	},

	/**
	* Encode an IPFS address into a content hash
	* @param {string} ipfsHash string containing an IPFS address
	* @return {string} the resulting content hash
	*/
	fromIpfs: function (ipfsHash) {
		return this.encode('ipfs-ns', ipfsHash);
	},

	/**
	* Encode a Skylink into a content hash
	* @param {string} skylink string containing a Skylink
	* @return {string} the resulting content hash
	*/
	fromSkylink: function (skylink) {
		return this.encode('skynet-ns', skylink);
	},

	/**
	* Encode a Swarm address into a content hash
	* @param {string} swarmHash string containing a Swarm address
	* @return {string} the resulting content hash
	*/
	fromSwarm: function (swarmHash) {
		return this.encode('swarm-ns', swarmHash);
	},

	/**
	* General purpose encoding function
  * @param {string} codec 
  * @param {string} value 
  */
	encode: function (codec, value) {
		let profile = profiles[codec];
		if (!profile) profile = profiles['default'];
		const encodedValue = profile.encode(value);
		return multiH.toHexString(multiC.addPrefix(codec, encodedValue))
	},

	/**
	* Extract the codec of a content hash
	* @param {string} hash hex string containing a content hash
	* @return {string} the extracted codec
	*/
	getCodec: function (hash) {
		let buffer = hexStringToBuffer(hash);
		return multiC.getCodec(buffer);
	},
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash",file:"node_modules\\@ensdomains\\content-hash\\src\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\src\\profiles.js", {"buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js","cids":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\cids\\src\\index.js","js-base64":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\js-base64\\base64.js","multihashes":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Csrc%5Cprofiles.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const CID = require('cids');
const multiH = require('multihashes');
const base64 = require('js-base64')

/**
 * Convert an hexadecimal string to a Buffer, the string can start with or without '0x'
 * @param {string} hex an hexadecimal value
 * @return {Buffer} the resulting Buffer
 */
const hexStringToBuffer = (hex) => {
	let prefix = hex.slice(0, 2);
	let value = hex.slice(2);
	let res = '';
	if (prefix === '0x') res = value;
	else res = hex;
	return multiH.fromHexString(res);
}

/**
 * Validates IPNS identifier  to safeguard against insecure names.
 * @param {CID} name ised in ipns-ns
 * @return {bool}
 */
const isCryptographicIPNS =  (cid) => {
  try {
    const { multihash } = cid
    // Additional check for identifiers shorter
    // than what inlined ED25519 pubkey would be
    // https://github.com/ensdomains/ens-app/issues/849#issuecomment-777088950
    if (multihash.length < 38) {
      const mh = multiH.decode(multihash)
      // ED25519 pubkeys are inlined using identity hash function
      // and we should not see anything shorter than that
      if (mh.name === 'identity' && mh.length < 36) {
        // One can read inlined string value via:
        // console.log('ipns-ns id:', String(multiH.decode(new CID(value).multihash).digest))
        return false
      }
    }
    // ok, CID looks fine
    return true
  } catch (_) { return false }
  return false
}

/**
* list of known encoding,
* encoding should be a function that takes a `string` input,
* and return a `Buffer` result
*/
const encodes = {
  /**
  * @param {string} value
  * @return {Buffer}
  */
  skynet: (value) => {
    return base64.toUint8Array(value)
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  swarm: (value) => {
    const multihash = multiH.encode(hexStringToBuffer(value), 'keccak-256');
		return new CID(1, 'swarm-manifest', multihash).bytes;
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  ipfs: (value) => {
    return new CID(value).toV1().bytes;
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  ipns: (value) => {
    const cid = new CID(value)
    if (!isCryptographicIPNS(cid)) {
        throw Error('ipns-ns allows only valid cryptographic libp2p-key identifiers, try using ED25519 pubkey instead')
    }
    // Represent IPNS name as a CID with libp2p-key codec
    // https://github.com/libp2p/specs/blob/master/RFC/0001-text-peerid-cid.md
    return new CID(1, 'libp2p-key', cid.multihash).bytes
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  utf8: (value) => {
    return Buffer.from(value, 'utf8');
  },
};

/** 
* list of known decoding,
* decoding should be a function that takes a `Buffer` input,
* and return a `string` result
*/
const decodes = {
  /**
  * @param {Buffer} value 
  */
  hexMultiHash: (value) => {
    const cid = new CID(value);
    return multiH.decode(cid.multihash).digest.toString('hex');
  },
  /**
  * @param {Buffer} value 
  */
  ipfs: (value) => {
    const cid = new CID(value).toV1();
    return cid.toString(cid.codec === 'libp2p-key' ? 'base36' : 'base32')
  },
  /**
  * @param {Buffer} value 
  */
  ipns: (value) => {
    const cid = new CID(value).toV1()
    if (!isCryptographicIPNS(cid)) {
        // Value is not a libp2p-key, return original string
        console.warn('[ensdomains/content-hash] use of non-cryptographic identifiers in ipns-ns is deprecated and will be removed, migrate to ED25519 libp2p-key')
        return String(multiH.decode(new CID(value).multihash).digest)
        // TODO: start throwing an error (after some deprecation period)
        // throw Error('ipns-ns allows only valid cryptographic libp2p-key identifiers, try using ED25519 pubkey instead')
    }
    return cid.toString('base36')
  },
  /**
  * @param {Buffer} value 
  */
  utf8: (value) => {
    return value.toString('utf8');
  },
  base64: (value) => {
    // `true` option makes it URL safe (replaces / and + with - and _ )
    return base64.fromUint8Array(value, true)
  }
};

/**
* list of known encoding/decoding for a given codec,
* `encode` should be chosen among the `encodes` functions
* `decode` should be chosen among the `decodes` functions
*/
const profiles = {
  'skynet-ns': {
    encode: encodes.skynet,
    decode: decodes.base64,
  },
  'swarm-ns': {
    encode: encodes.swarm,
    decode: decodes.hexMultiHash,
  },
  'ipfs-ns': {
    encode: encodes.ipfs,
    decode: decodes.ipfs,
  },
  'ipns-ns': {
    encode: encodes.ipns,
    decode: decodes.ipns,
  },
  'default': {
    encode: encodes.utf8,
    decode: decodes.utf8,
  },
};

exports.hexStringToBuffer = hexStringToBuffer;
exports.profiles = profiles;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash",file:"node_modules\\@ensdomains\\content-hash\\src\\profiles.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.development.js", {"@ethereumjs/tx":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ethereumjs\\tx\\dist\\index.js","@ethereumjs/util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ethereumjs\\util\\dist\\index.js","@keystonehq/bc-ur-registry-eth":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js","hdkey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\hdkey\\lib\\hdkey.js","rlp":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\rlp\\dist\\index.js","uuid":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cdist%5Cbase-eth-keyring.cjs.development.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var HDKey = _interopDefault(require('hdkey'));
var util = require('@ethereumjs/util');
var rlp = _interopDefault(require('rlp'));
var tx = require('@ethereumjs/tx');
var bcUrRegistryEth = require('@keystonehq/bc-ur-registry-eth');
var uuid = require('uuid');

const keyringType = "QR Hardware Wallet Device";
const pathBase = "m";
const MAX_INDEX = 1000;
const DEFAULT_CHILDREN_PATH = "0/*";
var KEYRING_MODE;

(function (KEYRING_MODE) {
  KEYRING_MODE["hd"] = "hd";
  KEYRING_MODE["pubkey"] = "pubkey";
})(KEYRING_MODE || (KEYRING_MODE = {}));

var KEYRING_ACCOUNT;

(function (KEYRING_ACCOUNT) {
  KEYRING_ACCOUNT["standard"] = "account.standard";
  KEYRING_ACCOUNT["ledger_live"] = "account.ledger_live";
  KEYRING_ACCOUNT["ledger_legacy"] = "account.ledger_legacy";
})(KEYRING_ACCOUNT || (KEYRING_ACCOUNT = {}));

class BaseKeyring {
  constructor(opts) {
    // @ts-ignore
    this.version = 1;

    this.getInteraction = () => {
      throw new Error("KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.");
    };

    this.type = keyringType;

    this.requestSignature = async (_requestId, signRequest, requestTitle, requestDescription) => {
      const ethSignature = await this.getInteraction().requestSignature(signRequest, requestTitle, requestDescription);
      const requestIdBuffer = ethSignature.getRequestId();
      const signature = ethSignature.getSignature();

      if (requestIdBuffer) {
        const requestId = uuid.stringify(requestIdBuffer);

        if (requestId !== _requestId) {
          throw new Error("KeystoneError#invalid_data: read signature error: mismatched requestId");
        }
      }

      const r = signature.slice(0, 32);
      const s = signature.slice(32, 64);
      const v = signature.slice(64);
      return {
        r,
        s,
        v
      };
    };

    this.__readCryptoHDKey = cryptoHDKey => {
      var _cryptoHDKey$getOrigi, _cryptoHDKey$getChild;

      const hdPath = `m/${cryptoHDKey.getOrigin().getPath()}`;
      const xfp = (_cryptoHDKey$getOrigi = cryptoHDKey.getOrigin().getSourceFingerprint()) == null ? void 0 : _cryptoHDKey$getOrigi.toString("hex");
      const childrenPath = ((_cryptoHDKey$getChild = cryptoHDKey.getChildren()) == null ? void 0 : _cryptoHDKey$getChild.getPath()) || DEFAULT_CHILDREN_PATH;
      const name = cryptoHDKey.getName();

      if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.standard) {
        this.keyringAccount = KEYRING_ACCOUNT.standard;
      } else if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.ledger_legacy) {
        this.keyringAccount = KEYRING_ACCOUNT.ledger_legacy;
      }

      if (!xfp) {
        throw new Error("KeystoneError#invalid_data: invalid crypto-hdkey, cannot get source fingerprint");
      }

      const xpub = cryptoHDKey.getBip32Key();
      this.xfp = xfp;
      this.xpub = xpub;
      this.hdPath = hdPath;
      this.childrenPath = childrenPath;

      if (name !== undefined && name !== "") {
        this.name = name;
      }

      this.initialized = true;
    };

    this.__readCryptoAccount = cryptoAccount => {
      var _cryptoAccount$getMas, _cryptoAccount$getOut;

      const xfp = (_cryptoAccount$getMas = cryptoAccount.getMasterFingerprint()) == null ? void 0 : _cryptoAccount$getMas.toString("hex");

      if (!xfp) {
        throw new Error("KeystoneError#invalid_data: invalid crypto-account, cannot get master fingerprint");
      }

      this.xfp = xfp;
      this.initialized = true;
      let changed = false;
      const outputs = cryptoAccount.getOutputDescriptors();

      if (!outputs || outputs.length === 0) {
        throw new Error("KeystoneError#invalid_data: invalid crypto-account, no crypto output found");
      }

      if (outputs.length % 5 !== 0) {
        throw new Error("KeystoneError#invalid_data: only support 5x pubkey accounts for now");
      }

      (_cryptoAccount$getOut = cryptoAccount.getOutputDescriptors()) == null ? void 0 : _cryptoAccount$getOut.forEach(od => {
        try {
          const cryptoHDKey = od.getHDKey();

          if (cryptoHDKey) {
            const key = cryptoHDKey.getKey();
            const path = `M/${cryptoHDKey.getOrigin().getPath()}`;
            const address = "0x" + util.publicToAddress(key, true).toString("hex");
            this.name = cryptoHDKey.getName();

            if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.ledger_live) {
              this.keyringAccount = KEYRING_ACCOUNT.ledger_live;
            }

            if (this.paths[util.toChecksumAddress(address)] === undefined) {
              changed = true;
            }

            this.paths[util.toChecksumAddress(address)] = path;
          }
        } catch (e) {
          throw new Error(`KeystoneError#invalid_data: ${e}`);
        }
      });
      return changed;
    }; // private __readLedgerLiveAccounts = async () => {
    //     const result = await this.getInteraction().readCryptoHDKeyOrCryptoAccount();
    //     if (result.getRegistryType() === extend.RegistryTypes.CRYPTO_ACCOUNT) {
    //         const changed = this.__readCryptoAccount(result as CryptoAccount);
    //         if (!changed) {
    //             throw new Error(`#KeystoneError#pubkey_account.no_new_account`);
    //         }
    //     } else {
    //         throw new Error(`KeystoneError#pubkey_account.unexpected_urtype`);
    //     }
    // };


    this.getName = () => {
      return this.name;
    };

    this.setAccountToUnlock = index => {
      this.unlockedAccount = parseInt(index, 10);
    };

    this.__getNormalPage = async increment => {
      this.page += increment;

      if (this.page <= 0) {
        this.page = 1;
      }

      const from = (this.page - 1) * this.perPage;
      const to = from + this.perPage;
      const accounts = [];

      for (let i = from; i < to; i++) {
        const address = await this.__addressFromIndex(pathBase, i);
        accounts.push({
          address,
          balance: null,
          index: i
        });
        this.indexes[util.toChecksumAddress(address)] = i;
      }

      return accounts;
    };

    this.__getLedgerLivePage = async increment => {
      const nextPage = this.page + increment;
      const from = (nextPage - 1) * this.perPage;
      const to = from + this.perPage;
      const accounts = [];

      for (let i = from; i < to; i++) {
        const address = await this.__addressFromIndex(pathBase, i);
        accounts.push({
          address,
          balance: null,
          index: i
        });
      }

      this.page += increment;
      return accounts;
    };

    this.__addressFromIndex = async (pb, i) => {
      if (this.keyringMode === KEYRING_MODE.hd) {
        this.checkKeyring();

        if (!this.hdk) {
          // @ts-ignore
          this.hdk = HDKey.fromExtendedKey(this.xpub);
        }

        const childrenPath = this.childrenPath.replace("*", String(i)).replace(/\*/g, "0");
        const dkey = this.hdk.derive(`${pb}/${childrenPath}`);
        const address = "0x" + util.publicToAddress(dkey.publicKey, true).toString("hex");
        return util.toChecksumAddress(address);
      } else {
        const result = Object.keys(this.paths)[i];

        if (result) {
          return util.toChecksumAddress(result);
        } else {
          throw new Error(`KeystoneError#pubkey_account.no_expected_account`);
        }
      }
    }; //common props


    this.page = 0;
    this.perPage = 5;
    this.accounts = [];
    this.currentAccount = 0;
    this.unlockedAccount = 0;
    this.name = "QR Hardware";
    this.keyringMode = KEYRING_MODE.hd;
    this.keyringAccount = KEYRING_ACCOUNT.standard;
    this.initialized = false; //hd props;

    this.xfp = "";
    this.xpub = "";
    this.hdPath = "";
    this.childrenPath = DEFAULT_CHILDREN_PATH;
    this.indexes = {}; //pubkey props;

    this.paths = {};
    this.deserialize(opts);
  } //initial read


  async readKeyring() {
    const result = await this.getInteraction().readCryptoHDKeyOrCryptoAccount();
    this.syncKeyring(result);
  }

  syncKeyring(data) {
    if (data.getRegistryType().getType() === bcUrRegistryEth.extend.RegistryTypes.CRYPTO_HDKEY.getType()) {
      this.keyringMode = KEYRING_MODE.hd;

      this.__readCryptoHDKey(data);
    } else {
      this.keyringMode = KEYRING_MODE.pubkey;

      this.__readCryptoAccount(data);
    }
  }

  checkKeyring() {
    if (!this.xfp || !this.xpub || !this.hdPath) {
      throw new Error("KeystoneError#invalid_keyring: keyring not fulfilled, please call function `readKeyring` firstly");
    }
  }

  serialize() {
    return Promise.resolve({
      //common
      initialized: this.initialized,
      accounts: this.accounts,
      currentAccount: this.currentAccount,
      page: this.page,
      perPage: this.perPage,
      keyringAccount: this.keyringAccount,
      keyringMode: this.keyringMode,
      name: this.name,
      version: this.version,
      xfp: this.xfp,
      //hd
      xpub: this.xpub,
      hdPath: this.hdPath,
      childrenPath: this.childrenPath,
      indexes: this.indexes,
      //pubkey
      paths: this.paths
    });
  }

  deserialize(opts) {
    if (opts) {
      //common props;
      this.accounts = opts.accounts;
      this.currentAccount = opts.currentAccount;
      this.page = opts.page;
      this.perPage = opts.perPage;
      this.name = opts.name;
      this.initialized = opts.initialized;
      this.keyringMode = opts.keyringMode || KEYRING_MODE.hd;
      this.keyringAccount = opts.keyringAccount || KEYRING_ACCOUNT.standard;
      this.xfp = opts.xfp; //hd props;

      this.xpub = opts.xpub;
      this.hdPath = opts.hdPath;
      this.indexes = opts.indexes;
      this.paths = opts.paths;
      this.childrenPath = opts.childrenPath || DEFAULT_CHILDREN_PATH;
    }
  }

  setCurrentAccount(index) {
    this.currentAccount = index;
  }

  getCurrentAccount() {
    return this.currentAccount;
  }

  getCurrentAddress() {
    return this.accounts[this.currentAccount];
  }

  async addAccounts(n = 1) {
    const from = this.unlockedAccount;
    const to = from + n;
    const newAccounts = [];

    for (let i = from; i < to; i++) {
      const address = await this.__addressFromIndex(pathBase, i);
      newAccounts.push(address);
      this.page = 0;
      this.unlockedAccount++;
    }

    this.accounts = this.accounts.concat(newAccounts);
    return this.accounts;
  }

  getFirstPage() {
    this.page = 0;
    return this.__getPage(1);
  }

  getNextPage() {
    return this.__getPage(1);
  }

  getPreviousPage() {
    return this.__getPage(-1);
  }

  async __getPage(increment) {
    if (!this.initialized) {
      await this.readKeyring();
    }

    if (this.keyringMode === KEYRING_MODE.hd) {
      return this.__getNormalPage(increment);
    } else {
      return this.__getLedgerLivePage(increment);
    }
  }

  getAccounts() {
    return Promise.resolve(this.accounts);
  }

  removeAccount(address) {
    if (!this.accounts.map(a => a.toLowerCase()).includes(address.toLowerCase())) {
      throw new Error(`Address ${address} not found in this keyring`);
    }

    this.accounts = this.accounts.filter(a => a.toLowerCase() !== address.toLowerCase());
  }

  async signTransaction(address, tx$1) {
    const dataType = tx$1.type === 0 ? bcUrRegistryEth.DataType.transaction : bcUrRegistryEth.DataType.typedTransaction;
    let messageToSign;

    if (tx$1.type === 0) {
      messageToSign = Buffer.from(rlp.encode(tx$1.getMessageToSign(false)));
    } else {
      messageToSign = tx$1.getMessageToSign(false);
    }

    const hdPath = await this._pathFromAddress(address);
    const chainId = Number(tx$1.common.chainId());
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(messageToSign, dataType, hdPath, this.xfp, requestId, chainId);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, "Scan with your Keystone", 'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature');
    return tx.TransactionFactory.fromTxData({ ...tx$1.toJSON(),
      type: tx$1.type,
      r,
      s,
      v
    }, {
      common: tx$1.common
    });
  }

  signMessage(withAccount, data) {
    return this.signPersonalMessage(withAccount, data);
  }

  async signPersonalMessage(withAccount, messageHex) {
    const usignedHex = util.stripHexPrefix(messageHex);
    const hdPath = await this._pathFromAddress(withAccount);
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(Buffer.from(usignedHex, "hex"), bcUrRegistryEth.DataType.personalMessage, hdPath, this.xfp, requestId, undefined, withAccount);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, "Scan with your Keystone", 'After your Keystone has signed this message, click on "Scan Keystone" to receive the signature');
    return "0x" + Buffer.concat([r, s, v]).toString("hex");
  }

  async signTypedData(withAccount, typedData) {
    const hdPath = await this._pathFromAddress(withAccount);
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(Buffer.from(JSON.stringify(typedData), "utf-8"), bcUrRegistryEth.DataType.typedData, hdPath, this.xfp, requestId, undefined, withAccount);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, "Scan with your Keystone", 'After your Keystone has signed this data, click on "Scan Keystone" to receive the signature');
    return "0x" + Buffer.concat([r, s, v]).toString("hex");
  }

  async _pathFromAddress(address) {
    if (this.keyringMode === KEYRING_MODE.hd) {
      const checksummedAddress = util.toChecksumAddress(address);
      let index = this.indexes[checksummedAddress];

      if (typeof index === "undefined") {
        for (let i = 0; i < MAX_INDEX; i++) {
          if (checksummedAddress === (await this.__addressFromIndex(pathBase, i))) {
            index = i;
            break;
          }
        }
      }

      if (typeof index === "undefined") {
        throw new Error("Unknown address");
      }

      return `${this.hdPath}/${this.childrenPath.replace("*", index.toString()).replace(/\*/g, "0")}`;
    } else {
      const checksummedAddress = util.toChecksumAddress(address);
      const path = this.paths[checksummedAddress];

      if (typeof path === "undefined") {
        throw new Error("Unknown address");
      }

      return path;
    }
  }

}
BaseKeyring.type = keyringType;

exports.BaseKeyring = BaseKeyring;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring",file:"node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.development.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.production.min.js", {"@ethereumjs/tx":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ethereumjs\\tx\\dist\\index.js","@ethereumjs/util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ethereumjs\\util\\dist\\index.js","@keystonehq/bc-ur-registry-eth":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js","hdkey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\hdkey\\lib\\hdkey.js","rlp":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\rlp\\dist\\index.js","uuid":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cdist%5Cbase-eth-keyring.cjs.production.min.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var t,r,i=e(require("hdkey")),s=require("@ethereumjs/util"),n=e(require("rlp")),a=require("@ethereumjs/tx"),o=require("@keystonehq/bc-ur-registry-eth"),h=require("uuid");!function(e){e.hd="hd",e.pubkey="pubkey"}(t||(t={})),function(e){e.standard="account.standard",e.ledger_live="account.ledger_live",e.ledger_legacy="account.ledger_legacy"}(r||(r={}));class c{constructor(e){this.version=1,this.getInteraction=()=>{throw new Error("KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.")},this.type="QR Hardware Wallet Device",this.requestSignature=async(e,t,r,i)=>{const s=await this.getInteraction().requestSignature(t,r,i),n=s.getRequestId(),a=s.getSignature();if(n&&h.stringify(n)!==e)throw new Error("KeystoneError#invalid_data: read signature error: mismatched requestId");return{r:a.slice(0,32),s:a.slice(32,64),v:a.slice(64)}},this.__readCryptoHDKey=e=>{var t,i;const s="m/"+e.getOrigin().getPath(),n=null==(t=e.getOrigin().getSourceFingerprint())?void 0:t.toString("hex"),a=(null==(i=e.getChildren())?void 0:i.getPath())||"0/*",o=e.getName();if(e.getNote()===r.standard?this.keyringAccount=r.standard:e.getNote()===r.ledger_legacy&&(this.keyringAccount=r.ledger_legacy),!n)throw new Error("KeystoneError#invalid_data: invalid crypto-hdkey, cannot get source fingerprint");const h=e.getBip32Key();this.xfp=n,this.xpub=h,this.hdPath=s,this.childrenPath=a,void 0!==o&&""!==o&&(this.name=o),this.initialized=!0},this.__readCryptoAccount=e=>{var t,i;const n=null==(t=e.getMasterFingerprint())?void 0:t.toString("hex");if(!n)throw new Error("KeystoneError#invalid_data: invalid crypto-account, cannot get master fingerprint");this.xfp=n,this.initialized=!0;let a=!1;const o=e.getOutputDescriptors();if(!o||0===o.length)throw new Error("KeystoneError#invalid_data: invalid crypto-account, no crypto output found");if(o.length%5!=0)throw new Error("KeystoneError#invalid_data: only support 5x pubkey accounts for now");return null==(i=e.getOutputDescriptors())||i.forEach(e=>{try{const t=e.getHDKey();if(t){const e=t.getKey(),i="M/"+t.getOrigin().getPath(),n="0x"+s.publicToAddress(e,!0).toString("hex");this.name=t.getName(),t.getNote()===r.ledger_live&&(this.keyringAccount=r.ledger_live),void 0===this.paths[s.toChecksumAddress(n)]&&(a=!0),this.paths[s.toChecksumAddress(n)]=i}}catch(e){throw new Error("KeystoneError#invalid_data: "+e)}}),a},this.getName=()=>this.name,this.setAccountToUnlock=e=>{this.unlockedAccount=parseInt(e,10)},this.__getNormalPage=async e=>{this.page+=e,this.page<=0&&(this.page=1);const t=(this.page-1)*this.perPage,r=t+this.perPage,i=[];for(let e=t;e<r;e++){const t=await this.__addressFromIndex("m",e);i.push({address:t,balance:null,index:e}),this.indexes[s.toChecksumAddress(t)]=e}return i},this.__getLedgerLivePage=async e=>{const t=(this.page+e-1)*this.perPage,r=t+this.perPage,i=[];for(let e=t;e<r;e++){const t=await this.__addressFromIndex("m",e);i.push({address:t,balance:null,index:e})}return this.page+=e,i},this.__addressFromIndex=async(e,r)=>{if(this.keyringMode===t.hd){this.checkKeyring(),this.hdk||(this.hdk=i.fromExtendedKey(this.xpub));const t=this.childrenPath.replace("*",String(r)).replace(/\*/g,"0"),n=this.hdk.derive(`${e}/${t}`),a="0x"+s.publicToAddress(n.publicKey,!0).toString("hex");return s.toChecksumAddress(a)}{const e=Object.keys(this.paths)[r];if(e)return s.toChecksumAddress(e);throw new Error("KeystoneError#pubkey_account.no_expected_account")}},this.page=0,this.perPage=5,this.accounts=[],this.currentAccount=0,this.unlockedAccount=0,this.name="QR Hardware",this.keyringMode=t.hd,this.keyringAccount=r.standard,this.initialized=!1,this.xfp="",this.xpub="",this.hdPath="",this.childrenPath="0/*",this.indexes={},this.paths={},this.deserialize(e)}async readKeyring(){const e=await this.getInteraction().readCryptoHDKeyOrCryptoAccount();this.syncKeyring(e)}syncKeyring(e){e.getRegistryType().getType()===o.extend.RegistryTypes.CRYPTO_HDKEY.getType()?(this.keyringMode=t.hd,this.__readCryptoHDKey(e)):(this.keyringMode=t.pubkey,this.__readCryptoAccount(e))}checkKeyring(){if(!this.xfp||!this.xpub||!this.hdPath)throw new Error("KeystoneError#invalid_keyring: keyring not fulfilled, please call function `readKeyring` firstly")}serialize(){return Promise.resolve({initialized:this.initialized,accounts:this.accounts,currentAccount:this.currentAccount,page:this.page,perPage:this.perPage,keyringAccount:this.keyringAccount,keyringMode:this.keyringMode,name:this.name,version:this.version,xfp:this.xfp,xpub:this.xpub,hdPath:this.hdPath,childrenPath:this.childrenPath,indexes:this.indexes,paths:this.paths})}deserialize(e){e&&(this.accounts=e.accounts,this.currentAccount=e.currentAccount,this.page=e.page,this.perPage=e.perPage,this.name=e.name,this.initialized=e.initialized,this.keyringMode=e.keyringMode||t.hd,this.keyringAccount=e.keyringAccount||r.standard,this.xfp=e.xfp,this.xpub=e.xpub,this.hdPath=e.hdPath,this.indexes=e.indexes,this.paths=e.paths,this.childrenPath=e.childrenPath||"0/*")}setCurrentAccount(e){this.currentAccount=e}getCurrentAccount(){return this.currentAccount}getCurrentAddress(){return this.accounts[this.currentAccount]}async addAccounts(e=1){const t=this.unlockedAccount,r=t+e,i=[];for(let e=t;e<r;e++){const t=await this.__addressFromIndex("m",e);i.push(t),this.page=0,this.unlockedAccount++}return this.accounts=this.accounts.concat(i),this.accounts}getFirstPage(){return this.page=0,this.__getPage(1)}getNextPage(){return this.__getPage(1)}getPreviousPage(){return this.__getPage(-1)}async __getPage(e){return this.initialized||await this.readKeyring(),this.keyringMode===t.hd?this.__getNormalPage(e):this.__getLedgerLivePage(e)}getAccounts(){return Promise.resolve(this.accounts)}removeAccount(e){if(!this.accounts.map(e=>e.toLowerCase()).includes(e.toLowerCase()))throw new Error(`Address ${e} not found in this keyring`);this.accounts=this.accounts.filter(t=>t.toLowerCase()!==e.toLowerCase())}async signTransaction(e,t){const r=0===t.type?o.DataType.transaction:o.DataType.typedTransaction;let i;i=0===t.type?Buffer.from(n.encode(t.getMessageToSign(!1))):t.getMessageToSign(!1);const s=await this._pathFromAddress(e),c=Number(t.common.chainId()),d=h.v4(),u=o.EthSignRequest.constructETHRequest(i,r,s,this.xfp,d,c),{r:g,s:y,v:p}=await this.requestSignature(d,u,"Scan with your Keystone",'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature');return a.TransactionFactory.fromTxData({...t.toJSON(),type:t.type,r:g,s:y,v:p},{common:t.common})}signMessage(e,t){return this.signPersonalMessage(e,t)}async signPersonalMessage(e,t){const r=s.stripHexPrefix(t),i=await this._pathFromAddress(e),n=h.v4(),a=o.EthSignRequest.constructETHRequest(Buffer.from(r,"hex"),o.DataType.personalMessage,i,this.xfp,n,void 0,e),{r:c,s:d,v:u}=await this.requestSignature(n,a,"Scan with your Keystone",'After your Keystone has signed this message, click on "Scan Keystone" to receive the signature');return"0x"+Buffer.concat([c,d,u]).toString("hex")}async signTypedData(e,t){const r=await this._pathFromAddress(e),i=h.v4(),s=o.EthSignRequest.constructETHRequest(Buffer.from(JSON.stringify(t),"utf-8"),o.DataType.typedData,r,this.xfp,i,void 0,e),{r:n,s:a,v:c}=await this.requestSignature(i,s,"Scan with your Keystone",'After your Keystone has signed this data, click on "Scan Keystone" to receive the signature');return"0x"+Buffer.concat([n,a,c]).toString("hex")}async _pathFromAddress(e){if(this.keyringMode===t.hd){const t=s.toChecksumAddress(e);let r=this.indexes[t];if(void 0===r)for(let e=0;e<1e3;e++)if(t===await this.__addressFromIndex("m",e)){r=e;break}if(void 0===r)throw new Error("Unknown address");return`${this.hdPath}/${this.childrenPath.replace("*",r.toString()).replace(/\*/g,"0")}`}{const t=s.toChecksumAddress(e),r=this.paths[t];if(void 0===r)throw new Error("Unknown address");return r}}}c.type="QR Hardware Wallet Device",exports.BaseKeyring=c;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring",file:"node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.production.min.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\index.js", {"./base-eth-keyring.cjs.development.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.development.js","./base-eth-keyring.cjs.production.min.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.production.min.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cdist%5Cindex.js
      return function (require, module, exports) {

'use strict'

if ("development" === 'production') {
  module.exports = require('./base-eth-keyring.cjs.production.min.js')
} else {
  module.exports = require('./base-eth-keyring.cjs.development.js')
}

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring",file:"node_modules\\@keystonehq\\base-eth-keyring\\dist\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.development.js", {"@ethereumjs/util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ethereumjs\\util\\dist\\index.js","@keystonehq/bc-ur-registry":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js","hdkey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\hdkey\\lib\\hdkey.js","uuid":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry-eth%5Cdist%5Cbc-ur-registry-eth.cjs.development.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var bcUrRegistry = require('@keystonehq/bc-ur-registry');
var uuid = require('uuid');
var HDKey = _interopDefault(require('hdkey'));
var util = require('@ethereumjs/util');

const ExtendedRegistryTypes = {
  ETH_SIGN_REQUEST: /*#__PURE__*/new bcUrRegistry.RegistryType("eth-sign-request", 401),
  ETH_SIGNATURE: /*#__PURE__*/new bcUrRegistry.RegistryType("eth-signature", 402),
  ETH_NFT_ITEM: /*#__PURE__*/new bcUrRegistry.RegistryType("eth-nft-item", 403)
};

const {
  decodeToDataItem,
  RegistryTypes
} = bcUrRegistry.extend;
var Keys;

(function (Keys) {
  Keys[Keys["requestId"] = 1] = "requestId";
  Keys[Keys["signData"] = 2] = "signData";
  Keys[Keys["dataType"] = 3] = "dataType";
  Keys[Keys["chainId"] = 4] = "chainId";
  Keys[Keys["derivationPath"] = 5] = "derivationPath";
  Keys[Keys["address"] = 6] = "address";
  Keys[Keys["origin"] = 7] = "origin";
})(Keys || (Keys = {}));

(function (DataType) {
  DataType[DataType["transaction"] = 1] = "transaction";
  DataType[DataType["typedData"] = 2] = "typedData";
  DataType[DataType["personalMessage"] = 3] = "personalMessage";
  DataType[DataType["typedTransaction"] = 4] = "typedTransaction";
})(exports.DataType || (exports.DataType = {}));

class EthSignRequest extends bcUrRegistry.RegistryItem {
  constructor(args) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_SIGN_REQUEST;

    this.getRequestId = () => this.requestId;

    this.getSignData = () => this.signData;

    this.getDataType = () => this.dataType;

    this.getChainId = () => this.chainId;

    this.getDerivationPath = () => this.derivationPath.getPath();

    this.getSourceFingerprint = () => this.derivationPath.getSourceFingerprint();

    this.getSignRequestAddress = () => this.address;

    this.getOrigin = () => this.origin;

    this.toDataItem = () => {
      const map = {};

      if (this.requestId) {
        map[Keys.requestId] = new bcUrRegistry.DataItem(this.requestId, RegistryTypes.UUID.getTag());
      }

      if (this.address) {
        map[Keys.address] = this.address;
      }

      if (this.chainId) {
        map[Keys.chainId] = this.chainId;
      }

      if (this.origin) {
        map[Keys.origin] = this.origin;
      }

      map[Keys.signData] = this.signData;
      map[Keys.dataType] = this.dataType;
      const keyPath = this.derivationPath.toDataItem();
      keyPath.setTag(this.derivationPath.getRegistryType().getTag());
      map[Keys.derivationPath] = keyPath;
      return new bcUrRegistry.DataItem(map);
    };

    this.requestId = args.requestId;
    this.signData = args.signData;
    this.dataType = args.dataType;
    this.chainId = args.chainId;
    this.derivationPath = args.derivationPath;
    this.address = args.address;
    this.origin = args.origin;
  }

  static constructETHRequest(signData, signDataType, hdPath, xfp, uuidString, chainId, address, origin) {
    const paths = hdPath.replace(/[m|M]\//, "").split("/");
    const hdpathObject = new bcUrRegistry.CryptoKeypath(paths.map(path => {
      const index = parseInt(path.replace("'", ""));
      let isHardened = false;

      if (path.endsWith("'")) {
        isHardened = true;
      }

      return new bcUrRegistry.PathComponent({
        index,
        hardened: isHardened
      });
    }), Buffer.from(xfp, "hex"));
    return new EthSignRequest({
      requestId: uuidString ? Buffer.from(uuid.parse(uuidString)) : undefined,
      signData,
      dataType: signDataType,
      derivationPath: hdpathObject,
      chainId,
      address: address ? Buffer.from(address.replace("0x", ""), "hex") : undefined,
      origin: origin || undefined
    });
  }

}

EthSignRequest.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const signData = map[Keys.signData];
  const dataType = map[Keys.dataType];
  const derivationPath = bcUrRegistry.CryptoKeypath.fromDataItem(map[Keys.derivationPath]);
  const chainId = map[Keys.chainId] ? map[Keys.chainId] : undefined;
  const address = map[Keys.address] ? map[Keys.address] : undefined;
  const requestId = map[Keys.requestId] ? map[Keys.requestId].getData() : undefined;
  const origin = map[Keys.origin] ? map[Keys.origin] : undefined;
  return new EthSignRequest({
    requestId,
    signData,
    dataType,
    chainId,
    derivationPath,
    address,
    origin
  });
};

EthSignRequest.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem(_cborPayload);
  return EthSignRequest.fromDataItem(dataItem);
};

const {
  RegistryTypes: RegistryTypes$1,
  decodeToDataItem: decodeToDataItem$1
} = bcUrRegistry.extend;
var Keys$1;

(function (Keys) {
  Keys[Keys["requestId"] = 1] = "requestId";
  Keys[Keys["signature"] = 2] = "signature";
  Keys[Keys["origin"] = 3] = "origin";
})(Keys$1 || (Keys$1 = {}));

class ETHSignature extends bcUrRegistry.RegistryItem {
  constructor(signature, requestId, origin) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_SIGNATURE;

    this.getRequestId = () => this.requestId;

    this.getSignature = () => this.signature;

    this.getOrigin = () => this.origin;

    this.toDataItem = () => {
      const map = {};

      if (this.requestId) {
        map[Keys$1.requestId] = new bcUrRegistry.DataItem(this.requestId, RegistryTypes$1.UUID.getTag());
      }

      if (this.origin) map[Keys$1.origin] = this.origin;
      map[Keys$1.signature] = this.signature;
      return new bcUrRegistry.DataItem(map);
    };

    this.signature = signature;
    this.requestId = requestId;
    this.origin = origin;
  }

}

ETHSignature.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const signature = map[Keys$1.signature];
  const requestId = map[Keys$1.requestId] ? map[Keys$1.requestId].getData() : undefined;
  return new ETHSignature(signature, requestId, map[Keys$1.origin]);
};

ETHSignature.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem$1(_cborPayload);
  return ETHSignature.fromDataItem(dataItem);
};

const {
  decodeToDataItem: decodeToDataItem$2
} = bcUrRegistry.extend;
var Keys$2;

(function (Keys) {
  Keys[Keys["chainId"] = 1] = "chainId";
  Keys[Keys["contractAddress"] = 2] = "contractAddress";
  Keys[Keys["contractName"] = 3] = "contractName";
  Keys[Keys["name"] = 4] = "name";
  Keys[Keys["mediaData"] = 5] = "mediaData";
})(Keys$2 || (Keys$2 = {}));

class ETHNFTItem extends bcUrRegistry.RegistryItem {
  constructor(args) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_NFT_ITEM;

    this.getChainId = () => this.chainId;

    this.getName = () => this.name;

    this.getmediaData = () => this.mediaData;

    this.getContractAddress = () => this.contractAddress;

    this.getContractName = () => this.contractName;

    this.toDataItem = () => {
      const map = {};
      map[Keys$2.chainId] = this.chainId;
      map[Keys$2.name] = this.name;
      map[Keys$2.contractAddress] = this.contractAddress;
      map[Keys$2.contractName] = this.contractName;
      map[Keys$2.mediaData] = this.mediaData;
      return new bcUrRegistry.DataItem(map);
    };

    this.chainId = args.chainId;
    this.name = args.name;
    this.contractAddress = args.contractAddress;
    this.contractName = args.contractName;
    this.mediaData = args.mediaData; // remove the data perfix for android usage
  }

  static constructETHNFTItem(chainId, contractAddress, contractName, name, mediaData) {
    return new ETHNFTItem({
      chainId,
      contractAddress,
      contractName,
      mediaData,
      name
    });
  }

}

ETHNFTItem.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const chainId = map[Keys$2.chainId];
  const name = map[Keys$2.name];
  const mediaData = map[Keys$2.mediaData];
  const contractAddress = map[Keys$2.contractAddress];
  const contractName = map[Keys$2.contractName];
  return new ETHNFTItem({
    chainId,
    name,
    contractAddress,
    contractName,
    mediaData
  });
};

ETHNFTItem.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem$2(_cborPayload);
  return ETHNFTItem.fromDataItem(dataItem);
};

// @ts-ignore
const generateAddressFromXpub = (xpub, derivePath) => {
  // @ts-ignore
  const node = HDKey.fromExtendedKey(xpub);
  const publicKey = node.derive(derivePath);
  const address = "0x" + util.publicToAddress(publicKey.publicKey, true).toString("hex");
  return util.toChecksumAddress(address);
};
const findHDPathFromAddress = (address, xpub, numberLimit, rootPath) => {
  for (let i = 0; i < numberLimit; i++) {
    const path = `M/0/${i}`;

    const _address = generateAddressFromXpub(xpub, path);

    if (address.toLowerCase() == _address.toLowerCase()) {
      return `${rootPath}/0/${i}`;
    }
  }

  return null;
};

bcUrRegistry.patchTags(Object.values(ExtendedRegistryTypes).filter(rt => !!rt.getTag()).map(rt => rt.getTag()));

Object.keys(bcUrRegistry).forEach(function (k) {
  if (k !== 'default') Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return bcUrRegistry[k];
    }
  });
});
exports.ETHNFTItem = ETHNFTItem;
exports.ETHSignature = ETHSignature;
exports.EthSignRequest = EthSignRequest;
exports.findHDPathFromAddress = findHDPathFromAddress;
exports.generateAddressFromXpub = generateAddressFromXpub;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.development.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.production.min.js", {"@ethereumjs/util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ethereumjs\\util\\dist\\index.js","@keystonehq/bc-ur-registry":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js","hdkey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\hdkey\\lib\\hdkey.js","uuid":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry-eth%5Cdist%5Cbc-ur-registry-eth.cjs.production.min.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t,e=require("@keystonehq/bc-ur-registry"),a=require("uuid"),s=(t=require("hdkey"))&&"object"==typeof t&&"default"in t?t.default:t,i=require("@ethereumjs/util");const r={ETH_SIGN_REQUEST:new e.RegistryType("eth-sign-request",401),ETH_SIGNATURE:new e.RegistryType("eth-signature",402),ETH_NFT_ITEM:new e.RegistryType("eth-nft-item",403)},{decodeToDataItem:n,RegistryTypes:d}=e.extend;var o,h;!function(t){t[t.requestId=1]="requestId",t[t.signData=2]="signData",t[t.dataType=3]="dataType",t[t.chainId=4]="chainId",t[t.derivationPath=5]="derivationPath",t[t.address=6]="address",t[t.origin=7]="origin"}(o||(o={})),(h=exports.DataType||(exports.DataType={}))[h.transaction=1]="transaction",h[h.typedData=2]="typedData",h[h.personalMessage=3]="personalMessage",h[h.typedTransaction=4]="typedTransaction";class c extends e.RegistryItem{constructor(t){super(),this.getRegistryType=()=>r.ETH_SIGN_REQUEST,this.getRequestId=()=>this.requestId,this.getSignData=()=>this.signData,this.getDataType=()=>this.dataType,this.getChainId=()=>this.chainId,this.getDerivationPath=()=>this.derivationPath.getPath(),this.getSourceFingerprint=()=>this.derivationPath.getSourceFingerprint(),this.getSignRequestAddress=()=>this.address,this.getOrigin=()=>this.origin,this.toDataItem=()=>{const t={};this.requestId&&(t[o.requestId]=new e.DataItem(this.requestId,d.UUID.getTag())),this.address&&(t[o.address]=this.address),this.chainId&&(t[o.chainId]=this.chainId),this.origin&&(t[o.origin]=this.origin),t[o.signData]=this.signData,t[o.dataType]=this.dataType;const a=this.derivationPath.toDataItem();return a.setTag(this.derivationPath.getRegistryType().getTag()),t[o.derivationPath]=a,new e.DataItem(t)},this.requestId=t.requestId,this.signData=t.signData,this.dataType=t.dataType,this.chainId=t.chainId,this.derivationPath=t.derivationPath,this.address=t.address,this.origin=t.origin}static constructETHRequest(t,s,i,r,n,d,o,h){const g=i.replace(/[m|M]\//,"").split("/"),u=new e.CryptoKeypath(g.map(t=>{const a=parseInt(t.replace("'",""));let s=!1;return t.endsWith("'")&&(s=!0),new e.PathComponent({index:a,hardened:s})}),Buffer.from(r,"hex"));return new c({requestId:n?Buffer.from(a.parse(n)):void 0,signData:t,dataType:s,derivationPath:u,chainId:d,address:o?Buffer.from(o.replace("0x",""),"hex"):void 0,origin:h||void 0})}}c.fromDataItem=t=>{const a=t.getData(),s=a[o.signData],i=a[o.dataType],r=e.CryptoKeypath.fromDataItem(a[o.derivationPath]),n=a[o.chainId]?a[o.chainId]:void 0,d=a[o.address]?a[o.address]:void 0,h=a[o.requestId]?a[o.requestId].getData():void 0;return new c({requestId:h,signData:s,dataType:i,chainId:n,derivationPath:r,address:d,origin:a[o.origin]?a[o.origin]:void 0})},c.fromCBOR=t=>{const e=n(t);return c.fromDataItem(e)};const{RegistryTypes:g,decodeToDataItem:u}=e.extend;var m;!function(t){t[t.requestId=1]="requestId",t[t.signature=2]="signature",t[t.origin=3]="origin"}(m||(m={}));class I extends e.RegistryItem{constructor(t,a,s){super(),this.getRegistryType=()=>r.ETH_SIGNATURE,this.getRequestId=()=>this.requestId,this.getSignature=()=>this.signature,this.getOrigin=()=>this.origin,this.toDataItem=()=>{const t={};return this.requestId&&(t[m.requestId]=new e.DataItem(this.requestId,g.UUID.getTag())),this.origin&&(t[m.origin]=this.origin),t[m.signature]=this.signature,new e.DataItem(t)},this.signature=t,this.requestId=a,this.origin=s}}I.fromDataItem=t=>{const e=t.getData(),a=e[m.signature],s=e[m.requestId]?e[m.requestId].getData():void 0;return new I(a,s,e[m.origin])},I.fromCBOR=t=>{const e=u(t);return I.fromDataItem(e)};const{decodeToDataItem:p}=e.extend;var D;!function(t){t[t.chainId=1]="chainId",t[t.contractAddress=2]="contractAddress",t[t.contractName=3]="contractName",t[t.name=4]="name",t[t.mediaData=5]="mediaData"}(D||(D={}));class T extends e.RegistryItem{constructor(t){super(),this.getRegistryType=()=>r.ETH_NFT_ITEM,this.getChainId=()=>this.chainId,this.getName=()=>this.name,this.getmediaData=()=>this.mediaData,this.getContractAddress=()=>this.contractAddress,this.getContractName=()=>this.contractName,this.toDataItem=()=>{const t={};return t[D.chainId]=this.chainId,t[D.name]=this.name,t[D.contractAddress]=this.contractAddress,t[D.contractName]=this.contractName,t[D.mediaData]=this.mediaData,new e.DataItem(t)},this.chainId=t.chainId,this.name=t.name,this.contractAddress=t.contractAddress,this.contractName=t.contractName,this.mediaData=t.mediaData}static constructETHNFTItem(t,e,a,s,i){return new T({chainId:t,contractAddress:e,contractName:a,mediaData:i,name:s})}}T.fromDataItem=t=>{const e=t.getData();return new T({chainId:e[D.chainId],name:e[D.name],contractAddress:e[D.contractAddress],contractName:e[D.contractName],mediaData:e[D.mediaData]})},T.fromCBOR=t=>{const e=p(t);return T.fromDataItem(e)};const y=(t,e)=>{const a=s.fromExtendedKey(t).derive(e),r="0x"+i.publicToAddress(a.publicKey,!0).toString("hex");return i.toChecksumAddress(r)};e.patchTags(Object.values(r).filter(t=>!!t.getTag()).map(t=>t.getTag())),Object.keys(e).forEach((function(t){"default"!==t&&Object.defineProperty(exports,t,{enumerable:!0,get:function(){return e[t]}})})),exports.ETHNFTItem=T,exports.ETHSignature=I,exports.EthSignRequest=c,exports.findHDPathFromAddress=(t,e,a,s)=>{for(let i=0;i<a;i++){const a=y(e,"M/0/"+i);if(t.toLowerCase()==a.toLowerCase())return`${s}/0/${i}`}return null},exports.generateAddressFromXpub=y;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.production.min.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js", {"./bc-ur-registry-eth.cjs.development.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.development.js","./bc-ur-registry-eth.cjs.production.min.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.production.min.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry-eth%5Cdist%5Cindex.js
      return function (require, module, exports) {

'use strict'

if ("development" === 'production') {
  module.exports = require('./bc-ur-registry-eth.cjs.production.min.js')
} else {
  module.exports = require('./bc-ur-registry-eth.cjs.development.js')
}

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Bytes.js", {"./RegistryItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CBytes.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bytes = void 0;
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
class Bytes extends RegistryItem_1.RegistryItem {
    constructor(bytes) {
        super();
        this.bytes = bytes;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.BYTES;
        };
        this.getData = () => this.bytes;
        this.toDataItem = () => {
            return new lib_1.DataItem(this.bytes);
        };
    }
}
exports.Bytes = Bytes;
Bytes.fromDataItem = (dataItem) => {
    const bytes = dataItem.getData();
    if (!bytes) {
        throw new Error(`#[ur-registry][Bytes][fn.fromDataItem]: decoded [dataItem][#data] is undefined: ${dataItem}`);
    }
    return new Bytes(bytes);
};
Bytes.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return Bytes.fromDataItem(dataItem);
};
//# sourceMappingURL=Bytes.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Bytes.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoAccount.js", {".":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js","./RegistryItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoAccount.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoAccount = void 0;
const _1 = require(".");
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys[Keys["masterFingerprint"] = 1] = "masterFingerprint";
    Keys[Keys["outputDescriptors"] = 2] = "outputDescriptors";
})(Keys || (Keys = {}));
class CryptoAccount extends RegistryItem_1.RegistryItem {
    constructor(masterFingerprint, outputDescriptors) {
        super();
        this.masterFingerprint = masterFingerprint;
        this.outputDescriptors = outputDescriptors;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_ACCOUNT;
        };
        this.getMasterFingerprint = () => this.masterFingerprint;
        this.getOutputDescriptors = () => this.outputDescriptors;
        this.toDataItem = () => {
            const map = {};
            if (this.masterFingerprint) {
                map[Keys.masterFingerprint] = this.masterFingerprint.readUInt32BE(0);
            }
            if (this.outputDescriptors) {
                map[Keys.outputDescriptors] = this.outputDescriptors.map((item) => item.toDataItem());
            }
            return new lib_1.DataItem(map);
        };
    }
}
exports.CryptoAccount = CryptoAccount;
CryptoAccount.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const masterFingerprint = Buffer.alloc(4);
    const _masterFingerprint = map[Keys.masterFingerprint];
    if (_masterFingerprint) {
        masterFingerprint.writeUInt32BE(_masterFingerprint, 0);
    }
    const outputDescriptors = map[Keys.outputDescriptors];
    const cryptoOutputs = outputDescriptors.map((item) => _1.CryptoOutput.fromDataItem(item));
    return new CryptoAccount(masterFingerprint, cryptoOutputs);
};
CryptoAccount.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoAccount.fromDataItem(dataItem);
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoAccount.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoCoinInfo.js", {"./RegistryItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoCoinInfo.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoCoinInfo = exports.Network = exports.Type = void 0;
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys["type"] = "1";
    Keys["network"] = "2";
})(Keys || (Keys = {}));
var Type;
(function (Type) {
    Type[Type["bitcoin"] = 0] = "bitcoin";
})(Type = exports.Type || (exports.Type = {}));
var Network;
(function (Network) {
    Network[Network["mainnet"] = 0] = "mainnet";
    Network[Network["testnet"] = 1] = "testnet";
})(Network = exports.Network || (exports.Network = {}));
class CryptoCoinInfo extends RegistryItem_1.RegistryItem {
    constructor(type, network) {
        super();
        this.type = type;
        this.network = network;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_COIN_INFO;
        };
        this.getType = () => {
            return this.type || Type.bitcoin;
        };
        this.getNetwork = () => {
            return this.network || Network.mainnet;
        };
        this.toDataItem = () => {
            const map = {};
            if (this.type) {
                map[Keys.type] = this.type;
            }
            if (this.network) {
                map[Keys.network] = this.network;
            }
            return new lib_1.DataItem(map);
        };
    }
}
exports.CryptoCoinInfo = CryptoCoinInfo;
CryptoCoinInfo.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const type = map[Keys.type];
    const network = map[Keys.network];
    return new CryptoCoinInfo(type, network);
};
CryptoCoinInfo.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoCoinInfo.fromDataItem(dataItem);
};
//# sourceMappingURL=CryptoCoinInfo.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoCoinInfo.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoECKey.js", {"./RegistryItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoECKey.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoECKey = void 0;
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys[Keys["curve"] = 1] = "curve";
    Keys[Keys["private"] = 2] = "private";
    Keys[Keys["data"] = 3] = "data";
})(Keys || (Keys = {}));
class CryptoECKey extends RegistryItem_1.RegistryItem {
    constructor(args) {
        super();
        this.isECKey = () => {
            return true;
        };
        this.getCurve = () => this.curve || 0;
        this.isPrivateKey = () => this.privateKey || false;
        this.getData = () => this.data;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_ECKEY;
        };
        this.toDataItem = () => {
            const map = {};
            if (this.curve) {
                map[Keys.curve] = this.curve;
            }
            if (this.privateKey !== undefined) {
                map[Keys.private] = this.privateKey;
            }
            map[Keys.data] = this.data;
            return new lib_1.DataItem(map);
        };
        this.getOutputDescriptorContent = () => {
            return this.data.toString('hex');
        };
        this.data = args.data;
        this.curve = args.curve;
        this.privateKey = args.privateKey || undefined;
    }
}
exports.CryptoECKey = CryptoECKey;
CryptoECKey.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const curve = map[Keys.curve];
    const privateKey = map[Keys.private];
    const data = map[Keys.data];
    if (!data) {
        throw new Error(`#[ur-registry][CryptoECKey][fn.fromDataItem]: decoded [dataItem][#data.data] is undefined: ${dataItem}`);
    }
    return new CryptoECKey({ data, curve, privateKey });
};
CryptoECKey.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoECKey.fromDataItem(dataItem);
};
//# sourceMappingURL=CryptoECKey.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoECKey.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js", {"./CryptoCoinInfo":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoCoinInfo.js","./CryptoKeypath":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoKeypath.js","./RegistryItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","bs58check":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\bs58check\\index.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoHDKey.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoHDKey = void 0;
const bs58check_1 = require("bs58check");
const CryptoCoinInfo_1 = require("./CryptoCoinInfo");
const CryptoKeypath_1 = require("./CryptoKeypath");
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys[Keys["is_master"] = 1] = "is_master";
    Keys[Keys["is_private"] = 2] = "is_private";
    Keys[Keys["key_data"] = 3] = "key_data";
    Keys[Keys["chain_code"] = 4] = "chain_code";
    Keys[Keys["use_info"] = 5] = "use_info";
    Keys[Keys["origin"] = 6] = "origin";
    Keys[Keys["children"] = 7] = "children";
    Keys[Keys["parent_fingerprint"] = 8] = "parent_fingerprint";
    Keys[Keys["name"] = 9] = "name";
    Keys[Keys["note"] = 10] = "note";
})(Keys || (Keys = {}));
class CryptoHDKey extends RegistryItem_1.RegistryItem {
    constructor(args) {
        super();
        this.isECKey = () => {
            return false;
        };
        this.getKey = () => this.key;
        this.getChainCode = () => this.chainCode;
        this.isMaster = () => this.master;
        this.isPrivateKey = () => !!this.privateKey;
        this.getUseInfo = () => this.useInfo;
        this.getOrigin = () => this.origin;
        this.getChildren = () => this.children;
        this.getParentFingerprint = () => this.parentFingerprint;
        this.getName = () => this.name;
        this.getNote = () => this.note;
        this.getBip32Key = () => {
            var _a, _b, _c;
            let version;
            let depth;
            let index = 0;
            let parentFingerprint = Buffer.alloc(4).fill(0);
            if (this.isMaster()) {
                version = Buffer.from('0488ADE4', 'hex');
                depth = 0;
                index = 0;
            }
            else {
                depth = ((_a = this.getOrigin()) === null || _a === void 0 ? void 0 : _a.getComponents().length) || ((_b = this.getOrigin()) === null || _b === void 0 ? void 0 : _b.getDepth());
                const paths = (_c = this.getOrigin()) === null || _c === void 0 ? void 0 : _c.getComponents();
                const lastPath = paths[paths.length - 1];
                if (lastPath) {
                    index = lastPath.isHardened() ? lastPath.getIndex() + 0x80000000 : lastPath.getIndex();
                    if (this.getParentFingerprint()) {
                        parentFingerprint = this.getParentFingerprint();
                    }
                }
                if (this.isPrivateKey()) {
                    version = Buffer.from('0488ADE4', 'hex');
                }
                else {
                    version = Buffer.from('0488B21E', 'hex');
                }
            }
            const depthBuffer = Buffer.alloc(1);
            depthBuffer.writeUInt8(depth, 0);
            const indexBuffer = Buffer.alloc(4);
            indexBuffer.writeUInt32BE(index, 0);
            const chainCode = this.getChainCode();
            const key = this.getKey();
            return (0, bs58check_1.encode)(Buffer.concat([version, depthBuffer, parentFingerprint, indexBuffer, chainCode, key]));
        };
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_HDKEY;
        };
        this.getOutputDescriptorContent = () => {
            var _a, _b, _c, _d, _e, _f, _g;
            let result = '';
            if (this.getOrigin()) {
                if (((_a = this.getOrigin()) === null || _a === void 0 ? void 0 : _a.getSourceFingerprint()) && ((_b = this.getOrigin()) === null || _b === void 0 ? void 0 : _b.getPath())) {
                    result += `${(_d = (_c = this.getOrigin()) === null || _c === void 0 ? void 0 : _c.getSourceFingerprint()) === null || _d === void 0 ? void 0 : _d.toString('hex')}/${(_e = this.getOrigin()) === null || _e === void 0 ? void 0 : _e.getPath()}`;
                }
            }
            result += this.getBip32Key();
            if (this.getChildren()) {
                if ((_f = this.getChildren()) === null || _f === void 0 ? void 0 : _f.getPath()) {
                    result += `/${(_g = this.getChildren()) === null || _g === void 0 ? void 0 : _g.getPath()}`;
                }
            }
            return result;
        };
        this.setupMasterKey = (args) => {
            this.master = true;
            this.key = args.key;
            this.chainCode = args.chainCode;
        };
        this.setupDeriveKey = (args) => {
            this.master = false;
            this.privateKey = args.isPrivateKey;
            this.key = args.key;
            this.chainCode = args.chainCode;
            this.useInfo = args.useInfo;
            this.origin = args.origin;
            this.children = args.children;
            this.parentFingerprint = args.parentFingerprint;
            this.name = args.name;
            this.note = args.note;
        };
        this.toDataItem = () => {
            const map = {};
            if (this.master) {
                map[Keys.is_master] = true;
                map[Keys.key_data] = this.key;
                map[Keys.chain_code] = this.chainCode;
            }
            else {
                if (this.privateKey !== undefined) {
                    map[Keys.is_private] = this.privateKey;
                }
                map[Keys.key_data] = this.key;
                if (this.chainCode) {
                    map[Keys.chain_code] = this.chainCode;
                }
                if (this.useInfo) {
                    const useInfo = this.useInfo.toDataItem();
                    useInfo.setTag(this.useInfo.getRegistryType().getTag());
                    map[Keys.use_info] = useInfo;
                }
                if (this.origin) {
                    const origin = this.origin.toDataItem();
                    origin.setTag(this.origin.getRegistryType().getTag());
                    map[Keys.origin] = origin;
                }
                if (this.children) {
                    const children = this.children.toDataItem();
                    children.setTag(this.children.getRegistryType().getTag());
                    map[Keys.children] = children;
                }
                if (this.parentFingerprint) {
                    map[Keys.parent_fingerprint] = this.parentFingerprint.readUInt32BE(0);
                }
                if (this.name !== undefined) {
                    map[Keys.name] = this.name;
                }
                if (this.note !== undefined) {
                    map[Keys.note] = this.note;
                }
            }
            return new lib_1.DataItem(map);
        };
        if (args.isMaster) {
            this.setupMasterKey(args);
        }
        else {
            this.setupDeriveKey(args);
        }
    }
}
exports.CryptoHDKey = CryptoHDKey;
CryptoHDKey.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const isMaster = !!map[Keys.is_master];
    const isPrivateKey = map[Keys.is_private];
    const key = map[Keys.key_data];
    const chainCode = map[Keys.chain_code];
    const useInfo = map[Keys.use_info]
        ? CryptoCoinInfo_1.CryptoCoinInfo.fromDataItem(map[Keys.use_info])
        : undefined;
    const origin = map[Keys.origin]
        ? CryptoKeypath_1.CryptoKeypath.fromDataItem(map[Keys.origin])
        : undefined;
    const children = map[Keys.children]
        ? CryptoKeypath_1.CryptoKeypath.fromDataItem(map[Keys.children])
        : undefined;
    const _parentFingerprint = map[Keys.parent_fingerprint];
    let parentFingerprint = undefined;
    if (_parentFingerprint) {
        parentFingerprint = Buffer.alloc(4);
        parentFingerprint.writeUInt32BE(_parentFingerprint, 0);
    }
    const name = map[Keys.name];
    const note = map[Keys.note];
    return new CryptoHDKey({
        isMaster,
        isPrivateKey,
        key,
        chainCode,
        useInfo,
        origin,
        children,
        parentFingerprint,
        name,
        note,
    });
};
CryptoHDKey.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoHDKey.fromDataItem(dataItem);
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoKeypath.js", {"./PathComponent":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\PathComponent.js","./RegistryItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoKeypath.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoKeypath = void 0;
const lib_1 = require("./lib");
const PathComponent_1 = require("./PathComponent");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys[Keys["components"] = 1] = "components";
    Keys[Keys["source_fingerprint"] = 2] = "source_fingerprint";
    Keys[Keys["depth"] = 3] = "depth";
})(Keys || (Keys = {}));
class CryptoKeypath extends RegistryItem_1.RegistryItem {
    constructor(components = [], sourceFingerprint, depth) {
        super();
        this.components = components;
        this.sourceFingerprint = sourceFingerprint;
        this.depth = depth;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_KEYPATH;
        };
        this.getPath = () => {
            if (this.components.length === 0) {
                return undefined;
            }
            const components = this.components.map((component) => {
                return `${component.isWildcard() ? '*' : component.getIndex()}${component.isHardened() ? "'" : ''}`;
            });
            return components.join('/');
        };
        this.getComponents = () => this.components;
        this.getSourceFingerprint = () => this.sourceFingerprint;
        this.getDepth = () => this.depth;
        this.toDataItem = () => {
            const map = {};
            const components = [];
            this.components &&
                this.components.forEach((component) => {
                    if (component.isWildcard()) {
                        components.push([]);
                    }
                    else {
                        components.push(component.getIndex());
                    }
                    components.push(component.isHardened());
                });
            map[Keys.components] = components;
            if (this.sourceFingerprint) {
                map[Keys.source_fingerprint] = this.sourceFingerprint.readUInt32BE(0);
            }
            if (this.depth !== undefined) {
                map[Keys.depth] = this.depth;
            }
            return new lib_1.DataItem(map);
        };
    }
}
exports.CryptoKeypath = CryptoKeypath;
CryptoKeypath.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const pathComponents = [];
    const components = map[Keys.components];
    if (components) {
        for (let i = 0; i < components.length; i += 2) {
            const isHardened = components[i + 1];
            const path = components[i];
            if (typeof path === 'number') {
                pathComponents.push(new PathComponent_1.PathComponent({ index: path, hardened: isHardened }));
            }
            else {
                pathComponents.push(new PathComponent_1.PathComponent({ hardened: isHardened }));
            }
        }
    }
    const _sourceFingerprint = map[Keys.source_fingerprint];
    let sourceFingerprint;
    if (_sourceFingerprint) {
        sourceFingerprint = Buffer.alloc(4);
        sourceFingerprint.writeUInt32BE(_sourceFingerprint, 0);
    }
    const depth = map[Keys.depth];
    return new CryptoKeypath(pathComponents, sourceFingerprint, depth);
};
CryptoKeypath.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoKeypath.fromDataItem(dataItem);
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoKeypath.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoOutput.js", {"./CryptoECKey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoECKey.js","./CryptoHDKey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js","./MultiKey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\MultiKey.js","./RegistryItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./ScriptExpression":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\ScriptExpression.js","./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoOutput.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoOutput = void 0;
const CryptoECKey_1 = require("./CryptoECKey");
const CryptoHDKey_1 = require("./CryptoHDKey");
const lib_1 = require("./lib");
const MultiKey_1 = require("./MultiKey");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
const ScriptExpression_1 = require("./ScriptExpression");
class CryptoOutput extends RegistryItem_1.RegistryItem {
    constructor(scriptExpressions, cryptoKey) {
        super();
        this.scriptExpressions = scriptExpressions;
        this.cryptoKey = cryptoKey;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_OUTPUT;
        };
        this.getCryptoKey = () => this.cryptoKey;
        this.getHDKey = () => {
            if (this.cryptoKey instanceof CryptoHDKey_1.CryptoHDKey) {
                return this.cryptoKey;
            }
            else {
                return undefined;
            }
        };
        this.getECKey = () => {
            if (this.cryptoKey instanceof CryptoECKey_1.CryptoECKey) {
                return this.cryptoKey;
            }
            else {
                return undefined;
            }
        };
        this.getMultiKey = () => {
            if (this.cryptoKey instanceof MultiKey_1.MultiKey) {
                return this.cryptoKey;
            }
            else {
                return undefined;
            }
        };
        this.getScriptExpressions = () => this.scriptExpressions;
        this._toOutputDescriptor = (seIndex) => {
            if (seIndex >= this.scriptExpressions.length) {
                return this.cryptoKey.getOutputDescriptorContent();
            }
            else {
                return `${this.scriptExpressions[seIndex].getExpression()}(${this._toOutputDescriptor(seIndex + 1)})`;
            }
        };
        this.toString = () => {
            return this._toOutputDescriptor(0);
        };
        this.toDataItem = () => {
            let dataItem = this.cryptoKey.toDataItem();
            if (this.cryptoKey instanceof CryptoECKey_1.CryptoECKey ||
                this.cryptoKey instanceof CryptoHDKey_1.CryptoHDKey) {
                dataItem.setTag(this.cryptoKey.getRegistryType().getTag());
            }
            const clonedSe = [...this.scriptExpressions];
            clonedSe.reverse().forEach((se) => {
                const tagValue = se.getTag();
                if (dataItem.getTag() === undefined) {
                    dataItem.setTag(tagValue);
                }
                else {
                    dataItem = new lib_1.DataItem(dataItem, tagValue);
                }
            });
            return dataItem;
        };
    }
}
exports.CryptoOutput = CryptoOutput;
CryptoOutput.fromDataItem = (dataItem) => {
    const scriptExpressions = [];
    let _dataItem = dataItem;
    while (true) {
        let _tag = _dataItem.getTag();
        const se = ScriptExpression_1.ScriptExpression.fromTag(_tag);
        if (se) {
            scriptExpressions.push(se);
            if (_dataItem.getData() instanceof lib_1.DataItem) {
                _dataItem = _dataItem.getData();
                _tag = _dataItem.getTag();
            }
            else {
                break;
            }
        }
        else {
            break;
        }
    }
    const seLength = scriptExpressions.length;
    const isMultiKey = seLength > 0 &&
        (scriptExpressions[seLength - 1].getExpression() ===
            ScriptExpression_1.ScriptExpressions.MULTISIG.getExpression() ||
            scriptExpressions[seLength - 1].getExpression() ===
                ScriptExpression_1.ScriptExpressions.SORTED_MULTISIG.getExpression());
    if (isMultiKey) {
        const multiKey = MultiKey_1.MultiKey.fromDataItem(_dataItem);
        return new CryptoOutput(scriptExpressions, multiKey);
    }
    if (_dataItem.getTag() === RegistryType_1.RegistryTypes.CRYPTO_HDKEY.getTag()) {
        const cryptoHDKey = CryptoHDKey_1.CryptoHDKey.fromDataItem(_dataItem);
        return new CryptoOutput(scriptExpressions, cryptoHDKey);
    }
    else {
        const cryptoECKey = CryptoECKey_1.CryptoECKey.fromDataItem(_dataItem);
        return new CryptoOutput(scriptExpressions, cryptoECKey);
    }
};
CryptoOutput.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoOutput.fromDataItem(dataItem);
};
//# sourceMappingURL=CryptoOutput.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoOutput.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoPSBT.js", {"./RegistryItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoPSBT.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoPSBT = void 0;
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
class CryptoPSBT extends RegistryItem_1.RegistryItem {
    constructor(psbt) {
        super();
        this.psbt = psbt;
        this.getRegistryType = () => RegistryType_1.RegistryTypes.CRYPTO_PSBT;
        this.getPSBT = () => this.psbt;
        this.toDataItem = () => {
            return new lib_1.DataItem(this.psbt);
        };
    }
}
exports.CryptoPSBT = CryptoPSBT;
CryptoPSBT.fromDataItem = (dataItem) => {
    const psbt = dataItem.getData();
    if (!psbt) {
        throw new Error(`#[ur-registry][CryptoPSBT][fn.fromDataItem]: decoded [dataItem][#data] is undefined: ${dataItem}`);
    }
    return new CryptoPSBT(psbt);
};
CryptoPSBT.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoPSBT.fromDataItem(dataItem);
};
//# sourceMappingURL=CryptoPSBT.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoPSBT.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Decoder\\index.js", {"..":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js","../RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","../errors":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\errors\\index.js","@ngraveio/bc-ur":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ngraveio\\bc-ur\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CDecoder%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.URRegistryDecoder = void 0;
const bc_ur_1 = require("@ngraveio/bc-ur");
const __1 = require("..");
const RegistryType_1 = require("../RegistryType");
const errors_1 = require("../errors");
class URRegistryDecoder extends bc_ur_1.URDecoder {
    constructor() {
        super(...arguments);
        this.resultRegistryType = () => {
            const ur = this.resultUR();
            switch (ur.type) {
                case RegistryType_1.RegistryTypes.BYTES.getType():
                    return __1.Bytes.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_HDKEY.getType():
                    return __1.CryptoHDKey.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_KEYPATH.getType():
                    return __1.CryptoKeypath.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_COIN_INFO.getType():
                    return __1.CryptoCoinInfo.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_ECKEY.getType():
                    return __1.CryptoECKey.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_OUTPUT.getType():
                    return __1.CryptoOutput.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_PSBT.getType():
                    return __1.CryptoPSBT.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_ACCOUNT.getType():
                    return __1.CryptoAccount.fromCBOR(ur.cbor);
                default:
                    throw new errors_1.UnknownURTypeError(`#[ur-registry][Decoder][fn.resultRegistryType]: registry type ${ur.type} is not supported now`);
            }
        };
    }
}
exports.URRegistryDecoder = URRegistryDecoder;
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Decoder\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\MultiKey.js", {"./CryptoECKey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoECKey.js","./CryptoHDKey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js","./RegistryItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib/DataItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\DataItem.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CMultiKey.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiKey = void 0;
const CryptoECKey_1 = require("./CryptoECKey");
const CryptoHDKey_1 = require("./CryptoHDKey");
const DataItem_1 = require("./lib/DataItem");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys[Keys["threshold"] = 1] = "threshold";
    Keys[Keys["keys"] = 2] = "keys";
})(Keys || (Keys = {}));
class MultiKey extends RegistryItem_1.RegistryItem {
    constructor(threshold, keys) {
        super();
        this.threshold = threshold;
        this.keys = keys;
        this.getThreshold = () => this.threshold;
        this.getKeys = () => this.keys;
        this.toDataItem = () => {
            const map = {};
            map[Keys.threshold] = this.threshold;
            const keys = this.keys.map((k) => {
                const dataItem = k.toDataItem();
                dataItem.setTag(k.getRegistryType().getTag());
                return dataItem;
            });
            map[Keys.keys] = keys;
            return new DataItem_1.DataItem(map);
        };
        this.getOutputDescriptorContent = () => {
            return [this.getThreshold(),
                this.keys.map(k => k.getOutputDescriptorContent()).join(','),
            ].join(',');
        };
    }
}
exports.MultiKey = MultiKey;
MultiKey.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const threshold = map[Keys.threshold];
    const _keys = map[Keys.keys];
    const keys = [];
    _keys.forEach((k) => {
        if (k.getTag() === RegistryType_1.RegistryTypes.CRYPTO_HDKEY.getTag()) {
            keys.push(CryptoHDKey_1.CryptoHDKey.fromDataItem(k));
        }
        else if (k.getTag() === RegistryType_1.RegistryTypes.CRYPTO_ECKEY.getTag()) {
            keys.push(CryptoECKey_1.CryptoECKey.fromDataItem(k));
        }
    });
    return new MultiKey(threshold, keys);
};
//# sourceMappingURL=MultiKey.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\MultiKey.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\PathComponent.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CPathComponent.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PathComponent = void 0;
class PathComponent {
    constructor(args) {
        this.getIndex = () => this.index;
        this.isWildcard = () => this.wildcard;
        this.isHardened = () => this.hardened;
        this.index = args.index;
        this.hardened = args.hardened;
        if (this.index !== undefined) {
            this.wildcard = false;
        }
        else {
            this.wildcard = true;
        }
        if (this.index && (this.index & PathComponent.HARDENED_BIT) !== 0) {
            throw new Error(`#[ur-registry][PathComponent][fn.constructor]: Invalid index ${this.index} - most significant bit cannot be set`);
        }
    }
}
exports.PathComponent = PathComponent;
PathComponent.HARDENED_BIT = 0x80000000;
//# sourceMappingURL=PathComponent.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\PathComponent.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js", {"./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","@ngraveio/bc-ur":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ngraveio\\bc-ur\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CRegistryItem.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegistryItem = void 0;
const bc_ur_1 = require("@ngraveio/bc-ur");
const lib_1 = require("./lib");
class RegistryItem {
    constructor() {
        this.toCBOR = () => {
            if (this.toDataItem() === undefined) {
                throw new Error(`#[ur-registry][RegistryItem][fn.toCBOR]: registry ${this.getRegistryType()}'s method toDataItem returns undefined`);
            }
            return (0, lib_1.encodeDataItem)(this.toDataItem());
        };
        this.toUR = () => {
            return new bc_ur_1.UR(this.toCBOR(), this.getRegistryType().getType());
        };
        this.toUREncoder = (maxFragmentLength, firstSeqNum, minFragmentLength) => {
            const ur = this.toUR();
            const urEncoder = new bc_ur_1.UREncoder(ur, maxFragmentLength, firstSeqNum, minFragmentLength);
            return urEncoder;
        };
    }
}
exports.RegistryItem = RegistryItem;
//# sourceMappingURL=RegistryItem.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CRegistryType.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegistryTypes = exports.RegistryType = void 0;
class RegistryType {
    constructor(type, tag) {
        this.type = type;
        this.tag = tag;
        this.getTag = () => this.tag;
        this.getType = () => this.type;
    }
}
exports.RegistryType = RegistryType;
exports.RegistryTypes = {
    UUID: new RegistryType('uuid', 37),
    BYTES: new RegistryType('bytes', undefined),
    CRYPTO_HDKEY: new RegistryType('crypto-hdkey', 303),
    CRYPTO_KEYPATH: new RegistryType('crypto-keypath', 304),
    CRYPTO_COIN_INFO: new RegistryType('crypto-coin-info', 305),
    CRYPTO_ECKEY: new RegistryType('crypto-eckey', 306),
    CRYPTO_OUTPUT: new RegistryType('crypto-output', 308),
    CRYPTO_PSBT: new RegistryType('crypto-psbt', 310),
    CRYPTO_ACCOUNT: new RegistryType('crypto-account', 311),
    CRYPTO_MULTI_ACCOUNTS: new RegistryType("crypto-multi-accounts", 1103),
};
//# sourceMappingURL=RegistryType.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\ScriptExpression.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CScriptExpression.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScriptExpressions = exports.ScriptExpression = void 0;
class ScriptExpression {
    constructor(tag, expression) {
        this.tag = tag;
        this.expression = expression;
        this.getTag = () => this.tag;
        this.getExpression = () => this.expression;
    }
}
exports.ScriptExpression = ScriptExpression;
ScriptExpression.fromTag = (tag) => {
    const se = Object.values(exports.ScriptExpressions).find((se) => se.getTag() === tag);
    return se;
};
exports.ScriptExpressions = {
    SCRIPT_HASH: new ScriptExpression(400, 'sh'),
    WITNESS_SCRIPT_HASH: new ScriptExpression(401, 'wsh'),
    PUBLIC_KEY: new ScriptExpression(402, 'pk'),
    PUBLIC_KEY_HASH: new ScriptExpression(403, 'pkh'),
    WITNESS_PUBLIC_KEY_HASH: new ScriptExpression(404, 'wpkh'),
    COMBO: new ScriptExpression(405, 'combo'),
    MULTISIG: new ScriptExpression(406, 'multi'),
    SORTED_MULTISIG: new ScriptExpression(407, 'sortedmulti'),
    ADDRESS: new ScriptExpression(307, 'addr'),
    RAW_SCRIPT: new ScriptExpression(408, 'raw'),
};
//# sourceMappingURL=ScriptExpression.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\ScriptExpression.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\errors\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Cerrors%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnknownURTypeError = void 0;
class UnknownURTypeError extends Error {
    constructor(message) {
        super(message);
    }
}
exports.UnknownURTypeError = UnknownURTypeError;
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\errors\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\extended\\CryptoMultiAccounts.js", {"../CryptoHDKey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js","../RegistryItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","../RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","../lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Cextended%5CCryptoMultiAccounts.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoMultiAccounts = void 0;
const RegistryType_1 = require("../RegistryType");
const CryptoHDKey_1 = require("../CryptoHDKey");
const RegistryItem_1 = require("../RegistryItem");
const lib_1 = require("../lib");
var Keys;
(function (Keys) {
    Keys[Keys["masterFingerprint"] = 1] = "masterFingerprint";
    Keys[Keys["keys"] = 2] = "keys";
    Keys[Keys["device"] = 3] = "device";
})(Keys || (Keys = {}));
class CryptoMultiAccounts extends RegistryItem_1.RegistryItem {
    constructor(masterFingerprint, keys, device) {
        super();
        this.masterFingerprint = masterFingerprint;
        this.keys = keys;
        this.device = device;
        this.getRegistryType = () => RegistryType_1.RegistryTypes.CRYPTO_MULTI_ACCOUNTS;
        this.getMasterFingerprint = () => this.masterFingerprint;
        this.getKeys = () => this.keys;
        this.getDevice = () => this.device;
        this.toDataItem = () => {
            const map = {};
            if (this.masterFingerprint) {
                map[Keys.masterFingerprint] = this.masterFingerprint.readUInt32BE(0);
            }
            if (this.keys) {
                map[Keys.keys] = this.keys.map((item) => {
                    const dataItem = item.toDataItem();
                    dataItem.setTag(item.getRegistryType().getTag());
                    return dataItem;
                });
            }
            if (this.device) {
                map[Keys.device] = this.device;
            }
            return new lib_1.DataItem(map);
        };
    }
}
exports.CryptoMultiAccounts = CryptoMultiAccounts;
CryptoMultiAccounts.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const masterFingerprint = Buffer.alloc(4);
    const _masterFingerprint = map[Keys.masterFingerprint];
    if (_masterFingerprint) {
        masterFingerprint.writeUInt32BE(_masterFingerprint, 0);
    }
    const keys = map[Keys.keys];
    const cryptoHDKeys = keys.map((item) => CryptoHDKey_1.CryptoHDKey.fromDataItem(item));
    const device = map[Keys.device];
    return new CryptoMultiAccounts(masterFingerprint, cryptoHDKeys, device);
};
CryptoMultiAccounts.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoMultiAccounts.fromDataItem(dataItem);
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\extended\\CryptoMultiAccounts.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js", {"./Bytes":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Bytes.js","./CryptoAccount":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoAccount.js","./CryptoCoinInfo":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoCoinInfo.js","./CryptoECKey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoECKey.js","./CryptoHDKey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js","./CryptoKeypath":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoKeypath.js","./CryptoOutput":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoOutput.js","./CryptoPSBT":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoPSBT.js","./Decoder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Decoder\\index.js","./MultiKey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\MultiKey.js","./PathComponent":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\PathComponent.js","./RegistryItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./ScriptExpression":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\ScriptExpression.js","./errors":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\errors\\index.js","./extended/CryptoMultiAccounts":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\extended\\CryptoMultiAccounts.js","./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","./patchCBOR":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\patchCBOR.js","./types":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\types.js","./utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\utils.js","buffer/":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\buffer\\index.js","tslib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\tslib\\tslib.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Buffer = exports.extend = exports.PathComponent = exports.ScriptExpressions = exports.MultiKey = exports.CryptoPSBT = exports.CryptoOutput = exports.CryptoECKey = exports.CryptoCoinInfoNetwork = exports.CryptoCoinInfoType = exports.CryptoCoinInfo = exports.CryptoKeypath = exports.CryptoMultiAccounts = exports.CryptoHDKey = exports.CryptoAccount = exports.Bytes = exports.URRegistryDecoder = exports.DataItem = void 0;
const tslib_1 = require("tslib");
require("./patchCBOR");
const buffer_1 = require("buffer/");
Object.defineProperty(exports, "Buffer", { enumerable: true, get: function () { return buffer_1.Buffer; } });
const CryptoHDKey_1 = require("./CryptoHDKey");
Object.defineProperty(exports, "CryptoHDKey", { enumerable: true, get: function () { return CryptoHDKey_1.CryptoHDKey; } });
const CryptoKeypath_1 = require("./CryptoKeypath");
Object.defineProperty(exports, "CryptoKeypath", { enumerable: true, get: function () { return CryptoKeypath_1.CryptoKeypath; } });
const CryptoCoinInfo_1 = require("./CryptoCoinInfo");
Object.defineProperty(exports, "CryptoCoinInfo", { enumerable: true, get: function () { return CryptoCoinInfo_1.CryptoCoinInfo; } });
Object.defineProperty(exports, "CryptoCoinInfoType", { enumerable: true, get: function () { return CryptoCoinInfo_1.Type; } });
Object.defineProperty(exports, "CryptoCoinInfoNetwork", { enumerable: true, get: function () { return CryptoCoinInfo_1.Network; } });
const CryptoECKey_1 = require("./CryptoECKey");
Object.defineProperty(exports, "CryptoECKey", { enumerable: true, get: function () { return CryptoECKey_1.CryptoECKey; } });
const Bytes_1 = require("./Bytes");
Object.defineProperty(exports, "Bytes", { enumerable: true, get: function () { return Bytes_1.Bytes; } });
const CryptoOutput_1 = require("./CryptoOutput");
Object.defineProperty(exports, "CryptoOutput", { enumerable: true, get: function () { return CryptoOutput_1.CryptoOutput; } });
const CryptoPSBT_1 = require("./CryptoPSBT");
Object.defineProperty(exports, "CryptoPSBT", { enumerable: true, get: function () { return CryptoPSBT_1.CryptoPSBT; } });
const CryptoAccount_1 = require("./CryptoAccount");
Object.defineProperty(exports, "CryptoAccount", { enumerable: true, get: function () { return CryptoAccount_1.CryptoAccount; } });
const Decoder_1 = require("./Decoder");
Object.defineProperty(exports, "URRegistryDecoder", { enumerable: true, get: function () { return Decoder_1.URRegistryDecoder; } });
const MultiKey_1 = require("./MultiKey");
Object.defineProperty(exports, "MultiKey", { enumerable: true, get: function () { return MultiKey_1.MultiKey; } });
const ScriptExpression_1 = require("./ScriptExpression");
Object.defineProperty(exports, "ScriptExpressions", { enumerable: true, get: function () { return ScriptExpression_1.ScriptExpressions; } });
const PathComponent_1 = require("./PathComponent");
Object.defineProperty(exports, "PathComponent", { enumerable: true, get: function () { return PathComponent_1.PathComponent; } });
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
const lib_1 = require("./lib");
var lib_2 = require("./lib");
Object.defineProperty(exports, "DataItem", { enumerable: true, get: function () { return lib_2.DataItem; } });
const utils_1 = require("./utils");
const CryptoMultiAccounts_1 = require("./extended/CryptoMultiAccounts");
Object.defineProperty(exports, "CryptoMultiAccounts", { enumerable: true, get: function () { return CryptoMultiAccounts_1.CryptoMultiAccounts; } });
const URlib = {
    URRegistryDecoder: Decoder_1.URRegistryDecoder,
    Bytes: Bytes_1.Bytes,
    CryptoAccount: CryptoAccount_1.CryptoAccount,
    CryptoHDKey: CryptoHDKey_1.CryptoHDKey,
    CryptoMultiAccounts: CryptoMultiAccounts_1.CryptoMultiAccounts,
    CryptoKeypath: CryptoKeypath_1.CryptoKeypath,
    CryptoCoinInfo: CryptoCoinInfo_1.CryptoCoinInfo,
    CryptoCoinInfoType: CryptoCoinInfo_1.Type,
    CryptoCoinInfoNetwork: CryptoCoinInfo_1.Network,
    CryptoECKey: CryptoECKey_1.CryptoECKey,
    CryptoOutput: CryptoOutput_1.CryptoOutput,
    CryptoPSBT: CryptoPSBT_1.CryptoPSBT,
    MultiKey: MultiKey_1.MultiKey,
    ScriptExpressions: ScriptExpression_1.ScriptExpressions,
    PathComponent: PathComponent_1.PathComponent,
};
const cbor = {
    addReader: lib_1.addReader,
    addSemanticDecode: lib_1.addSemanticDecode,
    addSemanticEncode: lib_1.addSemanticEncode,
    addWriter: lib_1.addWriter,
    patchTags: utils_1.patchTags,
};
const extend = {
    RegistryTypes: RegistryType_1.RegistryTypes,
    RegistryItem: RegistryItem_1.RegistryItem,
    RegistryType: RegistryType_1.RegistryType,
    decodeToDataItem: lib_1.decodeToDataItem,
    encodeDataItem: lib_1.encodeDataItem,
    cbor,
};
exports.extend = extend;
(0, tslib_1.__exportStar)(require("./errors"), exports);
(0, tslib_1.__exportStar)(require("./Decoder"), exports);
(0, tslib_1.__exportStar)(require("./lib"), exports);
(0, tslib_1.__exportStar)(require("./CryptoAccount"), exports);
(0, tslib_1.__exportStar)(require("./CryptoPSBT"), exports);
(0, tslib_1.__exportStar)(require("./CryptoHDKey"), exports);
(0, tslib_1.__exportStar)(require("./extended/CryptoMultiAccounts"), exports);
(0, tslib_1.__exportStar)(require("./CryptoOutput"), exports);
(0, tslib_1.__exportStar)(require("./CryptoCoinInfo"), exports);
(0, tslib_1.__exportStar)(require("./CryptoECKey"), exports);
(0, tslib_1.__exportStar)(require("./MultiKey"), exports);
(0, tslib_1.__exportStar)(require("./CryptoKeypath"), exports);
(0, tslib_1.__exportStar)(require("./patchCBOR"), exports);
(0, tslib_1.__exportStar)(require("./PathComponent"), exports);
(0, tslib_1.__exportStar)(require("./RegistryItem"), exports);
(0, tslib_1.__exportStar)(require("./RegistryType"), exports);
(0, tslib_1.__exportStar)(require("./types"), exports);
(0, tslib_1.__exportStar)(require("./utils"), exports);
exports.default = URlib;
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\DataItem.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Clib%5CDataItem.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataItem = void 0;
class DataItem {
    constructor(data, tag) {
        this.setTag = (tag) => {
            this.tag = tag;
        };
        this.clearTag = () => {
            this.tag = undefined;
        };
        this.getTag = () => {
            return this.tag;
        };
        this.getData = () => {
            return this.data;
        };
        this.data = data;
        this.tag = tag;
    }
}
exports.DataItem = DataItem;
//# sourceMappingURL=DataItem.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\DataItem.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\cbor-sync.js", {"./DataItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\DataItem.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Clib%5Ccbor-sync.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
(function (global, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    }
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = factory();
    }
    else {
        global.CBOR = factory();
    }
})(this, function () {
    const { DataItem } = require('./DataItem');
    var CBOR = (function () {
        function BinaryHex(hex) {
            this.$hex = hex;
        }
        BinaryHex.prototype = {
            length: function () {
                return this.$hex.length / 2;
            },
            toString: function (format) {
                if (!format || format === 'hex' || format === 16)
                    return this.$hex;
                if (format === 'utf-8') {
                    var encoded = '';
                    for (var i = 0; i < this.$hex.length; i += 2) {
                        encoded += '%' + this.$hex.substring(i, i + 2);
                    }
                    return decodeURIComponent(encoded);
                }
                if (format === 'latin') {
                    var encoded = [];
                    for (var i = 0; i < this.$hex.length; i += 2) {
                        encoded.push(parseInt(this.$hex.substring(i, i + 2), 16));
                    }
                    return String.fromCharCode.apply(String, encoded);
                }
                throw new Error('Unrecognised format: ' + format);
            },
        };
        BinaryHex.fromLatinString = function (latinString) {
            var hex = '';
            for (var i = 0; i < latinString.length; i++) {
                var pair = latinString.charCodeAt(i).toString(16);
                if (pair.length === 1)
                    pair = '0' + pair;
                hex += pair;
            }
            return new BinaryHex(hex);
        };
        BinaryHex.fromUtf8String = function (utf8String) {
            var encoded = encodeURIComponent(utf8String);
            var hex = '';
            for (var i = 0; i < encoded.length; i++) {
                if (encoded.charAt(i) === '%') {
                    hex += encoded.substring(i + 1, i + 3);
                    i += 2;
                }
                else {
                    var hexPair = encoded.charCodeAt(i).toString(16);
                    if (hexPair.length < 2)
                        hexPair = '0' + hexPair;
                    hex += hexPair;
                }
            }
            return new BinaryHex(hex);
        };
        var semanticEncoders = [];
        var semanticDecoders = {};
        var notImplemented = function (label) {
            return function () {
                throw new Error(label + ' not implemented');
            };
        };
        function Reader() { }
        Reader.prototype = {
            peekByte: notImplemented('peekByte'),
            readByte: notImplemented('readByte'),
            readChunk: notImplemented('readChunk'),
            readFloat16: function () {
                var half = this.readUint16();
                var exponent = (half & 0x7fff) >> 10;
                var mantissa = half & 0x3ff;
                var negative = half & 0x8000;
                if (exponent === 0x1f) {
                    if (mantissa === 0) {
                        return negative ? -Infinity : Infinity;
                    }
                    return NaN;
                }
                var magnitude = exponent
                    ? Math.pow(2, exponent - 25) * (1024 + mantissa)
                    : Math.pow(2, -24) * mantissa;
                return negative ? -magnitude : magnitude;
            },
            readFloat32: function () {
                var intValue = this.readUint32();
                var exponent = (intValue & 0x7fffffff) >> 23;
                var mantissa = intValue & 0x7fffff;
                var negative = intValue & 0x80000000;
                if (exponent === 0xff) {
                    if (mantissa === 0) {
                        return negative ? -Infinity : Infinity;
                    }
                    return NaN;
                }
                var magnitude = exponent
                    ? Math.pow(2, exponent - 23 - 127) * (8388608 + mantissa)
                    : Math.pow(2, -23 - 126) * mantissa;
                return negative ? -magnitude : magnitude;
            },
            readFloat64: function () {
                var int1 = this.readUint32(), int2 = this.readUint32();
                var exponent = (int1 >> 20) & 0x7ff;
                var mantissa = (int1 & 0xfffff) * 4294967296 + int2;
                var negative = int1 & 0x80000000;
                if (exponent === 0x7ff) {
                    if (mantissa === 0) {
                        return negative ? -Infinity : Infinity;
                    }
                    return NaN;
                }
                var magnitude = exponent
                    ? Math.pow(2, exponent - 52 - 1023) * (4503599627370496 + mantissa)
                    : Math.pow(2, -52 - 1022) * mantissa;
                return negative ? -magnitude : magnitude;
            },
            readUint16: function () {
                return this.readByte() * 256 + this.readByte();
            },
            readUint32: function () {
                return this.readUint16() * 65536 + this.readUint16();
            },
            readUint64: function () {
                return this.readUint32() * 4294967296 + this.readUint32();
            },
        };
        function Writer() { }
        Writer.prototype = {
            writeByte: notImplemented('writeByte'),
            result: notImplemented('result'),
            writeFloat16: notImplemented('writeFloat16'),
            writeFloat32: notImplemented('writeFloat32'),
            writeFloat64: notImplemented('writeFloat64'),
            writeUint16: function (value) {
                this.writeByte((value >> 8) & 0xff);
                this.writeByte(value & 0xff);
            },
            writeUint32: function (value) {
                this.writeUint16((value >> 16) & 0xffff);
                this.writeUint16(value & 0xffff);
            },
            writeUint64: function (value) {
                if (value >= 9007199254740992 || value <= -9007199254740992) {
                    throw new Error('Cannot encode Uint64 of: ' +
                        value +
                        ' magnitude to big (floating point errors)');
                }
                this.writeUint32(Math.floor(value / 4294967296));
                this.writeUint32(value % 4294967296);
            },
            writeString: notImplemented('writeString'),
            canWriteBinary: function (chunk) {
                return false;
            },
            writeBinary: notImplemented('writeChunk'),
        };
        function readHeaderRaw(reader) {
            var firstByte = reader.readByte();
            var majorType = firstByte >> 5, value = firstByte & 0x1f;
            return { type: majorType, value: value };
        }
        function valueFromHeader(header, reader) {
            var value = header.value;
            if (value < 24) {
                return value;
            }
            else if (value == 24) {
                return reader.readByte();
            }
            else if (value == 25) {
                return reader.readUint16();
            }
            else if (value == 26) {
                return reader.readUint32();
            }
            else if (value == 27) {
                return reader.readUint64();
            }
            else if (value == 31) {
                return null;
            }
            notImplemented('Additional info: ' + value)();
        }
        function writeHeaderRaw(type, value, writer) {
            writer.writeByte((type << 5) | value);
        }
        function writeHeader(type, value, writer) {
            var firstByte = type << 5;
            if (value < 24) {
                writer.writeByte(firstByte | value);
            }
            else if (value < 256) {
                writer.writeByte(firstByte | 24);
                writer.writeByte(value);
            }
            else if (value < 65536) {
                writer.writeByte(firstByte | 25);
                writer.writeUint16(value);
            }
            else if (value < 4294967296) {
                writer.writeByte(firstByte | 26);
                writer.writeUint32(value);
            }
            else {
                writer.writeByte(firstByte | 27);
                writer.writeUint64(value);
            }
        }
        var stopCode = new Error();
        function decodeReader(reader) {
            var header = readHeaderRaw(reader);
            switch (header.type) {
                case 0:
                    return valueFromHeader(header, reader);
                case 1:
                    return -1 - valueFromHeader(header, reader);
                case 2:
                    return reader.readChunk(valueFromHeader(header, reader));
                case 3:
                    var buffer = reader.readChunk(valueFromHeader(header, reader));
                    return buffer.toString('utf-8');
                case 4:
                case 5:
                    var arrayLength = valueFromHeader(header, reader);
                    var result = [];
                    if (arrayLength !== null) {
                        if (header.type === 5) {
                            arrayLength *= 2;
                        }
                        for (var i = 0; i < arrayLength; i++) {
                            result[i] = decodeReader(reader);
                        }
                    }
                    else {
                        var item;
                        while ((item = decodeReader(reader)) !== stopCode) {
                            result.push(item);
                        }
                    }
                    if (header.type === 5) {
                        var objResult = {};
                        for (var i = 0; i < result.length; i += 2) {
                            objResult[result[i]] = result[i + 1];
                        }
                        return objResult;
                    }
                    else {
                        return result;
                    }
                case 6:
                    var tag = valueFromHeader(header, reader);
                    var decoder = semanticDecoders[tag];
                    var result = decodeReader(reader);
                    return decoder ? decoder(result) : result;
                case 7:
                    if (header.value === 25) {
                        return reader.readFloat16();
                    }
                    else if (header.value === 26) {
                        return reader.readFloat32();
                    }
                    else if (header.value === 27) {
                        return reader.readFloat64();
                    }
                    switch (valueFromHeader(header, reader)) {
                        case 20:
                            return false;
                        case 21:
                            return true;
                        case 22:
                            return null;
                        case 23:
                            return undefined;
                        case null:
                            return stopCode;
                        default:
                            throw new Error('Unknown fixed value: ' + header.value);
                    }
                default:
                    throw new Error('Unsupported header: ' + JSON.stringify(header));
            }
            throw new Error('not implemented yet');
        }
        function encodeWriter(data, writer) {
            for (var i = 0; i < semanticEncoders.length; i++) {
                var replacement = semanticEncoders[i].fn(data);
                if (replacement !== undefined) {
                    writeHeader(6, semanticEncoders[i].tag, writer);
                    return encodeWriter(replacement, writer);
                }
            }
            if (data && typeof data.toCBOR === 'function') {
                data = data.toCBOR();
            }
            if (data === false) {
                writeHeader(7, 20, writer);
            }
            else if (data === true) {
                writeHeader(7, 21, writer);
            }
            else if (data === null) {
                writeHeader(7, 22, writer);
            }
            else if (data === undefined) {
                writeHeader(7, 23, writer);
            }
            else if (typeof data === 'number') {
                if (Math.floor(data) === data &&
                    data < 9007199254740992 &&
                    data > -9007199254740992) {
                    if (data < 0) {
                        writeHeader(1, -1 - data, writer);
                    }
                    else {
                        writeHeader(0, data, writer);
                    }
                }
                else {
                    writeHeaderRaw(7, 27, writer);
                    writer.writeFloat64(data);
                }
            }
            else if (typeof data === 'string') {
                writer.writeString(data, function (length) {
                    writeHeader(3, length, writer);
                });
            }
            else if (writer.canWriteBinary(data)) {
                writer.writeBinary(data, function (length) {
                    writeHeader(2, length, writer);
                });
            }
            else if (typeof data === 'object') {
                if (api.config.useToJSON && typeof data.toJSON === 'function') {
                    data = data.toJSON();
                }
                if (Array.isArray(data)) {
                    writeHeader(4, data.length, writer);
                    for (var i = 0; i < data.length; i++) {
                        encodeWriter(data[i], writer);
                    }
                }
                else {
                    var keys = Object.keys(data);
                    writeHeader(5, keys.length, writer);
                    for (var i = 0; i < keys.length; i++) {
                        const number = parseInt(keys[i]);
                        if (isNaN(number)) {
                            encodeWriter(keys[i], writer);
                            encodeWriter(data[keys[i]], writer);
                        }
                        else {
                            encodeWriter(number, writer);
                            encodeWriter(data[keys[i]], writer);
                        }
                    }
                }
            }
            else {
                throw new Error('CBOR encoding not supported: ' + data);
            }
        }
        var readerFunctions = [];
        var writerFunctions = [];
        var api = {
            config: {
                useToJSON: true,
            },
            addWriter: function (format, writerFunction) {
                if (typeof format === 'string') {
                    writerFunctions.push(function (f) {
                        if (format === f)
                            return writerFunction(f);
                    });
                }
                else {
                    writerFunctions.push(format);
                }
            },
            addReader: function (format, readerFunction) {
                if (typeof format === 'string') {
                    readerFunctions.push(function (data, f) {
                        if (format === f)
                            return readerFunction(data, f);
                    });
                }
                else {
                    readerFunctions.push(format);
                }
            },
            encode: function (data, format) {
                for (var i = 0; i < writerFunctions.length; i++) {
                    var func = writerFunctions[i];
                    var writer = func(format);
                    if (writer) {
                        encodeWriter(data, writer);
                        return writer.result();
                    }
                }
                throw new Error('Unsupported output format: ' + format);
            },
            encodeDataItem: function (data, format) {
                for (var i = 0; i < writerFunctions.length; i++) {
                    var func = writerFunctions[i];
                    var writer = func(format);
                    if (writer) {
                        if (data.getTag() !== undefined) {
                            encodeWriter(data, writer);
                            return writer.result();
                        }
                        else {
                            encodeWriter(data.getData(), writer);
                            return writer.result();
                        }
                    }
                }
                throw new Error('Unsupported output format: ' + format);
            },
            decode: function (data, format) {
                for (var i = 0; i < readerFunctions.length; i++) {
                    var func = readerFunctions[i];
                    var reader = func(data, format);
                    if (reader) {
                        return decodeReader(reader);
                    }
                }
                throw new Error('Unsupported input format: ' + format);
            },
            decodeToDataItem: function (data, format) {
                for (var i = 0; i < readerFunctions.length; i++) {
                    var func = readerFunctions[i];
                    var reader = func(data, format);
                    if (reader) {
                        const result = decodeReader(reader);
                        if (result instanceof DataItem) {
                            return result;
                        }
                        else {
                            return new DataItem(result);
                        }
                    }
                }
                throw new Error('Unsupported input format: ' + format);
            },
            addSemanticEncode: function (tag, fn) {
                if (typeof tag !== 'number' || tag % 1 !== 0 || tag < 0) {
                    throw new Error('Tag must be a positive integer');
                }
                semanticEncoders.push({ tag: tag, fn: fn });
                return this;
            },
            addSemanticDecode: function (tag, fn) {
                if (typeof tag !== 'number' || tag % 1 !== 0 || tag < 0) {
                    throw new Error('Tag must be a positive integer');
                }
                semanticDecoders[tag] = fn;
                return this;
            },
        };
        function BufferReader(buffer) {
            this.buffer = buffer;
            this.pos = 0;
        }
        BufferReader.prototype = Object.create(Reader.prototype);
        BufferReader.prototype.peekByte = function () {
            return this.buffer[this.pos];
        };
        BufferReader.prototype.readByte = function () {
            return this.buffer[this.pos++];
        };
        BufferReader.prototype.readUint16 = function () {
            var result = this.buffer.readUInt16BE(this.pos);
            this.pos += 2;
            return result;
        };
        BufferReader.prototype.readUint32 = function () {
            var result = this.buffer.readUInt32BE(this.pos);
            this.pos += 4;
            return result;
        };
        BufferReader.prototype.readFloat32 = function () {
            var result = this.buffer.readFloatBE(this.pos);
            this.pos += 4;
            return result;
        };
        BufferReader.prototype.readFloat64 = function () {
            var result = this.buffer.readDoubleBE(this.pos);
            this.pos += 8;
            return result;
        };
        BufferReader.prototype.readChunk = function (length) {
            var result = Buffer.alloc(length);
            this.buffer.copy(result, 0, this.pos, (this.pos += length));
            return result;
        };
        function BufferWriter(stringFormat) {
            this.byteLength = 0;
            this.defaultBufferLength = 16384;
            this.latestBuffer = Buffer.alloc(this.defaultBufferLength);
            this.latestBufferOffset = 0;
            this.completeBuffers = [];
            this.stringFormat = stringFormat;
        }
        BufferWriter.prototype = Object.create(Writer.prototype);
        BufferWriter.prototype.writeByte = function (value) {
            this.latestBuffer[this.latestBufferOffset++] = value;
            if (this.latestBufferOffset >= this.latestBuffer.length) {
                this.completeBuffers.push(this.latestBuffer);
                this.latestBuffer = Buffer.alloc(this.defaultBufferLength);
                this.latestBufferOffset = 0;
            }
            this.byteLength++;
        };
        BufferWriter.prototype.writeFloat32 = function (value) {
            var buffer = Buffer.alloc(4);
            buffer.writeFloatBE(value, 0);
            this.writeBuffer(buffer);
        };
        BufferWriter.prototype.writeFloat64 = function (value) {
            var buffer = Buffer.alloc(8);
            buffer.writeDoubleBE(value, 0);
            this.writeBuffer(buffer);
        };
        BufferWriter.prototype.writeString = function (string, lengthFunc) {
            var buffer = Buffer.from(string, 'utf-8');
            lengthFunc(buffer.length);
            this.writeBuffer(buffer);
        };
        BufferWriter.prototype.canWriteBinary = function (data) {
            return data instanceof Buffer;
        };
        BufferWriter.prototype.writeBinary = function (buffer, lengthFunc) {
            lengthFunc(buffer.length);
            this.writeBuffer(buffer);
        };
        BufferWriter.prototype.writeBuffer = function (chunk) {
            if (!(chunk instanceof Buffer))
                throw new TypeError('BufferWriter only accepts Buffers');
            if (!this.latestBufferOffset) {
                this.completeBuffers.push(chunk);
            }
            else if (this.latestBuffer.length - this.latestBufferOffset >=
                chunk.length) {
                chunk.copy(this.latestBuffer, this.latestBufferOffset);
                this.latestBufferOffset += chunk.length;
                if (this.latestBufferOffset >= this.latestBuffer.length) {
                    this.completeBuffers.push(this.latestBuffer);
                    this.latestBuffer = Buffer.alloc(this.defaultBufferLength);
                    this.latestBufferOffset = 0;
                }
            }
            else {
                this.completeBuffers.push(this.latestBuffer.slice(0, this.latestBufferOffset));
                this.completeBuffers.push(chunk);
                this.latestBuffer = Buffer.alloc(this.defaultBufferLength);
                this.latestBufferOffset = 0;
            }
            this.byteLength += chunk.length;
        };
        BufferWriter.prototype.result = function () {
            var result = Buffer.alloc(this.byteLength);
            var offset = 0;
            for (var i = 0; i < this.completeBuffers.length; i++) {
                var buffer = this.completeBuffers[i];
                buffer.copy(result, offset, 0, buffer.length);
                offset += buffer.length;
            }
            if (this.latestBufferOffset) {
                this.latestBuffer.copy(result, offset, 0, this.latestBufferOffset);
            }
            if (this.stringFormat)
                return result.toString(this.stringFormat);
            return result;
        };
        if (typeof Buffer === 'function') {
            api.addReader(function (data, format) {
                if (Buffer.isBuffer(data)) {
                    return new BufferReader(data);
                }
                if (format === 'hex' || format === 'base64') {
                    var buffer = Buffer.from(data, format);
                    return new BufferReader(buffer);
                }
            });
            api.addWriter(function (format) {
                if (!format || format === 'buffer') {
                    return new BufferWriter();
                }
                else if (format === 'hex' || format === 'base64') {
                    return new BufferWriter(format);
                }
            });
        }
        function HexReader(hex) {
            this.hex = hex;
            this.pos = 0;
        }
        HexReader.prototype = Object.create(Reader.prototype);
        HexReader.prototype.peekByte = function () {
            var pair = this.hex.substring(this.pos, 2);
            return parseInt(pair, 16);
        };
        HexReader.prototype.readByte = function () {
            var pair = this.hex.substring(this.pos, this.pos + 2);
            this.pos += 2;
            return parseInt(pair, 16);
        };
        HexReader.prototype.readChunk = function (length) {
            var hex = this.hex.substring(this.pos, this.pos + length * 2);
            this.pos += length * 2;
            if (typeof Buffer === 'function')
                return Buffer.from(hex, 'hex');
            return new BinaryHex(hex);
        };
        function HexWriter(finalFormat) {
            this.$hex = '';
            this.finalFormat = finalFormat || 'hex';
        }
        HexWriter.prototype = Object.create(Writer.prototype);
        HexWriter.prototype.writeByte = function (value) {
            if (value < 0 || value > 255)
                throw new Error('Byte value out of range: ' + value);
            var hex = value.toString(16);
            if (hex.length == 1) {
                hex = '0' + hex;
            }
            this.$hex += hex;
        };
        HexWriter.prototype.canWriteBinary = function (chunk) {
            return (chunk instanceof BinaryHex ||
                (typeof Buffer === 'function' && chunk instanceof Buffer));
        };
        HexWriter.prototype.writeBinary = function (chunk, lengthFunction) {
            if (chunk instanceof BinaryHex) {
                lengthFunction(chunk.length());
                this.$hex += chunk.$hex;
            }
            else if (typeof Buffer === 'function' && chunk instanceof Buffer) {
                lengthFunction(chunk.length);
                this.$hex += chunk.toString('hex');
            }
            else {
                throw new TypeError('HexWriter only accepts BinaryHex or Buffers');
            }
        };
        HexWriter.prototype.result = function () {
            if (this.finalFormat === 'buffer' && typeof Buffer === 'function') {
                return Buffer.from(this.$hex, 'hex');
            }
            return new BinaryHex(this.$hex).toString(this.finalFormat);
        };
        HexWriter.prototype.writeString = function (string, lengthFunction) {
            var buffer = BinaryHex.fromUtf8String(string);
            lengthFunction(buffer.length());
            this.$hex += buffer.$hex;
        };
        api.addReader(function (data, format) {
            if (data instanceof BinaryHex || data.$hex) {
                return new HexReader(data.$hex);
            }
            if (format === 'hex') {
                return new HexReader(data);
            }
        });
        api.addWriter(function (format) {
            if (format === 'hex') {
                return new HexWriter();
            }
        });
        return api;
    })();
    CBOR.addSemanticEncode(0, function (data) {
        if (data instanceof Date) {
            return data.toISOString();
        }
    })
        .addSemanticDecode(0, function (isoString) {
        return new Date(isoString);
    })
        .addSemanticDecode(1, function (isoString) {
        return new Date(isoString);
    });
    return CBOR;
});

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\cbor-sync.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js", {"./DataItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\DataItem.js","./cbor-sync":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\cbor-sync.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Clib%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataItem = exports.addWriter = exports.addReader = exports.addSemanticEncode = exports.addSemanticDecode = exports.decodeToDataItem = exports.encodeDataItem = void 0;
var cbor_sync_1 = require("./cbor-sync");
Object.defineProperty(exports, "encodeDataItem", { enumerable: true, get: function () { return cbor_sync_1.encodeDataItem; } });
Object.defineProperty(exports, "decodeToDataItem", { enumerable: true, get: function () { return cbor_sync_1.decodeToDataItem; } });
Object.defineProperty(exports, "addSemanticDecode", { enumerable: true, get: function () { return cbor_sync_1.addSemanticDecode; } });
Object.defineProperty(exports, "addSemanticEncode", { enumerable: true, get: function () { return cbor_sync_1.addSemanticEncode; } });
Object.defineProperty(exports, "addReader", { enumerable: true, get: function () { return cbor_sync_1.addReader; } });
Object.defineProperty(exports, "addWriter", { enumerable: true, get: function () { return cbor_sync_1.addWriter; } });
var DataItem_1 = require("./DataItem");
Object.defineProperty(exports, "DataItem", { enumerable: true, get: function () { return DataItem_1.DataItem; } });
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\patchCBOR.js", {"./RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./ScriptExpression":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\ScriptExpression.js","./utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CpatchCBOR.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const RegistryType_1 = require("./RegistryType");
const ScriptExpression_1 = require("./ScriptExpression");
const registryTags = Object.values(RegistryType_1.RegistryTypes)
    .filter((r) => !!r.getTag())
    .map((r) => r.getTag());
const scriptExpressionTags = Object.values(ScriptExpression_1.ScriptExpressions).map((se) => se.getTag());
(0, utils_1.patchTags)(registryTags.concat(scriptExpressionTags));
//# sourceMappingURL=patchCBOR.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\patchCBOR.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\types.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Ctypes.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=types.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\types.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\utils.js", {"./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Cutils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.patchTags = void 0;
const lib_1 = require("./lib");
const alreadyPatchedTag = [];
const patchTags = (tags) => {
    tags.forEach((tag) => {
        if (alreadyPatchedTag.find((i) => i === tag))
            return;
        (0, lib_1.addSemanticEncode)(tag, (data) => {
            if (data instanceof lib_1.DataItem) {
                if (data.getTag() === tag) {
                    return data.getData();
                }
            }
        });
        (0, lib_1.addSemanticDecode)(tag, (data) => {
            return new lib_1.DataItem(data, tag);
        });
        alreadyPatchedTag.push(tag);
    });
};
exports.patchTags = patchTags;
//# sourceMappingURL=utils.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\utils.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\rlp\\dist\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5Crlp%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.utils = exports.decode = exports.encode = void 0;
/**
 * RLP Encoding based on https://eth.wiki/en/fundamentals/rlp
 * This function takes in data, converts it to Uint8Array if not,
 * and adds a length for recursion.
 * @param input Will be converted to Uint8Array
 * @returns Uint8Array of encoded data
 **/
function encode(input) {
    if (Array.isArray(input)) {
        const output = [];
        for (let i = 0; i < input.length; i++) {
            output.push(encode(input[i]));
        }
        const buf = concatBytes(...output);
        return concatBytes(encodeLength(buf.length, 192), buf);
    }
    const inputBuf = toBytes(input);
    if (inputBuf.length === 1 && inputBuf[0] < 128) {
        return inputBuf;
    }
    return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);
}
exports.encode = encode;
/**
 * Slices a Uint8Array, throws if the slice goes out-of-bounds of the Uint8Array.
 * E.g. `safeSlice(hexToBytes('aa'), 1, 2)` will throw.
 * @param input
 * @param start
 * @param end
 */
function safeSlice(input, start, end) {
    if (end > input.length) {
        throw new Error('invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds');
    }
    return input.slice(start, end);
}
/**
 * Parse integers. Check if there is no leading zeros
 * @param v The value to parse
 */
function decodeLength(v) {
    if (v[0] === 0) {
        throw new Error('invalid RLP: extra zeros');
    }
    return parseHexByte(bytesToHex(v));
}
function encodeLength(len, offset) {
    if (len < 56) {
        return Uint8Array.from([len + offset]);
    }
    const hexLength = numberToHex(len);
    const lLength = hexLength.length / 2;
    const firstByte = numberToHex(offset + 55 + lLength);
    return Uint8Array.from(hexToBytes(firstByte + hexLength));
}
function decode(input, stream = false) {
    if (!input || input.length === 0) {
        return Uint8Array.from([]);
    }
    const inputBytes = toBytes(input);
    const decoded = _decode(inputBytes);
    if (stream) {
        return decoded;
    }
    if (decoded.remainder.length !== 0) {
        throw new Error('invalid RLP: remainder must be zero');
    }
    return decoded.data;
}
exports.decode = decode;
/** Decode an input with RLP */
function _decode(input) {
    let length, llength, data, innerRemainder, d;
    const decoded = [];
    const firstByte = input[0];
    if (firstByte <= 0x7f) {
        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
        return {
            data: input.slice(0, 1),
            remainder: input.slice(1),
        };
    }
    else if (firstByte <= 0xb7) {
        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
        // The range of the first byte is [0x80, 0xb7]
        length = firstByte - 0x7f;
        // set 0x80 null to 0
        if (firstByte === 0x80) {
            data = Uint8Array.from([]);
        }
        else {
            data = safeSlice(input, 1, length);
        }
        if (length === 2 && data[0] < 0x80) {
            throw new Error('invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed');
        }
        return {
            data: data,
            remainder: input.slice(length),
        };
    }
    else if (firstByte <= 0xbf) {
        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),
        // followed by the length, followed by the string
        llength = firstByte - 0xb6;
        if (input.length - 1 < llength) {
            throw new Error('invalid RLP: not enough bytes for string length');
        }
        length = decodeLength(safeSlice(input, 1, llength));
        if (length <= 55) {
            throw new Error('invalid RLP: expected string length to be greater than 55');
        }
        data = safeSlice(input, llength, length + llength);
        return {
            data: data,
            remainder: input.slice(length + llength),
        };
    }
    else if (firstByte <= 0xf7) {
        // a list between 0-55 bytes long
        length = firstByte - 0xbf;
        innerRemainder = safeSlice(input, 1, length);
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(length),
        };
    }
    else {
        // a list over 55 bytes long
        llength = firstByte - 0xf6;
        length = decodeLength(safeSlice(input, 1, llength));
        if (length < 56) {
            throw new Error('invalid RLP: encoded list too short');
        }
        const totalLength = llength + length;
        if (totalLength > input.length) {
            throw new Error('invalid RLP: total length is larger than the data');
        }
        innerRemainder = safeSlice(input, llength, totalLength);
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(totalLength),
        };
    }
}
const cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));
function bytesToHex(uint8a) {
    // Pre-caching chars with `cachedHexes` speeds this up 6x
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += cachedHexes[uint8a[i]];
    }
    return hex;
}
function parseHexByte(hexByte) {
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte))
        throw new Error('Invalid byte sequence');
    return byte;
}
// Caching slows it down 2-3x
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex');
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        array[i] = parseHexByte(hex.slice(j, j + 2));
    }
    return array;
}
/** Concatenates two Uint8Arrays into one. */
function concatBytes(...arrays) {
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
function utf8ToBytes(utf) {
    return new TextEncoder().encode(utf);
}
/** Transform an integer into its hexadecimal value */
function numberToHex(integer) {
    if (integer < 0) {
        throw new Error('Invalid integer as argument, must be unsigned!');
    }
    const hex = integer.toString(16);
    return hex.length % 2 ? `0${hex}` : hex;
}
/** Pad a string to be even */
function padToEven(a) {
    return a.length % 2 ? `0${a}` : a;
}
/** Check if a string is prefixed by 0x */
function isHexPrefixed(str) {
    return str.length >= 2 && str[0] === '0' && str[1] === 'x';
}
/** Removes 0x from a given String */
function stripHexPrefix(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return isHexPrefixed(str) ? str.slice(2) : str;
}
/** Transform anything into a Uint8Array */
function toBytes(v) {
    if (v instanceof Uint8Array) {
        return v;
    }
    if (typeof v === 'string') {
        if (isHexPrefixed(v)) {
            return hexToBytes(padToEven(stripHexPrefix(v)));
        }
        return utf8ToBytes(v);
    }
    if (typeof v === 'number' || typeof v === 'bigint') {
        if (!v) {
            return Uint8Array.from([]);
        }
        return hexToBytes(numberToHex(v));
    }
    if (v === null || v === undefined) {
        return Uint8Array.from([]);
    }
    throw new Error('toBytes: received unsupported type ' + typeof v);
}
exports.utils = {
    bytesToHex,
    concatBytes,
    hexToBytes,
    utf8ToBytes,
};
const RLP = { encode, decode };
exports.default = RLP;
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>rlp",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\rlp\\dist\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\index.js", {"./metamask-airgapped-keyring.cjs.development.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.development.js","./metamask-airgapped-keyring.cjs.production.min.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.production.min.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cdist%5Cindex.js
      return function (require, module, exports) {

'use strict'

if ("development" === 'production') {
  module.exports = require('./metamask-airgapped-keyring.cjs.production.min.js')
} else {
  module.exports = require('./metamask-airgapped-keyring.cjs.development.js')
}

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.development.js", {"@ethereumjs/tx":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ethereumjs\\tx\\dist\\index.js","@keystonehq/base-eth-keyring":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\index.js","@keystonehq/bc-ur-registry-eth":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js","@metamask/obs-store":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\index.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js","events":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\events\\events.js","rlp":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\rlp\\dist.browser\\index.js","uuid":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cdist%5Cmetamask-airgapped-keyring.cjs.development.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var baseEthKeyring = require('@keystonehq/base-eth-keyring');
var events = require('events');
var obsStore = require('@metamask/obs-store');
var bcUrRegistryEth = require('@keystonehq/bc-ur-registry-eth');
var uuid = require('uuid');
var tx = require('@ethereumjs/tx');
var rlp = _interopDefault(require('rlp'));

class MetamaskInteractionProvider extends events.EventEmitter {
  constructor() {
    super();

    this.cleanSyncListeners = () => {
      this.removeAllListeners("keystone-sync_success-hdkey");
      this.removeAllListeners("keystone-sync_success-account");
      this.removeAllListeners("keystone-sync_cancel");
    };

    this.cleanSignListeners = requestId => {
      this.removeAllListeners(`${requestId}-signed`);
      this.removeAllListeners(`${requestId}-canceled`);
    };

    this.readCryptoHDKeyOrCryptoAccount = () => {
      return new Promise((resolve, reject) => {
        this.memStore.updateState({
          sync: {
            reading: true
          }
        });
        this.on("keystone-sync_success-hdkey", cbor => {
          const cryptoHDKey = bcUrRegistryEth.CryptoHDKey.fromCBOR(Buffer.from(cbor, "hex"));
          this.resetState();
          resolve(cryptoHDKey);
        });
        this.on("keystone-sync_success-account", cbor => {
          const cryptoAccount = bcUrRegistryEth.CryptoAccount.fromCBOR(Buffer.from(cbor, "hex"));
          this.resetState();
          resolve(cryptoAccount);
        });
        this.on("keystone-sync_cancel", () => {
          this.resetState();
          reject(new Error("KeystoneError#sync_cancel. Sync process canceled, please retry"));
        });
      });
    };

    this.submitCryptoHDKey = cbor => {
      this.emit("keystone-sync_success-hdkey", cbor);
    };

    this.submitCryptoAccount = cbor => {
      this.emit("keystone-sync_success-account", cbor);
    };

    this.cancelSync = () => {
      this.emit("keystone-sync_cancel");
    };

    this.requestSignature = (signRequest, requestTitle, requestDescription) => {
      return new Promise((resolve, reject) => {
        const ur = signRequest.toUR();
        const requestIdBuffer = signRequest.getRequestId();
        const requestId = uuid.stringify(requestIdBuffer);
        const signPayload = {
          requestId,
          payload: {
            type: ur.type,
            cbor: ur.cbor.toString("hex")
          },
          title: requestTitle,
          description: requestDescription
        };
        this.memStore.updateState({
          sign: {
            request: signPayload
          }
        });
        this.once(`${requestId}-signed`, cbor => {
          const ethSignature = bcUrRegistryEth.ETHSignature.fromCBOR(Buffer.from(cbor, "hex"));
          this.resetState();
          resolve(ethSignature);
        });
        this.once(`${requestId}-canceled`, () => {
          this.resetState();
          reject(new Error("KeystoneError#Tx_canceled. Signing canceled, please retry"));
        });
      });
    };

    this.submitSignature = (requestId, cbor) => {
      this.emit(`${requestId}-signed`, cbor);
    };

    this.cancelRequestSignature = () => {
      const signPayload = this.memStore.getState().sign.request;

      if (signPayload) {
        const {
          requestId
        } = signPayload;
        this.memStore.updateState({
          sign: {}
        });
        this.emit(`${requestId}-canceled`);
      }
    };

    this.reset = () => {
      this.cleanSyncListeners();
      const signPayload = this.memStore.getState().sign.request;

      if (signPayload) {
        const {
          requestId
        } = signPayload;
        this.cleanSignListeners(requestId);
      }

      this.resetState();
    };

    this.resetState = () => {
      this.memStore.updateState({
        sync: {
          reading: false
        },
        sign: {}
      });
    };

    if (MetamaskInteractionProvider.instance) {
      return MetamaskInteractionProvider.instance;
    }

    this.memStore = new obsStore.ObservableStore({
      sync: {
        reading: false
      },
      sign: {},
      _version: 1
    });
    MetamaskInteractionProvider.instance = this;
  }

}

class MetaMaskKeyring extends baseEthKeyring.BaseKeyring {
  constructor(opts) {
    super(opts);

    this.getInteraction = () => {
      return new MetamaskInteractionProvider();
    };

    this.resetStore = () => {
      this.getInteraction().reset();
    };

    this.getMemStore = () => {
      return this.getInteraction().memStore;
    };

    this.removeAccount = address => {
      if (!this.accounts.map(a => a.toLowerCase()).includes(address.toLowerCase())) {
        throw new Error(`Address ${address} not found in this keyring`);
      }

      this.accounts = this.accounts.filter(a => a.toLowerCase() !== address.toLowerCase());
    };

    this.forgetDevice = () => {
      //common props
      this.page = 0;
      this.perPage = 5;
      this.accounts = [];
      this.currentAccount = 0;
      this.name = "QR Hardware";
      this.initialized = false; //hd props;

      this.xfp = "";
      this.xpub = "";
      this.hdPath = "";
      this.indexes = {};
      this.hdk = undefined; //pubkey props;

      this.paths = {};
    };

    this.submitCryptoHDKey = this.getInteraction().submitCryptoHDKey;
    this.submitCryptoAccount = this.getInteraction().submitCryptoAccount;
    this.submitSignature = this.getInteraction().submitSignature;
    this.cancelSync = this.getInteraction().cancelSync;
    this.cancelSignRequest = this.getInteraction().cancelRequestSignature;

    if (MetaMaskKeyring.instance) {
      MetaMaskKeyring.instance.deserialize(opts);
      return MetaMaskKeyring.instance;
    }

    MetaMaskKeyring.instance = this;
  }

  async signTransaction(address, tx$1) {
    const dataType = tx$1.type === 0 ? bcUrRegistryEth.DataType.transaction : bcUrRegistryEth.DataType.typedTransaction;
    let messageToSign;

    if (tx$1.type === 0) {
      messageToSign = rlp.encode(tx$1.getMessageToSign(false));
    } else {
      messageToSign = tx$1.getMessageToSign(false);
    }

    const hdPath = await this._pathFromAddress(address);
    const chainId = tx$1.common.chainId();
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(messageToSign, dataType, hdPath, this.xfp, requestId, chainId, address);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, "Scan with your Keystone", 'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature');
    const txJson = tx$1.toJSON();
    txJson.v = v;
    txJson.s = s;
    txJson.r = r;
    txJson.type = tx$1.type;
    const transaction = tx.TransactionFactory.fromTxData(txJson, {
      common: tx$1.common
    });
    return transaction;
  }

}
MetaMaskKeyring.type = baseEthKeyring.BaseKeyring.type;

exports.MetaMaskKeyring = MetaMaskKeyring;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.development.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.production.min.js", {"@ethereumjs/tx":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ethereumjs\\tx\\dist\\index.js","@keystonehq/base-eth-keyring":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\index.js","@keystonehq/bc-ur-registry-eth":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js","@metamask/obs-store":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\index.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js","events":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\events\\events.js","rlp":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\rlp\\dist.browser\\index.js","uuid":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cdist%5Cmetamask-airgapped-keyring.cjs.production.min.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e,t=require("@keystonehq/base-eth-keyring"),s=require("events"),n=require("@metamask/obs-store"),i=require("@keystonehq/bc-ur-registry-eth"),r=require("uuid"),c=require("@ethereumjs/tx"),o=(e=require("rlp"))&&"object"==typeof e&&"default"in e?e.default:e;class a extends s.EventEmitter{constructor(){if(super(),this.cleanSyncListeners=()=>{this.removeAllListeners("keystone-sync_success-hdkey"),this.removeAllListeners("keystone-sync_success-account"),this.removeAllListeners("keystone-sync_cancel")},this.cleanSignListeners=e=>{this.removeAllListeners(e+"-signed"),this.removeAllListeners(e+"-canceled")},this.readCryptoHDKeyOrCryptoAccount=()=>new Promise((e,t)=>{this.memStore.updateState({sync:{reading:!0}}),this.on("keystone-sync_success-hdkey",t=>{const s=i.CryptoHDKey.fromCBOR(Buffer.from(t,"hex"));this.resetState(),e(s)}),this.on("keystone-sync_success-account",t=>{const s=i.CryptoAccount.fromCBOR(Buffer.from(t,"hex"));this.resetState(),e(s)}),this.on("keystone-sync_cancel",()=>{this.resetState(),t(new Error("KeystoneError#sync_cancel. Sync process canceled, please retry"))})}),this.submitCryptoHDKey=e=>{this.emit("keystone-sync_success-hdkey",e)},this.submitCryptoAccount=e=>{this.emit("keystone-sync_success-account",e)},this.cancelSync=()=>{this.emit("keystone-sync_cancel")},this.requestSignature=(e,t,s)=>new Promise((n,c)=>{const o=e.toUR(),a=e.getRequestId(),h=r.stringify(a),u={requestId:h,payload:{type:o.type,cbor:o.cbor.toString("hex")},title:t,description:s};this.memStore.updateState({sign:{request:u}}),this.once(h+"-signed",e=>{const t=i.ETHSignature.fromCBOR(Buffer.from(e,"hex"));this.resetState(),n(t)}),this.once(h+"-canceled",()=>{this.resetState(),c(new Error("KeystoneError#Tx_canceled. Signing canceled, please retry"))})}),this.submitSignature=(e,t)=>{this.emit(e+"-signed",t)},this.cancelRequestSignature=()=>{const e=this.memStore.getState().sign.request;if(e){const{requestId:t}=e;this.memStore.updateState({sign:{}}),this.emit(t+"-canceled")}},this.reset=()=>{this.cleanSyncListeners();const e=this.memStore.getState().sign.request;if(e){const{requestId:t}=e;this.cleanSignListeners(t)}this.resetState()},this.resetState=()=>{this.memStore.updateState({sync:{reading:!1},sign:{}})},a.instance)return a.instance;this.memStore=new n.ObservableStore({sync:{reading:!1},sign:{},_version:1}),a.instance=this}}class h extends t.BaseKeyring{constructor(e){if(super(e),this.getInteraction=()=>new a,this.resetStore=()=>{this.getInteraction().reset()},this.getMemStore=()=>this.getInteraction().memStore,this.removeAccount=e=>{if(!this.accounts.map(e=>e.toLowerCase()).includes(e.toLowerCase()))throw new Error(`Address ${e} not found in this keyring`);this.accounts=this.accounts.filter(t=>t.toLowerCase()!==e.toLowerCase())},this.forgetDevice=()=>{this.page=0,this.perPage=5,this.accounts=[],this.currentAccount=0,this.name="QR Hardware",this.initialized=!1,this.xfp="",this.xpub="",this.hdPath="",this.indexes={},this.hdk=void 0,this.paths={}},this.submitCryptoHDKey=this.getInteraction().submitCryptoHDKey,this.submitCryptoAccount=this.getInteraction().submitCryptoAccount,this.submitSignature=this.getInteraction().submitSignature,this.cancelSync=this.getInteraction().cancelSync,this.cancelSignRequest=this.getInteraction().cancelRequestSignature,h.instance)return h.instance.deserialize(e),h.instance;h.instance=this}async signTransaction(e,t){const s=0===t.type?i.DataType.transaction:i.DataType.typedTransaction;let n;n=0===t.type?o.encode(t.getMessageToSign(!1)):t.getMessageToSign(!1);const a=await this._pathFromAddress(e),h=t.common.chainId(),u=r.v4(),y=i.EthSignRequest.constructETHRequest(n,s,a,this.xfp,u,h,e),{r:m,s:g,v:d}=await this.requestSignature(u,y,"Scan with your Keystone",'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature'),S=t.toJSON();return S.v=d,S.s=g,S.r=m,S.type=t.type,c.TransactionFactory.fromTxData(S,{common:t.common})}}h.type=t.BaseKeyring.type,exports.MetaMaskKeyring=h;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.production.min.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.development.js", {"@ethereumjs/util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ethereumjs\\util\\dist\\index.js","@keystonehq/bc-ur-registry":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js","hdkey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\hdkey\\lib\\hdkey.js","uuid":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry-eth%5Cdist%5Cbc-ur-registry-eth.cjs.development.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var bcUrRegistry = require('@keystonehq/bc-ur-registry');
var uuid = require('uuid');
var HDKey = _interopDefault(require('hdkey'));
var util = require('@ethereumjs/util');

const ExtendedRegistryTypes = {
  ETH_SIGN_REQUEST: /*#__PURE__*/new bcUrRegistry.RegistryType("eth-sign-request", 401),
  ETH_SIGNATURE: /*#__PURE__*/new bcUrRegistry.RegistryType("eth-signature", 402),
  ETH_NFT_ITEM: /*#__PURE__*/new bcUrRegistry.RegistryType("eth-nft-item", 403)
};

const {
  decodeToDataItem,
  RegistryTypes
} = bcUrRegistry.extend;
var Keys;

(function (Keys) {
  Keys[Keys["requestId"] = 1] = "requestId";
  Keys[Keys["signData"] = 2] = "signData";
  Keys[Keys["dataType"] = 3] = "dataType";
  Keys[Keys["chainId"] = 4] = "chainId";
  Keys[Keys["derivationPath"] = 5] = "derivationPath";
  Keys[Keys["address"] = 6] = "address";
  Keys[Keys["origin"] = 7] = "origin";
})(Keys || (Keys = {}));

(function (DataType) {
  DataType[DataType["transaction"] = 1] = "transaction";
  DataType[DataType["typedData"] = 2] = "typedData";
  DataType[DataType["personalMessage"] = 3] = "personalMessage";
  DataType[DataType["typedTransaction"] = 4] = "typedTransaction";
})(exports.DataType || (exports.DataType = {}));

class EthSignRequest extends bcUrRegistry.RegistryItem {
  constructor(args) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_SIGN_REQUEST;

    this.getRequestId = () => this.requestId;

    this.getSignData = () => this.signData;

    this.getDataType = () => this.dataType;

    this.getChainId = () => this.chainId;

    this.getDerivationPath = () => this.derivationPath.getPath();

    this.getSourceFingerprint = () => this.derivationPath.getSourceFingerprint();

    this.getSignRequestAddress = () => this.address;

    this.getOrigin = () => this.origin;

    this.toDataItem = () => {
      const map = {};

      if (this.requestId) {
        map[Keys.requestId] = new bcUrRegistry.DataItem(this.requestId, RegistryTypes.UUID.getTag());
      }

      if (this.address) {
        map[Keys.address] = this.address;
      }

      if (this.chainId) {
        map[Keys.chainId] = this.chainId;
      }

      if (this.origin) {
        map[Keys.origin] = this.origin;
      }

      map[Keys.signData] = this.signData;
      map[Keys.dataType] = this.dataType;
      const keyPath = this.derivationPath.toDataItem();
      keyPath.setTag(this.derivationPath.getRegistryType().getTag());
      map[Keys.derivationPath] = keyPath;
      return new bcUrRegistry.DataItem(map);
    };

    this.requestId = args.requestId;
    this.signData = args.signData;
    this.dataType = args.dataType;
    this.chainId = args.chainId;
    this.derivationPath = args.derivationPath;
    this.address = args.address;
    this.origin = args.origin;
  }

  static constructETHRequest(signData, signDataType, hdPath, xfp, uuidString, chainId, address, origin) {
    const paths = hdPath.replace(/[m|M]\//, "").split("/");
    const hdpathObject = new bcUrRegistry.CryptoKeypath(paths.map(path => {
      const index = parseInt(path.replace("'", ""));
      let isHardened = false;

      if (path.endsWith("'")) {
        isHardened = true;
      }

      return new bcUrRegistry.PathComponent({
        index,
        hardened: isHardened
      });
    }), Buffer.from(xfp, "hex"));
    return new EthSignRequest({
      requestId: uuidString ? Buffer.from(uuid.parse(uuidString)) : undefined,
      signData,
      dataType: signDataType,
      derivationPath: hdpathObject,
      chainId,
      address: address ? Buffer.from(address.replace("0x", ""), "hex") : undefined,
      origin: origin || undefined
    });
  }

}

EthSignRequest.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const signData = map[Keys.signData];
  const dataType = map[Keys.dataType];
  const derivationPath = bcUrRegistry.CryptoKeypath.fromDataItem(map[Keys.derivationPath]);
  const chainId = map[Keys.chainId] ? map[Keys.chainId] : undefined;
  const address = map[Keys.address] ? map[Keys.address] : undefined;
  const requestId = map[Keys.requestId] ? map[Keys.requestId].getData() : undefined;
  const origin = map[Keys.origin] ? map[Keys.origin] : undefined;
  return new EthSignRequest({
    requestId,
    signData,
    dataType,
    chainId,
    derivationPath,
    address,
    origin
  });
};

EthSignRequest.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem(_cborPayload);
  return EthSignRequest.fromDataItem(dataItem);
};

const {
  RegistryTypes: RegistryTypes$1,
  decodeToDataItem: decodeToDataItem$1
} = bcUrRegistry.extend;
var Keys$1;

(function (Keys) {
  Keys[Keys["requestId"] = 1] = "requestId";
  Keys[Keys["signature"] = 2] = "signature";
  Keys[Keys["origin"] = 3] = "origin";
})(Keys$1 || (Keys$1 = {}));

class ETHSignature extends bcUrRegistry.RegistryItem {
  constructor(signature, requestId, origin) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_SIGNATURE;

    this.getRequestId = () => this.requestId;

    this.getSignature = () => this.signature;

    this.getOrigin = () => this.origin;

    this.toDataItem = () => {
      const map = {};

      if (this.requestId) {
        map[Keys$1.requestId] = new bcUrRegistry.DataItem(this.requestId, RegistryTypes$1.UUID.getTag());
      }

      if (this.origin) map[Keys$1.origin] = this.origin;
      map[Keys$1.signature] = this.signature;
      return new bcUrRegistry.DataItem(map);
    };

    this.signature = signature;
    this.requestId = requestId;
    this.origin = origin;
  }

}

ETHSignature.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const signature = map[Keys$1.signature];
  const requestId = map[Keys$1.requestId] ? map[Keys$1.requestId].getData() : undefined;
  return new ETHSignature(signature, requestId, map[Keys$1.origin]);
};

ETHSignature.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem$1(_cborPayload);
  return ETHSignature.fromDataItem(dataItem);
};

const {
  decodeToDataItem: decodeToDataItem$2
} = bcUrRegistry.extend;
var Keys$2;

(function (Keys) {
  Keys[Keys["chainId"] = 1] = "chainId";
  Keys[Keys["contractAddress"] = 2] = "contractAddress";
  Keys[Keys["contractName"] = 3] = "contractName";
  Keys[Keys["name"] = 4] = "name";
  Keys[Keys["mediaData"] = 5] = "mediaData";
})(Keys$2 || (Keys$2 = {}));

class ETHNFTItem extends bcUrRegistry.RegistryItem {
  constructor(args) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_NFT_ITEM;

    this.getChainId = () => this.chainId;

    this.getName = () => this.name;

    this.getmediaData = () => this.mediaData;

    this.getContractAddress = () => this.contractAddress;

    this.getContractName = () => this.contractName;

    this.toDataItem = () => {
      const map = {};
      map[Keys$2.chainId] = this.chainId;
      map[Keys$2.name] = this.name;
      map[Keys$2.contractAddress] = this.contractAddress;
      map[Keys$2.contractName] = this.contractName;
      map[Keys$2.mediaData] = this.mediaData;
      return new bcUrRegistry.DataItem(map);
    };

    this.chainId = args.chainId;
    this.name = args.name;
    this.contractAddress = args.contractAddress;
    this.contractName = args.contractName;
    this.mediaData = args.mediaData; // remove the data perfix for android usage
  }

  static constructETHNFTItem(chainId, contractAddress, contractName, name, mediaData) {
    return new ETHNFTItem({
      chainId,
      contractAddress,
      contractName,
      mediaData,
      name
    });
  }

}

ETHNFTItem.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const chainId = map[Keys$2.chainId];
  const name = map[Keys$2.name];
  const mediaData = map[Keys$2.mediaData];
  const contractAddress = map[Keys$2.contractAddress];
  const contractName = map[Keys$2.contractName];
  return new ETHNFTItem({
    chainId,
    name,
    contractAddress,
    contractName,
    mediaData
  });
};

ETHNFTItem.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem$2(_cborPayload);
  return ETHNFTItem.fromDataItem(dataItem);
};

// @ts-ignore
const generateAddressFromXpub = (xpub, derivePath) => {
  // @ts-ignore
  const node = HDKey.fromExtendedKey(xpub);
  const publicKey = node.derive(derivePath);
  const address = "0x" + util.publicToAddress(publicKey.publicKey, true).toString("hex");
  return util.toChecksumAddress(address);
};
const findHDPathFromAddress = (address, xpub, numberLimit, rootPath) => {
  for (let i = 0; i < numberLimit; i++) {
    const path = `M/0/${i}`;

    const _address = generateAddressFromXpub(xpub, path);

    if (address.toLowerCase() == _address.toLowerCase()) {
      return `${rootPath}/0/${i}`;
    }
  }

  return null;
};

bcUrRegistry.patchTags(Object.values(ExtendedRegistryTypes).filter(rt => !!rt.getTag()).map(rt => rt.getTag()));

Object.keys(bcUrRegistry).forEach(function (k) {
  if (k !== 'default') Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return bcUrRegistry[k];
    }
  });
});
exports.ETHNFTItem = ETHNFTItem;
exports.ETHSignature = ETHSignature;
exports.EthSignRequest = EthSignRequest;
exports.findHDPathFromAddress = findHDPathFromAddress;
exports.generateAddressFromXpub = generateAddressFromXpub;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.development.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.production.min.js", {"@ethereumjs/util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ethereumjs\\util\\dist\\index.js","@keystonehq/bc-ur-registry":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js","hdkey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\hdkey\\lib\\hdkey.js","uuid":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry-eth%5Cdist%5Cbc-ur-registry-eth.cjs.production.min.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t,e=require("@keystonehq/bc-ur-registry"),a=require("uuid"),s=(t=require("hdkey"))&&"object"==typeof t&&"default"in t?t.default:t,i=require("@ethereumjs/util");const r={ETH_SIGN_REQUEST:new e.RegistryType("eth-sign-request",401),ETH_SIGNATURE:new e.RegistryType("eth-signature",402),ETH_NFT_ITEM:new e.RegistryType("eth-nft-item",403)},{decodeToDataItem:n,RegistryTypes:d}=e.extend;var o,h;!function(t){t[t.requestId=1]="requestId",t[t.signData=2]="signData",t[t.dataType=3]="dataType",t[t.chainId=4]="chainId",t[t.derivationPath=5]="derivationPath",t[t.address=6]="address",t[t.origin=7]="origin"}(o||(o={})),(h=exports.DataType||(exports.DataType={}))[h.transaction=1]="transaction",h[h.typedData=2]="typedData",h[h.personalMessage=3]="personalMessage",h[h.typedTransaction=4]="typedTransaction";class c extends e.RegistryItem{constructor(t){super(),this.getRegistryType=()=>r.ETH_SIGN_REQUEST,this.getRequestId=()=>this.requestId,this.getSignData=()=>this.signData,this.getDataType=()=>this.dataType,this.getChainId=()=>this.chainId,this.getDerivationPath=()=>this.derivationPath.getPath(),this.getSourceFingerprint=()=>this.derivationPath.getSourceFingerprint(),this.getSignRequestAddress=()=>this.address,this.getOrigin=()=>this.origin,this.toDataItem=()=>{const t={};this.requestId&&(t[o.requestId]=new e.DataItem(this.requestId,d.UUID.getTag())),this.address&&(t[o.address]=this.address),this.chainId&&(t[o.chainId]=this.chainId),this.origin&&(t[o.origin]=this.origin),t[o.signData]=this.signData,t[o.dataType]=this.dataType;const a=this.derivationPath.toDataItem();return a.setTag(this.derivationPath.getRegistryType().getTag()),t[o.derivationPath]=a,new e.DataItem(t)},this.requestId=t.requestId,this.signData=t.signData,this.dataType=t.dataType,this.chainId=t.chainId,this.derivationPath=t.derivationPath,this.address=t.address,this.origin=t.origin}static constructETHRequest(t,s,i,r,n,d,o,h){const g=i.replace(/[m|M]\//,"").split("/"),u=new e.CryptoKeypath(g.map(t=>{const a=parseInt(t.replace("'",""));let s=!1;return t.endsWith("'")&&(s=!0),new e.PathComponent({index:a,hardened:s})}),Buffer.from(r,"hex"));return new c({requestId:n?Buffer.from(a.parse(n)):void 0,signData:t,dataType:s,derivationPath:u,chainId:d,address:o?Buffer.from(o.replace("0x",""),"hex"):void 0,origin:h||void 0})}}c.fromDataItem=t=>{const a=t.getData(),s=a[o.signData],i=a[o.dataType],r=e.CryptoKeypath.fromDataItem(a[o.derivationPath]),n=a[o.chainId]?a[o.chainId]:void 0,d=a[o.address]?a[o.address]:void 0,h=a[o.requestId]?a[o.requestId].getData():void 0;return new c({requestId:h,signData:s,dataType:i,chainId:n,derivationPath:r,address:d,origin:a[o.origin]?a[o.origin]:void 0})},c.fromCBOR=t=>{const e=n(t);return c.fromDataItem(e)};const{RegistryTypes:g,decodeToDataItem:u}=e.extend;var m;!function(t){t[t.requestId=1]="requestId",t[t.signature=2]="signature",t[t.origin=3]="origin"}(m||(m={}));class I extends e.RegistryItem{constructor(t,a,s){super(),this.getRegistryType=()=>r.ETH_SIGNATURE,this.getRequestId=()=>this.requestId,this.getSignature=()=>this.signature,this.getOrigin=()=>this.origin,this.toDataItem=()=>{const t={};return this.requestId&&(t[m.requestId]=new e.DataItem(this.requestId,g.UUID.getTag())),this.origin&&(t[m.origin]=this.origin),t[m.signature]=this.signature,new e.DataItem(t)},this.signature=t,this.requestId=a,this.origin=s}}I.fromDataItem=t=>{const e=t.getData(),a=e[m.signature],s=e[m.requestId]?e[m.requestId].getData():void 0;return new I(a,s,e[m.origin])},I.fromCBOR=t=>{const e=u(t);return I.fromDataItem(e)};const{decodeToDataItem:p}=e.extend;var D;!function(t){t[t.chainId=1]="chainId",t[t.contractAddress=2]="contractAddress",t[t.contractName=3]="contractName",t[t.name=4]="name",t[t.mediaData=5]="mediaData"}(D||(D={}));class T extends e.RegistryItem{constructor(t){super(),this.getRegistryType=()=>r.ETH_NFT_ITEM,this.getChainId=()=>this.chainId,this.getName=()=>this.name,this.getmediaData=()=>this.mediaData,this.getContractAddress=()=>this.contractAddress,this.getContractName=()=>this.contractName,this.toDataItem=()=>{const t={};return t[D.chainId]=this.chainId,t[D.name]=this.name,t[D.contractAddress]=this.contractAddress,t[D.contractName]=this.contractName,t[D.mediaData]=this.mediaData,new e.DataItem(t)},this.chainId=t.chainId,this.name=t.name,this.contractAddress=t.contractAddress,this.contractName=t.contractName,this.mediaData=t.mediaData}static constructETHNFTItem(t,e,a,s,i){return new T({chainId:t,contractAddress:e,contractName:a,mediaData:i,name:s})}}T.fromDataItem=t=>{const e=t.getData();return new T({chainId:e[D.chainId],name:e[D.name],contractAddress:e[D.contractAddress],contractName:e[D.contractName],mediaData:e[D.mediaData]})},T.fromCBOR=t=>{const e=p(t);return T.fromDataItem(e)};const y=(t,e)=>{const a=s.fromExtendedKey(t).derive(e),r="0x"+i.publicToAddress(a.publicKey,!0).toString("hex");return i.toChecksumAddress(r)};e.patchTags(Object.values(r).filter(t=>!!t.getTag()).map(t=>t.getTag())),Object.keys(e).forEach((function(t){"default"!==t&&Object.defineProperty(exports,t,{enumerable:!0,get:function(){return e[t]}})})),exports.ETHNFTItem=T,exports.ETHSignature=I,exports.EthSignRequest=c,exports.findHDPathFromAddress=(t,e,a,s)=>{for(let i=0;i<a;i++){const a=y(e,"M/0/"+i);if(t.toLowerCase()==a.toLowerCase())return`${s}/0/${i}`}return null},exports.generateAddressFromXpub=y;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.production.min.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js", {"./bc-ur-registry-eth.cjs.development.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.development.js","./bc-ur-registry-eth.cjs.production.min.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.production.min.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry-eth%5Cdist%5Cindex.js
      return function (require, module, exports) {

'use strict'

if ("development" === 'production') {
  module.exports = require('./bc-ur-registry-eth.cjs.production.min.js')
} else {
  module.exports = require('./bc-ur-registry-eth.cjs.development.js')
}

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Bytes.js", {"./RegistryItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CBytes.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bytes = void 0;
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
class Bytes extends RegistryItem_1.RegistryItem {
    constructor(bytes) {
        super();
        this.bytes = bytes;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.BYTES;
        };
        this.getData = () => this.bytes;
        this.toDataItem = () => {
            return new lib_1.DataItem(this.bytes);
        };
    }
}
exports.Bytes = Bytes;
Bytes.fromDataItem = (dataItem) => {
    const bytes = dataItem.getData();
    if (!bytes) {
        throw new Error(`#[ur-registry][Bytes][fn.fromDataItem]: decoded [dataItem][#data] is undefined: ${dataItem}`);
    }
    return new Bytes(bytes);
};
Bytes.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return Bytes.fromDataItem(dataItem);
};
//# sourceMappingURL=Bytes.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Bytes.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoAccount.js", {".":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js","./RegistryItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoAccount.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoAccount = void 0;
const _1 = require(".");
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys[Keys["masterFingerprint"] = 1] = "masterFingerprint";
    Keys[Keys["outputDescriptors"] = 2] = "outputDescriptors";
})(Keys || (Keys = {}));
class CryptoAccount extends RegistryItem_1.RegistryItem {
    constructor(masterFingerprint, outputDescriptors) {
        super();
        this.masterFingerprint = masterFingerprint;
        this.outputDescriptors = outputDescriptors;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_ACCOUNT;
        };
        this.getMasterFingerprint = () => this.masterFingerprint;
        this.getOutputDescriptors = () => this.outputDescriptors;
        this.toDataItem = () => {
            const map = {};
            if (this.masterFingerprint) {
                map[Keys.masterFingerprint] = this.masterFingerprint.readUInt32BE(0);
            }
            if (this.outputDescriptors) {
                map[Keys.outputDescriptors] = this.outputDescriptors.map((item) => item.toDataItem());
            }
            return new lib_1.DataItem(map);
        };
    }
}
exports.CryptoAccount = CryptoAccount;
CryptoAccount.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const masterFingerprint = Buffer.alloc(4);
    const _masterFingerprint = map[Keys.masterFingerprint];
    if (_masterFingerprint) {
        masterFingerprint.writeUInt32BE(_masterFingerprint, 0);
    }
    const outputDescriptors = map[Keys.outputDescriptors];
    const cryptoOutputs = outputDescriptors.map((item) => _1.CryptoOutput.fromDataItem(item));
    return new CryptoAccount(masterFingerprint, cryptoOutputs);
};
CryptoAccount.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoAccount.fromDataItem(dataItem);
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoAccount.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoCoinInfo.js", {"./RegistryItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoCoinInfo.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoCoinInfo = exports.Network = exports.Type = void 0;
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys["type"] = "1";
    Keys["network"] = "2";
})(Keys || (Keys = {}));
var Type;
(function (Type) {
    Type[Type["bitcoin"] = 0] = "bitcoin";
})(Type = exports.Type || (exports.Type = {}));
var Network;
(function (Network) {
    Network[Network["mainnet"] = 0] = "mainnet";
    Network[Network["testnet"] = 1] = "testnet";
})(Network = exports.Network || (exports.Network = {}));
class CryptoCoinInfo extends RegistryItem_1.RegistryItem {
    constructor(type, network) {
        super();
        this.type = type;
        this.network = network;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_COIN_INFO;
        };
        this.getType = () => {
            return this.type || Type.bitcoin;
        };
        this.getNetwork = () => {
            return this.network || Network.mainnet;
        };
        this.toDataItem = () => {
            const map = {};
            if (this.type) {
                map[Keys.type] = this.type;
            }
            if (this.network) {
                map[Keys.network] = this.network;
            }
            return new lib_1.DataItem(map);
        };
    }
}
exports.CryptoCoinInfo = CryptoCoinInfo;
CryptoCoinInfo.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const type = map[Keys.type];
    const network = map[Keys.network];
    return new CryptoCoinInfo(type, network);
};
CryptoCoinInfo.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoCoinInfo.fromDataItem(dataItem);
};
//# sourceMappingURL=CryptoCoinInfo.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoCoinInfo.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoECKey.js", {"./RegistryItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoECKey.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoECKey = void 0;
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys[Keys["curve"] = 1] = "curve";
    Keys[Keys["private"] = 2] = "private";
    Keys[Keys["data"] = 3] = "data";
})(Keys || (Keys = {}));
class CryptoECKey extends RegistryItem_1.RegistryItem {
    constructor(args) {
        super();
        this.isECKey = () => {
            return true;
        };
        this.getCurve = () => this.curve || 0;
        this.isPrivateKey = () => this.privateKey || false;
        this.getData = () => this.data;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_ECKEY;
        };
        this.toDataItem = () => {
            const map = {};
            if (this.curve) {
                map[Keys.curve] = this.curve;
            }
            if (this.privateKey !== undefined) {
                map[Keys.private] = this.privateKey;
            }
            map[Keys.data] = this.data;
            return new lib_1.DataItem(map);
        };
        this.getOutputDescriptorContent = () => {
            return this.data.toString('hex');
        };
        this.data = args.data;
        this.curve = args.curve;
        this.privateKey = args.privateKey || undefined;
    }
}
exports.CryptoECKey = CryptoECKey;
CryptoECKey.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const curve = map[Keys.curve];
    const privateKey = map[Keys.private];
    const data = map[Keys.data];
    if (!data) {
        throw new Error(`#[ur-registry][CryptoECKey][fn.fromDataItem]: decoded [dataItem][#data.data] is undefined: ${dataItem}`);
    }
    return new CryptoECKey({ data, curve, privateKey });
};
CryptoECKey.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoECKey.fromDataItem(dataItem);
};
//# sourceMappingURL=CryptoECKey.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoECKey.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js", {"./CryptoCoinInfo":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoCoinInfo.js","./CryptoKeypath":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoKeypath.js","./RegistryItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","bs58check":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\bs58check\\index.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoHDKey.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoHDKey = void 0;
const bs58check_1 = require("bs58check");
const CryptoCoinInfo_1 = require("./CryptoCoinInfo");
const CryptoKeypath_1 = require("./CryptoKeypath");
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys[Keys["is_master"] = 1] = "is_master";
    Keys[Keys["is_private"] = 2] = "is_private";
    Keys[Keys["key_data"] = 3] = "key_data";
    Keys[Keys["chain_code"] = 4] = "chain_code";
    Keys[Keys["use_info"] = 5] = "use_info";
    Keys[Keys["origin"] = 6] = "origin";
    Keys[Keys["children"] = 7] = "children";
    Keys[Keys["parent_fingerprint"] = 8] = "parent_fingerprint";
    Keys[Keys["name"] = 9] = "name";
    Keys[Keys["note"] = 10] = "note";
})(Keys || (Keys = {}));
class CryptoHDKey extends RegistryItem_1.RegistryItem {
    constructor(args) {
        super();
        this.isECKey = () => {
            return false;
        };
        this.getKey = () => this.key;
        this.getChainCode = () => this.chainCode;
        this.isMaster = () => this.master;
        this.isPrivateKey = () => !!this.privateKey;
        this.getUseInfo = () => this.useInfo;
        this.getOrigin = () => this.origin;
        this.getChildren = () => this.children;
        this.getParentFingerprint = () => this.parentFingerprint;
        this.getName = () => this.name;
        this.getNote = () => this.note;
        this.getBip32Key = () => {
            var _a, _b, _c;
            let version;
            let depth;
            let index = 0;
            let parentFingerprint = Buffer.alloc(4).fill(0);
            if (this.isMaster()) {
                version = Buffer.from('0488ADE4', 'hex');
                depth = 0;
                index = 0;
            }
            else {
                depth = ((_a = this.getOrigin()) === null || _a === void 0 ? void 0 : _a.getComponents().length) || ((_b = this.getOrigin()) === null || _b === void 0 ? void 0 : _b.getDepth());
                const paths = (_c = this.getOrigin()) === null || _c === void 0 ? void 0 : _c.getComponents();
                const lastPath = paths[paths.length - 1];
                if (lastPath) {
                    index = lastPath.isHardened() ? lastPath.getIndex() + 0x80000000 : lastPath.getIndex();
                    if (this.getParentFingerprint()) {
                        parentFingerprint = this.getParentFingerprint();
                    }
                }
                if (this.isPrivateKey()) {
                    version = Buffer.from('0488ADE4', 'hex');
                }
                else {
                    version = Buffer.from('0488B21E', 'hex');
                }
            }
            const depthBuffer = Buffer.alloc(1);
            depthBuffer.writeUInt8(depth, 0);
            const indexBuffer = Buffer.alloc(4);
            indexBuffer.writeUInt32BE(index, 0);
            const chainCode = this.getChainCode();
            const key = this.getKey();
            return (0, bs58check_1.encode)(Buffer.concat([version, depthBuffer, parentFingerprint, indexBuffer, chainCode, key]));
        };
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_HDKEY;
        };
        this.getOutputDescriptorContent = () => {
            var _a, _b, _c, _d, _e, _f, _g;
            let result = '';
            if (this.getOrigin()) {
                if (((_a = this.getOrigin()) === null || _a === void 0 ? void 0 : _a.getSourceFingerprint()) && ((_b = this.getOrigin()) === null || _b === void 0 ? void 0 : _b.getPath())) {
                    result += `${(_d = (_c = this.getOrigin()) === null || _c === void 0 ? void 0 : _c.getSourceFingerprint()) === null || _d === void 0 ? void 0 : _d.toString('hex')}/${(_e = this.getOrigin()) === null || _e === void 0 ? void 0 : _e.getPath()}`;
                }
            }
            result += this.getBip32Key();
            if (this.getChildren()) {
                if ((_f = this.getChildren()) === null || _f === void 0 ? void 0 : _f.getPath()) {
                    result += `/${(_g = this.getChildren()) === null || _g === void 0 ? void 0 : _g.getPath()}`;
                }
            }
            return result;
        };
        this.setupMasterKey = (args) => {
            this.master = true;
            this.key = args.key;
            this.chainCode = args.chainCode;
        };
        this.setupDeriveKey = (args) => {
            this.master = false;
            this.privateKey = args.isPrivateKey;
            this.key = args.key;
            this.chainCode = args.chainCode;
            this.useInfo = args.useInfo;
            this.origin = args.origin;
            this.children = args.children;
            this.parentFingerprint = args.parentFingerprint;
            this.name = args.name;
            this.note = args.note;
        };
        this.toDataItem = () => {
            const map = {};
            if (this.master) {
                map[Keys.is_master] = true;
                map[Keys.key_data] = this.key;
                map[Keys.chain_code] = this.chainCode;
            }
            else {
                if (this.privateKey !== undefined) {
                    map[Keys.is_private] = this.privateKey;
                }
                map[Keys.key_data] = this.key;
                if (this.chainCode) {
                    map[Keys.chain_code] = this.chainCode;
                }
                if (this.useInfo) {
                    const useInfo = this.useInfo.toDataItem();
                    useInfo.setTag(this.useInfo.getRegistryType().getTag());
                    map[Keys.use_info] = useInfo;
                }
                if (this.origin) {
                    const origin = this.origin.toDataItem();
                    origin.setTag(this.origin.getRegistryType().getTag());
                    map[Keys.origin] = origin;
                }
                if (this.children) {
                    const children = this.children.toDataItem();
                    children.setTag(this.children.getRegistryType().getTag());
                    map[Keys.children] = children;
                }
                if (this.parentFingerprint) {
                    map[Keys.parent_fingerprint] = this.parentFingerprint.readUInt32BE(0);
                }
                if (this.name !== undefined) {
                    map[Keys.name] = this.name;
                }
                if (this.note !== undefined) {
                    map[Keys.note] = this.note;
                }
            }
            return new lib_1.DataItem(map);
        };
        if (args.isMaster) {
            this.setupMasterKey(args);
        }
        else {
            this.setupDeriveKey(args);
        }
    }
}
exports.CryptoHDKey = CryptoHDKey;
CryptoHDKey.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const isMaster = !!map[Keys.is_master];
    const isPrivateKey = map[Keys.is_private];
    const key = map[Keys.key_data];
    const chainCode = map[Keys.chain_code];
    const useInfo = map[Keys.use_info]
        ? CryptoCoinInfo_1.CryptoCoinInfo.fromDataItem(map[Keys.use_info])
        : undefined;
    const origin = map[Keys.origin]
        ? CryptoKeypath_1.CryptoKeypath.fromDataItem(map[Keys.origin])
        : undefined;
    const children = map[Keys.children]
        ? CryptoKeypath_1.CryptoKeypath.fromDataItem(map[Keys.children])
        : undefined;
    const _parentFingerprint = map[Keys.parent_fingerprint];
    let parentFingerprint = undefined;
    if (_parentFingerprint) {
        parentFingerprint = Buffer.alloc(4);
        parentFingerprint.writeUInt32BE(_parentFingerprint, 0);
    }
    const name = map[Keys.name];
    const note = map[Keys.note];
    return new CryptoHDKey({
        isMaster,
        isPrivateKey,
        key,
        chainCode,
        useInfo,
        origin,
        children,
        parentFingerprint,
        name,
        note,
    });
};
CryptoHDKey.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoHDKey.fromDataItem(dataItem);
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoKeypath.js", {"./PathComponent":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\PathComponent.js","./RegistryItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoKeypath.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoKeypath = void 0;
const lib_1 = require("./lib");
const PathComponent_1 = require("./PathComponent");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys[Keys["components"] = 1] = "components";
    Keys[Keys["source_fingerprint"] = 2] = "source_fingerprint";
    Keys[Keys["depth"] = 3] = "depth";
})(Keys || (Keys = {}));
class CryptoKeypath extends RegistryItem_1.RegistryItem {
    constructor(components = [], sourceFingerprint, depth) {
        super();
        this.components = components;
        this.sourceFingerprint = sourceFingerprint;
        this.depth = depth;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_KEYPATH;
        };
        this.getPath = () => {
            if (this.components.length === 0) {
                return undefined;
            }
            const components = this.components.map((component) => {
                return `${component.isWildcard() ? '*' : component.getIndex()}${component.isHardened() ? "'" : ''}`;
            });
            return components.join('/');
        };
        this.getComponents = () => this.components;
        this.getSourceFingerprint = () => this.sourceFingerprint;
        this.getDepth = () => this.depth;
        this.toDataItem = () => {
            const map = {};
            const components = [];
            this.components &&
                this.components.forEach((component) => {
                    if (component.isWildcard()) {
                        components.push([]);
                    }
                    else {
                        components.push(component.getIndex());
                    }
                    components.push(component.isHardened());
                });
            map[Keys.components] = components;
            if (this.sourceFingerprint) {
                map[Keys.source_fingerprint] = this.sourceFingerprint.readUInt32BE(0);
            }
            if (this.depth !== undefined) {
                map[Keys.depth] = this.depth;
            }
            return new lib_1.DataItem(map);
        };
    }
}
exports.CryptoKeypath = CryptoKeypath;
CryptoKeypath.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const pathComponents = [];
    const components = map[Keys.components];
    if (components) {
        for (let i = 0; i < components.length; i += 2) {
            const isHardened = components[i + 1];
            const path = components[i];
            if (typeof path === 'number') {
                pathComponents.push(new PathComponent_1.PathComponent({ index: path, hardened: isHardened }));
            }
            else {
                pathComponents.push(new PathComponent_1.PathComponent({ hardened: isHardened }));
            }
        }
    }
    const _sourceFingerprint = map[Keys.source_fingerprint];
    let sourceFingerprint;
    if (_sourceFingerprint) {
        sourceFingerprint = Buffer.alloc(4);
        sourceFingerprint.writeUInt32BE(_sourceFingerprint, 0);
    }
    const depth = map[Keys.depth];
    return new CryptoKeypath(pathComponents, sourceFingerprint, depth);
};
CryptoKeypath.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoKeypath.fromDataItem(dataItem);
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoKeypath.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoOutput.js", {"./CryptoECKey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoECKey.js","./CryptoHDKey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js","./MultiKey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\MultiKey.js","./RegistryItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./ScriptExpression":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\ScriptExpression.js","./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoOutput.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoOutput = void 0;
const CryptoECKey_1 = require("./CryptoECKey");
const CryptoHDKey_1 = require("./CryptoHDKey");
const lib_1 = require("./lib");
const MultiKey_1 = require("./MultiKey");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
const ScriptExpression_1 = require("./ScriptExpression");
class CryptoOutput extends RegistryItem_1.RegistryItem {
    constructor(scriptExpressions, cryptoKey) {
        super();
        this.scriptExpressions = scriptExpressions;
        this.cryptoKey = cryptoKey;
        this.getRegistryType = () => {
            return RegistryType_1.RegistryTypes.CRYPTO_OUTPUT;
        };
        this.getCryptoKey = () => this.cryptoKey;
        this.getHDKey = () => {
            if (this.cryptoKey instanceof CryptoHDKey_1.CryptoHDKey) {
                return this.cryptoKey;
            }
            else {
                return undefined;
            }
        };
        this.getECKey = () => {
            if (this.cryptoKey instanceof CryptoECKey_1.CryptoECKey) {
                return this.cryptoKey;
            }
            else {
                return undefined;
            }
        };
        this.getMultiKey = () => {
            if (this.cryptoKey instanceof MultiKey_1.MultiKey) {
                return this.cryptoKey;
            }
            else {
                return undefined;
            }
        };
        this.getScriptExpressions = () => this.scriptExpressions;
        this._toOutputDescriptor = (seIndex) => {
            if (seIndex >= this.scriptExpressions.length) {
                return this.cryptoKey.getOutputDescriptorContent();
            }
            else {
                return `${this.scriptExpressions[seIndex].getExpression()}(${this._toOutputDescriptor(seIndex + 1)})`;
            }
        };
        this.toString = () => {
            return this._toOutputDescriptor(0);
        };
        this.toDataItem = () => {
            let dataItem = this.cryptoKey.toDataItem();
            if (this.cryptoKey instanceof CryptoECKey_1.CryptoECKey ||
                this.cryptoKey instanceof CryptoHDKey_1.CryptoHDKey) {
                dataItem.setTag(this.cryptoKey.getRegistryType().getTag());
            }
            const clonedSe = [...this.scriptExpressions];
            clonedSe.reverse().forEach((se) => {
                const tagValue = se.getTag();
                if (dataItem.getTag() === undefined) {
                    dataItem.setTag(tagValue);
                }
                else {
                    dataItem = new lib_1.DataItem(dataItem, tagValue);
                }
            });
            return dataItem;
        };
    }
}
exports.CryptoOutput = CryptoOutput;
CryptoOutput.fromDataItem = (dataItem) => {
    const scriptExpressions = [];
    let _dataItem = dataItem;
    while (true) {
        let _tag = _dataItem.getTag();
        const se = ScriptExpression_1.ScriptExpression.fromTag(_tag);
        if (se) {
            scriptExpressions.push(se);
            if (_dataItem.getData() instanceof lib_1.DataItem) {
                _dataItem = _dataItem.getData();
                _tag = _dataItem.getTag();
            }
            else {
                break;
            }
        }
        else {
            break;
        }
    }
    const seLength = scriptExpressions.length;
    const isMultiKey = seLength > 0 &&
        (scriptExpressions[seLength - 1].getExpression() ===
            ScriptExpression_1.ScriptExpressions.MULTISIG.getExpression() ||
            scriptExpressions[seLength - 1].getExpression() ===
                ScriptExpression_1.ScriptExpressions.SORTED_MULTISIG.getExpression());
    if (isMultiKey) {
        const multiKey = MultiKey_1.MultiKey.fromDataItem(_dataItem);
        return new CryptoOutput(scriptExpressions, multiKey);
    }
    if (_dataItem.getTag() === RegistryType_1.RegistryTypes.CRYPTO_HDKEY.getTag()) {
        const cryptoHDKey = CryptoHDKey_1.CryptoHDKey.fromDataItem(_dataItem);
        return new CryptoOutput(scriptExpressions, cryptoHDKey);
    }
    else {
        const cryptoECKey = CryptoECKey_1.CryptoECKey.fromDataItem(_dataItem);
        return new CryptoOutput(scriptExpressions, cryptoECKey);
    }
};
CryptoOutput.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoOutput.fromDataItem(dataItem);
};
//# sourceMappingURL=CryptoOutput.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoOutput.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoPSBT.js", {"./RegistryItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CCryptoPSBT.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoPSBT = void 0;
const lib_1 = require("./lib");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
class CryptoPSBT extends RegistryItem_1.RegistryItem {
    constructor(psbt) {
        super();
        this.psbt = psbt;
        this.getRegistryType = () => RegistryType_1.RegistryTypes.CRYPTO_PSBT;
        this.getPSBT = () => this.psbt;
        this.toDataItem = () => {
            return new lib_1.DataItem(this.psbt);
        };
    }
}
exports.CryptoPSBT = CryptoPSBT;
CryptoPSBT.fromDataItem = (dataItem) => {
    const psbt = dataItem.getData();
    if (!psbt) {
        throw new Error(`#[ur-registry][CryptoPSBT][fn.fromDataItem]: decoded [dataItem][#data] is undefined: ${dataItem}`);
    }
    return new CryptoPSBT(psbt);
};
CryptoPSBT.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoPSBT.fromDataItem(dataItem);
};
//# sourceMappingURL=CryptoPSBT.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoPSBT.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Decoder\\index.js", {"..":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js","../RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","../errors":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\errors\\index.js","@ngraveio/bc-ur":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ngraveio\\bc-ur\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CDecoder%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.URRegistryDecoder = void 0;
const bc_ur_1 = require("@ngraveio/bc-ur");
const __1 = require("..");
const RegistryType_1 = require("../RegistryType");
const errors_1 = require("../errors");
class URRegistryDecoder extends bc_ur_1.URDecoder {
    constructor() {
        super(...arguments);
        this.resultRegistryType = () => {
            const ur = this.resultUR();
            switch (ur.type) {
                case RegistryType_1.RegistryTypes.BYTES.getType():
                    return __1.Bytes.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_HDKEY.getType():
                    return __1.CryptoHDKey.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_KEYPATH.getType():
                    return __1.CryptoKeypath.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_COIN_INFO.getType():
                    return __1.CryptoCoinInfo.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_ECKEY.getType():
                    return __1.CryptoECKey.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_OUTPUT.getType():
                    return __1.CryptoOutput.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_PSBT.getType():
                    return __1.CryptoPSBT.fromCBOR(ur.cbor);
                case RegistryType_1.RegistryTypes.CRYPTO_ACCOUNT.getType():
                    return __1.CryptoAccount.fromCBOR(ur.cbor);
                default:
                    throw new errors_1.UnknownURTypeError(`#[ur-registry][Decoder][fn.resultRegistryType]: registry type ${ur.type} is not supported now`);
            }
        };
    }
}
exports.URRegistryDecoder = URRegistryDecoder;
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Decoder\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\MultiKey.js", {"./CryptoECKey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoECKey.js","./CryptoHDKey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js","./RegistryItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./lib/DataItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\DataItem.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CMultiKey.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiKey = void 0;
const CryptoECKey_1 = require("./CryptoECKey");
const CryptoHDKey_1 = require("./CryptoHDKey");
const DataItem_1 = require("./lib/DataItem");
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
var Keys;
(function (Keys) {
    Keys[Keys["threshold"] = 1] = "threshold";
    Keys[Keys["keys"] = 2] = "keys";
})(Keys || (Keys = {}));
class MultiKey extends RegistryItem_1.RegistryItem {
    constructor(threshold, keys) {
        super();
        this.threshold = threshold;
        this.keys = keys;
        this.getThreshold = () => this.threshold;
        this.getKeys = () => this.keys;
        this.toDataItem = () => {
            const map = {};
            map[Keys.threshold] = this.threshold;
            const keys = this.keys.map((k) => {
                const dataItem = k.toDataItem();
                dataItem.setTag(k.getRegistryType().getTag());
                return dataItem;
            });
            map[Keys.keys] = keys;
            return new DataItem_1.DataItem(map);
        };
        this.getOutputDescriptorContent = () => {
            return [this.getThreshold(),
                this.keys.map(k => k.getOutputDescriptorContent()).join(','),
            ].join(',');
        };
    }
}
exports.MultiKey = MultiKey;
MultiKey.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const threshold = map[Keys.threshold];
    const _keys = map[Keys.keys];
    const keys = [];
    _keys.forEach((k) => {
        if (k.getTag() === RegistryType_1.RegistryTypes.CRYPTO_HDKEY.getTag()) {
            keys.push(CryptoHDKey_1.CryptoHDKey.fromDataItem(k));
        }
        else if (k.getTag() === RegistryType_1.RegistryTypes.CRYPTO_ECKEY.getTag()) {
            keys.push(CryptoECKey_1.CryptoECKey.fromDataItem(k));
        }
    });
    return new MultiKey(threshold, keys);
};
//# sourceMappingURL=MultiKey.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\MultiKey.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\PathComponent.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CPathComponent.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PathComponent = void 0;
class PathComponent {
    constructor(args) {
        this.getIndex = () => this.index;
        this.isWildcard = () => this.wildcard;
        this.isHardened = () => this.hardened;
        this.index = args.index;
        this.hardened = args.hardened;
        if (this.index !== undefined) {
            this.wildcard = false;
        }
        else {
            this.wildcard = true;
        }
        if (this.index && (this.index & PathComponent.HARDENED_BIT) !== 0) {
            throw new Error(`#[ur-registry][PathComponent][fn.constructor]: Invalid index ${this.index} - most significant bit cannot be set`);
        }
    }
}
exports.PathComponent = PathComponent;
PathComponent.HARDENED_BIT = 0x80000000;
//# sourceMappingURL=PathComponent.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\PathComponent.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js", {"./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","@ngraveio/bc-ur":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ngraveio\\bc-ur\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CRegistryItem.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegistryItem = void 0;
const bc_ur_1 = require("@ngraveio/bc-ur");
const lib_1 = require("./lib");
class RegistryItem {
    constructor() {
        this.toCBOR = () => {
            if (this.toDataItem() === undefined) {
                throw new Error(`#[ur-registry][RegistryItem][fn.toCBOR]: registry ${this.getRegistryType()}'s method toDataItem returns undefined`);
            }
            return (0, lib_1.encodeDataItem)(this.toDataItem());
        };
        this.toUR = () => {
            return new bc_ur_1.UR(this.toCBOR(), this.getRegistryType().getType());
        };
        this.toUREncoder = (maxFragmentLength, firstSeqNum, minFragmentLength) => {
            const ur = this.toUR();
            const urEncoder = new bc_ur_1.UREncoder(ur, maxFragmentLength, firstSeqNum, minFragmentLength);
            return urEncoder;
        };
    }
}
exports.RegistryItem = RegistryItem;
//# sourceMappingURL=RegistryItem.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CRegistryType.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegistryTypes = exports.RegistryType = void 0;
class RegistryType {
    constructor(type, tag) {
        this.type = type;
        this.tag = tag;
        this.getTag = () => this.tag;
        this.getType = () => this.type;
    }
}
exports.RegistryType = RegistryType;
exports.RegistryTypes = {
    UUID: new RegistryType('uuid', 37),
    BYTES: new RegistryType('bytes', undefined),
    CRYPTO_HDKEY: new RegistryType('crypto-hdkey', 303),
    CRYPTO_KEYPATH: new RegistryType('crypto-keypath', 304),
    CRYPTO_COIN_INFO: new RegistryType('crypto-coin-info', 305),
    CRYPTO_ECKEY: new RegistryType('crypto-eckey', 306),
    CRYPTO_OUTPUT: new RegistryType('crypto-output', 308),
    CRYPTO_PSBT: new RegistryType('crypto-psbt', 310),
    CRYPTO_ACCOUNT: new RegistryType('crypto-account', 311),
    CRYPTO_MULTI_ACCOUNTS: new RegistryType("crypto-multi-accounts", 1103),
};
//# sourceMappingURL=RegistryType.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\ScriptExpression.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CScriptExpression.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScriptExpressions = exports.ScriptExpression = void 0;
class ScriptExpression {
    constructor(tag, expression) {
        this.tag = tag;
        this.expression = expression;
        this.getTag = () => this.tag;
        this.getExpression = () => this.expression;
    }
}
exports.ScriptExpression = ScriptExpression;
ScriptExpression.fromTag = (tag) => {
    const se = Object.values(exports.ScriptExpressions).find((se) => se.getTag() === tag);
    return se;
};
exports.ScriptExpressions = {
    SCRIPT_HASH: new ScriptExpression(400, 'sh'),
    WITNESS_SCRIPT_HASH: new ScriptExpression(401, 'wsh'),
    PUBLIC_KEY: new ScriptExpression(402, 'pk'),
    PUBLIC_KEY_HASH: new ScriptExpression(403, 'pkh'),
    WITNESS_PUBLIC_KEY_HASH: new ScriptExpression(404, 'wpkh'),
    COMBO: new ScriptExpression(405, 'combo'),
    MULTISIG: new ScriptExpression(406, 'multi'),
    SORTED_MULTISIG: new ScriptExpression(407, 'sortedmulti'),
    ADDRESS: new ScriptExpression(307, 'addr'),
    RAW_SCRIPT: new ScriptExpression(408, 'raw'),
};
//# sourceMappingURL=ScriptExpression.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\ScriptExpression.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\errors\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Cerrors%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnknownURTypeError = void 0;
class UnknownURTypeError extends Error {
    constructor(message) {
        super(message);
    }
}
exports.UnknownURTypeError = UnknownURTypeError;
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\errors\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\extended\\CryptoMultiAccounts.js", {"../CryptoHDKey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js","../RegistryItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","../RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","../lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Cextended%5CCryptoMultiAccounts.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoMultiAccounts = void 0;
const RegistryType_1 = require("../RegistryType");
const CryptoHDKey_1 = require("../CryptoHDKey");
const RegistryItem_1 = require("../RegistryItem");
const lib_1 = require("../lib");
var Keys;
(function (Keys) {
    Keys[Keys["masterFingerprint"] = 1] = "masterFingerprint";
    Keys[Keys["keys"] = 2] = "keys";
    Keys[Keys["device"] = 3] = "device";
})(Keys || (Keys = {}));
class CryptoMultiAccounts extends RegistryItem_1.RegistryItem {
    constructor(masterFingerprint, keys, device) {
        super();
        this.masterFingerprint = masterFingerprint;
        this.keys = keys;
        this.device = device;
        this.getRegistryType = () => RegistryType_1.RegistryTypes.CRYPTO_MULTI_ACCOUNTS;
        this.getMasterFingerprint = () => this.masterFingerprint;
        this.getKeys = () => this.keys;
        this.getDevice = () => this.device;
        this.toDataItem = () => {
            const map = {};
            if (this.masterFingerprint) {
                map[Keys.masterFingerprint] = this.masterFingerprint.readUInt32BE(0);
            }
            if (this.keys) {
                map[Keys.keys] = this.keys.map((item) => {
                    const dataItem = item.toDataItem();
                    dataItem.setTag(item.getRegistryType().getTag());
                    return dataItem;
                });
            }
            if (this.device) {
                map[Keys.device] = this.device;
            }
            return new lib_1.DataItem(map);
        };
    }
}
exports.CryptoMultiAccounts = CryptoMultiAccounts;
CryptoMultiAccounts.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const masterFingerprint = Buffer.alloc(4);
    const _masterFingerprint = map[Keys.masterFingerprint];
    if (_masterFingerprint) {
        masterFingerprint.writeUInt32BE(_masterFingerprint, 0);
    }
    const keys = map[Keys.keys];
    const cryptoHDKeys = keys.map((item) => CryptoHDKey_1.CryptoHDKey.fromDataItem(item));
    const device = map[Keys.device];
    return new CryptoMultiAccounts(masterFingerprint, cryptoHDKeys, device);
};
CryptoMultiAccounts.fromCBOR = (_cborPayload) => {
    const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);
    return CryptoMultiAccounts.fromDataItem(dataItem);
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\extended\\CryptoMultiAccounts.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js", {"./Bytes":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Bytes.js","./CryptoAccount":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoAccount.js","./CryptoCoinInfo":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoCoinInfo.js","./CryptoECKey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoECKey.js","./CryptoHDKey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoHDKey.js","./CryptoKeypath":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoKeypath.js","./CryptoOutput":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoOutput.js","./CryptoPSBT":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\CryptoPSBT.js","./Decoder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\Decoder\\index.js","./MultiKey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\MultiKey.js","./PathComponent":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\PathComponent.js","./RegistryItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryItem.js","./RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./ScriptExpression":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\ScriptExpression.js","./errors":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\errors\\index.js","./extended/CryptoMultiAccounts":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\extended\\CryptoMultiAccounts.js","./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js","./patchCBOR":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\patchCBOR.js","./types":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\types.js","./utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\utils.js","buffer/":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\buffer\\index.js","tslib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\tslib\\tslib.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Buffer = exports.extend = exports.PathComponent = exports.ScriptExpressions = exports.MultiKey = exports.CryptoPSBT = exports.CryptoOutput = exports.CryptoECKey = exports.CryptoCoinInfoNetwork = exports.CryptoCoinInfoType = exports.CryptoCoinInfo = exports.CryptoKeypath = exports.CryptoMultiAccounts = exports.CryptoHDKey = exports.CryptoAccount = exports.Bytes = exports.URRegistryDecoder = exports.DataItem = void 0;
const tslib_1 = require("tslib");
require("./patchCBOR");
const buffer_1 = require("buffer/");
Object.defineProperty(exports, "Buffer", { enumerable: true, get: function () { return buffer_1.Buffer; } });
const CryptoHDKey_1 = require("./CryptoHDKey");
Object.defineProperty(exports, "CryptoHDKey", { enumerable: true, get: function () { return CryptoHDKey_1.CryptoHDKey; } });
const CryptoKeypath_1 = require("./CryptoKeypath");
Object.defineProperty(exports, "CryptoKeypath", { enumerable: true, get: function () { return CryptoKeypath_1.CryptoKeypath; } });
const CryptoCoinInfo_1 = require("./CryptoCoinInfo");
Object.defineProperty(exports, "CryptoCoinInfo", { enumerable: true, get: function () { return CryptoCoinInfo_1.CryptoCoinInfo; } });
Object.defineProperty(exports, "CryptoCoinInfoType", { enumerable: true, get: function () { return CryptoCoinInfo_1.Type; } });
Object.defineProperty(exports, "CryptoCoinInfoNetwork", { enumerable: true, get: function () { return CryptoCoinInfo_1.Network; } });
const CryptoECKey_1 = require("./CryptoECKey");
Object.defineProperty(exports, "CryptoECKey", { enumerable: true, get: function () { return CryptoECKey_1.CryptoECKey; } });
const Bytes_1 = require("./Bytes");
Object.defineProperty(exports, "Bytes", { enumerable: true, get: function () { return Bytes_1.Bytes; } });
const CryptoOutput_1 = require("./CryptoOutput");
Object.defineProperty(exports, "CryptoOutput", { enumerable: true, get: function () { return CryptoOutput_1.CryptoOutput; } });
const CryptoPSBT_1 = require("./CryptoPSBT");
Object.defineProperty(exports, "CryptoPSBT", { enumerable: true, get: function () { return CryptoPSBT_1.CryptoPSBT; } });
const CryptoAccount_1 = require("./CryptoAccount");
Object.defineProperty(exports, "CryptoAccount", { enumerable: true, get: function () { return CryptoAccount_1.CryptoAccount; } });
const Decoder_1 = require("./Decoder");
Object.defineProperty(exports, "URRegistryDecoder", { enumerable: true, get: function () { return Decoder_1.URRegistryDecoder; } });
const MultiKey_1 = require("./MultiKey");
Object.defineProperty(exports, "MultiKey", { enumerable: true, get: function () { return MultiKey_1.MultiKey; } });
const ScriptExpression_1 = require("./ScriptExpression");
Object.defineProperty(exports, "ScriptExpressions", { enumerable: true, get: function () { return ScriptExpression_1.ScriptExpressions; } });
const PathComponent_1 = require("./PathComponent");
Object.defineProperty(exports, "PathComponent", { enumerable: true, get: function () { return PathComponent_1.PathComponent; } });
const RegistryItem_1 = require("./RegistryItem");
const RegistryType_1 = require("./RegistryType");
const lib_1 = require("./lib");
var lib_2 = require("./lib");
Object.defineProperty(exports, "DataItem", { enumerable: true, get: function () { return lib_2.DataItem; } });
const utils_1 = require("./utils");
const CryptoMultiAccounts_1 = require("./extended/CryptoMultiAccounts");
Object.defineProperty(exports, "CryptoMultiAccounts", { enumerable: true, get: function () { return CryptoMultiAccounts_1.CryptoMultiAccounts; } });
const URlib = {
    URRegistryDecoder: Decoder_1.URRegistryDecoder,
    Bytes: Bytes_1.Bytes,
    CryptoAccount: CryptoAccount_1.CryptoAccount,
    CryptoHDKey: CryptoHDKey_1.CryptoHDKey,
    CryptoMultiAccounts: CryptoMultiAccounts_1.CryptoMultiAccounts,
    CryptoKeypath: CryptoKeypath_1.CryptoKeypath,
    CryptoCoinInfo: CryptoCoinInfo_1.CryptoCoinInfo,
    CryptoCoinInfoType: CryptoCoinInfo_1.Type,
    CryptoCoinInfoNetwork: CryptoCoinInfo_1.Network,
    CryptoECKey: CryptoECKey_1.CryptoECKey,
    CryptoOutput: CryptoOutput_1.CryptoOutput,
    CryptoPSBT: CryptoPSBT_1.CryptoPSBT,
    MultiKey: MultiKey_1.MultiKey,
    ScriptExpressions: ScriptExpression_1.ScriptExpressions,
    PathComponent: PathComponent_1.PathComponent,
};
const cbor = {
    addReader: lib_1.addReader,
    addSemanticDecode: lib_1.addSemanticDecode,
    addSemanticEncode: lib_1.addSemanticEncode,
    addWriter: lib_1.addWriter,
    patchTags: utils_1.patchTags,
};
const extend = {
    RegistryTypes: RegistryType_1.RegistryTypes,
    RegistryItem: RegistryItem_1.RegistryItem,
    RegistryType: RegistryType_1.RegistryType,
    decodeToDataItem: lib_1.decodeToDataItem,
    encodeDataItem: lib_1.encodeDataItem,
    cbor,
};
exports.extend = extend;
(0, tslib_1.__exportStar)(require("./errors"), exports);
(0, tslib_1.__exportStar)(require("./Decoder"), exports);
(0, tslib_1.__exportStar)(require("./lib"), exports);
(0, tslib_1.__exportStar)(require("./CryptoAccount"), exports);
(0, tslib_1.__exportStar)(require("./CryptoPSBT"), exports);
(0, tslib_1.__exportStar)(require("./CryptoHDKey"), exports);
(0, tslib_1.__exportStar)(require("./extended/CryptoMultiAccounts"), exports);
(0, tslib_1.__exportStar)(require("./CryptoOutput"), exports);
(0, tslib_1.__exportStar)(require("./CryptoCoinInfo"), exports);
(0, tslib_1.__exportStar)(require("./CryptoECKey"), exports);
(0, tslib_1.__exportStar)(require("./MultiKey"), exports);
(0, tslib_1.__exportStar)(require("./CryptoKeypath"), exports);
(0, tslib_1.__exportStar)(require("./patchCBOR"), exports);
(0, tslib_1.__exportStar)(require("./PathComponent"), exports);
(0, tslib_1.__exportStar)(require("./RegistryItem"), exports);
(0, tslib_1.__exportStar)(require("./RegistryType"), exports);
(0, tslib_1.__exportStar)(require("./types"), exports);
(0, tslib_1.__exportStar)(require("./utils"), exports);
exports.default = URlib;
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\DataItem.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Clib%5CDataItem.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataItem = void 0;
class DataItem {
    constructor(data, tag) {
        this.setTag = (tag) => {
            this.tag = tag;
        };
        this.clearTag = () => {
            this.tag = undefined;
        };
        this.getTag = () => {
            return this.tag;
        };
        this.getData = () => {
            return this.data;
        };
        this.data = data;
        this.tag = tag;
    }
}
exports.DataItem = DataItem;
//# sourceMappingURL=DataItem.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\DataItem.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\cbor-sync.js", {"./DataItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\DataItem.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Clib%5Ccbor-sync.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
(function (global, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    }
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = factory();
    }
    else {
        global.CBOR = factory();
    }
})(this, function () {
    const { DataItem } = require('./DataItem');
    var CBOR = (function () {
        function BinaryHex(hex) {
            this.$hex = hex;
        }
        BinaryHex.prototype = {
            length: function () {
                return this.$hex.length / 2;
            },
            toString: function (format) {
                if (!format || format === 'hex' || format === 16)
                    return this.$hex;
                if (format === 'utf-8') {
                    var encoded = '';
                    for (var i = 0; i < this.$hex.length; i += 2) {
                        encoded += '%' + this.$hex.substring(i, i + 2);
                    }
                    return decodeURIComponent(encoded);
                }
                if (format === 'latin') {
                    var encoded = [];
                    for (var i = 0; i < this.$hex.length; i += 2) {
                        encoded.push(parseInt(this.$hex.substring(i, i + 2), 16));
                    }
                    return String.fromCharCode.apply(String, encoded);
                }
                throw new Error('Unrecognised format: ' + format);
            },
        };
        BinaryHex.fromLatinString = function (latinString) {
            var hex = '';
            for (var i = 0; i < latinString.length; i++) {
                var pair = latinString.charCodeAt(i).toString(16);
                if (pair.length === 1)
                    pair = '0' + pair;
                hex += pair;
            }
            return new BinaryHex(hex);
        };
        BinaryHex.fromUtf8String = function (utf8String) {
            var encoded = encodeURIComponent(utf8String);
            var hex = '';
            for (var i = 0; i < encoded.length; i++) {
                if (encoded.charAt(i) === '%') {
                    hex += encoded.substring(i + 1, i + 3);
                    i += 2;
                }
                else {
                    var hexPair = encoded.charCodeAt(i).toString(16);
                    if (hexPair.length < 2)
                        hexPair = '0' + hexPair;
                    hex += hexPair;
                }
            }
            return new BinaryHex(hex);
        };
        var semanticEncoders = [];
        var semanticDecoders = {};
        var notImplemented = function (label) {
            return function () {
                throw new Error(label + ' not implemented');
            };
        };
        function Reader() { }
        Reader.prototype = {
            peekByte: notImplemented('peekByte'),
            readByte: notImplemented('readByte'),
            readChunk: notImplemented('readChunk'),
            readFloat16: function () {
                var half = this.readUint16();
                var exponent = (half & 0x7fff) >> 10;
                var mantissa = half & 0x3ff;
                var negative = half & 0x8000;
                if (exponent === 0x1f) {
                    if (mantissa === 0) {
                        return negative ? -Infinity : Infinity;
                    }
                    return NaN;
                }
                var magnitude = exponent
                    ? Math.pow(2, exponent - 25) * (1024 + mantissa)
                    : Math.pow(2, -24) * mantissa;
                return negative ? -magnitude : magnitude;
            },
            readFloat32: function () {
                var intValue = this.readUint32();
                var exponent = (intValue & 0x7fffffff) >> 23;
                var mantissa = intValue & 0x7fffff;
                var negative = intValue & 0x80000000;
                if (exponent === 0xff) {
                    if (mantissa === 0) {
                        return negative ? -Infinity : Infinity;
                    }
                    return NaN;
                }
                var magnitude = exponent
                    ? Math.pow(2, exponent - 23 - 127) * (8388608 + mantissa)
                    : Math.pow(2, -23 - 126) * mantissa;
                return negative ? -magnitude : magnitude;
            },
            readFloat64: function () {
                var int1 = this.readUint32(), int2 = this.readUint32();
                var exponent = (int1 >> 20) & 0x7ff;
                var mantissa = (int1 & 0xfffff) * 4294967296 + int2;
                var negative = int1 & 0x80000000;
                if (exponent === 0x7ff) {
                    if (mantissa === 0) {
                        return negative ? -Infinity : Infinity;
                    }
                    return NaN;
                }
                var magnitude = exponent
                    ? Math.pow(2, exponent - 52 - 1023) * (4503599627370496 + mantissa)
                    : Math.pow(2, -52 - 1022) * mantissa;
                return negative ? -magnitude : magnitude;
            },
            readUint16: function () {
                return this.readByte() * 256 + this.readByte();
            },
            readUint32: function () {
                return this.readUint16() * 65536 + this.readUint16();
            },
            readUint64: function () {
                return this.readUint32() * 4294967296 + this.readUint32();
            },
        };
        function Writer() { }
        Writer.prototype = {
            writeByte: notImplemented('writeByte'),
            result: notImplemented('result'),
            writeFloat16: notImplemented('writeFloat16'),
            writeFloat32: notImplemented('writeFloat32'),
            writeFloat64: notImplemented('writeFloat64'),
            writeUint16: function (value) {
                this.writeByte((value >> 8) & 0xff);
                this.writeByte(value & 0xff);
            },
            writeUint32: function (value) {
                this.writeUint16((value >> 16) & 0xffff);
                this.writeUint16(value & 0xffff);
            },
            writeUint64: function (value) {
                if (value >= 9007199254740992 || value <= -9007199254740992) {
                    throw new Error('Cannot encode Uint64 of: ' +
                        value +
                        ' magnitude to big (floating point errors)');
                }
                this.writeUint32(Math.floor(value / 4294967296));
                this.writeUint32(value % 4294967296);
            },
            writeString: notImplemented('writeString'),
            canWriteBinary: function (chunk) {
                return false;
            },
            writeBinary: notImplemented('writeChunk'),
        };
        function readHeaderRaw(reader) {
            var firstByte = reader.readByte();
            var majorType = firstByte >> 5, value = firstByte & 0x1f;
            return { type: majorType, value: value };
        }
        function valueFromHeader(header, reader) {
            var value = header.value;
            if (value < 24) {
                return value;
            }
            else if (value == 24) {
                return reader.readByte();
            }
            else if (value == 25) {
                return reader.readUint16();
            }
            else if (value == 26) {
                return reader.readUint32();
            }
            else if (value == 27) {
                return reader.readUint64();
            }
            else if (value == 31) {
                return null;
            }
            notImplemented('Additional info: ' + value)();
        }
        function writeHeaderRaw(type, value, writer) {
            writer.writeByte((type << 5) | value);
        }
        function writeHeader(type, value, writer) {
            var firstByte = type << 5;
            if (value < 24) {
                writer.writeByte(firstByte | value);
            }
            else if (value < 256) {
                writer.writeByte(firstByte | 24);
                writer.writeByte(value);
            }
            else if (value < 65536) {
                writer.writeByte(firstByte | 25);
                writer.writeUint16(value);
            }
            else if (value < 4294967296) {
                writer.writeByte(firstByte | 26);
                writer.writeUint32(value);
            }
            else {
                writer.writeByte(firstByte | 27);
                writer.writeUint64(value);
            }
        }
        var stopCode = new Error();
        function decodeReader(reader) {
            var header = readHeaderRaw(reader);
            switch (header.type) {
                case 0:
                    return valueFromHeader(header, reader);
                case 1:
                    return -1 - valueFromHeader(header, reader);
                case 2:
                    return reader.readChunk(valueFromHeader(header, reader));
                case 3:
                    var buffer = reader.readChunk(valueFromHeader(header, reader));
                    return buffer.toString('utf-8');
                case 4:
                case 5:
                    var arrayLength = valueFromHeader(header, reader);
                    var result = [];
                    if (arrayLength !== null) {
                        if (header.type === 5) {
                            arrayLength *= 2;
                        }
                        for (var i = 0; i < arrayLength; i++) {
                            result[i] = decodeReader(reader);
                        }
                    }
                    else {
                        var item;
                        while ((item = decodeReader(reader)) !== stopCode) {
                            result.push(item);
                        }
                    }
                    if (header.type === 5) {
                        var objResult = {};
                        for (var i = 0; i < result.length; i += 2) {
                            objResult[result[i]] = result[i + 1];
                        }
                        return objResult;
                    }
                    else {
                        return result;
                    }
                case 6:
                    var tag = valueFromHeader(header, reader);
                    var decoder = semanticDecoders[tag];
                    var result = decodeReader(reader);
                    return decoder ? decoder(result) : result;
                case 7:
                    if (header.value === 25) {
                        return reader.readFloat16();
                    }
                    else if (header.value === 26) {
                        return reader.readFloat32();
                    }
                    else if (header.value === 27) {
                        return reader.readFloat64();
                    }
                    switch (valueFromHeader(header, reader)) {
                        case 20:
                            return false;
                        case 21:
                            return true;
                        case 22:
                            return null;
                        case 23:
                            return undefined;
                        case null:
                            return stopCode;
                        default:
                            throw new Error('Unknown fixed value: ' + header.value);
                    }
                default:
                    throw new Error('Unsupported header: ' + JSON.stringify(header));
            }
            throw new Error('not implemented yet');
        }
        function encodeWriter(data, writer) {
            for (var i = 0; i < semanticEncoders.length; i++) {
                var replacement = semanticEncoders[i].fn(data);
                if (replacement !== undefined) {
                    writeHeader(6, semanticEncoders[i].tag, writer);
                    return encodeWriter(replacement, writer);
                }
            }
            if (data && typeof data.toCBOR === 'function') {
                data = data.toCBOR();
            }
            if (data === false) {
                writeHeader(7, 20, writer);
            }
            else if (data === true) {
                writeHeader(7, 21, writer);
            }
            else if (data === null) {
                writeHeader(7, 22, writer);
            }
            else if (data === undefined) {
                writeHeader(7, 23, writer);
            }
            else if (typeof data === 'number') {
                if (Math.floor(data) === data &&
                    data < 9007199254740992 &&
                    data > -9007199254740992) {
                    if (data < 0) {
                        writeHeader(1, -1 - data, writer);
                    }
                    else {
                        writeHeader(0, data, writer);
                    }
                }
                else {
                    writeHeaderRaw(7, 27, writer);
                    writer.writeFloat64(data);
                }
            }
            else if (typeof data === 'string') {
                writer.writeString(data, function (length) {
                    writeHeader(3, length, writer);
                });
            }
            else if (writer.canWriteBinary(data)) {
                writer.writeBinary(data, function (length) {
                    writeHeader(2, length, writer);
                });
            }
            else if (typeof data === 'object') {
                if (api.config.useToJSON && typeof data.toJSON === 'function') {
                    data = data.toJSON();
                }
                if (Array.isArray(data)) {
                    writeHeader(4, data.length, writer);
                    for (var i = 0; i < data.length; i++) {
                        encodeWriter(data[i], writer);
                    }
                }
                else {
                    var keys = Object.keys(data);
                    writeHeader(5, keys.length, writer);
                    for (var i = 0; i < keys.length; i++) {
                        const number = parseInt(keys[i]);
                        if (isNaN(number)) {
                            encodeWriter(keys[i], writer);
                            encodeWriter(data[keys[i]], writer);
                        }
                        else {
                            encodeWriter(number, writer);
                            encodeWriter(data[keys[i]], writer);
                        }
                    }
                }
            }
            else {
                throw new Error('CBOR encoding not supported: ' + data);
            }
        }
        var readerFunctions = [];
        var writerFunctions = [];
        var api = {
            config: {
                useToJSON: true,
            },
            addWriter: function (format, writerFunction) {
                if (typeof format === 'string') {
                    writerFunctions.push(function (f) {
                        if (format === f)
                            return writerFunction(f);
                    });
                }
                else {
                    writerFunctions.push(format);
                }
            },
            addReader: function (format, readerFunction) {
                if (typeof format === 'string') {
                    readerFunctions.push(function (data, f) {
                        if (format === f)
                            return readerFunction(data, f);
                    });
                }
                else {
                    readerFunctions.push(format);
                }
            },
            encode: function (data, format) {
                for (var i = 0; i < writerFunctions.length; i++) {
                    var func = writerFunctions[i];
                    var writer = func(format);
                    if (writer) {
                        encodeWriter(data, writer);
                        return writer.result();
                    }
                }
                throw new Error('Unsupported output format: ' + format);
            },
            encodeDataItem: function (data, format) {
                for (var i = 0; i < writerFunctions.length; i++) {
                    var func = writerFunctions[i];
                    var writer = func(format);
                    if (writer) {
                        if (data.getTag() !== undefined) {
                            encodeWriter(data, writer);
                            return writer.result();
                        }
                        else {
                            encodeWriter(data.getData(), writer);
                            return writer.result();
                        }
                    }
                }
                throw new Error('Unsupported output format: ' + format);
            },
            decode: function (data, format) {
                for (var i = 0; i < readerFunctions.length; i++) {
                    var func = readerFunctions[i];
                    var reader = func(data, format);
                    if (reader) {
                        return decodeReader(reader);
                    }
                }
                throw new Error('Unsupported input format: ' + format);
            },
            decodeToDataItem: function (data, format) {
                for (var i = 0; i < readerFunctions.length; i++) {
                    var func = readerFunctions[i];
                    var reader = func(data, format);
                    if (reader) {
                        const result = decodeReader(reader);
                        if (result instanceof DataItem) {
                            return result;
                        }
                        else {
                            return new DataItem(result);
                        }
                    }
                }
                throw new Error('Unsupported input format: ' + format);
            },
            addSemanticEncode: function (tag, fn) {
                if (typeof tag !== 'number' || tag % 1 !== 0 || tag < 0) {
                    throw new Error('Tag must be a positive integer');
                }
                semanticEncoders.push({ tag: tag, fn: fn });
                return this;
            },
            addSemanticDecode: function (tag, fn) {
                if (typeof tag !== 'number' || tag % 1 !== 0 || tag < 0) {
                    throw new Error('Tag must be a positive integer');
                }
                semanticDecoders[tag] = fn;
                return this;
            },
        };
        function BufferReader(buffer) {
            this.buffer = buffer;
            this.pos = 0;
        }
        BufferReader.prototype = Object.create(Reader.prototype);
        BufferReader.prototype.peekByte = function () {
            return this.buffer[this.pos];
        };
        BufferReader.prototype.readByte = function () {
            return this.buffer[this.pos++];
        };
        BufferReader.prototype.readUint16 = function () {
            var result = this.buffer.readUInt16BE(this.pos);
            this.pos += 2;
            return result;
        };
        BufferReader.prototype.readUint32 = function () {
            var result = this.buffer.readUInt32BE(this.pos);
            this.pos += 4;
            return result;
        };
        BufferReader.prototype.readFloat32 = function () {
            var result = this.buffer.readFloatBE(this.pos);
            this.pos += 4;
            return result;
        };
        BufferReader.prototype.readFloat64 = function () {
            var result = this.buffer.readDoubleBE(this.pos);
            this.pos += 8;
            return result;
        };
        BufferReader.prototype.readChunk = function (length) {
            var result = Buffer.alloc(length);
            this.buffer.copy(result, 0, this.pos, (this.pos += length));
            return result;
        };
        function BufferWriter(stringFormat) {
            this.byteLength = 0;
            this.defaultBufferLength = 16384;
            this.latestBuffer = Buffer.alloc(this.defaultBufferLength);
            this.latestBufferOffset = 0;
            this.completeBuffers = [];
            this.stringFormat = stringFormat;
        }
        BufferWriter.prototype = Object.create(Writer.prototype);
        BufferWriter.prototype.writeByte = function (value) {
            this.latestBuffer[this.latestBufferOffset++] = value;
            if (this.latestBufferOffset >= this.latestBuffer.length) {
                this.completeBuffers.push(this.latestBuffer);
                this.latestBuffer = Buffer.alloc(this.defaultBufferLength);
                this.latestBufferOffset = 0;
            }
            this.byteLength++;
        };
        BufferWriter.prototype.writeFloat32 = function (value) {
            var buffer = Buffer.alloc(4);
            buffer.writeFloatBE(value, 0);
            this.writeBuffer(buffer);
        };
        BufferWriter.prototype.writeFloat64 = function (value) {
            var buffer = Buffer.alloc(8);
            buffer.writeDoubleBE(value, 0);
            this.writeBuffer(buffer);
        };
        BufferWriter.prototype.writeString = function (string, lengthFunc) {
            var buffer = Buffer.from(string, 'utf-8');
            lengthFunc(buffer.length);
            this.writeBuffer(buffer);
        };
        BufferWriter.prototype.canWriteBinary = function (data) {
            return data instanceof Buffer;
        };
        BufferWriter.prototype.writeBinary = function (buffer, lengthFunc) {
            lengthFunc(buffer.length);
            this.writeBuffer(buffer);
        };
        BufferWriter.prototype.writeBuffer = function (chunk) {
            if (!(chunk instanceof Buffer))
                throw new TypeError('BufferWriter only accepts Buffers');
            if (!this.latestBufferOffset) {
                this.completeBuffers.push(chunk);
            }
            else if (this.latestBuffer.length - this.latestBufferOffset >=
                chunk.length) {
                chunk.copy(this.latestBuffer, this.latestBufferOffset);
                this.latestBufferOffset += chunk.length;
                if (this.latestBufferOffset >= this.latestBuffer.length) {
                    this.completeBuffers.push(this.latestBuffer);
                    this.latestBuffer = Buffer.alloc(this.defaultBufferLength);
                    this.latestBufferOffset = 0;
                }
            }
            else {
                this.completeBuffers.push(this.latestBuffer.slice(0, this.latestBufferOffset));
                this.completeBuffers.push(chunk);
                this.latestBuffer = Buffer.alloc(this.defaultBufferLength);
                this.latestBufferOffset = 0;
            }
            this.byteLength += chunk.length;
        };
        BufferWriter.prototype.result = function () {
            var result = Buffer.alloc(this.byteLength);
            var offset = 0;
            for (var i = 0; i < this.completeBuffers.length; i++) {
                var buffer = this.completeBuffers[i];
                buffer.copy(result, offset, 0, buffer.length);
                offset += buffer.length;
            }
            if (this.latestBufferOffset) {
                this.latestBuffer.copy(result, offset, 0, this.latestBufferOffset);
            }
            if (this.stringFormat)
                return result.toString(this.stringFormat);
            return result;
        };
        if (typeof Buffer === 'function') {
            api.addReader(function (data, format) {
                if (Buffer.isBuffer(data)) {
                    return new BufferReader(data);
                }
                if (format === 'hex' || format === 'base64') {
                    var buffer = Buffer.from(data, format);
                    return new BufferReader(buffer);
                }
            });
            api.addWriter(function (format) {
                if (!format || format === 'buffer') {
                    return new BufferWriter();
                }
                else if (format === 'hex' || format === 'base64') {
                    return new BufferWriter(format);
                }
            });
        }
        function HexReader(hex) {
            this.hex = hex;
            this.pos = 0;
        }
        HexReader.prototype = Object.create(Reader.prototype);
        HexReader.prototype.peekByte = function () {
            var pair = this.hex.substring(this.pos, 2);
            return parseInt(pair, 16);
        };
        HexReader.prototype.readByte = function () {
            var pair = this.hex.substring(this.pos, this.pos + 2);
            this.pos += 2;
            return parseInt(pair, 16);
        };
        HexReader.prototype.readChunk = function (length) {
            var hex = this.hex.substring(this.pos, this.pos + length * 2);
            this.pos += length * 2;
            if (typeof Buffer === 'function')
                return Buffer.from(hex, 'hex');
            return new BinaryHex(hex);
        };
        function HexWriter(finalFormat) {
            this.$hex = '';
            this.finalFormat = finalFormat || 'hex';
        }
        HexWriter.prototype = Object.create(Writer.prototype);
        HexWriter.prototype.writeByte = function (value) {
            if (value < 0 || value > 255)
                throw new Error('Byte value out of range: ' + value);
            var hex = value.toString(16);
            if (hex.length == 1) {
                hex = '0' + hex;
            }
            this.$hex += hex;
        };
        HexWriter.prototype.canWriteBinary = function (chunk) {
            return (chunk instanceof BinaryHex ||
                (typeof Buffer === 'function' && chunk instanceof Buffer));
        };
        HexWriter.prototype.writeBinary = function (chunk, lengthFunction) {
            if (chunk instanceof BinaryHex) {
                lengthFunction(chunk.length());
                this.$hex += chunk.$hex;
            }
            else if (typeof Buffer === 'function' && chunk instanceof Buffer) {
                lengthFunction(chunk.length);
                this.$hex += chunk.toString('hex');
            }
            else {
                throw new TypeError('HexWriter only accepts BinaryHex or Buffers');
            }
        };
        HexWriter.prototype.result = function () {
            if (this.finalFormat === 'buffer' && typeof Buffer === 'function') {
                return Buffer.from(this.$hex, 'hex');
            }
            return new BinaryHex(this.$hex).toString(this.finalFormat);
        };
        HexWriter.prototype.writeString = function (string, lengthFunction) {
            var buffer = BinaryHex.fromUtf8String(string);
            lengthFunction(buffer.length());
            this.$hex += buffer.$hex;
        };
        api.addReader(function (data, format) {
            if (data instanceof BinaryHex || data.$hex) {
                return new HexReader(data.$hex);
            }
            if (format === 'hex') {
                return new HexReader(data);
            }
        });
        api.addWriter(function (format) {
            if (format === 'hex') {
                return new HexWriter();
            }
        });
        return api;
    })();
    CBOR.addSemanticEncode(0, function (data) {
        if (data instanceof Date) {
            return data.toISOString();
        }
    })
        .addSemanticDecode(0, function (isoString) {
        return new Date(isoString);
    })
        .addSemanticDecode(1, function (isoString) {
        return new Date(isoString);
    });
    return CBOR;
});

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\cbor-sync.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js", {"./DataItem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\DataItem.js","./cbor-sync":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\cbor-sync.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Clib%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataItem = exports.addWriter = exports.addReader = exports.addSemanticEncode = exports.addSemanticDecode = exports.decodeToDataItem = exports.encodeDataItem = void 0;
var cbor_sync_1 = require("./cbor-sync");
Object.defineProperty(exports, "encodeDataItem", { enumerable: true, get: function () { return cbor_sync_1.encodeDataItem; } });
Object.defineProperty(exports, "decodeToDataItem", { enumerable: true, get: function () { return cbor_sync_1.decodeToDataItem; } });
Object.defineProperty(exports, "addSemanticDecode", { enumerable: true, get: function () { return cbor_sync_1.addSemanticDecode; } });
Object.defineProperty(exports, "addSemanticEncode", { enumerable: true, get: function () { return cbor_sync_1.addSemanticEncode; } });
Object.defineProperty(exports, "addReader", { enumerable: true, get: function () { return cbor_sync_1.addReader; } });
Object.defineProperty(exports, "addWriter", { enumerable: true, get: function () { return cbor_sync_1.addWriter; } });
var DataItem_1 = require("./DataItem");
Object.defineProperty(exports, "DataItem", { enumerable: true, get: function () { return DataItem_1.DataItem; } });
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\patchCBOR.js", {"./RegistryType":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\RegistryType.js","./ScriptExpression":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\ScriptExpression.js","./utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5CpatchCBOR.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const RegistryType_1 = require("./RegistryType");
const ScriptExpression_1 = require("./ScriptExpression");
const registryTags = Object.values(RegistryType_1.RegistryTypes)
    .filter((r) => !!r.getTag())
    .map((r) => r.getTag());
const scriptExpressionTags = Object.values(ScriptExpression_1.ScriptExpressions).map((se) => se.getTag());
(0, utils_1.patchTags)(registryTags.concat(scriptExpressionTags));
//# sourceMappingURL=patchCBOR.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\patchCBOR.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\types.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Ctypes.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=types.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\types.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\utils.js", {"./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@keystonehq%5Cbc-ur-registry%5Cdist%5Cutils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.patchTags = void 0;
const lib_1 = require("./lib");
const alreadyPatchedTag = [];
const patchTags = (tags) => {
    tags.forEach((tag) => {
        if (alreadyPatchedTag.find((i) => i === tag))
            return;
        (0, lib_1.addSemanticEncode)(tag, (data) => {
            if (data instanceof lib_1.DataItem) {
                if (data.getTag() === tag) {
                    return data.getData();
                }
            }
        });
        (0, lib_1.addSemanticDecode)(tag, (data) => {
            return new lib_1.DataItem(data, tag);
        });
        alreadyPatchedTag.push(tag);
    });
};
exports.patchTags = patchTags;
//# sourceMappingURL=utils.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/bc-ur-registry-eth>@keystonehq/bc-ur-registry",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\utils.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ComposedStore.js", {"./ObservableStore":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@metamask%5Cobs-store%5Cdist%5CComposedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComposedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class ComposedStore extends ObservableStore_1.ObservableStore {
    constructor(children) {
        // Typecast: Preserve existing behavior
        super({});
        // subscribe to children
        this._children = children || {};
        Object.keys(this._children).forEach((childKey) => {
            const child = this._children[childKey];
            this._addChild(childKey, child);
        });
    }
    _addChild(childKey, child) {
        const updateFromChild = (childValue) => {
            const state = this.getState();
            state[childKey] = childValue;
            this.putState(state);
        };
        child.subscribe(updateFromChild);
        updateFromChild(child.getState());
    }
}
exports.ComposedStore = ComposedStore;
//# sourceMappingURL=ComposedStore.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ComposedStore.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\MergedStore.js", {"./ObservableStore":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@metamask%5Cobs-store%5Cdist%5CMergedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class MergedStore extends ObservableStore_1.ObservableStore {
    constructor(children = []) {
        // Typecast: Preserve existing behavior
        super({});
        this._children = children;
        // subscribe to children
        children.forEach((child) => this._addChild(child));
        this._updateWholeState();
    }
    _addChild(child) {
        child.subscribe(() => this._updateWholeState());
    }
    _updateWholeState() {
        const childStates = this._children.map((child) => child.getState());
        // apply shallow merge over states
        const state = Object.assign({}, ...childStates);
        this.putState(state);
    }
}
exports.MergedStore = MergedStore;
//# sourceMappingURL=MergedStore.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\MergedStore.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js", {"@metamask/safe-event-emitter":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\safe-event-emitter\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@metamask%5Cobs-store%5Cdist%5CObservableStore.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservableStore = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
class ObservableStore extends safe_event_emitter_1.default {
    constructor(initState) {
        super();
        if (initState) {
            this._state = initState;
        }
        else {
            // Typecast/default state: Preserve existing behavior
            this._state = {};
        }
    }
    // wrapper around internal getState
    getState() {
        return this._getState();
    }
    // wrapper around internal putState
    putState(newState) {
        this._putState(newState);
        this.emit('update', newState);
    }
    updateState(partialState) {
        // if non-null object, merge
        if (partialState && typeof partialState === 'object') {
            const state = this.getState();
            this.putState(Object.assign(Object.assign({}, state), partialState));
            // if not object, use new value
        }
        else {
            this.putState(partialState);
        }
    }
    // subscribe to changes
    subscribe(handler) {
        this.on('update', handler);
    }
    // unsubscribe to changes
    unsubscribe(handler) {
        this.removeListener('update', handler);
    }
    //
    // private
    //
    // read from persistence
    _getState() {
        return this._state;
    }
    // write to persistence
    _putState(newState) {
        this._state = newState;
    }
}
exports.ObservableStore = ObservableStore;
//# sourceMappingURL=ObservableStore.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\asStream.js", {"stream":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\stream-browserify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@metamask%5Cobs-store%5Cdist%5CasStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeAsStream = void 0;
const stream_1 = require("stream");
class ObservableStoreStream extends stream_1.Duplex {
    constructor(obsStore) {
        super({
            // pass values, not serializations
            objectMode: true,
        });
        // dont buffer outgoing updates
        this.resume();
        // save handler so we can unsubscribe later
        this.handler = (state) => this.push(state);
        // subscribe to obsStore changes
        this.obsStore = obsStore;
        this.obsStore.subscribe(this.handler);
    }
    // emit current state on new destination
    pipe(dest, options) {
        const result = super.pipe(dest, options);
        dest.write(this.obsStore.getState());
        return result;
    }
    // write from incoming stream to state
    _write(chunk, _encoding, callback) {
        this.obsStore.putState(chunk);
        callback();
    }
    // noop - outgoing stream is asking us if we have data we arent giving it
    _read(_size) {
        return undefined;
    }
    // unsubscribe from event emitter
    _destroy(err, callback) {
        this.obsStore.unsubscribe(this.handler);
        super._destroy(err, callback);
    }
}
function storeAsStream(obsStore) {
    return new ObservableStoreStream(obsStore);
}
exports.storeAsStream = storeAsStream;
//# sourceMappingURL=asStream.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\asStream.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\index.js", {"./ComposedStore":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ComposedStore.js","./MergedStore":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\MergedStore.js","./ObservableStore":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js","./asStream":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\asStream.js","./transform":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\transform.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@metamask%5Cobs-store%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./asStream"), exports);
__exportStar(require("./ComposedStore"), exports);
__exportStar(require("./MergedStore"), exports);
__exportStar(require("./ObservableStore"), exports);
__exportStar(require("./transform"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\transform.js", {"through2":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\through2\\through2.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@metamask%5Cobs-store%5Cdist%5Ctransform.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeTransformStream = void 0;
const through2_1 = require("through2");
function storeTransformStream(syncTransformFn) {
    return through2_1.obj((state, _encoding, cb) => {
        try {
            const newState = syncTransformFn(state);
            cb(null, newState);
            return undefined;
        }
        catch (err) {
            cb(err);
            return undefined;
        }
    });
}
exports.storeTransformStream = storeTransformStream;
//# sourceMappingURL=transform.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\transform.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\through2\\through2.js", {"_process":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\process\\browser.js","readable-stream":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\readable-stream\\readable-browser.js","util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\util\\util.js","xtend":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\xtend\\immutable.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5Cthrough2%5Cthrough2.js
      return function (require, module, exports) {
(function (process){(function (){
var Transform = require('readable-stream').Transform
  , inherits  = require('util').inherits
  , xtend     = require('xtend')

function DestroyableTransform(opts) {
  Transform.call(this, opts)
  this._destroyed = false
}

inherits(DestroyableTransform, Transform)

DestroyableTransform.prototype.destroy = function(err) {
  if (this._destroyed) return
  this._destroyed = true
  
  var self = this
  process.nextTick(function() {
    if (err)
      self.emit('error', err)
    self.emit('close')
  })
}

// a noop _transform function
function noop (chunk, enc, callback) {
  callback(null, chunk)
}


// create a new export function, used by both the main export and
// the .ctor export, contains common logic for dealing with arguments
function through2 (construct) {
  return function (options, transform, flush) {
    if (typeof options == 'function') {
      flush     = transform
      transform = options
      options   = {}
    }

    if (typeof transform != 'function')
      transform = noop

    if (typeof flush != 'function')
      flush = null

    return construct(options, transform, flush)
  }
}


// main export, just make me a transform stream!
module.exports = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(options)

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})


// make me a reusable prototype that I can `new`, or implicitly `new`
// with a constructor call
module.exports.ctor = through2(function (options, transform, flush) {
  function Through2 (override) {
    if (!(this instanceof Through2))
      return new Through2(override)

    this.options = xtend(options, override)

    DestroyableTransform.call(this, this.options)
  }

  inherits(Through2, DestroyableTransform)

  Through2.prototype._transform = transform

  if (flush)
    Through2.prototype._flush = flush

  return Through2
})


module.exports.obj = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})

}).call(this)}).call(this,require('_process'))

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store>through2",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\through2\\through2.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\address-book-controller\\dist\\AddressBookController.js", {"@metamask/base-controller":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\base-controller\\dist\\index.js","@metamask/controller-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\controller-utils\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Caddress-book-controller%5Cdist%5CAddressBookController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressBookController = exports.AddressType = void 0;
const controller_utils_1 = require("@metamask/controller-utils");
const base_controller_1 = require("@metamask/base-controller");
var AddressType;
(function (AddressType) {
    AddressType["externallyOwnedAccounts"] = "EXTERNALLY_OWNED_ACCOUNTS";
    AddressType["contractAccounts"] = "CONTRACT_ACCOUNTS";
    AddressType["nonAccounts"] = "NON_ACCOUNTS";
})(AddressType = exports.AddressType || (exports.AddressType = {}));
/**
 * Controller that manages a list of recipient addresses associated with nicknames.
 */
class AddressBookController extends base_controller_1.BaseController {
    /**
     * Creates an AddressBookController instance.
     *
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor(config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'AddressBookController';
        this.defaultState = { addressBook: {} };
        this.initialize();
    }
    /**
     * Remove all contract entries.
     */
    clear() {
        this.update({ addressBook: {} });
    }
    /**
     * Remove a contract entry by address.
     *
     * @param chainId - Chain id identifies the current chain.
     * @param address - Recipient address to delete.
     * @returns Whether the entry was deleted.
     */
    delete(chainId, address) {
        address = (0, controller_utils_1.toChecksumHexAddress)(address);
        if (!(0, controller_utils_1.isValidHexAddress)(address) ||
            !this.state.addressBook[chainId] ||
            !this.state.addressBook[chainId][address]) {
            return false;
        }
        const addressBook = Object.assign({}, this.state.addressBook);
        delete addressBook[chainId][address];
        if (Object.keys(addressBook[chainId]).length === 0) {
            delete addressBook[chainId];
        }
        this.update({ addressBook });
        return true;
    }
    /**
     * Add or update a contact entry by address.
     *
     * @param address - Recipient address to add or update.
     * @param name - Nickname to associate with this address.
     * @param chainId - Chain id identifies the current chain.
     * @param memo - User's note about address.
     * @param addressType - Contact's address type.
     * @returns Boolean indicating if the address was successfully set.
     */
    set(address, name, chainId = '1', memo = '', addressType) {
        address = (0, controller_utils_1.toChecksumHexAddress)(address);
        if (!(0, controller_utils_1.isValidHexAddress)(address)) {
            return false;
        }
        const entry = {
            address,
            chainId,
            isEns: false,
            memo,
            name,
            addressType,
        };
        const ensName = (0, controller_utils_1.normalizeEnsName)(name);
        if (ensName) {
            entry.name = ensName;
            entry.isEns = true;
        }
        this.update({
            addressBook: Object.assign(Object.assign({}, this.state.addressBook), { [chainId]: Object.assign(Object.assign({}, this.state.addressBook[chainId]), { [address]: entry }) }),
        });
        return true;
    }
}
exports.AddressBookController = AddressBookController;
exports.default = AddressBookController;
//# sourceMappingURL=AddressBookController.js.map
      };
    };
  }
  }
}, {package:"@metamask/address-book-controller",file:"node_modules\\@metamask\\address-book-controller\\dist\\AddressBookController.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\address-book-controller\\dist\\index.js", {"./AddressBookController":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\address-book-controller\\dist\\AddressBookController.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Caddress-book-controller%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./AddressBookController"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/address-book-controller",file:"node_modules\\@metamask\\address-book-controller\\dist\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\announcement-controller\\dist\\AnnouncementController.js", {"@metamask/base-controller":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\base-controller\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Cannouncement-controller%5Cdist%5CAnnouncementController.js
      return function (require, module, exports) {
"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AnnouncementController_instances, _AnnouncementController_addAnnouncements;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnnouncementController = void 0;
const base_controller_1 = require("@metamask/base-controller");
const controllerName = 'AnnouncementController';
const defaultState = {
    announcements: {},
};
const metadata = {
    announcements: {
        persist: true,
        anonymous: true,
    },
};
/**
 * Controller for managing in-app announcements.
 */
class AnnouncementController extends base_controller_1.BaseControllerV2 {
    /**
     * Creates a AnnouncementController instance.
     *
     * @param args - The arguments to this function.
     * @param args.messenger - Messenger used to communicate with BaseV2 controller.
     * @param args.state - Initial state to set on this controller.
     * @param args.allAnnouncements - Announcements to be passed through to #addAnnouncements
     */
    constructor({ messenger, state, allAnnouncements, }) {
        const mergedState = Object.assign(Object.assign({}, defaultState), state);
        super({ messenger, metadata, name: controllerName, state: mergedState });
        _AnnouncementController_instances.add(this);
        __classPrivateFieldGet(this, _AnnouncementController_instances, "m", _AnnouncementController_addAnnouncements).call(this, allAnnouncements);
    }
    /**
     * Updates the status of the status of the specified announcements
     * once it is read by the user.
     *
     * @param viewedIds - The announcement IDs to mark as viewed.
     */
    updateViewed(viewedIds) {
        this.update(({ announcements }) => {
            for (const id of Object.keys(viewedIds).map(Number)) {
                announcements[id].isShown = viewedIds[id];
            }
        });
    }
}
exports.AnnouncementController = AnnouncementController;
_AnnouncementController_instances = new WeakSet(), _AnnouncementController_addAnnouncements = function _AnnouncementController_addAnnouncements(allAnnouncements) {
    this.update((state) => {
        Object.values(allAnnouncements).forEach((announcement) => {
            var _a;
            state.announcements[announcement.id] = (_a = state.announcements[announcement.id]) !== null && _a !== void 0 ? _a : Object.assign(Object.assign({}, announcement), { isShown: false });
        });
    });
};
//# sourceMappingURL=AnnouncementController.js.map
      };
    };
  }
  }
}, {package:"@metamask/announcement-controller",file:"node_modules\\@metamask\\announcement-controller\\dist\\AnnouncementController.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\announcement-controller\\dist\\index.js", {"./AnnouncementController":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\announcement-controller\\dist\\AnnouncementController.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Cannouncement-controller%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./AnnouncementController"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/announcement-controller",file:"node_modules\\@metamask\\announcement-controller\\dist\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\approval-controller\\dist\\ApprovalController.js", {"./errors":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\approval-controller\\dist\\errors.js","@metamask/base-controller":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\base-controller\\dist\\index.js","eth-rpc-errors":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\eth-rpc-errors\\dist\\index.js","nanoid":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\approval-controller\\node_modules\\nanoid\\index.browser.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Capproval-controller%5Cdist%5CApprovalController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApprovalController = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const nanoid_1 = require("nanoid");
const base_controller_1 = require("@metamask/base-controller");
const errors_1 = require("./errors");
const controllerName = 'ApprovalController';
const stateMetadata = {
    pendingApprovals: { persist: false, anonymous: true },
    pendingApprovalCount: { persist: false, anonymous: false },
};
const getAlreadyPendingMessage = (origin, type) => `Request of type '${type}' already pending for origin ${origin}. Please wait.`;
const getDefaultState = () => {
    return {
        pendingApprovals: {},
        pendingApprovalCount: 0,
    };
};
/**
 * Controller for managing requests that require user approval.
 *
 * Enables limiting the number of pending requests by origin and type, counting
 * pending requests, and more.
 *
 * Adding a request returns a promise that resolves or rejects when the request
 * is approved or denied, respectively.
 */
class ApprovalController extends base_controller_1.BaseControllerV2 {
    /**
     * Construct an Approval controller.
     *
     * @param options - The controller options.
     * @param options.showApprovalRequest - Function for opening the UI such that
     * the request can be displayed to the user.
     * @param options.messenger - The restricted controller messenger for the Approval controller.
     * @param options.state - The initial controller state.
     * @param options.typesExcludedFromRateLimiting - Array of aproval types which allow multiple pending approval requests from the same origin.
     */
    constructor({ messenger, showApprovalRequest, state = {}, typesExcludedFromRateLimiting = [], }) {
        super({
            name: controllerName,
            metadata: stateMetadata,
            messenger,
            state: Object.assign(Object.assign({}, getDefaultState()), state),
        });
        this._approvals = new Map();
        this._origins = new Map();
        this._showApprovalRequest = showApprovalRequest;
        this._typesExcludedFromRateLimiting = typesExcludedFromRateLimiting;
        this.registerMessageHandlers();
    }
    /**
     * Constructor helper for registering this controller's messaging system
     * actions.
     */
    registerMessageHandlers() {
        this.messagingSystem.registerActionHandler(`${controllerName}:clearRequests`, this.clear.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:addRequest`, (opts, shouldShowRequest) => {
            if (shouldShowRequest) {
                return this.addAndShowApprovalRequest(opts);
            }
            return this.add(opts);
        });
        this.messagingSystem.registerActionHandler(`${controllerName}:hasRequest`, this.has.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:acceptRequest`, this.accept.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:rejectRequest`, this.reject.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:updateRequestState`, this.updateRequestState.bind(this));
    }
    /**
     * Adds an approval request per the given arguments, calls the show approval
     * request function, and returns the associated approval promise.
     *
     * There can only be one approval per origin and type. An error is thrown if
     * attempting to add an invalid or duplicate request.
     *
     * @param opts - Options bag.
     * @param opts.id - The id of the approval request. A random id will be
     * generated if none is provided.
     * @param opts.origin - The origin of the approval request.
     * @param opts.type - The type associated with the approval request.
     * @param opts.requestData - Additional data associated with the request,
     * @param opts.requestState - Additional state associated with the request,
     * if any.
     * @returns The approval promise.
     */
    addAndShowApprovalRequest(opts) {
        const promise = this._add(opts.origin, opts.type, opts.id, opts.requestData, opts.requestState);
        this._showApprovalRequest();
        return promise;
    }
    /**
     * Adds an approval request per the given arguments and returns the approval
     * promise.
     *
     * There can only be one approval per origin and type. An error is thrown if
     * attempting to add an invalid or duplicate request.
     *
     * @param opts - Options bag.
     * @param opts.id - The id of the approval request. A random id will be
     * generated if none is provided.
     * @param opts.origin - The origin of the approval request.
     * @param opts.type - The type associated with the approval request.
     * @param opts.requestData - Additional data associated with the request,
     * if any.
     * @returns The approval promise.
     */
    add(opts) {
        return this._add(opts.origin, opts.type, opts.id, opts.requestData, opts.requestState);
    }
    /**
     * Gets the info for the approval request with the given id.
     *
     * @param id - The id of the approval request.
     * @returns The approval request data associated with the id.
     */
    get(id) {
        return this.state.pendingApprovals[id];
    }
    /**
     * Gets the number of pending approvals, by origin and/or type.
     *
     * If only `origin` is specified, all approvals for that origin will be
     * counted, regardless of type.
     * If only `type` is specified, all approvals for that type will be counted,
     * regardless of origin.
     * If both `origin` and `type` are specified, 0 or 1 will be returned.
     *
     * @param opts - The approval count options.
     * @param opts.origin - An approval origin.
     * @param opts.type - The type of the approval request.
     * @returns The current approval request count for the given origin and/or
     * type.
     */
    getApprovalCount(opts = {}) {
        var _a;
        if (!opts.origin && !opts.type) {
            throw new Error('Must specify origin, type, or both.');
        }
        const { origin, type: _type } = opts;
        if (origin && _type) {
            return ((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.get(_type)) || 0;
        }
        if (origin) {
            return Array.from((this._origins.get(origin) || new Map()).values()).reduce((total, value) => total + value, 0);
        }
        // Only "type" was specified
        let count = 0;
        for (const approval of Object.values(this.state.pendingApprovals)) {
            if (approval.type === _type) {
                count += 1;
            }
        }
        return count;
    }
    /**
     * Get the total count of all pending approval requests for all origins.
     *
     * @returns The total pending approval request count.
     */
    getTotalApprovalCount() {
        return this.state.pendingApprovalCount;
    }
    /**
     * Checks if there's a pending approval request per the given parameters.
     * At least one parameter must be specified. An error will be thrown if the
     * parameters are invalid.
     *
     * If `id` is specified, all other parameters will be ignored.
     * If `id` is not specified, the method will check for requests that match
     * all of the specified parameters.
     *
     * @param opts - Options bag.
     * @param opts.id - The ID to check for.
     * @param opts.origin - The origin to check for.
     * @param opts.type - The type to check for.
     * @returns `true` if a matching approval is found, and `false` otherwise.
     */
    has(opts = {}) {
        var _a;
        const { id, origin, type: _type } = opts;
        if (id) {
            if (typeof id !== 'string') {
                throw new Error('May not specify non-string id.');
            }
            return this._approvals.has(id);
        }
        if (_type && typeof _type !== 'string') {
            throw new Error('May not specify non-string type.');
        }
        if (origin) {
            if (typeof origin !== 'string') {
                throw new Error('May not specify non-string origin.');
            }
            // Check origin and type pair if type also specified
            if (_type) {
                return Boolean((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.get(_type));
            }
            return this._origins.has(origin);
        }
        if (_type) {
            for (const approval of Object.values(this.state.pendingApprovals)) {
                if (approval.type === _type) {
                    return true;
                }
            }
            return false;
        }
        throw new Error('Must specify a valid combination of id, origin, and type.');
    }
    /**
     * Resolves the promise of the approval with the given id, and deletes the
     * approval. Throws an error if no such approval exists.
     *
     * @param id - The id of the approval request.
     * @param value - The value to resolve the approval promise with.
     */
    accept(id, value) {
        this._deleteApprovalAndGetCallbacks(id).resolve(value);
    }
    /**
     * Rejects the promise of the approval with the given id, and deletes the
     * approval. Throws an error if no such approval exists.
     *
     * @param id - The id of the approval request.
     * @param error - The error to reject the approval promise with.
     */
    reject(id, error) {
        this._deleteApprovalAndGetCallbacks(id).reject(error);
    }
    /**
     * Rejects and deletes all approval requests.
     *
     * @param rejectionError - The EthereumRpcError to reject the approval
     * requests with.
     */
    clear(rejectionError) {
        for (const id of this._approvals.keys()) {
            this.reject(id, rejectionError);
        }
        this._origins.clear();
        this.update(() => getDefaultState());
    }
    /**
     * Updates the request state of the approval with the given id.
     *
     * @param opts - Options bag.
     * @param opts.id - The id of the approval request.
     * @param opts.requestState - Additional data associated with the request
     */
    updateRequestState(opts) {
        if (!this.state.pendingApprovals[opts.id]) {
            throw new errors_1.ApprovalRequestNotFoundError(opts.id);
        }
        this.update((draftState) => {
            // Typecast: ts(2589)
            draftState.pendingApprovals[opts.id].requestState =
                opts.requestState;
        });
    }
    /**
     * Implementation of add operation.
     *
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     * @param id - The id of the approval request.
     * @param requestData - The request data associated with the approval request.
     * @param requestState - The request state associated with the approval request.
     * @returns The approval promise.
     */
    _add(origin, type, id = (0, nanoid_1.nanoid)(), requestData, requestState) {
        this._validateAddParams(id, origin, type, requestData, requestState);
        if (!this._typesExcludedFromRateLimiting.includes(type) &&
            this.has({ origin, type })) {
            throw eth_rpc_errors_1.ethErrors.rpc.resourceUnavailable(getAlreadyPendingMessage(origin, type));
        }
        // add pending approval
        return new Promise((resolve, reject) => {
            this._approvals.set(id, { resolve, reject });
            this._addPendingApprovalOrigin(origin, type);
            this._addToStore(id, origin, type, requestData, requestState);
        });
    }
    /**
     * Validates parameters to the add method.
     *
     * @param id - The id of the approval request.
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     * @param requestData - The request data associated with the approval request.
     * @param requestState - The request state associated with the approval request.
     */
    _validateAddParams(id, origin, type, requestData, requestState) {
        let errorMessage = null;
        if (!id || typeof id !== 'string') {
            errorMessage = 'Must specify non-empty string id.';
        }
        else if (this._approvals.has(id)) {
            errorMessage = `Approval request with id '${id}' already exists.`;
        }
        else if (!origin || typeof origin !== 'string') {
            errorMessage = 'Must specify non-empty string origin.';
        }
        else if (!type || typeof type !== 'string') {
            errorMessage = 'Must specify non-empty string type.';
        }
        else if (requestData &&
            (typeof requestData !== 'object' || Array.isArray(requestData))) {
            errorMessage = 'Request data must be a plain object if specified.';
        }
        else if (requestState &&
            (typeof requestState !== 'object' || Array.isArray(requestState))) {
            errorMessage = 'Request state must be a plain object if specified.';
        }
        if (errorMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.internal(errorMessage);
        }
    }
    /**
     * Adds an entry to _origins.
     * Performs no validation.
     *
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     */
    _addPendingApprovalOrigin(origin, type) {
        let originMap = this._origins.get(origin);
        if (!originMap) {
            originMap = new Map();
            this._origins.set(origin, originMap);
        }
        const currentValue = originMap.get(type) || 0;
        originMap.set(type, currentValue + 1);
    }
    /**
     * Adds an entry to the store.
     * Performs no validation.
     *
     * @param id - The id of the approval request.
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     * @param requestData - The request data associated with the approval request.
     * @param requestState - The request state associated with the approval request.
     */
    _addToStore(id, origin, type, requestData, requestState) {
        const approval = {
            id,
            origin,
            type,
            time: Date.now(),
            requestData: requestData || null,
            requestState: requestState || null,
        };
        this.update((draftState) => {
            // Typecast: ts(2589)
            draftState.pendingApprovals[id] = approval;
            draftState.pendingApprovalCount = Object.keys(draftState.pendingApprovals).length;
        });
    }
    /**
     * Deletes the approval with the given id. The approval promise must be
     * resolved or reject before this method is called.
     * Deletion is an internal operation because approval state is solely
     * managed by this controller.
     *
     * @param id - The id of the approval request to be deleted.
     */
    _delete(id) {
        this._approvals.delete(id);
        // This method is only called after verifying that the approval with the
        // specified id exists.
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const { origin, type } = this.state.pendingApprovals[id];
        const originMap = this._origins.get(origin);
        const originTotalCount = this.getApprovalCount({ origin });
        const originTypeCount = originMap.get(type);
        if (originTotalCount === 1) {
            this._origins.delete(origin);
        }
        else {
            originMap.set(type, originTypeCount - 1);
        }
        this.update((draftState) => {
            delete draftState.pendingApprovals[id];
            draftState.pendingApprovalCount = Object.keys(draftState.pendingApprovals).length;
        });
    }
    /**
     * Gets the approval callbacks for the given id, deletes the entry, and then
     * returns the callbacks for promise resolution.
     * Throws an error if no approval is found for the given id.
     *
     * @param id - The id of the approval request.
     * @returns The promise callbacks associated with the approval request.
     */
    _deleteApprovalAndGetCallbacks(id) {
        const callbacks = this._approvals.get(id);
        if (!callbacks) {
            throw new errors_1.ApprovalRequestNotFoundError(id);
        }
        this._delete(id);
        return callbacks;
    }
}
exports.ApprovalController = ApprovalController;
exports.default = ApprovalController;
//# sourceMappingURL=ApprovalController.js.map
      };
    };
  }
  }
}, {package:"@metamask/approval-controller",file:"node_modules\\@metamask\\approval-controller\\dist\\ApprovalController.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\approval-controller\\dist\\errors.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Capproval-controller%5Cdist%5Cerrors.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApprovalRequestNotFoundError = void 0;
class ApprovalRequestNotFoundError extends Error {
    constructor(id) {
        super(`Approval request with id '${id}' not found.`);
    }
}
exports.ApprovalRequestNotFoundError = ApprovalRequestNotFoundError;
//# sourceMappingURL=errors.js.map
      };
    };
  }
  }
}, {package:"@metamask/approval-controller",file:"node_modules\\@metamask\\approval-controller\\dist\\errors.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\approval-controller\\dist\\index.js", {"./ApprovalController":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\approval-controller\\dist\\ApprovalController.js","./errors":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\approval-controller\\dist\\errors.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Capproval-controller%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./ApprovalController"), exports);
__exportStar(require("./errors"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/approval-controller",file:"node_modules\\@metamask\\approval-controller\\dist\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\approval-controller\\node_modules\\nanoid\\index.browser.cjs", {"./url-alphabet/index.cjs":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\approval-controller\\node_modules\\nanoid\\url-alphabet\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Capproval-controller%5Cnode_modules%5Cnanoid%5Cindex.browser.cjs
      return function (require, module, exports) {
let { urlAlphabet } = require('./url-alphabet/index.cjs')
let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))
let customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1
  let step = -~((1.6 * mask * defaultSize) / alphabet.length)
  return (size = defaultSize) => {
    let id = ''
    while (true) {
      let bytes = getRandom(step)
      let j = step
      while (j--) {
        id += alphabet[bytes[j] & mask] || ''
        if (id.length === size) return id
      }
    }
  }
}
let customAlphabet = (alphabet, size = 21) =>
  customRandom(alphabet, size, random)
let nanoid = (size = 21) =>
  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
    byte &= 63
    if (byte < 36) {
      id += byte.toString(36)
    } else if (byte < 62) {
      id += (byte - 26).toString(36).toUpperCase()
    } else if (byte > 62) {
      id += '-'
    } else {
      id += '_'
    }
    return id
  }, '')
module.exports = { nanoid, customAlphabet, customRandom, urlAlphabet, random }

      };
    };
  }
  }
}, {package:"@metamask/approval-controller>nanoid",file:"node_modules\\@metamask\\approval-controller\\node_modules\\nanoid\\index.browser.cjs",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\approval-controller\\node_modules\\nanoid\\url-alphabet\\index.cjs", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Capproval-controller%5Cnode_modules%5Cnanoid%5Curl-alphabet%5Cindex.cjs
      return function (require, module, exports) {
let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'
module.exports = { urlAlphabet }

      };
    };
  }
  }
}, {package:"@metamask/approval-controller>nanoid",file:"node_modules\\@metamask\\approval-controller\\node_modules\\nanoid\\url-alphabet\\index.cjs",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\browser-passworder\\dist\\index.js", {"buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Cbrowser-passworder%5Cdist%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSalt = exports.serializeBufferForStorage = exports.serializeBufferFromStorage = exports.keyFromPassword = exports.exportKey = exports.importKey = exports.decryptWithKey = exports.decryptWithDetail = exports.decrypt = exports.encryptWithKey = exports.encryptWithDetail = exports.encrypt = void 0;
const EXPORT_FORMAT = 'jwk';
const DERIVED_KEY_FORMAT = 'AES-GCM';
const STRING_ENCODING = 'utf-8';
/**
 * Encrypts a data object that can be any serializable value using
 * a provided password.
 *
 * @param password - The password to use for encryption.
 * @param dataObj - The data to encrypt.
 * @param key - The CryptoKey to encrypt with.
 * @param salt - The salt to use to encrypt.
 * @returns The encrypted vault.
 */
async function encrypt(password, dataObj, key, salt = generateSalt()) {
    const cryptoKey = key || (await keyFromPassword(password, salt));
    const payload = await encryptWithKey(cryptoKey, dataObj);
    payload.salt = salt;
    return JSON.stringify(payload);
}
exports.encrypt = encrypt;
/**
 * Encrypts a data object that can be any serializable value using
 * a provided password.
 *
 * @param password - A password to use for encryption.
 * @param dataObj - The data to encrypt.
 * @param salt - The salt used to encrypt.
 * @returns The vault and exported key string.
 */
async function encryptWithDetail(password, dataObj, salt = generateSalt()) {
    const key = await keyFromPassword(password, salt, true);
    const exportedKeyString = await exportKey(key);
    const vault = await encrypt(password, dataObj, key, salt);
    return {
        vault,
        exportedKeyString,
    };
}
exports.encryptWithDetail = encryptWithDetail;
/**
 * Encrypts the provided serializable javascript object using the
 * provided CryptoKey and returns an object containing the cypher text and
 * the initialization vector used.
 *
 * @param key - The CryptoKey to encrypt with.
 * @param dataObj - A serializable JavaScript object to encrypt.
 * @returns The encrypted data.
 */
async function encryptWithKey(key, dataObj) {
    const data = JSON.stringify(dataObj);
    const dataBuffer = Buffer.from(data, STRING_ENCODING);
    const vector = global.crypto.getRandomValues(new Uint8Array(16));
    const buf = await global.crypto.subtle.encrypt({
        name: DERIVED_KEY_FORMAT,
        iv: vector,
    }, key, dataBuffer);
    const buffer = new Uint8Array(buf);
    const vectorStr = Buffer.from(vector).toString('base64');
    const vaultStr = Buffer.from(buffer).toString('base64');
    return {
        data: vaultStr,
        iv: vectorStr,
    };
}
exports.encryptWithKey = encryptWithKey;
/**
 * Given a password and a cypher text, decrypts the text and returns
 * the resulting value.
 *
 * @param password - The password to decrypt with.
 * @param text - The cypher text to decrypt.
 * @param key - The key to decrypt with.
 * @returns The decrypted data.
 */
async function decrypt(password, text, key) {
    const payload = JSON.parse(text);
    const { salt } = payload;
    const cryptoKey = key || (await keyFromPassword(password, salt));
    const result = await decryptWithKey(cryptoKey, payload);
    return result;
}
exports.decrypt = decrypt;
/**
 * Given a password and a cypher text, decrypts the text and returns
 * the resulting value, keyString, and salt.
 *
 * @param password - The password to decrypt with.
 * @param text - The encrypted vault to decrypt.
 * @returns The decrypted vault along with the salt and exported key.
 */
async function decryptWithDetail(password, text) {
    const payload = JSON.parse(text);
    const { salt } = payload;
    const key = await keyFromPassword(password, salt, true);
    const exportedKeyString = await exportKey(key);
    const vault = await decrypt(password, text, key);
    return {
        exportedKeyString,
        vault,
        salt,
    };
}
exports.decryptWithDetail = decryptWithDetail;
/**
 * Given a CryptoKey and an EncryptionResult object containing the initialization
 * vector (iv) and data to decrypt, return the resulting decrypted value.
 *
 * @param key - The CryptoKey to decrypt with.
 * @param payload - The payload to decrypt, returned from an encryption method.
 * @returns The decrypted data.
 */
async function decryptWithKey(key, payload) {
    const encryptedData = Buffer.from(payload.data, 'base64');
    const vector = Buffer.from(payload.iv, 'base64');
    let decryptedObj;
    try {
        const result = await crypto.subtle.decrypt({ name: DERIVED_KEY_FORMAT, iv: vector }, key, encryptedData);
        const decryptedData = new Uint8Array(result);
        const decryptedStr = Buffer.from(decryptedData).toString(STRING_ENCODING);
        decryptedObj = JSON.parse(decryptedStr);
    }
    catch (e) {
        throw new Error('Incorrect password');
    }
    return decryptedObj;
}
exports.decryptWithKey = decryptWithKey;
/**
 * Receives an exported CryptoKey string and creates a key.
 *
 * @param keyString - The key string to import.
 * @returns A CryptoKey.
 */
async function importKey(keyString) {
    const key = await window.crypto.subtle.importKey(EXPORT_FORMAT, JSON.parse(keyString), DERIVED_KEY_FORMAT, true, ['encrypt', 'decrypt']);
    return key;
}
exports.importKey = importKey;
/**
 * Receives an exported CryptoKey string, creates a key,
 * and decrypts cipher text with the reconstructed key.
 *
 * @param key - The CryptoKey to export.
 * @returns A key string.
 */
async function exportKey(key) {
    const exportedKey = await window.crypto.subtle.exportKey(EXPORT_FORMAT, key);
    return JSON.stringify(exportedKey);
}
exports.exportKey = exportKey;
/**
 * Generate a CryptoKey from a password and random salt.
 *
 * @param password - The password to use to generate key.
 * @param salt - The salt string to use in key derivation.
 * @param exportable - Should the derived key be exportable.
 * @returns A CryptoKey for encryption and decryption.
 */
async function keyFromPassword(password, salt, exportable = false) {
    const passBuffer = Buffer.from(password, STRING_ENCODING);
    const saltBuffer = Buffer.from(salt, 'base64');
    const key = await global.crypto.subtle.importKey('raw', passBuffer, { name: 'PBKDF2' }, false, ['deriveBits', 'deriveKey']);
    const derivedKey = await global.crypto.subtle.deriveKey({
        name: 'PBKDF2',
        salt: saltBuffer,
        iterations: 10000,
        hash: 'SHA-256',
    }, key, { name: DERIVED_KEY_FORMAT, length: 256 }, exportable, ['encrypt', 'decrypt']);
    return derivedKey;
}
exports.keyFromPassword = keyFromPassword;
/**
 * Converts a hex string into a buffer.
 *
 * @param str - Hex encoded string.
 * @returns The string ecoded as a byte array.
 */
function serializeBufferFromStorage(str) {
    const stripStr = str.slice(0, 2) === '0x' ? str.slice(2) : str;
    const buf = new Uint8Array(stripStr.length / 2);
    for (let i = 0; i < stripStr.length; i += 2) {
        const seg = stripStr.substr(i, 2);
        buf[i / 2] = parseInt(seg, 16);
    }
    return buf;
}
exports.serializeBufferFromStorage = serializeBufferFromStorage;
/**
 * Converts a buffer into a hex string ready for storage.
 *
 * @param buffer - Buffer to serialize.
 * @returns A hex encoded string.
 */
function serializeBufferForStorage(buffer) {
    let result = '0x';
    buffer.forEach((value) => {
        result += unprefixedHex(value);
    });
    return result;
}
exports.serializeBufferForStorage = serializeBufferForStorage;
/**
 * Converts a number into hex value, and ensures proper leading 0
 * for single characters strings.
 *
 * @param num - The number to convert to string.
 * @returns An unprefixed hex string.
 */
function unprefixedHex(num) {
    let hex = num.toString(16);
    while (hex.length < 2) {
        hex = `0${hex}`;
    }
    return hex;
}
/**
 * Generates a random string for use as a salt in CryptoKey generation.
 *
 * @param byteCount - The number of bytes to generate.
 * @returns A randomly generated string.
 */
function generateSalt(byteCount = 32) {
    const view = new Uint8Array(byteCount);
    global.crypto.getRandomValues(view);
    // Uint8Array is a fixed length array and thus does not have methods like pop, etc
    // so TypeScript complains about casting it to an array. Array.from() works here for
    // getting the proper type, but it results in a functional difference. In order to
    // cast, you have to first cast view to unknown then cast the unknown value to number[]
    // TypeScript ftw: double opt in to write potentially type-mismatched code.
    const b64encoded = btoa(String.fromCharCode.apply(null, view));
    return b64encoded;
}
exports.generateSalt = generateSalt;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/browser-passworder",file:"node_modules\\@metamask\\browser-passworder\\dist\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-hd-keyring\\index.js", {"@ethereumjs/util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ethereumjs\\util\\dist\\index.js","@metamask/eth-sig-util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-sig-util\\dist\\index.js","@metamask/scure-bip39":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\scure-bip39\\dist\\index.js","@metamask/scure-bip39/dist/wordlists/english":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\scure-bip39\\dist\\wordlists\\english.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereum-cryptography/hdkey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\ethereum-cryptography\\hdkey.js","ethereum-cryptography/keccak":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\ethereum-cryptography\\keccak.js","ethereum-cryptography/utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\ethereum-cryptography\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-hd-keyring%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const { HDKey } = require('ethereum-cryptography/hdkey');
const { keccak256 } = require('ethereum-cryptography/keccak');
const { bytesToHex } = require('ethereum-cryptography/utils');
const {
  stripHexPrefix,
  privateToPublic,
  publicToAddress,
  ecsign,
  arrToBufArr,
  bufferToHex,
} = require('@ethereumjs/util');
const bip39 = require('@metamask/scure-bip39');
const { wordlist } = require('@metamask/scure-bip39/dist/wordlists/english');
const {
  concatSig,
  decrypt,
  getEncryptionPublicKey,
  normalize,
  personalSign,
  signTypedData,
  SignTypedDataVersion,
} = require('@metamask/eth-sig-util');

// Options:
const hdPathString = `m/44'/60'/0'/0`;
const type = 'HD Key Tree';

class HdKeyring {
  /* PUBLIC METHODS */
  constructor(opts = {}) {
    this.type = type;
    this._wallets = [];
    this.deserialize(opts);
  }

  generateRandomMnemonic() {
    this._initFromMnemonic(bip39.generateMnemonic(wordlist));
  }

  _uint8ArrayToString(mnemonic) {
    const recoveredIndices = Array.from(
      new Uint16Array(new Uint8Array(mnemonic).buffer),
    );
    return recoveredIndices.map((i) => wordlist[i]).join(' ');
  }

  _stringToUint8Array(mnemonic) {
    const indices = mnemonic.split(' ').map((word) => wordlist.indexOf(word));
    return new Uint8Array(new Uint16Array(indices).buffer);
  }

  _mnemonicToUint8Array(mnemonic) {
    let mnemonicData = mnemonic;
    // when encrypted/decrypted, buffers get cast into js object with a property type set to buffer
    if (mnemonic && mnemonic.type && mnemonic.type === 'Buffer') {
      mnemonicData = mnemonic.data;
    }

    if (
      // this block is for backwards compatibility with vaults that were previously stored as buffers, number arrays or plain text strings
      typeof mnemonicData === 'string' ||
      Buffer.isBuffer(mnemonicData) ||
      Array.isArray(mnemonicData)
    ) {
      let mnemonicAsString = mnemonicData;
      if (Array.isArray(mnemonicData)) {
        mnemonicAsString = Buffer.from(mnemonicData).toString();
      } else if (Buffer.isBuffer(mnemonicData)) {
        mnemonicAsString = mnemonicData.toString();
      }
      return this._stringToUint8Array(mnemonicAsString);
    } else if (
      mnemonicData instanceof Object &&
      !(mnemonicData instanceof Uint8Array)
    ) {
      // when encrypted/decrypted the Uint8Array becomes a js object we need to cast back to a Uint8Array
      return Uint8Array.from(Object.values(mnemonicData));
    }
    return mnemonicData;
  }

  serialize() {
    const mnemonicAsString = this._uint8ArrayToString(this.mnemonic);
    const uint8ArrayMnemonic = new TextEncoder('utf-8').encode(
      mnemonicAsString,
    );

    return Promise.resolve({
      mnemonic: Array.from(uint8ArrayMnemonic),
      numberOfAccounts: this._wallets.length,
      hdPath: this.hdPath,
    });
  }

  deserialize(opts = {}) {
    if (opts.numberOfAccounts && !opts.mnemonic) {
      throw new Error(
        'Eth-Hd-Keyring: Deserialize method cannot be called with an opts value for numberOfAccounts and no menmonic',
      );
    }

    if (this.root) {
      throw new Error(
        'Eth-Hd-Keyring: Secret recovery phrase already provided',
      );
    }
    this.opts = opts;
    this._wallets = [];
    this.mnemonic = null;
    this.root = null;
    this.hdPath = opts.hdPath || hdPathString;

    if (opts.mnemonic) {
      this._initFromMnemonic(opts.mnemonic);
    }

    if (opts.numberOfAccounts) {
      return this.addAccounts(opts.numberOfAccounts);
    }

    return Promise.resolve([]);
  }

  addAccounts(numberOfAccounts = 1) {
    if (!this.root) {
      throw new Error('Eth-Hd-Keyring: No secret recovery phrase provided');
    }

    const oldLen = this._wallets.length;
    const newWallets = [];
    for (let i = oldLen; i < numberOfAccounts + oldLen; i++) {
      const wallet = this.root.deriveChild(i);
      newWallets.push(wallet);
      this._wallets.push(wallet);
    }
    const hexWallets = newWallets.map((w) => {
      return this._addressfromPublicKey(w.publicKey);
    });
    return Promise.resolve(hexWallets);
  }

  getAccounts() {
    return this._wallets.map((w) => this._addressfromPublicKey(w.publicKey));
  }

  /* BASE KEYRING METHODS */

  // returns an address specific to an app
  async getAppKeyAddress(address, origin) {
    if (!origin || typeof origin !== 'string') {
      throw new Error(`'origin' must be a non-empty string`);
    }
    const wallet = this._getWalletForAccount(address, {
      withAppKeyOrigin: origin,
    });
    const appKeyAddress = normalize(
      publicToAddress(wallet.publicKey).toString('hex'),
    );

    return appKeyAddress;
  }

  // exportAccount should return a hex-encoded private key:
  async exportAccount(address, opts = {}) {
    const wallet = this._getWalletForAccount(address, opts);
    return bytesToHex(wallet.privateKey);
  }

  // tx is an instance of the ethereumjs-transaction class.
  async signTransaction(address, tx, opts = {}) {
    const privKey = this._getPrivateKeyFor(address, opts);
    const signedTx = tx.sign(privKey);
    // Newer versions of Ethereumjs-tx are immutable and return a new tx object
    return signedTx === undefined ? tx : signedTx;
  }

  // For eth_sign, we need to sign arbitrary data:
  async signMessage(address, data, opts = {}) {
    const message = stripHexPrefix(data);
    const privKey = this._getPrivateKeyFor(address, opts);
    const msgSig = ecsign(Buffer.from(message, 'hex'), privKey);
    const rawMsgSig = concatSig(msgSig.v, msgSig.r, msgSig.s);
    return rawMsgSig;
  }

  // For personal_sign, we need to prefix the message:
  async signPersonalMessage(address, msgHex, opts = {}) {
    const privKey = this._getPrivateKeyFor(address, opts);
    const privateKey = Buffer.from(privKey, 'hex');
    const sig = personalSign({ privateKey, data: msgHex });
    return sig;
  }

  // For eth_decryptMessage:
  async decryptMessage(withAccount, encryptedData) {
    const wallet = this._getWalletForAccount(withAccount);
    const { privateKey: privateKeyAsUint8Array } = wallet;
    const privateKeyAsHex = Buffer.from(privateKeyAsUint8Array).toString('hex');
    const sig = decrypt({ privateKey: privateKeyAsHex, encryptedData });
    return sig;
  }

  // personal_signTypedData, signs data along with the schema
  async signTypedData(
    withAccount,
    typedData,
    opts = { version: SignTypedDataVersion.V1 },
  ) {
    // Treat invalid versions as "V1"
    const version = Object.keys(SignTypedDataVersion).includes(opts.version)
      ? opts.version
      : SignTypedDataVersion.V1;

    const privateKey = this._getPrivateKeyFor(withAccount, opts);
    return signTypedData({ privateKey, data: typedData, version });
  }

  removeAccount(account) {
    const address = normalize(account);
    if (
      !this._wallets
        .map(({ publicKey }) => this._addressfromPublicKey(publicKey))
        .includes(address)
    ) {
      throw new Error(`Address ${address} not found in this keyring`);
    }

    this._wallets = this._wallets.filter(
      ({ publicKey }) => this._addressfromPublicKey(publicKey) !== address,
    );
  }

  // get public key for nacl
  async getEncryptionPublicKey(withAccount, opts = {}) {
    const privKey = this._getPrivateKeyFor(withAccount, opts);
    const publicKey = getEncryptionPublicKey(privKey);
    return publicKey;
  }

  _getPrivateKeyFor(address, opts = {}) {
    if (!address) {
      throw new Error('Must specify address.');
    }
    const wallet = this._getWalletForAccount(address, opts);
    return wallet.privateKey;
  }

  _getWalletForAccount(account, opts = {}) {
    const address = normalize(account);
    let wallet = this._wallets.find(({ publicKey }) => {
      return this._addressfromPublicKey(publicKey) === address;
    });
    if (!wallet) {
      throw new Error('HD Keyring - Unable to find matching address.');
    }

    if (opts.withAppKeyOrigin) {
      const { privateKey } = wallet;
      const appKeyOriginBuffer = Buffer.from(opts.withAppKeyOrigin, 'utf8');
      const appKeyBuffer = Buffer.concat([privateKey, appKeyOriginBuffer]);
      const appKeyPrivateKey = arrToBufArr(keccak256(appKeyBuffer, 256));
      const appKeyPublicKey = privateToPublic(appKeyPrivateKey);
      wallet = { privateKey: appKeyPrivateKey, publicKey: appKeyPublicKey };
    }

    return wallet;
  }

  /* PRIVATE / UTILITY METHODS */

  /**
   * Sets appropriate properties for the keyring based on the given
   * BIP39-compliant mnemonic.
   *
   * @param {string|Array<number>|Buffer} mnemonic - A seed phrase represented
   * as a string, an array of UTF-8 bytes, or a Buffer. Mnemonic input
   * passed as type buffer or array of UTF-8 bytes must be NFKD normalized.
   */
  _initFromMnemonic(mnemonic) {
    if (this.root) {
      throw new Error(
        'Eth-Hd-Keyring: Secret recovery phrase already provided',
      );
    }

    this.mnemonic = this._mnemonicToUint8Array(mnemonic);

    // validate before initializing
    const isValid = bip39.validateMnemonic(this.mnemonic, wordlist);
    if (!isValid) {
      throw new Error(
        'Eth-Hd-Keyring: Invalid secret recovery phrase provided',
      );
    }

    // eslint-disable-next-line node/no-sync
    const seed = bip39.mnemonicToSeedSync(this.mnemonic, wordlist);
    this.hdWallet = HDKey.fromMasterSeed(seed);
    this.root = this.hdWallet.derive(this.hdPath);
  }

  // small helper function to convert publicKey in Uint8Array form to a publicAddress as a hex
  _addressfromPublicKey(publicKey) {
    return bufferToHex(
      publicToAddress(Buffer.from(publicKey), true),
    ).toLowerCase();
  }
}

HdKeyring.type = type;
module.exports = HdKeyring;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-hd-keyring",file:"node_modules\\@metamask\\eth-hd-keyring\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-infura-middleware.js", {"./fetch-config-from-req":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\fetch-config-from-req.js","./logging-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\logging-utils.js","eth-rpc-errors":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\eth-rpc-errors\\dist\\index.js","json-rpc-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-rpc-engine\\dist\\index.js","node-fetch":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\node-fetch\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cdist%5Ccreate-infura-middleware.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createInfuraMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const node_fetch_1 = __importDefault(require("node-fetch"));
const fetch_config_from_req_1 = require("./fetch-config-from-req");
const logging_utils_1 = require("./logging-utils");
const log = (0, logging_utils_1.createModuleLogger)(logging_utils_1.projectLogger, 'create-infura-middleware');
const RETRIABLE_ERRORS = [
    // ignore server overload errors
    'Gateway timeout',
    'ETIMEDOUT',
    'ECONNRESET',
    // ignore server sent html error pages
    // or truncated json responses
    'SyntaxError',
];
/**
 * Builds [`json-rpc-engine`](https://github.com/MetaMask/json-rpc-engine)-compatible middleware designed
 * for interfacing with Infura's JSON-RPC endpoints.
 *
 * @param opts - The options.
 * @param opts.network - A network that Infura supports; plugs into
 * `https://${network}.infura.io` (default: 'mainnet').
 * @param opts.maxAttempts - The number of times a request to Infura should be
 * retried in the case of failure (default: 5).
 * @param opts.source - A descriptor for the entity making the request; tracked
 * by Infura for analytics purposes.
 * @param opts.projectId - The Infura project id.
 * @param opts.headers - Extra headers that will be used to make the request.
 * @returns The `json-rpc-engine`-compatible middleware.
 */
function createInfuraMiddleware({ network = 'mainnet', maxAttempts = 5, source, projectId, headers = {}, }) {
    // validate options
    if (!projectId || typeof projectId !== 'string') {
        throw new Error(`Invalid value for 'projectId': "${projectId}"`);
    }
    if (!headers || typeof headers !== 'object') {
        throw new Error(`Invalid value for 'headers': "${headers}"`);
    }
    if (!maxAttempts) {
        throw new Error(`Invalid value for 'maxAttempts': "${maxAttempts}" (${typeof maxAttempts})`);
    }
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res) => {
        // retry MAX_ATTEMPTS times, if error matches filter
        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
            try {
                // attempt request
                log('Attempting request to Infura. network = %o, projectId = %s, headers = %o, req = %o', network, projectId, headers, req);
                await performFetch(network, projectId, headers, req, res, source);
                // request was successful
                break;
            }
            catch (err) {
                // an error was caught while performing the request
                // if not retriable, resolve with the encountered error
                if (!isRetriableError(err)) {
                    // abort with error
                    log('Non-retriable request error encountered. req = %o, res = %o, error = %o', req, res, err);
                    throw err;
                }
                // if no more attempts remaining, throw an error
                const remainingAttempts = maxAttempts - attempt;
                if (!remainingAttempts) {
                    log('Retriable request error encountered, but exceeded max attempts. req = %o, res = %o, error = %o', req, res, err);
                    const errMsg = `InfuraProvider - cannot complete request. All retries exhausted.\nOriginal Error:\n${err.toString()}\n\n`;
                    const retriesExhaustedErr = new Error(errMsg);
                    throw retriesExhaustedErr;
                }
                // otherwise, ignore error and retry again after timeout
                log('Retriable request error encountered. req = %o, res = %o, error = %o', req, res, err);
                log('Waiting 1 second to try again...');
                await timeout(1000);
            }
        }
        // request was handled correctly, end
    });
}
exports.createInfuraMiddleware = createInfuraMiddleware;
/**
 * Makes a request to Infura, updating the given response object if the response
 * has a "successful" status code or throwing an error otherwise.
 *
 * @param network - A network that Infura supports; plugs into
 * `https://${network}.infura.io`.
 * @param projectId - The Infura project id.
 * @param extraHeaders - Extra headers that will be used to make the request.
 * @param req - The original request object obtained via the middleware stack.
 * @param res - The original response object obtained via the middleware stack.
 * @param source - A descriptor for the entity making the request;
 * tracked by Infura for analytics purposes.
 * @throws an error with a detailed message if the HTTP status code is anywhere
 * outside 2xx, and especially if it is 405, 429, 503, or 504.
 */
async function performFetch(network, projectId, extraHeaders, req, res, source) {
    const { fetchUrl, fetchParams } = (0, fetch_config_from_req_1.fetchConfigFromReq)({
        network,
        projectId,
        extraHeaders,
        req,
        source,
    });
    const response = await (0, node_fetch_1.default)(fetchUrl, fetchParams);
    const rawData = await response.text();
    // handle errors
    if (!response.ok) {
        switch (response.status) {
            case 405:
                throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound();
            case 429:
                throw createRatelimitError();
            case 503:
            case 504:
                throw createTimeoutError();
            default:
                throw createInternalError(rawData);
        }
    }
    // special case for now
    if (req.method === 'eth_getBlockByNumber' && rawData === 'Not Found') {
        res.result = null;
        return;
    }
    // parse JSON
    const data = JSON.parse(rawData);
    // finally return result
    res.result = data.result;
    res.error = data.error;
}
/**
 * Builds a JSON-RPC 2.0 internal error object describing a rate-limiting
 * error.
 *
 * @returns The error object.
 */
function createRatelimitError() {
    const msg = `Request is being rate limited.`;
    return createInternalError(msg);
}
/**
 * Builds a JSON-RPC 2.0 internal error object describing a timeout error.
 *
 * @returns The error object.
 */
function createTimeoutError() {
    let msg = `Gateway timeout. The request took too long to process. `;
    msg += `This can happen when querying logs over too wide a block range.`;
    return createInternalError(msg);
}
/**
 * Builds a JSON-RPC 2.0 internal error object.
 *
 * @param msg - The message.
 * @returns The error object.
 */
function createInternalError(msg) {
    return eth_rpc_errors_1.ethErrors.rpc.internal(msg);
}
/**
 * Upon making a request, we may get an error that is temporary and
 * intermittent. In these cases we can attempt the request again with the
 * assumption that the error is unlikely to occur again. Here we determine if we
 * have received such an error.
 *
 * @param err - The error object.
 * @returns Whether the request that produced the error can be retried.
 */
function isRetriableError(err) {
    const errMessage = err.toString();
    return RETRIABLE_ERRORS.some((phrase) => errMessage.includes(phrase));
}
/**
 * A utility function that promisifies `setTimeout`.
 *
 * @param length - The number of milliseconds to wait.
 * @returns A promise that resolves after the given time has elapsed.
 */
function timeout(length) {
    return new Promise((resolve) => {
        setTimeout(resolve, length);
    });
}
//# sourceMappingURL=create-infura-middleware.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura",file:"node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-infura-middleware.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-provider.js", {"./create-infura-middleware":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-infura-middleware.js","eth-json-rpc-middleware":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\index.js","json-rpc-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cdist%5Ccreate-provider.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createProvider = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const eth_json_rpc_middleware_1 = require("eth-json-rpc-middleware");
const create_infura_middleware_1 = require("./create-infura-middleware");
/**
 * Creates a provider (as defined in
 * [`eth-json-rpc-middleware`](https://github.com/MetaMask/eth-json-rpc-middleware)
 * which is preloaded with middleware specialized for interfacing with Infura
 * JSON-RPC endpoints.
 *
 * @param opts - Options to {@link createInfuraMiddleware}.
 * @returns The provider as returned by `providerFromEngine` (a part of
 * [`eth-json-rpc-middleware`](https://github.com/MetaMask/eth-json-rpc-middleware)).
 */
function createProvider(opts) {
    const engine = new json_rpc_engine_1.JsonRpcEngine();
    engine.push((0, create_infura_middleware_1.createInfuraMiddleware)(opts));
    return (0, eth_json_rpc_middleware_1.providerFromEngine)(engine);
}
exports.createProvider = createProvider;
//# sourceMappingURL=create-provider.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura",file:"node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-provider.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\fetch-config-from-req.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cdist%5Cfetch-config-from-req.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchConfigFromReq = void 0;
/**
 * Determines the arguments to feed into `fetch` in order to make a request to
 * Infura.
 *
 * @param options - The options.
 * @param options.network - A network that Infura supports; plugs into
 * `https://${network}.infura.io`.
 * @param options.projectId - The Infura project id.
 * @param options.extraHeaders - Extra headers that will be used to make the
 * request.
 * @param options.req - The original request object obtained via the
 * middleware stack.
 * @param options.source - A descriptor for the entity making the request;
 * tracked by Infura for analytics purposes.
 * @returns An object containing the URL and a bag of options, both of which
 * will be passed to `fetch`.
 */
function fetchConfigFromReq({ network, projectId, extraHeaders = {}, req, source, }) {
    const requestOrigin = req.origin || 'internal';
    const headers = Object.assign({}, extraHeaders, {
        Accept: 'application/json',
        'Content-Type': 'application/json',
    });
    if (source) {
        headers['Infura-Source'] = `${source}/${requestOrigin}`;
    }
    return {
        fetchUrl: `https://${network}.infura.io/v3/${projectId}`,
        fetchParams: {
            method: 'POST',
            headers,
            body: JSON.stringify(normalizeReq(req)),
        },
    };
}
exports.fetchConfigFromReq = fetchConfigFromReq;
/**
 * Strips out extra keys from a request object that could be rejected by strict
 * nodes like parity.
 *
 * @param req - The original request object obtained via the middleware stack.
 * @returns An object that describes a JSON-RPC request.
 */
function normalizeReq(req) {
    return {
        id: req.id,
        jsonrpc: req.jsonrpc,
        method: req.method,
        params: req.params,
    };
}
//# sourceMappingURL=fetch-config-from-req.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura",file:"node_modules\\@metamask\\eth-json-rpc-infura\\dist\\fetch-config-from-req.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\index.js", {"./create-infura-middleware":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-infura-middleware.js","./create-provider":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-provider.js","./fetch-config-from-req":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\fetch-config-from-req.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./create-infura-middleware"), exports);
__exportStar(require("./fetch-config-from-req"), exports);
__exportStar(require("./create-provider"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura",file:"node_modules\\@metamask\\eth-json-rpc-infura\\dist\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\logging-utils.js", {"@metamask/utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cdist%5Clogging-utils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createModuleLogger = exports.projectLogger = void 0;
const utils_1 = require("@metamask/utils");
Object.defineProperty(exports, "createModuleLogger", { enumerable: true, get: function () { return utils_1.createModuleLogger; } });
exports.projectLogger = (0, utils_1.createProjectLogger)('eth-json-rpc-infura');
//# sourceMappingURL=logging-utils.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura",file:"node_modules\\@metamask\\eth-json-rpc-infura\\dist\\logging-utils.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js", {"superstruct":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cassert.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertExhaustive = exports.assertStruct = exports.assert = exports.AssertionError = void 0;
const superstruct_1 = require("superstruct");
/**
 * Type guard for determining whether the given value is an error object with a
 * `message` property, such as an instance of Error.
 *
 * @param error - The object to check.
 * @returns True or false, depending on the result.
 */
function isErrorWithMessage(error) {
    return typeof error === 'object' && error !== null && 'message' in error;
}
/**
 * Check if a value is a constructor, i.e., a function that can be called with
 * the `new` keyword.
 *
 * @param fn - The value to check.
 * @returns `true` if the value is a constructor, or `false` otherwise.
 */
function isConstructable(fn) {
    var _a, _b;
    /* istanbul ignore next */
    return Boolean(typeof ((_b = (_a = fn === null || fn === void 0 ? void 0 : fn.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) === 'string');
}
/**
 * Get the error message from an unknown error object. If the error object has
 * a `message` property, that property is returned. Otherwise, the stringified
 * error object is returned.
 *
 * @param error - The error object to get the message from.
 * @returns The error message.
 */
function getErrorMessage(error) {
    const message = isErrorWithMessage(error) ? error.message : String(error);
    // If the error ends with a period, remove it, as we'll add our own period.
    if (message.endsWith('.')) {
        return message.slice(0, -1);
    }
    return message;
}
/**
 * Initialise an {@link AssertionErrorConstructor} error.
 *
 * @param ErrorWrapper - The error class to use.
 * @param message - The error message.
 * @returns The error object.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getError(ErrorWrapper, message) {
    if (isConstructable(ErrorWrapper)) {
        return new ErrorWrapper({
            message,
        });
    }
    return ErrorWrapper({
        message,
    });
}
/**
 * The default error class that is thrown if an assertion fails.
 */
class AssertionError extends Error {
    constructor(options) {
        super(options.message);
        this.code = 'ERR_ASSERTION';
    }
}
exports.AssertionError = AssertionError;
/**
 * Same as Node.js assert.
 * If the value is falsy, throws an error, does nothing otherwise.
 *
 * @throws {@link AssertionError} If value is falsy.
 * @param value - The test that should be truthy to pass.
 * @param message - Message to be passed to {@link AssertionError} or an
 * {@link Error} instance to throw.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}. If a custom error class is provided for
 * the `message` argument, this argument is ignored.
 */
function assert(value, message = 'Assertion failed.', 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper = AssertionError) {
    if (!value) {
        if (message instanceof Error) {
            throw message;
        }
        throw getError(ErrorWrapper, message);
    }
}
exports.assert = assert;
/**
 * Assert a value against a Superstruct struct.
 *
 * @param value - The value to validate.
 * @param struct - The struct to validate against.
 * @param errorPrefix - A prefix to add to the error message. Defaults to
 * "Assertion failed".
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the value is not valid.
 */
function assertStruct(value, struct, errorPrefix = 'Assertion failed', 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper = AssertionError) {
    try {
        (0, superstruct_1.assert)(value, struct);
    }
    catch (error) {
        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessage(error)}.`);
    }
}
exports.assertStruct = assertStruct;
/**
 * Use in the default case of a switch that you want to be fully exhaustive.
 * Using this function forces the compiler to enforce exhaustivity during
 * compile-time.
 *
 * @example
 * ```
 * const number = 1;
 * switch (number) {
 *   case 0:
 *     ...
 *   case 1:
 *     ...
 *   default:
 *     assertExhaustive(snapPrefix);
 * }
 * ```
 * @param _object - The object on which the switch is being operated.
 */
function assertExhaustive(_object) {
    throw new Error('Invalid branch reached. Should be detected during compilation.');
}
exports.assertExhaustive = assertExhaustive;
//# sourceMappingURL=assert.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\base64.js", {"./assert":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","superstruct":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cbase64.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.base64 = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
/**
 * Ensure that a provided string-based struct is valid base64.
 *
 * @param struct - The string based struct.
 * @param options - Optional options to specialize base64 validation. See {@link Base64Options} documentation.
 * @returns A superstruct validating base64.
 */
const base64 = (struct, options = {}) => {
    var _a, _b;
    const paddingRequired = (_a = options.paddingRequired) !== null && _a !== void 0 ? _a : false;
    const characterSet = (_b = options.characterSet) !== null && _b !== void 0 ? _b : 'base64';
    let letters;
    if (characterSet === 'base64') {
        letters = String.raw `[A-Za-z0-9+\/]`;
    }
    else {
        (0, assert_1.assert)(characterSet === 'base64url');
        letters = String.raw `[-_A-Za-z0-9]`;
    }
    let re;
    if (paddingRequired) {
        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, 'u');
    }
    else {
        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, 'u');
    }
    return (0, superstruct_1.pattern)(struct, re);
};
exports.base64 = base64;
//# sourceMappingURL=base64.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\base64.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\bytes.js", {"./assert":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","./hex":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\hex.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cbytes.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDataView = exports.concatBytes = exports.valueToBytes = exports.stringToBytes = exports.numberToBytes = exports.signedBigIntToBytes = exports.bigIntToBytes = exports.hexToBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToSignedBigInt = exports.bytesToBigInt = exports.bytesToHex = exports.assertIsBytes = exports.isBytes = void 0;
const assert_1 = require("./assert");
const hex_1 = require("./hex");
// '0'.charCodeAt(0) === 48
const HEX_MINIMUM_NUMBER_CHARACTER = 48;
// '9'.charCodeAt(0) === 57
const HEX_MAXIMUM_NUMBER_CHARACTER = 58;
const HEX_CHARACTER_OFFSET = 87;
/**
 * Memoized function that returns an array to be used as a lookup table for
 * converting bytes to hexadecimal values.
 *
 * The array is created lazily and then cached for future use. The benefit of
 * this approach is that the performance of converting bytes to hex is much
 * better than if we were to call `toString(16)` on each byte.
 *
 * The downside is that the array is created once and then never garbage
 * collected. This is not a problem in practice because the array is only 256
 * elements long.
 *
 * @returns A function that returns the lookup table.
 */
function getPrecomputedHexValuesBuilder() {
    // To avoid issues with tree shaking, we need to use a function to return the
    // array. This is because the array is only used in the `bytesToHex` function
    // and if we were to use a global variable, the array might be removed by the
    // tree shaker.
    const lookupTable = [];
    return () => {
        if (lookupTable.length === 0) {
            for (let i = 0; i < 256; i++) {
                lookupTable.push(i.toString(16).padStart(2, '0'));
            }
        }
        return lookupTable;
    };
}
/**
 * Function implementation of the {@link getPrecomputedHexValuesBuilder}
 * function.
 */
const getPrecomputedHexValues = getPrecomputedHexValuesBuilder();
/**
 * Check if a value is a `Uint8Array`.
 *
 * @param value - The value to check.
 * @returns Whether the value is a `Uint8Array`.
 */
function isBytes(value) {
    return value instanceof Uint8Array;
}
exports.isBytes = isBytes;
/**
 * Assert that a value is a `Uint8Array`.
 *
 * @param value - The value to check.
 * @throws If the value is not a `Uint8Array`.
 */
function assertIsBytes(value) {
    (0, assert_1.assert)(isBytes(value), 'Value must be a Uint8Array.');
}
exports.assertIsBytes = assertIsBytes;
/**
 * Convert a `Uint8Array` to a hexadecimal string.
 *
 * @param bytes - The bytes to convert to a hexadecimal string.
 * @returns The hexadecimal string.
 */
function bytesToHex(bytes) {
    assertIsBytes(bytes);
    if (bytes.length === 0) {
        return '0x';
    }
    const lookupTable = getPrecomputedHexValues();
    const hexadecimal = new Array(bytes.length);
    for (let i = 0; i < bytes.length; i++) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        hexadecimal[i] = lookupTable[bytes[i]];
    }
    return (0, hex_1.add0x)(hexadecimal.join(''));
}
exports.bytesToHex = bytesToHex;
/**
 * Convert a `Uint8Array` to a `bigint`.
 *
 * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.
 * To convert a two's complement encoded `Uint8Array` to a `bigint`, use
 * {@link bytesToSignedBigInt}.
 *
 * @param bytes - The bytes to convert to a `bigint`.
 * @returns The `bigint`.
 */
function bytesToBigInt(bytes) {
    assertIsBytes(bytes);
    const hexadecimal = bytesToHex(bytes);
    return BigInt(hexadecimal);
}
exports.bytesToBigInt = bytesToBigInt;
/**
 * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are
 * encoded in two's complement.
 *
 * To convert a `Uint8Array` to an unsigned `bigint` instead, use
 * {@link bytesToBigInt}.
 *
 * @see https://en.wikipedia.org/wiki/Two%27s_complement
 * @param bytes - The bytes to convert to a signed `bigint`.
 * @returns The signed `bigint`.
 */
function bytesToSignedBigInt(bytes) {
    assertIsBytes(bytes);
    let value = BigInt(0);
    for (const byte of bytes) {
        // eslint-disable-next-line no-bitwise
        value = (value << BigInt(8)) + BigInt(byte);
    }
    return BigInt.asIntN(bytes.length * 8, value);
}
exports.bytesToSignedBigInt = bytesToSignedBigInt;
/**
 * Convert a `Uint8Array` to a `number`.
 *
 * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.
 *
 * @param bytes - The bytes to convert to a number.
 * @returns The number.
 * @throws If the resulting number is not a safe integer.
 */
function bytesToNumber(bytes) {
    assertIsBytes(bytes);
    const bigint = bytesToBigInt(bytes);
    (0, assert_1.assert)(bigint <= BigInt(Number.MAX_SAFE_INTEGER), 'Number is not a safe integer. Use `bytesToBigInt` instead.');
    return Number(bigint);
}
exports.bytesToNumber = bytesToNumber;
/**
 * Convert a UTF-8 encoded `Uint8Array` to a `string`.
 *
 * @param bytes - The bytes to convert to a string.
 * @returns The string.
 */
function bytesToString(bytes) {
    assertIsBytes(bytes);
    return new TextDecoder().decode(bytes);
}
exports.bytesToString = bytesToString;
/**
 * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be
 * prefixed with `0x`. It accepts even and odd length strings.
 *
 * If the value is "0x", an empty `Uint8Array` is returned.
 *
 * @param value - The hexadecimal string to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function hexToBytes(value) {
    var _a;
    // "0x" is often used as empty byte array.
    if (((_a = value === null || value === void 0 ? void 0 : value.toLowerCase) === null || _a === void 0 ? void 0 : _a.call(value)) === '0x') {
        return new Uint8Array();
    }
    (0, hex_1.assertIsHexString)(value);
    // Remove the `0x` prefix if it exists, and pad the string to have an even
    // number of characters.
    const strippedValue = (0, hex_1.remove0x)(value).toLowerCase();
    const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;
    const bytes = new Uint8Array(normalizedValue.length / 2);
    for (let i = 0; i < bytes.length; i++) {
        // While this is not the prettiest way to convert a hexadecimal string to a
        // `Uint8Array`, it is a lot faster than using `parseInt` to convert each
        // character.
        const c1 = normalizedValue.charCodeAt(i * 2);
        const c2 = normalizedValue.charCodeAt(i * 2 + 1);
        const n1 = c1 -
            (c1 < HEX_MAXIMUM_NUMBER_CHARACTER
                ? HEX_MINIMUM_NUMBER_CHARACTER
                : HEX_CHARACTER_OFFSET);
        const n2 = c2 -
            (c2 < HEX_MAXIMUM_NUMBER_CHARACTER
                ? HEX_MINIMUM_NUMBER_CHARACTER
                : HEX_CHARACTER_OFFSET);
        bytes[i] = n1 * 16 + n2;
    }
    return bytes;
}
exports.hexToBytes = hexToBytes;
/**
 * Convert a `bigint` to a `Uint8Array`.
 *
 * This assumes that the `bigint` is an unsigned integer. To convert a signed
 * `bigint` instead, use {@link signedBigIntToBytes}.
 *
 * @param value - The bigint to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function bigIntToBytes(value) {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(value >= BigInt(0), 'Value must be a non-negative bigint.');
    const hexadecimal = value.toString(16);
    return hexToBytes(hexadecimal);
}
exports.bigIntToBytes = bigIntToBytes;
/**
 * Check if a `bigint` fits in a certain number of bytes.
 *
 * @param value - The `bigint` to check.
 * @param bytes - The number of bytes.
 * @returns Whether the `bigint` fits in the number of bytes.
 */
function bigIntFits(value, bytes) {
    (0, assert_1.assert)(bytes > 0);
    /* eslint-disable no-bitwise */
    const mask = value >> BigInt(31);
    return !(((~value & mask) + (value & ~mask)) >> BigInt(bytes * 8 + ~0));
    /* eslint-enable no-bitwise */
}
/**
 * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement
 * encoding to represent negative numbers.
 *
 * To convert an unsigned `bigint` to a `Uint8Array` instead, use
 * {@link bigIntToBytes}.
 *
 * @see https://en.wikipedia.org/wiki/Two%27s_complement
 * @param value - The number to convert to bytes.
 * @param byteLength - The length of the resulting `Uint8Array`. If the number
 * is larger than the maximum value that can be represented by the given length,
 * an error is thrown.
 * @returns The bytes as `Uint8Array`.
 */
function signedBigIntToBytes(value, byteLength) {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(typeof byteLength === 'number', 'Byte length must be a number.');
    (0, assert_1.assert)(byteLength > 0, 'Byte length must be greater than 0.');
    (0, assert_1.assert)(bigIntFits(value, byteLength), 'Byte length is too small to represent the given value.');
    // ESLint doesn't like mutating function parameters, so to avoid having to
    // disable the rule, we create a new variable.
    let numberValue = value;
    const bytes = new Uint8Array(byteLength);
    for (let i = 0; i < bytes.length; i++) {
        bytes[i] = Number(BigInt.asUintN(8, numberValue));
        // eslint-disable-next-line no-bitwise
        numberValue >>= BigInt(8);
    }
    return bytes.reverse();
}
exports.signedBigIntToBytes = signedBigIntToBytes;
/**
 * Convert a `number` to a `Uint8Array`.
 *
 * @param value - The number to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 * @throws If the number is not a safe integer.
 */
function numberToBytes(value) {
    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');
    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToBytes` instead.');
    const hexadecimal = value.toString(16);
    return hexToBytes(hexadecimal);
}
exports.numberToBytes = numberToBytes;
/**
 * Convert a `string` to a UTF-8 encoded `Uint8Array`.
 *
 * @param value - The string to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function stringToBytes(value) {
    (0, assert_1.assert)(typeof value === 'string', 'Value must be a string.');
    return new TextEncoder().encode(value);
}
exports.stringToBytes = stringToBytes;
/**
 * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,
 * a `bigint`, a `number`, or a `string`.
 *
 * This will attempt to guess the type of the value based on its type and
 * contents. For more control over the conversion, use the more specific
 * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.
 *
 * If the value is a `string`, and it is prefixed with `0x`, it will be
 * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a
 * UTF-8 string. To convert a hexadecimal string to bytes without interpreting
 * it as a UTF-8 string, use {@link hexToBytes} instead.
 *
 * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed
 * `bigint` to bytes, use {@link signedBigIntToBytes} instead.
 *
 * If the value is a `Uint8Array`, it will be returned as-is.
 *
 * @param value - The value to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function valueToBytes(value) {
    if (typeof value === 'bigint') {
        return bigIntToBytes(value);
    }
    if (typeof value === 'number') {
        return numberToBytes(value);
    }
    if (typeof value === 'string') {
        if (value.startsWith('0x')) {
            return hexToBytes(value);
        }
        return stringToBytes(value);
    }
    if (isBytes(value)) {
        return value;
    }
    throw new TypeError(`Unsupported value type: "${typeof value}".`);
}
exports.valueToBytes = valueToBytes;
/**
 * Concatenate multiple byte-like values into a single `Uint8Array`. The values
 * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses
 * {@link valueToBytes} under the hood to convert each value to bytes. Refer to
 * the documentation of that function for more information.
 *
 * @param values - The values to concatenate.
 * @returns The concatenated bytes as `Uint8Array`.
 */
function concatBytes(values) {
    const normalizedValues = new Array(values.length);
    let byteLength = 0;
    for (let i = 0; i < values.length; i++) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const value = valueToBytes(values[i]);
        normalizedValues[i] = value;
        byteLength += value.length;
    }
    const bytes = new Uint8Array(byteLength);
    for (let i = 0, offset = 0; i < normalizedValues.length; i++) {
        // While we could simply spread the values into an array and use
        // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.
        bytes.set(normalizedValues[i], offset);
        offset += normalizedValues[i].length;
    }
    return bytes;
}
exports.concatBytes = concatBytes;
/**
 * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience
 * function that avoids having to create a {@link DataView} manually, which
 * requires passing the `byteOffset` and `byteLength` parameters every time.
 *
 * Not passing the `byteOffset` and `byteLength` parameters can result in
 * unexpected behavior when the {@link Uint8Array} is a view of a larger
 * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.
 *
 * This function also supports Node.js {@link Buffer}s.
 *
 * @example
 * ```typescript
 * const bytes = new Uint8Array([1, 2, 3]);
 *
 * // This is equivalent to:
 * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
 * const dataView = createDataView(bytes);
 * ```
 * @param bytes - The bytes to create the {@link DataView} from.
 * @returns The {@link DataView}.
 */
function createDataView(bytes) {
    // To maintain compatibility with Node.js, we need to check if the bytes are
    // a Buffer. If so, we need to slice the buffer to get the underlying
    // ArrayBuffer.
    // eslint-disable-next-line no-restricted-globals
    if (typeof Buffer !== 'undefined' && bytes instanceof Buffer) {
        const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
        return new DataView(buffer);
    }
    return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
}
exports.createDataView = createDataView;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\bytes.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\checksum.js", {"./base64":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\base64.js","superstruct":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cchecksum.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChecksumStruct = void 0;
const superstruct_1 = require("superstruct");
const base64_1 = require("./base64");
exports.ChecksumStruct = (0, superstruct_1.size)((0, base64_1.base64)((0, superstruct_1.string)(), { paddingRequired: true }), 44, 44);
//# sourceMappingURL=checksum.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\checksum.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\coercers.js", {"./assert":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","./bytes":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\bytes.js","./hex":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\hex.js","superstruct":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Ccoercers.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHex = exports.createBytes = exports.createBigInt = exports.createNumber = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
const bytes_1 = require("./bytes");
const hex_1 = require("./hex");
const NumberLikeStruct = (0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.bigint)(), (0, superstruct_1.string)(), hex_1.StrictHexStruct]);
const NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);
const BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);
const BytesLikeStruct = (0, superstruct_1.union)([hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array)]);
const BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([hex_1.StrictHexStruct]), bytes_1.hexToBytes);
const HexCoercer = (0, superstruct_1.coerce)(hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);
/**
 * Create a number from a number-like value.
 *
 * - If the value is a number, it is returned as-is.
 * - If the value is a `bigint`, it is converted to a number.
 * - If the value is a string, it is interpreted as a decimal number.
 * - If the value is a hex string (i.e., it starts with "0x"), it is
 * interpreted as a hexadecimal number.
 *
 * This validates that the value is a number-like value, and that the resulting
 * number is not `NaN` or `Infinity`.
 *
 * @example
 * ```typescript
 * const value = createNumber('0x010203');
 * console.log(value); // 66051
 *
 * const otherValue = createNumber(123n);
 * console.log(otherValue); // 123
 * ```
 * @param value - The value to create the number from.
 * @returns The created number.
 * @throws If the value is not a number-like value, or if the resulting number
 * is `NaN` or `Infinity`.
 */
function createNumber(value) {
    try {
        const result = (0, superstruct_1.create)(value, NumberCoercer);
        (0, assert_1.assert)(Number.isFinite(result), `Expected a number-like value, got "${value}".`);
        return result;
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a number-like value, got "${value}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createNumber = createNumber;
/**
 * Create a `bigint` from a number-like value.
 *
 * - If the value is a number, it is converted to a `bigint`.
 * - If the value is a `bigint`, it is returned as-is.
 * - If the value is a string, it is interpreted as a decimal number and
 * converted to a `bigint`.
 * - If the value is a hex string (i.e., it starts with "0x"), it is
 * interpreted as a hexadecimal number and converted to a `bigint`.
 *
 * @example
 * ```typescript
 * const value = createBigInt('0x010203');
 * console.log(value); // 16909060n
 *
 * const otherValue = createBigInt(123);
 * console.log(otherValue); // 123n
 * ```
 * @param value - The value to create the bigint from.
 * @returns The created bigint.
 * @throws If the value is not a number-like value.
 */
function createBigInt(value) {
    try {
        // The `BigInt` constructor throws if the value is not a number-like value.
        // There is no need to validate the value manually.
        return (0, superstruct_1.create)(value, BigIntCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a number-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createBigInt = createBigInt;
/**
 * Create a byte array from a bytes-like value.
 *
 * - If the value is a byte array, it is returned as-is.
 * - If the value is a hex string (i.e., it starts with "0x"), it is interpreted
 * as a hexadecimal number and converted to a byte array.
 *
 * @example
 * ```typescript
 * const value = createBytes('0x010203');
 * console.log(value); // Uint8Array [ 1, 2, 3 ]
 *
 * const otherValue = createBytes('0x010203');
 * console.log(otherValue); // Uint8Array [ 1, 2, 3 ]
 * ```
 * @param value - The value to create the byte array from.
 * @returns The created byte array.
 * @throws If the value is not a bytes-like value.
 */
function createBytes(value) {
    if (typeof value === 'string' && value.toLowerCase() === '0x') {
        return new Uint8Array();
    }
    try {
        return (0, superstruct_1.create)(value, BytesCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createBytes = createBytes;
/**
 * Create a hexadecimal string from a bytes-like value.
 *
 * - If the value is a hex string (i.e., it starts with "0x"), it is returned
 * as-is.
 * - If the value is a `Uint8Array`, it is converted to a hex string.
 *
 * @example
 * ```typescript
 * const value = createHex(new Uint8Array([1, 2, 3]));
 * console.log(value); // '0x010203'
 *
 * const otherValue = createHex('0x010203');
 * console.log(otherValue); // '0x010203'
 * ```
 * @param value - The value to create the hex string from.
 * @returns The created hex string.
 * @throws If the value is not a bytes-like value.
 */
function createHex(value) {
    if ((value instanceof Uint8Array && value.length === 0) ||
        (typeof value === 'string' && value.toLowerCase() === '0x')) {
        return '0x';
    }
    try {
        return (0, superstruct_1.create)(value, HexCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createHex = createHex;
//# sourceMappingURL=coercers.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\coercers.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\collections.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Ccollections.js
      return function (require, module, exports) {
"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FrozenMap_map, _FrozenSet_set;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrozenSet = exports.FrozenMap = void 0;
/**
 * A {@link ReadonlyMap} that cannot be modified after instantiation.
 * The implementation uses an inner map hidden via a private field, and the
 * immutability guarantee relies on it being impossible to get a reference
 * to this map.
 */
class FrozenMap {
    constructor(entries) {
        _FrozenMap_map.set(this, void 0);
        __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries), "f");
        Object.freeze(this);
    }
    get size() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").size;
    }
    [(_FrozenMap_map = new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f")[Symbol.iterator]();
    }
    entries() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").entries();
    }
    forEach(callbackfn, thisArg) {
        // We have to wrap the specified callback in order to prevent it from
        // receiving a reference to the inner map.
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").forEach((value, key, _map) => callbackfn.call(thisArg, value, key, this));
    }
    get(key) {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").get(key);
    }
    has(key) {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").has(key);
    }
    keys() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").keys();
    }
    values() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").values();
    }
    toString() {
        return `FrozenMap(${this.size}) {${this.size > 0
            ? ` ${[...this.entries()]
                .map(([key, value]) => `${String(key)} => ${String(value)}`)
                .join(', ')} `
            : ''}}`;
    }
}
exports.FrozenMap = FrozenMap;
/**
 * A {@link ReadonlySet} that cannot be modified after instantiation.
 * The implementation uses an inner set hidden via a private field, and the
 * immutability guarantee relies on it being impossible to get a reference
 * to this set.
 */
class FrozenSet {
    constructor(values) {
        _FrozenSet_set.set(this, void 0);
        __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), "f");
        Object.freeze(this);
    }
    get size() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").size;
    }
    [(_FrozenSet_set = new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f")[Symbol.iterator]();
    }
    entries() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").entries();
    }
    forEach(callbackfn, thisArg) {
        // We have to wrap the specified callback in order to prevent it from
        // receiving a reference to the inner set.
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").forEach((value, value2, _set) => callbackfn.call(thisArg, value, value2, this));
    }
    has(value) {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").has(value);
    }
    keys() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").keys();
    }
    values() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").values();
    }
    toString() {
        return `FrozenSet(${this.size}) {${this.size > 0
            ? ` ${[...this.values()].map((member) => String(member)).join(', ')} `
            : ''}}`;
    }
}
exports.FrozenSet = FrozenSet;
Object.freeze(FrozenMap);
Object.freeze(FrozenMap.prototype);
Object.freeze(FrozenSet);
Object.freeze(FrozenSet.prototype);
//# sourceMappingURL=collections.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\collections.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\hex.js", {"./assert":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","superstruct":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Chex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.remove0x = exports.add0x = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isStrictHexString = exports.isHexString = exports.StrictHexStruct = exports.HexStruct = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
exports.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:0x)?[0-9a-f]+$/iu);
exports.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]+$/iu);
/**
 * Check if a string is a valid hex string.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid hex string.
 */
function isHexString(value) {
    return (0, superstruct_1.is)(value, exports.HexStruct);
}
exports.isHexString = isHexString;
/**
 * Strictly check if a string is a valid hex string. A valid hex string must
 * start with the "0x"-prefix.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid hex string.
 */
function isStrictHexString(value) {
    return (0, superstruct_1.is)(value, exports.StrictHexStruct);
}
exports.isStrictHexString = isStrictHexString;
/**
 * Assert that a value is a valid hex string.
 *
 * @param value - The value to check.
 * @throws If the value is not a valid hex string.
 */
function assertIsHexString(value) {
    (0, assert_1.assert)(isHexString(value), 'Value must be a hexadecimal string.');
}
exports.assertIsHexString = assertIsHexString;
/**
 * Assert that a value is a valid hex string. A valid hex string must start with
 * the "0x"-prefix.
 *
 * @param value - The value to check.
 * @throws If the value is not a valid hex string.
 */
function assertIsStrictHexString(value) {
    (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with "0x".');
}
exports.assertIsStrictHexString = assertIsStrictHexString;
/**
 * Add the `0x`-prefix to a hexadecimal string. If the string already has the
 * prefix, it is returned as-is.
 *
 * @param hexadecimal - The hexadecimal string to add the prefix to.
 * @returns The prefixed hexadecimal string.
 */
function add0x(hexadecimal) {
    if (hexadecimal.startsWith('0x')) {
        return hexadecimal;
    }
    if (hexadecimal.startsWith('0X')) {
        return `0x${hexadecimal.substring(2)}`;
    }
    return `0x${hexadecimal}`;
}
exports.add0x = add0x;
/**
 * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have
 * the prefix, it is returned as-is.
 *
 * @param hexadecimal - The hexadecimal string to remove the prefix from.
 * @returns The un-prefixed hexadecimal string.
 */
function remove0x(hexadecimal) {
    if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {
        return hexadecimal.substring(2);
    }
    return hexadecimal;
}
exports.remove0x = remove0x;
//# sourceMappingURL=hex.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\hex.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\index.js", {"./assert":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","./base64":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\base64.js","./bytes":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\bytes.js","./checksum":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\checksum.js","./coercers":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\coercers.js","./collections":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\collections.js","./hex":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\hex.js","./json":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\json.js","./logging":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\logging.js","./misc":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\misc.js","./number":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\number.js","./opaque":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\opaque.js","./time":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\time.js","./versions":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\versions.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./assert"), exports);
__exportStar(require("./base64"), exports);
__exportStar(require("./bytes"), exports);
__exportStar(require("./checksum"), exports);
__exportStar(require("./coercers"), exports);
__exportStar(require("./collections"), exports);
__exportStar(require("./hex"), exports);
__exportStar(require("./json"), exports);
__exportStar(require("./logging"), exports);
__exportStar(require("./misc"), exports);
__exportStar(require("./number"), exports);
__exportStar(require("./opaque"), exports);
__exportStar(require("./time"), exports);
__exportStar(require("./versions"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\json.js", {"./assert":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","./misc":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\misc.js","superstruct":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cjson.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateJsonAndGetSize = exports.getJsonRpcIdValidator = exports.assertIsJsonRpcError = exports.isJsonRpcError = exports.assertIsJsonRpcFailure = exports.isJsonRpcFailure = exports.assertIsJsonRpcSuccess = exports.isJsonRpcSuccess = exports.assertIsJsonRpcResponse = exports.isJsonRpcResponse = exports.assertIsPendingJsonRpcResponse = exports.isPendingJsonRpcResponse = exports.JsonRpcResponseStruct = exports.JsonRpcFailureStruct = exports.JsonRpcSuccessStruct = exports.PendingJsonRpcResponseStruct = exports.assertIsJsonRpcRequest = exports.isJsonRpcRequest = exports.assertIsJsonRpcNotification = exports.isJsonRpcNotification = exports.JsonRpcNotificationStruct = exports.JsonRpcRequestStruct = exports.JsonRpcParamsStruct = exports.JsonRpcErrorStruct = exports.JsonRpcIdStruct = exports.JsonRpcVersionStruct = exports.jsonrpc2 = exports.isValidJson = exports.JsonStruct = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
const misc_1 = require("./misc");
exports.JsonStruct = (0, superstruct_1.define)('Json', (value) => {
    const [isValid] = validateJsonAndGetSize(value, true);
    if (!isValid) {
        return 'Expected a valid JSON-serializable value';
    }
    return true;
});
/**
 * Check if the given value is a valid {@link Json} value, i.e., a value that is
 * serializable to JSON.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid {@link Json} value.
 */
function isValidJson(value) {
    return (0, superstruct_1.is)(value, exports.JsonStruct);
}
exports.isValidJson = isValidJson;
/**
 * The string '2.0'.
 */
exports.jsonrpc2 = '2.0';
exports.JsonRpcVersionStruct = (0, superstruct_1.literal)(exports.jsonrpc2);
exports.JsonRpcIdStruct = (0, superstruct_1.nullable)((0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.string)()]));
exports.JsonRpcErrorStruct = (0, superstruct_1.object)({
    code: (0, superstruct_1.integer)(),
    message: (0, superstruct_1.string)(),
    data: (0, superstruct_1.optional)(exports.JsonStruct),
    stack: (0, superstruct_1.optional)((0, superstruct_1.string)()),
});
exports.JsonRpcParamsStruct = (0, superstruct_1.optional)((0, superstruct_1.union)([(0, superstruct_1.record)((0, superstruct_1.string)(), exports.JsonStruct), (0, superstruct_1.array)(exports.JsonStruct)]));
exports.JsonRpcRequestStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    method: (0, superstruct_1.string)(),
    params: exports.JsonRpcParamsStruct,
});
exports.JsonRpcNotificationStruct = (0, superstruct_1.omit)(exports.JsonRpcRequestStruct, ['id']);
/**
 * Check if the given value is a valid {@link JsonRpcNotification} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcNotification}
 * object.
 */
function isJsonRpcNotification(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcNotificationStruct);
}
exports.isJsonRpcNotification = isJsonRpcNotification;
/**
 * Assert that the given value is a valid {@link JsonRpcNotification} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcNotification} object.
 */
function assertIsJsonRpcNotification(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcNotificationStruct, 'Invalid JSON-RPC notification', ErrorWrapper);
}
exports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;
/**
 * Check if the given value is a valid {@link JsonRpcRequest} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcRequest} object.
 */
function isJsonRpcRequest(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcRequestStruct);
}
exports.isJsonRpcRequest = isJsonRpcRequest;
/**
 * Assert that the given value is a valid {@link JsonRpcRequest} object.
 *
 * @param value - The JSON-RPC request or notification to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcRequest} object.
 */
function assertIsJsonRpcRequest(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcRequestStruct, 'Invalid JSON-RPC request', ErrorWrapper);
}
exports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;
exports.PendingJsonRpcResponseStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    result: (0, superstruct_1.optional)((0, superstruct_1.unknown)()),
    error: (0, superstruct_1.optional)(exports.JsonRpcErrorStruct),
});
exports.JsonRpcSuccessStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    result: exports.JsonStruct,
});
exports.JsonRpcFailureStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    error: exports.JsonRpcErrorStruct,
});
exports.JsonRpcResponseStruct = (0, superstruct_1.union)([
    exports.JsonRpcSuccessStruct,
    exports.JsonRpcFailureStruct,
]);
/**
 * Type guard to check whether specified JSON-RPC response is a
 * {@link PendingJsonRpcResponse}.
 *
 * @param response - The JSON-RPC response to check.
 * @returns Whether the specified JSON-RPC response is pending.
 */
function isPendingJsonRpcResponse(response) {
    return (0, superstruct_1.is)(response, exports.PendingJsonRpcResponseStruct);
}
exports.isPendingJsonRpcResponse = isPendingJsonRpcResponse;
/**
 * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.
 *
 * @param response - The JSON-RPC response to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link PendingJsonRpcResponse}
 * object.
 */
function assertIsPendingJsonRpcResponse(response, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(response, exports.PendingJsonRpcResponseStruct, 'Invalid pending JSON-RPC response', ErrorWrapper);
}
exports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;
/**
 * Type guard to check if a value is a {@link JsonRpcResponse}.
 *
 * @param response - The object to check.
 * @returns Whether the object is a JsonRpcResponse.
 */
function isJsonRpcResponse(response) {
    return (0, superstruct_1.is)(response, exports.JsonRpcResponseStruct);
}
exports.isJsonRpcResponse = isJsonRpcResponse;
/**
 * Assert that the given value is a valid {@link JsonRpcResponse} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcResponse} object.
 */
function assertIsJsonRpcResponse(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcResponseStruct, 'Invalid JSON-RPC response', ErrorWrapper);
}
exports.assertIsJsonRpcResponse = assertIsJsonRpcResponse;
/**
 * Check if the given value is a valid {@link JsonRpcSuccess} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.
 */
function isJsonRpcSuccess(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcSuccessStruct);
}
exports.isJsonRpcSuccess = isJsonRpcSuccess;
/**
 * Assert that the given value is a valid {@link JsonRpcSuccess} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcSuccess} object.
 */
function assertIsJsonRpcSuccess(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcSuccessStruct, 'Invalid JSON-RPC success response', ErrorWrapper);
}
exports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;
/**
 * Check if the given value is a valid {@link JsonRpcFailure} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcFailure} object.
 */
function isJsonRpcFailure(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcFailureStruct);
}
exports.isJsonRpcFailure = isJsonRpcFailure;
/**
 * Assert that the given value is a valid {@link JsonRpcFailure} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcFailure} object.
 */
function assertIsJsonRpcFailure(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcFailureStruct, 'Invalid JSON-RPC failure response', ErrorWrapper);
}
exports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;
/**
 * Check if the given value is a valid {@link JsonRpcError} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcError} object.
 */
function isJsonRpcError(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcErrorStruct);
}
exports.isJsonRpcError = isJsonRpcError;
/**
 * Assert that the given value is a valid {@link JsonRpcError} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcError} object.
 */
function assertIsJsonRpcError(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcErrorStruct, 'Invalid JSON-RPC error', ErrorWrapper);
}
exports.assertIsJsonRpcError = assertIsJsonRpcError;
/**
 * Gets a function for validating JSON-RPC request / response `id` values.
 *
 * By manipulating the options of this factory, you can control the behavior
 * of the resulting validator for some edge cases. This is useful because e.g.
 * `null` should sometimes but not always be permitted.
 *
 * Note that the empty string (`''`) is always permitted by the JSON-RPC
 * specification, but that kind of sucks and you may want to forbid it in some
 * instances anyway.
 *
 * For more details, see the
 * [JSON-RPC Specification](https://www.jsonrpc.org/specification).
 *
 * @param options - An options object.
 * @param options.permitEmptyString - Whether the empty string (i.e. `''`)
 * should be treated as a valid ID. Default: `true`
 * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)
 * should be treated as valid IDs. Default: `false`
 * @param options.permitNull - Whether `null` should be treated as a valid ID.
 * Default: `true`
 * @returns The JSON-RPC ID validator function.
 */
function getJsonRpcIdValidator(options) {
    const { permitEmptyString, permitFractions, permitNull } = Object.assign({ permitEmptyString: true, permitFractions: false, permitNull: true }, options);
    /**
     * Type guard for {@link JsonRpcId}.
     *
     * @param id - The JSON-RPC ID value to check.
     * @returns Whether the given ID is valid per the options given to the
     * factory.
     */
    const isValidJsonRpcId = (id) => {
        return Boolean((typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||
            (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||
            (permitNull && id === null));
    };
    return isValidJsonRpcId;
}
exports.getJsonRpcIdValidator = getJsonRpcIdValidator;
/**
 * Checks whether a value is JSON serializable and counts the total number
 * of bytes needed to store the serialized version of the value.
 *
 * @param jsObject - Potential JSON serializable object.
 * @param skipSizingProcess - Skip JSON size calculation (default: false).
 * @returns Tuple [isValid, plainTextSizeInBytes] containing a boolean that signals whether
 * the value was serializable and a number of bytes that it will use when serialized to JSON.
 */
function validateJsonAndGetSize(jsObject, skipSizingProcess = false) {
    const seenObjects = new Set();
    /**
     * Checks whether a value is JSON serializable and counts the total number
     * of bytes needed to store the serialized version of the value.
     *
     * This function assumes the encoding of the JSON is done in UTF-8.
     *
     * @param value - Potential JSON serializable value.
     * @param skipSizing - Skip JSON size calculation (default: false).
     * @returns Tuple [isValid, plainTextSizeInBytes] containing a boolean that signals whether
     * the value was serializable and a number of bytes that it will use when serialized to JSON.
     */
    function getJsonSerializableInfo(value, skipSizing) {
        if (value === undefined) {
            return [false, 0];
        }
        else if (value === null) {
            // Return already specified constant size for null (special object)
            return [true, skipSizing ? 0 : misc_1.JsonSize.Null];
        }
        // Check and calculate sizes for basic (and some special) types
        const typeOfValue = typeof value;
        try {
            if (typeOfValue === 'function') {
                return [false, 0];
            }
            else if (typeOfValue === 'string' || value instanceof String) {
                return [
                    true,
                    skipSizing
                        ? 0
                        : (0, misc_1.calculateStringSize)(value) + misc_1.JsonSize.Quote * 2,
                ];
            }
            else if (typeOfValue === 'boolean' || value instanceof Boolean) {
                if (skipSizing) {
                    return [true, 0];
                }
                // eslint-disable-next-line eqeqeq
                return [true, value == true ? misc_1.JsonSize.True : misc_1.JsonSize.False];
            }
            else if (typeOfValue === 'number' || value instanceof Number) {
                if (skipSizing) {
                    return [true, 0];
                }
                return [true, (0, misc_1.calculateNumberSize)(value)];
            }
            else if (value instanceof Date) {
                if (skipSizing) {
                    return [true, 0];
                }
                return [
                    true,
                    // Note: Invalid dates will serialize to null
                    isNaN(value.getDate())
                        ? misc_1.JsonSize.Null
                        : misc_1.JsonSize.Date + misc_1.JsonSize.Quote * 2,
                ];
            }
        }
        catch (_) {
            return [false, 0];
        }
        // If object is not plain and cannot be serialized properly,
        // stop here and return false for serialization
        if (!(0, misc_1.isPlainObject)(value) && !Array.isArray(value)) {
            return [false, 0];
        }
        // Circular object detection (handling)
        // Check if the same object already exists
        if (seenObjects.has(value)) {
            return [false, 0];
        }
        // Add new object to the seen objects set
        // Only the plain objects should be added (Primitive types are skipped)
        seenObjects.add(value);
        // Continue object decomposition
        try {
            return [
                true,
                Object.entries(value).reduce((sum, [key, nestedValue], idx, arr) => {
                    // Recursively process next nested object or primitive type
                    // eslint-disable-next-line prefer-const
                    let [valid, size] = getJsonSerializableInfo(nestedValue, skipSizing);
                    if (!valid) {
                        throw new Error('JSON validation did not pass. Validation process stopped.');
                    }
                    // Circular object detection
                    // Once a child node is visited and processed remove it from the set.
                    // This will prevent false positives with the same adjacent objects.
                    seenObjects.delete(value);
                    if (skipSizing) {
                        return 0;
                    }
                    // Objects will have be serialized with "key": value,
                    // therefore we include the key in the calculation here
                    const keySize = Array.isArray(value)
                        ? 0
                        : key.length + misc_1.JsonSize.Comma + misc_1.JsonSize.Colon * 2;
                    const separator = idx < arr.length - 1 ? misc_1.JsonSize.Comma : 0;
                    return sum + keySize + size + separator;
                }, 
                // Starts at 2 because the serialized JSON string data (plain text)
                // will minimally contain {}/[]
                skipSizing ? 0 : misc_1.JsonSize.Wrapper * 2),
            ];
        }
        catch (_) {
            return [false, 0];
        }
    }
    return getJsonSerializableInfo(jsObject, skipSizingProcess);
}
exports.validateJsonAndGetSize = validateJsonAndGetSize;
//# sourceMappingURL=json.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\json.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\logging.js", {"debug":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\debug\\src\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Clogging.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createModuleLogger = exports.createProjectLogger = void 0;
const debug_1 = __importDefault(require("debug"));
const globalLogger = (0, debug_1.default)('metamask');
/**
 * Creates a logger via the `debug` library whose log messages will be tagged
 * using the name of your project. By default, such messages will be
 * suppressed, but you can reveal them by setting the `DEBUG` environment
 * variable to `metamask:<projectName>`. You can also set this variable to
 * `metamask:*` if you want to see log messages from all MetaMask projects that
 * are also using this function to create their loggers.
 *
 * @param projectName - The name of your project. This should be the name of
 * your NPM package if you're developing one.
 * @returns An instance of `debug`.
 */
function createProjectLogger(projectName) {
    return globalLogger.extend(projectName);
}
exports.createProjectLogger = createProjectLogger;
/**
 * Creates a logger via the `debug` library which is derived from the logger for
 * the whole project whose log messages will be tagged using the name of your
 * module. By default, such messages will be suppressed, but you can reveal them
 * by setting the `DEBUG` environment variable to
 * `metamask:<projectName>:<moduleName>`. You can also set this variable to
 * `metamask:<projectName>:*` if you want to see log messages from the project,
 * or `metamask:*` if you want to see log messages from all MetaMask projects.
 *
 * @param projectLogger - The logger created via {@link createProjectLogger}.
 * @param moduleName - The name of your module. You could use the name of the
 * file where you're using this logger or some other name.
 * @returns An instance of `debug`.
 */
function createModuleLogger(projectLogger, moduleName) {
    return projectLogger.extend(moduleName);
}
exports.createModuleLogger = createModuleLogger;
//# sourceMappingURL=logging.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\logging.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\misc.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cmisc.js
      return function (require, module, exports) {
"use strict";
//
// Types
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateNumberSize = exports.calculateStringSize = exports.isASCII = exports.isPlainObject = exports.ESCAPE_CHARACTERS_REGEXP = exports.JsonSize = exports.hasProperty = exports.isObject = exports.isNullOrUndefined = exports.isNonEmptyArray = void 0;
//
// Type Guards
//
/**
 * A {@link NonEmptyArray} type guard.
 *
 * @template Element - The non-empty array member type.
 * @param value - The value to check.
 * @returns Whether the value is a non-empty array.
 */
function isNonEmptyArray(value) {
    return Array.isArray(value) && value.length > 0;
}
exports.isNonEmptyArray = isNonEmptyArray;
/**
 * Type guard for "nullishness".
 *
 * @param value - Any value.
 * @returns `true` if the value is null or undefined, `false` otherwise.
 */
function isNullOrUndefined(value) {
    return value === null || value === undefined;
}
exports.isNullOrUndefined = isNullOrUndefined;
/**
 * A type guard for {@link RuntimeObject}.
 *
 * @param value - The value to check.
 * @returns Whether the specified value has a runtime type of `object` and is
 * neither `null` nor an `Array`.
 */
function isObject(value) {
    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
}
exports.isObject = isObject;
//
// Other utility functions
//
/**
 * A type guard for ensuring an object has a property.
 *
 * @param objectToCheck - The object to check.
 * @param name - The property name to check for.
 * @returns Whether the specified object has an own property with the specified
 * name, regardless of whether it is enumerable or not.
 */
const hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);
exports.hasProperty = hasProperty;
/**
 * Predefined sizes (in Bytes) of specific parts of JSON structure.
 */
var JsonSize;
(function (JsonSize) {
    JsonSize[JsonSize["Null"] = 4] = "Null";
    JsonSize[JsonSize["Comma"] = 1] = "Comma";
    JsonSize[JsonSize["Wrapper"] = 1] = "Wrapper";
    JsonSize[JsonSize["True"] = 4] = "True";
    JsonSize[JsonSize["False"] = 5] = "False";
    JsonSize[JsonSize["Quote"] = 1] = "Quote";
    JsonSize[JsonSize["Colon"] = 1] = "Colon";
    // eslint-disable-next-line @typescript-eslint/no-shadow
    JsonSize[JsonSize["Date"] = 24] = "Date";
})(JsonSize = exports.JsonSize || (exports.JsonSize = {}));
/**
 * Regular expression with pattern matching for (special) escaped characters.
 */
exports.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
/**
 * Check if the value is plain object.
 *
 * @param value - Value to be checked.
 * @returns True if an object is the plain JavaScript object,
 * false if the object is not plain (e.g. function).
 */
function isPlainObject(value) {
    if (typeof value !== 'object' || value === null) {
        return false;
    }
    try {
        let proto = value;
        while (Object.getPrototypeOf(proto) !== null) {
            proto = Object.getPrototypeOf(proto);
        }
        return Object.getPrototypeOf(value) === proto;
    }
    catch (_) {
        return false;
    }
}
exports.isPlainObject = isPlainObject;
/**
 * Check if character is ASCII.
 *
 * @param character - Character.
 * @returns True if a character code is ASCII, false if not.
 */
function isASCII(character) {
    return character.charCodeAt(0) <= 127;
}
exports.isASCII = isASCII;
/**
 * Calculate string size.
 *
 * @param value - String value to calculate size.
 * @returns Number of bytes used to store whole string value.
 */
function calculateStringSize(value) {
    var _a;
    const size = value.split('').reduce((total, character) => {
        if (isASCII(character)) {
            return total + 1;
        }
        return total + 2;
    }, 0);
    // Also detect characters that need backslash escape
    return size + ((_a = value.match(exports.ESCAPE_CHARACTERS_REGEXP)) !== null && _a !== void 0 ? _a : []).length;
}
exports.calculateStringSize = calculateStringSize;
/**
 * Calculate size of a number ofter JSON serialization.
 *
 * @param value - Number value to calculate size.
 * @returns Number of bytes used to store whole number in JSON.
 */
function calculateNumberSize(value) {
    return value.toString().length;
}
exports.calculateNumberSize = calculateNumberSize;
//# sourceMappingURL=misc.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\misc.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\number.js", {"./assert":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","./hex":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\hex.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cnumber.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hexToBigInt = exports.hexToNumber = exports.bigIntToHex = exports.numberToHex = void 0;
const assert_1 = require("./assert");
const hex_1 = require("./hex");
/**
 * Convert a number to a hexadecimal string. This verifies that the number is a
 * non-negative safe integer.
 *
 * To convert a `bigint` to a hexadecimal string instead, use
 * {@link bigIntToHex}.
 *
 * @example
 * ```typescript
 * numberToHex(0); // '0x0'
 * numberToHex(1); // '0x1'
 * numberToHex(16); // '0x10'
 * ```
 * @param value - The number to convert to a hexadecimal string.
 * @returns The hexadecimal string, with the "0x"-prefix.
 * @throws If the number is not a non-negative safe integer.
 */
const numberToHex = (value) => {
    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');
    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToHex` instead.');
    return (0, hex_1.add0x)(value.toString(16));
};
exports.numberToHex = numberToHex;
/**
 * Convert a `bigint` to a hexadecimal string. This verifies that the `bigint`
 * is a non-negative integer.
 *
 * To convert a number to a hexadecimal string instead, use {@link numberToHex}.
 *
 * @example
 * ```typescript
 * bigIntToHex(0n); // '0x0'
 * bigIntToHex(1n); // '0x1'
 * bigIntToHex(16n); // '0x10'
 * ```
 * @param value - The `bigint` to convert to a hexadecimal string.
 * @returns The hexadecimal string, with the "0x"-prefix.
 * @throws If the `bigint` is not a non-negative integer.
 */
const bigIntToHex = (value) => {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative bigint.');
    return (0, hex_1.add0x)(value.toString(16));
};
exports.bigIntToHex = bigIntToHex;
/**
 * Convert a hexadecimal string to a number. This verifies that the string is a
 * valid hex string, and that the resulting number is a safe integer. Both
 * "0x"-prefixed and unprefixed strings are supported.
 *
 * To convert a hexadecimal string to a `bigint` instead, use
 * {@link hexToBigInt}.
 *
 * @example
 * ```typescript
 * hexToNumber('0x0'); // 0
 * hexToNumber('0x1'); // 1
 * hexToNumber('0x10'); // 16
 * ```
 * @param value - The hexadecimal string to convert to a number.
 * @returns The number.
 * @throws If the value is not a valid hexadecimal string, or if the resulting
 * number is not a safe integer.
 */
const hexToNumber = (value) => {
    (0, hex_1.assertIsHexString)(value);
    // `parseInt` accepts values without the "0x"-prefix, whereas `Number` does
    // not. Using this is slightly faster than `Number(add0x(value))`.
    const numberValue = parseInt(value, 16);
    (0, assert_1.assert)(Number.isSafeInteger(numberValue), 'Value is not a safe integer. Use `hexToBigInt` instead.');
    return numberValue;
};
exports.hexToNumber = hexToNumber;
/**
 * Convert a hexadecimal string to a `bigint`. This verifies that the string is
 * a valid hex string. Both "0x"-prefixed and unprefixed strings are supported.
 *
 * To convert a hexadecimal string to a number instead, use {@link hexToNumber}.
 *
 * @example
 * ```typescript
 * hexToBigInt('0x0'); // 0n
 * hexToBigInt('0x1'); // 1n
 * hexToBigInt('0x10'); // 16n
 * ```
 * @param value - The hexadecimal string to convert to a `bigint`.
 * @returns The `bigint`.
 * @throws If the value is not a valid hexadecimal string.
 */
const hexToBigInt = (value) => {
    (0, hex_1.assertIsHexString)(value);
    // The `BigInt` constructor requires the "0x"-prefix to parse a hex string.
    return BigInt((0, hex_1.add0x)(value));
};
exports.hexToBigInt = hexToBigInt;
//# sourceMappingURL=number.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\number.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\opaque.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Copaque.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=opaque.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\opaque.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\time.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Ctime.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.timeSince = exports.inMilliseconds = exports.Duration = void 0;
/**
 * Common duration constants, in milliseconds.
 */
var Duration;
(function (Duration) {
    /**
     * A millisecond.
     */
    Duration[Duration["Millisecond"] = 1] = "Millisecond";
    /**
     * A second, in milliseconds.
     */
    Duration[Duration["Second"] = 1000] = "Second";
    /**
     * A minute, in milliseconds.
     */
    Duration[Duration["Minute"] = 60000] = "Minute";
    /**
     * An hour, in milliseconds.
     */
    Duration[Duration["Hour"] = 3600000] = "Hour";
    /**
     * A day, in milliseconds.
     */
    Duration[Duration["Day"] = 86400000] = "Day";
    /**
     * A week, in milliseconds.
     */
    Duration[Duration["Week"] = 604800000] = "Week";
    /**
     * A year, in milliseconds.
     */
    Duration[Duration["Year"] = 31536000000] = "Year";
})(Duration = exports.Duration || (exports.Duration = {}));
const isNonNegativeInteger = (number) => Number.isInteger(number) && number >= 0;
const assertIsNonNegativeInteger = (number, name) => {
    if (!isNonNegativeInteger(number)) {
        throw new Error(`"${name}" must be a non-negative integer. Received: "${number}".`);
    }
};
/**
 * Calculates the millisecond value of the specified number of units of time.
 *
 * @param count - The number of units of time.
 * @param duration - The unit of time to count.
 * @returns The count multiplied by the specified duration.
 */
function inMilliseconds(count, duration) {
    assertIsNonNegativeInteger(count, 'count');
    return count * duration;
}
exports.inMilliseconds = inMilliseconds;
/**
 * Gets the milliseconds since a particular Unix epoch timestamp.
 *
 * @param timestamp - A Unix millisecond timestamp.
 * @returns The number of milliseconds elapsed since the specified timestamp.
 */
function timeSince(timestamp) {
    assertIsNonNegativeInteger(timestamp, 'timestamp');
    return Date.now() - timestamp;
}
exports.timeSince = timeSince;
//# sourceMappingURL=time.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\time.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\versions.js", {"./assert":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","semver":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\index.js","superstruct":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cversions.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.satisfiesVersionRange = exports.gtRange = exports.gtVersion = exports.assertIsSemVerRange = exports.assertIsSemVerVersion = exports.isValidSemVerRange = exports.isValidSemVerVersion = exports.VersionRangeStruct = exports.VersionStruct = void 0;
const semver_1 = require("semver");
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
/**
 * A struct for validating a version string.
 */
exports.VersionStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version', (value) => {
    if ((0, semver_1.valid)(value) === null) {
        return `Expected SemVer version, got "${value}"`;
    }
    return true;
});
exports.VersionRangeStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version range', (value) => {
    if ((0, semver_1.validRange)(value) === null) {
        return `Expected SemVer range, got "${value}"`;
    }
    return true;
});
/**
 * Checks whether a SemVer version is valid.
 *
 * @param version - A potential version.
 * @returns `true` if the version is valid, and `false` otherwise.
 */
function isValidSemVerVersion(version) {
    return (0, superstruct_1.is)(version, exports.VersionStruct);
}
exports.isValidSemVerVersion = isValidSemVerVersion;
/**
 * Checks whether a SemVer version range is valid.
 *
 * @param versionRange - A potential version range.
 * @returns `true` if the version range is valid, and `false` otherwise.
 */
function isValidSemVerRange(versionRange) {
    return (0, superstruct_1.is)(versionRange, exports.VersionRangeStruct);
}
exports.isValidSemVerRange = isValidSemVerRange;
/**
 * Asserts that a value is a valid concrete SemVer version.
 *
 * @param version - A potential SemVer concrete version.
 */
function assertIsSemVerVersion(version) {
    (0, assert_1.assertStruct)(version, exports.VersionStruct);
}
exports.assertIsSemVerVersion = assertIsSemVerVersion;
/**
 * Asserts that a value is a valid SemVer range.
 *
 * @param range - A potential SemVer range.
 */
function assertIsSemVerRange(range) {
    (0, assert_1.assertStruct)(range, exports.VersionRangeStruct);
}
exports.assertIsSemVerRange = assertIsSemVerRange;
/**
 * Checks whether a SemVer version is greater than another.
 *
 * @param version1 - The left-hand version.
 * @param version2 - The right-hand version.
 * @returns `version1 > version2`.
 */
function gtVersion(version1, version2) {
    return (0, semver_1.gt)(version1, version2);
}
exports.gtVersion = gtVersion;
/**
 * Checks whether a SemVer version is greater than all possibilities in a range.
 *
 * @param version - A SemvVer version.
 * @param range - The range to check against.
 * @returns `version > range`.
 */
function gtRange(version, range) {
    return (0, semver_1.gtr)(version, range);
}
exports.gtRange = gtRange;
/**
 * Returns whether a SemVer version satisfies a SemVer range.
 *
 * @param version - The SemVer version to check.
 * @param versionRange - The SemVer version range to check against.
 * @returns Whether the version satisfied the version range.
 */
function satisfiesVersionRange(version, versionRange) {
    return (0, semver_1.satisfies)(version, versionRange, {
        includePrerelease: true,
    });
}
exports.satisfiesVersionRange = satisfiesVersionRange;
//# sourceMappingURL=versions.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\versions.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-cache.js", {"./logging-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","json-rpc-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cblock-cache.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockCacheMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'block-cache');
// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925
const emptyValues = [undefined, null, '\u003cnil\u003e'];
//
// Cache Strategies
//
class BlockCacheStrategy {
    constructor() {
        this.cache = {};
    }
    getBlockCacheForPayload(_payload, blockNumberHex) {
        const blockNumber = Number.parseInt(blockNumberHex, 16);
        let blockCache = this.cache[blockNumber];
        // create new cache if necesary
        if (!blockCache) {
            const newCache = {};
            this.cache[blockNumber] = newCache;
            blockCache = newCache;
        }
        return blockCache;
    }
    async get(payload, requestedBlockNumber) {
        // lookup block cache
        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        // lookup payload in block cache
        const identifier = cache_1.cacheIdentifierForPayload(payload, true);
        return identifier ? blockCache[identifier] : undefined;
    }
    async set(payload, requestedBlockNumber, result) {
        // check if we can cached this result
        const canCacheResult = this.canCacheResult(payload, result);
        if (!canCacheResult) {
            return;
        }
        // set the value in the cache
        const identifier = cache_1.cacheIdentifierForPayload(payload, true);
        if (!identifier) {
            return;
        }
        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        blockCache[identifier] = result;
    }
    canCacheRequest(payload) {
        // check request method
        if (!cache_1.canCache(payload)) {
            return false;
        }
        // check blockTag
        const blockTag = cache_1.blockTagForPayload(payload);
        if (blockTag === 'pending') {
            return false;
        }
        // can be cached
        return true;
    }
    canCacheResult(payload, result) {
        // never cache empty values (e.g. undefined)
        if (emptyValues.includes(result)) {
            return false;
        }
        // check if transactions have block reference before caching
        if (payload.method &&
            ['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {
            if (!result ||
                !result.blockHash ||
                result.blockHash ===
                    '0x0000000000000000000000000000000000000000000000000000000000000000') {
                return false;
            }
        }
        // otherwise true
        return true;
    }
    // removes all block caches with block number lower than `oldBlockHex`
    clearBefore(oldBlockHex) {
        const oldBlockNumber = Number.parseInt(oldBlockHex, 16);
        // clear old caches
        Object.keys(this.cache)
            .map(Number)
            .filter((num) => num < oldBlockNumber)
            .forEach((num) => delete this.cache[num]);
    }
}
function createBlockCacheMiddleware({ blockTracker, } = {}) {
    // validate options
    if (!blockTracker) {
        throw new Error('createBlockCacheMiddleware - No PollingBlockTracker specified');
    }
    // create caching strategies
    const blockCache = new BlockCacheStrategy();
    const strategies = {
        perma: blockCache,
        block: blockCache,
        fork: blockCache,
    };
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        // allow cach to be skipped if so specified
        if (req.skipCache) {
            return next();
        }
        // check type and matching strategy
        const type = cache_1.cacheTypeForPayload(req);
        const strategy = strategies[type];
        // If there's no strategy in place, pass it down the chain.
        if (!strategy) {
            return next();
        }
        // If the strategy can't cache this request, ignore it.
        if (!strategy.canCacheRequest(req)) {
            return next();
        }
        // get block reference (number or keyword)
        let blockTag = cache_1.blockTagForPayload(req);
        if (!blockTag) {
            blockTag = 'latest';
        }
        log('blockTag = %o, req = %o', blockTag, req);
        // get exact block number
        let requestedBlockNumber;
        if (blockTag === 'earliest') {
            // this just exists for symmetry with "latest"
            requestedBlockNumber = '0x00';
        }
        else if (blockTag === 'latest') {
            // fetch latest block number
            log('Fetching latest block number to determine cache key');
            const latestBlockNumber = await blockTracker.getLatestBlock();
            // clear all cache before latest block
            log('Clearing values stored under block numbers before %o', latestBlockNumber);
            blockCache.clearBefore(latestBlockNumber);
            requestedBlockNumber = latestBlockNumber;
        }
        else {
            // We have a hex number
            requestedBlockNumber = blockTag;
        }
        // end on a hit, continue on a miss
        const cacheResult = await strategy.get(req, requestedBlockNumber);
        if (cacheResult === undefined) {
            // cache miss
            // wait for other middleware to handle request
            log('No cache stored under block number %o, carrying request forward', requestedBlockNumber);
            // eslint-disable-next-line node/callback-return
            await next();
            // add result to cache
            // it's safe to cast res.result as Block, due to runtime type checks
            // performed when strategy.set is called
            log('Populating cache with', res);
            await strategy.set(req, requestedBlockNumber, res.result);
        }
        else {
            // fill in result from cache
            log('Cache hit, reusing cache result stored under block number %o', requestedBlockNumber);
            res.result = cacheResult;
        }
        return undefined;
    });
}
exports.createBlockCacheMiddleware = createBlockCacheMiddleware;
//# sourceMappingURL=block-cache.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-cache.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js", {"./utils/cache":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","json-rpc-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cblock-ref-rewrite.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockRefRewriteMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const cache_1 = require("./utils/cache");
function createBlockRefRewriteMiddleware({ blockTracker, } = {}) {
    if (!blockTracker) {
        throw Error('BlockRefRewriteMiddleware - mandatory "blockTracker" option is missing.');
    }
    return json_rpc_engine_1.createAsyncMiddleware(async (req, _res, next) => {
        var _a;
        const blockRefIndex = cache_1.blockTagParamIndex(req);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        // skip if not "latest"
        let blockRef = (_a = req.params) === null || _a === void 0 ? void 0 : _a[blockRefIndex];
        // omitted blockRef implies "latest"
        if (blockRef === undefined) {
            blockRef = 'latest';
        }
        if (blockRef !== 'latest') {
            return next();
        }
        // rewrite blockRef to block-tracker's block number
        const latestBlockNumber = await blockTracker.getLatestBlock();
        if (req.params) {
            // eslint-disable-next-line require-atomic-updates
            req.params[blockRefIndex] = latestBlockNumber;
        }
        return next();
    });
}
exports.createBlockRefRewriteMiddleware = createBlockRefRewriteMiddleware;
//# sourceMappingURL=block-ref-rewrite.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref.js", {"./logging-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","clone":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\clone\\clone.js","json-rpc-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-rpc-engine\\dist\\index.js","pify":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\pify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cblock-ref.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockRefMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const clone_1 = __importDefault(require("clone"));
const pify_1 = __importDefault(require("pify"));
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'block-ref');
function createBlockRefMiddleware({ provider, blockTracker, } = {}) {
    if (!provider) {
        throw Error('BlockRefMiddleware - mandatory "provider" option is missing.');
    }
    if (!blockTracker) {
        throw Error('BlockRefMiddleware - mandatory "blockTracker" option is missing.');
    }
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        var _a, _b;
        const blockRefIndex = cache_1.blockTagParamIndex(req);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        const blockRef = (_b = (_a = req.params) === null || _a === void 0 ? void 0 : _a[blockRefIndex]) !== null && _b !== void 0 ? _b : 'latest';
        // skip if not "latest"
        if (blockRef !== 'latest') {
            log('blockRef is not "latest", carrying request forward');
            return next();
        }
        // lookup latest block
        const latestBlockNumber = await blockTracker.getLatestBlock();
        log(`blockRef is "latest", setting param ${blockRefIndex} to latest block ${latestBlockNumber}`);
        // create child request with specific block-ref
        const childRequest = clone_1.default(req);
        if (childRequest.params) {
            childRequest.params[blockRefIndex] = latestBlockNumber;
        }
        // perform child request
        log('Performing another request %o', childRequest);
        const childRes = await pify_1.default(provider.sendAsync).call(provider, childRequest);
        // copy child response onto original response
        res.result = childRes.result;
        res.error = childRes.error;
        return undefined;
    });
}
exports.createBlockRefMiddleware = createBlockRefMiddleware;
//# sourceMappingURL=block-ref.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js", {"./logging-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\logging-utils.js","json-rpc-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cblock-tracker-inspector.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockTrackerInspectorMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const logging_utils_1 = require("./logging-utils");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'block-tracker-inspector');
const futureBlockRefRequests = [
    'eth_getTransactionByHash',
    'eth_getTransactionReceipt',
];
// inspect if response contains a block ref higher than our latest block
function createBlockTrackerInspectorMiddleware({ blockTracker, }) {
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        var _a;
        if (!futureBlockRefRequests.includes(req.method)) {
            return next();
        }
        // eslint-disable-next-line node/callback-return
        await next();
        // abort if no result or no block number
        if (!((_a = res.result) === null || _a === void 0 ? void 0 : _a.blockNumber)) {
            return undefined;
        }
        log('res.result.blockNumber exists, proceeding. res = %o', res);
        if (typeof res.result.blockNumber === 'string') {
            // if number is higher, suggest block-tracker check for a new block
            const blockNumber = Number.parseInt(res.result.blockNumber, 16);
            // Typecast: If getCurrentBlock returns null, currentBlockNumber will be NaN, which is fine.
            const currentBlockNumber = Number.parseInt(blockTracker.getCurrentBlock(), 16);
            if (blockNumber > currentBlockNumber) {
                log('blockNumber from response is greater than current block number, refreshing current block number');
                await blockTracker.checkForLatestBlock();
            }
        }
        return undefined;
    });
}
exports.createBlockTrackerInspectorMiddleware = createBlockTrackerInspectorMiddleware;
//# sourceMappingURL=block-tracker-inspector.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\fetch.js", {"btoa":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js","eth-rpc-errors":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\eth-rpc-errors\\dist\\index.js","json-rpc-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-rpc-engine\\dist\\index.js","node-fetch":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cfetch.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFetchConfigFromReq = exports.createFetchMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const eth_rpc_errors_1 = require("eth-rpc-errors");
/* eslint-disable @typescript-eslint/no-require-imports,@typescript-eslint/no-shadow */
const fetch = global.fetch || require('node-fetch');
const btoa = global.btoa || require('btoa');
/* eslint-enable @typescript-eslint/no-require-imports,@typescript-eslint/no-shadow */
const RETRIABLE_ERRORS = [
    // ignore server overload errors
    'Gateway timeout',
    'ETIMEDOUT',
    // ignore server sent html error pages
    // or truncated json responses
    'failed to parse response body',
    // ignore errors where http req failed to establish
    'Failed to fetch',
];
function createFetchMiddleware({ rpcUrl, originHttpHeaderKey, }) {
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, _next) => {
        const { fetchUrl, fetchParams } = createFetchConfigFromReq({
            req,
            rpcUrl,
            originHttpHeaderKey,
        });
        // attempt request multiple times
        const maxAttempts = 5;
        const retryInterval = 1000;
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            try {
                const fetchRes = await fetch(fetchUrl, fetchParams);
                // check for http errrors
                checkForHttpErrors(fetchRes);
                // parse response body
                const rawBody = await fetchRes.text();
                let fetchBody;
                try {
                    fetchBody = JSON.parse(rawBody);
                }
                catch (_) {
                    throw new Error(`FetchMiddleware - failed to parse response body: "${rawBody}"`);
                }
                const result = parseResponse(fetchRes, fetchBody);
                // set result and exit retry loop
                res.result = result;
                return;
            }
            catch (err) {
                const errMsg = err.toString();
                const isRetriable = RETRIABLE_ERRORS.some((phrase) => errMsg.includes(phrase));
                // re-throw error if not retriable
                if (!isRetriable) {
                    throw err;
                }
            }
            // delay before retrying
            await timeout(retryInterval);
        }
    });
}
exports.createFetchMiddleware = createFetchMiddleware;
function checkForHttpErrors(fetchRes) {
    // check for errors
    switch (fetchRes.status) {
        case 405:
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound();
        case 418:
            throw createRatelimitError();
        case 503:
        case 504:
            throw createTimeoutError();
        default:
            break;
    }
}
function parseResponse(fetchRes, body) {
    // check for error code
    if (fetchRes.status !== 200) {
        throw eth_rpc_errors_1.ethErrors.rpc.internal({
            message: `Non-200 status code: '${fetchRes.status}'`,
            data: body,
        });
    }
    // check for rpc error
    if (body.error) {
        throw eth_rpc_errors_1.ethErrors.rpc.internal({
            data: body.error,
        });
    }
    // return successful result
    return body.result;
}
function createFetchConfigFromReq({ req, rpcUrl, originHttpHeaderKey, }) {
    const parsedUrl = new URL(rpcUrl);
    const fetchUrl = normalizeUrlFromParsed(parsedUrl);
    // prepare payload
    // copy only canonical json rpc properties
    const payload = {
        id: req.id,
        jsonrpc: req.jsonrpc,
        method: req.method,
        params: req.params,
    };
    // extract 'origin' parameter from request
    const originDomain = req.origin;
    // serialize request body
    const serializedPayload = JSON.stringify(payload);
    // configure fetch params
    const fetchParams = {
        method: 'POST',
        headers: {
            Accept: 'application/json',
            'Content-Type': 'application/json',
        },
        body: serializedPayload,
    };
    // encoded auth details as header (not allowed in fetch url)
    if (parsedUrl.username && parsedUrl.password) {
        const authString = `${parsedUrl.username}:${parsedUrl.password}`;
        const encodedAuth = btoa(authString);
        fetchParams.headers.Authorization = `Basic ${encodedAuth}`;
    }
    // optional: add request origin as header
    if (originHttpHeaderKey && originDomain) {
        fetchParams.headers[originHttpHeaderKey] = originDomain;
    }
    return { fetchUrl, fetchParams };
}
exports.createFetchConfigFromReq = createFetchConfigFromReq;
function normalizeUrlFromParsed(parsedUrl) {
    let result = '';
    result += parsedUrl.protocol;
    result += `//${parsedUrl.hostname}`;
    if (parsedUrl.port) {
        result += `:${parsedUrl.port}`;
    }
    result += `${parsedUrl.pathname}`;
    result += `${parsedUrl.search}`;
    return result;
}
function createRatelimitError() {
    return eth_rpc_errors_1.ethErrors.rpc.internal({ message: `Request is being rate limited.` });
}
function createTimeoutError() {
    let msg = `Gateway timeout. The request took too long to process. `;
    msg += `This can happen when querying logs over too wide a block range.`;
    return eth_rpc_errors_1.ethErrors.rpc.internal({ message: msg });
}
function timeout(duration) {
    return new Promise((resolve) => setTimeout(resolve, duration));
}
//# sourceMappingURL=fetch.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\fetch.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\index.js", {"./block-cache":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-cache.js","./block-ref":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref.js","./block-ref-rewrite":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js","./block-tracker-inspector":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js","./fetch":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\fetch.js","./inflight-cache":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\inflight-cache.js","./providerAsMiddleware":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js","./providerFromEngine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromEngine.js","./providerFromMiddleware":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromMiddleware.js","./retryOnEmpty":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js","./wallet":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\wallet.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./block-cache"), exports);
__exportStar(require("./block-ref-rewrite"), exports);
__exportStar(require("./block-ref"), exports);
__exportStar(require("./block-tracker-inspector"), exports);
__exportStar(require("./fetch"), exports);
__exportStar(require("./inflight-cache"), exports);
__exportStar(require("./providerAsMiddleware"), exports);
__exportStar(require("./providerFromEngine"), exports);
__exportStar(require("./providerFromMiddleware"), exports);
__exportStar(require("./retryOnEmpty"), exports);
__exportStar(require("./wallet"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\inflight-cache.js", {"./logging-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","clone":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\clone\\clone.js","json-rpc-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cinflight-cache.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createInflightCacheMiddleware = void 0;
const clone_1 = __importDefault(require("clone"));
const json_rpc_engine_1 = require("json-rpc-engine");
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'inflight-cache');
function createInflightCacheMiddleware() {
    const inflightRequests = {};
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        // allow cach to be skipped if so specified
        if (req.skipCache) {
            return next();
        }
        // get cacheId, if cacheable
        const cacheId = cache_1.cacheIdentifierForPayload(req);
        // if not cacheable, skip
        if (!cacheId) {
            log('Request is not cacheable, proceeding. req = %o', req);
            return next();
        }
        // check for matching requests
        let activeRequestHandlers = inflightRequests[cacheId];
        // if found, wait for the active request to be handled
        if (activeRequestHandlers) {
            // setup the response listener and wait for it to be called
            // it will handle copying the result and request fields
            log('Running %i handler(s) for request %o', activeRequestHandlers.length, req);
            await createActiveRequestHandler(res, activeRequestHandlers);
            return undefined;
        }
        // setup response handler array for subsequent requests
        activeRequestHandlers = [];
        inflightRequests[cacheId] = activeRequestHandlers;
        // allow request to be handled normally
        log('Carrying original request forward %o', req);
        // eslint-disable-next-line node/callback-return
        await next();
        // clear inflight requests
        delete inflightRequests[cacheId];
        // schedule activeRequestHandlers to be handled
        log('Running %i collected handler(s) for request %o', activeRequestHandlers.length, req);
        handleActiveRequest(res, activeRequestHandlers);
        // complete
        return undefined;
    });
    function createActiveRequestHandler(res, activeRequestHandlers) {
        const { resolve, promise } = deferredPromise();
        activeRequestHandlers.push((handledRes) => {
            // append a copy of the result and error to the response
            res.result = clone_1.default(handledRes.result);
            res.error = clone_1.default(handledRes.error);
            resolve();
        });
        return promise;
    }
    function handleActiveRequest(res, activeRequestHandlers) {
        // use setTimeout so we can resolve our original request first
        setTimeout(() => {
            activeRequestHandlers.forEach((handler) => {
                try {
                    handler(res);
                }
                catch (err) {
                    // catch error so all requests are handled correctly
                    console.error(err);
                }
            });
        });
    }
}
exports.createInflightCacheMiddleware = createInflightCacheMiddleware;
function deferredPromise() {
    let resolve;
    const promise = new Promise((_resolve) => {
        resolve = _resolve;
    });
    return { resolve, promise };
}
//# sourceMappingURL=inflight-cache.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\inflight-cache.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\logging-utils.js", {"@metamask/utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Clogging-utils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createModuleLogger = exports.projectLogger = void 0;
const utils_1 = require("@metamask/utils");
Object.defineProperty(exports, "createModuleLogger", { enumerable: true, get: function () { return utils_1.createModuleLogger; } });
exports.projectLogger = utils_1.createProjectLogger('eth-json-rpc-middleware');
//# sourceMappingURL=logging-utils.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\logging-utils.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5CproviderAsMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ethersProviderAsMiddleware = exports.providerAsMiddleware = void 0;
function providerAsMiddleware(provider) {
    return (req, res, _next, end) => {
        // send request to provider
        provider.sendAsync(req, (err, providerRes) => {
            // forward any error
            if (err instanceof Error) {
                return end(err);
            }
            // copy provider response onto original response
            Object.assign(res, providerRes);
            return end();
        });
    };
}
exports.providerAsMiddleware = providerAsMiddleware;
function ethersProviderAsMiddleware(provider) {
    return (req, res, _next, end) => {
        // send request to provider
        provider.send(req, (err, providerRes) => {
            // forward any error
            if (err) {
                return end(err);
            }
            // copy provider response onto original response
            Object.assign(res, providerRes);
            return end();
        });
    };
}
exports.ethersProviderAsMiddleware = ethersProviderAsMiddleware;
//# sourceMappingURL=providerAsMiddleware.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromEngine.js", {"@metamask/safe-event-emitter":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\safe-event-emitter\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5CproviderFromEngine.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.providerFromEngine = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
function providerFromEngine(engine) {
    const provider = new safe_event_emitter_1.default();
    // handle both rpc send methods
    provider.sendAsync = (req, cb) => {
        engine.handle(req, cb);
    };
    provider.send = (req, callback) => {
        if (typeof callback !== 'function') {
            throw new Error('Must provide callback to "send" method.');
        }
        engine.handle(req, callback);
    };
    // forward notifications
    if (engine.on) {
        engine.on('notification', (message) => {
            provider.emit('data', null, message);
        });
    }
    return provider;
}
exports.providerFromEngine = providerFromEngine;
//# sourceMappingURL=providerFromEngine.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromEngine.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromMiddleware.js", {"./providerFromEngine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromEngine.js","json-rpc-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5CproviderFromMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.providerFromMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const providerFromEngine_1 = require("./providerFromEngine");
function providerFromMiddleware(middleware) {
    const engine = new json_rpc_engine_1.JsonRpcEngine();
    engine.push(middleware);
    const provider = providerFromEngine_1.providerFromEngine(engine);
    return provider;
}
exports.providerFromMiddleware = providerFromMiddleware;
//# sourceMappingURL=providerFromMiddleware.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromMiddleware.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js", {"./logging-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","clone":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\clone\\clone.js","json-rpc-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-rpc-engine\\dist\\index.js","pify":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\pify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5CretryOnEmpty.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRetryOnEmptyMiddleware = void 0;
const clone_1 = __importDefault(require("clone"));
const json_rpc_engine_1 = require("json-rpc-engine");
const pify_1 = __importDefault(require("pify"));
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
//
// RetryOnEmptyMiddleware will retry any request with an empty response that has
// a numbered block reference at or lower than the blockTracker's latest block.
// Its useful for dealing with load-balanced ethereum JSON RPC
// nodes that are not always in sync with each other.
//
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'retry-on-empty');
// empty values used to determine if a request should be retried
// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925
const emptyValues = [
    undefined,
    null,
    '\u003cnil\u003e',
];
function createRetryOnEmptyMiddleware({ provider, blockTracker, } = {}) {
    if (!provider) {
        throw Error('RetryOnEmptyMiddleware - mandatory "provider" option is missing.');
    }
    if (!blockTracker) {
        throw Error('RetryOnEmptyMiddleware - mandatory "blockTracker" option is missing.');
    }
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        var _a;
        const blockRefIndex = cache_1.blockTagParamIndex(req);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        // skip if not exact block references
        let blockRef = (_a = req.params) === null || _a === void 0 ? void 0 : _a[blockRefIndex];
        // omitted blockRef implies "latest"
        if (blockRef === undefined) {
            blockRef = 'latest';
        }
        // skip if non-number block reference
        if (['latest', 'pending'].includes(blockRef)) {
            return next();
        }
        // skip if block refernce is not a valid number
        const blockRefNumber = Number.parseInt(blockRef.slice(2), 16);
        if (Number.isNaN(blockRefNumber)) {
            return next();
        }
        // lookup latest block
        const latestBlockNumberHex = await blockTracker.getLatestBlock();
        const latestBlockNumber = Number.parseInt(latestBlockNumberHex.slice(2), 16);
        // skip if request block number is higher than current
        if (blockRefNumber > latestBlockNumber) {
            log('Requested block number %o is higher than latest block number %o, falling through to original request', blockRefNumber, latestBlockNumber);
            return next();
        }
        log('Requested block number %o is not higher than latest block number %o, trying request until non-empty response is received', blockRefNumber, latestBlockNumber);
        // create child request with specific block-ref
        const childRequest = clone_1.default(req);
        // attempt child request until non-empty response is received
        const childResponse = await retry(10, async () => {
            log('Performing request %o', childRequest);
            const attemptResponse = await pify_1.default(provider.sendAsync).call(provider, childRequest);
            log('Response is %o', attemptResponse);
            // verify result
            if (emptyValues.includes(attemptResponse.result)) {
                throw new Error(`RetryOnEmptyMiddleware - empty response "${JSON.stringify(attemptResponse)}" for request "${JSON.stringify(childRequest)}"`);
            }
            return attemptResponse;
        });
        log('Copying result %o and error %o', childResponse.result, childResponse.error);
        // copy child response onto original response
        res.result = childResponse.result;
        res.error = childResponse.error;
        return undefined;
    });
}
exports.createRetryOnEmptyMiddleware = createRetryOnEmptyMiddleware;
async function retry(maxRetries, asyncFn) {
    for (let index = 0; index < maxRetries; index++) {
        try {
            return await asyncFn();
        }
        catch (err) {
            log('(call %i) Request failed, waiting 1s to retry again...', index + 1);
            await timeout(1000);
        }
    }
    log('Retries exhausted');
    throw new Error('RetryOnEmptyMiddleware - retries exhausted');
}
function timeout(duration) {
    return new Promise((resolve) => setTimeout(resolve, duration));
}
//# sourceMappingURL=retryOnEmpty.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js", {"json-stable-stringify":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-stable-stringify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cutils%5Ccache.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cacheTypeForPayload = exports.blockTagParamIndex = exports.paramsWithoutBlockTag = exports.blockTagForPayload = exports.canCache = exports.cacheIdentifierForPayload = void 0;
const json_stable_stringify_1 = __importDefault(require("json-stable-stringify"));
function cacheIdentifierForPayload(payload, skipBlockRef) {
    var _a;
    const simpleParams = skipBlockRef
        ? paramsWithoutBlockTag(payload)
        : (_a = payload.params) !== null && _a !== void 0 ? _a : [];
    if (canCache(payload)) {
        return `${payload.method}:${json_stable_stringify_1.default(simpleParams)}`;
    }
    return null;
}
exports.cacheIdentifierForPayload = cacheIdentifierForPayload;
function canCache(payload) {
    return cacheTypeForPayload(payload) !== 'never';
}
exports.canCache = canCache;
function blockTagForPayload(payload) {
    if (!payload.params) {
        return undefined;
    }
    const index = blockTagParamIndex(payload);
    // Block tag param not passed.
    if (index === undefined || index >= payload.params.length) {
        return undefined;
    }
    return payload.params[index];
}
exports.blockTagForPayload = blockTagForPayload;
function paramsWithoutBlockTag(payload) {
    if (!payload.params) {
        return [];
    }
    const index = blockTagParamIndex(payload);
    // Block tag param not passed.
    if (index === undefined || index >= payload.params.length) {
        return payload.params;
    }
    // eth_getBlockByNumber has the block tag first, then the optional includeTx? param
    if (payload.method === 'eth_getBlockByNumber') {
        return payload.params.slice(1);
    }
    return payload.params.slice(0, index);
}
exports.paramsWithoutBlockTag = paramsWithoutBlockTag;
function blockTagParamIndex(payload) {
    switch (payload.method) {
        // blockTag is at index 2
        case 'eth_getStorageAt':
            return 2;
        // blockTag is at index 1
        case 'eth_getBalance':
        case 'eth_getCode':
        case 'eth_getTransactionCount':
        case 'eth_call':
            return 1;
        // blockTag is at index 0
        case 'eth_getBlockByNumber':
            return 0;
        // there is no blockTag
        default:
            return undefined;
    }
}
exports.blockTagParamIndex = blockTagParamIndex;
function cacheTypeForPayload(payload) {
    switch (payload.method) {
        // cache permanently
        case 'web3_clientVersion':
        case 'web3_sha3':
        case 'eth_protocolVersion':
        case 'eth_getBlockTransactionCountByHash':
        case 'eth_getUncleCountByBlockHash':
        case 'eth_getCode':
        case 'eth_getBlockByHash':
        case 'eth_getTransactionByHash':
        case 'eth_getTransactionByBlockHashAndIndex':
        case 'eth_getTransactionReceipt':
        case 'eth_getUncleByBlockHashAndIndex':
        case 'eth_getCompilers':
        case 'eth_compileLLL':
        case 'eth_compileSolidity':
        case 'eth_compileSerpent':
        case 'shh_version':
        case 'test_permaCache':
            return 'perma';
        // cache until fork
        case 'eth_getBlockByNumber':
        case 'eth_getBlockTransactionCountByNumber':
        case 'eth_getUncleCountByBlockNumber':
        case 'eth_getTransactionByBlockNumberAndIndex':
        case 'eth_getUncleByBlockNumberAndIndex':
        case 'test_forkCache':
            return 'fork';
        // cache for block
        case 'eth_gasPrice':
        case 'eth_blockNumber':
        case 'eth_getBalance':
        case 'eth_getStorageAt':
        case 'eth_getTransactionCount':
        case 'eth_call':
        case 'eth_estimateGas':
        case 'eth_getFilterLogs':
        case 'eth_getLogs':
        case 'test_blockCache':
            return 'block';
        // never cache
        default:
            return 'never';
    }
}
exports.cacheTypeForPayload = cacheTypeForPayload;
//# sourceMappingURL=cache.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\wallet.js", {"@metamask/eth-sig-util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-sig-util\\dist\\index.js","eth-rpc-errors":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\eth-rpc-errors\\dist\\index.js","json-rpc-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cwallet.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWalletMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const sigUtil = __importStar(require("@metamask/eth-sig-util"));
const eth_rpc_errors_1 = require("eth-rpc-errors");
function createWalletMiddleware({ getAccounts, processDecryptMessage, processEncryptionPublicKey, processEthSignMessage, processPersonalMessage, processTransaction, processSignTransaction, processTypedMessage, processTypedMessageV3, processTypedMessageV4, }) {
    if (!getAccounts) {
        throw new Error('opts.getAccounts is required');
    }
    return json_rpc_engine_1.createScaffoldMiddleware({
        // account lookups
        eth_accounts: json_rpc_engine_1.createAsyncMiddleware(lookupAccounts),
        eth_coinbase: json_rpc_engine_1.createAsyncMiddleware(lookupDefaultAccount),
        // tx signatures
        eth_sendTransaction: json_rpc_engine_1.createAsyncMiddleware(sendTransaction),
        eth_signTransaction: json_rpc_engine_1.createAsyncMiddleware(signTransaction),
        // message signatures
        eth_sign: json_rpc_engine_1.createAsyncMiddleware(ethSign),
        eth_signTypedData: json_rpc_engine_1.createAsyncMiddleware(signTypedData),
        eth_signTypedData_v3: json_rpc_engine_1.createAsyncMiddleware(signTypedDataV3),
        eth_signTypedData_v4: json_rpc_engine_1.createAsyncMiddleware(signTypedDataV4),
        personal_sign: json_rpc_engine_1.createAsyncMiddleware(personalSign),
        eth_getEncryptionPublicKey: json_rpc_engine_1.createAsyncMiddleware(encryptionPublicKey),
        eth_decrypt: json_rpc_engine_1.createAsyncMiddleware(decryptMessage),
        personal_ecRecover: json_rpc_engine_1.createAsyncMiddleware(personalRecover),
    });
    //
    // account lookups
    //
    async function lookupAccounts(req, res) {
        res.result = await getAccounts(req);
    }
    async function lookupDefaultAccount(req, res) {
        const accounts = await getAccounts(req);
        res.result = accounts[0] || null;
    }
    //
    // transaction signatures
    //
    async function sendTransaction(req, res) {
        if (!processTransaction) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const txParams = req.params[0] || {};
        txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
        res.result = await processTransaction(txParams, req);
    }
    async function signTransaction(req, res) {
        if (!processSignTransaction) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const txParams = req.params[0] || {};
        txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
        res.result = await processSignTransaction(txParams, req);
    }
    //
    // message signatures
    //
    async function ethSign(req, res) {
        if (!processEthSignMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        res.result = await processEthSignMessage(msgParams, req);
    }
    async function signTypedData(req, res) {
        if (!processTypedMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const message = req.params[0];
        const address = await validateAndNormalizeKeyholder(req.params[1], req);
        const version = 'V1';
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        res.result = await processTypedMessage(msgParams, req, version);
    }
    async function signTypedDataV3(req, res) {
        if (!processTypedMessageV3) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const version = 'V3';
        const msgParams = {
            data: message,
            from: address,
            version,
        };
        res.result = await processTypedMessageV3(msgParams, req, version);
    }
    async function signTypedDataV4(req, res) {
        if (!processTypedMessageV4) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const version = 'V4';
        const msgParams = {
            data: message,
            from: address,
            version,
        };
        res.result = await processTypedMessageV4(msgParams, req, version);
    }
    async function personalSign(req, res) {
        if (!processPersonalMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        // process normally
        const firstParam = req.params[0];
        const secondParam = req.params[1];
        // non-standard "extraParams" to be appended to our "msgParams" obj
        const extraParams = req.params[2] || {};
        // We initially incorrectly ordered these parameters.
        // To gracefully respect users who adopted this API early,
        // we are currently gracefully recovering from the wrong param order
        // when it is clearly identifiable.
        //
        // That means when the first param is definitely an address,
        // and the second param is definitely not, but is hex.
        let address, message;
        if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {
            let warning = `The eth_personalSign method requires params ordered `;
            warning += `[message, address]. This was previously handled incorrectly, `;
            warning += `and has been corrected automatically. `;
            warning += `Please switch this param order for smooth behavior in the future.`;
            res.warning = warning;
            address = firstParam;
            message = secondParam;
        }
        else {
            message = firstParam;
            address = secondParam;
        }
        address = await validateAndNormalizeKeyholder(address, req);
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        // eslint-disable-next-line require-atomic-updates
        res.result = await processPersonalMessage(msgParams, req);
    }
    async function personalRecover(req, res) {
        const message = req.params[0];
        const signature = req.params[1];
        const signerAddress = sigUtil.recoverPersonalSignature({
            data: message,
            signature,
        });
        res.result = signerAddress;
    }
    async function encryptionPublicKey(req, res) {
        if (!processEncryptionPublicKey) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        res.result = await processEncryptionPublicKey(address, req);
    }
    async function decryptMessage(req, res) {
        if (!processDecryptMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const ciphertext = req.params[0];
        const address = await validateAndNormalizeKeyholder(req.params[1], req);
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: ciphertext });
        res.result = await processDecryptMessage(msgParams, req);
    }
    //
    // utility
    //
    /**
     * Validates the keyholder address, and returns a normalized (i.e. lowercase)
     * copy of it.
     *
     * @param {string} address - The address to validate and normalize.
     * @param {Object} req - The request object.
     * @returns {string} - The normalized address, if valid. Otherwise, throws
     * an error
     */
    async function validateAndNormalizeKeyholder(address, req) {
        if (typeof address === 'string' &&
            address.length > 0 &&
            resemblesAddress(address)) {
            // ensure address is included in provided accounts. `suppressUnauthorized: false` is passed to `getAccounts`
            // so that an "unauthorized" error is thrown if the requester does not have the `eth_accounts`
            // permission.
            const accounts = await getAccounts(req, {
                suppressUnauthorized: false,
            });
            const normalizedAccounts = accounts.map((_address) => _address.toLowerCase());
            const normalizedAddress = address.toLowerCase();
            if (normalizedAccounts.includes(normalizedAddress)) {
                return normalizedAddress;
            }
            throw eth_rpc_errors_1.ethErrors.provider.unauthorized();
        }
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: `Invalid parameters: must provide an Ethereum address.`,
        });
    }
}
exports.createWalletMiddleware = createWalletMiddleware;
function resemblesAddress(str) {
    // hex prefix 2 + 20 bytes
    return str.length === 2 + 20 * 2;
}
//# sourceMappingURL=wallet.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\wallet.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\pify\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Cpify%5Cindex.js
      return function (require, module, exports) {
'use strict';

const processFn = (fn, opts) => function () {
	const P = opts.promiseModule;
	const args = new Array(arguments.length);

	for (let i = 0; i < arguments.length; i++) {
		args[i] = arguments[i];
	}

	return new P((resolve, reject) => {
		if (opts.errorFirst) {
			args.push(function (err, result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 1; i < arguments.length; i++) {
						results[i - 1] = arguments[i];
					}

					if (err) {
						results.unshift(err);
						reject(results);
					} else {
						resolve(results);
					}
				} else if (err) {
					reject(err);
				} else {
					resolve(result);
				}
			});
		} else {
			args.push(function (result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 0; i < arguments.length; i++) {
						results[i] = arguments[i];
					}

					resolve(results);
				} else {
					resolve(result);
				}
			});
		}

		fn.apply(this, args);
	});
};

module.exports = (obj, opts) => {
	opts = Object.assign({
		exclude: [/.+(Sync|Stream)$/],
		errorFirst: true,
		promiseModule: Promise
	}, opts);

	const filter = key => {
		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
	};

	let ret;
	if (typeof obj === 'function') {
		ret = function () {
			if (opts.excludeMain) {
				return obj.apply(this, arguments);
			}

			return processFn(obj, opts).apply(this, arguments);
		};
	} else {
		ret = Object.create(Object.getPrototypeOf(obj));
	}

	for (const key in obj) { // eslint-disable-line guard-for-in
		const x = obj[key];
		ret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;
	}

	return ret;
};

      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware>pify",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\pify\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-cache.js", {"./logging-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\cache.js","json-rpc-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cblock-cache.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockCacheMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'block-cache');
// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925
const emptyValues = [undefined, null, '\u003cnil\u003e'];
//
// Cache Strategies
//
class BlockCacheStrategy {
    constructor() {
        this.cache = {};
    }
    getBlockCache(blockNumberHex) {
        const blockNumber = Number.parseInt(blockNumberHex, 16);
        let blockCache = this.cache[blockNumber];
        // create new cache if necesary
        if (!blockCache) {
            const newCache = {};
            this.cache[blockNumber] = newCache;
            blockCache = newCache;
        }
        return blockCache;
    }
    async get(request, requestedBlockNumber) {
        // lookup block cache
        const blockCache = this.getBlockCache(requestedBlockNumber);
        // lookup payload in block cache
        const identifier = cache_1.cacheIdentifierForRequest(request, true);
        return identifier ? blockCache[identifier] : undefined;
    }
    async set(request, requestedBlockNumber, result) {
        // check if we can cached this result
        const canCacheResult = this.canCacheResult(request, result);
        if (!canCacheResult) {
            return;
        }
        // set the value in the cache
        const identifier = cache_1.cacheIdentifierForRequest(request, true);
        if (!identifier) {
            return;
        }
        const blockCache = this.getBlockCache(requestedBlockNumber);
        blockCache[identifier] = result;
    }
    canCacheRequest(request) {
        // check request method
        if (!cache_1.canCache(request.method)) {
            return false;
        }
        // check blockTag
        const blockTag = cache_1.blockTagForRequest(request);
        if (blockTag === 'pending') {
            return false;
        }
        // can be cached
        return true;
    }
    canCacheResult(request, result) {
        // never cache empty values (e.g. undefined)
        if (emptyValues.includes(result)) {
            return false;
        }
        // check if transactions have block reference before caching
        if (request.method &&
            ['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(request.method)) {
            if (!result ||
                !result.blockHash ||
                result.blockHash ===
                    '0x0000000000000000000000000000000000000000000000000000000000000000') {
                return false;
            }
        }
        // otherwise true
        return true;
    }
    // removes all block caches with block number lower than `oldBlockHex`
    clearBefore(oldBlockHex) {
        const oldBlockNumber = Number.parseInt(oldBlockHex, 16);
        // clear old caches
        Object.keys(this.cache)
            .map(Number)
            .filter((num) => num < oldBlockNumber)
            .forEach((num) => delete this.cache[num]);
    }
}
function createBlockCacheMiddleware({ blockTracker, } = {}) {
    // validate options
    if (!blockTracker) {
        throw new Error('createBlockCacheMiddleware - No PollingBlockTracker specified');
    }
    // create caching strategies
    const blockCache = new BlockCacheStrategy();
    const strategies = {
        [cache_1.CacheStrategy.Permanent]: blockCache,
        [cache_1.CacheStrategy.Block]: blockCache,
        [cache_1.CacheStrategy.Fork]: blockCache,
        [cache_1.CacheStrategy.Never]: undefined,
    };
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        // allow cach to be skipped if so specified
        if (req.skipCache) {
            return next();
        }
        // check type and matching strategy
        const type = cache_1.cacheTypeForMethod(req.method);
        const strategy = strategies[type];
        // If there's no strategy in place, pass it down the chain.
        if (!strategy) {
            return next();
        }
        // If the strategy can't cache this request, ignore it.
        if (!strategy.canCacheRequest(req)) {
            return next();
        }
        // get block reference (number or keyword)
        const requestBlockTag = cache_1.blockTagForRequest(req);
        const blockTag = requestBlockTag && typeof requestBlockTag === 'string'
            ? requestBlockTag
            : 'latest';
        log('blockTag = %o, req = %o', blockTag, req);
        // get exact block number
        let requestedBlockNumber;
        if (blockTag === 'earliest') {
            // this just exists for symmetry with "latest"
            requestedBlockNumber = '0x00';
        }
        else if (blockTag === 'latest') {
            // fetch latest block number
            log('Fetching latest block number to determine cache key');
            const latestBlockNumber = await blockTracker.getLatestBlock();
            // clear all cache before latest block
            log('Clearing values stored under block numbers before %o', latestBlockNumber);
            blockCache.clearBefore(latestBlockNumber);
            requestedBlockNumber = latestBlockNumber;
        }
        else {
            // We have a hex number
            requestedBlockNumber = blockTag;
        }
        // end on a hit, continue on a miss
        const cacheResult = await strategy.get(req, requestedBlockNumber);
        if (cacheResult === undefined) {
            // cache miss
            // wait for other middleware to handle request
            log('No cache stored under block number %o, carrying request forward', requestedBlockNumber);
            // eslint-disable-next-line node/callback-return
            await next();
            // add result to cache
            // it's safe to cast res.result as Block, due to runtime type checks
            // performed when strategy.set is called
            log('Populating cache with', res);
            await strategy.set(req, requestedBlockNumber, res.result);
        }
        else {
            // fill in result from cache
            log('Cache hit, reusing cache result stored under block number %o', requestedBlockNumber);
            res.result = cacheResult;
        }
        return undefined;
    });
}
exports.createBlockCacheMiddleware = createBlockCacheMiddleware;
//# sourceMappingURL=block-cache.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-cache.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js", {"./utils/cache":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\cache.js","json-rpc-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cblock-ref-rewrite.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockRefRewriteMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const cache_1 = require("./utils/cache");
function createBlockRefRewriteMiddleware({ blockTracker, } = {}) {
    if (!blockTracker) {
        throw Error('BlockRefRewriteMiddleware - mandatory "blockTracker" option is missing.');
    }
    return json_rpc_engine_1.createAsyncMiddleware(async (req, _res, next) => {
        const blockRefIndex = cache_1.blockTagParamIndex(req.method);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        // skip if not "latest"
        let blockRef = Array.isArray(req.params)
            ? req.params[blockRefIndex]
            : undefined;
        // omitted blockRef implies "latest"
        if (blockRef === undefined) {
            blockRef = 'latest';
        }
        if (blockRef !== 'latest') {
            return next();
        }
        // rewrite blockRef to block-tracker's block number
        const latestBlockNumber = await blockTracker.getLatestBlock();
        if (Array.isArray(req.params)) {
            // eslint-disable-next-line require-atomic-updates
            req.params[blockRefIndex] = latestBlockNumber;
        }
        return next();
    });
}
exports.createBlockRefRewriteMiddleware = createBlockRefRewriteMiddleware;
//# sourceMappingURL=block-ref-rewrite.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-ref.js", {"./logging-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\cache.js","clone":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\clone\\clone.js","json-rpc-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-rpc-engine\\dist\\index.js","pify":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\pify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cblock-ref.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockRefMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const clone_1 = __importDefault(require("clone"));
const pify_1 = __importDefault(require("pify"));
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'block-ref');
function createBlockRefMiddleware({ provider, blockTracker, } = {}) {
    if (!provider) {
        throw Error('BlockRefMiddleware - mandatory "provider" option is missing.');
    }
    if (!blockTracker) {
        throw Error('BlockRefMiddleware - mandatory "blockTracker" option is missing.');
    }
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        var _a;
        const blockRefIndex = cache_1.blockTagParamIndex(req.method);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        const blockRef = Array.isArray(req.params)
            ? (_a = req.params[blockRefIndex]) !== null && _a !== void 0 ? _a : 'latest'
            : 'latest';
        // skip if not "latest"
        if (blockRef !== 'latest') {
            log('blockRef is not "latest", carrying request forward');
            return next();
        }
        // lookup latest block
        const latestBlockNumber = await blockTracker.getLatestBlock();
        log(`blockRef is "latest", setting param ${blockRefIndex} to latest block ${latestBlockNumber}`);
        // create child request with specific block-ref
        const childRequest = clone_1.default(req);
        if (Array.isArray(childRequest.params)) {
            childRequest.params[blockRefIndex] = latestBlockNumber;
        }
        // perform child request
        log('Performing another request %o', childRequest);
        const childRes = await pify_1.default(provider.sendAsync).call(provider, childRequest);
        // copy child response onto original response
        res.result = childRes.result;
        res.error = childRes.error;
        return undefined;
    });
}
exports.createBlockRefMiddleware = createBlockRefMiddleware;
//# sourceMappingURL=block-ref.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-ref.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js", {"./logging-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\logging-utils.js","json-rpc-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cblock-tracker-inspector.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockTrackerInspectorMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const logging_utils_1 = require("./logging-utils");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'block-tracker-inspector');
const futureBlockRefRequests = [
    'eth_getTransactionByHash',
    'eth_getTransactionReceipt',
];
/**
 * Determines whether the given object has the given property.
 *
 * @param objectToCheck - The object to check.
 * @param property - The property to look for.
 * @returns - Whether the object has the property.
 */
function hasProperty(objectToCheck, property) {
    return Object.hasOwnProperty.call(objectToCheck, property);
}
function getResultBlockNumber(response) {
    const { result } = response;
    if (!result ||
        typeof result !== 'object' ||
        !hasProperty(result, 'blockNumber')) {
        return undefined;
    }
    if (typeof result.blockNumber === 'string') {
        return result.blockNumber;
    }
    return undefined;
}
// inspect if response contains a block ref higher than our latest block
function createBlockTrackerInspectorMiddleware({ blockTracker, }) {
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        if (!futureBlockRefRequests.includes(req.method)) {
            return next();
        }
        // eslint-disable-next-line node/callback-return
        await next();
        // abort if no result or no block number
        const responseBlockNumber = getResultBlockNumber(res);
        if (!responseBlockNumber) {
            return undefined;
        }
        log('res.result.blockNumber exists, proceeding. res = %o', res);
        // if number is higher, suggest block-tracker check for a new block
        const blockNumber = Number.parseInt(responseBlockNumber, 16);
        // Typecast: If getCurrentBlock returns null, currentBlockNumber will be NaN, which is fine.
        const currentBlockNumber = Number.parseInt(blockTracker.getCurrentBlock(), 16);
        if (blockNumber > currentBlockNumber) {
            log('blockNumber from response is greater than current block number, refreshing current block number');
            await blockTracker.checkForLatestBlock();
        }
        return undefined;
    });
}
exports.createBlockTrackerInspectorMiddleware = createBlockTrackerInspectorMiddleware;
//# sourceMappingURL=block-tracker-inspector.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\fetch.js", {"./utils/timeout":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\timeout.js","eth-rpc-errors":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\eth-rpc-errors\\dist\\index.js","json-rpc-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cfetch.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFetchConfigFromReq = exports.createFetchMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const timeout_1 = require("./utils/timeout");
const RETRIABLE_ERRORS = [
    // ignore server overload errors
    'Gateway timeout',
    'ETIMEDOUT',
    // ignore server sent html error pages
    // or truncated json responses
    'failed to parse response body',
    // ignore errors where http req failed to establish
    'Failed to fetch',
];
/**
 * Create middleware for sending a JSON-RPC request to the given RPC URL.
 *
 * @param options - Options
 * @param options.btoa - Generates a base64-encoded string from a binary string.
 * @param options.fetch - The `fetch` function; expected to be equivalent to `window.fetch`.
 * @param options.rpcUrl - The URL to send the request to.
 * @param options.originHttpHeaderKey - If provider, the origin field for each JSON-RPC request
 * will be attached to each outgoing fetch request under this header.
 * @returns The fetch middleware.
 */
function createFetchMiddleware({ 
// eslint-disable-next-line @typescript-eslint/no-shadow
btoa, 
// eslint-disable-next-line @typescript-eslint/no-shadow
fetch, rpcUrl, originHttpHeaderKey, }) {
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, _next) => {
        const { fetchUrl, fetchParams } = createFetchConfigFromReq({
            btoa,
            req,
            rpcUrl,
            originHttpHeaderKey,
        });
        // attempt request multiple times
        const maxAttempts = 5;
        const retryInterval = 1000;
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            try {
                const fetchRes = await fetch(fetchUrl, fetchParams);
                // check for http errrors
                checkForHttpErrors(fetchRes);
                // parse response body
                const rawBody = await fetchRes.text();
                let fetchBody;
                try {
                    fetchBody = JSON.parse(rawBody);
                }
                catch (_) {
                    throw new Error(`FetchMiddleware - failed to parse response body: "${rawBody}"`);
                }
                const result = parseResponse(fetchRes, fetchBody);
                // set result and exit retry loop
                res.result = result;
                return;
            }
            catch (err) {
                const errMsg = err.toString();
                const isRetriable = RETRIABLE_ERRORS.some((phrase) => errMsg.includes(phrase));
                // re-throw error if not retriable
                if (!isRetriable) {
                    throw err;
                }
            }
            // delay before retrying
            await timeout_1.timeout(retryInterval);
        }
    });
}
exports.createFetchMiddleware = createFetchMiddleware;
function checkForHttpErrors(fetchRes) {
    // check for errors
    switch (fetchRes.status) {
        case 405:
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound();
        case 418:
            throw createRatelimitError();
        case 503:
        case 504:
            throw createTimeoutError();
        default:
            break;
    }
}
function parseResponse(fetchRes, body) {
    // check for error code
    if (fetchRes.status !== 200) {
        throw eth_rpc_errors_1.ethErrors.rpc.internal({
            message: `Non-200 status code: '${fetchRes.status}'`,
            data: body,
        });
    }
    // check for rpc error
    if (body.error) {
        throw eth_rpc_errors_1.ethErrors.rpc.internal({
            data: body.error,
        });
    }
    // return successful result
    return body.result;
}
/**
 * Generate `fetch` configuration for sending the given request to an RPC API.
 *
 * @param options - Options
 * @param options.btoa - Generates a base64-encoded string from a binary string.
 * @param options.rpcUrl - The URL to send the request to.
 * @param options.originHttpHeaderKey - If provider, the origin field for each JSON-RPC request
 * will be attached to each outgoing fetch request under this header.
 * @returns The fetch middleware.
 */
function createFetchConfigFromReq({ 
// eslint-disable-next-line @typescript-eslint/no-shadow
btoa, req, rpcUrl, originHttpHeaderKey, }) {
    const parsedUrl = new URL(rpcUrl);
    const fetchUrl = normalizeUrlFromParsed(parsedUrl);
    // prepare payload
    // copy only canonical json rpc properties
    const payload = {
        id: req.id,
        jsonrpc: req.jsonrpc,
        method: req.method,
        params: req.params,
    };
    // extract 'origin' parameter from request
    const originDomain = req.origin;
    // serialize request body
    const serializedPayload = JSON.stringify(payload);
    // configure fetch params
    const fetchParams = {
        method: 'POST',
        headers: {
            Accept: 'application/json',
            'Content-Type': 'application/json',
        },
        body: serializedPayload,
    };
    // encoded auth details as header (not allowed in fetch url)
    if (parsedUrl.username && parsedUrl.password) {
        const authString = `${parsedUrl.username}:${parsedUrl.password}`;
        const encodedAuth = btoa(authString);
        fetchParams.headers.Authorization = `Basic ${encodedAuth}`;
    }
    // optional: add request origin as header
    if (originHttpHeaderKey && originDomain) {
        fetchParams.headers[originHttpHeaderKey] = originDomain;
    }
    return { fetchUrl, fetchParams };
}
exports.createFetchConfigFromReq = createFetchConfigFromReq;
function normalizeUrlFromParsed(parsedUrl) {
    let result = '';
    result += parsedUrl.protocol;
    result += `//${parsedUrl.hostname}`;
    if (parsedUrl.port) {
        result += `:${parsedUrl.port}`;
    }
    result += `${parsedUrl.pathname}`;
    result += `${parsedUrl.search}`;
    return result;
}
function createRatelimitError() {
    return eth_rpc_errors_1.ethErrors.rpc.internal({ message: `Request is being rate limited.` });
}
function createTimeoutError() {
    let msg = `Gateway timeout. The request took too long to process. `;
    msg += `This can happen when querying logs over too wide a block range.`;
    return eth_rpc_errors_1.ethErrors.rpc.internal({ message: msg });
}
//# sourceMappingURL=fetch.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\fetch.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\index.js", {"./block-cache":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-cache.js","./block-ref":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-ref.js","./block-ref-rewrite":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js","./block-tracker-inspector":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js","./fetch":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\fetch.js","./inflight-cache":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\inflight-cache.js","./providerAsMiddleware":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js","./retryOnEmpty":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js","./wallet":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\wallet.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./block-cache"), exports);
__exportStar(require("./block-ref-rewrite"), exports);
__exportStar(require("./block-ref"), exports);
__exportStar(require("./block-tracker-inspector"), exports);
__exportStar(require("./fetch"), exports);
__exportStar(require("./inflight-cache"), exports);
__exportStar(require("./providerAsMiddleware"), exports);
__exportStar(require("./retryOnEmpty"), exports);
__exportStar(require("./wallet"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\inflight-cache.js", {"./logging-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\cache.js","clone":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\clone\\clone.js","json-rpc-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cinflight-cache.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createInflightCacheMiddleware = void 0;
const clone_1 = __importDefault(require("clone"));
const json_rpc_engine_1 = require("json-rpc-engine");
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'inflight-cache');
function createInflightCacheMiddleware() {
    const inflightRequests = {};
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        // allow cach to be skipped if so specified
        if (req.skipCache) {
            return next();
        }
        // get cacheId, if cacheable
        const cacheId = cache_1.cacheIdentifierForRequest(req);
        // if not cacheable, skip
        if (!cacheId) {
            log('Request is not cacheable, proceeding. req = %o', req);
            return next();
        }
        // check for matching requests
        let activeRequestHandlers = inflightRequests[cacheId];
        // if found, wait for the active request to be handled
        if (activeRequestHandlers) {
            // setup the response listener and wait for it to be called
            // it will handle copying the result and request fields
            log('Running %i handler(s) for request %o', activeRequestHandlers.length, req);
            await createActiveRequestHandler(res, activeRequestHandlers);
            return undefined;
        }
        // setup response handler array for subsequent requests
        activeRequestHandlers = [];
        inflightRequests[cacheId] = activeRequestHandlers;
        // allow request to be handled normally
        log('Carrying original request forward %o', req);
        // eslint-disable-next-line node/callback-return
        await next();
        // clear inflight requests
        delete inflightRequests[cacheId];
        // schedule activeRequestHandlers to be handled
        log('Running %i collected handler(s) for request %o', activeRequestHandlers.length, req);
        handleActiveRequest(res, activeRequestHandlers);
        // complete
        return undefined;
    });
    function createActiveRequestHandler(res, activeRequestHandlers) {
        const { resolve, promise } = deferredPromise();
        activeRequestHandlers.push((handledRes) => {
            // append a copy of the result and error to the response
            res.result = clone_1.default(handledRes.result);
            res.error = clone_1.default(handledRes.error);
            resolve();
        });
        return promise;
    }
    function handleActiveRequest(res, activeRequestHandlers) {
        // use setTimeout so we can resolve our original request first
        setTimeout(() => {
            activeRequestHandlers.forEach((handler) => {
                try {
                    handler(res);
                }
                catch (err) {
                    // catch error so all requests are handled correctly
                    console.error(err);
                }
            });
        });
    }
}
exports.createInflightCacheMiddleware = createInflightCacheMiddleware;
function deferredPromise() {
    let resolve;
    const promise = new Promise((_resolve) => {
        resolve = _resolve;
    });
    return { resolve, promise };
}
//# sourceMappingURL=inflight-cache.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\inflight-cache.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\logging-utils.js", {"@metamask/utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Clogging-utils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createModuleLogger = exports.projectLogger = void 0;
const utils_1 = require("@metamask/utils");
Object.defineProperty(exports, "createModuleLogger", { enumerable: true, get: function () { return utils_1.createModuleLogger; } });
exports.projectLogger = utils_1.createProjectLogger('eth-json-rpc-middleware');
//# sourceMappingURL=logging-utils.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\logging-utils.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5CproviderAsMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ethersProviderAsMiddleware = exports.providerAsMiddleware = void 0;
function providerAsMiddleware(provider) {
    return (req, res, _next, end) => {
        // send request to provider
        provider.sendAsync(req, (err, providerRes) => {
            // forward any error
            if (err instanceof Error) {
                return end(err);
            }
            // copy provider response onto original response
            Object.assign(res, providerRes);
            return end();
        });
    };
}
exports.providerAsMiddleware = providerAsMiddleware;
function ethersProviderAsMiddleware(provider) {
    return (req, res, _next, end) => {
        // send request to provider
        provider.send(req, (err, providerRes) => {
            // forward any error
            if (err) {
                // TODO: Remove this cast when next major `json-rpc-engine` release is out
                // The next release changes how errors are propogated.
                return end(err);
            }
            // copy provider response onto original response
            Object.assign(res, providerRes);
            return end();
        });
    };
}
exports.ethersProviderAsMiddleware = ethersProviderAsMiddleware;
//# sourceMappingURL=providerAsMiddleware.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js", {"./logging-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\cache.js","./utils/timeout":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\timeout.js","clone":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\clone\\clone.js","json-rpc-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-rpc-engine\\dist\\index.js","pify":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\pify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5CretryOnEmpty.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRetryOnEmptyMiddleware = void 0;
const clone_1 = __importDefault(require("clone"));
const json_rpc_engine_1 = require("json-rpc-engine");
const pify_1 = __importDefault(require("pify"));
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
const timeout_1 = require("./utils/timeout");
//
// RetryOnEmptyMiddleware will retry any request with an empty response that has
// a numbered block reference at or lower than the blockTracker's latest block.
// Its useful for dealing with load-balanced ethereum JSON RPC
// nodes that are not always in sync with each other.
//
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'retry-on-empty');
// empty values used to determine if a request should be retried
// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925
const emptyValues = [
    undefined,
    null,
    '\u003cnil\u003e',
];
function createRetryOnEmptyMiddleware({ provider, blockTracker, } = {}) {
    if (!provider) {
        throw Error('RetryOnEmptyMiddleware - mandatory "provider" option is missing.');
    }
    if (!blockTracker) {
        throw Error('RetryOnEmptyMiddleware - mandatory "blockTracker" option is missing.');
    }
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        const blockRefIndex = cache_1.blockTagParamIndex(req.method);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        // skip if not exact block references
        let blockRef = Array.isArray(req.params)
            ? req.params[blockRefIndex]
            : undefined;
        // omitted blockRef implies "latest"
        if (blockRef === undefined) {
            blockRef = 'latest';
        }
        // skip if non-number block reference
        if (['latest', 'pending'].includes(blockRef)) {
            return next();
        }
        // skip if block refernce is not a valid number
        const blockRefNumber = Number.parseInt(blockRef.slice(2), 16);
        if (Number.isNaN(blockRefNumber)) {
            return next();
        }
        // lookup latest block
        const latestBlockNumberHex = await blockTracker.getLatestBlock();
        const latestBlockNumber = Number.parseInt(latestBlockNumberHex.slice(2), 16);
        // skip if request block number is higher than current
        if (blockRefNumber > latestBlockNumber) {
            log('Requested block number %o is higher than latest block number %o, falling through to original request', blockRefNumber, latestBlockNumber);
            return next();
        }
        log('Requested block number %o is not higher than latest block number %o, trying request until non-empty response is received', blockRefNumber, latestBlockNumber);
        // create child request with specific block-ref
        const childRequest = clone_1.default(req);
        // attempt child request until non-empty response is received
        const childResponse = await retry(10, async () => {
            log('Performing request %o', childRequest);
            const attemptResponse = await pify_1.default(provider.sendAsync).call(provider, childRequest);
            log('Response is %o', attemptResponse);
            // verify result
            if (emptyValues.includes(attemptResponse.result)) {
                throw new Error(`RetryOnEmptyMiddleware - empty response "${JSON.stringify(attemptResponse)}" for request "${JSON.stringify(childRequest)}"`);
            }
            return attemptResponse;
        });
        log('Copying result %o and error %o', childResponse.result, childResponse.error);
        // copy child response onto original response
        res.result = childResponse.result;
        res.error = childResponse.error;
        return undefined;
    });
}
exports.createRetryOnEmptyMiddleware = createRetryOnEmptyMiddleware;
async function retry(maxRetries, asyncFn) {
    for (let index = 0; index < maxRetries; index++) {
        try {
            return await asyncFn();
        }
        catch (err) {
            log('(call %i) Request failed, waiting 1s to retry again...', index + 1);
            await timeout_1.timeout(1000);
        }
    }
    log('Retries exhausted');
    throw new Error('RetryOnEmptyMiddleware - retries exhausted');
}
//# sourceMappingURL=retryOnEmpty.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\cache.js", {"safe-stable-stringify":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\safe-stable-stringify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cutils%5Ccache.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cacheTypeForMethod = exports.blockTagParamIndex = exports.blockTagForRequest = exports.canCache = exports.cacheIdentifierForRequest = exports.CacheStrategy = void 0;
const safe_stable_stringify_1 = require("safe-stable-stringify");
const stringify = safe_stable_stringify_1.configure({ bigint: false, circularValue: Error });
/**
 * The cache strategy to use for a given method.
 */
var CacheStrategy;
(function (CacheStrategy) {
    /**
     * Cache per-block.
     */
    CacheStrategy["Block"] = "block";
    /**
     * Cache until a chain reorganization occurs.
     */
    CacheStrategy["Fork"] = "fork";
    /**
     * Never cache.
     */
    CacheStrategy["Never"] = "never";
    /**
     * Permanently cache.
     */
    CacheStrategy["Permanent"] = "perma";
})(CacheStrategy = exports.CacheStrategy || (exports.CacheStrategy = {}));
/*
 * Return a cache identifier for the given request.
 *
 * This identifier should include any request details that might impact the
 * response, with the exception of the block parameter if the `skipBlockRef`
 * option is set,
 *
 * If the request cannot be cached, this will return `null`.
 *
 * @param request - The JSON-RPC request.
 * @param skipBlockRef - Skip the block parameter when generating the cache
 * identifier.
 * @returns The cache identifier for this request, or `null` if it can't be
 * cached.
 */
function cacheIdentifierForRequest(request, skipBlockRef) {
    var _a;
    const simpleParams = skipBlockRef
        ? paramsWithoutBlockTag(request)
        : (_a = request.params) !== null && _a !== void 0 ? _a : [];
    if (canCache(request.method)) {
        return `${request.method}:${stringify(simpleParams)}`;
    }
    return null;
}
exports.cacheIdentifierForRequest = cacheIdentifierForRequest;
/**
 * Return whether a method can be cached or not.
 *
 * @param method - The method to check.
 * @returns Whether the method can be cached.
 */
function canCache(method) {
    return cacheTypeForMethod(method) !== CacheStrategy.Never;
}
exports.canCache = canCache;
/**
 * Return the block parameter for the given request, if it has one.
 *
 * @param request - The JSON-RPC request.
 * @returns The block parameter in the given request, or `undefined` if none was found.
 */
function blockTagForRequest(request) {
    if (!request.params) {
        return undefined;
    }
    const index = blockTagParamIndex(request.method);
    // Block tag param not passed.
    if (index === undefined ||
        !Array.isArray(request.params) ||
        index >= request.params.length) {
        return undefined;
    }
    return request.params[index];
}
exports.blockTagForRequest = blockTagForRequest;
/**
 * Return the request parameters without the block parameter.
 *
 * @param request - The JSON-RPC request.
 * @returns The request parameters with the block parameter removed, if one was found.
 */
function paramsWithoutBlockTag(request) {
    if (!request.params) {
        return [];
    }
    const index = blockTagParamIndex(request.method);
    // Block tag param not passed.
    if (index === undefined ||
        !Array.isArray(request.params) ||
        index >= request.params.length) {
        return request.params;
    }
    // eth_getBlockByNumber has the block tag first, then the optional includeTx? param
    if (request.method === 'eth_getBlockByNumber') {
        return request.params.slice(1);
    }
    return request.params.slice(0, index);
}
/**
 * Returns the index of the block parameter for the given method.
 *
 * @param method - A JSON-RPC method.
 * @returns The index of the block parameter for that method, or `undefined` if
 * there is no known block parameter.
 */
function blockTagParamIndex(method) {
    switch (method) {
        // blockTag is at index 2
        case 'eth_getStorageAt':
            return 2;
        // blockTag is at index 1
        case 'eth_getBalance':
        case 'eth_getCode':
        case 'eth_getTransactionCount':
        case 'eth_call':
            return 1;
        // blockTag is at index 0
        case 'eth_getBlockByNumber':
            return 0;
        // there is no blockTag
        default:
            return undefined;
    }
}
exports.blockTagParamIndex = blockTagParamIndex;
/**
 * Return the cache type used for the given method.
 *
 * @param method - A JSON-RPC method.
 * @returns The cache type to use for that method.
 */
function cacheTypeForMethod(method) {
    switch (method) {
        // cache permanently
        case 'web3_clientVersion':
        case 'web3_sha3':
        case 'eth_protocolVersion':
        case 'eth_getBlockTransactionCountByHash':
        case 'eth_getUncleCountByBlockHash':
        case 'eth_getCode':
        case 'eth_getBlockByHash':
        case 'eth_getTransactionByHash':
        case 'eth_getTransactionByBlockHashAndIndex':
        case 'eth_getTransactionReceipt':
        case 'eth_getUncleByBlockHashAndIndex':
        case 'eth_getCompilers':
        case 'eth_compileLLL':
        case 'eth_compileSolidity':
        case 'eth_compileSerpent':
        case 'shh_version':
        case 'test_permaCache':
            return CacheStrategy.Permanent;
        // cache until fork
        case 'eth_getBlockByNumber':
        case 'eth_getBlockTransactionCountByNumber':
        case 'eth_getUncleCountByBlockNumber':
        case 'eth_getTransactionByBlockNumberAndIndex':
        case 'eth_getUncleByBlockNumberAndIndex':
        case 'test_forkCache':
            return CacheStrategy.Fork;
        // cache for block
        case 'eth_gasPrice':
        case 'eth_blockNumber':
        case 'eth_getBalance':
        case 'eth_getStorageAt':
        case 'eth_getTransactionCount':
        case 'eth_call':
        case 'eth_estimateGas':
        case 'eth_getFilterLogs':
        case 'eth_getLogs':
        case 'test_blockCache':
            return CacheStrategy.Block;
        // never cache
        default:
            return CacheStrategy.Never;
    }
}
exports.cacheTypeForMethod = cacheTypeForMethod;
//# sourceMappingURL=cache.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\cache.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\timeout.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cutils%5Ctimeout.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.timeout = void 0;
/**
 * Wait the specified number of milliseconds.
 *
 * @param duration - The number of milliseconds to wait.
 * @returns A promise that resolves after the specified amount of time.
 */
function timeout(duration) {
    return new Promise((resolve) => setTimeout(resolve, duration));
}
exports.timeout = timeout;
//# sourceMappingURL=timeout.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\timeout.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\wallet.js", {"@metamask/eth-sig-util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-sig-util\\dist\\index.js","eth-rpc-errors":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\eth-rpc-errors\\dist\\index.js","json-rpc-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cwallet.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWalletMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const sigUtil = __importStar(require("@metamask/eth-sig-util"));
const eth_rpc_errors_1 = require("eth-rpc-errors");
function createWalletMiddleware({ getAccounts, processDecryptMessage, processEncryptionPublicKey, processEthSignMessage, processPersonalMessage, processTransaction, processSignTransaction, processTypedMessage, processTypedMessageV3, processTypedMessageV4, }) {
    if (!getAccounts) {
        throw new Error('opts.getAccounts is required');
    }
    return json_rpc_engine_1.createScaffoldMiddleware({
        // account lookups
        eth_accounts: json_rpc_engine_1.createAsyncMiddleware(lookupAccounts),
        eth_coinbase: json_rpc_engine_1.createAsyncMiddleware(lookupDefaultAccount),
        // tx signatures
        eth_sendTransaction: json_rpc_engine_1.createAsyncMiddleware(sendTransaction),
        eth_signTransaction: json_rpc_engine_1.createAsyncMiddleware(signTransaction),
        // message signatures
        eth_sign: json_rpc_engine_1.createAsyncMiddleware(ethSign),
        eth_signTypedData: json_rpc_engine_1.createAsyncMiddleware(signTypedData),
        eth_signTypedData_v3: json_rpc_engine_1.createAsyncMiddleware(signTypedDataV3),
        eth_signTypedData_v4: json_rpc_engine_1.createAsyncMiddleware(signTypedDataV4),
        personal_sign: json_rpc_engine_1.createAsyncMiddleware(personalSign),
        eth_getEncryptionPublicKey: json_rpc_engine_1.createAsyncMiddleware(encryptionPublicKey),
        eth_decrypt: json_rpc_engine_1.createAsyncMiddleware(decryptMessage),
        personal_ecRecover: json_rpc_engine_1.createAsyncMiddleware(personalRecover),
    });
    //
    // account lookups
    //
    async function lookupAccounts(req, res) {
        res.result = await getAccounts(req);
    }
    async function lookupDefaultAccount(req, res) {
        const accounts = await getAccounts(req);
        res.result = accounts[0] || null;
    }
    //
    // transaction signatures
    //
    async function sendTransaction(req, res) {
        if (!processTransaction) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const txParams = req.params[0] || {};
        txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
        res.result = await processTransaction(txParams, req);
    }
    async function signTransaction(req, res) {
        if (!processSignTransaction) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const txParams = req.params[0] || {};
        txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
        res.result = await processSignTransaction(txParams, req);
    }
    //
    // message signatures
    //
    async function ethSign(req, res) {
        if (!processEthSignMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        res.result = await processEthSignMessage(msgParams, req);
    }
    async function signTypedData(req, res) {
        if (!processTypedMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const message = req.params[0];
        const address = await validateAndNormalizeKeyholder(req.params[1], req);
        const version = 'V1';
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        res.result = await processTypedMessage(msgParams, req, version);
    }
    async function signTypedDataV3(req, res) {
        if (!processTypedMessageV3) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const version = 'V3';
        const msgParams = {
            data: message,
            from: address,
            version,
        };
        res.result = await processTypedMessageV3(msgParams, req, version);
    }
    async function signTypedDataV4(req, res) {
        if (!processTypedMessageV4) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const version = 'V4';
        const msgParams = {
            data: message,
            from: address,
            version,
        };
        res.result = await processTypedMessageV4(msgParams, req, version);
    }
    async function personalSign(req, res) {
        if (!processPersonalMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        // process normally
        const firstParam = req.params[0];
        const secondParam = req.params[1];
        // non-standard "extraParams" to be appended to our "msgParams" obj
        const extraParams = req.params[2] || {};
        // We initially incorrectly ordered these parameters.
        // To gracefully respect users who adopted this API early,
        // we are currently gracefully recovering from the wrong param order
        // when it is clearly identifiable.
        //
        // That means when the first param is definitely an address,
        // and the second param is definitely not, but is hex.
        let address, message;
        if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {
            let warning = `The eth_personalSign method requires params ordered `;
            warning += `[message, address]. This was previously handled incorrectly, `;
            warning += `and has been corrected automatically. `;
            warning += `Please switch this param order for smooth behavior in the future.`;
            res.warning = warning;
            address = firstParam;
            message = secondParam;
        }
        else {
            message = firstParam;
            address = secondParam;
        }
        address = await validateAndNormalizeKeyholder(address, req);
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        // eslint-disable-next-line require-atomic-updates
        res.result = await processPersonalMessage(msgParams, req);
    }
    async function personalRecover(req, res) {
        const message = req.params[0];
        const signature = req.params[1];
        const signerAddress = sigUtil.recoverPersonalSignature({
            data: message,
            signature,
        });
        res.result = signerAddress;
    }
    async function encryptionPublicKey(req, res) {
        if (!processEncryptionPublicKey) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        res.result = await processEncryptionPublicKey(address, req);
    }
    async function decryptMessage(req, res) {
        if (!processDecryptMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const ciphertext = req.params[0];
        const address = await validateAndNormalizeKeyholder(req.params[1], req);
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: ciphertext });
        res.result = await processDecryptMessage(msgParams, req);
    }
    //
    // utility
    //
    /**
     * Validates the keyholder address, and returns a normalized (i.e. lowercase)
     * copy of it.
     *
     * @param {string} address - The address to validate and normalize.
     * @param {Object} req - The request object.
     * @returns {string} - The normalized address, if valid. Otherwise, throws
     * an error
     */
    async function validateAndNormalizeKeyholder(address, req) {
        if (typeof address === 'string' &&
            address.length > 0 &&
            resemblesAddress(address)) {
            // Ensure that an "unauthorized" error is thrown if the requester does not have the `eth_accounts`
            // permission.
            const accounts = await getAccounts(req);
            const normalizedAccounts = accounts.map((_address) => _address.toLowerCase());
            const normalizedAddress = address.toLowerCase();
            if (normalizedAccounts.includes(normalizedAddress)) {
                return normalizedAddress;
            }
            throw eth_rpc_errors_1.ethErrors.provider.unauthorized();
        }
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: `Invalid parameters: must provide an Ethereum address.`,
        });
    }
}
exports.createWalletMiddleware = createWalletMiddleware;
function resemblesAddress(str) {
    // hex prefix 2 + 20 bytes
    return str.length === 2 + 20 * 2;
}
//# sourceMappingURL=wallet.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\wallet.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js", {"superstruct":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cassert.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertExhaustive = exports.assertStruct = exports.assert = exports.AssertionError = void 0;
const superstruct_1 = require("superstruct");
/**
 * Type guard for determining whether the given value is an error object with a
 * `message` property, such as an instance of Error.
 *
 * @param error - The object to check.
 * @returns True or false, depending on the result.
 */
function isErrorWithMessage(error) {
    return typeof error === 'object' && error !== null && 'message' in error;
}
/**
 * Check if a value is a constructor, i.e., a function that can be called with
 * the `new` keyword.
 *
 * @param fn - The value to check.
 * @returns `true` if the value is a constructor, or `false` otherwise.
 */
function isConstructable(fn) {
    var _a, _b;
    /* istanbul ignore next */
    return Boolean(typeof ((_b = (_a = fn === null || fn === void 0 ? void 0 : fn.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) === 'string');
}
/**
 * Get the error message from an unknown error object. If the error object has
 * a `message` property, that property is returned. Otherwise, the stringified
 * error object is returned.
 *
 * @param error - The error object to get the message from.
 * @returns The error message.
 */
function getErrorMessage(error) {
    const message = isErrorWithMessage(error) ? error.message : String(error);
    // If the error ends with a period, remove it, as we'll add our own period.
    if (message.endsWith('.')) {
        return message.slice(0, -1);
    }
    return message;
}
/**
 * Initialise an {@link AssertionErrorConstructor} error.
 *
 * @param ErrorWrapper - The error class to use.
 * @param message - The error message.
 * @returns The error object.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getError(ErrorWrapper, message) {
    if (isConstructable(ErrorWrapper)) {
        return new ErrorWrapper({
            message,
        });
    }
    return ErrorWrapper({
        message,
    });
}
/**
 * The default error class that is thrown if an assertion fails.
 */
class AssertionError extends Error {
    constructor(options) {
        super(options.message);
        this.code = 'ERR_ASSERTION';
    }
}
exports.AssertionError = AssertionError;
/**
 * Same as Node.js assert.
 * If the value is falsy, throws an error, does nothing otherwise.
 *
 * @throws {@link AssertionError} If value is falsy.
 * @param value - The test that should be truthy to pass.
 * @param message - Message to be passed to {@link AssertionError} or an
 * {@link Error} instance to throw.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}. If a custom error class is provided for
 * the `message` argument, this argument is ignored.
 */
function assert(value, message = 'Assertion failed.', 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper = AssertionError) {
    if (!value) {
        if (message instanceof Error) {
            throw message;
        }
        throw getError(ErrorWrapper, message);
    }
}
exports.assert = assert;
/**
 * Assert a value against a Superstruct struct.
 *
 * @param value - The value to validate.
 * @param struct - The struct to validate against.
 * @param errorPrefix - A prefix to add to the error message. Defaults to
 * "Assertion failed".
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the value is not valid.
 */
function assertStruct(value, struct, errorPrefix = 'Assertion failed', 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper = AssertionError) {
    try {
        (0, superstruct_1.assert)(value, struct);
    }
    catch (error) {
        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessage(error)}.`);
    }
}
exports.assertStruct = assertStruct;
/**
 * Use in the default case of a switch that you want to be fully exhaustive.
 * Using this function forces the compiler to enforce exhaustivity during
 * compile-time.
 *
 * @example
 * ```
 * const number = 1;
 * switch (number) {
 *   case 0:
 *     ...
 *   case 1:
 *     ...
 *   default:
 *     assertExhaustive(snapPrefix);
 * }
 * ```
 * @param _object - The object on which the switch is being operated.
 */
function assertExhaustive(_object) {
    throw new Error('Invalid branch reached. Should be detected during compilation.');
}
exports.assertExhaustive = assertExhaustive;
//# sourceMappingURL=assert.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\base64.js", {"./assert":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","superstruct":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cbase64.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.base64 = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
/**
 * Ensure that a provided string-based struct is valid base64.
 *
 * @param struct - The string based struct.
 * @param options - Optional options to specialize base64 validation. See {@link Base64Options} documentation.
 * @returns A superstruct validating base64.
 */
const base64 = (struct, options = {}) => {
    var _a, _b;
    const paddingRequired = (_a = options.paddingRequired) !== null && _a !== void 0 ? _a : false;
    const characterSet = (_b = options.characterSet) !== null && _b !== void 0 ? _b : 'base64';
    let letters;
    if (characterSet === 'base64') {
        letters = String.raw `[A-Za-z0-9+\/]`;
    }
    else {
        (0, assert_1.assert)(characterSet === 'base64url');
        letters = String.raw `[-_A-Za-z0-9]`;
    }
    let re;
    if (paddingRequired) {
        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, 'u');
    }
    else {
        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, 'u');
    }
    return (0, superstruct_1.pattern)(struct, re);
};
exports.base64 = base64;
//# sourceMappingURL=base64.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\base64.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\bytes.js", {"./assert":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","./hex":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\hex.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cbytes.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDataView = exports.concatBytes = exports.valueToBytes = exports.stringToBytes = exports.numberToBytes = exports.signedBigIntToBytes = exports.bigIntToBytes = exports.hexToBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToSignedBigInt = exports.bytesToBigInt = exports.bytesToHex = exports.assertIsBytes = exports.isBytes = void 0;
const assert_1 = require("./assert");
const hex_1 = require("./hex");
// '0'.charCodeAt(0) === 48
const HEX_MINIMUM_NUMBER_CHARACTER = 48;
// '9'.charCodeAt(0) === 57
const HEX_MAXIMUM_NUMBER_CHARACTER = 58;
const HEX_CHARACTER_OFFSET = 87;
/**
 * Memoized function that returns an array to be used as a lookup table for
 * converting bytes to hexadecimal values.
 *
 * The array is created lazily and then cached for future use. The benefit of
 * this approach is that the performance of converting bytes to hex is much
 * better than if we were to call `toString(16)` on each byte.
 *
 * The downside is that the array is created once and then never garbage
 * collected. This is not a problem in practice because the array is only 256
 * elements long.
 *
 * @returns A function that returns the lookup table.
 */
function getPrecomputedHexValuesBuilder() {
    // To avoid issues with tree shaking, we need to use a function to return the
    // array. This is because the array is only used in the `bytesToHex` function
    // and if we were to use a global variable, the array might be removed by the
    // tree shaker.
    const lookupTable = [];
    return () => {
        if (lookupTable.length === 0) {
            for (let i = 0; i < 256; i++) {
                lookupTable.push(i.toString(16).padStart(2, '0'));
            }
        }
        return lookupTable;
    };
}
/**
 * Function implementation of the {@link getPrecomputedHexValuesBuilder}
 * function.
 */
const getPrecomputedHexValues = getPrecomputedHexValuesBuilder();
/**
 * Check if a value is a `Uint8Array`.
 *
 * @param value - The value to check.
 * @returns Whether the value is a `Uint8Array`.
 */
function isBytes(value) {
    return value instanceof Uint8Array;
}
exports.isBytes = isBytes;
/**
 * Assert that a value is a `Uint8Array`.
 *
 * @param value - The value to check.
 * @throws If the value is not a `Uint8Array`.
 */
function assertIsBytes(value) {
    (0, assert_1.assert)(isBytes(value), 'Value must be a Uint8Array.');
}
exports.assertIsBytes = assertIsBytes;
/**
 * Convert a `Uint8Array` to a hexadecimal string.
 *
 * @param bytes - The bytes to convert to a hexadecimal string.
 * @returns The hexadecimal string.
 */
function bytesToHex(bytes) {
    assertIsBytes(bytes);
    if (bytes.length === 0) {
        return '0x';
    }
    const lookupTable = getPrecomputedHexValues();
    const hexadecimal = new Array(bytes.length);
    for (let i = 0; i < bytes.length; i++) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        hexadecimal[i] = lookupTable[bytes[i]];
    }
    return (0, hex_1.add0x)(hexadecimal.join(''));
}
exports.bytesToHex = bytesToHex;
/**
 * Convert a `Uint8Array` to a `bigint`.
 *
 * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.
 * To convert a two's complement encoded `Uint8Array` to a `bigint`, use
 * {@link bytesToSignedBigInt}.
 *
 * @param bytes - The bytes to convert to a `bigint`.
 * @returns The `bigint`.
 */
function bytesToBigInt(bytes) {
    assertIsBytes(bytes);
    const hexadecimal = bytesToHex(bytes);
    return BigInt(hexadecimal);
}
exports.bytesToBigInt = bytesToBigInt;
/**
 * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are
 * encoded in two's complement.
 *
 * To convert a `Uint8Array` to an unsigned `bigint` instead, use
 * {@link bytesToBigInt}.
 *
 * @see https://en.wikipedia.org/wiki/Two%27s_complement
 * @param bytes - The bytes to convert to a signed `bigint`.
 * @returns The signed `bigint`.
 */
function bytesToSignedBigInt(bytes) {
    assertIsBytes(bytes);
    let value = BigInt(0);
    for (const byte of bytes) {
        // eslint-disable-next-line no-bitwise
        value = (value << BigInt(8)) + BigInt(byte);
    }
    return BigInt.asIntN(bytes.length * 8, value);
}
exports.bytesToSignedBigInt = bytesToSignedBigInt;
/**
 * Convert a `Uint8Array` to a `number`.
 *
 * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.
 *
 * @param bytes - The bytes to convert to a number.
 * @returns The number.
 * @throws If the resulting number is not a safe integer.
 */
function bytesToNumber(bytes) {
    assertIsBytes(bytes);
    const bigint = bytesToBigInt(bytes);
    (0, assert_1.assert)(bigint <= BigInt(Number.MAX_SAFE_INTEGER), 'Number is not a safe integer. Use `bytesToBigInt` instead.');
    return Number(bigint);
}
exports.bytesToNumber = bytesToNumber;
/**
 * Convert a UTF-8 encoded `Uint8Array` to a `string`.
 *
 * @param bytes - The bytes to convert to a string.
 * @returns The string.
 */
function bytesToString(bytes) {
    assertIsBytes(bytes);
    return new TextDecoder().decode(bytes);
}
exports.bytesToString = bytesToString;
/**
 * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be
 * prefixed with `0x`. It accepts even and odd length strings.
 *
 * If the value is "0x", an empty `Uint8Array` is returned.
 *
 * @param value - The hexadecimal string to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function hexToBytes(value) {
    var _a;
    // "0x" is often used as empty byte array.
    if (((_a = value === null || value === void 0 ? void 0 : value.toLowerCase) === null || _a === void 0 ? void 0 : _a.call(value)) === '0x') {
        return new Uint8Array();
    }
    (0, hex_1.assertIsHexString)(value);
    // Remove the `0x` prefix if it exists, and pad the string to have an even
    // number of characters.
    const strippedValue = (0, hex_1.remove0x)(value).toLowerCase();
    const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;
    const bytes = new Uint8Array(normalizedValue.length / 2);
    for (let i = 0; i < bytes.length; i++) {
        // While this is not the prettiest way to convert a hexadecimal string to a
        // `Uint8Array`, it is a lot faster than using `parseInt` to convert each
        // character.
        const c1 = normalizedValue.charCodeAt(i * 2);
        const c2 = normalizedValue.charCodeAt(i * 2 + 1);
        const n1 = c1 -
            (c1 < HEX_MAXIMUM_NUMBER_CHARACTER
                ? HEX_MINIMUM_NUMBER_CHARACTER
                : HEX_CHARACTER_OFFSET);
        const n2 = c2 -
            (c2 < HEX_MAXIMUM_NUMBER_CHARACTER
                ? HEX_MINIMUM_NUMBER_CHARACTER
                : HEX_CHARACTER_OFFSET);
        bytes[i] = n1 * 16 + n2;
    }
    return bytes;
}
exports.hexToBytes = hexToBytes;
/**
 * Convert a `bigint` to a `Uint8Array`.
 *
 * This assumes that the `bigint` is an unsigned integer. To convert a signed
 * `bigint` instead, use {@link signedBigIntToBytes}.
 *
 * @param value - The bigint to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function bigIntToBytes(value) {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(value >= BigInt(0), 'Value must be a non-negative bigint.');
    const hexadecimal = value.toString(16);
    return hexToBytes(hexadecimal);
}
exports.bigIntToBytes = bigIntToBytes;
/**
 * Check if a `bigint` fits in a certain number of bytes.
 *
 * @param value - The `bigint` to check.
 * @param bytes - The number of bytes.
 * @returns Whether the `bigint` fits in the number of bytes.
 */
function bigIntFits(value, bytes) {
    (0, assert_1.assert)(bytes > 0);
    /* eslint-disable no-bitwise */
    const mask = value >> BigInt(31);
    return !(((~value & mask) + (value & ~mask)) >> BigInt(bytes * 8 + ~0));
    /* eslint-enable no-bitwise */
}
/**
 * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement
 * encoding to represent negative numbers.
 *
 * To convert an unsigned `bigint` to a `Uint8Array` instead, use
 * {@link bigIntToBytes}.
 *
 * @see https://en.wikipedia.org/wiki/Two%27s_complement
 * @param value - The number to convert to bytes.
 * @param byteLength - The length of the resulting `Uint8Array`. If the number
 * is larger than the maximum value that can be represented by the given length,
 * an error is thrown.
 * @returns The bytes as `Uint8Array`.
 */
function signedBigIntToBytes(value, byteLength) {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(typeof byteLength === 'number', 'Byte length must be a number.');
    (0, assert_1.assert)(byteLength > 0, 'Byte length must be greater than 0.');
    (0, assert_1.assert)(bigIntFits(value, byteLength), 'Byte length is too small to represent the given value.');
    // ESLint doesn't like mutating function parameters, so to avoid having to
    // disable the rule, we create a new variable.
    let numberValue = value;
    const bytes = new Uint8Array(byteLength);
    for (let i = 0; i < bytes.length; i++) {
        bytes[i] = Number(BigInt.asUintN(8, numberValue));
        // eslint-disable-next-line no-bitwise
        numberValue >>= BigInt(8);
    }
    return bytes.reverse();
}
exports.signedBigIntToBytes = signedBigIntToBytes;
/**
 * Convert a `number` to a `Uint8Array`.
 *
 * @param value - The number to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 * @throws If the number is not a safe integer.
 */
function numberToBytes(value) {
    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');
    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToBytes` instead.');
    const hexadecimal = value.toString(16);
    return hexToBytes(hexadecimal);
}
exports.numberToBytes = numberToBytes;
/**
 * Convert a `string` to a UTF-8 encoded `Uint8Array`.
 *
 * @param value - The string to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function stringToBytes(value) {
    (0, assert_1.assert)(typeof value === 'string', 'Value must be a string.');
    return new TextEncoder().encode(value);
}
exports.stringToBytes = stringToBytes;
/**
 * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,
 * a `bigint`, a `number`, or a `string`.
 *
 * This will attempt to guess the type of the value based on its type and
 * contents. For more control over the conversion, use the more specific
 * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.
 *
 * If the value is a `string`, and it is prefixed with `0x`, it will be
 * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a
 * UTF-8 string. To convert a hexadecimal string to bytes without interpreting
 * it as a UTF-8 string, use {@link hexToBytes} instead.
 *
 * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed
 * `bigint` to bytes, use {@link signedBigIntToBytes} instead.
 *
 * If the value is a `Uint8Array`, it will be returned as-is.
 *
 * @param value - The value to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function valueToBytes(value) {
    if (typeof value === 'bigint') {
        return bigIntToBytes(value);
    }
    if (typeof value === 'number') {
        return numberToBytes(value);
    }
    if (typeof value === 'string') {
        if (value.startsWith('0x')) {
            return hexToBytes(value);
        }
        return stringToBytes(value);
    }
    if (isBytes(value)) {
        return value;
    }
    throw new TypeError(`Unsupported value type: "${typeof value}".`);
}
exports.valueToBytes = valueToBytes;
/**
 * Concatenate multiple byte-like values into a single `Uint8Array`. The values
 * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses
 * {@link valueToBytes} under the hood to convert each value to bytes. Refer to
 * the documentation of that function for more information.
 *
 * @param values - The values to concatenate.
 * @returns The concatenated bytes as `Uint8Array`.
 */
function concatBytes(values) {
    const normalizedValues = new Array(values.length);
    let byteLength = 0;
    for (let i = 0; i < values.length; i++) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const value = valueToBytes(values[i]);
        normalizedValues[i] = value;
        byteLength += value.length;
    }
    const bytes = new Uint8Array(byteLength);
    for (let i = 0, offset = 0; i < normalizedValues.length; i++) {
        // While we could simply spread the values into an array and use
        // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.
        bytes.set(normalizedValues[i], offset);
        offset += normalizedValues[i].length;
    }
    return bytes;
}
exports.concatBytes = concatBytes;
/**
 * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience
 * function that avoids having to create a {@link DataView} manually, which
 * requires passing the `byteOffset` and `byteLength` parameters every time.
 *
 * Not passing the `byteOffset` and `byteLength` parameters can result in
 * unexpected behavior when the {@link Uint8Array} is a view of a larger
 * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.
 *
 * This function also supports Node.js {@link Buffer}s.
 *
 * @example
 * ```typescript
 * const bytes = new Uint8Array([1, 2, 3]);
 *
 * // This is equivalent to:
 * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
 * const dataView = createDataView(bytes);
 * ```
 * @param bytes - The bytes to create the {@link DataView} from.
 * @returns The {@link DataView}.
 */
function createDataView(bytes) {
    // To maintain compatibility with Node.js, we need to check if the bytes are
    // a Buffer. If so, we need to slice the buffer to get the underlying
    // ArrayBuffer.
    // eslint-disable-next-line no-restricted-globals
    if (typeof Buffer !== 'undefined' && bytes instanceof Buffer) {
        const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
        return new DataView(buffer);
    }
    return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
}
exports.createDataView = createDataView;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\bytes.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\checksum.js", {"./base64":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\base64.js","superstruct":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cchecksum.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChecksumStruct = void 0;
const superstruct_1 = require("superstruct");
const base64_1 = require("./base64");
exports.ChecksumStruct = (0, superstruct_1.size)((0, base64_1.base64)((0, superstruct_1.string)(), { paddingRequired: true }), 44, 44);
//# sourceMappingURL=checksum.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\checksum.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\coercers.js", {"./assert":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","./bytes":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\bytes.js","./hex":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\hex.js","superstruct":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Ccoercers.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHex = exports.createBytes = exports.createBigInt = exports.createNumber = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
const bytes_1 = require("./bytes");
const hex_1 = require("./hex");
const NumberLikeStruct = (0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.bigint)(), (0, superstruct_1.string)(), hex_1.StrictHexStruct]);
const NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);
const BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);
const BytesLikeStruct = (0, superstruct_1.union)([hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array)]);
const BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([hex_1.StrictHexStruct]), bytes_1.hexToBytes);
const HexCoercer = (0, superstruct_1.coerce)(hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);
/**
 * Create a number from a number-like value.
 *
 * - If the value is a number, it is returned as-is.
 * - If the value is a `bigint`, it is converted to a number.
 * - If the value is a string, it is interpreted as a decimal number.
 * - If the value is a hex string (i.e., it starts with "0x"), it is
 * interpreted as a hexadecimal number.
 *
 * This validates that the value is a number-like value, and that the resulting
 * number is not `NaN` or `Infinity`.
 *
 * @example
 * ```typescript
 * const value = createNumber('0x010203');
 * console.log(value); // 66051
 *
 * const otherValue = createNumber(123n);
 * console.log(otherValue); // 123
 * ```
 * @param value - The value to create the number from.
 * @returns The created number.
 * @throws If the value is not a number-like value, or if the resulting number
 * is `NaN` or `Infinity`.
 */
function createNumber(value) {
    try {
        const result = (0, superstruct_1.create)(value, NumberCoercer);
        (0, assert_1.assert)(Number.isFinite(result), `Expected a number-like value, got "${value}".`);
        return result;
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a number-like value, got "${value}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createNumber = createNumber;
/**
 * Create a `bigint` from a number-like value.
 *
 * - If the value is a number, it is converted to a `bigint`.
 * - If the value is a `bigint`, it is returned as-is.
 * - If the value is a string, it is interpreted as a decimal number and
 * converted to a `bigint`.
 * - If the value is a hex string (i.e., it starts with "0x"), it is
 * interpreted as a hexadecimal number and converted to a `bigint`.
 *
 * @example
 * ```typescript
 * const value = createBigInt('0x010203');
 * console.log(value); // 16909060n
 *
 * const otherValue = createBigInt(123);
 * console.log(otherValue); // 123n
 * ```
 * @param value - The value to create the bigint from.
 * @returns The created bigint.
 * @throws If the value is not a number-like value.
 */
function createBigInt(value) {
    try {
        // The `BigInt` constructor throws if the value is not a number-like value.
        // There is no need to validate the value manually.
        return (0, superstruct_1.create)(value, BigIntCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a number-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createBigInt = createBigInt;
/**
 * Create a byte array from a bytes-like value.
 *
 * - If the value is a byte array, it is returned as-is.
 * - If the value is a hex string (i.e., it starts with "0x"), it is interpreted
 * as a hexadecimal number and converted to a byte array.
 *
 * @example
 * ```typescript
 * const value = createBytes('0x010203');
 * console.log(value); // Uint8Array [ 1, 2, 3 ]
 *
 * const otherValue = createBytes('0x010203');
 * console.log(otherValue); // Uint8Array [ 1, 2, 3 ]
 * ```
 * @param value - The value to create the byte array from.
 * @returns The created byte array.
 * @throws If the value is not a bytes-like value.
 */
function createBytes(value) {
    if (typeof value === 'string' && value.toLowerCase() === '0x') {
        return new Uint8Array();
    }
    try {
        return (0, superstruct_1.create)(value, BytesCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createBytes = createBytes;
/**
 * Create a hexadecimal string from a bytes-like value.
 *
 * - If the value is a hex string (i.e., it starts with "0x"), it is returned
 * as-is.
 * - If the value is a `Uint8Array`, it is converted to a hex string.
 *
 * @example
 * ```typescript
 * const value = createHex(new Uint8Array([1, 2, 3]));
 * console.log(value); // '0x010203'
 *
 * const otherValue = createHex('0x010203');
 * console.log(otherValue); // '0x010203'
 * ```
 * @param value - The value to create the hex string from.
 * @returns The created hex string.
 * @throws If the value is not a bytes-like value.
 */
function createHex(value) {
    if ((value instanceof Uint8Array && value.length === 0) ||
        (typeof value === 'string' && value.toLowerCase() === '0x')) {
        return '0x';
    }
    try {
        return (0, superstruct_1.create)(value, HexCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createHex = createHex;
//# sourceMappingURL=coercers.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\coercers.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\collections.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Ccollections.js
      return function (require, module, exports) {
"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FrozenMap_map, _FrozenSet_set;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrozenSet = exports.FrozenMap = void 0;
/**
 * A {@link ReadonlyMap} that cannot be modified after instantiation.
 * The implementation uses an inner map hidden via a private field, and the
 * immutability guarantee relies on it being impossible to get a reference
 * to this map.
 */
class FrozenMap {
    constructor(entries) {
        _FrozenMap_map.set(this, void 0);
        __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries), "f");
        Object.freeze(this);
    }
    get size() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").size;
    }
    [(_FrozenMap_map = new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f")[Symbol.iterator]();
    }
    entries() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").entries();
    }
    forEach(callbackfn, thisArg) {
        // We have to wrap the specified callback in order to prevent it from
        // receiving a reference to the inner map.
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").forEach((value, key, _map) => callbackfn.call(thisArg, value, key, this));
    }
    get(key) {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").get(key);
    }
    has(key) {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").has(key);
    }
    keys() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").keys();
    }
    values() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").values();
    }
    toString() {
        return `FrozenMap(${this.size}) {${this.size > 0
            ? ` ${[...this.entries()]
                .map(([key, value]) => `${String(key)} => ${String(value)}`)
                .join(', ')} `
            : ''}}`;
    }
}
exports.FrozenMap = FrozenMap;
/**
 * A {@link ReadonlySet} that cannot be modified after instantiation.
 * The implementation uses an inner set hidden via a private field, and the
 * immutability guarantee relies on it being impossible to get a reference
 * to this set.
 */
class FrozenSet {
    constructor(values) {
        _FrozenSet_set.set(this, void 0);
        __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), "f");
        Object.freeze(this);
    }
    get size() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").size;
    }
    [(_FrozenSet_set = new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f")[Symbol.iterator]();
    }
    entries() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").entries();
    }
    forEach(callbackfn, thisArg) {
        // We have to wrap the specified callback in order to prevent it from
        // receiving a reference to the inner set.
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").forEach((value, value2, _set) => callbackfn.call(thisArg, value, value2, this));
    }
    has(value) {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").has(value);
    }
    keys() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").keys();
    }
    values() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").values();
    }
    toString() {
        return `FrozenSet(${this.size}) {${this.size > 0
            ? ` ${[...this.values()].map((member) => String(member)).join(', ')} `
            : ''}}`;
    }
}
exports.FrozenSet = FrozenSet;
Object.freeze(FrozenMap);
Object.freeze(FrozenMap.prototype);
Object.freeze(FrozenSet);
Object.freeze(FrozenSet.prototype);
//# sourceMappingURL=collections.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\collections.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\hex.js", {"./assert":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","superstruct":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Chex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.remove0x = exports.add0x = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isStrictHexString = exports.isHexString = exports.StrictHexStruct = exports.HexStruct = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
exports.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:0x)?[0-9a-f]+$/iu);
exports.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]+$/iu);
/**
 * Check if a string is a valid hex string.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid hex string.
 */
function isHexString(value) {
    return (0, superstruct_1.is)(value, exports.HexStruct);
}
exports.isHexString = isHexString;
/**
 * Strictly check if a string is a valid hex string. A valid hex string must
 * start with the "0x"-prefix.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid hex string.
 */
function isStrictHexString(value) {
    return (0, superstruct_1.is)(value, exports.StrictHexStruct);
}
exports.isStrictHexString = isStrictHexString;
/**
 * Assert that a value is a valid hex string.
 *
 * @param value - The value to check.
 * @throws If the value is not a valid hex string.
 */
function assertIsHexString(value) {
    (0, assert_1.assert)(isHexString(value), 'Value must be a hexadecimal string.');
}
exports.assertIsHexString = assertIsHexString;
/**
 * Assert that a value is a valid hex string. A valid hex string must start with
 * the "0x"-prefix.
 *
 * @param value - The value to check.
 * @throws If the value is not a valid hex string.
 */
function assertIsStrictHexString(value) {
    (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with "0x".');
}
exports.assertIsStrictHexString = assertIsStrictHexString;
/**
 * Add the `0x`-prefix to a hexadecimal string. If the string already has the
 * prefix, it is returned as-is.
 *
 * @param hexadecimal - The hexadecimal string to add the prefix to.
 * @returns The prefixed hexadecimal string.
 */
function add0x(hexadecimal) {
    if (hexadecimal.startsWith('0x')) {
        return hexadecimal;
    }
    if (hexadecimal.startsWith('0X')) {
        return `0x${hexadecimal.substring(2)}`;
    }
    return `0x${hexadecimal}`;
}
exports.add0x = add0x;
/**
 * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have
 * the prefix, it is returned as-is.
 *
 * @param hexadecimal - The hexadecimal string to remove the prefix from.
 * @returns The un-prefixed hexadecimal string.
 */
function remove0x(hexadecimal) {
    if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {
        return hexadecimal.substring(2);
    }
    return hexadecimal;
}
exports.remove0x = remove0x;
//# sourceMappingURL=hex.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\hex.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\index.js", {"./assert":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","./base64":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\base64.js","./bytes":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\bytes.js","./checksum":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\checksum.js","./coercers":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\coercers.js","./collections":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\collections.js","./hex":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\hex.js","./json":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\json.js","./logging":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\logging.js","./misc":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\misc.js","./number":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\number.js","./opaque":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\opaque.js","./time":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\time.js","./versions":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\versions.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./assert"), exports);
__exportStar(require("./base64"), exports);
__exportStar(require("./bytes"), exports);
__exportStar(require("./checksum"), exports);
__exportStar(require("./coercers"), exports);
__exportStar(require("./collections"), exports);
__exportStar(require("./hex"), exports);
__exportStar(require("./json"), exports);
__exportStar(require("./logging"), exports);
__exportStar(require("./misc"), exports);
__exportStar(require("./number"), exports);
__exportStar(require("./opaque"), exports);
__exportStar(require("./time"), exports);
__exportStar(require("./versions"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\json.js", {"./assert":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","./misc":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\misc.js","superstruct":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cjson.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateJsonAndGetSize = exports.getJsonRpcIdValidator = exports.assertIsJsonRpcError = exports.isJsonRpcError = exports.assertIsJsonRpcFailure = exports.isJsonRpcFailure = exports.assertIsJsonRpcSuccess = exports.isJsonRpcSuccess = exports.assertIsJsonRpcResponse = exports.isJsonRpcResponse = exports.assertIsPendingJsonRpcResponse = exports.isPendingJsonRpcResponse = exports.JsonRpcResponseStruct = exports.JsonRpcFailureStruct = exports.JsonRpcSuccessStruct = exports.PendingJsonRpcResponseStruct = exports.assertIsJsonRpcRequest = exports.isJsonRpcRequest = exports.assertIsJsonRpcNotification = exports.isJsonRpcNotification = exports.JsonRpcNotificationStruct = exports.JsonRpcRequestStruct = exports.JsonRpcParamsStruct = exports.JsonRpcErrorStruct = exports.JsonRpcIdStruct = exports.JsonRpcVersionStruct = exports.jsonrpc2 = exports.isValidJson = exports.JsonStruct = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
const misc_1 = require("./misc");
exports.JsonStruct = (0, superstruct_1.define)('Json', (value) => {
    const [isValid] = validateJsonAndGetSize(value, true);
    if (!isValid) {
        return 'Expected a valid JSON-serializable value';
    }
    return true;
});
/**
 * Check if the given value is a valid {@link Json} value, i.e., a value that is
 * serializable to JSON.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid {@link Json} value.
 */
function isValidJson(value) {
    return (0, superstruct_1.is)(value, exports.JsonStruct);
}
exports.isValidJson = isValidJson;
/**
 * The string '2.0'.
 */
exports.jsonrpc2 = '2.0';
exports.JsonRpcVersionStruct = (0, superstruct_1.literal)(exports.jsonrpc2);
exports.JsonRpcIdStruct = (0, superstruct_1.nullable)((0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.string)()]));
exports.JsonRpcErrorStruct = (0, superstruct_1.object)({
    code: (0, superstruct_1.integer)(),
    message: (0, superstruct_1.string)(),
    data: (0, superstruct_1.optional)(exports.JsonStruct),
    stack: (0, superstruct_1.optional)((0, superstruct_1.string)()),
});
exports.JsonRpcParamsStruct = (0, superstruct_1.optional)((0, superstruct_1.union)([(0, superstruct_1.record)((0, superstruct_1.string)(), exports.JsonStruct), (0, superstruct_1.array)(exports.JsonStruct)]));
exports.JsonRpcRequestStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    method: (0, superstruct_1.string)(),
    params: exports.JsonRpcParamsStruct,
});
exports.JsonRpcNotificationStruct = (0, superstruct_1.omit)(exports.JsonRpcRequestStruct, ['id']);
/**
 * Check if the given value is a valid {@link JsonRpcNotification} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcNotification}
 * object.
 */
function isJsonRpcNotification(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcNotificationStruct);
}
exports.isJsonRpcNotification = isJsonRpcNotification;
/**
 * Assert that the given value is a valid {@link JsonRpcNotification} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcNotification} object.
 */
function assertIsJsonRpcNotification(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcNotificationStruct, 'Invalid JSON-RPC notification', ErrorWrapper);
}
exports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;
/**
 * Check if the given value is a valid {@link JsonRpcRequest} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcRequest} object.
 */
function isJsonRpcRequest(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcRequestStruct);
}
exports.isJsonRpcRequest = isJsonRpcRequest;
/**
 * Assert that the given value is a valid {@link JsonRpcRequest} object.
 *
 * @param value - The JSON-RPC request or notification to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcRequest} object.
 */
function assertIsJsonRpcRequest(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcRequestStruct, 'Invalid JSON-RPC request', ErrorWrapper);
}
exports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;
exports.PendingJsonRpcResponseStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    result: (0, superstruct_1.optional)((0, superstruct_1.unknown)()),
    error: (0, superstruct_1.optional)(exports.JsonRpcErrorStruct),
});
exports.JsonRpcSuccessStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    result: exports.JsonStruct,
});
exports.JsonRpcFailureStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    error: exports.JsonRpcErrorStruct,
});
exports.JsonRpcResponseStruct = (0, superstruct_1.union)([
    exports.JsonRpcSuccessStruct,
    exports.JsonRpcFailureStruct,
]);
/**
 * Type guard to check whether specified JSON-RPC response is a
 * {@link PendingJsonRpcResponse}.
 *
 * @param response - The JSON-RPC response to check.
 * @returns Whether the specified JSON-RPC response is pending.
 */
function isPendingJsonRpcResponse(response) {
    return (0, superstruct_1.is)(response, exports.PendingJsonRpcResponseStruct);
}
exports.isPendingJsonRpcResponse = isPendingJsonRpcResponse;
/**
 * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.
 *
 * @param response - The JSON-RPC response to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link PendingJsonRpcResponse}
 * object.
 */
function assertIsPendingJsonRpcResponse(response, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(response, exports.PendingJsonRpcResponseStruct, 'Invalid pending JSON-RPC response', ErrorWrapper);
}
exports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;
/**
 * Type guard to check if a value is a {@link JsonRpcResponse}.
 *
 * @param response - The object to check.
 * @returns Whether the object is a JsonRpcResponse.
 */
function isJsonRpcResponse(response) {
    return (0, superstruct_1.is)(response, exports.JsonRpcResponseStruct);
}
exports.isJsonRpcResponse = isJsonRpcResponse;
/**
 * Assert that the given value is a valid {@link JsonRpcResponse} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcResponse} object.
 */
function assertIsJsonRpcResponse(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcResponseStruct, 'Invalid JSON-RPC response', ErrorWrapper);
}
exports.assertIsJsonRpcResponse = assertIsJsonRpcResponse;
/**
 * Check if the given value is a valid {@link JsonRpcSuccess} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.
 */
function isJsonRpcSuccess(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcSuccessStruct);
}
exports.isJsonRpcSuccess = isJsonRpcSuccess;
/**
 * Assert that the given value is a valid {@link JsonRpcSuccess} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcSuccess} object.
 */
function assertIsJsonRpcSuccess(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcSuccessStruct, 'Invalid JSON-RPC success response', ErrorWrapper);
}
exports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;
/**
 * Check if the given value is a valid {@link JsonRpcFailure} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcFailure} object.
 */
function isJsonRpcFailure(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcFailureStruct);
}
exports.isJsonRpcFailure = isJsonRpcFailure;
/**
 * Assert that the given value is a valid {@link JsonRpcFailure} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcFailure} object.
 */
function assertIsJsonRpcFailure(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcFailureStruct, 'Invalid JSON-RPC failure response', ErrorWrapper);
}
exports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;
/**
 * Check if the given value is a valid {@link JsonRpcError} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcError} object.
 */
function isJsonRpcError(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcErrorStruct);
}
exports.isJsonRpcError = isJsonRpcError;
/**
 * Assert that the given value is a valid {@link JsonRpcError} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcError} object.
 */
function assertIsJsonRpcError(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcErrorStruct, 'Invalid JSON-RPC error', ErrorWrapper);
}
exports.assertIsJsonRpcError = assertIsJsonRpcError;
/**
 * Gets a function for validating JSON-RPC request / response `id` values.
 *
 * By manipulating the options of this factory, you can control the behavior
 * of the resulting validator for some edge cases. This is useful because e.g.
 * `null` should sometimes but not always be permitted.
 *
 * Note that the empty string (`''`) is always permitted by the JSON-RPC
 * specification, but that kind of sucks and you may want to forbid it in some
 * instances anyway.
 *
 * For more details, see the
 * [JSON-RPC Specification](https://www.jsonrpc.org/specification).
 *
 * @param options - An options object.
 * @param options.permitEmptyString - Whether the empty string (i.e. `''`)
 * should be treated as a valid ID. Default: `true`
 * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)
 * should be treated as valid IDs. Default: `false`
 * @param options.permitNull - Whether `null` should be treated as a valid ID.
 * Default: `true`
 * @returns The JSON-RPC ID validator function.
 */
function getJsonRpcIdValidator(options) {
    const { permitEmptyString, permitFractions, permitNull } = Object.assign({ permitEmptyString: true, permitFractions: false, permitNull: true }, options);
    /**
     * Type guard for {@link JsonRpcId}.
     *
     * @param id - The JSON-RPC ID value to check.
     * @returns Whether the given ID is valid per the options given to the
     * factory.
     */
    const isValidJsonRpcId = (id) => {
        return Boolean((typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||
            (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||
            (permitNull && id === null));
    };
    return isValidJsonRpcId;
}
exports.getJsonRpcIdValidator = getJsonRpcIdValidator;
/**
 * Checks whether a value is JSON serializable and counts the total number
 * of bytes needed to store the serialized version of the value.
 *
 * @param jsObject - Potential JSON serializable object.
 * @param skipSizingProcess - Skip JSON size calculation (default: false).
 * @returns Tuple [isValid, plainTextSizeInBytes] containing a boolean that signals whether
 * the value was serializable and a number of bytes that it will use when serialized to JSON.
 */
function validateJsonAndGetSize(jsObject, skipSizingProcess = false) {
    const seenObjects = new Set();
    /**
     * Checks whether a value is JSON serializable and counts the total number
     * of bytes needed to store the serialized version of the value.
     *
     * This function assumes the encoding of the JSON is done in UTF-8.
     *
     * @param value - Potential JSON serializable value.
     * @param skipSizing - Skip JSON size calculation (default: false).
     * @returns Tuple [isValid, plainTextSizeInBytes] containing a boolean that signals whether
     * the value was serializable and a number of bytes that it will use when serialized to JSON.
     */
    function getJsonSerializableInfo(value, skipSizing) {
        if (value === undefined) {
            return [false, 0];
        }
        else if (value === null) {
            // Return already specified constant size for null (special object)
            return [true, skipSizing ? 0 : misc_1.JsonSize.Null];
        }
        // Check and calculate sizes for basic (and some special) types
        const typeOfValue = typeof value;
        try {
            if (typeOfValue === 'function') {
                return [false, 0];
            }
            else if (typeOfValue === 'string' || value instanceof String) {
                return [
                    true,
                    skipSizing
                        ? 0
                        : (0, misc_1.calculateStringSize)(value) + misc_1.JsonSize.Quote * 2,
                ];
            }
            else if (typeOfValue === 'boolean' || value instanceof Boolean) {
                if (skipSizing) {
                    return [true, 0];
                }
                // eslint-disable-next-line eqeqeq
                return [true, value == true ? misc_1.JsonSize.True : misc_1.JsonSize.False];
            }
            else if (typeOfValue === 'number' || value instanceof Number) {
                if (skipSizing) {
                    return [true, 0];
                }
                return [true, (0, misc_1.calculateNumberSize)(value)];
            }
            else if (value instanceof Date) {
                if (skipSizing) {
                    return [true, 0];
                }
                return [
                    true,
                    // Note: Invalid dates will serialize to null
                    isNaN(value.getDate())
                        ? misc_1.JsonSize.Null
                        : misc_1.JsonSize.Date + misc_1.JsonSize.Quote * 2,
                ];
            }
        }
        catch (_) {
            return [false, 0];
        }
        // If object is not plain and cannot be serialized properly,
        // stop here and return false for serialization
        if (!(0, misc_1.isPlainObject)(value) && !Array.isArray(value)) {
            return [false, 0];
        }
        // Circular object detection (handling)
        // Check if the same object already exists
        if (seenObjects.has(value)) {
            return [false, 0];
        }
        // Add new object to the seen objects set
        // Only the plain objects should be added (Primitive types are skipped)
        seenObjects.add(value);
        // Continue object decomposition
        try {
            return [
                true,
                Object.entries(value).reduce((sum, [key, nestedValue], idx, arr) => {
                    // Recursively process next nested object or primitive type
                    // eslint-disable-next-line prefer-const
                    let [valid, size] = getJsonSerializableInfo(nestedValue, skipSizing);
                    if (!valid) {
                        throw new Error('JSON validation did not pass. Validation process stopped.');
                    }
                    // Circular object detection
                    // Once a child node is visited and processed remove it from the set.
                    // This will prevent false positives with the same adjacent objects.
                    seenObjects.delete(value);
                    if (skipSizing) {
                        return 0;
                    }
                    // Objects will have be serialized with "key": value,
                    // therefore we include the key in the calculation here
                    const keySize = Array.isArray(value)
                        ? 0
                        : key.length + misc_1.JsonSize.Comma + misc_1.JsonSize.Colon * 2;
                    const separator = idx < arr.length - 1 ? misc_1.JsonSize.Comma : 0;
                    return sum + keySize + size + separator;
                }, 
                // Starts at 2 because the serialized JSON string data (plain text)
                // will minimally contain {}/[]
                skipSizing ? 0 : misc_1.JsonSize.Wrapper * 2),
            ];
        }
        catch (_) {
            return [false, 0];
        }
    }
    return getJsonSerializableInfo(jsObject, skipSizingProcess);
}
exports.validateJsonAndGetSize = validateJsonAndGetSize;
//# sourceMappingURL=json.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\json.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\logging.js", {"debug":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\debug\\src\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Clogging.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createModuleLogger = exports.createProjectLogger = void 0;
const debug_1 = __importDefault(require("debug"));
const globalLogger = (0, debug_1.default)('metamask');
/**
 * Creates a logger via the `debug` library whose log messages will be tagged
 * using the name of your project. By default, such messages will be
 * suppressed, but you can reveal them by setting the `DEBUG` environment
 * variable to `metamask:<projectName>`. You can also set this variable to
 * `metamask:*` if you want to see log messages from all MetaMask projects that
 * are also using this function to create their loggers.
 *
 * @param projectName - The name of your project. This should be the name of
 * your NPM package if you're developing one.
 * @returns An instance of `debug`.
 */
function createProjectLogger(projectName) {
    return globalLogger.extend(projectName);
}
exports.createProjectLogger = createProjectLogger;
/**
 * Creates a logger via the `debug` library which is derived from the logger for
 * the whole project whose log messages will be tagged using the name of your
 * module. By default, such messages will be suppressed, but you can reveal them
 * by setting the `DEBUG` environment variable to
 * `metamask:<projectName>:<moduleName>`. You can also set this variable to
 * `metamask:<projectName>:*` if you want to see log messages from the project,
 * or `metamask:*` if you want to see log messages from all MetaMask projects.
 *
 * @param projectLogger - The logger created via {@link createProjectLogger}.
 * @param moduleName - The name of your module. You could use the name of the
 * file where you're using this logger or some other name.
 * @returns An instance of `debug`.
 */
function createModuleLogger(projectLogger, moduleName) {
    return projectLogger.extend(moduleName);
}
exports.createModuleLogger = createModuleLogger;
//# sourceMappingURL=logging.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\logging.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\misc.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cmisc.js
      return function (require, module, exports) {
"use strict";
//
// Types
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateNumberSize = exports.calculateStringSize = exports.isASCII = exports.isPlainObject = exports.ESCAPE_CHARACTERS_REGEXP = exports.JsonSize = exports.hasProperty = exports.isObject = exports.isNullOrUndefined = exports.isNonEmptyArray = void 0;
//
// Type Guards
//
/**
 * A {@link NonEmptyArray} type guard.
 *
 * @template Element - The non-empty array member type.
 * @param value - The value to check.
 * @returns Whether the value is a non-empty array.
 */
function isNonEmptyArray(value) {
    return Array.isArray(value) && value.length > 0;
}
exports.isNonEmptyArray = isNonEmptyArray;
/**
 * Type guard for "nullishness".
 *
 * @param value - Any value.
 * @returns `true` if the value is null or undefined, `false` otherwise.
 */
function isNullOrUndefined(value) {
    return value === null || value === undefined;
}
exports.isNullOrUndefined = isNullOrUndefined;
/**
 * A type guard for {@link RuntimeObject}.
 *
 * @param value - The value to check.
 * @returns Whether the specified value has a runtime type of `object` and is
 * neither `null` nor an `Array`.
 */
function isObject(value) {
    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
}
exports.isObject = isObject;
//
// Other utility functions
//
/**
 * A type guard for ensuring an object has a property.
 *
 * @param objectToCheck - The object to check.
 * @param name - The property name to check for.
 * @returns Whether the specified object has an own property with the specified
 * name, regardless of whether it is enumerable or not.
 */
const hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);
exports.hasProperty = hasProperty;
/**
 * Predefined sizes (in Bytes) of specific parts of JSON structure.
 */
var JsonSize;
(function (JsonSize) {
    JsonSize[JsonSize["Null"] = 4] = "Null";
    JsonSize[JsonSize["Comma"] = 1] = "Comma";
    JsonSize[JsonSize["Wrapper"] = 1] = "Wrapper";
    JsonSize[JsonSize["True"] = 4] = "True";
    JsonSize[JsonSize["False"] = 5] = "False";
    JsonSize[JsonSize["Quote"] = 1] = "Quote";
    JsonSize[JsonSize["Colon"] = 1] = "Colon";
    // eslint-disable-next-line @typescript-eslint/no-shadow
    JsonSize[JsonSize["Date"] = 24] = "Date";
})(JsonSize = exports.JsonSize || (exports.JsonSize = {}));
/**
 * Regular expression with pattern matching for (special) escaped characters.
 */
exports.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
/**
 * Check if the value is plain object.
 *
 * @param value - Value to be checked.
 * @returns True if an object is the plain JavaScript object,
 * false if the object is not plain (e.g. function).
 */
function isPlainObject(value) {
    if (typeof value !== 'object' || value === null) {
        return false;
    }
    try {
        let proto = value;
        while (Object.getPrototypeOf(proto) !== null) {
            proto = Object.getPrototypeOf(proto);
        }
        return Object.getPrototypeOf(value) === proto;
    }
    catch (_) {
        return false;
    }
}
exports.isPlainObject = isPlainObject;
/**
 * Check if character is ASCII.
 *
 * @param character - Character.
 * @returns True if a character code is ASCII, false if not.
 */
function isASCII(character) {
    return character.charCodeAt(0) <= 127;
}
exports.isASCII = isASCII;
/**
 * Calculate string size.
 *
 * @param value - String value to calculate size.
 * @returns Number of bytes used to store whole string value.
 */
function calculateStringSize(value) {
    var _a;
    const size = value.split('').reduce((total, character) => {
        if (isASCII(character)) {
            return total + 1;
        }
        return total + 2;
    }, 0);
    // Also detect characters that need backslash escape
    return size + ((_a = value.match(exports.ESCAPE_CHARACTERS_REGEXP)) !== null && _a !== void 0 ? _a : []).length;
}
exports.calculateStringSize = calculateStringSize;
/**
 * Calculate size of a number ofter JSON serialization.
 *
 * @param value - Number value to calculate size.
 * @returns Number of bytes used to store whole number in JSON.
 */
function calculateNumberSize(value) {
    return value.toString().length;
}
exports.calculateNumberSize = calculateNumberSize;
//# sourceMappingURL=misc.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\misc.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\number.js", {"./assert":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","./hex":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\hex.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cnumber.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hexToBigInt = exports.hexToNumber = exports.bigIntToHex = exports.numberToHex = void 0;
const assert_1 = require("./assert");
const hex_1 = require("./hex");
/**
 * Convert a number to a hexadecimal string. This verifies that the number is a
 * non-negative safe integer.
 *
 * To convert a `bigint` to a hexadecimal string instead, use
 * {@link bigIntToHex}.
 *
 * @example
 * ```typescript
 * numberToHex(0); // '0x0'
 * numberToHex(1); // '0x1'
 * numberToHex(16); // '0x10'
 * ```
 * @param value - The number to convert to a hexadecimal string.
 * @returns The hexadecimal string, with the "0x"-prefix.
 * @throws If the number is not a non-negative safe integer.
 */
const numberToHex = (value) => {
    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');
    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToHex` instead.');
    return (0, hex_1.add0x)(value.toString(16));
};
exports.numberToHex = numberToHex;
/**
 * Convert a `bigint` to a hexadecimal string. This verifies that the `bigint`
 * is a non-negative integer.
 *
 * To convert a number to a hexadecimal string instead, use {@link numberToHex}.
 *
 * @example
 * ```typescript
 * bigIntToHex(0n); // '0x0'
 * bigIntToHex(1n); // '0x1'
 * bigIntToHex(16n); // '0x10'
 * ```
 * @param value - The `bigint` to convert to a hexadecimal string.
 * @returns The hexadecimal string, with the "0x"-prefix.
 * @throws If the `bigint` is not a non-negative integer.
 */
const bigIntToHex = (value) => {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative bigint.');
    return (0, hex_1.add0x)(value.toString(16));
};
exports.bigIntToHex = bigIntToHex;
/**
 * Convert a hexadecimal string to a number. This verifies that the string is a
 * valid hex string, and that the resulting number is a safe integer. Both
 * "0x"-prefixed and unprefixed strings are supported.
 *
 * To convert a hexadecimal string to a `bigint` instead, use
 * {@link hexToBigInt}.
 *
 * @example
 * ```typescript
 * hexToNumber('0x0'); // 0
 * hexToNumber('0x1'); // 1
 * hexToNumber('0x10'); // 16
 * ```
 * @param value - The hexadecimal string to convert to a number.
 * @returns The number.
 * @throws If the value is not a valid hexadecimal string, or if the resulting
 * number is not a safe integer.
 */
const hexToNumber = (value) => {
    (0, hex_1.assertIsHexString)(value);
    // `parseInt` accepts values without the "0x"-prefix, whereas `Number` does
    // not. Using this is slightly faster than `Number(add0x(value))`.
    const numberValue = parseInt(value, 16);
    (0, assert_1.assert)(Number.isSafeInteger(numberValue), 'Value is not a safe integer. Use `hexToBigInt` instead.');
    return numberValue;
};
exports.hexToNumber = hexToNumber;
/**
 * Convert a hexadecimal string to a `bigint`. This verifies that the string is
 * a valid hex string. Both "0x"-prefixed and unprefixed strings are supported.
 *
 * To convert a hexadecimal string to a number instead, use {@link hexToNumber}.
 *
 * @example
 * ```typescript
 * hexToBigInt('0x0'); // 0n
 * hexToBigInt('0x1'); // 1n
 * hexToBigInt('0x10'); // 16n
 * ```
 * @param value - The hexadecimal string to convert to a `bigint`.
 * @returns The `bigint`.
 * @throws If the value is not a valid hexadecimal string.
 */
const hexToBigInt = (value) => {
    (0, hex_1.assertIsHexString)(value);
    // The `BigInt` constructor requires the "0x"-prefix to parse a hex string.
    return BigInt((0, hex_1.add0x)(value));
};
exports.hexToBigInt = hexToBigInt;
//# sourceMappingURL=number.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\number.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\opaque.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Copaque.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=opaque.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\opaque.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\time.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Ctime.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.timeSince = exports.inMilliseconds = exports.Duration = void 0;
/**
 * Common duration constants, in milliseconds.
 */
var Duration;
(function (Duration) {
    /**
     * A millisecond.
     */
    Duration[Duration["Millisecond"] = 1] = "Millisecond";
    /**
     * A second, in milliseconds.
     */
    Duration[Duration["Second"] = 1000] = "Second";
    /**
     * A minute, in milliseconds.
     */
    Duration[Duration["Minute"] = 60000] = "Minute";
    /**
     * An hour, in milliseconds.
     */
    Duration[Duration["Hour"] = 3600000] = "Hour";
    /**
     * A day, in milliseconds.
     */
    Duration[Duration["Day"] = 86400000] = "Day";
    /**
     * A week, in milliseconds.
     */
    Duration[Duration["Week"] = 604800000] = "Week";
    /**
     * A year, in milliseconds.
     */
    Duration[Duration["Year"] = 31536000000] = "Year";
})(Duration = exports.Duration || (exports.Duration = {}));
const isNonNegativeInteger = (number) => Number.isInteger(number) && number >= 0;
const assertIsNonNegativeInteger = (number, name) => {
    if (!isNonNegativeInteger(number)) {
        throw new Error(`"${name}" must be a non-negative integer. Received: "${number}".`);
    }
};
/**
 * Calculates the millisecond value of the specified number of units of time.
 *
 * @param count - The number of units of time.
 * @param duration - The unit of time to count.
 * @returns The count multiplied by the specified duration.
 */
function inMilliseconds(count, duration) {
    assertIsNonNegativeInteger(count, 'count');
    return count * duration;
}
exports.inMilliseconds = inMilliseconds;
/**
 * Gets the milliseconds since a particular Unix epoch timestamp.
 *
 * @param timestamp - A Unix millisecond timestamp.
 * @returns The number of milliseconds elapsed since the specified timestamp.
 */
function timeSince(timestamp) {
    assertIsNonNegativeInteger(timestamp, 'timestamp');
    return Date.now() - timestamp;
}
exports.timeSince = timeSince;
//# sourceMappingURL=time.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\time.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\versions.js", {"./assert":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","semver":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\index.js","superstruct":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cversions.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.satisfiesVersionRange = exports.gtRange = exports.gtVersion = exports.assertIsSemVerRange = exports.assertIsSemVerVersion = exports.isValidSemVerRange = exports.isValidSemVerVersion = exports.VersionRangeStruct = exports.VersionStruct = void 0;
const semver_1 = require("semver");
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
/**
 * A struct for validating a version string.
 */
exports.VersionStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version', (value) => {
    if ((0, semver_1.valid)(value) === null) {
        return `Expected SemVer version, got "${value}"`;
    }
    return true;
});
exports.VersionRangeStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version range', (value) => {
    if ((0, semver_1.validRange)(value) === null) {
        return `Expected SemVer range, got "${value}"`;
    }
    return true;
});
/**
 * Checks whether a SemVer version is valid.
 *
 * @param version - A potential version.
 * @returns `true` if the version is valid, and `false` otherwise.
 */
function isValidSemVerVersion(version) {
    return (0, superstruct_1.is)(version, exports.VersionStruct);
}
exports.isValidSemVerVersion = isValidSemVerVersion;
/**
 * Checks whether a SemVer version range is valid.
 *
 * @param versionRange - A potential version range.
 * @returns `true` if the version range is valid, and `false` otherwise.
 */
function isValidSemVerRange(versionRange) {
    return (0, superstruct_1.is)(versionRange, exports.VersionRangeStruct);
}
exports.isValidSemVerRange = isValidSemVerRange;
/**
 * Asserts that a value is a valid concrete SemVer version.
 *
 * @param version - A potential SemVer concrete version.
 */
function assertIsSemVerVersion(version) {
    (0, assert_1.assertStruct)(version, exports.VersionStruct);
}
exports.assertIsSemVerVersion = assertIsSemVerVersion;
/**
 * Asserts that a value is a valid SemVer range.
 *
 * @param range - A potential SemVer range.
 */
function assertIsSemVerRange(range) {
    (0, assert_1.assertStruct)(range, exports.VersionRangeStruct);
}
exports.assertIsSemVerRange = assertIsSemVerRange;
/**
 * Checks whether a SemVer version is greater than another.
 *
 * @param version1 - The left-hand version.
 * @param version2 - The right-hand version.
 * @returns `version1 > version2`.
 */
function gtVersion(version1, version2) {
    return (0, semver_1.gt)(version1, version2);
}
exports.gtVersion = gtVersion;
/**
 * Checks whether a SemVer version is greater than all possibilities in a range.
 *
 * @param version - A SemvVer version.
 * @param range - The range to check against.
 * @returns `version > range`.
 */
function gtRange(version, range) {
    return (0, semver_1.gtr)(version, range);
}
exports.gtRange = gtRange;
/**
 * Returns whether a SemVer version satisfies a SemVer range.
 *
 * @param version - The SemVer version to check.
 * @param versionRange - The SemVer version range to check against.
 * @returns Whether the version satisfied the version range.
 */
function satisfiesVersionRange(version, versionRange) {
    return (0, semver_1.satisfies)(version, versionRange, {
        includePrerelease: true,
    });
}
exports.satisfiesVersionRange = satisfiesVersionRange;
//# sourceMappingURL=versions.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\versions.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\pify\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5Cpify%5Cindex.js
      return function (require, module, exports) {
'use strict';

const processFn = (fn, opts) => function () {
	const P = opts.promiseModule;
	const args = new Array(arguments.length);

	for (let i = 0; i < arguments.length; i++) {
		args[i] = arguments[i];
	}

	return new P((resolve, reject) => {
		if (opts.errorFirst) {
			args.push(function (err, result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 1; i < arguments.length; i++) {
						results[i - 1] = arguments[i];
					}

					if (err) {
						results.unshift(err);
						reject(results);
					} else {
						resolve(results);
					}
				} else if (err) {
					reject(err);
				} else {
					resolve(result);
				}
			});
		} else {
			args.push(function (result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 0; i < arguments.length; i++) {
						results[i] = arguments[i];
					}

					resolve(results);
				} else {
					resolve(result);
				}
			});
		}

		fn.apply(this, args);
	});
};

module.exports = (obj, opts) => {
	opts = Object.assign({
		exclude: [/.+(Sync|Stream)$/],
		errorFirst: true,
		promiseModule: Promise
	}, opts);

	const filter = key => {
		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
	};

	let ret;
	if (typeof obj === 'function') {
		ret = function () {
			if (opts.excludeMain) {
				return obj.apply(this, arguments);
			}

			return processFn(obj, opts).apply(this, arguments);
		};
	} else {
		ret = Object.create(Object.getPrototypeOf(obj));
	}

	for (const key in obj) { // eslint-disable-line guard-for-in
		const x = obj[key];
		ret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;
	}

	return ret;
};

      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>pify",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\pify\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\index.js", {"./provider-from-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\provider-from-engine.js","./provider-from-middleware":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\provider-from-middleware.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-provider%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./provider-from-engine"), exports);
__exportStar(require("./provider-from-middleware"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-provider",file:"node_modules\\@metamask\\eth-json-rpc-provider\\dist\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\provider-from-engine.js", {"./safe-event-emitter-provider":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\safe-event-emitter-provider.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-provider%5Cdist%5Cprovider-from-engine.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.providerFromEngine = void 0;
const safe_event_emitter_provider_1 = require("./safe-event-emitter-provider");
/**
 * Construct an Ethereum provider from the given JSON-RPC engine.
 *
 * @param engine - The JSON-RPC engine to construct a provider from.
 * @returns An Ethereum provider.
 */
function providerFromEngine(engine) {
    return new safe_event_emitter_provider_1.SafeEventEmitterProvider({ engine });
}
exports.providerFromEngine = providerFromEngine;
//# sourceMappingURL=provider-from-engine.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-provider",file:"node_modules\\@metamask\\eth-json-rpc-provider\\dist\\provider-from-engine.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\provider-from-middleware.js", {"./provider-from-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\provider-from-engine.js","json-rpc-engine":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-provider%5Cdist%5Cprovider-from-middleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.providerFromMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const provider_from_engine_1 = require("./provider-from-engine");
/**
 * Construct an Ethereum provider from the given middleware.
 *
 * @param middleware - The middleware to construct a provider from.
 * @returns An Ethereum provider.
 */
function providerFromMiddleware(middleware) {
    const engine = new json_rpc_engine_1.JsonRpcEngine();
    engine.push(middleware);
    const provider = (0, provider_from_engine_1.providerFromEngine)(engine);
    return provider;
}
exports.providerFromMiddleware = providerFromMiddleware;
//# sourceMappingURL=provider-from-middleware.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-provider",file:"node_modules\\@metamask\\eth-json-rpc-provider\\dist\\provider-from-middleware.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\safe-event-emitter-provider.js", {"@metamask/safe-event-emitter":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\safe-event-emitter\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-json-rpc-provider%5Cdist%5Csafe-event-emitter-provider.js
      return function (require, module, exports) {
"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _SafeEventEmitterProvider_engine;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SafeEventEmitterProvider = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
/**
 * An Ethereum provider.
 *
 * This provider loosely follows conventions that pre-date EIP-1193.
 * It is not compliant with any Ethereum provider standard.
 */
class SafeEventEmitterProvider extends safe_event_emitter_1.default {
    /**
     * Construct a SafeEventEmitterProvider from a JSON-RPC engine.
     *
     * @param options - Options.
     * @param options.engine - The JSON-RPC engine used to process requests.
     */
    constructor({ engine }) {
        super();
        _SafeEventEmitterProvider_engine.set(this, void 0);
        /**
         * Send a provider request asynchronously.
         *
         * @param req - The request to send.
         * @param callback - A function that is called upon the success or failure of the request.
         */
        this.sendAsync = (req, callback) => {
            __classPrivateFieldGet(this, _SafeEventEmitterProvider_engine, "f").handle(req, callback);
        };
        /**
         * Send a provider request asynchronously.
         *
         * This method serves the same purpose as `sendAsync`. It only exists for
         * legacy reasons.
         *
         * @deprecated Use `sendAsync` instead.
         * @param req - The request to send.
         * @param callback - A function that is called upon the success or failure of the request.
         */
        this.send = (req, callback) => {
            if (typeof callback !== 'function') {
                throw new Error('Must provide callback to "send" method.');
            }
            __classPrivateFieldGet(this, _SafeEventEmitterProvider_engine, "f").handle(req, callback);
        };
        __classPrivateFieldSet(this, _SafeEventEmitterProvider_engine, engine, "f");
        if (engine.on) {
            engine.on('notification', (message) => {
                this.emit('data', null, message);
            });
        }
    }
}
exports.SafeEventEmitterProvider = SafeEventEmitterProvider;
_SafeEventEmitterProvider_engine = new WeakMap();
//# sourceMappingURL=safe-event-emitter-provider.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-provider",file:"node_modules\\@metamask\\eth-json-rpc-provider\\dist\\safe-event-emitter-provider.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-keyring-controller\\index.js", {"@metamask/browser-passworder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\browser-passworder\\dist\\index.js","@metamask/eth-hd-keyring":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-hd-keyring\\index.js","@metamask/eth-sig-util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-sig-util\\dist\\index.js","@metamask/eth-simple-keyring":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-simple-keyring\\index.js","events":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\events\\events.js","obs-store":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\obs-store\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-keyring-controller%5Cindex.js
      return function (require, module, exports) {
const encryptor = require('@metamask/browser-passworder');
const HdKeyring = require('@metamask/eth-hd-keyring');
const { normalize: normalizeAddress } = require('@metamask/eth-sig-util');
const SimpleKeyring = require('@metamask/eth-simple-keyring');
// TODO: Stop using `events`, and remove the notice about this from the README
// eslint-disable-next-line import/no-nodejs-modules
const { EventEmitter } = require('events');
const ObservableStore = require('obs-store');

const defaultKeyringBuilders = [
  keyringBuilderFactory(SimpleKeyring),
  keyringBuilderFactory(HdKeyring),
];

const KEYRINGS_TYPE_MAP = {
  HD_KEYRING: 'HD Key Tree',
  SIMPLE_KEYRING: 'Simple Key Pair',
};

/**
 * Strip the hex prefix from an address, if present.
 *
 * @param {string} address - The address that might be hex prefixed.
 * @returns {string} The address without a hex prefix.
 */
function stripHexPrefix(address) {
  if (address.startsWith('0x')) {
    return address.slice(2);
  }
  return address;
}

class KeyringController extends EventEmitter {
  //
  // PUBLIC METHODS
  //

  constructor(opts) {
    super();
    const initState = opts.initState || {};
    this.keyringBuilders = opts.keyringBuilders
      ? defaultKeyringBuilders.concat(opts.keyringBuilders)
      : defaultKeyringBuilders;
    this.store = new ObservableStore(initState);
    this.memStore = new ObservableStore({
      isUnlocked: false,
      keyringTypes: this.keyringBuilders.map(
        (keyringBuilder) => keyringBuilder.type,
      ),
      keyrings: [],
      encryptionKey: null,
    });

    this.encryptor = opts.encryptor || encryptor;
    this.keyrings = [];
    this._unsupportedKeyrings = [];

    // This option allows the controller to cache an exported key
    // for use in decrypting and encrypting data without password
    this.cacheEncryptionKey = Boolean(opts.cacheEncryptionKey);
  }

  /**
   * Full Update
   *
   * Emits the `update` event and @returns a Promise that resolves to
   * the current state.
   *
   * Frequently used to end asynchronous chains in this class,
   * indicating consumers can often either listen for updates,
   * or accept a state-resolving promise to consume their results.
   *
   * @returns {object} The controller state.
   */
  fullUpdate() {
    this.emit('update', this.memStore.getState());
    return this.memStore.getState();
  }

  /**
   * Create New Vault And Keychain
   *
   * Destroys any old encrypted storage,
   * creates a new encrypted store with the given password,
   * randomly creates a new HD wallet with 1 account,
   * faucets that account on the testnet.
   *
   * @fires KeyringController#unlock
   * @param {string} password - The password to encrypt the vault with.
   * @returns {Promise<object>} A Promise that resolves to the state.
   */
  async createNewVaultAndKeychain(password) {
    this.password = password;

    await this.createFirstKeyTree();
    this.setUnlocked();
    return this.fullUpdate();
  }

  /**
   * CreateNewVaultAndRestore
   *
   * Destroys any old encrypted storage,
   * creates a new encrypted store with the given password,
   * creates a new HD wallet from the given seed with 1 account.
   *
   * @fires KeyringController#unlock
   * @param {string} password - The password to encrypt the vault with.
   * @param {Uint8Array | string} seedPhrase - The BIP39-compliant seed phrase,
   * either as a string or Uint8Array.
   * @returns {Promise<object>} A Promise that resolves to the state.
   */
  async createNewVaultAndRestore(password, seedPhrase) {
    if (typeof password !== 'string') {
      throw new Error('Password must be text.');
    }
    this.password = password;

    await this.clearKeyrings();
    const keyring = await this.addNewKeyring(KEYRINGS_TYPE_MAP.HD_KEYRING, {
      mnemonic: seedPhrase,
      numberOfAccounts: 1,
    });
    const [firstAccount] = await keyring.getAccounts();

    if (!firstAccount) {
      throw new Error('KeyringController - First Account not found.');
    }
    this.setUnlocked();
    return this.fullUpdate();
  }

  /**
   * Set Locked
   * This method deallocates all secrets, and effectively locks MetaMask.
   *
   * @fires KeyringController#lock
   * @returns {Promise<object>} A Promise that resolves to the state.
   */
  async setLocked() {
    delete this.password;

    // set locked
    this.memStore.updateState({
      isUnlocked: false,
      encryptionKey: null,
      encryptionSalt: null,
    });

    // remove keyrings
    this.keyrings = [];
    await this._updateMemStoreKeyrings();
    this.emit('lock');
    return this.fullUpdate();
  }

  /**
   * Submit password.
   *
   * Attempts to decrypt the current vault and load its keyrings
   * into memory.
   *
   * Temporarily also migrates any old-style vaults first, as well
   * (Pre MetaMask 3.0.0).
   *
   * @fires KeyringController#unlock
   * @param {string} password - The keyring controller password.
   * @returns {Promise<object>} A Promise that resolves to the state.
   */
  async submitPassword(password) {
    this.keyrings = await this.unlockKeyrings(password);

    this.setUnlocked();
    return this.fullUpdate();
  }

  /**
   * Submit Encryption Key.
   *
   * Attempts to decrypt the current vault and load its keyrings
   * into memory based on the vault and CryptoKey information.
   *
   * @fires KeyringController#unlock
   * @param {string} encryptionKey - The encrypted key information used to decrypt the vault.
   * @param {string} encryptionSalt - The salt used to generate the last key.
   * @returns {Promise<object>} A Promise that resolves to the state.
   */
  async submitEncryptionKey(encryptionKey, encryptionSalt) {
    this.keyrings = await this.unlockKeyrings(
      undefined,
      encryptionKey,
      encryptionSalt,
    );
    this.setUnlocked();
    return this.fullUpdate();
  }

  /**
   * Verify Password
   *
   * Attempts to decrypt the current vault with a given password
   * to verify its validity.
   *
   * @param {string} password - The vault password.
   */
  async verifyPassword(password) {
    const encryptedVault = this.store.getState().vault;
    if (!encryptedVault) {
      throw new Error('Cannot unlock without a previous vault.');
    }
    await this.encryptor.decrypt(password, encryptedVault);
  }

  /**
   * Add New Keyring
   *
   * Adds a new Keyring of the given `type` to the vault
   * and the current decrypted Keyrings array.
   *
   * All Keyring classes implement a unique `type` string,
   * and this is used to retrieve them from the keyringBuilders array.
   *
   * @param {string} type - The type of keyring to add.
   * @param {object} opts - The constructor options for the keyring.
   * @returns {Promise<Keyring>} The new keyring.
   */
  async addNewKeyring(type, opts) {
    const keyring = await this._newKeyring(type, opts);

    if ((!opts || !opts.mnemonic) && type === KEYRINGS_TYPE_MAP.HD_KEYRING) {
      keyring.generateRandomMnemonic();
      await keyring.addAccounts();
    }

    const accounts = await keyring.getAccounts();
    await this.checkForDuplicate(type, accounts);

    this.keyrings.push(keyring);
    await this.persistAllKeyrings();

    this.fullUpdate();

    return keyring;
  }

  /**
   * Remove Empty Keyrings.
   *
   * Loops through the keyrings and removes the ones with empty accounts
   * (usually after removing the last / only account) from a keyring.
   */
  async removeEmptyKeyrings() {
    const validKeyrings = [];

    // Since getAccounts returns a Promise
    // We need to wait to hear back form each keyring
    // in order to decide which ones are now valid (accounts.length > 0)

    await Promise.all(
      this.keyrings.map(async (keyring) => {
        const accounts = await keyring.getAccounts();
        if (accounts.length > 0) {
          validKeyrings.push(keyring);
        }
      }),
    );
    this.keyrings = validKeyrings;
  }

  /**
   * Checks for duplicate keypairs, using the the first account in the given
   * array. Rejects if a duplicate is found.
   *
   * Only supports 'Simple Key Pair'.
   *
   * @param {string} type - The key pair type to check for.
   * @param {Array<string>} newAccountArray - Array of new accounts.
   * @returns {Promise<Array<string>>} The account, if no duplicate is found.
   */
  async checkForDuplicate(type, newAccountArray) {
    const accounts = await this.getAccounts();

    switch (type) {
      case KEYRINGS_TYPE_MAP.SIMPLE_KEYRING: {
        const isIncluded = Boolean(
          accounts.find(
            (key) =>
              key === newAccountArray[0] ||
              key === stripHexPrefix(newAccountArray[0]),
          ),
        );

        if (isIncluded) {
          throw new Error(
            'The account you are trying to import is a duplicate',
          );
        }
        return newAccountArray;
      }

      default: {
        return newAccountArray;
      }
    }
  }

  /**
   * Add New Account.
   *
   * Calls the `addAccounts` method on the given keyring,
   * and then saves those changes.
   *
   * @param {Keyring} selectedKeyring - The currently selected keyring.
   * @returns {Promise<object>} A Promise that resolves to the state.
   */
  async addNewAccount(selectedKeyring) {
    const accounts = await selectedKeyring.addAccounts(1);
    accounts.forEach((hexAccount) => {
      this.emit('newAccount', hexAccount);
    });

    await this.persistAllKeyrings();
    return this.fullUpdate();
  }

  /**
   * Export Account
   *
   * Requests the private key from the keyring controlling
   * the specified address.
   *
   * Returns a Promise that may resolve with the private key string.
   *
   * @param {string} address - The address of the account to export.
   * @returns {Promise<string>} The private key of the account.
   */
  async exportAccount(address) {
    const keyring = await this.getKeyringForAccount(address);
    return await keyring.exportAccount(normalizeAddress(address));
  }

  /**
   * Remove Account.
   *
   * Removes a specific account from a keyring
   * If the account is the last/only one then it also removes the keyring.
   *
   * @param {string} address - The address of the account to remove.
   * @returns {Promise<void>} A Promise that resolves if the operation was successful.
   */
  async removeAccount(address) {
    const keyring = await this.getKeyringForAccount(address);

    // Not all the keyrings support this, so we have to check
    if (typeof keyring.removeAccount === 'function') {
      keyring.removeAccount(address);
      this.emit('removedAccount', address);
    } else {
      throw new Error(
        `Keyring ${keyring.type} doesn't support account removal operations`,
      );
    }

    const accounts = await keyring.getAccounts();
    // Check if this was the last/only account
    if (accounts.length === 0) {
      await this.removeEmptyKeyrings();
    }

    await this.persistAllKeyrings();
    return this.fullUpdate();
  }

  //
  // SIGNING METHODS
  //

  /**
   * Sign Ethereum Transaction
   *
   * Signs an Ethereum transaction object.
   *
   * @param {object} ethTx - The transaction to sign.
   * @param {string} _fromAddress - The transaction 'from' address.
   * @param {object} opts - Signing options.
   * @returns {Promise<object>} The signed transaction object.
   */
  async signTransaction(ethTx, _fromAddress, opts = {}) {
    const fromAddress = normalizeAddress(_fromAddress);
    const keyring = await this.getKeyringForAccount(fromAddress);
    return await keyring.signTransaction(fromAddress, ethTx, opts);
  }

  /**
   * Sign Message
   *
   * Attempts to sign the provided message parameters.
   *
   * @param {object} msgParams - The message parameters to sign.
   * @param {object} opts - Additional signing options.
   * @returns {Promise<Buffer>} The raw signature.
   */
  async signMessage(msgParams, opts = {}) {
    const address = normalizeAddress(msgParams.from);
    const keyring = await this.getKeyringForAccount(address);
    return await keyring.signMessage(address, msgParams.data, opts);
  }

  /**
   * Sign Personal Message
   *
   * Attempts to sign the provided message parameters.
   * Prefixes the hash before signing per the personal sign expectation.
   *
   * @param {object} msgParams - The message parameters to sign.
   * @param {object} opts - Additional signing options.
   * @returns {Promise<Buffer>} The raw signature.
   */
  async signPersonalMessage(msgParams, opts = {}) {
    const address = normalizeAddress(msgParams.from);
    const keyring = await this.getKeyringForAccount(address);
    return await keyring.signPersonalMessage(address, msgParams.data, opts);
  }

  /**
   * Get encryption public key
   *
   * Get encryption public key for using in encrypt/decrypt process.
   *
   * @param {object} address - The address to get the encryption public key for.
   * @param {object} opts - Additional encryption options.
   * @returns {Promise<Buffer>} The public key.
   */
  async getEncryptionPublicKey(address, opts = {}) {
    const normalizedAddress = normalizeAddress(address);
    const keyring = await this.getKeyringForAccount(address);
    return await keyring.getEncryptionPublicKey(normalizedAddress, opts);
  }

  /**
   * Decrypt Message
   *
   * Attempts to decrypt the provided message parameters.
   *
   * @param {object} msgParams - The decryption message parameters.
   * @param {object} opts - Additional decryption options.
   * @returns {Promise<Buffer>} The raw decryption result.
   */
  async decryptMessage(msgParams, opts = {}) {
    const address = normalizeAddress(msgParams.from);
    const keyring = await this.getKeyringForAccount(address);
    return keyring.decryptMessage(address, msgParams.data, opts);
  }

  /**
   * Sign Typed Data.
   *
   * @see {@link https://github.com/ethereum/EIPs/pull/712#issuecomment-329988454|EIP712}.
   * @param {object} msgParams - The message parameters to sign.
   * @param {object} opts - Additional signing options.
   * @returns {Promise<Buffer>} The raw signature.
   */
  async signTypedMessage(msgParams, opts = { version: 'V1' }) {
    const address = normalizeAddress(msgParams.from);
    const keyring = await this.getKeyringForAccount(address);
    return keyring.signTypedData(address, msgParams.data, opts);
  }

  /**
   * Gets the app key address for the given Ethereum address and origin.
   *
   * @param {string} _address - The Ethereum address for the app key.
   * @param {string} origin - The origin for the app key.
   * @returns {string} The app key address.
   */
  async getAppKeyAddress(_address, origin) {
    const address = normalizeAddress(_address);
    const keyring = await this.getKeyringForAccount(address);
    return keyring.getAppKeyAddress(address, origin);
  }

  /**
   * Exports an app key private key for the given Ethereum address and origin.
   *
   * @param {string} _address - The Ethereum address for the app key.
   * @param {string} origin - The origin for the app key.
   * @returns {string} The app key private key.
   */
  async exportAppKeyForAddress(_address, origin) {
    const address = normalizeAddress(_address);
    const keyring = await this.getKeyringForAccount(address);
    // The "in" operator is typically restricted because it also checks inherited properties,
    // which can be unexpected for plain objects. We're allowing it here because `keyring` is not
    // a plain object, and we explicitly want to include inherited methods in this check.
    // eslint-disable-next-line no-restricted-syntax
    if (!('exportAccount' in keyring)) {
      throw new Error(
        `The keyring for address ${_address} does not support exporting.`,
      );
    }
    return keyring.exportAccount(address, { withAppKeyOrigin: origin });
  }

  //
  // PRIVATE METHODS
  //

  /**
   * Create First Key Tree.
   *
   * - Clears the existing vault.
   * - Creates a new vault.
   * - Creates a random new HD Keyring with 1 account.
   * - Makes that account the selected account.
   * - Faucets that account on testnet.
   * - Puts the current seed words into the state tree.
   *
   * @returns {Promise<void>} A promise that resolves if the operation was successful.
   */
  async createFirstKeyTree() {
    this.clearKeyrings();

    const keyring = await this.addNewKeyring(KEYRINGS_TYPE_MAP.HD_KEYRING);
    const [firstAccount] = await keyring.getAccounts();
    if (!firstAccount) {
      throw new Error('KeyringController - No account found on keychain.');
    }

    const hexAccount = normalizeAddress(firstAccount);
    this.emit('newVault', hexAccount);
    return null;
  }

  /**
   * Persist All Keyrings
   *
   * Iterates the current `keyrings` array,
   * serializes each one into a serialized array,
   * encrypts that array with the provided `password`,
   * and persists that encrypted string to storage.
   *
   * @returns {Promise<boolean>} Resolves to true once keyrings are persisted.
   */
  async persistAllKeyrings() {
    const { encryptionKey, encryptionSalt } = this.memStore.getState();

    if (!this.password && !encryptionKey) {
      throw new Error(
        'Cannot persist vault without password and encryption key',
      );
    }

    const serializedKeyrings = await Promise.all(
      this.keyrings.map(async (keyring) => {
        const [type, data] = await Promise.all([
          keyring.type,
          keyring.serialize(),
        ]);
        return { type, data };
      }),
    );

    serializedKeyrings.push(...this._unsupportedKeyrings);

    let vault;
    let newEncryptionKey;

    if (this.cacheEncryptionKey) {
      if (this.password) {
        const { vault: newVault, exportedKeyString } =
          await this.encryptor.encryptWithDetail(
            this.password,
            serializedKeyrings,
          );

        vault = newVault;
        newEncryptionKey = exportedKeyString;
      } else if (encryptionKey) {
        const key = await this.encryptor.importKey(encryptionKey);
        const vaultJSON = await this.encryptor.encryptWithKey(
          key,
          serializedKeyrings,
        );
        vaultJSON.salt = encryptionSalt;
        vault = JSON.stringify(vaultJSON);
      }
    } else {
      vault = await this.encryptor.encrypt(this.password, serializedKeyrings);
    }

    if (!vault) {
      throw new Error('Cannot persist vault without vault information');
    }

    this.store.updateState({ vault });

    // The keyring updates need to be announced before updating the encryptionKey
    // so that the updated keyring gets propagated to the extension first.
    // Not calling _updateMemStoreKeyrings results in the wrong account being selected
    // in the extension.
    await this._updateMemStoreKeyrings();

    if (newEncryptionKey) {
      this.memStore.updateState({
        encryptionKey: newEncryptionKey,
        encryptionSalt: JSON.parse(vault).salt,
      });
    }

    return true;
  }

  /**
   * Unlock Keyrings.
   *
   * Attempts to unlock the persisted encrypted storage,
   * initializing the persisted keyrings to RAM.
   *
   * @param {string} password - The keyring controller password.
   * @param {string} encryptionKey - An exported key string to unlock keyrings with.
   * @param {string} encryptionSalt - The salt used to encrypt the vault.
   * @returns {Promise<Array<Keyring>>} The keyrings.
   */
  async unlockKeyrings(password, encryptionKey, encryptionSalt) {
    const encryptedVault = this.store.getState().vault;
    if (!encryptedVault) {
      throw new Error('Cannot unlock without a previous vault.');
    }

    await this.clearKeyrings();

    let vault;

    if (this.cacheEncryptionKey) {
      if (password) {
        const result = await this.encryptor.decryptWithDetail(
          password,
          encryptedVault,
        );
        vault = result.vault;
        this.password = password;

        this.memStore.updateState({
          encryptionKey: result.exportedKeyString,
          encryptionSalt: result.salt,
        });
      } else {
        const parsedEncryptedVault = JSON.parse(encryptedVault);

        if (encryptionSalt !== parsedEncryptedVault.salt) {
          throw new Error('Encryption key and salt provided are expired');
        }

        const key = await this.encryptor.importKey(encryptionKey);
        vault = await this.encryptor.decryptWithKey(key, parsedEncryptedVault);

        // This call is required on the first call because encryptionKey
        // is not yet inside the memStore
        this.memStore.updateState({
          encryptionKey,
          encryptionSalt,
        });
      }
    } else {
      vault = await this.encryptor.decrypt(password, encryptedVault);
      this.password = password;
    }

    await Promise.all(vault.map(this._restoreKeyring.bind(this)));
    await this._updateMemStoreKeyrings();
    return this.keyrings;
  }

  /**
   * Restore Keyring
   *
   * Attempts to initialize a new keyring from the provided serialized payload.
   * On success, updates the memStore keyrings and returns the resulting
   * keyring instance.
   *
   * @param {object} serialized - The serialized keyring.
   * @returns {Promise<Keyring>} The deserialized keyring.
   */
  async restoreKeyring(serialized) {
    const keyring = await this._restoreKeyring(serialized);
    if (keyring) {
      await this._updateMemStoreKeyrings();
    }
    return keyring;
  }

  /**
   * Restore Keyring Helper
   *
   * Attempts to initialize a new keyring from the provided serialized payload.
   * On success, returns the resulting keyring instance.
   *
   * @param {object} serialized - The serialized keyring.
   * @returns {Promise<Keyring|undefined>} The deserialized keyring or undefined if the keyring type is unsupported.
   */
  async _restoreKeyring(serialized) {
    const { type, data } = serialized;

    const keyring = await this._newKeyring(type, data);
    if (!keyring) {
      this._unsupportedKeyrings.push(serialized);
      return undefined;
    }

    // getAccounts also validates the accounts for some keyrings
    await keyring.getAccounts();
    this.keyrings.push(keyring);
    return keyring;
  }

  /**
   * Get Keyring Class For Type
   *
   * Searches the current `keyringBuilders` array
   * for a Keyring builder whose unique `type` property
   * matches the provided `type`,
   * returning it if it exists.
   *
   * @param {string} type - The type whose class to get.
   * @returns {Keyring|undefined} The class, if it exists.
   */
  getKeyringBuilderForType(type) {
    return this.keyringBuilders.find(
      (keyringBuilder) => keyringBuilder.type === type,
    );
  }

  /**
   * Get Keyrings by Type
   *
   * Gets all keyrings of the given type.
   *
   * @param {string} type - The keyring types to retrieve.
   * @returns {Array<Keyring>} The keyrings.
   */
  getKeyringsByType(type) {
    return this.keyrings.filter((keyring) => keyring.type === type);
  }

  /**
   * Get Accounts
   *
   * Returns the public addresses of all current accounts
   * managed by all currently unlocked keyrings.
   *
   * @returns {Promise<Array<string>>} The array of accounts.
   */
  async getAccounts() {
    const keyrings = this.keyrings || [];

    const keyringArrays = await Promise.all(
      keyrings.map((keyring) => keyring.getAccounts()),
    );
    const addresses = keyringArrays.reduce((res, arr) => {
      return res.concat(arr);
    }, []);

    return addresses.map(normalizeAddress);
  }

  /**
   * Get Keyring For Account
   *
   * Returns the currently initialized keyring that manages
   * the specified `address` if one exists.
   *
   * @param {string} address - An account address.
   * @returns {Promise<Keyring>} The keyring of the account, if it exists.
   */
  async getKeyringForAccount(address) {
    const hexed = normalizeAddress(address);

    const candidates = await Promise.all(
      this.keyrings.map((keyring) => {
        return Promise.all([keyring, keyring.getAccounts()]);
      }),
    );

    const winners = candidates.filter((candidate) => {
      const accounts = candidate[1].map(normalizeAddress);
      return accounts.includes(hexed);
    });
    if (winners && winners.length > 0) {
      return winners[0][0];
    }

    // Adding more info to the error
    let errorInfo = '';
    if (!address) {
      errorInfo = 'The address passed in is invalid/empty';
    } else if (!candidates || !candidates.length) {
      errorInfo = 'There are no keyrings';
    } else if (!winners || !winners.length) {
      errorInfo = 'There are keyrings, but none match the address';
    }
    throw new Error(
      `No keyring found for the requested account. Error info: ${errorInfo}`,
    );
  }

  /**
   * Display For Keyring
   *
   * Is used for adding the current keyrings to the state object.
   *
   * @param {Keyring} keyring - The keyring to display.
   * @returns {Promise<object>} A keyring display object, with type and accounts properties.
   */
  async displayForKeyring(keyring) {
    const accounts = await keyring.getAccounts();

    return {
      type: keyring.type,
      accounts: accounts.map(normalizeAddress),
    };
  }

  /**
   * Clear Keyrings
   *
   * Deallocates all currently managed keyrings and accounts.
   * Used before initializing a new vault.
   */

  /* eslint-disable require-await */
  async clearKeyrings() {
    // clear keyrings from memory
    this.keyrings = [];
    this.memStore.updateState({
      keyrings: [],
    });
  }

  /**
   * Update memStore Keyrings
   *
   * Updates the in-memory keyrings, without persisting.
   */
  async _updateMemStoreKeyrings() {
    const keyrings = await Promise.all(
      this.keyrings.map(this.displayForKeyring),
    );
    return this.memStore.updateState({ keyrings });
  }

  /**
   * Unlock Keyrings
   *
   * Unlocks the keyrings.
   *
   * @fires KeyringController#unlock
   */
  setUnlocked() {
    this.memStore.updateState({ isUnlocked: true });
    this.emit('unlock');
  }

  /**
   * Forget hardware keyring.
   *
   * Forget hardware and update memorized state.
   *
   * @param {Keyring} keyring - The keyring to forget.
   */
  forgetKeyring(keyring) {
    if (keyring.forgetDevice) {
      keyring.forgetDevice();
      this.persistAllKeyrings();
    } else {
      throw new Error(
        `KeyringController - keyring does not have method "forgetDevice", keyring type: ${keyring.type}`,
      );
    }
  }

  /**
   * Instantiate, initialize and return a new keyring
   *
   * The keyring instantiated is of the given `type`.
   *
   * @param {string} type - The type of keyring to add.
   * @param {object} data - The data to restore a previously serialized keyring.
   * @returns {Promise<Keyring>} The new keyring.
   */
  async _newKeyring(type, data) {
    const keyringBuilder = this.getKeyringBuilderForType(type);

    if (!keyringBuilder) {
      return undefined;
    }

    const keyring = keyringBuilder();

    await keyring.deserialize(data);

    if (keyring.init) {
      await keyring.init();
    }

    return keyring;
  }
}

/**
 * Get builder function for `Keyring`
 *
 * Returns a builder function for `Keyring` with a `type` property.
 *
 * @param {Keyring} Keyring - The Keyring class for the builder.
 * @returns {Function} A builder function for the given Keyring.
 */
function keyringBuilderFactory(Keyring) {
  const builder = () => new Keyring();

  builder.type = Keyring.type;

  return builder;
}

module.exports = {
  KeyringController,
  keyringBuilderFactory,
};

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller",file:"node_modules\\@metamask\\eth-keyring-controller\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\index.js", {"@ethereumjs/tx":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ethereumjs\\tx\\dist\\index.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js","eth-sig-util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\index.js","ethereumjs-util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\ethereumjs-util\\dist.browser\\index.js","events":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\events\\events.js","hdkey":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\hdkey\\lib\\hdkey.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const { EventEmitter } = require('events')
const HDKey = require('hdkey')
const ethUtil = require('ethereumjs-util')
const sigUtil = require('eth-sig-util')
const { TransactionFactory } = require('@ethereumjs/tx')

const pathBase = 'm'
const hdPathString = `${pathBase}/44'/60'/0'`
const type = 'Ledger Hardware'

const BRIDGE_URL = 'https://metamask.github.io/eth-ledger-bridge-keyring'

const MAX_INDEX = 1000
const NETWORK_API_URLS = {
  ropsten: 'http://api-ropsten.etherscan.io',
  kovan: 'http://api-kovan.etherscan.io',
  rinkeby: 'https://api-rinkeby.etherscan.io',
  mainnet: 'https://api.etherscan.io',
}

const CONNECTION_EVENT = 'ledger-connection-change'

class LedgerBridgeKeyring extends EventEmitter {
  constructor (opts = {}) {
    super()
    this.accountDetails = {}
    this.bridgeUrl = null
    this.type = type
    this.page = 0
    this.perPage = 5
    this.unlockedAccount = 0
    this.hdk = new HDKey()
    this.paths = {}
    this.iframe = null
    this.network = 'mainnet'
    this.implementFullBIP44 = false
    this.deserialize(opts)

    this.iframeLoaded = false
    this._setupIframe()

    this.currentMessageId = 0
    this.messageCallbacks = {}
    this._setupListener()
  }

  serialize () {
    return Promise.resolve({
      hdPath: this.hdPath,
      accounts: this.accounts,
      accountDetails: this.accountDetails,
      bridgeUrl: this.bridgeUrl,
      implementFullBIP44: false,
    })
  }

  deserialize (opts = {}) {
    this.hdPath = opts.hdPath || hdPathString
    this.bridgeUrl = opts.bridgeUrl || BRIDGE_URL
    this.accounts = opts.accounts || []
    this.accountDetails = opts.accountDetails || {}
    if (!opts.accountDetails) {
      this._migrateAccountDetails(opts)
    }

    this.implementFullBIP44 = opts.implementFullBIP44 || false

    // Remove accounts that don't have corresponding account details
    this.accounts = this.accounts
      .filter((account) => Object.keys(this.accountDetails).includes(ethUtil.toChecksumAddress(account)))

    return Promise.resolve()
  }

  _migrateAccountDetails (opts) {
    if (this._isLedgerLiveHdPath() && opts.accountIndexes) {
      for (const account of Object.keys(opts.accountIndexes)) {
        this.accountDetails[account] = {
          bip44: true,
          hdPath: this._getPathForIndex(opts.accountIndexes[account]),
        }
      }
    }

    // try to migrate non-LedgerLive accounts too
    if (!this._isLedgerLiveHdPath()) {
      this.accounts
        .filter((account) => !Object.keys(this.accountDetails).includes(ethUtil.toChecksumAddress(account)))
        .forEach((account) => {
          try {
            this.accountDetails[ethUtil.toChecksumAddress(account)] = {
              bip44: false,
              hdPath: this._pathFromAddress(account),
            }
          } catch (e) {
            console.log(`failed to migrate account ${account}`)
          }
        })
    }
  }

  isUnlocked () {
    return Boolean(this.hdk && this.hdk.publicKey)
  }

  isConnected () {
    return this.isDeviceConnected
  }

  setAccountToUnlock (index) {
    this.unlockedAccount = parseInt(index, 10)
  }

  setHdPath (hdPath) {
    // Reset HDKey if the path changes
    if (this.hdPath !== hdPath) {
      this.hdk = new HDKey()
    }
    this.hdPath = hdPath
  }

  unlock (hdPath, updateHdk = true) {
    if (this.isUnlocked() && !hdPath) {
      return Promise.resolve('already unlocked')
    }
    const path = hdPath ? this._toLedgerPath(hdPath) : this.hdPath
    return new Promise((resolve, reject) => {
      this._sendMessage({
        action: 'ledger-unlock',
        params: {
          hdPath: path,
        },
      },
      ({ success, payload }) => {
        if (success) {
          if (updateHdk) {
            this.hdk.publicKey = Buffer.from(payload.publicKey, 'hex')
            this.hdk.chainCode = Buffer.from(payload.chainCode, 'hex')
          }
          resolve(payload.address)
        } else {
          reject(payload.error || new Error('Unknown error'))
        }
      })
    })
  }

  addAccounts (n = 1) {

    return new Promise((resolve, reject) => {
      this.unlock()
        .then(async (_) => {
          const from = this.unlockedAccount
          const to = from + n
          for (let i = from; i < to; i++) {
            const path = this._getPathForIndex(i)
            let address
            if (this._isLedgerLiveHdPath()) {
              address = await this.unlock(path)
            } else {
              address = this._addressFromIndex(pathBase, i)
            }
            this.accountDetails[ethUtil.toChecksumAddress(address)] = {
              // TODO: consider renaming this property, as the current name is misleading
              // It's currently used to represent whether an account uses the Ledger Live path.
              bip44: this._isLedgerLiveHdPath(),
              hdPath: path,
            }

            if (!this.accounts.includes(address)) {
              this.accounts.push(address)
            }
            this.page = 0
          }
          resolve(this.accounts)
        })
        .catch(reject)
    })
  }

  getFirstPage () {
    this.page = 0
    return this.__getPage(1)
  }

  getNextPage () {
    return this.__getPage(1)
  }

  getPreviousPage () {
    return this.__getPage(-1)
  }

  getAccounts () {
    return Promise.resolve(this.accounts.slice())
  }

  removeAccount (address) {
    if (!this.accounts.map((a) => a.toLowerCase()).includes(address.toLowerCase())) {
      throw new Error(`Address ${address} not found in this keyring`)
    }
    this.accounts = this.accounts.filter((a) => a.toLowerCase() !== address.toLowerCase())
    delete this.accountDetails[ethUtil.toChecksumAddress(address)]
  }

  attemptMakeApp () {
    return new Promise((resolve, reject) => {
      this._sendMessage({
        action: 'ledger-make-app',
      }, ({ success, error }) => {
        if (success) {
          resolve(true)
        } else {
          reject(error)
        }
      })
    })
  }

  updateTransportMethod (transportType) {
    return new Promise((resolve, reject) => {
      // If the iframe isn't loaded yet, let's store the desired transportType value and
      // optimistically return a successful promise
      if (!this.iframeLoaded) {
        this.delayedPromise = {
          resolve,
          reject,
          transportType,
        }
        return
      }

      this._sendMessage({
        action: 'ledger-update-transport',
        params: { transportType },
      }, ({ success }) => {
        if (success) {
          resolve(true)
        } else {
          reject(new Error('Ledger transport could not be updated'))
        }
      })
    })
  }

  // tx is an instance of the ethereumjs-transaction class.
  signTransaction (address, tx) {
    let rawTxHex
    // transactions built with older versions of ethereumjs-tx have a
    // getChainId method that newer versions do not. Older versions are mutable
    // while newer versions default to being immutable. Expected shape and type
    // of data for v, r and s differ (Buffer (old) vs BN (new))
    if (typeof tx.getChainId === 'function') {
      // In this version of ethereumjs-tx we must add the chainId in hex format
      // to the initial v value. The chainId must be included in the serialized
      // transaction which is only communicated to ethereumjs-tx in this
      // value. In newer versions the chainId is communicated via the 'Common'
      // object.
      tx.v = ethUtil.bufferToHex(tx.getChainId())
      tx.r = '0x00'
      tx.s = '0x00'

      rawTxHex = tx.serialize().toString('hex')

      return this._signTransaction(address, rawTxHex, (payload) => {
        tx.v = Buffer.from(payload.v, 'hex')
        tx.r = Buffer.from(payload.r, 'hex')
        tx.s = Buffer.from(payload.s, 'hex')
        return tx
      })
    }

    // The below `encode` call is only necessary for legacy transactions, as `getMessageToSign`
    // calls `rlp.encode` internally for non-legacy transactions. As per the "Transaction Execution"
    // section of the ethereum yellow paper, transactions need to be "well-formed RLP, with no additional
    // trailing bytes".

    // Note also that `getMessageToSign` will return valid RLP for all transaction types, whereas the
    // `serialize` method will not for any transaction type except legacy. This is because `serialize` includes
    // empty r, s and v values in the encoded rlp. This is why we use `getMessageToSign` here instead of `serialize`.
    const messageToSign = tx.getMessageToSign(false)

    rawTxHex = Buffer.isBuffer(messageToSign)
      ? messageToSign.toString('hex')
      : ethUtil.rlp.encode(messageToSign).toString('hex')

    return this._signTransaction(address, rawTxHex, (payload) => {
      // Because tx will be immutable, first get a plain javascript object that
      // represents the transaction. Using txData here as it aligns with the
      // nomenclature of ethereumjs/tx.
      const txData = tx.toJSON()
      // The fromTxData utility expects a type to support transactions with a type other than 0
      txData.type = tx.type
      // The fromTxData utility expects v,r and s to be hex prefixed
      txData.v = ethUtil.addHexPrefix(payload.v)
      txData.r = ethUtil.addHexPrefix(payload.r)
      txData.s = ethUtil.addHexPrefix(payload.s)
      // Adopt the 'common' option from the original transaction and set the
      // returned object to be frozen if the original is frozen.
      return TransactionFactory.fromTxData(txData, { common: tx.common, freeze: Object.isFrozen(tx) })
    })
  }

  _signTransaction (address, rawTxHex, handleSigning) {
    return new Promise((resolve, reject) => {
      this.unlockAccountByAddress(address)
        .then((hdPath) => {
          this._sendMessage({
            action: 'ledger-sign-transaction',
            params: {
              tx: rawTxHex,
              hdPath,
            },
          },
          ({ success, payload }) => {
            if (success) {

              const newOrMutatedTx = handleSigning(payload)
              const valid = newOrMutatedTx.verifySignature()
              if (valid) {
                resolve(newOrMutatedTx)
              } else {
                reject(new Error('Ledger: The transaction signature is not valid'))
              }
            } else {
              reject(payload.error || new Error('Ledger: Unknown error while signing transaction'))
            }
          })
        })
        .catch(reject)
    })
  }

  signMessage (withAccount, data) {
    return this.signPersonalMessage(withAccount, data)
  }

  // For personal_sign, we need to prefix the message:
  signPersonalMessage (withAccount, message) {
    return new Promise((resolve, reject) => {
      this.unlockAccountByAddress(withAccount)
        .then((hdPath) => {
          this._sendMessage({
            action: 'ledger-sign-personal-message',
            params: {
              hdPath,
              message: ethUtil.stripHexPrefix(message),
            },
          },
          ({ success, payload }) => {
            if (success) {
              let v = parseInt(payload.v, 10)
              v = v.toString(16)
              if (v.length < 2) {
                v = `0${v}`
              }
              const signature = `0x${payload.r}${payload.s}${v}`
              const addressSignedWith = sigUtil.recoverPersonalSignature({ data: message, sig: signature })
              if (ethUtil.toChecksumAddress(addressSignedWith) !== ethUtil.toChecksumAddress(withAccount)) {
                reject(new Error('Ledger: The signature doesnt match the right address'))
              }
              resolve(signature)
            } else {
              reject(payload.error || new Error('Ledger: Unknown error while signing message'))
            }
          })
        })
        .catch(reject)
    })
  }

  async unlockAccountByAddress (address) {
    const checksummedAddress = ethUtil.toChecksumAddress(address)
    if (!Object.keys(this.accountDetails).includes(checksummedAddress)) {
      throw new Error(`Ledger: Account for address '${checksummedAddress}' not found`)
    }
    const { hdPath } = this.accountDetails[checksummedAddress]
    const unlockedAddress = await this.unlock(hdPath, false)

    // unlock resolves to the address for the given hdPath as reported by the ledger device
    // if that address is not the requested address, then this account belongs to a different device or seed
    if (unlockedAddress.toLowerCase() !== address.toLowerCase()) {
      throw new Error(`Ledger: Account ${address} does not belong to the connected device`)
    }
    return hdPath
  }

  async signTypedData (withAccount, data, options = {}) {
    const isV4 = options.version === 'V4'
    if (!isV4) {
      throw new Error('Ledger: Only version 4 of typed data signing is supported')
    }

    const {
      domain,
      types,
      primaryType,
      message,
    } = sigUtil.TypedDataUtils.sanitizeData(data)
    const domainSeparatorHex = sigUtil.TypedDataUtils.hashStruct('EIP712Domain', domain, types, isV4).toString('hex')
    const hashStructMessageHex = sigUtil.TypedDataUtils.hashStruct(primaryType, message, types, isV4).toString('hex')

    const hdPath = await this.unlockAccountByAddress(withAccount)
    const { success, payload } = await new Promise((resolve) => {
      this._sendMessage({
        action: 'ledger-sign-typed-data',
        params: {
          hdPath,
          domainSeparatorHex,
          hashStructMessageHex,
        },
      },
      (result) => resolve(result))
    })

    if (success) {
      let v = parseInt(payload.v, 10)
      v = v.toString(16)
      if (v.length < 2) {
        v = `0${v}`
      }
      const signature = `0x${payload.r}${payload.s}${v}`
      const addressSignedWith = sigUtil.recoverTypedSignature_v4({
        data,
        sig: signature,
      })
      if (ethUtil.toChecksumAddress(addressSignedWith) !== ethUtil.toChecksumAddress(withAccount)) {
        throw new Error('Ledger: The signature doesnt match the right address')
      }
      return signature
    }
    throw payload.error || new Error('Ledger: Unknown error while signing message')
  }

  exportAccount () {
    throw new Error('Not supported on this device')
  }

  forgetDevice () {
    this.accounts = []
    this.page = 0
    this.unlockedAccount = 0
    this.paths = {}
    this.accountDetails = {}
    this.hdk = new HDKey()
  }

  /* PRIVATE METHODS */

  _setupIframe () {
    this.iframe = document.createElement('iframe')
    this.iframe.src = this.bridgeUrl
    this.iframe.allow = `hid 'src'`
    this.iframe.onload = async () => {
      // If the ledger live preference was set before the iframe is loaded,
      // set it after the iframe has loaded
      this.iframeLoaded = true
      if (this.delayedPromise) {
        try {
          const result = await this.updateTransportMethod(
            this.delayedPromise.transportType,
          )
          this.delayedPromise.resolve(result)
        } catch (e) {
          this.delayedPromise.reject(e)
        } finally {
          delete this.delayedPromise
        }
      }
    }
    document.head.appendChild(this.iframe)
  }

  _getOrigin () {
    const tmp = this.bridgeUrl.split('/')
    tmp.splice(-1, 1)
    return tmp.join('/')
  }

  _sendMessage (msg, cb) {
    msg.target = 'LEDGER-IFRAME'

    this.currentMessageId += 1
    msg.messageId = this.currentMessageId

    this.messageCallbacks[this.currentMessageId] = cb
    this.iframe.contentWindow.postMessage(msg, '*')
  }

  _setupListener () {
    this._eventListener = ({ origin, data }) => {
      if (origin !== this._getOrigin()) {
        return false
      }

      if (data) {
        if (this.messageCallbacks[data.messageId]) {
          this.messageCallbacks[data.messageId](data)
        } else if (data.action === CONNECTION_EVENT) {
          this.isDeviceConnected = data.payload.connected
        }
      }

      return undefined
    }
    window.addEventListener('message', this._eventListener)
  }

  destroy () {
    window.removeEventListener('message', this._eventListener)
  }

  async __getPage (increment) {

    this.page += increment

    if (this.page <= 0) {
      this.page = 1
    }
    const from = (this.page - 1) * this.perPage
    const to = from + this.perPage

    await this.unlock()
    let accounts
    if (this._isLedgerLiveHdPath()) {
      accounts = await this._getAccountsBIP44(from, to)
    } else {
      accounts = this._getAccountsLegacy(from, to)
    }
    return accounts
  }

  async _getAccountsBIP44 (from, to) {
    const accounts = []

    for (let i = from; i < to; i++) {
      const path = this._getPathForIndex(i)
      const address = await this.unlock(path)
      const valid = this.implementFullBIP44 ? await this._hasPreviousTransactions(address) : true
      accounts.push({
        address,
        balance: null,
        index: i,
      })
      // PER BIP44
      // "Software should prevent a creation of an account if
      // a previous account does not have a transaction history
      // (meaning none of its addresses have been used before)."
      if (!valid) {
        break
      }
    }
    return accounts
  }

  _getAccountsLegacy (from, to) {
    const accounts = []

    for (let i = from; i < to; i++) {
      const address = this._addressFromIndex(pathBase, i)
      accounts.push({
        address,
        balance: null,
        index: i,
      })
      this.paths[ethUtil.toChecksumAddress(address)] = i
    }
    return accounts
  }

  _padLeftEven (hex) {
    return hex.length % 2 === 0 ? hex : `0${hex}`
  }

  _normalize (buf) {
    return this._padLeftEven(ethUtil.bufferToHex(buf).toLowerCase())
  }

  // eslint-disable-next-line no-shadow
  _addressFromIndex (pathBase, i) {
    const dkey = this.hdk.derive(`${pathBase}/${i}`)
    const address = ethUtil
      .publicToAddress(dkey.publicKey, true)
      .toString('hex')
    return ethUtil.toChecksumAddress(`0x${address}`)
  }

  _pathFromAddress (address) {
    const checksummedAddress = ethUtil.toChecksumAddress(address)
    let index = this.paths[checksummedAddress]
    if (typeof index === 'undefined') {
      for (let i = 0; i < MAX_INDEX; i++) {
        if (checksummedAddress === this._addressFromIndex(pathBase, i)) {
          index = i
          break
        }
      }
    }

    if (typeof index === 'undefined') {
      throw new Error('Unknown address')
    }
    return this._getPathForIndex(index)
  }

  _toAscii (hex) {
    let str = ''
    let i = 0
    const l = hex.length
    if (hex.substring(0, 2) === '0x') {
      i = 2
    }
    for (; i < l; i += 2) {
      const code = parseInt(hex.substr(i, 2), 16)
      str += String.fromCharCode(code)
    }

    return str
  }

  _getPathForIndex (index) {
    // Check if the path is BIP 44 (Ledger Live)
    return this._isLedgerLiveHdPath() ? `m/44'/60'/${index}'/0/0` : `${this.hdPath}/${index}`
  }

  _isLedgerLiveHdPath () {
    return this.hdPath === `m/44'/60'/0'/0/0`
  }

  _toLedgerPath (path) {
    return path.toString().replace('m/', '')
  }

  async _hasPreviousTransactions (address) {
    const apiUrl = this._getApiUrl()
    const response = await window.fetch(`${apiUrl}/api?module=account&action=txlist&address=${address}&tag=latest&page=1&offset=1`)
    const parsedResponse = await response.json()
    if (parsedResponse.status !== '0' && parsedResponse.result.length > 0) {
      return true
    }
    return false
  }

  _getApiUrl () {
    return NETWORK_API_URLS[this.network] || NETWORK_API_URLS.mainnet
  }

}

LedgerBridgeKeyring.type = type
module.exports = LedgerBridgeKeyring

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\index.js", {"buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereumjs-abi":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\ethereumjs-abi\\index.js","ethereumjs-util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js","tweetnacl":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\tweetnacl\\nacl-fast.js","tweetnacl-util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\tweetnacl-util\\nacl-util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Ceth-sig-util%5Cindex.js
      return function (require, module, exports) {
const { Buffer } = require('buffer')
const ethUtil = require('ethereumjs-util')
const ethAbi = require('ethereumjs-abi')
const nacl = require('tweetnacl')
nacl.util = require('tweetnacl-util')

const TYPED_MESSAGE_SCHEMA = {
  type: 'object',
  properties: {
    types: {
      type: 'object',
      additionalProperties: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            name: { type: 'string' },
            type: { type: 'string' },
          },
          required: ['name', 'type'],
        },
      },
    },
    primaryType: { type: 'string' },
    domain: { type: 'object' },
    message: { type: 'object' },
  },
  required: ['types', 'primaryType', 'domain', 'message'],
}

/**
 * A collection of utility functions used for signing typed data
 */
const TypedDataUtils = {

  /**
   * Encodes an object by encoding and concatenating each of its members
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of an object
   */
  encodeData (primaryType, data, types, useV4 = true) {
    const encodedTypes = ['bytes32']
    const encodedValues = [this.hashType(primaryType, types)]

    if (useV4) {
      const encodeField = (name, type, value) => {
        if (types[type] !== undefined) {
          return ['bytes32', value === null || value === undefined ?
            '0x0000000000000000000000000000000000000000000000000000000000000000' :
            ethUtil.keccak(this.encodeData(type, value, types, useV4))]
        }

        if (value === undefined) {
          throw new Error(`missing value for field ${name} of type ${type}`)
        }

        if (type === 'bytes') {
          return ['bytes32', ethUtil.keccak(value)]
        }

        if (type === 'string') {
          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
          if (typeof value === 'string') {
            value = Buffer.from(value, 'utf8')
          }
          return ['bytes32', ethUtil.keccak(value)]
        }

        if (type.lastIndexOf(']') === type.length - 1) {
          const parsedType = type.slice(0, type.lastIndexOf('['))
          const typeValuePairs = value.map((item) => encodeField(name, parsedType, item))
          return ['bytes32', ethUtil.keccak(ethAbi.rawEncode(
            typeValuePairs.map(([_type]) => _type),
            typeValuePairs.map(([, _value]) => _value),
          ))]
        }

        return [type, value]
      }

      for (const field of types[primaryType]) {
        const [type, value] = encodeField(field.name, field.type, data[field.name])
        encodedTypes.push(type)
        encodedValues.push(value)
      }
    } else {
      for (const field of types[primaryType]) {
        let value = data[field.name]
        if (value !== undefined) {
          if (field.type === 'bytes') {
            encodedTypes.push('bytes32')
            value = ethUtil.keccak(value)
            encodedValues.push(value)
          } else if (field.type === 'string') {
            encodedTypes.push('bytes32')
            // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
            if (typeof value === 'string') {
              value = Buffer.from(value, 'utf8')
            }
            value = ethUtil.keccak(value)
            encodedValues.push(value)
          } else if (types[field.type] !== undefined) {
            encodedTypes.push('bytes32')
            value = ethUtil.keccak(this.encodeData(field.type, value, types, useV4))
            encodedValues.push(value)
          } else if (field.type.lastIndexOf(']') === field.type.length - 1) {
            throw new Error('Arrays currently unimplemented in encodeData')
          } else {
            encodedTypes.push(field.type)
            encodedValues.push(value)
          }
        }
      }
    }

    return ethAbi.rawEncode(encodedTypes, encodedValues)
  },

  /**
   * Encodes the type of an object by encoding a comma delimited list of its members
   *
   * @param {string} primaryType - Root type to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of the type of an object
   */
  encodeType (primaryType, types) {
    let result = ''
    let deps = this.findTypeDependencies(primaryType, types).filter((dep) => dep !== primaryType)
    deps = [primaryType].concat(deps.sort())
    for (const type of deps) {
      const children = types[type]
      if (!children) {
        throw new Error(`No type definition specified: ${type}`)
      }
      result += `${type}(${types[type].map(({ name, type: _type }) => `${_type} ${name}`).join(',')})`
    }
    return result
  },

  /**
   * Finds all types within a type defintion object
   *
   * @param {string} primaryType - Root type
   * @param {Object} types - Type definitions
   * @param {Array} results - current set of accumulated types
   * @returns {Array} - Set of all types found in the type definition
   */
  findTypeDependencies (primaryType, types, results = []) {
    const [firstWord] = primaryType.match(/^\w*/u)
    primaryType = firstWord
    if (results.includes(primaryType) || types[primaryType] === undefined) {
      return results
    }
    results.push(primaryType)
    for (const field of types[primaryType]) {
      for (const dep of this.findTypeDependencies(field.type, types, results)) {
        !results.includes(dep) && results.push(dep)
      }
    }
    return results
  },

  /**
   * Hashes an object
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashStruct (primaryType, data, types, useV4 = true) {
    return ethUtil.keccak(this.encodeData(primaryType, data, types, useV4))
  },

  /**
   * Hashes the type of an object
   *
   * @param {string} primaryType - Root type to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashType (primaryType, types) {
    return ethUtil.keccak(this.encodeType(primaryType, types))
  },

  /**
   * Removes properties from a message object that are not defined per EIP-712
   *
   * @param {Object} data - typed message object
   * @returns {Object} - typed message object with only allowed fields
   */
  sanitizeData (data) {
    const sanitizedData = {}
    for (const key of Object.keys(TYPED_MESSAGE_SCHEMA.properties)) {
      data[key] && (sanitizedData[key] = data[key])
    }
    if (sanitizedData.types) {
      sanitizedData.types = { EIP712Domain: [], ...sanitizedData.types }
    }
    return sanitizedData
  },

  /**
   * Signs a typed message as per EIP-712 and returns its keccak hash
   *
   * @param {Object} typedData - Types message data to sign
   * @returns {string} - keccak hash of the resulting signed message
   */
  sign (typedData, useV4 = true) {
    const sanitizedData = this.sanitizeData(typedData)
    const parts = [Buffer.from('1901', 'hex')]
    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4))
    if (sanitizedData.primaryType !== 'EIP712Domain') {
      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4))
    }
    return ethUtil.keccak(Buffer.concat(parts))
  },
}

module.exports = {
  TYPED_MESSAGE_SCHEMA,
  TypedDataUtils,

  concatSig (v, r, s) {
    const rSig = ethUtil.fromSigned(r)
    const sSig = ethUtil.fromSigned(s)
    const vSig = ethUtil.bufferToInt(v)
    const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64)
    const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64)
    const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig))
    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex')
  },

  normalize (input) {
    if (!input) {
      return undefined
    }

    if (typeof input === 'number') {
      const buffer = ethUtil.toBuffer(input)
      input = ethUtil.bufferToHex(buffer)
    }

    if (typeof input !== 'string') {
      let msg = 'eth-sig-util.normalize() requires hex string or integer input.'
      msg += ` received ${typeof input}: ${input}`
      throw new Error(msg)
    }

    return ethUtil.addHexPrefix(input.toLowerCase())
  },

  personalSign (privateKey, msgParams) {
    const message = ethUtil.toBuffer(msgParams.data)
    const msgHash = ethUtil.hashPersonalMessage(message)
    const sig = ethUtil.ecsign(msgHash, privateKey)
    const serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
    return serialized
  },

  recoverPersonalSignature (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    const sender = ethUtil.publicToAddress(publicKey)
    const senderHex = ethUtil.bufferToHex(sender)
    return senderHex
  },

  extractPublicKey (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    return `0x${publicKey.toString('hex')}`
  },

  typedSignatureHash (typedData) {
    const hashBuffer = typedSignatureHash(typedData)
    return ethUtil.bufferToHex(hashBuffer)
  },

  signTypedDataLegacy (privateKey, msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const sig = ethUtil.ecsign(msgHash, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  recoverTypedSignatureLegacy (msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const publicKey = recoverPublicKey(msgHash, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  },

  encrypt (receiverPublicKey, msgParams, version) {

    switch (version) {
      case 'x25519-xsalsa20-poly1305': {
        if (typeof msgParams.data === 'undefined') {
          throw new Error('Cannot detect secret message, message params should be of the form {data: "secret message"} ')
        }
        // generate ephemeral keypair
        const ephemeralKeyPair = nacl.box.keyPair()

        // assemble encryption parameters - from string to UInt8
        let pubKeyUInt8Array
        try {
          pubKeyUInt8Array = nacl.util.decodeBase64(receiverPublicKey)
        } catch (err) {
          throw new Error('Bad public key')
        }

        const msgParamsUInt8Array = nacl.util.decodeUTF8(msgParams.data)
        const nonce = nacl.randomBytes(nacl.box.nonceLength)

        // encrypt
        const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey)

        // handle encrypted data
        const output = {
          version: 'x25519-xsalsa20-poly1305',
          nonce: nacl.util.encodeBase64(nonce),
          ephemPublicKey: nacl.util.encodeBase64(ephemeralKeyPair.publicKey),
          ciphertext: nacl.util.encodeBase64(encryptedMessage),
        }
        // return encrypted msg data
        return output
      }
      default:
        throw new Error('Encryption type/version not supported')

    }
  },

  encryptSafely (receiverPublicKey, msgParams, version) {

    const DEFAULT_PADDING_LENGTH = (2 ** 11)
    const NACL_EXTRA_BYTES = 16

    const { data } = msgParams
    if (!data) {
      throw new Error('Cannot encrypt empty msg.data')
    }

    if (typeof data === 'object' && data.toJSON) {
      // remove toJSON attack vector
      // TODO, check all possible children
      throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property')
    }

    // add padding
    const dataWithPadding = {
      data,
      padding: '',
    }

    // calculate padding
    const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8')
    const modVal = (dataLength % DEFAULT_PADDING_LENGTH)
    let padLength = 0
    // Only pad if necessary
    if (modVal > 0) {
      padLength = (DEFAULT_PADDING_LENGTH - modVal) - NACL_EXTRA_BYTES // nacl extra bytes
    }
    dataWithPadding.padding = '0'.repeat(padLength)

    const paddedMsgParams = { data: JSON.stringify(dataWithPadding) }
    return this.encrypt(receiverPublicKey, paddedMsgParams, version)
  },

  decrypt (encryptedData, receiverPrivateKey) {

    switch (encryptedData.version) {
      case 'x25519-xsalsa20-poly1305': {
        // string to buffer to UInt8Array
        const recieverPrivateKeyUint8Array = nacl_decodeHex(receiverPrivateKey)
        const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey

        // assemble decryption parameters
        const nonce = nacl.util.decodeBase64(encryptedData.nonce)
        const ciphertext = nacl.util.decodeBase64(encryptedData.ciphertext)
        const ephemPublicKey = nacl.util.decodeBase64(encryptedData.ephemPublicKey)

        // decrypt
        const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey)

        // return decrypted msg data
        let output
        try {
          output = nacl.util.encodeUTF8(decryptedMessage)
        } catch (err) {
          throw new Error('Decryption failed.')
        }

        if (output) {
          return output
        }
        throw new Error('Decryption failed.')
      }

      default:
        throw new Error('Encryption type/version not supported.')
    }
  },

  decryptSafely (encryptedData, receiverPrivateKey) {
    const dataWithPadding = JSON.parse(this.decrypt(encryptedData, receiverPrivateKey))
    return dataWithPadding.data
  },


  getEncryptionPublicKey (privateKey) {
    const privateKeyUint8Array = nacl_decodeHex(privateKey)
    const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey
    return nacl.util.encodeBase64(encryptionPublicKey)
  },


  /**
   * A generic entry point for all typed data methods to be passed, includes a version parameter.
   */
  signTypedMessage (privateKey, msgParams, version = 'V4') {
    switch (version) {
      case 'V1':
        return this.signTypedDataLegacy(privateKey, msgParams)
      case 'V3':
        return this.signTypedData(privateKey, msgParams)
      case 'V4':
      default:
        return this.signTypedData_v4(privateKey, msgParams)
    }
  },

  recoverTypedMessage (msgParams, version = 'V4') {
    switch (version) {
      case 'V1':
        return this.recoverTypedSignatureLegacy(msgParams)
      case 'V3':
        return this.recoverTypedSignature(msgParams)
      case 'V4':
      default:
        return this.recoverTypedSignature_v4(msgParams)
    }
  },

  signTypedData (privateKey, msgParams) {
    const message = TypedDataUtils.sign(msgParams.data, false)
    const sig = ethUtil.ecsign(message, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  signTypedData_v4 (privateKey, msgParams) {
    const message = TypedDataUtils.sign(msgParams.data)
    const sig = ethUtil.ecsign(message, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  recoverTypedSignature (msgParams) {
    const message = TypedDataUtils.sign(msgParams.data, false)
    const publicKey = recoverPublicKey(message, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  },

  recoverTypedSignature_v4 (msgParams) {
    const message = TypedDataUtils.sign(msgParams.data)
    const publicKey = recoverPublicKey(message, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  },

}

/**
 * @param typedData - Array of data along with types, as per EIP712.
 * @returns Buffer
 */
function typedSignatureHash (typedData) {
  const error = new Error('Expect argument to be non-empty array')
  if (typeof typedData !== 'object' || !typedData.length) {
    throw error
  }

  const data = typedData.map(function (e) {
    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value
  })
  const types = typedData.map(function (e) {
    return e.type
  })
  const schema = typedData.map(function (e) {
    if (!e.name) {
      throw error
    }
    return `${e.type} ${e.name}`
  })

  return ethAbi.soliditySHA3(
    ['bytes32', 'bytes32'],
    [
      ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema),
      ethAbi.soliditySHA3(types, data),
    ],
  )
}

function recoverPublicKey (hash, sig) {
  const signature = ethUtil.toBuffer(sig)
  const sigParams = ethUtil.fromRpcSig(signature)
  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s)
}

function getPublicKeyFor (msgParams) {
  const message = ethUtil.toBuffer(msgParams.data)
  const msgHash = ethUtil.hashPersonalMessage(message)
  return recoverPublicKey(msgHash, msgParams.sig)
}


function padWithZeroes (number, length) {
  let myString = `${number}`
  while (myString.length < length) {
    myString = `0${myString}`
  }
  return myString
}

// converts hex strings to the Uint8Array format used by nacl
function nacl_decodeHex (msgHex) {
  const msgBase64 = (Buffer.from(msgHex, 'hex')).toString('base64')
  return nacl.util.decodeBase64(msgBase64)
}



      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js", {"./secp256k1-adapter":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-adapter.js","assert":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\assert\\assert.js","bn.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\bn.js\\lib\\bn.js","create-hash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\create-hash\\browser.js","ethereum-cryptography/keccak":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethereum-cryptography\\keccak.js","ethjs-util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethjs-util\\lib\\index.js","rlp":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\rlp\\dist.browser\\index.js","safe-buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Ceth-sig-util%5Cnode_modules%5Cethereumjs-util%5Cdist%5Cindex.js
      return function (require, module, exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _require = require('ethereum-cryptography/keccak'),
    keccak224 = _require.keccak224,
    keccak384 = _require.keccak384,
    k256 = _require.keccak256,
    keccak512 = _require.keccak512;

var secp256k1 = require('./secp256k1-adapter');
var assert = require('assert');
var rlp = require('rlp');
var BN = require('bn.js');
var createHash = require('create-hash');
var Buffer = require('safe-buffer').Buffer;
Object.assign(exports, require('ethjs-util'));

/**
 * the max integer that this VM can handle (a ```BN```)
 * @var {BN} MAX_INTEGER
 */
exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);

/**
 * 2^256 (a ```BN```)
 * @var {BN} TWO_POW256
 */
exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);

/**
 * Keccak-256 hash of null (a ```String```)
 * @var {String} KECCAK256_NULL_S
 */
exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;

/**
 * Keccak-256 hash of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_NULL
 */
exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
exports.SHA3_NULL = exports.KECCAK256_NULL;

/**
 * Keccak-256 of an RLP of an empty array (a ```String```)
 * @var {String} KECCAK256_RLP_ARRAY_S
 */
exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;

/**
 * Keccak-256 of an RLP of an empty array (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP_ARRAY
 */
exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;

/**
 * Keccak-256 hash of the RLP of null  (a ```String```)
 * @var {String} KECCAK256_RLP_S
 */
exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;

/**
 * Keccak-256 hash of the RLP of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP
 */
exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');
exports.SHA3_RLP = exports.KECCAK256_RLP;

/**
 * [`BN`](https://github.com/indutny/bn.js)
 * @var {Function}
 */
exports.BN = BN;

/**
 * [`rlp`](https://github.com/ethereumjs/rlp)
 * @var {Function}
 */
exports.rlp = rlp;

/**
 * [`secp256k1`](https://github.com/cryptocoinjs/secp256k1-node/)
 * @var {Object}
 */
exports.secp256k1 = secp256k1;

/**
 * Returns a buffer filled with 0s
 * @method zeros
 * @param {Number} bytes  the number of bytes the buffer should be
 * @return {Buffer}
 */
exports.zeros = function (bytes) {
  return Buffer.allocUnsafe(bytes).fill(0);
};

/**
  * Returns a zero address
  * @method zeroAddress
  * @return {String}
  */
exports.zeroAddress = function () {
  var addressLength = 20;
  var zeroAddress = exports.zeros(addressLength);
  return exports.bufferToHex(zeroAddress);
};

/**
 * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @method lsetLength
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @param {Boolean} [right=false] whether to start padding form the left or right
 * @return {Buffer|Array}
 */
exports.setLengthLeft = exports.setLength = function (msg, length, right) {
  var buf = exports.zeros(length);
  msg = exports.toBuffer(msg);
  if (right) {
    if (msg.length < length) {
      msg.copy(buf);
      return buf;
    }
    return msg.slice(0, length);
  } else {
    if (msg.length < length) {
      msg.copy(buf, length - msg.length);
      return buf;
    }
    return msg.slice(-length);
  }
};

/**
 * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @return {Buffer|Array}
 */
exports.setLengthRight = function (msg, length) {
  return exports.setLength(msg, length, true);
};

/**
 * Trims leading zeros from a `Buffer` or an `Array`
 * @param {Buffer|Array|String} a
 * @return {Buffer|Array|String}
 */
exports.unpad = exports.stripZeros = function (a) {
  a = exports.stripHexPrefix(a);
  var first = a[0];
  while (a.length > 0 && first.toString() === '0') {
    a = a.slice(1);
    first = a[0];
  }
  return a;
};
/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param {*} v the value
 */
exports.toBuffer = function (v) {
  if (!Buffer.isBuffer(v)) {
    if (Array.isArray(v)) {
      v = Buffer.from(v);
    } else if (typeof v === 'string') {
      if (exports.isHexString(v)) {
        v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), 'hex');
      } else {
        v = Buffer.from(v);
      }
    } else if (typeof v === 'number') {
      v = exports.intToBuffer(v);
    } else if (v === null || v === undefined) {
      v = Buffer.allocUnsafe(0);
    } else if (BN.isBN(v)) {
      v = v.toArrayLike(Buffer);
    } else if (v.toArray) {
      // converts a BN to a Buffer
      v = Buffer.from(v.toArray());
    } else {
      throw new Error('invalid type');
    }
  }
  return v;
};

/**
 * Converts a `Buffer` to a `Number`
 * @param {Buffer} buf
 * @return {Number}
 * @throws If the input number exceeds 53 bits.
 */
exports.bufferToInt = function (buf) {
  return new BN(exports.toBuffer(buf)).toNumber();
};

/**
 * Converts a `Buffer` into a hex `String`
 * @param {Buffer} buf
 * @return {String}
 */
exports.bufferToHex = function (buf) {
  buf = exports.toBuffer(buf);
  return '0x' + buf.toString('hex');
};

/**
 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
 * @param {Buffer} num
 * @return {BN}
 */
exports.fromSigned = function (num) {
  return new BN(num).fromTwos(256);
};

/**
 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
 * @param {BN} num
 * @return {Buffer}
 */
exports.toUnsigned = function (num) {
  return Buffer.from(num.toTwos(256).toArray());
};

/**
 * Creates Keccak hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the Keccak width
 * @return {Buffer}
 */
exports.keccak = function (a, bits) {
  a = exports.toBuffer(a);
  if (!bits) bits = 256;

  switch (bits) {
    case 224:
      {
        return keccak224(a);
      }
    case 256:
      {
        return k256(a);
      }
    case 384:
      {
        return keccak384(a);
      }
    case 512:
      {
        return keccak512(a);
      }
    default:
      {
        throw new Error('Invald algorithm: keccak' + bits);
      }
  }
};

/**
 * Creates Keccak-256 hash of the input, alias for keccak(a, 256)
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.keccak256 = function (a) {
  return exports.keccak(a);
};

/**
 * Creates SHA-3 (Keccak) hash of the input [OBSOLETE]
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the SHA-3 width
 * @return {Buffer}
 */
exports.sha3 = exports.keccak;

/**
 * Creates SHA256 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.sha256 = function (a) {
  a = exports.toBuffer(a);
  return createHash('sha256').update(a).digest();
};

/**
 * Creates RIPEMD160 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Boolean} padded whether it should be padded to 256 bits or not
 * @return {Buffer}
 */
exports.ripemd160 = function (a, padded) {
  a = exports.toBuffer(a);
  var hash = createHash('rmd160').update(a).digest();
  if (padded === true) {
    return exports.setLength(hash, 32);
  } else {
    return hash;
  }
};

/**
 * Creates SHA-3 hash of the RLP encoded version of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.rlphash = function (a) {
  return exports.keccak(rlp.encode(a));
};

/**
 * Checks if the private key satisfies the rules of the curve secp256k1.
 * @param {Buffer} privateKey
 * @return {Boolean}
 */
exports.isValidPrivate = function (privateKey) {
  return secp256k1.privateKeyVerify(privateKey);
};

/**
 * Checks if the public key satisfies the rules of the curve secp256k1
 * and the requirements of Ethereum.
 * @param {Buffer} publicKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Boolean}
 */
exports.isValidPublic = function (publicKey, sanitize) {
  if (publicKey.length === 64) {
    // Convert to SEC1 for secp256k1
    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
  }

  if (!sanitize) {
    return false;
  }

  return secp256k1.publicKeyVerify(publicKey);
};

/**
 * Returns the ethereum address of a given public key.
 * Accepts "Ethereum public keys" and SEC1 encoded keys.
 * @param {Buffer} pubKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Buffer}
 */
exports.pubToAddress = exports.publicToAddress = function (pubKey, sanitize) {
  pubKey = exports.toBuffer(pubKey);
  if (sanitize && pubKey.length !== 64) {
    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
  }
  assert(pubKey.length === 64);
  // Only take the lower 160bits of the hash
  return exports.keccak(pubKey).slice(-20);
};

/**
 * Returns the ethereum public key of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
var privateToPublic = exports.privateToPublic = function (privateKey) {
  privateKey = exports.toBuffer(privateKey);
  // skip the type flag and use the X, Y points
  return secp256k1.publicKeyCreate(privateKey, false).slice(1);
};

/**
 * Converts a public key to the Ethereum format.
 * @param {Buffer} publicKey
 * @return {Buffer}
 */
exports.importPublic = function (publicKey) {
  publicKey = exports.toBuffer(publicKey);
  if (publicKey.length !== 64) {
    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
  }
  return publicKey;
};

/**
 * ECDSA sign
 * @param {Buffer} msgHash
 * @param {Buffer} privateKey
 * @return {Object}
 */
exports.ecsign = function (msgHash, privateKey) {
  var sig = secp256k1.sign(msgHash, privateKey);

  var ret = {};
  ret.r = sig.signature.slice(0, 32);
  ret.s = sig.signature.slice(32, 64);
  ret.v = sig.recovery + 27;
  return ret;
};

/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 * @param message
 * @returns {Buffer} hash
 */
exports.hashPersonalMessage = function (message) {
  var prefix = exports.toBuffer('\x19Ethereum Signed Message:\n' + message.length.toString());
  return exports.keccak(Buffer.concat([prefix, message]));
};

/**
 * ECDSA public key recovery from signature
 * @param {Buffer} msgHash
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {Buffer} publicKey
 */
exports.ecrecover = function (msgHash, v, r, s) {
  var signature = Buffer.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);
  var recovery = v - 27;
  if (recovery !== 0 && recovery !== 1) {
    throw new Error('Invalid signature v value');
  }
  var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
  return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
};

/**
 * Convert signature parameters into the format of `eth_sign` RPC method
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {String} sig
 */
exports.toRpcSig = function (v, r, s) {
  // NOTE: with potential introduction of chainId this might need to be updated
  if (v !== 27 && v !== 28) {
    throw new Error('Invalid recovery id');
  }

  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
  // FIXME: this might change in the future - https://github.com/ethereum/go-ethereum/issues/2053
  return exports.bufferToHex(Buffer.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));
};

/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 * @param {String} sig
 * @return {Object}
 */
exports.fromRpcSig = function (sig) {
  sig = exports.toBuffer(sig);

  // NOTE: with potential introduction of chainId this might need to be updated
  if (sig.length !== 65) {
    throw new Error('Invalid signature length');
  }

  var v = sig[64];
  // support both versions of `eth_sign` responses
  if (v < 27) {
    v += 27;
  }

  return {
    v: v,
    r: sig.slice(0, 32),
    s: sig.slice(32, 64)
  };
};

/**
 * Returns the ethereum address of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
exports.privateToAddress = function (privateKey) {
  return exports.publicToAddress(privateToPublic(privateKey));
};

/**
 * Checks if the address is a valid. Accepts checksummed addresses too
 * @param {String} address
 * @return {Boolean}
 */
exports.isValidAddress = function (address) {
  return (/^0x[0-9a-fA-F]{40}$/.test(address)
  );
};

/**
  * Checks if a given address is a zero address
  * @method isZeroAddress
  * @param {String} address
  * @return {Boolean}
  */
exports.isZeroAddress = function (address) {
  var zeroAddress = exports.zeroAddress();
  return zeroAddress === exports.addHexPrefix(address);
};

/**
 * Returns a checksummed address
 * @param {String} address
 * @return {String}
 */
exports.toChecksumAddress = function (address) {
  address = exports.stripHexPrefix(address).toLowerCase();
  var hash = exports.keccak(address).toString('hex');
  var ret = '0x';

  for (var i = 0; i < address.length; i++) {
    if (parseInt(hash[i], 16) >= 8) {
      ret += address[i].toUpperCase();
    } else {
      ret += address[i];
    }
  }

  return ret;
};

/**
 * Checks if the address is a valid checksummed address
 * @param {Buffer} address
 * @return {Boolean}
 */
exports.isValidChecksumAddress = function (address) {
  return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
};

/**
 * Generates an address of a newly created contract
 * @param {Buffer} from the address which is creating this new address
 * @param {Buffer} nonce the nonce of the from account
 * @return {Buffer}
 */
exports.generateAddress = function (from, nonce) {
  from = exports.toBuffer(from);
  nonce = new BN(nonce);

  if (nonce.isZero()) {
    // in RLP we want to encode null in the case of zero nonce
    // read the RLP documentation for an answer if you dare
    nonce = null;
  } else {
    nonce = Buffer.from(nonce.toArray());
  }

  // Only take the lower 160bits of the hash
  return exports.rlphash([from, nonce]).slice(-20);
};

/**
 * Returns true if the supplied address belongs to a precompiled account (Byzantium)
 * @param {Buffer|String} address
 * @return {Boolean}
 */
exports.isPrecompiled = function (address) {
  var a = exports.unpad(address);
  return a.length === 1 && a[0] >= 1 && a[0] <= 8;
};

/**
 * Adds "0x" to a given `String` if it does not already start with "0x"
 * @param {String} str
 * @return {String}
 */
exports.addHexPrefix = function (str) {
  if (typeof str !== 'string') {
    return str;
  }

  return exports.isHexPrefixed(str) ? str : '0x' + str;
};

/**
 * Validate ECDSA signature
 * @method isValidSignature
 * @param {Buffer} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @param {Boolean} [homestead=true]
 * @return {Boolean}
 */

exports.isValidSignature = function (v, r, s, homestead) {
  var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
  var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);

  if (r.length !== 32 || s.length !== 32) {
    return false;
  }

  if (v !== 27 && v !== 28) {
    return false;
  }

  r = new BN(r);
  s = new BN(s);

  if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {
    return false;
  }

  if (homestead === false && new BN(s).cmp(SECP256K1_N_DIV_2) === 1) {
    return false;
  }

  return true;
};

/**
 * Converts a `Buffer` or `Array` to JSON
 * @param {Buffer|Array} ba
 * @return {Array|String|null}
 */
exports.baToJSON = function (ba) {
  if (Buffer.isBuffer(ba)) {
    return '0x' + ba.toString('hex');
  } else if (ba instanceof Array) {
    var array = [];
    for (var i = 0; i < ba.length; i++) {
      array.push(exports.baToJSON(ba[i]));
    }
    return array;
  }
};

/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param {Object} self the `Object` to define properties on
 * @param {Array} fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param {*} data data to be validated against the definitions
 */
exports.defineProperties = function (self, fields, data) {
  self.raw = [];
  self._fields = [];

  // attach the `toJSON`
  self.toJSON = function (label) {
    if (label) {
      var obj = {};
      self._fields.forEach(function (field) {
        obj[field] = '0x' + self[field].toString('hex');
      });
      return obj;
    }
    return exports.baToJSON(this.raw);
  };

  self.serialize = function serialize() {
    return rlp.encode(self.raw);
  };

  fields.forEach(function (field, i) {
    self._fields.push(field.name);
    function getter() {
      return self.raw[i];
    }
    function setter(v) {
      v = exports.toBuffer(v);

      if (v.toString('hex') === '00' && !field.allowZero) {
        v = Buffer.allocUnsafe(0);
      }

      if (field.allowLess && field.length) {
        v = exports.stripZeros(v);
        assert(field.length >= v.length, 'The field ' + field.name + ' must not have more ' + field.length + ' bytes');
      } else if (!(field.allowZero && v.length === 0) && field.length) {
        assert(field.length === v.length, 'The field ' + field.name + ' must have byte length of ' + field.length);
      }

      self.raw[i] = v;
    }

    Object.defineProperty(self, field.name, {
      enumerable: true,
      configurable: true,
      get: getter,
      set: setter
    });

    if (field.default) {
      self[field.name] = field.default;
    }

    // attach alias
    if (field.alias) {
      Object.defineProperty(self, field.alias, {
        enumerable: false,
        configurable: true,
        set: setter,
        get: getter
      });
    }
  });

  // if the constuctor is passed data
  if (data) {
    if (typeof data === 'string') {
      data = Buffer.from(exports.stripHexPrefix(data), 'hex');
    }

    if (Buffer.isBuffer(data)) {
      data = rlp.decode(data);
    }

    if (Array.isArray(data)) {
      if (data.length > self._fields.length) {
        throw new Error('wrong number of fields in data');
      }

      // make sure all the items are buffers
      data.forEach(function (d, i) {
        self[self._fields[i]] = exports.toBuffer(d);
      });
    } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
      var keys = Object.keys(data);
      fields.forEach(function (field) {
        if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];
        if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];
      });
    } else {
      throw new Error('invalid data');
    }
  }
};
      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util>ethereumjs-util",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-adapter.js", {"./secp256k1-lib/der":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\der.js","./secp256k1-lib/index":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\index.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereum-cryptography/secp256k1":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethereum-cryptography\\secp256k1.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Ceth-sig-util%5Cnode_modules%5Cethereumjs-util%5Cdist%5Csecp256k1-adapter.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var secp256k1 = require('ethereum-cryptography/secp256k1');

function getSecp256k1 () { return require('./secp256k1-lib/index'); }
var der = require('./secp256k1-lib/der');

/**
 * Verify an ECDSA privateKey
 * @method privateKeyVerify
 * @param {Buffer} privateKey
 * @return {boolean}
 */
var privateKeyVerify = function privateKeyVerify(privateKey) {
  // secp256k1 v4 version throws when privateKey length is not 32
  if (privateKey.length !== 32) {
    return false;
  }

  return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
};

/**
 * Export a privateKey in DER format
 * @method privateKeyExport
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {boolean}
 */
var privateKeyExport = function privateKeyExport(privateKey, compressed) {
  var secp256k1v3 = getSecp256k1();
  // privateKeyExport method is not part of secp256k1 v4 package
  // this implementation is based on v3
  if (privateKey.length !== 32) {
    throw new RangeError('private key length is invalid');
  }

  var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);

  return der.privateKeyExport(privateKey, publicKey, compressed);
};

/**
 * Import a privateKey in DER format
 * @method privateKeyImport
 * @param {Buffer} privateKey
 * @return {Buffer}
 */

var privateKeyImport = function privateKeyImport(privateKey) {
  // privateKeyImport method is not part of secp256k1 v4 package
  // this implementation is based on v3
  privateKey = der.privateKeyImport(privateKey);
  if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {
    return privateKey;
  }

  throw new Error("couldn't import from DER format");
};

/**
 * Negate a privateKey by subtracting it from the order of the curve's base point
 * @method privateKeyNegate
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var privateKeyNegate = function privateKeyNegate(privateKey) {
  return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
};

/**
 * Compute the inverse of a privateKey (modulo the order of the curve's base point).
 * @method privateKeyModInverse
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var privateKeyModInverse = function privateKeyModInverse(privateKey) {
  if (privateKey.length !== 32) {
    throw new Error('private key length is invalid');
  }
  var secp256k1v3 = getSecp256k1();
  return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
};

/**
 * Tweak a privateKey by adding tweak to it.
 * @method privateKeyTweakAdd
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
var privateKeyTweakAdd = function privateKeyTweakAdd(privateKey, tweak) {
  return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
};

/**
 * Tweak a privateKey by multiplying it by a tweak.
 * @method privateKeyTweakMul
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
var privateKeyTweakMul = function privateKeyTweakMul(privateKey, tweak) {
  return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
};

/**
 * Compute the public key for a privateKey.
 * @method publicKeyCreate
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyCreate = function publicKeyCreate(privateKey, compressed) {
  return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
};

/**
 * Convert a publicKey to compressed or uncompressed form.
 * @method publicKeyConvert
 * @param {Buffer} publicKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyConvert = function publicKeyConvert(publicKey, compressed) {
  return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
};

/**
 * Verify an ECDSA publicKey.
 * @method publicKeyVerify
 * @param {Buffer} publicKey
 * @return {boolean}
 */
var publicKeyVerify = function publicKeyVerify(publicKey) {
  // secp256k1 v4 version throws when publicKey length is not 33 or 65
  if (publicKey.length !== 33 && publicKey.length !== 65) {
    return false;
  }

  return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
};

/**
 * Tweak a publicKey by adding tweak times the generator to it.
 * @method publicKeyTweakAdd
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyTweakAdd = function publicKeyTweakAdd(publicKey, tweak, compressed) {
  return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};

/**
 * Tweak a publicKey by multiplying it by a tweak value
 * @method publicKeyTweakMul
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyTweakMul = function publicKeyTweakMul(publicKey, tweak, compressed) {
  return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};

/**
 * Add a given publicKeys together.
 * @method publicKeyCombine
 * @param {Array<Buffer>} publicKeys
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyCombine = function publicKeyCombine(publicKeys, compressed) {
  var keys = [];
  publicKeys.forEach(function (publicKey) {
    keys.push(Uint8Array.from(publicKey));
  });

  return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));
};

/**
 * Convert a signature to a normalized lower-S form.
 * @method signatureNormalize
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureNormalize = function signatureNormalize(signature) {
  return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
};

/**
 * Serialize an ECDSA signature in DER format.
 * @method signatureExport
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureExport = function signatureExport(signature) {
  return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));
};

/**
 * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImport
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureImport = function signatureImport(signature) {
  return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));
};

/**
 * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImportLax
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureImportLax = function signatureImportLax(signature) {
  // signatureImportLax method is not part of secp256k1 v4 package
  // this implementation is based on v3
  // ensure that signature is greater than 0
  if (signature.length === 0) {
    throw new RangeError('signature length is invalid');
  }
  var secp256k1v3 = getSecp256k1();

  var sigObj = der.signatureImportLax(signature);
  if (sigObj === null) {
    throw new Error("couldn't parse DER signature");
  }

  return secp256k1v3.signatureImport(sigObj);
};

/**
 * Create an ECDSA signature. Always return low-S signature.
 * @method sign
 * @param {Buffer} message
 * @param {Buffer} privateKey
 * @param {Object} options
 * @return {Buffer}
 */
var sign = function sign(message, privateKey, options) {
  if (options === null) {
    throw new TypeError('options should be an Object');
  }

  var signOptions = void 0;

  if (options) {
    signOptions = {};

    if (options.data === null) {
      throw new TypeError('options.data should be a Buffer');
    }

    if (options.data) {
      // validate option.data length
      if (options.data.length !== 32) {
        throw new RangeError('options.data length is invalid');
      }

      signOptions.data = new Uint8Array(options.data);
    }

    if (options.noncefn === null) {
      throw new TypeError('options.noncefn should be a Function');
    }

    if (options.noncefn) {
      //  convert option.noncefn function signature
      signOptions.noncefn = function (message, privateKey, algo, data, attempt) {
        var bufferAlgo = algo != null ? Buffer.from(algo) : null;
        var bufferData = data != null ? Buffer.from(data) : null;

        var buffer = Buffer.from('');

        if (options.noncefn) {
          buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);
        }

        return Uint8Array.from(buffer);
      };
    }
  }

  var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);

  return {
    signature: Buffer.from(sig.signature),
    recovery: sig.recid
  };
};

/**
 * Verify an ECDSA signature.
 * @method verify
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Buffer} publicKey
 * @return {boolean}
 */
var verify = function verify(message, signature, publicKey) {
  // note: secp256k1 v4 verify method has a different argument order
  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
};

/**
 * Recover an ECDSA public key from a signature.
 * @method recover
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Number} recid
 * @param {boolean} compressed
 * @return {Buffer}
 */
var recover = function recover(message, signature, recid, compressed) {
  // note: secp256k1 v4 recover method has a different argument order
  return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
};

/**
 * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.
 * @method ecdh
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var ecdh = function ecdh(publicKey, privateKey) {
  // note: secp256k1 v3 doesn't allow optional parameter
  return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
};

/**
 * Compute an EC Diffie-Hellman secret and return public key as result
 * @method ecdhUnsafe
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var ecdhUnsafe = function ecdhUnsafe(publicKey, privateKey, compressed) {
  // ecdhUnsafe method is not part of secp256k1 v4 package
  // this implementation is based on v3
  // ensure valid publicKey length
  if (publicKey.length !== 33 && publicKey.length !== 65) {
    throw new RangeError('public key length is invalid');
  }

  // ensure valid privateKey length
  if (privateKey.length !== 32) {
    throw new RangeError('private key length is invalid');
  }
  var secp256k1v3 = getSecp256k1();

  return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
};

module.exports = {
  privateKeyVerify: privateKeyVerify,
  privateKeyExport: privateKeyExport,
  privateKeyImport: privateKeyImport,
  privateKeyNegate: privateKeyNegate,
  privateKeyModInverse: privateKeyModInverse,
  privateKeyTweakAdd: privateKeyTweakAdd,
  privateKeyTweakMul: privateKeyTweakMul,

  publicKeyCreate: publicKeyCreate,
  publicKeyConvert: publicKeyConvert,
  publicKeyVerify: publicKeyVerify,
  publicKeyTweakAdd: publicKeyTweakAdd,
  publicKeyTweakMul: publicKeyTweakMul,
  publicKeyCombine: publicKeyCombine,

  signatureNormalize: signatureNormalize,
  signatureExport: signatureExport,
  signatureImport: signatureImport,
  signatureImportLax: signatureImportLax,

  sign: sign,
  verify: verify,
  recover: recover,

  ecdh: ecdh,
  ecdhUnsafe: ecdhUnsafe
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util>ethereumjs-util",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-adapter.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\der.js", {"buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Ceth-sig-util%5Cnode_modules%5Cethereumjs-util%5Cdist%5Csecp256k1-lib%5Cder.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

// This file is imported from secp256k1 v3
// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE

var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
// begin
0x30, 0x81, 0xd3, 0x02, 0x01, 0x01, 0x04, 0x20,
// private key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// middle
0xa0, 0x81, 0x85, 0x30, 0x81, 0x82, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x21, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x24, 0x03, 0x22, 0x00,
// public key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);

var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
// begin
0x30, 0x82, 0x01, 0x13, 0x02, 0x01, 0x01, 0x04, 0x20,
// private key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// middle
0xa0, 0x81, 0xa5, 0x30, 0x81, 0xa2, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x41, 0x04, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0e, 0x11, 0x08, 0xa8, 0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10, 0xd4, 0xb8, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x44, 0x03, 0x42, 0x00,
// public key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);

exports.privateKeyExport = function (privateKey, publicKey, compressed) {
  var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
  privateKey.copy(result, compressed ? 8 : 9);
  publicKey.copy(result, compressed ? 181 : 214);
  return result;
};

exports.privateKeyImport = function (privateKey) {
  var length = privateKey.length;

  // sequence header
  var index = 0;
  if (length < index + 1 || privateKey[index] !== 0x30) return null;
  index += 1;

  // sequence length constructor
  if (length < index + 1 || !(privateKey[index] & 0x80)) return null;

  var lenb = privateKey[index] & 0x7f;
  index += 1;
  if (lenb < 1 || lenb > 2) return null;
  if (length < index + lenb) return null;

  // sequence length
  var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
  index += lenb;
  if (length < index + len) return null;

  // sequence element 0: version number (=1)
  if (length < index + 3 || privateKey[index] !== 0x02 || privateKey[index + 1] !== 0x01 || privateKey[index + 2] !== 0x01) {
    return null;
  }
  index += 3;

  // sequence element 1: octet string, up to 32 bytes
  if (length < index + 2 || privateKey[index] !== 0x04 || privateKey[index + 1] > 0x20 || length < index + 2 + privateKey[index + 1]) {
    return null;
  }

  return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
};

exports.signatureImportLax = function (signature) {
  var r = Buffer.alloc(32, 0);
  var s = Buffer.alloc(32, 0);

  var length = signature.length;
  var index = 0;

  // sequence tag byte
  if (signature[index++] !== 0x30) {
    return null;
  }

  // sequence length byte
  var lenbyte = signature[index++];
  if (lenbyte & 0x80) {
    index += lenbyte - 0x80;
    if (index > length) {
      return null;
    }
  }

  // sequence tag byte for r
  if (signature[index++] !== 0x02) {
    return null;
  }

  // length for r
  var rlen = signature[index++];
  if (rlen & 0x80) {
    lenbyte = rlen - 0x80;
    if (index + lenbyte > length) {
      return null;
    }
    for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1) {}
    for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
      rlen = (rlen << 8) + signature[index];
    }
  }
  if (rlen > length - index) {
    return null;
  }
  var rindex = index;
  index += rlen;

  // sequence tag byte for s
  if (signature[index++] !== 0x02) {
    return null;
  }

  // length for s
  var slen = signature[index++];
  if (slen & 0x80) {
    lenbyte = slen - 0x80;
    if (index + lenbyte > length) {
      return null;
    }
    for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1) {}
    for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
      slen = (slen << 8) + signature[index];
    }
  }
  if (slen > length - index) {
    return null;
  }
  var sindex = index;
  index += slen;

  // ignore leading zeros in r
  for (; rlen > 0 && signature[rindex] === 0x00; rlen -= 1, rindex += 1) {}
  // copy r value
  if (rlen > 32) {
    return null;
  }
  var rvalue = signature.slice(rindex, rindex + rlen);
  rvalue.copy(r, 32 - rvalue.length);

  // ignore leading zeros in s
  for (; slen > 0 && signature[sindex] === 0x00; slen -= 1, sindex += 1) {}
  // copy s value
  if (slen > 32) {
    return null;
  }
  var svalue = signature.slice(sindex, sindex + slen);
  svalue.copy(s, 32 - svalue.length);

  return { r: r, s: s };
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util>ethereumjs-util",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\der.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\index.js", {"bn.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\bn.js\\lib\\bn.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js","elliptic":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\elliptic\\lib\\elliptic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Ceth-sig-util%5Cnode_modules%5Cethereumjs-util%5Cdist%5Csecp256k1-lib%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

// This file is imported from secp256k1 v3
// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE

var BN = require('bn.js');
var EC = require('elliptic').ec;

var ec = new EC('secp256k1');
var ecparams = ec.curve;

exports.privateKeyExport = function (privateKey, compressed) {
  var d = new BN(privateKey);
  if (d.ucmp(ecparams.n) >= 0) {
    throw new Error('couldn\'t export to DER format');
  }

  var point = ec.g.mul(d);
  return toPublicKey(point.getX(), point.getY(), compressed);
};

exports.privateKeyModInverse = function (privateKey) {
  var bn = new BN(privateKey);
  if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {
    throw new Error('private key range is invalid');
  }

  return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32);
};

exports.signatureImport = function (sigObj) {
  var r = new BN(sigObj.r);
  if (r.ucmp(ecparams.n) >= 0) {
    r = new BN(0);
  }

  var s = new BN(sigObj.s);
  if (s.ucmp(ecparams.n) >= 0) {
    s = new BN(0);
  }

  return Buffer.concat([r.toArrayLike(Buffer, 'be', 32), s.toArrayLike(Buffer, 'be', 32)]);
};

exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
  var point = ec.keyFromPublic(publicKey);

  var scalar = new BN(privateKey);
  if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
    throw new Error('scalar was invalid (zero or overflow)');
  }

  var shared = point.pub.mul(scalar);
  return toPublicKey(shared.getX(), shared.getY(), compressed);
};

var toPublicKey = function toPublicKey(x, y, compressed) {
  var publicKey = void 0;

  if (compressed) {
    publicKey = Buffer.alloc(33);
    publicKey[0] = y.isOdd() ? 0x03 : 0x02;
    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
  } else {
    publicKey = Buffer.alloc(65);
    publicKey[0] = 0x04;
    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
    y.toArrayLike(Buffer, 'be', 32).copy(publicKey, 33);
  }

  return publicKey;
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util>ethereumjs-util",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethereum-cryptography\\hash-utils.js", {"buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Cethereum-cryptography%5Chash-utils.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function createHashFunction(hashConstructor) {
    return function (msg) {
        var hash = hashConstructor();
        hash.update(msg);
        return Buffer.from(hash.digest());
    };
}
exports.createHashFunction = createHashFunction;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util>ethereumjs-util>ethereum-cryptography",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethereum-cryptography\\hash-utils.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethereum-cryptography\\keccak.js", {"./hash-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethereum-cryptography\\hash-utils.js","keccak":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\keccak\\js.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Cethereum-cryptography%5Ckeccak.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var hash_utils_1 = require("./hash-utils");
var createKeccakHash = require("keccak");
exports.keccak224 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak224");
});
exports.keccak256 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak256");
});
exports.keccak384 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak384");
});
exports.keccak512 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak512");
});
//# sourceMappingURL=keccak.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util>ethereumjs-util>ethereum-cryptography",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethereum-cryptography\\keccak.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethereum-cryptography\\random.js", {"randombytes":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\randombytes\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Cethereum-cryptography%5Crandom.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var randombytes = require("randombytes");
function getRandomBytes(bytes) {
    return new Promise(function (resolve, reject) {
        randombytes(bytes, function (err, resp) {
            if (err) {
                reject(err);
                return;
            }
            resolve(resp);
        });
    });
}
exports.getRandomBytes = getRandomBytes;
function getRandomBytesSync(bytes) {
    return randombytes(bytes);
}
exports.getRandomBytesSync = getRandomBytesSync;
//# sourceMappingURL=random.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util>ethereumjs-util>ethereum-cryptography",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethereum-cryptography\\random.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethereum-cryptography\\secp256k1.js", {"./random":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethereum-cryptography\\random.js","secp256k1":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\secp256k1\\elliptic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Cethereum-cryptography%5Csecp256k1.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var secp256k1_1 = require("secp256k1");
var random_1 = require("./random");
var SECP256K1_PRIVATE_KEY_SIZE = 32;
function createPrivateKey() {
    return __awaiter(this, void 0, void 0, function () {
        var pk;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!true) return [3 /*break*/, 2];
                    return [4 /*yield*/, random_1.getRandomBytes(SECP256K1_PRIVATE_KEY_SIZE)];
                case 1:
                    pk = _a.sent();
                    if (secp256k1_1.privateKeyVerify(pk)) {
                        return [2 /*return*/, pk];
                    }
                    return [3 /*break*/, 0];
                case 2: return [2 /*return*/];
            }
        });
    });
}
exports.createPrivateKey = createPrivateKey;
function createPrivateKeySync() {
    while (true) {
        var pk = random_1.getRandomBytesSync(SECP256K1_PRIVATE_KEY_SIZE);
        if (secp256k1_1.privateKeyVerify(pk)) {
            return pk;
        }
    }
}
exports.createPrivateKeySync = createPrivateKeySync;
__export(require("secp256k1"));
//# sourceMappingURL=secp256k1.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util>ethereumjs-util>ethereum-cryptography",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethereum-cryptography\\secp256k1.js",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcC9zY3JpcHRzL21ldGFtYXNrLWNvbnRyb2xsZXIuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAwMi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDAzLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMDQuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAwNS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDA2LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMDcuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAwOC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDA5LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTAuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAxMS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDEyLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTMuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAxNC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDE1LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTYuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAxNy5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDE4LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTkuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyMC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDIxLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMjIuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyMy5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDI0LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMjUuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyNi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDI3LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMjguanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyOS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDMwLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMzEuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAzMi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDMzLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMzQuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAzNS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDM2LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMzcuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAzOC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDM5LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDAuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA0MS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDQyLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDMuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA0NC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDQ1LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDYuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA0Ny5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDQ4LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDkuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA1MC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDUxLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNTIuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA1My5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDU0LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNTUuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA1Ni5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDU3LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNTguanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA1OS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDYwLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNjEuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA2Mi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDYzLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNjQuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA2NS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDY2LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNjcuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA2OC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDY5LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNzAuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA3MS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDcyLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNzMuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA3NC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDc1LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNzYuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA3Ny5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDc4LnRzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNzkuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA4MC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDgxLnRzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wODIudHMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA4My50cyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDg0LnRzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wODUudHMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA4Ni50cyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvZmFpbC10eC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2Jhc2UuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvcmZjNDY0OC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvbm9kZV9tb2R1bGVzL3ZhcmludC9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL25vZGVfbW9kdWxlcy92YXJpbnQvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGljb2RlYy9ub2RlX21vZHVsZXMvdmFyaW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGljb2RlYy9ub2RlX21vZHVsZXMvdmFyaW50L2xlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL2Jhc2UtdGFibGUuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL2ludC10YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL3ByaW50LmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGljb2RlYy9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL3ZhcmludC10YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpaGFzaGVzL25vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2Jhc2UuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWhhc2hlcy9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWhhc2hlcy9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpaGFzaGVzL25vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL3JmYzQ2NDguanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWhhc2hlcy9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGloYXNoZXMvc3JjL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpaGFzaGVzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2NvbmNhdC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2Zyb20tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvdG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9zcmMvaGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9zcmMvcHJvZmlsZXMuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9kaXN0L2Jhc2UtZXRoLWtleXJpbmcuY2pzLmRldmVsb3BtZW50LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvZGlzdC9iYXNlLWV0aC1rZXlyaW5nLmNqcy5wcm9kdWN0aW9uLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnktZXRoL2Rpc3QvYmMtdXItcmVnaXN0cnktZXRoLmNqcy5kZXZlbG9wbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS1ldGgvZGlzdC9iYy11ci1yZWdpc3RyeS1ldGguY2pzLnByb2R1Y3Rpb24ubWluLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5LWV0aC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvQnl0ZXMuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9DcnlwdG9BY2NvdW50LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvQ3J5cHRvQ29pbkluZm8uanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9DcnlwdG9FQ0tleS5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L0NyeXB0b0hES2V5LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvQ3J5cHRvS2V5cGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L0NyeXB0b091dHB1dC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L0NyeXB0b1BTQlQuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9EZWNvZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvTXVsdGlLZXkuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9QYXRoQ29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvUmVnaXN0cnlJdGVtLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvUmVnaXN0cnlUeXBlLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvU2NyaXB0RXhwcmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L2Vycm9ycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L2V4dGVuZGVkL0NyeXB0b011bHRpQWNjb3VudHMuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L2xpYi9EYXRhSXRlbS5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L2xpYi9jYm9yLXN5bmMuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9wYXRjaENCT1IuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvbm9kZV9tb2R1bGVzL3JscC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvZGlzdC9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy5janMuZGV2ZWxvcG1lbnQuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvZGlzdC9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy5janMucHJvZHVjdGlvbi5taW4uanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5LWV0aC9kaXN0L2JjLXVyLXJlZ2lzdHJ5LWV0aC5janMuZGV2ZWxvcG1lbnQuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5LWV0aC9kaXN0L2JjLXVyLXJlZ2lzdHJ5LWV0aC5janMucHJvZHVjdGlvbi5taW4uanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5LWV0aC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L0J5dGVzLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L0NyeXB0b0FjY291bnQuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvQ3J5cHRvQ29pbkluZm8uanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvQ3J5cHRvRUNLZXkuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvQ3J5cHRvSERLZXkuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvQ3J5cHRvS2V5cGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9DcnlwdG9PdXRwdXQuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvQ3J5cHRvUFNCVC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9EZWNvZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L011bHRpS2V5LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L1BhdGhDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvUmVnaXN0cnlJdGVtLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L1JlZ2lzdHJ5VHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9TY3JpcHRFeHByZXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L2Vycm9ycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9leHRlbmRlZC9DcnlwdG9NdWx0aUFjY291bnRzLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L2xpYi9EYXRhSXRlbS5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9saWIvY2Jvci1zeW5jLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS9kaXN0L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnkvZGlzdC9wYXRjaENCT1IuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvdHlwZXMuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5L2Rpc3QvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9Db21wb3NlZFN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvTWVyZ2VkU3RvcmUuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9PYnNlcnZhYmxlU3RvcmUuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9hc1N0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy90aHJvdWdoMi90aHJvdWdoMi5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWRkcmVzcy1ib29rLWNvbnRyb2xsZXIvZGlzdC9BZGRyZXNzQm9va0NvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FkZHJlc3MtYm9vay1jb250cm9sbGVyL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2Fubm91bmNlbWVudC1jb250cm9sbGVyL2Rpc3QvQW5ub3VuY2VtZW50Q29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svYW5ub3VuY2VtZW50LWNvbnRyb2xsZXIvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svYXBwcm92YWwtY29udHJvbGxlci9kaXN0L0FwcHJvdmFsQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svYXBwcm92YWwtY29udHJvbGxlci9kaXN0L2Vycm9ycy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svYXBwcm92YWwtY29udHJvbGxlci9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hcHByb3ZhbC1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9uYW5vaWQvaW5kZXguYnJvd3Nlci5janMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FwcHJvdmFsLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL25hbm9pZC91cmwtYWxwaGFiZXQvaW5kZXguY2pzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9icm93c2VyLXBhc3N3b3JkZXIvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWhkLWtleXJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvZGlzdC9jcmVhdGUtaW5mdXJhLW1pZGRsZXdhcmUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvZGlzdC9jcmVhdGUtcHJvdmlkZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvZGlzdC9mZXRjaC1jb25maWctZnJvbS1yZXEuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9kaXN0L2xvZ2dpbmctdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYmFzZTY0LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9ieXRlcy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2hlY2tzdW0uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvZXJjZXJzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jb2xsZWN0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvaGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbG9nZ2luZy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbWlzYy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9vcGFxdWUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RpbWUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3ZlcnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2Jsb2NrLWNhY2hlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2Jsb2NrLXJlZi1yZXdyaXRlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2Jsb2NrLXJlZi5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9ibG9jay10cmFja2VyLWluc3BlY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9mZXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9pbmZsaWdodC1jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9sb2dnaW5nLXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L3Byb3ZpZGVyQXNNaWRkbGV3YXJlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L3Byb3ZpZGVyRnJvbUVuZ2luZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9wcm92aWRlckZyb21NaWRkbGV3YXJlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L3JldHJ5T25FbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC91dGlscy9jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC93YWxsZXQuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvbm9kZV9tb2R1bGVzL3BpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvYmxvY2stY2FjaGUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvYmxvY2stcmVmLXJld3JpdGUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvYmxvY2stcmVmLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2Jsb2NrLXRyYWNrZXItaW5zcGVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2ZldGNoLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2luZmxpZ2h0LWNhY2hlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2xvZ2dpbmctdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvcHJvdmlkZXJBc01pZGRsZXdhcmUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvcmV0cnlPbkVtcHR5LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L3V0aWxzL2NhY2hlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L3V0aWxzL3RpbWVvdXQuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3Qvd2FsbGV0LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYmFzZTY0LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYnl0ZXMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jaGVja3N1bS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvZXJjZXJzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY29sbGVjdGlvbnMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9oZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2pzb24uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9sb2dnaW5nLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbWlzYy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L251bWJlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L29wYXF1ZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RpbWUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC92ZXJzaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL3BpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1wcm92aWRlci9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtcHJvdmlkZXIvZGlzdC9wcm92aWRlci1mcm9tLWVuZ2luZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLXByb3ZpZGVyL2Rpc3QvcHJvdmlkZXItZnJvbS1taWRkbGV3YXJlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtcHJvdmlkZXIvZGlzdC9zYWZlLWV2ZW50LWVtaXR0ZXItcHJvdmlkZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1rZXlyaW5nLWNvbnRyb2xsZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcvbm9kZV9tb2R1bGVzL2V0aC1zaWctdXRpbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMvZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMvZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9zZWNwMjU2azEtYWRhcHRlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMvZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9zZWNwMjU2azEtbGliL2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMvZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9zZWNwMjU2azEtbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvaGFzaC11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nhay5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3JhbmRvbS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3NlY3AyNTZrMS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFBLFVBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsUUFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsUUFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxNQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxZQUFBLE9BQUEsQ0FBQSxxQkFBQSxDQUFBLENBQUE7QUFDQSxJQUFBLFlBQUEsT0FBQSxDQUFBLG1DQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsaUJBQUEsT0FBQSxDQUFBLGlCQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsMkJBQUEsT0FBQSxDQUFBLDRCQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsd0JBQUEsT0FBQSxDQUFBLG1DQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsVUFBQSxPQUFBLENBQUEsUUFBQSxDQUFBLENBQUE7QUFDQSxJQUFBLHdCQUFBLE9BQUEsQ0FBQSxrQ0FBQSxDQUFBLENBQUE7QUFJQSxJQUFBLHFCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHNCQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSx1QkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSwwQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsZ0JBQUEsT0FBQSxDQUFBLGdCQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsa0JBQUEsT0FBQSxDQUFBLGlCQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsWUFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxVQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxvQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSw4QkFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsMEJBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEscUNBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLHFCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHFCQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSw0QkFBQSxPQUFBLENBQUEsd0NBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxZQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLFdBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLFVBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsUUFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsV0FBQSxPQUFBLENBQUEsaUJBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSx5QkFBQSxPQUFBLENBQUEsbUNBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxzQkFBQSxPQUFBLENBQUEsK0JBQUEsQ0FBQSxDQUFBO0FBSUEsSUFBQSxrQkFBQSxPQUFBLENBQUEsMkJBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxxQkFBQSxPQUFBLENBQUEsOEJBQUEsQ0FBQSxDQUFBO0FBU0EsSUFBQSxzQkFBQSxPQUFBLENBQUEsK0JBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSwwQkFBQSxPQUFBLENBQUEsbUNBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxvQkFBQSxPQUFBLENBQUEsOEJBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSx3QkFBQSxPQUFBLENBQUEsaUNBQUEsQ0FBQSxDQUFBO0FBSUEsSUFBQSw2QkFBQSxPQUFBLENBQUEsdUNBQUEsQ0FBQSxDQUFBO0FBSUEsSUFBQSwrQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSx5Q0FBQSxDQUFBLENBQUEsQ0FBQTtBQUVBLElBQUEsdUJBQUEsT0FBQSxDQUFBLGdDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsbUJBQUEsT0FBQSxDQUFBLDRCQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsZUFBQSxPQUFBLENBQUEsb0NBQUEsQ0FBQSxDQUFBO0FBTUEsSUFBQSxTQUFBLE9BQUEsQ0FBQSw4QkFBQSxDQUFBLENBQUE7QUFLQSxJQUFBLFdBQUEsT0FBQSxDQUFBLGdDQUFBLENBQUEsQ0FBQTtBQUtBLElBQUEsbUJBQUEsT0FBQSxDQUFBLHlDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsV0FBQSxPQUFBLENBQUEsZ0NBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxlQUFBLE9BQUEsQ0FBQSxvQ0FBQSxDQUFBLENBQUE7QUFJQSxJQUFBLGlCQUFBLE9BQUEsQ0FBQSw0QkFBQSxDQUFBLENBQUE7QUFDQSxJQUFBLFFBQUEsT0FBQSxDQUFBLDZCQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsT0FBQSxPQUFBLENBQUEsNEJBQUEsQ0FBQSxDQUFBO0FBSUEsSUFBQSxlQUFBLE9BQUEsQ0FBQSxvQ0FBQSxDQUFBLENBQUE7QUFLQSxJQUFBLGFBQUEsT0FBQSxDQUFBLGdDQUFBLENBQUEsQ0FBQTtBQUlBLElBQUEsZUFBQSxPQUFBLENBQUEsbUNBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxnQkFBQSxPQUFBLENBQUEsd0NBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxVQUFBLE9BQUEsQ0FBQSwrQkFBQSxDQUFBLENBQUE7QUFDQSxJQUFBLDJCQUFBLE9BQUEsQ0FBQSw0Q0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLE1BQUEsT0FBQSxDQUFBLGdDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsY0FBQSxPQUFBLENBQUEsdUNBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxhQUFBLE9BQUEsQ0FBQSxtQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLDJCQUFBLE9BQUEsQ0FBQSw2QkFBQSxDQUFBLENBQUE7QUFJQSxJQUFBLDZCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLGlDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxrQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSx1QkFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsaUNBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEscUNBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLDBCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLDhCQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSx1QkFBQSxPQUFBLENBQUEsNkJBQUEsQ0FBQSxDQUFBO0FBR0EsSUFBQSwwQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSw4QkFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEseUJBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsNkJBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLDhCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLGtDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxlQUFBLE9BQUEsQ0FBQSxvQkFBQSxDQUFBLENBQUE7QUFDQSxJQUFBLE9BQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsbUJBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLFlBQUEsT0FBQSxDQUFBLHVCQUFBLENBQUEsQ0FBQTtBQUlBLElBQUEsZUFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSwyQkFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsWUFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSx5QkFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsa0JBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsK0JBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLFNBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEscUJBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLGNBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsMEJBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLFVBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsc0JBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLHdCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHFDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxrQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSwrQkFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsZ0JBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsNEJBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLGdCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLDZCQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxVQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHFCQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSwyQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSw2QkFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsc0JBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsNEJBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLGdCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLDJCQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxXQUFBLE9BQUEsQ0FBQSxlQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsd0JBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsNEJBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLFFBQUEsT0FBQSxDQUFBLFlBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSw0QkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxnQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsdUJBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEscUNBQUEsQ0FBQSxDQUFBLENBQUE7QUFFQSxJQUFBLGdCQUFBLE9BQUEsQ0FBQSwyQkFBQSxDQUFBLENBQUE7QUFXQSxJQUFBLHFDQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHlDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSwyQkFBQSxPQUFBLENBQUEsaUNBQUEsQ0FBQSxDQUFBO0FBQXdFLHFDQUFBLEVBQUEsT0FBQSxHQUFBLElBQUEsR0FBQSxXQUFBLEdBQUEsR0FBQSxHQUFBLEVBQUEsU0FBQSxHQUFBLEVBQUEsQ0FBQSxFQUFBO0FBQUEsMENBQUEsRUFBQSxNQUFBLGNB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LENBQUEsT0FBQTtBQUNBLElBQUEsRUFBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsRUFBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsSUFBQSxHQUFBLHVCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsR0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsSUFBQSxHQUFBLHVCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsSUFBQSxHQUFBLHVCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsSUFBQSxHQUFBLHVCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsSUFBQSxHQUFBLHVCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsSUFBQSxHQUFBLHVCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsSUFBQSxHQUFBLHVCQUFBLENBQUEsT0FBQTtBQUE4QixTQUFBLHlCQUFBLFdBQUEsZUFBQSxPQUFBLGtDQUFBLGlCQUFBLE9BQUEsT0FBQSxRQUFBLGdCQUFBLE9BQUEsT0FBQSxZQUFBLHdCQUFBLFlBQUEsQ0FBQSxXQUFBLFdBQUEsV0FBQSxHQUFBLGdCQUFBLEdBQUEsaUJBQUEsS0FBQSxXQUFBO0FBQUEsU0FBQSx3QkFBQSxHQUFBLEVBQUEsV0FBQSxTQUFBLFdBQUEsSUFBQSxHQUFBLElBQUEsR0FBQSxDQUFBLFVBQUEsV0FBQSxHQUFBLFFBQUEsR0FBQSxvQkFBQSxHQUFBLHdCQUFBLEdBQUEsNEJBQUEsT0FBQSxFQUFBLEdBQUEsVUFBQSxLQUFBLEdBQUEsd0JBQUEsQ0FBQSxXQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxZQUFBLEtBQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxTQUFBLE1BQUEsV0FBQSxxQkFBQSxHQUFBLE1BQUEsQ0FBQSxjQUFBLElBQUEsTUFBQSxDQUFBLHdCQUFBLFdBQUEsR0FBQSxJQUFBLEdBQUEsUUFBQSxHQUFBLGtCQUFBLE1BQUEsQ0FBQSxTQUFBLENBQUEsY0FBQSxDQUFBLElBQUEsQ0FBQSxHQUFBLEVBQUEsR0FBQSxTQUFBLElBQUEsR0FBQSxxQkFBQSxHQUFBLE1BQUEsQ0FBQSx3QkFBQSxDQUFBLEdBQUEsRUFBQSxHQUFBLGNBQUEsSUFBQSxLQUFBLElBQUEsQ0FBQSxHQUFBLElBQUEsSUFBQSxDQUFBLEdBQUEsS0FBQSxNQUFBLENBQUEsY0FBQSxDQUFBLE1BQUEsRUFBQSxHQUFBLEVBQUEsSUFBQSxZQUFBLE1BQUEsQ0FBQSxHQUFBLElBQUEsR0FBQSxDQUFBLEdBQUEsU0FBQSxNQUFBLENBQUEsT0FBQSxHQUFBLEdBQUEsTUFBQSxLQUFBLElBQUEsS0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLEVBQUEsTUFBQSxZQUFBLE1BQUE7QUFBQSxTQUFBLHVCQUFBLEdBQUEsV0FBQSxHQUFBLElBQUEsR0FBQSxDQUFBLFVBQUEsR0FBQSxHQUFBLEtBQUEsT0FBQSxFQUFBLEdBQUE7QUEzRjlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF3RkEsTUFBTSxVQUFVLEdBQUcsQ0FDakIsU0FBSSxFQUNKLFVBQUksRUFDSixVQUFJLEVBQ0osVUFBSSxFQUNKLFVBQUksRUFDSixVQUFJLEVBQ0osVUFBSSxFQUNKLFVBQUksRUFDSixVQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLElBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLElBQUksRUFDSixJQUFJLEVBQ0osSUFBSSxFQUNKLElBQUksRUFDSixJQUFJLEVBQ0osSUFBSSxDQUNMO0FBQUMsSUFBQSxRQUFBLEdBRWEsVUFBVTtBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTs7Ozs7Ozs7Ozs7Ozs7QUNyTHpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2hlQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuVUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDeHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3BQQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuVUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDeHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN2VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN6WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3pYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JHQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNoNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUMzb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNwdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDbllBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImJhY2tncm91bmQtMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcbmltcG9ydCBwdW1wIGZyb20gJ3B1bXAnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZVN0b3JlIH0gZnJvbSAnQG1ldGFtYXNrL29icy1zdG9yZSc7XG5pbXBvcnQgeyBzdG9yZUFzU3RyZWFtIH0gZnJvbSAnQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L2FzU3RyZWFtJztcbmltcG9ydCB7IEpzb25ScGNFbmdpbmUgfSBmcm9tICdqc29uLXJwYy1lbmdpbmUnO1xuaW1wb3J0IHsgY3JlYXRlRW5naW5lU3RyZWFtIH0gZnJvbSAnanNvbi1ycGMtbWlkZGxld2FyZS1zdHJlYW0nO1xuaW1wb3J0IHsgcHJvdmlkZXJBc01pZGRsZXdhcmUgfSBmcm9tICdAbWV0YW1hc2svZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUnO1xuaW1wb3J0IHsgZGVib3VuY2UgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHtcbiAgS2V5cmluZ0NvbnRyb2xsZXIsXG4gIGtleXJpbmdCdWlsZGVyRmFjdG9yeSxcbn0gZnJvbSAnQG1ldGFtYXNrL2V0aC1rZXlyaW5nLWNvbnRyb2xsZXInO1xuaW1wb3J0IGNyZWF0ZUZpbHRlck1pZGRsZXdhcmUgZnJvbSAnZXRoLWpzb24tcnBjLWZpbHRlcnMnO1xuaW1wb3J0IGNyZWF0ZVN1YnNjcmlwdGlvbk1hbmFnZXIgZnJvbSAnZXRoLWpzb24tcnBjLWZpbHRlcnMvc3Vic2NyaXB0aW9uTWFuYWdlcic7XG5pbXBvcnQgeyBlcnJvckNvZGVzIGFzIHJwY0Vycm9yQ29kZXMsIEV0aGVyZXVtUnBjRXJyb3IgfSBmcm9tICdldGgtcnBjLWVycm9ycyc7XG5pbXBvcnQgeyBNdXRleCB9IGZyb20gJ2F3YWl0LXNlbWFwaG9yZSc7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBUcmV6b3JLZXlyaW5nIGZyb20gJ0BtZXRhbWFzay9ldGgtdHJlem9yLWtleXJpbmcnO1xuaW1wb3J0IExlZGdlckJyaWRnZUtleXJpbmcgZnJvbSAnQG1ldGFtYXNrL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcnO1xuaW1wb3J0IExhdHRpY2VLZXlyaW5nIGZyb20gJ2V0aC1sYXR0aWNlLWtleXJpbmcnO1xuaW1wb3J0IHsgTWV0YU1hc2tLZXlyaW5nIGFzIFFSSGFyZHdhcmVLZXlyaW5nIH0gZnJvbSAnQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcnO1xuaW1wb3J0IEV0aFF1ZXJ5IGZyb20gJ2V0aC1xdWVyeSc7XG5pbXBvcnQgbmFub2lkIGZyb20gJ25hbm9pZCc7XG5pbXBvcnQgeyBjYXB0dXJlRXhjZXB0aW9uIH0gZnJvbSAnQHNlbnRyeS9icm93c2VyJztcbmltcG9ydCB7IEFkZHJlc3NCb29rQ29udHJvbGxlciB9IGZyb20gJ0BtZXRhbWFzay9hZGRyZXNzLWJvb2stY29udHJvbGxlcic7XG5pbXBvcnQge1xuICBBcHByb3ZhbENvbnRyb2xsZXIsXG4gIEFwcHJvdmFsUmVxdWVzdE5vdEZvdW5kRXJyb3IsXG59IGZyb20gJ0BtZXRhbWFzay9hcHByb3ZhbC1jb250cm9sbGVyJztcbmltcG9ydCB7IENvbnRyb2xsZXJNZXNzZW5nZXIgfSBmcm9tICdAbWV0YW1hc2svYmFzZS1jb250cm9sbGVyJztcbmltcG9ydCB7XG4gIEN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIsXG4gIFRva2VuTGlzdENvbnRyb2xsZXIsXG4gIFRva2Vuc0NvbnRyb2xsZXIsXG4gIFRva2VuUmF0ZXNDb250cm9sbGVyLFxuICBOZnRDb250cm9sbGVyLFxuICBBc3NldHNDb250cmFjdENvbnRyb2xsZXIsXG4gIE5mdERldGVjdGlvbkNvbnRyb2xsZXIsXG59IGZyb20gJ0BtZXRhbWFzay9hc3NldHMtY29udHJvbGxlcnMnO1xuaW1wb3J0IHsgUGhpc2hpbmdDb250cm9sbGVyIH0gZnJvbSAnQG1ldGFtYXNrL3BoaXNoaW5nLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgQW5ub3VuY2VtZW50Q29udHJvbGxlciB9IGZyb20gJ0BtZXRhbWFzay9hbm5vdW5jZW1lbnQtY29udHJvbGxlcic7XG5pbXBvcnQgeyBHYXNGZWVDb250cm9sbGVyIH0gZnJvbSAnQG1ldGFtYXNrL2dhcy1mZWUtY29udHJvbGxlcic7XG5pbXBvcnQge1xuICBQZXJtaXNzaW9uQ29udHJvbGxlcixcbiAgUGVybWlzc2lvbnNSZXF1ZXN0Tm90Rm91bmRFcnJvcixcbn0gZnJvbSAnQG1ldGFtYXNrL3Blcm1pc3Npb24tY29udHJvbGxlcic7XG5pbXBvcnQge1xuICBTdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLFxuICBTdWJqZWN0VHlwZSxcbn0gZnJvbSAnQG1ldGFtYXNrL3N1YmplY3QtbWV0YWRhdGEtY29udHJvbGxlcic7XG5pbXBvcnQgU21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyIGZyb20gJ0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlcic7XG5cbmltcG9ydCB7IFNpZ25hdHVyZUNvbnRyb2xsZXIgfSBmcm9tICdAbWV0YW1hc2svc2lnbmF0dXJlLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgQXBwcm92YWxUeXBlIH0gZnJvbSAnQG1ldGFtYXNrL2NvbnRyb2xsZXItdXRpbHMnO1xuaW1wb3J0IHtcbiAgQXNzZXRUeXBlLFxuICBUcmFuc2FjdGlvblN0YXR1cyxcbiAgVHJhbnNhY3Rpb25UeXBlLFxuICBUb2tlblN0YW5kYXJkLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7XG4gIEdBU19BUElfQkFTRV9VUkwsXG4gIEdBU19ERVZfQVBJX0JBU0VfVVJMLFxuICBTV0FQU19DTElFTlRfSUQsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvc3dhcHMnO1xuaW1wb3J0IHtcbiAgQ0hBSU5fSURTLFxuICBORVRXT1JLX1RZUEVTLFxuICBOZXR3b3JrU3RhdHVzLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xuaW1wb3J0IHsgSGFyZHdhcmVEZXZpY2VOYW1lcyB9IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvaGFyZHdhcmUtd2FsbGV0cyc7XG5pbXBvcnQgeyBLZXlyaW5nVHlwZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMva2V5cmluZyc7XG5pbXBvcnQge1xuICBDYXZlYXRUeXBlcyxcbiAgUmVzdHJpY3RlZE1ldGhvZHMsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvcGVybWlzc2lvbnMnO1xuaW1wb3J0IHsgVUlfTk9USUZJQ0FUSU9OUyB9IGZyb20gJy4uLy4uL3NoYXJlZC9ub3RpZmljYXRpb25zJztcbmltcG9ydCB7IE1JTExJU0VDT05ELCBTRUNPTkQgfSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RpbWUnO1xuaW1wb3J0IHtcbiAgT1JJR0lOX01FVEFNQVNLLFxuICBQT0xMSU5HX1RPS0VOX0VOVklST05NRU5UX1RZUEVTLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL2FwcCc7XG5pbXBvcnQge1xuICBNZXRhTWV0cmljc0V2ZW50Q2F0ZWdvcnksXG4gIE1ldGFNZXRyaWNzRXZlbnROYW1lLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL21ldGFtZXRyaWNzJztcblxuaW1wb3J0IHtcbiAgZ2V0VG9rZW5JZFBhcmFtLFxuICBmZXRjaFRva2VuQmFsYW5jZSxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi90b2tlbi11dGlsLnRzJztcbmltcG9ydCB7IGlzRXF1YWxDYXNlSW5zZW5zaXRpdmUgfSBmcm9tICcuLi8uLi9zaGFyZWQvbW9kdWxlcy9zdHJpbmctdXRpbHMnO1xuaW1wb3J0IHsgcGFyc2VTdGFuZGFyZFRva2VuVHJhbnNhY3Rpb25EYXRhIH0gZnJvbSAnLi4vLi4vc2hhcmVkL21vZHVsZXMvdHJhbnNhY3Rpb24udXRpbHMnO1xuaW1wb3J0IHsgU1RBVElDX01BSU5ORVRfVE9LRU5fTElTVCB9IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdG9rZW5zJztcbmltcG9ydCB7IGdldFRva2VuVmFsdWVQYXJhbSB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvbWV0YW1hc2stY29udHJvbGxlci11dGlscyc7XG5pbXBvcnQgeyBpc01hbmlmZXN0VjMgfSBmcm9tICcuLi8uLi9zaGFyZWQvbW9kdWxlcy9tdjMudXRpbHMnO1xuaW1wb3J0IHsgaGV4VG9EZWNpbWFsIH0gZnJvbSAnLi4vLi4vc2hhcmVkL21vZHVsZXMvY29udmVyc2lvbi51dGlscyc7XG5pbXBvcnQgeyBBQ1RJT05fUVVFVUVfTUVUUklDU19FMkVfVEVTVCB9IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdGVzdC1mbGFncyc7XG5pbXBvcnQge1xuICBvbk1lc3NhZ2VSZWNlaXZlZCxcbiAgY2hlY2tGb3JNdWx0aXBsZVZlcnNpb25zUnVubmluZyxcbn0gZnJvbSAnLi9kZXRlY3QtbXVsdGlwbGUtaW5zdGFuY2VzJztcbmltcG9ydCBDb21wb3NhYmxlT2JzZXJ2YWJsZVN0b3JlIGZyb20gJy4vbGliL0NvbXBvc2FibGVPYnNlcnZhYmxlU3RvcmUnO1xuaW1wb3J0IEFjY291bnRUcmFja2VyIGZyb20gJy4vbGliL2FjY291bnQtdHJhY2tlcic7XG5pbXBvcnQgY3JlYXRlRHVwZVJlcUZpbHRlck1pZGRsZXdhcmUgZnJvbSAnLi9saWIvY3JlYXRlRHVwZVJlcUZpbHRlck1pZGRsZXdhcmUnO1xuaW1wb3J0IGNyZWF0ZUxvZ2dlck1pZGRsZXdhcmUgZnJvbSAnLi9saWIvY3JlYXRlTG9nZ2VyTWlkZGxld2FyZSc7XG5pbXBvcnQge1xuICBjcmVhdGVNZXRob2RNaWRkbGV3YXJlLFxufSBmcm9tICcuL2xpYi9ycGMtbWV0aG9kLW1pZGRsZXdhcmUnO1xuaW1wb3J0IGNyZWF0ZU9yaWdpbk1pZGRsZXdhcmUgZnJvbSAnLi9saWIvY3JlYXRlT3JpZ2luTWlkZGxld2FyZSc7XG5pbXBvcnQgY3JlYXRlVGFiSWRNaWRkbGV3YXJlIGZyb20gJy4vbGliL2NyZWF0ZVRhYklkTWlkZGxld2FyZSc7XG5pbXBvcnQgY3JlYXRlT25ib2FyZGluZ01pZGRsZXdhcmUgZnJvbSAnLi9saWIvY3JlYXRlT25ib2FyZGluZ01pZGRsZXdhcmUnO1xuaW1wb3J0IHsgc2V0dXBNdWx0aXBsZXggfSBmcm9tICcuL2xpYi9zdHJlYW0tdXRpbHMnO1xuaW1wb3J0IEVuc0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVycy9lbnMnO1xuaW1wb3J0IHtcbiAgTmV0d29ya0NvbnRyb2xsZXIsXG4gIE5ldHdvcmtDb250cm9sbGVyRXZlbnRUeXBlLFxufSBmcm9tICcuL2NvbnRyb2xsZXJzL25ldHdvcmsnO1xuaW1wb3J0IFByZWZlcmVuY2VzQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL3ByZWZlcmVuY2VzJztcbmltcG9ydCBBcHBTdGF0ZUNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVycy9hcHAtc3RhdGUnO1xuaW1wb3J0IENhY2hlZEJhbGFuY2VzQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL2NhY2hlZC1iYWxhbmNlcyc7XG5pbXBvcnQgQWxlcnRDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlcnMvYWxlcnQnO1xuaW1wb3J0IE9uYm9hcmRpbmdDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlcnMvb25ib2FyZGluZyc7XG5pbXBvcnQgQmFja3VwQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL2JhY2t1cCc7XG5pbXBvcnQgSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlcnMvaW5jb21pbmctdHJhbnNhY3Rpb25zJztcbmltcG9ydCBEZWNyeXB0TWVzc2FnZUNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVycy9kZWNyeXB0LW1lc3NhZ2UnO1xuaW1wb3J0IFRyYW5zYWN0aW9uQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL3RyYW5zYWN0aW9ucyc7XG5pbXBvcnQgRGV0ZWN0VG9rZW5zQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL2RldGVjdC10b2tlbnMnO1xuaW1wb3J0IFN3YXBzQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL3N3YXBzJztcbmltcG9ydCBhY2NvdW50SW1wb3J0ZXIgZnJvbSAnLi9hY2NvdW50LWltcG9ydC1zdHJhdGVnaWVzJztcbmltcG9ydCBzZWVkUGhyYXNlVmVyaWZpZXIgZnJvbSAnLi9saWIvc2VlZC1waHJhc2UtdmVyaWZpZXInO1xuaW1wb3J0IE1ldGFNZXRyaWNzQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL21ldGFtZXRyaWNzJztcbmltcG9ydCB7IHNlZ21lbnQgfSBmcm9tICcuL2xpYi9zZWdtZW50JztcbmltcG9ydCBjcmVhdGVNZXRhUlBDSGFuZGxlciBmcm9tICcuL2xpYi9jcmVhdGVNZXRhUlBDSGFuZGxlcic7XG5pbXBvcnQgeyBwcmV2aW91c1ZhbHVlQ29tcGFyYXRvciB9IGZyb20gJy4vbGliL3V0aWwnO1xuaW1wb3J0IGNyZWF0ZU1ldGFtYXNrTWlkZGxld2FyZSBmcm9tICcuL2xpYi9jcmVhdGVNZXRhbWFza01pZGRsZXdhcmUnO1xuaW1wb3J0IEVuY3J5cHRpb25QdWJsaWNLZXlDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlcnMvZW5jcnlwdGlvbi1wdWJsaWMta2V5JztcblxuaW1wb3J0IHtcbiAgQ2F2ZWF0TXV0YXRvckZhY3RvcmllcyxcbiAgZ2V0Q2F2ZWF0U3BlY2lmaWNhdGlvbnMsXG4gIGdldENoYW5nZWRBY2NvdW50cyxcbiAgZ2V0UGVybWlzc2lvbkJhY2tncm91bmRBcGlNZXRob2RzLFxuICBnZXRQZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMsXG4gIGdldFBlcm1pdHRlZEFjY291bnRzQnlPcmlnaW4sXG4gIE5PVElGSUNBVElPTl9OQU1FUyxcbiAgUGVybWlzc2lvbkxvZ0NvbnRyb2xsZXIsXG4gIHVucmVzdHJpY3RlZE1ldGhvZHMsXG59IGZyb20gJy4vY29udHJvbGxlcnMvcGVybWlzc2lvbnMnO1xuaW1wb3J0IGNyZWF0ZVJQQ01ldGhvZFRyYWNraW5nTWlkZGxld2FyZSBmcm9tICcuL2xpYi9jcmVhdGVSUENNZXRob2RUcmFja2luZ01pZGRsZXdhcmUnO1xuaW1wb3J0IHsgc2VjdXJpdHlQcm92aWRlckNoZWNrIH0gZnJvbSAnLi9saWIvc2VjdXJpdHktcHJvdmlkZXItaGVscGVycyc7XG5cbmV4cG9ydCBjb25zdCBNRVRBTUFTS19DT05UUk9MTEVSX0VWRU5UUyA9IHtcbiAgLy8gRmlyZWQgYWZ0ZXIgc3RhdGUgY2hhbmdlcyB0aGF0IGltcGFjdCB0aGUgZXh0ZW5zaW9uIGJhZGdlICh1bmFwcHJvdmVkIG1zZyBjb3VudClcbiAgLy8gVGhlIHByb2Nlc3Mgb2YgdXBkYXRpbmcgdGhlIGJhZGdlIGhhcHBlbnMgaW4gYXBwL3NjcmlwdHMvYmFja2dyb3VuZC5qcy5cbiAgVVBEQVRFX0JBREdFOiAndXBkYXRlQmFkZ2UnLFxuICAvLyBUT0RPOiBBZGQgdGhpcyBhbmQgc2ltaWxhciBlbnVtcyB0byB0aGUgYGNvbnRyb2xsZXJzYCByZXBvIGFuZCBleHBvcnQgdGhlbVxuICBBUFBST1ZBTF9TVEFURV9DSEFOR0U6ICdBcHByb3ZhbENvbnRyb2xsZXI6c3RhdGVDaGFuZ2UnLFxufTtcblxuLy8gc3RyZWFtIGNoYW5uZWxzXG5jb25zdCBQSElTSElOR19TQUZFTElTVCA9ICdtZXRhbWFzay1waGlzaGluZy1zYWZlbGlzdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1ldGFtYXNrQ29udHJvbGxlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb25zdCB7IGlzRmlyc3RNZXRhTWFza0NvbnRyb2xsZXJTZXR1cCB9ID0gb3B0cztcblxuICAgIHRoaXMuZGVmYXVsdE1heExpc3RlbmVycyA9IDIwO1xuXG4gICAgdGhpcy5zZW5kVXBkYXRlID0gZGVib3VuY2UoXG4gICAgICB0aGlzLnByaXZhdGVTZW5kVXBkYXRlLmJpbmQodGhpcyksXG4gICAgICBNSUxMSVNFQ09ORCAqIDIwMCxcbiAgICApO1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5leHRlbnNpb24gPSBvcHRzLmJyb3dzZXI7XG4gICAgdGhpcy5wbGF0Zm9ybSA9IG9wdHMucGxhdGZvcm07XG4gICAgdGhpcy5ub3RpZmljYXRpb25NYW5hZ2VyID0gb3B0cy5ub3RpZmljYXRpb25NYW5hZ2VyO1xuICAgIGNvbnN0IGluaXRTdGF0ZSA9IG9wdHMuaW5pdFN0YXRlIHx8IHt9O1xuICAgIGNvbnN0IHZlcnNpb24gPSB0aGlzLnBsYXRmb3JtLmdldFZlcnNpb24oKTtcbiAgICB0aGlzLnJlY29yZEZpcnN0VGltZUluZm8oaW5pdFN0YXRlKTtcblxuICAgIC8vIHRoaXMga2VlcHMgdHJhY2sgb2YgaG93IG1hbnkgXCJjb250cm9sbGVyU3RyZWFtXCIgY29ubmVjdGlvbnMgYXJlIG9wZW5cbiAgICAvLyB0aGUgb25seSB0aGluZyB0aGF0IHVzZXMgY29udHJvbGxlciBjb25uZWN0aW9ucyBhcmUgb3BlbiBtZXRhbWFzayBVSSBpbnN0YW5jZXNcbiAgICB0aGlzLmFjdGl2ZUNvbnRyb2xsZXJDb25uZWN0aW9ucyA9IDA7XG5cbiAgICB0aGlzLmdldFJlcXVlc3RBY2NvdW50VGFiSWRzID0gb3B0cy5nZXRSZXF1ZXN0QWNjb3VudFRhYklkcztcbiAgICB0aGlzLmdldE9wZW5NZXRhbWFza1RhYnNJZHMgPSBvcHRzLmdldE9wZW5NZXRhbWFza1RhYnNJZHM7XG5cbiAgICB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIgPSBuZXcgQ29udHJvbGxlck1lc3NlbmdlcigpO1xuXG4gICAgLy8gaW5zdGFuY2Ugb2YgYSBjbGFzcyB0aGF0IHdyYXBzIHRoZSBleHRlbnNpb24ncyBzdG9yYWdlIGxvY2FsIEFQSS5cbiAgICB0aGlzLmxvY2FsU3RvcmVBcGlXcmFwcGVyID0gb3B0cy5sb2NhbFN0b3JlO1xuXG4gICAgLy8gb2JzZXJ2YWJsZSBzdGF0ZSBzdG9yZVxuICAgIHRoaXMuc3RvcmUgPSBuZXcgQ29tcG9zYWJsZU9ic2VydmFibGVTdG9yZSh7XG4gICAgICBzdGF0ZTogaW5pdFN0YXRlLFxuICAgICAgY29udHJvbGxlck1lc3NlbmdlcjogdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLFxuICAgICAgcGVyc2lzdDogdHJ1ZSxcbiAgICB9KTtcblxuICAgIC8vIGV4dGVybmFsIGNvbm5lY3Rpb25zIGJ5IG9yaWdpblxuICAgIC8vIERvIG5vdCBtb2RpZnkgZGlyZWN0bHkuIFVzZSB0aGUgYXNzb2NpYXRlZCBtZXRob2RzLlxuICAgIHRoaXMuY29ubmVjdGlvbnMgPSB7fTtcblxuICAgIC8vIGxvY2sgdG8gZW5zdXJlIG9ubHkgb25lIHZhdWx0IGNyZWF0ZWQgYXQgb25jZVxuICAgIHRoaXMuY3JlYXRlVmF1bHRNdXRleCA9IG5ldyBNdXRleCgpO1xuXG4gICAgdGhpcy5leHRlbnNpb24ucnVudGltZS5vbkluc3RhbGxlZC5hZGRMaXN0ZW5lcigoZGV0YWlscykgPT4ge1xuICAgICAgaWYgKGRldGFpbHMucmVhc29uID09PSAndXBkYXRlJyAmJiB2ZXJzaW9uID09PSAnOC4xLjAnKSB7XG4gICAgICAgIHRoaXMucGxhdGZvcm0ub3BlbkV4dGVuc2lvbkluQnJvd3NlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gbmV4dCwgd2Ugd2lsbCBpbml0aWFsaXplIHRoZSBjb250cm9sbGVyc1xuICAgIC8vIGNvbnRyb2xsZXIgaW5pdGlhbGl6YXRpb24gb3JkZXIgbWF0dGVyc1xuXG4gICAgdGhpcy5hcHByb3ZhbENvbnRyb2xsZXIgPSBuZXcgQXBwcm92YWxDb250cm9sbGVyKHtcbiAgICAgIG1lc3NlbmdlcjogdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLmdldFJlc3RyaWN0ZWQoe1xuICAgICAgICBuYW1lOiAnQXBwcm92YWxDb250cm9sbGVyJyxcbiAgICAgIH0pLFxuICAgICAgc2hvd0FwcHJvdmFsUmVxdWVzdDogb3B0cy5zaG93VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIHR5cGVzRXhjbHVkZWRGcm9tUmF0ZUxpbWl0aW5nOiBbXG4gICAgICAgIEFwcHJvdmFsVHlwZS5FdGhTaWduLFxuICAgICAgICBBcHByb3ZhbFR5cGUuUGVyc29uYWxTaWduLFxuICAgICAgICBBcHByb3ZhbFR5cGUuRXRoU2lnblR5cGVkRGF0YSxcbiAgICAgICAgQXBwcm92YWxUeXBlLlRyYW5zYWN0aW9uLFxuICAgICAgICBBcHByb3ZhbFR5cGUuV2F0Y2hBc3NldCxcbiAgICAgICAgQXBwcm92YWxUeXBlLkV0aEdldEVuY3J5cHRpb25QdWJsaWNLZXksXG4gICAgICAgIEFwcHJvdmFsVHlwZS5FdGhEZWNyeXB0LFxuICAgICAgXSxcbiAgICB9KTtcblxuICAgIGNvbnN0IG5ldHdvcmtDb250cm9sbGVyTWVzc2VuZ2VyID0gdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLmdldFJlc3RyaWN0ZWQoe1xuICAgICAgbmFtZTogJ05ldHdvcmtDb250cm9sbGVyJyxcbiAgICAgIGFsbG93ZWRFdmVudHM6IE9iamVjdC52YWx1ZXMoTmV0d29ya0NvbnRyb2xsZXJFdmVudFR5cGUpLFxuICAgIH0pO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIgPSBuZXcgTmV0d29ya0NvbnRyb2xsZXIoe1xuICAgICAgbWVzc2VuZ2VyOiBuZXR3b3JrQ29udHJvbGxlck1lc3NlbmdlcixcbiAgICAgIHN0YXRlOiBpbml0U3RhdGUuTmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICBpbmZ1cmFQcm9qZWN0SWQ6IG9wdHMuaW5mdXJhUHJvamVjdElkLFxuICAgICAgdHJhY2tNZXRhTWV0cmljc0V2ZW50OiAoLi4uYXJncykgPT5cbiAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tFdmVudCguLi5hcmdzKSxcbiAgICB9KTtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmluaXRpYWxpemVQcm92aWRlcigpO1xuICAgIHRoaXMucHJvdmlkZXIgPVxuICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRQcm92aWRlckFuZEJsb2NrVHJhY2tlcigpLnByb3ZpZGVyO1xuICAgIHRoaXMuYmxvY2tUcmFja2VyID1cbiAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0UHJvdmlkZXJBbmRCbG9ja1RyYWNrZXIoKS5ibG9ja1RyYWNrZXI7XG5cbiAgICBjb25zdCB0b2tlbkxpc3RNZXNzZW5nZXIgPSB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuZ2V0UmVzdHJpY3RlZCh7XG4gICAgICBuYW1lOiAnVG9rZW5MaXN0Q29udHJvbGxlcicsXG4gICAgfSk7XG5cbiAgICB0aGlzLnRva2VuTGlzdENvbnRyb2xsZXIgPSBuZXcgVG9rZW5MaXN0Q29udHJvbGxlcih7XG4gICAgICBjaGFpbklkOiBoZXhUb0RlY2ltYWwoXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5wcm92aWRlckNvbmZpZy5jaGFpbklkLFxuICAgICAgKSxcbiAgICAgIHByZXZlbnRQb2xsaW5nT25OZXR3b3JrUmVzdGFydDogaW5pdFN0YXRlLlRva2VuTGlzdENvbnRyb2xsZXJcbiAgICAgICAgPyBpbml0U3RhdGUuVG9rZW5MaXN0Q29udHJvbGxlci5wcmV2ZW50UG9sbGluZ09uTmV0d29ya1Jlc3RhcnRcbiAgICAgICAgOiB0cnVlLFxuICAgICAgb25OZXR3b3JrU3RhdGVDaGFuZ2U6IChjYikgPT4ge1xuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZSgobmV0d29ya1N0YXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgbW9kaWZpZWROZXR3b3JrU3RhdGUgPSB7XG4gICAgICAgICAgICAuLi5uZXR3b3JrU3RhdGUsXG4gICAgICAgICAgICBwcm92aWRlckNvbmZpZzoge1xuICAgICAgICAgICAgICAuLi5uZXR3b3JrU3RhdGUucHJvdmlkZXJDb25maWcsXG4gICAgICAgICAgICAgIGNoYWluSWQ6IGhleFRvRGVjaW1hbChuZXR3b3JrU3RhdGUucHJvdmlkZXJDb25maWcuY2hhaW5JZCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGNiKG1vZGlmaWVkTmV0d29ya1N0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgbWVzc2VuZ2VyOiB0b2tlbkxpc3RNZXNzZW5nZXIsXG4gICAgICBzdGF0ZTogaW5pdFN0YXRlLlRva2VuTGlzdENvbnRyb2xsZXIsXG4gICAgfSk7XG5cbiAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlciA9IG5ldyBQcmVmZXJlbmNlc0NvbnRyb2xsZXIoe1xuICAgICAgaW5pdFN0YXRlOiBpbml0U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgaW5pdExhbmdDb2RlOiBvcHRzLmluaXRMYW5nQ29kZSxcbiAgICAgIG9uSW5mdXJhSXNCbG9ja2VkOiBuZXR3b3JrQ29udHJvbGxlck1lc3Nlbmdlci5zdWJzY3JpYmUuYmluZChcbiAgICAgICAgbmV0d29ya0NvbnRyb2xsZXJNZXNzZW5nZXIsXG4gICAgICAgIE5ldHdvcmtDb250cm9sbGVyRXZlbnRUeXBlLkluZnVyYUlzQmxvY2tlZCxcbiAgICAgICksXG4gICAgICBvbkluZnVyYUlzVW5ibG9ja2VkOiBuZXR3b3JrQ29udHJvbGxlck1lc3Nlbmdlci5zdWJzY3JpYmUuYmluZChcbiAgICAgICAgbmV0d29ya0NvbnRyb2xsZXJNZXNzZW5nZXIsXG4gICAgICAgIE5ldHdvcmtDb250cm9sbGVyRXZlbnRUeXBlLkluZnVyYUlzVW5ibG9ja2VkLFxuICAgICAgKSxcbiAgICAgIHRva2VuTGlzdENvbnRyb2xsZXI6IHRoaXMudG9rZW5MaXN0Q29udHJvbGxlcixcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgIH0pO1xuXG4gICAgdGhpcy50b2tlbnNDb250cm9sbGVyID0gbmV3IFRva2Vuc0NvbnRyb2xsZXIoe1xuICAgICAgb25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlOiB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5zdWJzY3JpYmUuYmluZChcbiAgICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICApLFxuICAgICAgb25OZXR3b3JrU3RhdGVDaGFuZ2U6IChjYikgPT5cbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5zdWJzY3JpYmUoKG5ldHdvcmtTdGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG1vZGlmaWVkTmV0d29ya1N0YXRlID0ge1xuICAgICAgICAgICAgLi4ubmV0d29ya1N0YXRlLFxuICAgICAgICAgICAgcHJvdmlkZXJDb25maWc6IHtcbiAgICAgICAgICAgICAgLi4ubmV0d29ya1N0YXRlLnByb3ZpZGVyQ29uZmlnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBjYihtb2RpZmllZE5ldHdvcmtTdGF0ZSk7XG4gICAgICAgIH0pLFxuICAgICAgY29uZmlnOiB7IHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyIH0sXG4gICAgICBzdGF0ZTogaW5pdFN0YXRlLlRva2Vuc0NvbnRyb2xsZXIsXG4gICAgICBtZXNzZW5nZXI6IHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5nZXRSZXN0cmljdGVkKHtcbiAgICAgICAgbmFtZTogJ1Rva2Vuc0NvbnRyb2xsZXInLFxuICAgICAgICBhbGxvd2VkQWN0aW9uczogW1xuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9OmFkZFJlcXVlc3RgLFxuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9OmFjY2VwdFJlcXVlc3RgLFxuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9OnJlamVjdFJlcXVlc3RgLFxuICAgICAgICBdLFxuICAgICAgfSksXG4gICAgfSk7XG5cbiAgICB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlciA9IG5ldyBBc3NldHNDb250cmFjdENvbnRyb2xsZXIoXG4gICAgICB7XG4gICAgICAgIG9uUHJlZmVyZW5jZXNTdGF0ZUNoYW5nZTogKGxpc3RlbmVyKSA9PlxuICAgICAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZShsaXN0ZW5lciksXG4gICAgICAgIC8vIFRoaXMgaGFuZGxlciBpcyBtaXNuYW1lZCwgYW5kIGlzIGEga25vd24gaXNzdWUgdGhhdCB3aWxsIGJlIHJlc29sdmVkXG4gICAgICAgIC8vIGJ5IHBsYW5uZWQgcmVmYWN0b3JzLiBJdCBzaG91bGQgYmUgb25OZXR3b3JrRGlkQ2hhbmdlIHdoaWNoIGhhcHBlbnNcbiAgICAgICAgLy8gQUZURVIgdGhlIHByb3ZpZGVyIGluIHRoZSBuZXR3b3JrIGNvbnRyb2xsZXIgaXMgdXBkYXRlZCB0byByZWZsZWN0XG4gICAgICAgIC8vIHRoZSBuZXcgc3RhdGUgb2YgdGhlIG5ldHdvcmsgY29udHJvbGxlci4gSW4gIzE4MDQxIHdlIGNoYW5nZWQgdGhpc1xuICAgICAgICAvLyBoYW5kbGVyIHRvIGJlIHRyaWdnZXJlZCBieSB0aGUgY2hhbmdlIGluIHRoZSBuZXR3b3JrIHN0YXRlIGJlY2F1c2VcbiAgICAgICAgLy8gdGhhdCBpcyB3aGF0IHRoZSBoYW5kbGVyIG5hbWUgaW1wbGllcywgYnV0IHRoaXMgdHJpZ2dlcnMgdG9vIHNvb25cbiAgICAgICAgLy8gY2F1c2luZyB0aGUgcHJvdmlkZXIgb2YgdGhlIEFzc2V0c0NvbnRyYWN0Q29udHJvbGxlciB0byB0cmFpbCB0aGVcbiAgICAgICAgLy8gbmV0d29yayBwcm92aWRlciBieSBvbmUgdXBkYXRlLlxuICAgICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZTogKGNiKSA9PlxuICAgICAgICAgIG5ldHdvcmtDb250cm9sbGVyTWVzc2VuZ2VyLnN1YnNjcmliZShcbiAgICAgICAgICAgIE5ldHdvcmtDb250cm9sbGVyRXZlbnRUeXBlLk5ldHdvcmtEaWRDaGFuZ2UsXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG5ldHdvcmtTdGF0ZSA9IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWROZXR3b3JrU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgLi4ubmV0d29ya1N0YXRlLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgICAuLi5uZXR3b3JrU3RhdGUucHJvdmlkZXJDb25maWcsXG4gICAgICAgICAgICAgICAgICBjaGFpbklkOiBoZXhUb0RlY2ltYWwobmV0d29ya1N0YXRlLnByb3ZpZGVyQ29uZmlnLmNoYWluSWQpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldHVybiBjYihtb2RpZmllZE5ldHdvcmtTdGF0ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICksXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICAgIH0sXG4gICAgICBpbml0U3RhdGUuQXNzZXRzQ29udHJhY3RDb250cm9sbGVyLFxuICAgICk7XG5cbiAgICB0aGlzLm5mdENvbnRyb2xsZXIgPSBuZXcgTmZ0Q29udHJvbGxlcihcbiAgICAgIHtcbiAgICAgICAgb25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlOlxuICAgICAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZS5iaW5kKFxuICAgICAgICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICAgICAgKSxcbiAgICAgICAgb25OZXR3b3JrU3RhdGVDaGFuZ2U6IChjYikgPT5cbiAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZSgobmV0d29ya1N0YXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb2RpZmllZE5ldHdvcmtTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgLi4ubmV0d29ya1N0YXRlLFxuICAgICAgICAgICAgICBwcm92aWRlckNvbmZpZzoge1xuICAgICAgICAgICAgICAgIC4uLm5ldHdvcmtTdGF0ZS5wcm92aWRlckNvbmZpZyxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBoZXhUb0RlY2ltYWwobmV0d29ya1N0YXRlLnByb3ZpZGVyQ29uZmlnLmNoYWluSWQpLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBjYihtb2RpZmllZE5ldHdvcmtTdGF0ZSk7XG4gICAgICAgICAgfSksXG4gICAgICAgIGdldEVSQzcyMUFzc2V0TmFtZTpcbiAgICAgICAgICB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlci5nZXRFUkM3MjFBc3NldE5hbWUuYmluZChcbiAgICAgICAgICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLFxuICAgICAgICAgICksXG4gICAgICAgIGdldEVSQzcyMUFzc2V0U3ltYm9sOlxuICAgICAgICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLmdldEVSQzcyMUFzc2V0U3ltYm9sLmJpbmQoXG4gICAgICAgICAgICB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcixcbiAgICAgICAgICApLFxuICAgICAgICBnZXRFUkM3MjFUb2tlblVSSTogdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIuZ2V0RVJDNzIxVG9rZW5VUkkuYmluZChcbiAgICAgICAgICB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgICAgZ2V0RVJDNzIxT3duZXJPZjogdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIuZ2V0RVJDNzIxT3duZXJPZi5iaW5kKFxuICAgICAgICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgICBnZXRFUkMxMTU1QmFsYW5jZU9mOlxuICAgICAgICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLmdldEVSQzExNTVCYWxhbmNlT2YuYmluZChcbiAgICAgICAgICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLFxuICAgICAgICAgICksXG4gICAgICAgIGdldEVSQzExNTVUb2tlblVSSTpcbiAgICAgICAgICB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlci5nZXRFUkMxMTU1VG9rZW5VUkkuYmluZChcbiAgICAgICAgICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLFxuICAgICAgICAgICksXG4gICAgICAgIG9uTmZ0QWRkZWQ6ICh7IGFkZHJlc3MsIHN5bWJvbCwgdG9rZW5JZCwgc3RhbmRhcmQsIHNvdXJjZSB9KSA9PlxuICAgICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnRyYWNrRXZlbnQoe1xuICAgICAgICAgICAgZXZlbnQ6IE1ldGFNZXRyaWNzRXZlbnROYW1lLk5mdEFkZGVkLFxuICAgICAgICAgICAgY2F0ZWdvcnk6IE1ldGFNZXRyaWNzRXZlbnRDYXRlZ29yeS5XYWxsZXQsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIHRva2VuX2NvbnRyYWN0X2FkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICAgIHRva2VuX3N5bWJvbDogc3ltYm9sLFxuICAgICAgICAgICAgICBhc3NldF90eXBlOiBBc3NldFR5cGUuTkZULFxuICAgICAgICAgICAgICB0b2tlbl9zdGFuZGFyZDogc3RhbmRhcmQsXG4gICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZW5zaXRpdmVQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIHRva2VuSWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pLFxuICAgICAgfSxcbiAgICAgIHt9LFxuICAgICAgaW5pdFN0YXRlLk5mdENvbnRyb2xsZXIsXG4gICAgKTtcblxuICAgIHRoaXMubmZ0Q29udHJvbGxlci5zZXRBcGlLZXkocHJvY2Vzcy5lbnYuT1BFTlNFQV9LRVkpO1xuXG4gICAgdGhpcy5uZnREZXRlY3Rpb25Db250cm9sbGVyID0gbmV3IE5mdERldGVjdGlvbkNvbnRyb2xsZXIoe1xuICAgICAgb25OZnRzU3RhdGVDaGFuZ2U6IChsaXN0ZW5lcikgPT4gdGhpcy5uZnRDb250cm9sbGVyLnN1YnNjcmliZShsaXN0ZW5lciksXG4gICAgICBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2U6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZS5iaW5kKFxuICAgICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICksXG4gICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZTogKGNiKSA9PlxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZSgobmV0d29ya1N0YXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgbW9kaWZpZWROZXR3b3JrU3RhdGUgPSB7XG4gICAgICAgICAgICAuLi5uZXR3b3JrU3RhdGUsXG4gICAgICAgICAgICBwcm92aWRlckNvbmZpZzoge1xuICAgICAgICAgICAgICAuLi5uZXR3b3JrU3RhdGUucHJvdmlkZXJDb25maWcsXG4gICAgICAgICAgICAgIGNoYWluSWQ6IGhleFRvRGVjaW1hbChuZXR3b3JrU3RhdGUucHJvdmlkZXJDb25maWcuY2hhaW5JZCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGNiKG1vZGlmaWVkTmV0d29ya1N0YXRlKTtcbiAgICAgICAgfSksXG4gICAgICBnZXRPcGVuU2VhQXBpS2V5OiAoKSA9PiB0aGlzLm5mdENvbnRyb2xsZXIub3BlblNlYUFwaUtleSxcbiAgICAgIGdldEJhbGFuY2VzSW5TaW5nbGVDYWxsOlxuICAgICAgICB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlci5nZXRCYWxhbmNlc0luU2luZ2xlQ2FsbC5iaW5kKFxuICAgICAgICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgYWRkTmZ0OiB0aGlzLm5mdENvbnRyb2xsZXIuYWRkTmZ0LmJpbmQodGhpcy5uZnRDb250cm9sbGVyKSxcbiAgICAgIGdldE5mdFN0YXRlOiAoKSA9PiB0aGlzLm5mdENvbnRyb2xsZXIuc3RhdGUsXG4gICAgfSk7XG5cbiAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlciA9IG5ldyBNZXRhTWV0cmljc0NvbnRyb2xsZXIoe1xuICAgICAgc2VnbWVudCxcbiAgICAgIHByZWZlcmVuY2VzU3RvcmU6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLFxuICAgICAgb25OZXR3b3JrRGlkQ2hhbmdlOiBuZXR3b3JrQ29udHJvbGxlck1lc3Nlbmdlci5zdWJzY3JpYmUuYmluZChcbiAgICAgICAgbmV0d29ya0NvbnRyb2xsZXJNZXNzZW5nZXIsXG4gICAgICAgIE5ldHdvcmtDb250cm9sbGVyRXZlbnRUeXBlLk5ldHdvcmtEaWRDaGFuZ2UsXG4gICAgICApLFxuICAgICAgZ2V0TmV0d29ya0lkZW50aWZpZXI6ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBycGNVcmwgfSA9XG4gICAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLnByb3ZpZGVyQ29uZmlnO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gTkVUV09SS19UWVBFUy5SUEMgPyBycGNVcmwgOiB0eXBlO1xuICAgICAgfSxcbiAgICAgIGdldEN1cnJlbnRDaGFpbklkOiAoKSA9PlxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkucHJvdmlkZXJDb25maWcuY2hhaW5JZCxcbiAgICAgIHZlcnNpb246IHRoaXMucGxhdGZvcm0uZ2V0VmVyc2lvbigpLFxuICAgICAgZW52aXJvbm1lbnQ6IHByb2Nlc3MuZW52Lk1FVEFNQVNLX0VOVklST05NRU5ULFxuICAgICAgZXh0ZW5zaW9uOiB0aGlzLmV4dGVuc2lvbixcbiAgICAgIGluaXRTdGF0ZTogaW5pdFN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgIGNhcHR1cmVFeGNlcHRpb24sXG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCd1cGRhdGUnLCAodXBkYXRlKSA9PiB7XG4gICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci5oYW5kbGVNZXRhTWFza1N0YXRlVXBkYXRlKHVwZGF0ZSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBnYXNGZWVNZXNzZW5nZXIgPSB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuZ2V0UmVzdHJpY3RlZCh7XG4gICAgICBuYW1lOiAnR2FzRmVlQ29udHJvbGxlcicsXG4gICAgfSk7XG5cbiAgICBjb25zdCBnYXNBcGlCYXNlVXJsID0gcHJvY2Vzcy5lbnYuU1dBUFNfVVNFX0RFVl9BUElTXG4gICAgICA/IEdBU19ERVZfQVBJX0JBU0VfVVJMXG4gICAgICA6IEdBU19BUElfQkFTRV9VUkw7XG5cbiAgICB0aGlzLmdhc0ZlZUNvbnRyb2xsZXIgPSBuZXcgR2FzRmVlQ29udHJvbGxlcih7XG4gICAgICBzdGF0ZTogaW5pdFN0YXRlLkdhc0ZlZUNvbnRyb2xsZXIsXG4gICAgICBpbnRlcnZhbDogMTAwMDAsXG4gICAgICBtZXNzZW5nZXI6IGdhc0ZlZU1lc3NlbmdlcixcbiAgICAgIGNsaWVudElkOiBTV0FQU19DTElFTlRfSUQsXG4gICAgICBnZXRQcm92aWRlcjogKCkgPT5cbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRQcm92aWRlckFuZEJsb2NrVHJhY2tlcigpLnByb3ZpZGVyLFxuICAgICAgLy8gTk9URTogVGhpcyBvcHRpb24gaXMgaW5hY2N1cmF0ZWx5IG5hbWVkOyBpdCBzaG91bGQgYmUgY2FsbGVkXG4gICAgICAvLyBvbk5ldHdvcmtEaWRDaGFuZ2VcbiAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlOiBuZXR3b3JrQ29udHJvbGxlck1lc3Nlbmdlci5zdWJzY3JpYmUuYmluZChcbiAgICAgICAgbmV0d29ya0NvbnRyb2xsZXJNZXNzZW5nZXIsXG4gICAgICAgIE5ldHdvcmtDb250cm9sbGVyRXZlbnRUeXBlLk5ldHdvcmtEaWRDaGFuZ2UsXG4gICAgICApLFxuICAgICAgZ2V0Q3VycmVudE5ldHdvcmtFSVAxNTU5Q29tcGF0aWJpbGl0eTpcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRFSVAxNTU5Q29tcGF0aWJpbGl0eS5iaW5kKFxuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICBnZXRDdXJyZW50QWNjb3VudEVJUDE1NTlDb21wYXRpYmlsaXR5OlxuICAgICAgICB0aGlzLmdldEN1cnJlbnRBY2NvdW50RUlQMTU1OUNvbXBhdGliaWxpdHkuYmluZCh0aGlzKSxcbiAgICAgIGxlZ2FjeUFQSUVuZHBvaW50OiBgJHtnYXNBcGlCYXNlVXJsfS9uZXR3b3Jrcy88Y2hhaW5faWQ+L2dhc1ByaWNlc2AsXG4gICAgICBFSVAxNTU5QVBJRW5kcG9pbnQ6IGAke2dhc0FwaUJhc2VVcmx9L25ldHdvcmtzLzxjaGFpbl9pZD4vc3VnZ2VzdGVkR2FzRmVlc2AsXG4gICAgICBnZXRDdXJyZW50TmV0d29ya0xlZ2FjeUdhc0FQSUNvbXBhdGliaWxpdHk6ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBjaGFpbklkIH0gPVxuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5wcm92aWRlckNvbmZpZztcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW52LklOX1RFU1QgfHwgY2hhaW5JZCA9PT0gQ0hBSU5fSURTLk1BSU5ORVQ7XG4gICAgICB9LFxuICAgICAgZ2V0Q2hhaW5JZDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuSU5fVEVTVFxuICAgICAgICAgID8gQ0hBSU5fSURTLk1BSU5ORVRcbiAgICAgICAgICA6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5wcm92aWRlckNvbmZpZy5jaGFpbklkO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHRoaXMucXJIYXJkd2FyZUtleXJpbmcgPSBuZXcgUVJIYXJkd2FyZUtleXJpbmcoKTtcblxuICAgIHRoaXMuYXBwU3RhdGVDb250cm9sbGVyID0gbmV3IEFwcFN0YXRlQ29udHJvbGxlcih7XG4gICAgICBhZGRVbmxvY2tMaXN0ZW5lcjogdGhpcy5vbi5iaW5kKHRoaXMsICd1bmxvY2snKSxcbiAgICAgIGlzVW5sb2NrZWQ6IHRoaXMuaXNVbmxvY2tlZC5iaW5kKHRoaXMpLFxuICAgICAgaW5pdFN0YXRlOiBpbml0U3RhdGUuQXBwU3RhdGVDb250cm9sbGVyLFxuICAgICAgb25JbmFjdGl2ZVRpbWVvdXQ6ICgpID0+IHRoaXMuc2V0TG9ja2VkKCksXG4gICAgICBwcmVmZXJlbmNlc1N0b3JlOiB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZSxcbiAgICAgIHFySGFyZHdhcmVTdG9yZTogdGhpcy5xckhhcmR3YXJlS2V5cmluZy5nZXRNZW1TdG9yZSgpLFxuICAgICAgbWVzc2VuZ2VyOiB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuZ2V0UmVzdHJpY3RlZCh7XG4gICAgICAgIG5hbWU6ICdBcHBTdGF0ZUNvbnRyb2xsZXInLFxuICAgICAgICBhbGxvd2VkQWN0aW9uczogW1xuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9OmFkZFJlcXVlc3RgLFxuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9OmFjY2VwdFJlcXVlc3RgLFxuICAgICAgICBdLFxuICAgICAgfSksXG4gICAgfSk7XG5cbiAgICBjb25zdCBjdXJyZW5jeVJhdGVNZXNzZW5nZXIgPSB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuZ2V0UmVzdHJpY3RlZCh7XG4gICAgICBuYW1lOiAnQ3VycmVuY3lSYXRlQ29udHJvbGxlcicsXG4gICAgfSk7XG4gICAgdGhpcy5jdXJyZW5jeVJhdGVDb250cm9sbGVyID0gbmV3IEN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIoe1xuICAgICAgaW5jbHVkZVVzZFJhdGU6IHRydWUsXG4gICAgICBtZXNzZW5nZXI6IGN1cnJlbmN5UmF0ZU1lc3NlbmdlcixcbiAgICAgIHN0YXRlOiB7XG4gICAgICAgIC4uLmluaXRTdGF0ZS5DdXJyZW5jeUNvbnRyb2xsZXIsXG4gICAgICAgIG5hdGl2ZUN1cnJlbmN5OlxuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5wcm92aWRlckNvbmZpZy50aWNrZXIsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgdGhpcy5waGlzaGluZ0NvbnRyb2xsZXIgPSBuZXcgUGhpc2hpbmdDb250cm9sbGVyKFxuICAgICAge30sXG4gICAgICBpbml0U3RhdGUuUGhpc2hpbmdDb250cm9sbGVyLFxuICAgICk7XG5cbiAgICB0aGlzLnBoaXNoaW5nQ29udHJvbGxlci5tYXliZVVwZGF0ZVN0YXRlKCk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuSU5fVEVTVCkge1xuICAgICAgdGhpcy5waGlzaGluZ0NvbnRyb2xsZXIuc2V0SG90bGlzdFJlZnJlc2hJbnRlcnZhbCg1ICogU0VDT05EKTtcbiAgICAgIHRoaXMucGhpc2hpbmdDb250cm9sbGVyLnNldFN0YWxlbGlzdFJlZnJlc2hJbnRlcnZhbCgzMCAqIFNFQ09ORCk7XG4gICAgfVxuXG4gICAgY29uc3QgYW5ub3VuY2VtZW50TWVzc2VuZ2VyID0gdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLmdldFJlc3RyaWN0ZWQoe1xuICAgICAgbmFtZTogJ0Fubm91bmNlbWVudENvbnRyb2xsZXInLFxuICAgIH0pO1xuICAgIHRoaXMuYW5ub3VuY2VtZW50Q29udHJvbGxlciA9IG5ldyBBbm5vdW5jZW1lbnRDb250cm9sbGVyKHtcbiAgICAgIG1lc3NlbmdlcjogYW5ub3VuY2VtZW50TWVzc2VuZ2VyLFxuICAgICAgYWxsQW5ub3VuY2VtZW50czogVUlfTk9USUZJQ0FUSU9OUyxcbiAgICAgIHN0YXRlOiBpbml0U3RhdGUuQW5ub3VuY2VtZW50Q29udHJvbGxlcixcbiAgICB9KTtcblxuICAgIC8vIHRva2VuIGV4Y2hhbmdlIHJhdGUgdHJhY2tlclxuICAgIHRoaXMudG9rZW5SYXRlc0NvbnRyb2xsZXIgPSBuZXcgVG9rZW5SYXRlc0NvbnRyb2xsZXIoXG4gICAgICB7XG4gICAgICAgIG9uVG9rZW5zU3RhdGVDaGFuZ2U6IChsaXN0ZW5lcikgPT5cbiAgICAgICAgICB0aGlzLnRva2Vuc0NvbnRyb2xsZXIuc3Vic2NyaWJlKGxpc3RlbmVyKSxcbiAgICAgICAgb25DdXJyZW5jeVJhdGVTdGF0ZUNoYW5nZTogKGxpc3RlbmVyKSA9PlxuICAgICAgICAgIHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5zdWJzY3JpYmUoXG4gICAgICAgICAgICBgJHt0aGlzLmN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIubmFtZX06c3RhdGVDaGFuZ2VgLFxuICAgICAgICAgICAgbGlzdGVuZXIsXG4gICAgICAgICAgKSxcbiAgICAgICAgb25OZXR3b3JrU3RhdGVDaGFuZ2U6IChjYikgPT5cbiAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZSgobmV0d29ya1N0YXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb2RpZmllZE5ldHdvcmtTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgLi4ubmV0d29ya1N0YXRlLFxuICAgICAgICAgICAgICBwcm92aWRlckNvbmZpZzoge1xuICAgICAgICAgICAgICAgIC4uLm5ldHdvcmtTdGF0ZS5wcm92aWRlckNvbmZpZyxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBoZXhUb0RlY2ltYWwobmV0d29ya1N0YXRlLnByb3ZpZGVyQ29uZmlnLmNoYWluSWQpLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBjYihtb2RpZmllZE5ldHdvcmtTdGF0ZSk7XG4gICAgICAgICAgfSksXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBkaXNhYmxlZDpcbiAgICAgICAgICAhdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS51c2VDdXJyZW5jeVJhdGVDaGVjayxcbiAgICAgIH0sXG4gICAgICBpbml0U3RhdGUuVG9rZW5SYXRlc0NvbnRyb2xsZXIsXG4gICAgKTtcbiAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5zdWJzY3JpYmUoXG4gICAgICBwcmV2aW91c1ZhbHVlQ29tcGFyYXRvcigocHJldlN0YXRlLCBjdXJyU3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgeyB1c2VDdXJyZW5jeVJhdGVDaGVjazogcHJldlVzZUN1cnJlbmN5UmF0ZUNoZWNrIH0gPSBwcmV2U3RhdGU7XG4gICAgICAgIGNvbnN0IHsgdXNlQ3VycmVuY3lSYXRlQ2hlY2s6IGN1cnJVc2VDdXJyZW5jeVJhdGVDaGVjayB9ID0gY3VyclN0YXRlO1xuICAgICAgICBpZiAoY3VyclVzZUN1cnJlbmN5UmF0ZUNoZWNrICYmICFwcmV2VXNlQ3VycmVuY3lSYXRlQ2hlY2spIHtcbiAgICAgICAgICB0aGlzLmN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIuc3RhcnQoKTtcbiAgICAgICAgICB0aGlzLnRva2VuUmF0ZXNDb250cm9sbGVyLmNvbmZpZ3VyZShcbiAgICAgICAgICAgIHsgZGlzYWJsZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWN1cnJVc2VDdXJyZW5jeVJhdGVDaGVjayAmJiBwcmV2VXNlQ3VycmVuY3lSYXRlQ2hlY2spIHtcbiAgICAgICAgICB0aGlzLmN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIuc3RvcCgpO1xuICAgICAgICAgIHRoaXMudG9rZW5SYXRlc0NvbnRyb2xsZXIuY29uZmlndXJlKHsgZGlzYWJsZWQ6IHRydWUgfSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKSksXG4gICAgKTtcblxuICAgIHRoaXMuZW5zQ29udHJvbGxlciA9IG5ldyBFbnNDb250cm9sbGVyKHtcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgICAgZ2V0Q3VycmVudENoYWluSWQ6ICgpID0+XG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5wcm92aWRlckNvbmZpZy5jaGFpbklkLFxuICAgICAgb25OZXR3b3JrRGlkQ2hhbmdlOiBuZXR3b3JrQ29udHJvbGxlck1lc3Nlbmdlci5zdWJzY3JpYmUuYmluZChcbiAgICAgICAgbmV0d29ya0NvbnRyb2xsZXJNZXNzZW5nZXIsXG4gICAgICAgIE5ldHdvcmtDb250cm9sbGVyRXZlbnRUeXBlLk5ldHdvcmtEaWRDaGFuZ2UsXG4gICAgICApLFxuICAgIH0pO1xuXG4gICAgdGhpcy5vbmJvYXJkaW5nQ29udHJvbGxlciA9IG5ldyBPbmJvYXJkaW5nQ29udHJvbGxlcih7XG4gICAgICBpbml0U3RhdGU6IGluaXRTdGF0ZS5PbmJvYXJkaW5nQ29udHJvbGxlcixcbiAgICB9KTtcblxuICAgIHRoaXMuaW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyID0gbmV3IEluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlcih7XG4gICAgICBibG9ja1RyYWNrZXI6IHRoaXMuYmxvY2tUcmFja2VyLFxuICAgICAgb25OZXR3b3JrRGlkQ2hhbmdlOiBuZXR3b3JrQ29udHJvbGxlck1lc3Nlbmdlci5zdWJzY3JpYmUuYmluZChcbiAgICAgICAgbmV0d29ya0NvbnRyb2xsZXJNZXNzZW5nZXIsXG4gICAgICAgIE5ldHdvcmtDb250cm9sbGVyRXZlbnRUeXBlLk5ldHdvcmtEaWRDaGFuZ2UsXG4gICAgICApLFxuICAgICAgZ2V0Q3VycmVudENoYWluSWQ6ICgpID0+XG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5wcm92aWRlckNvbmZpZy5jaGFpbklkLFxuICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyOiB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgIG9uYm9hcmRpbmdDb250cm9sbGVyOiB0aGlzLm9uYm9hcmRpbmdDb250cm9sbGVyLFxuICAgICAgaW5pdFN0YXRlOiBpbml0U3RhdGUuSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxuICAgIH0pO1xuXG4gICAgLy8gYWNjb3VudCB0cmFja2VyIHdhdGNoZXMgYmFsYW5jZXMsIG5vbmNlcywgYW5kIGFueSBjb2RlIGF0IHRoZWlyIGFkZHJlc3NcbiAgICB0aGlzLmFjY291bnRUcmFja2VyID0gbmV3IEFjY291bnRUcmFja2VyKHtcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgICAgYmxvY2tUcmFja2VyOiB0aGlzLmJsb2NrVHJhY2tlcixcbiAgICAgIGdldEN1cnJlbnRDaGFpbklkOiAoKSA9PlxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkucHJvdmlkZXJDb25maWcuY2hhaW5JZCxcbiAgICAgIGdldE5ldHdvcmtJZGVudGlmaWVyOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcnBjVXJsIH0gPVxuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5wcm92aWRlckNvbmZpZztcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IE5FVFdPUktfVFlQRVMuUlBDID8gcnBjVXJsIDogdHlwZTtcbiAgICAgIH0sXG4gICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXI6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgb25ib2FyZGluZ0NvbnRyb2xsZXI6IHRoaXMub25ib2FyZGluZ0NvbnRyb2xsZXIsXG4gICAgICBpbml0U3RhdGU6XG4gICAgICAgIGlzTWFuaWZlc3RWMyAmJlxuICAgICAgICBpc0ZpcnN0TWV0YU1hc2tDb250cm9sbGVyU2V0dXAgPT09IGZhbHNlICYmXG4gICAgICAgIGluaXRTdGF0ZS5BY2NvdW50VHJhY2tlcj8uYWNjb3VudHNcbiAgICAgICAgICA/IHsgYWNjb3VudHM6IGluaXRTdGF0ZS5BY2NvdW50VHJhY2tlci5hY2NvdW50cyB9XG4gICAgICAgICAgOiB7IGFjY291bnRzOiB7fSB9LFxuICAgIH0pO1xuXG4gICAgLy8gc3RhcnQgYW5kIHN0b3AgcG9sbGluZyBmb3IgYmFsYW5jZXMgYmFzZWQgb24gYWN0aXZlQ29udHJvbGxlckNvbm5lY3Rpb25zXG4gICAgdGhpcy5vbignY29udHJvbGxlckNvbm5lY3Rpb25DaGFuZ2VkJywgKGFjdGl2ZUNvbnRyb2xsZXJDb25uZWN0aW9ucykgPT4ge1xuICAgICAgY29uc3QgeyBjb21wbGV0ZWRPbmJvYXJkaW5nIH0gPVxuICAgICAgICB0aGlzLm9uYm9hcmRpbmdDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoYWN0aXZlQ29udHJvbGxlckNvbm5lY3Rpb25zID4gMCAmJiBjb21wbGV0ZWRPbmJvYXJkaW5nKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlck5ldHdvcmtyZXF1ZXN0cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdG9wTmV0d29ya1JlcXVlc3RzKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uYm9hcmRpbmdDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZShcbiAgICAgIHByZXZpb3VzVmFsdWVDb21wYXJhdG9yKGFzeW5jIChwcmV2U3RhdGUsIGN1cnJTdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGNvbXBsZXRlZE9uYm9hcmRpbmc6IHByZXZDb21wbGV0ZWRPbmJvYXJkaW5nIH0gPSBwcmV2U3RhdGU7XG4gICAgICAgIGNvbnN0IHsgY29tcGxldGVkT25ib2FyZGluZzogY3VyckNvbXBsZXRlZE9uYm9hcmRpbmcgfSA9IGN1cnJTdGF0ZTtcbiAgICAgICAgaWYgKCFwcmV2Q29tcGxldGVkT25ib2FyZGluZyAmJiBjdXJyQ29tcGxldGVkT25ib2FyZGluZykge1xuICAgICAgICAgIHRoaXMudHJpZ2dlck5ldHdvcmtyZXF1ZXN0cygpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzLm9uYm9hcmRpbmdDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkpLFxuICAgICk7XG5cbiAgICB0aGlzLmNhY2hlZEJhbGFuY2VzQ29udHJvbGxlciA9IG5ldyBDYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXIoe1xuICAgICAgYWNjb3VudFRyYWNrZXI6IHRoaXMuYWNjb3VudFRyYWNrZXIsXG4gICAgICBnZXRDdXJyZW50Q2hhaW5JZDogKCkgPT5cbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLnByb3ZpZGVyQ29uZmlnLmNoYWluSWQsXG4gICAgICBpbml0U3RhdGU6IGluaXRTdGF0ZS5DYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXIsXG4gICAgfSk7XG5cbiAgICBsZXQgYWRkaXRpb25hbEtleXJpbmdzID0gW2tleXJpbmdCdWlsZGVyRmFjdG9yeShRUkhhcmR3YXJlS2V5cmluZyldO1xuXG4gICAgaWYgKHRoaXMuY2FuVXNlSGFyZHdhcmVXYWxsZXRzKCkpIHtcbiAgICAgIGNvbnN0IGtleXJpbmdPdmVycmlkZXMgPSB0aGlzLm9wdHMub3ZlcnJpZGVzPy5rZXlyaW5ncztcblxuICAgICAgY29uc3QgYWRkaXRpb25hbEtleXJpbmdUeXBlcyA9IFtcbiAgICAgICAga2V5cmluZ092ZXJyaWRlcz8udHJlem9yIHx8IFRyZXpvcktleXJpbmcsXG4gICAgICAgIGtleXJpbmdPdmVycmlkZXM/LmxlZGdlciB8fCBMZWRnZXJCcmlkZ2VLZXlyaW5nLFxuICAgICAgICBrZXlyaW5nT3ZlcnJpZGVzPy5sYXR0aWNlIHx8IExhdHRpY2VLZXlyaW5nLFxuICAgICAgICBRUkhhcmR3YXJlS2V5cmluZyxcbiAgICAgIF07XG4gICAgICBhZGRpdGlvbmFsS2V5cmluZ3MgPSBhZGRpdGlvbmFsS2V5cmluZ1R5cGVzLm1hcCgoa2V5cmluZ1R5cGUpID0+XG4gICAgICAgIGtleXJpbmdCdWlsZGVyRmFjdG9yeShrZXlyaW5nVHlwZSksXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMua2V5cmluZ0NvbnRyb2xsZXIgPSBuZXcgS2V5cmluZ0NvbnRyb2xsZXIoe1xuICAgICAga2V5cmluZ0J1aWxkZXJzOiBhZGRpdGlvbmFsS2V5cmluZ3MsXG4gICAgICBpbml0U3RhdGU6IGluaXRTdGF0ZS5LZXlyaW5nQ29udHJvbGxlcixcbiAgICAgIGVuY3J5cHRvcjogb3B0cy5lbmNyeXB0b3IgfHwgdW5kZWZpbmVkLFxuICAgICAgY2FjaGVFbmNyeXB0aW9uS2V5OiBpc01hbmlmZXN0VjMsXG4gICAgfSk7XG5cbiAgICB0aGlzLmtleXJpbmdDb250cm9sbGVyLm1lbVN0b3JlLnN1YnNjcmliZSgoc3RhdGUpID0+XG4gICAgICB0aGlzLl9vbktleXJpbmdDb250cm9sbGVyVXBkYXRlKHN0YXRlKSxcbiAgICApO1xuXG4gICAgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5vbigndW5sb2NrJywgKCkgPT4gdGhpcy5fb25VbmxvY2soKSk7XG4gICAgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5vbignbG9jaycsICgpID0+IHRoaXMuX29uTG9jaygpKTtcblxuICAgIGNvbnN0IGdldElkZW50aXRpZXMgPSAoKSA9PlxuICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5pZGVudGl0aWVzO1xuXG4gICAgdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlciA9IG5ldyBQZXJtaXNzaW9uQ29udHJvbGxlcih7XG4gICAgICBtZXNzZW5nZXI6IHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5nZXRSZXN0cmljdGVkKHtcbiAgICAgICAgbmFtZTogJ1Blcm1pc3Npb25Db250cm9sbGVyJyxcbiAgICAgICAgYWxsb3dlZEFjdGlvbnM6IFtcbiAgICAgICAgICBgJHt0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5uYW1lfTphZGRSZXF1ZXN0YCxcbiAgICAgICAgICBgJHt0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5uYW1lfTpoYXNSZXF1ZXN0YCxcbiAgICAgICAgICBgJHt0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5uYW1lfTphY2NlcHRSZXF1ZXN0YCxcbiAgICAgICAgICBgJHt0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5uYW1lfTpyZWplY3RSZXF1ZXN0YCxcbiAgICAgICAgICBgU25hcENvbnRyb2xsZXI6Z2V0UGVybWl0dGVkYCxcbiAgICAgICAgICBgU25hcENvbnRyb2xsZXI6aW5zdGFsbGAsXG4gICAgICAgICAgYFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXI6Z2V0U3ViamVjdE1ldGFkYXRhYCxcbiAgICAgICAgXSxcbiAgICAgIH0pLFxuICAgICAgc3RhdGU6IGluaXRTdGF0ZS5QZXJtaXNzaW9uQ29udHJvbGxlcixcbiAgICAgIGNhdmVhdFNwZWNpZmljYXRpb25zOiBnZXRDYXZlYXRTcGVjaWZpY2F0aW9ucyh7IGdldElkZW50aXRpZXMgfSksXG4gICAgICBwZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnM6IHtcbiAgICAgICAgLi4uZ2V0UGVybWlzc2lvblNwZWNpZmljYXRpb25zKHtcbiAgICAgICAgICBnZXRJZGVudGl0aWVzLFxuICAgICAgICAgIGdldEFsbEFjY291bnRzOiB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzLmJpbmQoXG4gICAgICAgICAgICB0aGlzLmtleXJpbmdDb250cm9sbGVyLFxuICAgICAgICAgICksXG4gICAgICAgICAgY2FwdHVyZUtleXJpbmdUeXBlc1dpdGhNaXNzaW5nSWRlbnRpdGllczogKFxuICAgICAgICAgICAgaWRlbnRpdGllcyA9IHt9LFxuICAgICAgICAgICAgYWNjb3VudHMgPSBbXSxcbiAgICAgICAgICApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzTWlzc2luZ0lkZW50aXRpZXMgPSBhY2NvdW50cy5maWx0ZXIoXG4gICAgICAgICAgICAgIChhZGRyZXNzKSA9PiAhaWRlbnRpdGllc1thZGRyZXNzXSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBrZXlyaW5nVHlwZXNXaXRoTWlzc2luZ0lkZW50aXRpZXMgPVxuICAgICAgICAgICAgICBhY2NvdW50c01pc3NpbmdJZGVudGl0aWVzLm1hcChcbiAgICAgICAgICAgICAgICAoYWRkcmVzcykgPT5cbiAgICAgICAgICAgICAgICAgIHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ0ZvckFjY291bnQoYWRkcmVzcyk/LnR5cGUsXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNvbnN0IGlkZW50aXRpZXNDb3VudCA9IE9iamVjdC5rZXlzKGlkZW50aXRpZXMgfHwge30pLmxlbmd0aDtcblxuICAgICAgICAgICAgY29uc3QgYWNjb3VudFRyYWNrZXJDb3VudCA9IE9iamVjdC5rZXlzKFxuICAgICAgICAgICAgICB0aGlzLmFjY291bnRUcmFja2VyLnN0b3JlLmdldFN0YXRlKCkuYWNjb3VudHMgfHwge30sXG4gICAgICAgICAgICApLmxlbmd0aDtcblxuICAgICAgICAgICAgY2FwdHVyZUV4Y2VwdGlvbihcbiAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBBdHRlbXB0IHRvIGdldCBwZXJtaXNzaW9uIHNwZWNpZmljYXRpb25zIGZhaWxlZCBiZWNhdXNlIHRoZWlyIHdlcmUgJHthY2NvdW50cy5sZW5ndGh9IGFjY291bnRzLCBidXQgJHtpZGVudGl0aWVzQ291bnR9IGlkZW50aXRpZXMsIGFuZCB0aGUgJHtrZXlyaW5nVHlwZXNXaXRoTWlzc2luZ0lkZW50aXRpZXN9IGtleXJpbmdzIGluY2x1ZGVkIGFjY291bnRzIHdpdGggbWlzc2luZyBpZGVudGl0aWVzLiBNZWFud2hpbGUsIHRoZXJlIGFyZSAke2FjY291bnRUcmFja2VyQ291bnR9IGFjY291bnRzIGluIHRoZSBhY2NvdW50IHRyYWNrZXIuYCxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSksXG4gICAgICB9LFxuICAgICAgdW5yZXN0cmljdGVkTWV0aG9kcyxcbiAgICB9KTtcblxuICAgIHRoaXMucGVybWlzc2lvbkxvZ0NvbnRyb2xsZXIgPSBuZXcgUGVybWlzc2lvbkxvZ0NvbnRyb2xsZXIoe1xuICAgICAgcmVzdHJpY3RlZE1ldGhvZHM6IG5ldyBTZXQoT2JqZWN0LmtleXMoUmVzdHJpY3RlZE1ldGhvZHMpKSxcbiAgICAgIGluaXRTdGF0ZTogaW5pdFN0YXRlLlBlcm1pc3Npb25Mb2dDb250cm9sbGVyLFxuICAgIH0pO1xuXG4gICAgdGhpcy5zdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyID0gbmV3IFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIoe1xuICAgICAgbWVzc2VuZ2VyOiB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuZ2V0UmVzdHJpY3RlZCh7XG4gICAgICAgIG5hbWU6ICdTdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyJyxcbiAgICAgICAgYWxsb3dlZEFjdGlvbnM6IFtgJHt0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLm5hbWV9Omhhc1Blcm1pc3Npb25zYF0sXG4gICAgICB9KSxcbiAgICAgIHN0YXRlOiBpbml0U3RhdGUuU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcixcbiAgICAgIHN1YmplY3RDYWNoZUxpbWl0OiAxMDAsXG4gICAgfSk7XG5cblxuXG4gICAgdGhpcy5kZXRlY3RUb2tlbnNDb250cm9sbGVyID0gbmV3IERldGVjdFRva2Vuc0NvbnRyb2xsZXIoe1xuICAgICAgcHJlZmVyZW5jZXM6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgdG9rZW5zQ29udHJvbGxlcjogdGhpcy50b2tlbnNDb250cm9sbGVyLFxuICAgICAgYXNzZXRzQ29udHJhY3RDb250cm9sbGVyOiB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcixcbiAgICAgIG5ldHdvcms6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICBrZXlyaW5nTWVtU3RvcmU6IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIubWVtU3RvcmUsXG4gICAgICB0b2tlbkxpc3Q6IHRoaXMudG9rZW5MaXN0Q29udHJvbGxlcixcbiAgICAgIHRyYWNrTWV0YU1ldHJpY3NFdmVudDogdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tFdmVudC5iaW5kKFxuICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZHJlc3NCb29rQ29udHJvbGxlciA9IG5ldyBBZGRyZXNzQm9va0NvbnRyb2xsZXIoXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBpbml0U3RhdGUuQWRkcmVzc0Jvb2tDb250cm9sbGVyLFxuICAgICk7XG5cbiAgICB0aGlzLmFsZXJ0Q29udHJvbGxlciA9IG5ldyBBbGVydENvbnRyb2xsZXIoe1xuICAgICAgaW5pdFN0YXRlOiBpbml0U3RhdGUuQWxlcnRDb250cm9sbGVyLFxuICAgICAgcHJlZmVyZW5jZXNTdG9yZTogdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgfSk7XG5cbiAgICB0aGlzLmJhY2t1cENvbnRyb2xsZXIgPSBuZXcgQmFja3VwQ29udHJvbGxlcih7XG4gICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXI6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgYWRkcmVzc0Jvb2tDb250cm9sbGVyOiB0aGlzLmFkZHJlc3NCb29rQ29udHJvbGxlcixcbiAgICAgIG5ldHdvcmtDb250cm9sbGVyOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgdHJhY2tNZXRhTWV0cmljc0V2ZW50OiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50LmJpbmQoXG4gICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICB9KTtcblxuICAgIHRoaXMudHhDb250cm9sbGVyID0gbmV3IFRyYW5zYWN0aW9uQ29udHJvbGxlcih7XG4gICAgICBpbml0U3RhdGU6XG4gICAgICAgIGluaXRTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIgfHwgaW5pdFN0YXRlLlRyYW5zYWN0aW9uTWFuYWdlcixcbiAgICAgIGdldFBlcm1pdHRlZEFjY291bnRzOiB0aGlzLmdldFBlcm1pdHRlZEFjY291bnRzLmJpbmQodGhpcyksXG4gICAgICBnZXRQcm92aWRlckNvbmZpZzogKCkgPT5cbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLnByb3ZpZGVyQ29uZmlnLFxuICAgICAgZ2V0Q3VycmVudE5ldHdvcmtFSVAxNTU5Q29tcGF0aWJpbGl0eTpcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRFSVAxNTU5Q29tcGF0aWJpbGl0eS5iaW5kKFxuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICBnZXRDdXJyZW50QWNjb3VudEVJUDE1NTlDb21wYXRpYmlsaXR5OlxuICAgICAgICB0aGlzLmdldEN1cnJlbnRBY2NvdW50RUlQMTU1OUNvbXBhdGliaWxpdHkuYmluZCh0aGlzKSxcbiAgICAgIGdldE5ldHdvcmtJZDogKCkgPT4gdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLm5ldHdvcmtJZCxcbiAgICAgIGdldE5ldHdvcmtTdGF0dXM6ICgpID0+XG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5uZXR3b3JrU3RhdHVzLFxuICAgICAgb25OZXR3b3JrU3RhdGVDaGFuZ2U6IChsaXN0ZW5lcikgPT4ge1xuICAgICAgICBsZXQgcHJldmlvdXNOZXR3b3JrSWQgPVxuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5uZXR3b3JrSWQ7XG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlKChzdGF0ZSkgPT4ge1xuICAgICAgICAgIGlmIChwcmV2aW91c05ldHdvcmtJZCAhPT0gc3RhdGUubmV0d29ya0lkKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICAgICAgcHJldmlvdXNOZXR3b3JrSWQgPSBzdGF0ZS5uZXR3b3JrSWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBnZXRDdXJyZW50Q2hhaW5JZDogKCkgPT5cbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLnByb3ZpZGVyQ29uZmlnLmNoYWluSWQsXG4gICAgICBwcmVmZXJlbmNlc1N0b3JlOiB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZSxcbiAgICAgIHR4SGlzdG9yeUxpbWl0OiA2MCxcbiAgICAgIHNpZ25UcmFuc2FjdGlvbjogdGhpcy5rZXlyaW5nQ29udHJvbGxlci5zaWduVHJhbnNhY3Rpb24uYmluZChcbiAgICAgICAgdGhpcy5rZXlyaW5nQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICAgIGJsb2NrVHJhY2tlcjogdGhpcy5ibG9ja1RyYWNrZXIsXG4gICAgICBjcmVhdGVFdmVudEZyYWdtZW50OiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci5jcmVhdGVFdmVudEZyYWdtZW50LmJpbmQoXG4gICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHVwZGF0ZUV2ZW50RnJhZ21lbnQ6IHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnVwZGF0ZUV2ZW50RnJhZ21lbnQuYmluZChcbiAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgZmluYWxpemVFdmVudEZyYWdtZW50OlxuICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci5maW5hbGl6ZUV2ZW50RnJhZ21lbnQuYmluZChcbiAgICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgIGdldEV2ZW50RnJhZ21lbnRCeUlkOlxuICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci5nZXRFdmVudEZyYWdtZW50QnlJZC5iaW5kKFxuICAgICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgdHJhY2tNZXRhTWV0cmljc0V2ZW50OiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50LmJpbmQoXG4gICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIGdldFBhcnRpY2lwYXRlSW5NZXRyaWNzOiAoKSA9PlxuICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci5zdGF0ZS5wYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3MsXG4gICAgICBnZXRFSVAxNTU5R2FzRmVlRXN0aW1hdGVzOlxuICAgICAgICB0aGlzLmdhc0ZlZUNvbnRyb2xsZXIuZmV0Y2hHYXNGZWVFc3RpbWF0ZXMuYmluZCh0aGlzLmdhc0ZlZUNvbnRyb2xsZXIpLFxuICAgICAgZ2V0RXh0ZXJuYWxQZW5kaW5nVHJhbnNhY3Rpb25zOlxuICAgICAgICB0aGlzLmdldEV4dGVybmFsUGVuZGluZ1RyYW5zYWN0aW9ucy5iaW5kKHRoaXMpLFxuICAgICAgZ2V0QWNjb3VudFR5cGU6IHRoaXMuZ2V0QWNjb3VudFR5cGUuYmluZCh0aGlzKSxcbiAgICAgIGdldERldmljZU1vZGVsOiB0aGlzLmdldERldmljZU1vZGVsLmJpbmQodGhpcyksXG4gICAgICBnZXRUb2tlblN0YW5kYXJkQW5kRGV0YWlsczogdGhpcy5nZXRUb2tlblN0YW5kYXJkQW5kRGV0YWlscy5iaW5kKHRoaXMpLFxuICAgICAgc2VjdXJpdHlQcm92aWRlclJlcXVlc3Q6IHRoaXMuc2VjdXJpdHlQcm92aWRlclJlcXVlc3QuYmluZCh0aGlzKSxcbiAgICAgIG1lc3NlbmdlcjogdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLmdldFJlc3RyaWN0ZWQoe1xuICAgICAgICBuYW1lOiAnVHJhbnNhY3Rpb25Db250cm9sbGVyJyxcbiAgICAgICAgYWxsb3dlZEFjdGlvbnM6IFtcbiAgICAgICAgICBgJHt0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5uYW1lfTphZGRSZXF1ZXN0YCxcbiAgICAgICAgICBgJHt0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5uYW1lfTphY2NlcHRSZXF1ZXN0YCxcbiAgICAgICAgICBgJHt0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5uYW1lfTpyZWplY3RSZXF1ZXN0YCxcbiAgICAgICAgXSxcbiAgICAgIH0pLFxuICAgIH0pO1xuXG4gICAgdGhpcy50eENvbnRyb2xsZXIub24oYHR4OnN0YXR1cy11cGRhdGVgLCBhc3luYyAodHhJZCwgc3RhdHVzKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIHN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuY29uZmlybWVkIHx8XG4gICAgICAgIHN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuZmFpbGVkXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgdHhNZXRhID0gdGhpcy50eENvbnRyb2xsZXIudHhTdGF0ZU1hbmFnZXIuZ2V0VHJhbnNhY3Rpb24odHhJZCk7XG4gICAgICAgIGxldCBycGNQcmVmcyA9IHt9O1xuICAgICAgICBpZiAodHhNZXRhLmNoYWluSWQpIHtcbiAgICAgICAgICBjb25zdCB7IG5ldHdvcmtDb25maWd1cmF0aW9ucyB9ID1cbiAgICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBjb25zdCBtYXRjaGluZ05ldHdvcmtDb25maWcgPSBPYmplY3QudmFsdWVzKFxuICAgICAgICAgICAgbmV0d29ya0NvbmZpZ3VyYXRpb25zLFxuICAgICAgICAgICkuZmluZChcbiAgICAgICAgICAgIChuZXR3b3JrQ29uZmlndXJhdGlvbikgPT5cbiAgICAgICAgICAgICAgbmV0d29ya0NvbmZpZ3VyYXRpb24uY2hhaW5JZCA9PT0gdHhNZXRhLmNoYWluSWQsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBycGNQcmVmcyA9IG1hdGNoaW5nTmV0d29ya0NvbmZpZz8ucnBjUHJlZnMgPz8ge307XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMucGxhdGZvcm0uc2hvd1RyYW5zYWN0aW9uTm90aWZpY2F0aW9uKHR4TWV0YSwgcnBjUHJlZnMpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxvZy5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSB0cmFuc2FjdGlvbiBub3RpZmljYXRpb24nLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHR4UmVjZWlwdCB9ID0gdHhNZXRhO1xuXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSB0cmFuc2ZlckZyb20gbWV0aG9kIGdlbmVyYXRlZCBmcm9tIHdpdGhpbiB0aGUgYXBwIGl0IG1heSBiZSBhbiBORlQgdHJhbnNmZXIgdHJhbnNhY3Rpb25cbiAgICAgICAgLy8gaW4gd2hpY2ggY2FzZSB3ZSB3aWxsIHdhbnQgdG8gY2hlY2sgYW5kIHVwZGF0ZSBvd25lcnNoaXAgc3RhdHVzIG9mIHRoZSB0cmFuc2ZlcnJlZCBORlQuXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0eE1ldGEudHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLnRva2VuTWV0aG9kVHJhbnNmZXJGcm9tICYmXG4gICAgICAgICAgdHhNZXRhLnR4UGFyYW1zICE9PSB1bmRlZmluZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHRvOiBjb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICBmcm9tOiB1c2VyQWRkcmVzcyxcbiAgICAgICAgICB9ID0gdHhNZXRhLnR4UGFyYW1zO1xuICAgICAgICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gdHhNZXRhO1xuICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uRGF0YSA9IHBhcnNlU3RhbmRhcmRUb2tlblRyYW5zYWN0aW9uRGF0YShkYXRhKTtcbiAgICAgICAgICAvLyBTb21ldGltZXMgdGhlIHRva2VuSWQgdmFsdWUgaXMgcGFyc2VkIGFzIFwiX3ZhbHVlXCIgcGFyYW0uIE5vdCBzZWVpbmcgdGhpcyBvZnRlbiBhbnkgbW9yZSwgYnV0IHN0aWxsIG9jY2FzaW9uYWxseTpcbiAgICAgICAgICAvLyBpLmUuIGNhbGwgYXBwcm92ZSgpIG9uIEJBWUMgY29udHJhY3QgLSBodHRwczovL2V0aGVyc2Nhbi5pby90b2tlbi8weGJjNGNhMGVkYTc2NDdhOGFiN2MyMDYxYzJlMTE4YTE4YTkzNmYxM2Qjd3JpdGVDb250cmFjdCwgYW5kIHRva2VuSWQgc2hvd3MgdXAgYXMgX3ZhbHVlLFxuICAgICAgICAgIC8vIG5vdCBzdXJlIHdoeSBzaW5jZSBpdCBkb2Vzbid0IG1hdGNoIHRoZSBFUkM3MjEgQUJJIHNwZWMgd2UgdXNlIHRvIHBhcnNlIHRoZXNlIHRyYW5zYWN0aW9ucyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9tZXRhbWFzay1ldGgtYWJpcy9ibG9iL2QwNDc0MzA4YTI4OGY5MjUyNTk3YjdjOTNhM2E4ZGVhYWQxOWUxYjIvc3JjL2FiaXMvYWJpRVJDNzIxLnRzI0w2Mi5cbiAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbkRhdGFUb2tlbklkID1cbiAgICAgICAgICAgIGdldFRva2VuSWRQYXJhbSh0cmFuc2FjdGlvbkRhdGEpID8/XG4gICAgICAgICAgICBnZXRUb2tlblZhbHVlUGFyYW0odHJhbnNhY3Rpb25EYXRhKTtcbiAgICAgICAgICBjb25zdCB7IGFsbE5mdHMgfSA9IHRoaXMubmZ0Q29udHJvbGxlci5zdGF0ZTtcblxuICAgICAgICAgIGNvbnN0IGNoYWluSWRBc0RlY2ltYWwgPSBoZXhUb0RlY2ltYWwoY2hhaW5JZCk7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgaXRzIGEga25vd24gTkZUXG4gICAgICAgICAgY29uc3Qga25vd25OZnQgPSBhbGxOZnRzPy5bdXNlckFkZHJlc3NdPy5bY2hhaW5JZEFzRGVjaW1hbF0/LmZpbmQoXG4gICAgICAgICAgICAoeyBhZGRyZXNzLCB0b2tlbklkIH0pID0+XG4gICAgICAgICAgICAgIGlzRXF1YWxDYXNlSW5zZW5zaXRpdmUoYWRkcmVzcywgY29udHJhY3RBZGRyZXNzKSAmJlxuICAgICAgICAgICAgICB0b2tlbklkID09PSB0cmFuc2FjdGlvbkRhdGFUb2tlbklkLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBpZiBpdCBpcyB3ZSBjaGVjayBhbmQgdXBkYXRlIG93bmVyc2hpcCBzdGF0dXMuXG4gICAgICAgICAgaWYgKGtub3duTmZ0KSB7XG4gICAgICAgICAgICB0aGlzLm5mdENvbnRyb2xsZXIuY2hlY2tBbmRVcGRhdGVTaW5nbGVOZnRPd25lcnNoaXBTdGF0dXMoXG4gICAgICAgICAgICAgIGtub3duTmZ0LFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgeyB1c2VyQWRkcmVzcywgY2hhaW5JZDogY2hhaW5JZEFzRGVjaW1hbCB9LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtZXRhbWFza1N0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuXG4gICAgICAgIGlmICh0eFJlY2VpcHQgJiYgdHhSZWNlaXB0LnN0YXR1cyA9PT0gJzB4MCcpIHtcbiAgICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50KFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBldmVudDogJ1R4IFN0YXR1cyBVcGRhdGU6IE9uLUNoYWluIEZhaWx1cmUnLFxuICAgICAgICAgICAgICBjYXRlZ29yeTogTWV0YU1ldHJpY3NFdmVudENhdGVnb3J5LkJhY2tncm91bmQsXG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdUcmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZTogdHhNZXRhLnNpbXVsYXRpb25GYWlscz8ucmVhc29uLFxuICAgICAgICAgICAgICAgIG51bWJlck9mVG9rZW5zOiBtZXRhbWFza1N0YXRlLnRva2Vucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZBY2NvdW50czogT2JqZWN0LmtleXMobWV0YW1hc2tTdGF0ZS5hY2NvdW50cykubGVuZ3RoLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWF0b21vRXZlbnQ6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIG5ldHdvcmtDb250cm9sbGVyTWVzc2VuZ2VyLnN1YnNjcmliZShcbiAgICAgIE5ldHdvcmtDb250cm9sbGVyRXZlbnRUeXBlLk5ldHdvcmtEaWRDaGFuZ2UsXG4gICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdGlja2VyIH0gPVxuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5wcm92aWRlckNvbmZpZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIuc2V0TmF0aXZlQ3VycmVuY3kodGlja2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBUT0RPOiBIYW5kbGUgZmFpbHVyZSB0byBnZXQgY29udmVyc2lvbiByYXRlIG1vcmUgZ3JhY2VmdWxseVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICk7XG5cbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmxvb2t1cE5ldHdvcmsoKTtcbiAgICB0aGlzLmRlY3J5cHRNZXNzYWdlQ29udHJvbGxlciA9IG5ldyBEZWNyeXB0TWVzc2FnZUNvbnRyb2xsZXIoe1xuICAgICAgZ2V0U3RhdGU6IHRoaXMuZ2V0U3RhdGUuYmluZCh0aGlzKSxcbiAgICAgIGtleXJpbmdDb250cm9sbGVyOiB0aGlzLmtleXJpbmdDb250cm9sbGVyLFxuICAgICAgbWVzc2VuZ2VyOiB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuZ2V0UmVzdHJpY3RlZCh7XG4gICAgICAgIG5hbWU6ICdEZWNyeXB0TWVzc2FnZUNvbnRyb2xsZXInLFxuICAgICAgICBhbGxvd2VkQWN0aW9uczogW1xuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9OmFkZFJlcXVlc3RgLFxuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9OmFjY2VwdFJlcXVlc3RgLFxuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9OnJlamVjdFJlcXVlc3RgLFxuICAgICAgICBdLFxuICAgICAgfSksXG4gICAgICBtZXRyaWNzRXZlbnQ6IHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnRyYWNrRXZlbnQuYmluZChcbiAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgIH0pO1xuXG4gICAgdGhpcy5lbmNyeXB0aW9uUHVibGljS2V5Q29udHJvbGxlciA9IG5ldyBFbmNyeXB0aW9uUHVibGljS2V5Q29udHJvbGxlcih7XG4gICAgICBtZXNzZW5nZXI6IHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5nZXRSZXN0cmljdGVkKHtcbiAgICAgICAgbmFtZTogJ0VuY3J5cHRpb25QdWJsaWNLZXlDb250cm9sbGVyJyxcbiAgICAgICAgYWxsb3dlZEFjdGlvbnM6IFtcbiAgICAgICAgICBgJHt0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5uYW1lfTphZGRSZXF1ZXN0YCxcbiAgICAgICAgICBgJHt0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5uYW1lfTphY2NlcHRSZXF1ZXN0YCxcbiAgICAgICAgICBgJHt0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5uYW1lfTpyZWplY3RSZXF1ZXN0YCxcbiAgICAgICAgXSxcbiAgICAgIH0pLFxuICAgICAga2V5cmluZ0NvbnRyb2xsZXI6IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIsXG4gICAgICBnZXRTdGF0ZTogdGhpcy5nZXRTdGF0ZS5iaW5kKHRoaXMpLFxuICAgICAgbWV0cmljc0V2ZW50OiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50LmJpbmQoXG4gICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICB9KTtcblxuICAgIHRoaXMuc2lnbmF0dXJlQ29udHJvbGxlciA9IG5ldyBTaWduYXR1cmVDb250cm9sbGVyKHtcbiAgICAgIG1lc3NlbmdlcjogdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLmdldFJlc3RyaWN0ZWQoe1xuICAgICAgICBuYW1lOiAnU2lnbmF0dXJlQ29udHJvbGxlcicsXG4gICAgICAgIGFsbG93ZWRBY3Rpb25zOiBbXG4gICAgICAgICAgYCR7dGhpcy5hcHByb3ZhbENvbnRyb2xsZXIubmFtZX06YWRkUmVxdWVzdGAsXG4gICAgICAgICAgYCR7dGhpcy5hcHByb3ZhbENvbnRyb2xsZXIubmFtZX06YWNjZXB0UmVxdWVzdGAsXG4gICAgICAgICAgYCR7dGhpcy5hcHByb3ZhbENvbnRyb2xsZXIubmFtZX06cmVqZWN0UmVxdWVzdGAsXG4gICAgICAgIF0sXG4gICAgICB9KSxcbiAgICAgIGtleXJpbmdDb250cm9sbGVyOiB0aGlzLmtleXJpbmdDb250cm9sbGVyLFxuICAgICAgaXNFdGhTaWduRW5hYmxlZDogKCkgPT5cbiAgICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKVxuICAgICAgICAgID8uZGlzYWJsZWRScGNNZXRob2RQcmVmZXJlbmNlcz8uZXRoX3NpZ24sXG4gICAgICBnZXRBbGxTdGF0ZTogdGhpcy5nZXRTdGF0ZS5iaW5kKHRoaXMpLFxuICAgICAgc2VjdXJpdHlQcm92aWRlclJlcXVlc3Q6IHRoaXMuc2VjdXJpdHlQcm92aWRlclJlcXVlc3QuYmluZCh0aGlzKSxcbiAgICAgIGdldEN1cnJlbnRDaGFpbklkOiAoKSA9PlxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkucHJvdmlkZXJDb25maWcuY2hhaW5JZCxcbiAgICB9KTtcblxuICAgIHRoaXMuc2lnbmF0dXJlQ29udHJvbGxlci5odWIub24oJ2NhbmNlbFdpdGhSZWFzb24nLCAobWVzc2FnZSwgcmVhc29uKSA9PiB7XG4gICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50KHtcbiAgICAgICAgZXZlbnQ6IHJlYXNvbixcbiAgICAgICAgY2F0ZWdvcnk6IE1ldGFNZXRyaWNzRXZlbnRDYXRlZ29yeS5UcmFuc2FjdGlvbnMsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBhY3Rpb246ICdTaWduIFJlcXVlc3QnLFxuICAgICAgICAgIHR5cGU6IG1lc3NhZ2UudHlwZSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zd2Fwc0NvbnRyb2xsZXIgPSBuZXcgU3dhcHNDb250cm9sbGVyKHtcbiAgICAgIGdldEJ1ZmZlcmVkR2FzTGltaXQ6IHRoaXMudHhDb250cm9sbGVyLnR4R2FzVXRpbC5nZXRCdWZmZXJlZEdhc0xpbWl0LmJpbmQoXG4gICAgICAgIHRoaXMudHhDb250cm9sbGVyLnR4R2FzVXRpbCxcbiAgICAgICksXG4gICAgICBuZXR3b3JrQ29udHJvbGxlcjogdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlOiAobGlzdGVuZXIpID0+XG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlKGxpc3RlbmVyKSxcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgICAgZ2V0UHJvdmlkZXJDb25maWc6ICgpID0+XG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5wcm92aWRlckNvbmZpZyxcbiAgICAgIGdldFRva2VuUmF0ZXNTdGF0ZTogKCkgPT4gdGhpcy50b2tlblJhdGVzQ29udHJvbGxlci5zdGF0ZSxcbiAgICAgIGdldEN1cnJlbnRDaGFpbklkOiAoKSA9PlxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkucHJvdmlkZXJDb25maWcuY2hhaW5JZCxcbiAgICAgIGdldEVJUDE1NTlHYXNGZWVFc3RpbWF0ZXM6XG4gICAgICAgIHRoaXMuZ2FzRmVlQ29udHJvbGxlci5mZXRjaEdhc0ZlZUVzdGltYXRlcy5iaW5kKHRoaXMuZ2FzRmVlQ29udHJvbGxlciksXG4gICAgfSk7XG4gICAgdGhpcy5zbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIgPSBuZXcgU21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyKFxuICAgICAge1xuICAgICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZTogKGNiKSA9PiB7XG4gICAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5zdWJzY3JpYmUoKG5ldHdvcmtTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9kaWZpZWROZXR3b3JrU3RhdGUgPSB7XG4gICAgICAgICAgICAgIC4uLm5ldHdvcmtTdGF0ZSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJDb25maWc6IHtcbiAgICAgICAgICAgICAgICAuLi5uZXR3b3JrU3RhdGUucHJvdmlkZXJDb25maWcsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGNiKG1vZGlmaWVkTmV0d29ya1N0YXRlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TmV0d29yazogKCkgPT5cbiAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkubmV0d29ya0lkID8/ICdsb2FkaW5nJyxcbiAgICAgICAgZ2V0Tm9uY2VMb2NrOiB0aGlzLnR4Q29udHJvbGxlci5ub25jZVRyYWNrZXIuZ2V0Tm9uY2VMb2NrLmJpbmQoXG4gICAgICAgICAgdGhpcy50eENvbnRyb2xsZXIubm9uY2VUcmFja2VyLFxuICAgICAgICApLFxuICAgICAgICBjb25maXJtRXh0ZXJuYWxUcmFuc2FjdGlvbjpcbiAgICAgICAgICB0aGlzLnR4Q29udHJvbGxlci5jb25maXJtRXh0ZXJuYWxUcmFuc2FjdGlvbi5iaW5kKHRoaXMudHhDb250cm9sbGVyKSxcbiAgICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXG4gICAgICAgIHRyYWNrTWV0YU1ldHJpY3NFdmVudDogdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tFdmVudC5iaW5kKFxuICAgICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3VwcG9ydGVkQ2hhaW5JZHM6IFtDSEFJTl9JRFMuTUFJTk5FVCwgQ0hBSU5fSURTLkdPRVJMSV0sXG4gICAgICB9LFxuICAgICAgaW5pdFN0YXRlLlNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlcixcbiAgICApO1xuXG4gICAgLy8gZW5zdXJlIGFjY291bnRUcmFja2VyIHVwZGF0ZXMgYmFsYW5jZXMgYWZ0ZXIgbmV0d29yayBjaGFuZ2VcbiAgICBuZXR3b3JrQ29udHJvbGxlck1lc3Nlbmdlci5zdWJzY3JpYmUoXG4gICAgICBOZXR3b3JrQ29udHJvbGxlckV2ZW50VHlwZS5OZXR3b3JrRGlkQ2hhbmdlLFxuICAgICAgKCkgPT4ge1xuICAgICAgICB0aGlzLmFjY291bnRUcmFja2VyLl91cGRhdGVBY2NvdW50cygpO1xuICAgICAgfSxcbiAgICApO1xuXG4gICAgLy8gY2xlYXIgdW5hcHByb3ZlZCB0cmFuc2FjdGlvbnMgYW5kIG1lc3NhZ2VzIHdoZW4gdGhlIG5ldHdvcmsgd2lsbCBjaGFuZ2VcbiAgICBuZXR3b3JrQ29udHJvbGxlck1lc3Nlbmdlci5zdWJzY3JpYmUoXG4gICAgICBOZXR3b3JrQ29udHJvbGxlckV2ZW50VHlwZS5OZXR3b3JrV2lsbENoYW5nZSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgdGhpcy50eENvbnRyb2xsZXIudHhTdGF0ZU1hbmFnZXIuY2xlYXJVbmFwcHJvdmVkVHhzKCk7XG4gICAgICAgIHRoaXMuZW5jcnlwdGlvblB1YmxpY0tleUNvbnRyb2xsZXIuY2xlYXJVbmFwcHJvdmVkKCk7XG4gICAgICAgIHRoaXMuZGVjcnlwdE1lc3NhZ2VDb250cm9sbGVyLmNsZWFyVW5hcHByb3ZlZCgpO1xuICAgICAgICB0aGlzLnNpZ25hdHVyZUNvbnRyb2xsZXIuY2xlYXJVbmFwcHJvdmVkKCk7XG4gICAgICB9LFxuICAgICk7XG5cbiAgICBpZiAoaXNNYW5pZmVzdFYzICYmIGdsb2JhbFRoaXMuaXNGaXJzdFRpbWVQcm9maWxlTG9hZGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHsgc2VydmljZVdvcmtlckxhc3RBY3RpdmVUaW1lIH0gPVxuICAgICAgICB0aGlzLmFwcFN0YXRlQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgY29uc3QgbWV0YW1ldHJpY3NQYXlsb2FkID0ge1xuICAgICAgICBjYXRlZ29yeTogTWV0YU1ldHJpY3NFdmVudENhdGVnb3J5LlNlcnZpY2VXb3JrZXJzLFxuICAgICAgICBldmVudDogTWV0YU1ldHJpY3NFdmVudE5hbWUuU2VydmljZVdvcmtlclJlc3RhcnRlZCxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIHNlcnZpY2Vfd29ya2VyX3Jlc3RhcnRlZF90aW1lOlxuICAgICAgICAgICAgRGF0ZS5ub3coKSAtIHNlcnZpY2VXb3JrZXJMYXN0QWN0aXZlVGltZSxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnRyYWNrRXZlbnQobWV0YW1ldHJpY3NQYXlsb2FkKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nLndhcm4oJ0ZhaWxlZCB0byB0cmFjayBzZXJ2aWNlIHdvcmtlciByZXN0YXJ0IG1ldHJpYzonLCBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm1ldGFtYXNrTWlkZGxld2FyZSA9IGNyZWF0ZU1ldGFtYXNrTWlkZGxld2FyZSh7XG4gICAgICBzdGF0aWM6IHtcbiAgICAgICAgZXRoX3N5bmNpbmc6IGZhbHNlLFxuICAgICAgICB3ZWIzX2NsaWVudFZlcnNpb246IGBNZXRhTWFzay92JHt2ZXJzaW9ufWAsXG4gICAgICB9LFxuICAgICAgdmVyc2lvbixcbiAgICAgIC8vIGFjY291bnQgbWdtdFxuICAgICAgZ2V0QWNjb3VudHM6IGFzeW5jIChcbiAgICAgICAgeyBvcmlnaW46IGlubmVyT3JpZ2luIH0sXG4gICAgICAgIHsgc3VwcHJlc3NVbmF1dGhvcml6ZWRFcnJvciA9IHRydWUgfSA9IHt9LFxuICAgICAgKSA9PiB7XG4gICAgICAgIGlmIChpbm5lck9yaWdpbiA9PT0gT1JJR0lOX01FVEFNQVNLKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWRBZGRyZXNzID1cbiAgICAgICAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLmdldFNlbGVjdGVkQWRkcmVzcygpO1xuICAgICAgICAgIHJldHVybiBzZWxlY3RlZEFkZHJlc3MgPyBbc2VsZWN0ZWRBZGRyZXNzXSA6IFtdO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNVbmxvY2tlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UGVybWl0dGVkQWNjb3VudHMoaW5uZXJPcmlnaW4sIHtcbiAgICAgICAgICAgIHN1cHByZXNzVW5hdXRob3JpemVkRXJyb3IsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdOyAvLyBjaGFuZ2luZyB0aGlzIGlzIGEgYnJlYWtpbmcgY2hhbmdlXG4gICAgICB9LFxuICAgICAgLy8gdHggc2lnbmluZ1xuICAgICAgcHJvY2Vzc1RyYW5zYWN0aW9uOiB0aGlzLm5ld1VuYXBwcm92ZWRUcmFuc2FjdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgLy8gbXNnIHNpZ25pbmdcbiAgICAgIHByb2Nlc3NFdGhTaWduTWVzc2FnZTogdGhpcy5zaWduYXR1cmVDb250cm9sbGVyLm5ld1Vuc2lnbmVkTWVzc2FnZS5iaW5kKFxuICAgICAgICB0aGlzLnNpZ25hdHVyZUNvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgcHJvY2Vzc1R5cGVkTWVzc2FnZTpcbiAgICAgICAgdGhpcy5zaWduYXR1cmVDb250cm9sbGVyLm5ld1Vuc2lnbmVkVHlwZWRNZXNzYWdlLmJpbmQoXG4gICAgICAgICAgdGhpcy5zaWduYXR1cmVDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgcHJvY2Vzc1R5cGVkTWVzc2FnZVYzOlxuICAgICAgICB0aGlzLnNpZ25hdHVyZUNvbnRyb2xsZXIubmV3VW5zaWduZWRUeXBlZE1lc3NhZ2UuYmluZChcbiAgICAgICAgICB0aGlzLnNpZ25hdHVyZUNvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICBwcm9jZXNzVHlwZWRNZXNzYWdlVjQ6XG4gICAgICAgIHRoaXMuc2lnbmF0dXJlQ29udHJvbGxlci5uZXdVbnNpZ25lZFR5cGVkTWVzc2FnZS5iaW5kKFxuICAgICAgICAgIHRoaXMuc2lnbmF0dXJlQ29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgIHByb2Nlc3NQZXJzb25hbE1lc3NhZ2U6XG4gICAgICAgIHRoaXMuc2lnbmF0dXJlQ29udHJvbGxlci5uZXdVbnNpZ25lZFBlcnNvbmFsTWVzc2FnZS5iaW5kKFxuICAgICAgICAgIHRoaXMuc2lnbmF0dXJlQ29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgIHByb2Nlc3NFbmNyeXB0aW9uUHVibGljS2V5OlxuICAgICAgICB0aGlzLmVuY3J5cHRpb25QdWJsaWNLZXlDb250cm9sbGVyLm5ld1JlcXVlc3RFbmNyeXB0aW9uUHVibGljS2V5LmJpbmQoXG4gICAgICAgICAgdGhpcy5lbmNyeXB0aW9uUHVibGljS2V5Q29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgIHByb2Nlc3NEZWNyeXB0TWVzc2FnZTpcbiAgICAgICAgdGhpcy5kZWNyeXB0TWVzc2FnZUNvbnRyb2xsZXIubmV3UmVxdWVzdERlY3J5cHRNZXNzYWdlLmJpbmQoXG4gICAgICAgICAgdGhpcy5kZWNyeXB0TWVzc2FnZUNvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICBnZXRQZW5kaW5nTm9uY2U6IHRoaXMuZ2V0UGVuZGluZ05vbmNlLmJpbmQodGhpcyksXG4gICAgICBnZXRQZW5kaW5nVHJhbnNhY3Rpb25CeUhhc2g6IChoYXNoKSA9PlxuICAgICAgICB0aGlzLnR4Q29udHJvbGxlci5nZXRUcmFuc2FjdGlvbnMoe1xuICAgICAgICAgIHNlYXJjaENyaXRlcmlhOiB7XG4gICAgICAgICAgICBoYXNoLFxuICAgICAgICAgICAgc3RhdHVzOiBUcmFuc2FjdGlvblN0YXR1cy5zdWJtaXR0ZWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlbMF0sXG4gICAgfSk7XG5cbiAgICAvLyBlbnN1cmUgaXNDbGllbnRPcGVuQW5kVW5sb2NrZWQgaXMgdXBkYXRlZCB3aGVuIG1lbVN0YXRlIHVwZGF0ZXNcbiAgICB0aGlzLm9uKCd1cGRhdGUnLCAobWVtU3RhdGUpID0+IHRoaXMuX29uU3RhdGVVcGRhdGUobWVtU3RhdGUpKTtcblxuICAgIC8qKlxuICAgICAqIEFsbCBjb250cm9sbGVycyBpbiBNZW1zdG9yZSBidXQgbm90IGluIHN0b3JlLiBUaGV5IGFyZSBub3QgcGVyc2lzdGVkLlxuICAgICAqIE9uIGNocm9tZSBwcm9maWxlIHJlLXN0YXJ0LCB0aGV5IHdpbGwgYmUgcmUtaW5pdGlhbGl6ZWQuXG4gICAgICovXG4gICAgY29uc3QgcmVzZXRPblJlc3RhcnRTdG9yZSA9IHtcbiAgICAgIEFjY291bnRUcmFja2VyOiB0aGlzLmFjY291bnRUcmFja2VyLnN0b3JlLFxuICAgICAgVHhDb250cm9sbGVyOiB0aGlzLnR4Q29udHJvbGxlci5tZW1TdG9yZSxcbiAgICAgIFRva2VuUmF0ZXNDb250cm9sbGVyOiB0aGlzLnRva2VuUmF0ZXNDb250cm9sbGVyLFxuICAgICAgRGVjcnlwdE1lc3NhZ2VDb250cm9sbGVyOiB0aGlzLmRlY3J5cHRNZXNzYWdlQ29udHJvbGxlcixcbiAgICAgIEVuY3J5cHRpb25QdWJsaWNLZXlDb250cm9sbGVyOiB0aGlzLmVuY3J5cHRpb25QdWJsaWNLZXlDb250cm9sbGVyLFxuICAgICAgU2lnbmF0dXJlQ29udHJvbGxlcjogdGhpcy5zaWduYXR1cmVDb250cm9sbGVyLFxuICAgICAgU3dhcHNDb250cm9sbGVyOiB0aGlzLnN3YXBzQ29udHJvbGxlci5zdG9yZSxcbiAgICAgIEVuc0NvbnRyb2xsZXI6IHRoaXMuZW5zQ29udHJvbGxlci5zdG9yZSxcbiAgICAgIEFwcHJvdmFsQ29udHJvbGxlcjogdGhpcy5hcHByb3ZhbENvbnRyb2xsZXIsXG4gICAgfTtcblxuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RydWN0dXJlKHtcbiAgICAgIEFwcFN0YXRlQ29udHJvbGxlcjogdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIuc3RvcmUsXG4gICAgICBUcmFuc2FjdGlvbkNvbnRyb2xsZXI6IHRoaXMudHhDb250cm9sbGVyLnN0b3JlLFxuICAgICAgS2V5cmluZ0NvbnRyb2xsZXI6IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXI6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLFxuICAgICAgTWV0YU1ldHJpY3NDb250cm9sbGVyOiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci5zdG9yZSxcbiAgICAgIEFkZHJlc3NCb29rQ29udHJvbGxlcjogdGhpcy5hZGRyZXNzQm9va0NvbnRyb2xsZXIsXG4gICAgICBDdXJyZW5jeUNvbnRyb2xsZXI6IHRoaXMuY3VycmVuY3lSYXRlQ29udHJvbGxlcixcbiAgICAgIE5ldHdvcmtDb250cm9sbGVyOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLFxuICAgICAgQ2FjaGVkQmFsYW5jZXNDb250cm9sbGVyOiB0aGlzLmNhY2hlZEJhbGFuY2VzQ29udHJvbGxlci5zdG9yZSxcbiAgICAgIEFsZXJ0Q29udHJvbGxlcjogdGhpcy5hbGVydENvbnRyb2xsZXIuc3RvcmUsXG4gICAgICBPbmJvYXJkaW5nQ29udHJvbGxlcjogdGhpcy5vbmJvYXJkaW5nQ29udHJvbGxlci5zdG9yZSxcbiAgICAgIEluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlcjogdGhpcy5pbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICBQZXJtaXNzaW9uQ29udHJvbGxlcjogdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlcixcbiAgICAgIFBlcm1pc3Npb25Mb2dDb250cm9sbGVyOiB0aGlzLnBlcm1pc3Npb25Mb2dDb250cm9sbGVyLnN0b3JlLFxuICAgICAgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcjogdGhpcy5zdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLFxuICAgICAgQmFja3VwQ29udHJvbGxlcjogdGhpcy5iYWNrdXBDb250cm9sbGVyLFxuICAgICAgQW5ub3VuY2VtZW50Q29udHJvbGxlcjogdGhpcy5hbm5vdW5jZW1lbnRDb250cm9sbGVyLFxuICAgICAgR2FzRmVlQ29udHJvbGxlcjogdGhpcy5nYXNGZWVDb250cm9sbGVyLFxuICAgICAgVG9rZW5MaXN0Q29udHJvbGxlcjogdGhpcy50b2tlbkxpc3RDb250cm9sbGVyLFxuICAgICAgVG9rZW5zQ29udHJvbGxlcjogdGhpcy50b2tlbnNDb250cm9sbGVyLFxuICAgICAgU21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyOiB0aGlzLnNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlcixcbiAgICAgIE5mdENvbnRyb2xsZXI6IHRoaXMubmZ0Q29udHJvbGxlcixcbiAgICAgIFBoaXNoaW5nQ29udHJvbGxlcjogdGhpcy5waGlzaGluZ0NvbnRyb2xsZXIsXG4gICAgICAuLi5yZXNldE9uUmVzdGFydFN0b3JlLFxuICAgIH0pO1xuXG4gICAgdGhpcy5tZW1TdG9yZSA9IG5ldyBDb21wb3NhYmxlT2JzZXJ2YWJsZVN0b3JlKHtcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICBBcHBTdGF0ZUNvbnRyb2xsZXI6IHRoaXMuYXBwU3RhdGVDb250cm9sbGVyLnN0b3JlLFxuICAgICAgICBOZXR3b3JrQ29udHJvbGxlcjogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICAgQ2FjaGVkQmFsYW5jZXNDb250cm9sbGVyOiB0aGlzLmNhY2hlZEJhbGFuY2VzQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICAgS2V5cmluZ0NvbnRyb2xsZXI6IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIubWVtU3RvcmUsXG4gICAgICAgIFByZWZlcmVuY2VzQ29udHJvbGxlcjogdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICAgIE1ldGFNZXRyaWNzQ29udHJvbGxlcjogdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICAgIEFkZHJlc3NCb29rQ29udHJvbGxlcjogdGhpcy5hZGRyZXNzQm9va0NvbnRyb2xsZXIsXG4gICAgICAgIEN1cnJlbmN5Q29udHJvbGxlcjogdGhpcy5jdXJyZW5jeVJhdGVDb250cm9sbGVyLFxuICAgICAgICBBbGVydENvbnRyb2xsZXI6IHRoaXMuYWxlcnRDb250cm9sbGVyLnN0b3JlLFxuICAgICAgICBPbmJvYXJkaW5nQ29udHJvbGxlcjogdGhpcy5vbmJvYXJkaW5nQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICAgSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyOlxuICAgICAgICAgIHRoaXMuaW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyLnN0b3JlLFxuICAgICAgICBQZXJtaXNzaW9uQ29udHJvbGxlcjogdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlcixcbiAgICAgICAgUGVybWlzc2lvbkxvZ0NvbnRyb2xsZXI6IHRoaXMucGVybWlzc2lvbkxvZ0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICAgIFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXI6IHRoaXMuc3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcixcbiAgICAgICAgQmFja3VwQ29udHJvbGxlcjogdGhpcy5iYWNrdXBDb250cm9sbGVyLFxuICAgICAgICBBbm5vdW5jZW1lbnRDb250cm9sbGVyOiB0aGlzLmFubm91bmNlbWVudENvbnRyb2xsZXIsXG4gICAgICAgIEdhc0ZlZUNvbnRyb2xsZXI6IHRoaXMuZ2FzRmVlQ29udHJvbGxlcixcbiAgICAgICAgVG9rZW5MaXN0Q29udHJvbGxlcjogdGhpcy50b2tlbkxpc3RDb250cm9sbGVyLFxuICAgICAgICBUb2tlbnNDb250cm9sbGVyOiB0aGlzLnRva2Vuc0NvbnRyb2xsZXIsXG4gICAgICAgIFNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlcjogdGhpcy5zbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIsXG4gICAgICAgIE5mdENvbnRyb2xsZXI6IHRoaXMubmZ0Q29udHJvbGxlcixcbiAgICAgICAgLi4ucmVzZXRPblJlc3RhcnRTdG9yZSxcbiAgICAgIH0sXG4gICAgICBjb250cm9sbGVyTWVzc2VuZ2VyOiB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIsXG4gICAgfSk7XG5cbiAgICAvLyBpZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lLCBjbGVhciB0aGUgc3RhdGUgb2YgYnkgY2FsbGluZyB0aGVzZSBtZXRob2RzXG4gICAgY29uc3QgcmVzZXRNZXRob2RzID0gW1xuICAgICAgdGhpcy5hY2NvdW50VHJhY2tlci5yZXNldFN0YXRlLFxuICAgICAgdGhpcy50eENvbnRyb2xsZXIucmVzZXRTdGF0ZSxcbiAgICAgIHRoaXMuZGVjcnlwdE1lc3NhZ2VDb250cm9sbGVyLnJlc2V0U3RhdGUuYmluZChcbiAgICAgICAgdGhpcy5kZWNyeXB0TWVzc2FnZUNvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgdGhpcy5lbmNyeXB0aW9uUHVibGljS2V5Q29udHJvbGxlci5yZXNldFN0YXRlLmJpbmQoXG4gICAgICAgIHRoaXMuZW5jcnlwdGlvblB1YmxpY0tleUNvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgdGhpcy5zaWduYXR1cmVDb250cm9sbGVyLnJlc2V0U3RhdGUuYmluZCh0aGlzLnNpZ25hdHVyZUNvbnRyb2xsZXIpLFxuICAgICAgdGhpcy5zd2Fwc0NvbnRyb2xsZXIucmVzZXRTdGF0ZSxcbiAgICAgIHRoaXMuZW5zQ29udHJvbGxlci5yZXNldFN0YXRlLFxuICAgICAgdGhpcy5hcHByb3ZhbENvbnRyb2xsZXIuY2xlYXIuYmluZCh0aGlzLmFwcHJvdmFsQ29udHJvbGxlciksXG4gICAgICAvLyBXRSBTSE9VTEQgQUREIFRva2VuTGlzdENvbnRyb2xsZXIucmVzZXRTdGF0ZSBoZXJlIHRvby4gQnV0IGl0J3Mgbm90IGltcGxlbWVudGVkIHlldC5cbiAgICBdO1xuXG4gICAgaWYgKGlzTWFuaWZlc3RWMykge1xuICAgICAgaWYgKGlzRmlyc3RNZXRhTWFza0NvbnRyb2xsZXJTZXR1cCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnJlc2V0U3RhdGVzKHJlc2V0TWV0aG9kcyk7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uLnN0b3JhZ2Uuc2Vzc2lvbi5zZXQoe1xuICAgICAgICAgIGlzRmlyc3RNZXRhTWFza0NvbnRyb2xsZXJTZXR1cDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpdCdzIGFsd2F5cyB0aGUgZmlyc3QgdGltZSBpbiBNVjJcbiAgICAgIHRoaXMucmVzZXRTdGF0ZXMocmVzZXRNZXRob2RzKTtcbiAgICB9XG5cbiAgICAvLyBBdXRvbWF0aWMgbG9naW4gdmlhIGNvbmZpZyBwYXNzd29yZCBvciBsb2dpblRva2VuXG4gICAgaWYgKFxuICAgICAgIXRoaXMuaXNVbmxvY2tlZCgpICYmXG4gICAgICB0aGlzLm9uYm9hcmRpbmdDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkuY29tcGxldGVkT25ib2FyZGluZ1xuICAgICkge1xuICAgICAgdGhpcy5fbG9naW5Vc2VyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N0YXJ0VUlTeW5jKCk7XG4gICAgfVxuXG4gICAgLy8gTGF6aWx5IHVwZGF0ZSB0aGUgc3RvcmUgd2l0aCB0aGUgY3VycmVudCBleHRlbnNpb24gZW52aXJvbm1lbnRcbiAgICB0aGlzLmV4dGVuc2lvbi5ydW50aW1lLmdldFBsYXRmb3JtSW5mbygpLnRoZW4oKHsgb3MgfSkgPT4ge1xuICAgICAgdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIuc2V0QnJvd3NlckVudmlyb25tZW50KFxuICAgICAgICBvcyxcbiAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgcHJlc2VudGx5IG9ubHkgc3VwcG9ydGVkIGJ5IEZpcmVmb3hcbiAgICAgICAgdGhpcy5leHRlbnNpb24ucnVudGltZS5nZXRCcm93c2VySW5mbyA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAnY2hyb21lJ1xuICAgICAgICAgIDogJ2ZpcmVmb3gnLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRoaXMuc2V0dXBDb250cm9sbGVyRXZlbnRTdWJzY3JpcHRpb25zKCk7XG5cbiAgICAvLyBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGVzZSBsZWdhY3kgc3RyZWFtcywgc2VlIGhlcmU6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL21ldGFtYXNrLWV4dGVuc2lvbi9pc3N1ZXMvMTU0OTFcbiAgICAvLyBUT0RPOkxlZ2FjeVByb3ZpZGVyOiBEZWxldGVcbiAgICB0aGlzLnB1YmxpY0NvbmZpZ1N0b3JlID0gdGhpcy5jcmVhdGVQdWJsaWNDb25maWdTdG9yZSgpO1xuXG4gICAgLy8gTXVsdGlwbGUgTWV0YU1hc2sgaW5zdGFuY2VzIGxhdW5jaGVkIHdhcm5pbmdcbiAgICB0aGlzLmV4dGVuc2lvbi5ydW50aW1lLm9uTWVzc2FnZUV4dGVybmFsLmFkZExpc3RlbmVyKG9uTWVzc2FnZVJlY2VpdmVkKTtcbiAgICAvLyBGaXJlIGEgcGluZyBtZXNzYWdlIHRvIGNoZWNrIGlmIG90aGVyIGV4dGVuc2lvbnMgYXJlIHJ1bm5pbmdcbiAgICBjaGVja0Zvck11bHRpcGxlVmVyc2lvbnNSdW5uaW5nKCk7XG4gIH1cblxuICB0cmlnZ2VyTmV0d29ya3JlcXVlc3RzKCkge1xuICAgIHRoaXMuYWNjb3VudFRyYWNrZXIuc3RhcnQoKTtcbiAgICB0aGlzLmluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlci5zdGFydCgpO1xuICAgIGlmICh0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLnVzZUN1cnJlbmN5UmF0ZUNoZWNrKSB7XG4gICAgICB0aGlzLmN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkudXNlVG9rZW5EZXRlY3Rpb24pIHtcbiAgICAgIHRoaXMudG9rZW5MaXN0Q29udHJvbGxlci5zdGFydCgpO1xuICAgIH1cbiAgfVxuXG4gIHN0b3BOZXR3b3JrUmVxdWVzdHMoKSB7XG4gICAgdGhpcy5hY2NvdW50VHJhY2tlci5zdG9wKCk7XG4gICAgdGhpcy5pbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXIuc3RvcCgpO1xuICAgIGlmICh0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLnVzZUN1cnJlbmN5UmF0ZUNoZWNrKSB7XG4gICAgICB0aGlzLmN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIuc3RvcCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS51c2VUb2tlbkRldGVjdGlvbikge1xuICAgICAgdGhpcy50b2tlbkxpc3RDb250cm9sbGVyLnN0b3AoKTtcbiAgICB9XG4gIH1cblxuICBjYW5Vc2VIYXJkd2FyZVdhbGxldHMoKSB7XG4gICAgcmV0dXJuICFpc01hbmlmZXN0VjMgfHwgcHJvY2Vzcy5lbnYuSEFSRFdBUkVfV0FMTEVUU19NVjM7XG4gIH1cblxuICByZXNldFN0YXRlcyhyZXNldE1ldGhvZHMpIHtcbiAgICByZXNldE1ldGhvZHMuZm9yRWFjaCgocmVzZXRNZXRob2QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc2V0TWV0aG9kKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cblxuICAvKipcbiAgICogU2V0cyB1cCBCYXNlQ29udHJvbGxlciBWMiBldmVudCBzdWJzY3JpcHRpb25zLiBDdXJyZW50bHksIHRoaXMgaW5jbHVkZXNcbiAgICogdGhlIHN1YnNjcmlwdGlvbnMgbmVjZXNzYXJ5IHRvIG5vdGlmeSBwZXJtaXNzaW9uIHN1YmplY3RzIG9mIGFjY291bnRcbiAgICogY2hhbmdlcy5cbiAgICpcbiAgICogU29tZSBvZiB0aGUgc3Vic2NyaXB0aW9ucyBpbiB0aGlzIG1ldGhvZCBhcmUgQ29udHJvbGxlck1lc3NlbmdlciBzZWxlY3RvclxuICAgKiBldmVudCBzdWJzY3JpcHRpb25zLiBTZWUgdGhlIHJlbGV2YW50IGRvY3VtZW50YXRpb24gZm9yXG4gICAqIGBAbWV0YW1hc2svYmFzZS1jb250cm9sbGVyYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogTm90ZSB0aGF0IGFjY291bnQtcmVsYXRlZCBub3RpZmljYXRpb25zIGVtaXR0ZWQgd2hlbiB0aGUgZXh0ZW5zaW9uXG4gICAqIGJlY29tZXMgdW5sb2NrZWQgYXJlIGhhbmRsZWQgaW4gTWV0YU1hc2tDb250cm9sbGVyLl9vblVubG9jay5cbiAgICovXG4gIHNldHVwQ29udHJvbGxlckV2ZW50U3Vic2NyaXB0aW9ucygpIHtcbiAgICBjb25zdCBoYW5kbGVBY2NvdW50c0NoYW5nZSA9IGFzeW5jIChvcmlnaW4sIG5ld0FjY291bnRzKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc1VubG9ja2VkKCkpIHtcbiAgICAgICAgdGhpcy5ub3RpZnlDb25uZWN0aW9ucyhvcmlnaW4sIHtcbiAgICAgICAgICBtZXRob2Q6IE5PVElGSUNBVElPTl9OQU1FUy5hY2NvdW50c0NoYW5nZWQsXG4gICAgICAgICAgLy8gVGhpcyBzaG91bGQgYmUgdGhlIHNhbWUgYXMgdGhlIHJldHVybiB2YWx1ZSBvZiBgZXRoX2FjY291bnRzYCxcbiAgICAgICAgICAvLyBuYW1lbHkgYW4gYXJyYXkgb2YgdGhlIGN1cnJlbnQgLyBtb3N0IHJlY2VudGx5IHNlbGVjdGVkIEV0aGVyZXVtXG4gICAgICAgICAgLy8gYWNjb3VudC5cbiAgICAgICAgICBwYXJhbXM6XG4gICAgICAgICAgICBuZXdBY2NvdW50cy5sZW5ndGggPCAyXG4gICAgICAgICAgICAgID8gLy8gSWYgdGhlIGxlbmd0aCBpcyAxIG9yIDAsIHRoZSBhY2NvdW50cyBhcmUgc29ydGVkIGJ5IGRlZmluaXRpb24uXG4gICAgICAgICAgICAgICAgbmV3QWNjb3VudHNcbiAgICAgICAgICAgICAgOiAvLyBJZiB0aGUgbGVuZ3RoIGlzIDIgb3IgZ3JlYXRlciwgd2UgaGF2ZSB0byBleGVjdXRlXG4gICAgICAgICAgICAgICAgLy8gYGV0aF9hY2NvdW50c2AgdmkgdGhpcyBtZXRob2QuXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5nZXRQZXJtaXR0ZWRBY2NvdW50cyhvcmlnaW4pLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wZXJtaXNzaW9uTG9nQ29udHJvbGxlci51cGRhdGVBY2NvdW50c0hpc3Rvcnkob3JpZ2luLCBuZXdBY2NvdW50cyk7XG4gICAgfTtcblxuICAgIC8vIFRoaXMgaGFuZGxlcyBhY2NvdW50IGNoYW5nZXMgd2hlbmV2ZXIgdGhlIHNlbGVjdGVkIGFkZHJlc3MgY2hhbmdlcy5cbiAgICBsZXQgbGFzdFNlbGVjdGVkQWRkcmVzcztcbiAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5zdWJzY3JpYmUoYXN5bmMgKHsgc2VsZWN0ZWRBZGRyZXNzIH0pID0+IHtcbiAgICAgIGlmIChzZWxlY3RlZEFkZHJlc3MgJiYgc2VsZWN0ZWRBZGRyZXNzICE9PSBsYXN0U2VsZWN0ZWRBZGRyZXNzKSB7XG4gICAgICAgIGxhc3RTZWxlY3RlZEFkZHJlc3MgPSBzZWxlY3RlZEFkZHJlc3M7XG4gICAgICAgIGNvbnN0IHBlcm1pdHRlZEFjY291bnRzTWFwID0gZ2V0UGVybWl0dGVkQWNjb3VudHNCeU9yaWdpbihcbiAgICAgICAgICB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLnN0YXRlLFxuICAgICAgICApO1xuXG4gICAgICAgIGZvciAoY29uc3QgW29yaWdpbiwgYWNjb3VudHNdIG9mIHBlcm1pdHRlZEFjY291bnRzTWFwLmVudHJpZXMoKSkge1xuICAgICAgICAgIGlmIChhY2NvdW50cy5pbmNsdWRlcyhzZWxlY3RlZEFkZHJlc3MpKSB7XG4gICAgICAgICAgICBoYW5kbGVBY2NvdW50c0NoYW5nZShvcmlnaW4sIGFjY291bnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRoaXMgaGFuZGxlcyBhY2NvdW50IGNoYW5nZXMgZXZlcnkgdGltZSByZWxldmFudCBwZXJtaXNzaW9uIHN0YXRlXG4gICAgLy8gY2hhbmdlcywgZm9yIGFueSByZWFzb24uXG4gICAgdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLnN1YnNjcmliZShcbiAgICAgIGAke3RoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIubmFtZX06c3RhdGVDaGFuZ2VgLFxuICAgICAgYXN5bmMgKGN1cnJlbnRWYWx1ZSwgcHJldmlvdXNWYWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBjaGFuZ2VkQWNjb3VudHMgPSBnZXRDaGFuZ2VkQWNjb3VudHMoY3VycmVudFZhbHVlLCBwcmV2aW91c1ZhbHVlKTtcblxuICAgICAgICBmb3IgKGNvbnN0IFtvcmlnaW4sIGFjY291bnRzXSBvZiBjaGFuZ2VkQWNjb3VudHMuZW50cmllcygpKSB7XG4gICAgICAgICAgaGFuZGxlQWNjb3VudHNDaGFuZ2Uob3JpZ2luLCBhY2NvdW50cyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXRQZXJtaXR0ZWRBY2NvdW50c0J5T3JpZ2luLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBUT0RPOkxlZ2FjeVByb3ZpZGVyOiBEZWxldGVcbiAgICogQ29uc3RydWN0b3IgaGVscGVyOiBpbml0aWFsaXplIGEgcHVibGljIGNvbmZpZyBzdG9yZS5cbiAgICogVGhpcyBzdG9yZSBpcyB1c2VkIHRvIG1ha2Ugc29tZSBjb25maWcgaW5mbyBhdmFpbGFibGUgdG8gRGFwcHMgc3luY2hyb25vdXNseS5cbiAgICovXG4gIGNyZWF0ZVB1YmxpY0NvbmZpZ1N0b3JlKCkge1xuICAgIC8vIHN1YnNldCBvZiBzdGF0ZSBmb3IgbWV0YW1hc2sgaW5wYWdlIHByb3ZpZGVyXG4gICAgY29uc3QgcHVibGljQ29uZmlnU3RvcmUgPSBuZXcgT2JzZXJ2YWJsZVN0b3JlKCk7XG4gICAgY29uc3QgeyBuZXR3b3JrQ29udHJvbGxlciB9ID0gdGhpcztcblxuICAgIC8vIHNldHVwIG1lbVN0b3JlIHN1YnNjcmlwdGlvbiBob29rc1xuICAgIHRoaXMub24oJ3VwZGF0ZScsIHVwZGF0ZVB1YmxpY0NvbmZpZ1N0b3JlKTtcbiAgICB1cGRhdGVQdWJsaWNDb25maWdTdG9yZSh0aGlzLmdldFN0YXRlKCkpO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlUHVibGljQ29uZmlnU3RvcmUobWVtU3RhdGUpIHtcbiAgICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gbmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5wcm92aWRlckNvbmZpZztcbiAgICAgIGlmIChtZW1TdGF0ZS5uZXR3b3JrU3RhdHVzID09PSBOZXR3b3JrU3RhdHVzLkF2YWlsYWJsZSkge1xuICAgICAgICBwdWJsaWNDb25maWdTdG9yZS5wdXRTdGF0ZShzZWxlY3RQdWJsaWNTdGF0ZShjaGFpbklkLCBtZW1TdGF0ZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbGVjdFB1YmxpY1N0YXRlKGNoYWluSWQsIHsgaXNVbmxvY2tlZCwgbmV0d29ya0lkIH0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVW5sb2NrZWQsXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIG5ldHdvcmtWZXJzaW9uOiBuZXR3b3JrSWQgPz8gJ2xvYWRpbmcnLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHVibGljQ29uZmlnU3RvcmU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyByZWxldmFudCBzdGF0ZSBmb3IgdGhlIHByb3ZpZGVyIG9mIGFuIGV4dGVybmFsIG9yaWdpbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBvcmlnaW4gdG8gZ2V0IHRoZSBwcm92aWRlciBzdGF0ZSBmb3IuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHsgaXNVbmxvY2tlZDogYm9vbGVhbiwgbmV0d29ya1ZlcnNpb246IHN0cmluZywgY2hhaW5JZDogc3RyaW5nLCBhY2NvdW50czogc3RyaW5nW10gfT59IEFuIG9iamVjdCB3aXRoIHJlbGV2YW50IHN0YXRlIHByb3BlcnRpZXMuXG4gICAqL1xuICBhc3luYyBnZXRQcm92aWRlclN0YXRlKG9yaWdpbikge1xuICAgIHJldHVybiB7XG4gICAgICBpc1VubG9ja2VkOiB0aGlzLmlzVW5sb2NrZWQoKSxcbiAgICAgIC4uLnRoaXMuZ2V0UHJvdmlkZXJOZXR3b3JrU3RhdGUoKSxcbiAgICAgIGFjY291bnRzOiBhd2FpdCB0aGlzLmdldFBlcm1pdHRlZEFjY291bnRzKG9yaWdpbiksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIG5ldHdvcmsgc3RhdGUgcmVsZXZhbnQgZm9yIGV4dGVybmFsIHByb3ZpZGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IFttZW1TdGF0ZV0gLSBUaGUgTWV0YU1hc2sgbWVtU3RhdGUuIElmIG5vdCBwcm92aWRlZCxcbiAgICogdGhpcyBmdW5jdGlvbiB3aWxsIHJldHJpZXZlIHRoZSBtb3N0IHJlY2VudCBzdGF0ZS5cbiAgICogQHJldHVybnMge29iamVjdH0gQW4gb2JqZWN0IHdpdGggcmVsZXZhbnQgbmV0d29yayBzdGF0ZSBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgZ2V0UHJvdmlkZXJOZXR3b3JrU3RhdGUobWVtU3RhdGUpIHtcbiAgICBjb25zdCB7IG5ldHdvcmtJZCB9ID0gbWVtU3RhdGUgfHwgdGhpcy5nZXRTdGF0ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBjaGFpbklkOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkucHJvdmlkZXJDb25maWcuY2hhaW5JZCxcbiAgICAgIG5ldHdvcmtWZXJzaW9uOiBuZXR3b3JrSWQgPz8gJ2xvYWRpbmcnLFxuICAgIH07XG4gIH1cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEVYUE9TRUQgVE8gVEhFIFVJIFNVQlNZU1RFTVxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLyoqXG4gICAqIFRoZSBtZXRhbWFzay1zdGF0ZSBvZiB0aGUgdmFyaW91cyBjb250cm9sbGVycywgbWFkZSBhdmFpbGFibGUgdG8gdGhlIFVJXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IHN0YXR1c1xuICAgKi9cbiAgZ2V0U3RhdGUoKSB7XG4gICAgY29uc3QgeyB2YXVsdCB9ID0gdGhpcy5rZXlyaW5nQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGlzSW5pdGlhbGl6ZWQgPSBCb29sZWFuKHZhdWx0KTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc0luaXRpYWxpemVkLFxuICAgICAgLi4udGhpcy5tZW1TdG9yZS5nZXRGbGF0U3RhdGUoKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gT2JqZWN0IGNvbnRhaW5pbmcgQVBJIENhbGxiYWNrIEZ1bmN0aW9ucy5cbiAgICogVGhlc2UgZnVuY3Rpb25zIGFyZSB0aGUgaW50ZXJmYWNlIGZvciB0aGUgVUkuXG4gICAqIFRoZSBBUEkgb2JqZWN0IGNhbiBiZSB0cmFuc21pdHRlZCBvdmVyIGEgc3RyZWFtIHZpYSBKU09OLVJQQy5cbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgQVBJIGZ1bmN0aW9ucy5cbiAgICovXG4gIGdldEFwaSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBhZGRyZXNzQm9va0NvbnRyb2xsZXIsXG4gICAgICBhbGVydENvbnRyb2xsZXIsXG4gICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIsXG4gICAgICBuZnRDb250cm9sbGVyLFxuICAgICAgbmZ0RGV0ZWN0aW9uQ29udHJvbGxlcixcbiAgICAgIGN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIsXG4gICAgICBkZXRlY3RUb2tlbnNDb250cm9sbGVyLFxuICAgICAgZW5zQ29udHJvbGxlcixcbiAgICAgIGdhc0ZlZUNvbnRyb2xsZXIsXG4gICAgICBtZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICBuZXR3b3JrQ29udHJvbGxlcixcbiAgICAgIGFubm91bmNlbWVudENvbnRyb2xsZXIsXG4gICAgICBvbmJvYXJkaW5nQ29udHJvbGxlcixcbiAgICAgIHBlcm1pc3Npb25Db250cm9sbGVyLFxuICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgcXJIYXJkd2FyZUtleXJpbmcsXG4gICAgICBzd2Fwc0NvbnRyb2xsZXIsXG4gICAgICB0b2tlbnNDb250cm9sbGVyLFxuICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxuICAgICAgdHhDb250cm9sbGVyLFxuICAgICAgYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLFxuICAgICAgYmFja3VwQ29udHJvbGxlcixcbiAgICAgIGFwcHJvdmFsQ29udHJvbGxlcixcbiAgICB9ID0gdGhpcztcblxuICAgIHJldHVybiB7XG4gICAgICAvLyBldGNcbiAgICAgIGdldFN0YXRlOiB0aGlzLmdldFN0YXRlLmJpbmQodGhpcyksXG4gICAgICBzZXRDdXJyZW50Q3VycmVuY3k6IGN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIuc2V0Q3VycmVudEN1cnJlbmN5LmJpbmQoXG4gICAgICAgIGN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0VXNlQmxvY2tpZTogcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFVzZUJsb2NraWUuYmluZChcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldFVzZU5vbmNlRmllbGQ6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRVc2VOb25jZUZpZWxkLmJpbmQoXG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRVc2VQaGlzaERldGVjdDogcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFVzZVBoaXNoRGV0ZWN0LmJpbmQoXG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRVc2VNdWx0aUFjY291bnRCYWxhbmNlQ2hlY2tlcjpcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFVzZU11bHRpQWNjb3VudEJhbGFuY2VDaGVja2VyLmJpbmQoXG4gICAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgc2V0VXNlVG9rZW5EZXRlY3Rpb246IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRVc2VUb2tlbkRldGVjdGlvbi5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0VXNlTmZ0RGV0ZWN0aW9uOiBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0VXNlTmZ0RGV0ZWN0aW9uLmJpbmQoXG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRVc2VDdXJyZW5jeVJhdGVDaGVjazpcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFVzZUN1cnJlbmN5UmF0ZUNoZWNrLmJpbmQoXG4gICAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgc2V0T3BlblNlYUVuYWJsZWQ6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRPcGVuU2VhRW5hYmxlZC5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0SXBmc0dhdGV3YXk6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRJcGZzR2F0ZXdheS5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0UGFydGljaXBhdGVJbk1ldGFNZXRyaWNzOlxuICAgICAgICBtZXRhTWV0cmljc0NvbnRyb2xsZXIuc2V0UGFydGljaXBhdGVJbk1ldGFNZXRyaWNzLmJpbmQoXG4gICAgICAgICAgbWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgc2V0Q3VycmVudExvY2FsZTogcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldEN1cnJlbnRMb2NhbGUuYmluZChcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIG1hcmtQYXNzd29yZEZvcmdvdHRlbjogdGhpcy5tYXJrUGFzc3dvcmRGb3Jnb3R0ZW4uYmluZCh0aGlzKSxcbiAgICAgIHVuTWFya1Bhc3N3b3JkRm9yZ290dGVuOiB0aGlzLnVuTWFya1Bhc3N3b3JkRm9yZ290dGVuLmJpbmQodGhpcyksXG4gICAgICBnZXRSZXF1ZXN0QWNjb3VudFRhYklkczogdGhpcy5nZXRSZXF1ZXN0QWNjb3VudFRhYklkcyxcbiAgICAgIGdldE9wZW5NZXRhbWFza1RhYnNJZHM6IHRoaXMuZ2V0T3Blbk1ldGFtYXNrVGFic0lkcyxcbiAgICAgIG1hcmtOb3RpZmljYXRpb25Qb3B1cEFzQXV0b21hdGljYWxseUNsb3NlZDogKCkgPT5cbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25NYW5hZ2VyLm1hcmtBc0F1dG9tYXRpY2FsbHlDbG9zZWQoKSxcblxuICAgICAgLy8gYXBwcm92YWxcbiAgICAgIHJlcXVlc3RVc2VyQXBwcm92YWw6XG4gICAgICAgIGFwcHJvdmFsQ29udHJvbGxlci5hZGRBbmRTaG93QXBwcm92YWxSZXF1ZXN0LmJpbmQoYXBwcm92YWxDb250cm9sbGVyKSxcblxuICAgICAgLy8gcHJpbWFyeSBIRCBrZXlyaW5nIG1hbmFnZW1lbnRcbiAgICAgIGFkZE5ld0FjY291bnQ6IHRoaXMuYWRkTmV3QWNjb3VudC5iaW5kKHRoaXMpLFxuICAgICAgdmVyaWZ5U2VlZFBocmFzZTogdGhpcy52ZXJpZnlTZWVkUGhyYXNlLmJpbmQodGhpcyksXG4gICAgICByZXNldEFjY291bnQ6IHRoaXMucmVzZXRBY2NvdW50LmJpbmQodGhpcyksXG4gICAgICByZW1vdmVBY2NvdW50OiB0aGlzLnJlbW92ZUFjY291bnQuYmluZCh0aGlzKSxcbiAgICAgIGltcG9ydEFjY291bnRXaXRoU3RyYXRlZ3k6IHRoaXMuaW1wb3J0QWNjb3VudFdpdGhTdHJhdGVneS5iaW5kKHRoaXMpLFxuXG4gICAgICAvLyBoYXJkd2FyZSB3YWxsZXRzXG4gICAgICBjb25uZWN0SGFyZHdhcmU6IHRoaXMuY29ubmVjdEhhcmR3YXJlLmJpbmQodGhpcyksXG4gICAgICBmb3JnZXREZXZpY2U6IHRoaXMuZm9yZ2V0RGV2aWNlLmJpbmQodGhpcyksXG4gICAgICBjaGVja0hhcmR3YXJlU3RhdHVzOiB0aGlzLmNoZWNrSGFyZHdhcmVTdGF0dXMuYmluZCh0aGlzKSxcbiAgICAgIHVubG9ja0hhcmR3YXJlV2FsbGV0QWNjb3VudDogdGhpcy51bmxvY2tIYXJkd2FyZVdhbGxldEFjY291bnQuYmluZCh0aGlzKSxcbiAgICAgIHNldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2U6XG4gICAgICAgIHRoaXMuc2V0TGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZS5iaW5kKHRoaXMpLFxuICAgICAgYXR0ZW1wdExlZGdlclRyYW5zcG9ydENyZWF0aW9uOlxuICAgICAgICB0aGlzLmF0dGVtcHRMZWRnZXJUcmFuc3BvcnRDcmVhdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgZXN0YWJsaXNoTGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZTpcbiAgICAgICAgdGhpcy5lc3RhYmxpc2hMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlLmJpbmQodGhpcyksXG5cbiAgICAgIC8vIHFyIGhhcmR3YXJlIGRldmljZXNcbiAgICAgIHN1Ym1pdFFSSGFyZHdhcmVDcnlwdG9IREtleTpcbiAgICAgICAgcXJIYXJkd2FyZUtleXJpbmcuc3VibWl0Q3J5cHRvSERLZXkuYmluZChxckhhcmR3YXJlS2V5cmluZyksXG4gICAgICBzdWJtaXRRUkhhcmR3YXJlQ3J5cHRvQWNjb3VudDpcbiAgICAgICAgcXJIYXJkd2FyZUtleXJpbmcuc3VibWl0Q3J5cHRvQWNjb3VudC5iaW5kKHFySGFyZHdhcmVLZXlyaW5nKSxcbiAgICAgIGNhbmNlbFN5bmNRUkhhcmR3YXJlOlxuICAgICAgICBxckhhcmR3YXJlS2V5cmluZy5jYW5jZWxTeW5jLmJpbmQocXJIYXJkd2FyZUtleXJpbmcpLFxuICAgICAgc3VibWl0UVJIYXJkd2FyZVNpZ25hdHVyZTpcbiAgICAgICAgcXJIYXJkd2FyZUtleXJpbmcuc3VibWl0U2lnbmF0dXJlLmJpbmQocXJIYXJkd2FyZUtleXJpbmcpLFxuICAgICAgY2FuY2VsUVJIYXJkd2FyZVNpZ25SZXF1ZXN0OlxuICAgICAgICBxckhhcmR3YXJlS2V5cmluZy5jYW5jZWxTaWduUmVxdWVzdC5iaW5kKHFySGFyZHdhcmVLZXlyaW5nKSxcblxuICAgICAgLy8gdmF1bHQgbWFuYWdlbWVudFxuICAgICAgc3VibWl0UGFzc3dvcmQ6IHRoaXMuc3VibWl0UGFzc3dvcmQuYmluZCh0aGlzKSxcbiAgICAgIHZlcmlmeVBhc3N3b3JkOiB0aGlzLnZlcmlmeVBhc3N3b3JkLmJpbmQodGhpcyksXG5cbiAgICAgIC8vIG5ldHdvcmsgbWFuYWdlbWVudFxuICAgICAgc2V0UHJvdmlkZXJUeXBlOlxuICAgICAgICBuZXR3b3JrQ29udHJvbGxlci5zZXRQcm92aWRlclR5cGUuYmluZChuZXR3b3JrQ29udHJvbGxlciksXG4gICAgICByb2xsYmFja1RvUHJldmlvdXNQcm92aWRlcjpcbiAgICAgICAgbmV0d29ya0NvbnRyb2xsZXIucm9sbGJhY2tUb1ByZXZpb3VzUHJvdmlkZXIuYmluZChuZXR3b3JrQ29udHJvbGxlciksXG4gICAgICByZW1vdmVOZXR3b3JrQ29uZmlndXJhdGlvbjpcbiAgICAgICAgbmV0d29ya0NvbnRyb2xsZXIucmVtb3ZlTmV0d29ya0NvbmZpZ3VyYXRpb24uYmluZChuZXR3b3JrQ29udHJvbGxlciksXG4gICAgICBzZXRBY3RpdmVOZXR3b3JrOlxuICAgICAgICBuZXR3b3JrQ29udHJvbGxlci5zZXRBY3RpdmVOZXR3b3JrLmJpbmQobmV0d29ya0NvbnRyb2xsZXIpLFxuICAgICAgdXBzZXJ0TmV0d29ya0NvbmZpZ3VyYXRpb246XG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIudXBzZXJ0TmV0d29ya0NvbmZpZ3VyYXRpb24uYmluZChcbiAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgZ2V0Q3VycmVudE5ldHdvcmtFSVAxNTU5Q29tcGF0aWJpbGl0eTpcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRFSVAxNTU5Q29tcGF0aWJpbGl0eS5iaW5kKFxuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICAvLyBQcmVmZXJlbmNlc0NvbnRyb2xsZXJcbiAgICAgIHNldFNlbGVjdGVkQWRkcmVzczogcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFNlbGVjdGVkQWRkcmVzcy5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgYWRkVG9rZW46IHRva2Vuc0NvbnRyb2xsZXIuYWRkVG9rZW4uYmluZCh0b2tlbnNDb250cm9sbGVyKSxcbiAgICAgIHJlamVjdFdhdGNoQXNzZXQ6XG4gICAgICAgIHRva2Vuc0NvbnRyb2xsZXIucmVqZWN0V2F0Y2hBc3NldC5iaW5kKHRva2Vuc0NvbnRyb2xsZXIpLFxuICAgICAgYWNjZXB0V2F0Y2hBc3NldDpcbiAgICAgICAgdG9rZW5zQ29udHJvbGxlci5hY2NlcHRXYXRjaEFzc2V0LmJpbmQodG9rZW5zQ29udHJvbGxlciksXG4gICAgICB1cGRhdGVUb2tlblR5cGU6IHRva2Vuc0NvbnRyb2xsZXIudXBkYXRlVG9rZW5UeXBlLmJpbmQodG9rZW5zQ29udHJvbGxlciksXG4gICAgICBzZXRBY2NvdW50TGFiZWw6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRBY2NvdW50TGFiZWwuYmluZChcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldEZlYXR1cmVGbGFnOiBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0RmVhdHVyZUZsYWcuYmluZChcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldFByZWZlcmVuY2U6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRQcmVmZXJlbmNlLmJpbmQoXG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgICksXG5cbiAgICAgIGFkZEtub3duTWV0aG9kRGF0YTogcHJlZmVyZW5jZXNDb250cm9sbGVyLmFkZEtub3duTWV0aG9kRGF0YS5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0RGlzbWlzc1NlZWRCYWNrVXBSZW1pbmRlcjpcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldERpc21pc3NTZWVkQmFja1VwUmVtaW5kZXIuYmluZChcbiAgICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICBzZXREaXNhYmxlZFJwY01ldGhvZFByZWZlcmVuY2U6XG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXREaXNhYmxlZFJwY01ldGhvZFByZWZlcmVuY2UuYmluZChcbiAgICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICBnZXRScGNNZXRob2RQcmVmZXJlbmNlczpcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLmdldFJwY01ldGhvZFByZWZlcmVuY2VzLmJpbmQoXG4gICAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgc2V0QWR2YW5jZWRHYXNGZWU6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRBZHZhbmNlZEdhc0ZlZS5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0VGhlbWU6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRUaGVtZS5iaW5kKHByZWZlcmVuY2VzQ29udHJvbGxlciksXG4gICAgICBzZXRUcmFuc2FjdGlvblNlY3VyaXR5Q2hlY2tFbmFibGVkOlxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0VHJhbnNhY3Rpb25TZWN1cml0eUNoZWNrRW5hYmxlZC5iaW5kKFxuICAgICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgIC8vIEFzc2V0c0NvbnRyYWN0Q29udHJvbGxlclxuICAgICAgZ2V0VG9rZW5TdGFuZGFyZEFuZERldGFpbHM6IHRoaXMuZ2V0VG9rZW5TdGFuZGFyZEFuZERldGFpbHMuYmluZCh0aGlzKSxcblxuICAgICAgLy8gTmZ0Q29udHJvbGxlclxuICAgICAgYWRkTmZ0OiBuZnRDb250cm9sbGVyLmFkZE5mdC5iaW5kKG5mdENvbnRyb2xsZXIpLFxuXG4gICAgICBhZGROZnRWZXJpZnlPd25lcnNoaXA6XG4gICAgICAgIG5mdENvbnRyb2xsZXIuYWRkTmZ0VmVyaWZ5T3duZXJzaGlwLmJpbmQobmZ0Q29udHJvbGxlciksXG5cbiAgICAgIHJlbW92ZUFuZElnbm9yZU5mdDogbmZ0Q29udHJvbGxlci5yZW1vdmVBbmRJZ25vcmVOZnQuYmluZChuZnRDb250cm9sbGVyKSxcblxuICAgICAgcmVtb3ZlTmZ0OiBuZnRDb250cm9sbGVyLnJlbW92ZU5mdC5iaW5kKG5mdENvbnRyb2xsZXIpLFxuXG4gICAgICBjaGVja0FuZFVwZGF0ZUFsbE5mdHNPd25lcnNoaXBTdGF0dXM6XG4gICAgICAgIG5mdENvbnRyb2xsZXIuY2hlY2tBbmRVcGRhdGVBbGxOZnRzT3duZXJzaGlwU3RhdHVzLmJpbmQobmZ0Q29udHJvbGxlciksXG5cbiAgICAgIGNoZWNrQW5kVXBkYXRlU2luZ2xlTmZ0T3duZXJzaGlwU3RhdHVzOlxuICAgICAgICBuZnRDb250cm9sbGVyLmNoZWNrQW5kVXBkYXRlU2luZ2xlTmZ0T3duZXJzaGlwU3RhdHVzLmJpbmQoXG4gICAgICAgICAgbmZ0Q29udHJvbGxlcixcbiAgICAgICAgKSxcblxuICAgICAgaXNOZnRPd25lcjogbmZ0Q29udHJvbGxlci5pc05mdE93bmVyLmJpbmQobmZ0Q29udHJvbGxlciksXG5cbiAgICAgIC8vIEFkZHJlc3NDb250cm9sbGVyXG4gICAgICBzZXRBZGRyZXNzQm9vazogYWRkcmVzc0Jvb2tDb250cm9sbGVyLnNldC5iaW5kKGFkZHJlc3NCb29rQ29udHJvbGxlciksXG4gICAgICByZW1vdmVGcm9tQWRkcmVzc0Jvb2s6IGFkZHJlc3NCb29rQ29udHJvbGxlci5kZWxldGUuYmluZChcbiAgICAgICAgYWRkcmVzc0Jvb2tDb250cm9sbGVyLFxuICAgICAgKSxcblxuICAgICAgLy8gQXBwU3RhdGVDb250cm9sbGVyXG4gICAgICBzZXRMYXN0QWN0aXZlVGltZTpcbiAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLnNldExhc3RBY3RpdmVUaW1lLmJpbmQoYXBwU3RhdGVDb250cm9sbGVyKSxcbiAgICAgIHNldERlZmF1bHRIb21lQWN0aXZlVGFiTmFtZTpcbiAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLnNldERlZmF1bHRIb21lQWN0aXZlVGFiTmFtZS5iaW5kKGFwcFN0YXRlQ29udHJvbGxlciksXG4gICAgICBzZXRDb25uZWN0ZWRTdGF0dXNQb3BvdmVySGFzQmVlblNob3duOlxuICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIuc2V0Q29ubmVjdGVkU3RhdHVzUG9wb3Zlckhhc0JlZW5TaG93bi5iaW5kKFxuICAgICAgICAgIGFwcFN0YXRlQ29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgIHNldFJlY292ZXJ5UGhyYXNlUmVtaW5kZXJIYXNCZWVuU2hvd246XG4gICAgICAgIGFwcFN0YXRlQ29udHJvbGxlci5zZXRSZWNvdmVyeVBocmFzZVJlbWluZGVySGFzQmVlblNob3duLmJpbmQoXG4gICAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgc2V0UmVjb3ZlcnlQaHJhc2VSZW1pbmRlckxhc3RTaG93bjpcbiAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLnNldFJlY292ZXJ5UGhyYXNlUmVtaW5kZXJMYXN0U2hvd24uYmluZChcbiAgICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICBzZXRUZXJtc09mVXNlTGFzdEFncmVlZDpcbiAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLnNldFRlcm1zT2ZVc2VMYXN0QWdyZWVkLmJpbmQoYXBwU3RhdGVDb250cm9sbGVyKSxcbiAgICAgIHNldE91dGRhdGVkQnJvd3Nlcldhcm5pbmdMYXN0U2hvd246XG4gICAgICAgIGFwcFN0YXRlQ29udHJvbGxlci5zZXRPdXRkYXRlZEJyb3dzZXJXYXJuaW5nTGFzdFNob3duLmJpbmQoXG4gICAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgc2V0U2hvd1Rlc3RuZXRNZXNzYWdlSW5Ecm9wZG93bjpcbiAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLnNldFNob3dUZXN0bmV0TWVzc2FnZUluRHJvcGRvd24uYmluZChcbiAgICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICBzZXRTaG93QmV0YUhlYWRlcjpcbiAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLnNldFNob3dCZXRhSGVhZGVyLmJpbmQoYXBwU3RhdGVDb250cm9sbGVyKSxcbiAgICAgIHNldFNob3dQcm9kdWN0VG91cjpcbiAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLnNldFNob3dQcm9kdWN0VG91ci5iaW5kKGFwcFN0YXRlQ29udHJvbGxlciksXG4gICAgICB1cGRhdGVOZnREcm9wRG93blN0YXRlOlxuICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIudXBkYXRlTmZ0RHJvcERvd25TdGF0ZS5iaW5kKGFwcFN0YXRlQ29udHJvbGxlciksXG4gICAgICBzZXRGaXJzdFRpbWVVc2VkTmV0d29yazpcbiAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLnNldEZpcnN0VGltZVVzZWROZXR3b3JrLmJpbmQoYXBwU3RhdGVDb250cm9sbGVyKSxcblxuICAgICAgLy8gRW5zQ29udHJvbGxlclxuICAgICAgdHJ5UmV2ZXJzZVJlc29sdmVBZGRyZXNzOlxuICAgICAgICBlbnNDb250cm9sbGVyLnJldmVyc2VSZXNvbHZlQWRkcmVzcy5iaW5kKGVuc0NvbnRyb2xsZXIpLFxuXG4gICAgICAvLyBLZXlyaW5nQ29udHJvbGxlclxuICAgICAgc2V0TG9ja2VkOiB0aGlzLnNldExvY2tlZC5iaW5kKHRoaXMpLFxuICAgICAgY3JlYXRlTmV3VmF1bHRBbmRLZXljaGFpbjogdGhpcy5jcmVhdGVOZXdWYXVsdEFuZEtleWNoYWluLmJpbmQodGhpcyksXG4gICAgICBjcmVhdGVOZXdWYXVsdEFuZFJlc3RvcmU6IHRoaXMuY3JlYXRlTmV3VmF1bHRBbmRSZXN0b3JlLmJpbmQodGhpcyksXG4gICAgICBleHBvcnRBY2NvdW50OiB0aGlzLmV4cG9ydEFjY291bnQuYmluZCh0aGlzKSxcblxuICAgICAgLy8gdHhDb250cm9sbGVyXG4gICAgICBjYW5jZWxUcmFuc2FjdGlvbjogdHhDb250cm9sbGVyLmNhbmNlbFRyYW5zYWN0aW9uLmJpbmQodHhDb250cm9sbGVyKSxcbiAgICAgIHVwZGF0ZVRyYW5zYWN0aW9uOiB0eENvbnRyb2xsZXIudXBkYXRlVHJhbnNhY3Rpb24uYmluZCh0eENvbnRyb2xsZXIpLFxuICAgICAgdXBkYXRlQW5kQXBwcm92ZVRyYW5zYWN0aW9uOlxuICAgICAgICB0eENvbnRyb2xsZXIudXBkYXRlQW5kQXBwcm92ZVRyYW5zYWN0aW9uLmJpbmQodHhDb250cm9sbGVyKSxcbiAgICAgIGFwcHJvdmVUcmFuc2FjdGlvbnNXaXRoU2FtZU5vbmNlOlxuICAgICAgICB0eENvbnRyb2xsZXIuYXBwcm92ZVRyYW5zYWN0aW9uc1dpdGhTYW1lTm9uY2UuYmluZCh0eENvbnRyb2xsZXIpLFxuICAgICAgY3JlYXRlQ2FuY2VsVHJhbnNhY3Rpb246IHRoaXMuY3JlYXRlQ2FuY2VsVHJhbnNhY3Rpb24uYmluZCh0aGlzKSxcbiAgICAgIGNyZWF0ZVNwZWVkVXBUcmFuc2FjdGlvbjogdGhpcy5jcmVhdGVTcGVlZFVwVHJhbnNhY3Rpb24uYmluZCh0aGlzKSxcbiAgICAgIGVzdGltYXRlR2FzOiB0aGlzLmVzdGltYXRlR2FzLmJpbmQodGhpcyksXG4gICAgICBnZXROZXh0Tm9uY2U6IHRoaXMuZ2V0TmV4dE5vbmNlLmJpbmQodGhpcyksXG4gICAgICBhZGRVbmFwcHJvdmVkVHJhbnNhY3Rpb246XG4gICAgICAgIHR4Q29udHJvbGxlci5hZGRVbmFwcHJvdmVkVHJhbnNhY3Rpb24uYmluZCh0eENvbnRyb2xsZXIpLFxuICAgICAgY3JlYXRlVHJhbnNhY3Rpb25FdmVudEZyYWdtZW50OlxuICAgICAgICB0eENvbnRyb2xsZXIuY3JlYXRlVHJhbnNhY3Rpb25FdmVudEZyYWdtZW50LmJpbmQodHhDb250cm9sbGVyKSxcbiAgICAgIGdldFRyYW5zYWN0aW9uczogdHhDb250cm9sbGVyLmdldFRyYW5zYWN0aW9ucy5iaW5kKHR4Q29udHJvbGxlciksXG5cbiAgICAgIHVwZGF0ZUVkaXRhYmxlUGFyYW1zOlxuICAgICAgICB0eENvbnRyb2xsZXIudXBkYXRlRWRpdGFibGVQYXJhbXMuYmluZCh0eENvbnRyb2xsZXIpLFxuICAgICAgdXBkYXRlVHJhbnNhY3Rpb25HYXNGZWVzOlxuICAgICAgICB0eENvbnRyb2xsZXIudXBkYXRlVHJhbnNhY3Rpb25HYXNGZWVzLmJpbmQodHhDb250cm9sbGVyKSxcbiAgICAgIHVwZGF0ZVRyYW5zYWN0aW9uU2VuZEZsb3dIaXN0b3J5OlxuICAgICAgICB0eENvbnRyb2xsZXIudXBkYXRlVHJhbnNhY3Rpb25TZW5kRmxvd0hpc3RvcnkuYmluZCh0eENvbnRyb2xsZXIpLFxuXG4gICAgICB1cGRhdGVTd2FwQXBwcm92YWxUcmFuc2FjdGlvbjpcbiAgICAgICAgdHhDb250cm9sbGVyLnVwZGF0ZVN3YXBBcHByb3ZhbFRyYW5zYWN0aW9uLmJpbmQodHhDb250cm9sbGVyKSxcbiAgICAgIHVwZGF0ZVN3YXBUcmFuc2FjdGlvbjpcbiAgICAgICAgdHhDb250cm9sbGVyLnVwZGF0ZVN3YXBUcmFuc2FjdGlvbi5iaW5kKHR4Q29udHJvbGxlciksXG5cbiAgICAgIHVwZGF0ZVByZXZpb3VzR2FzUGFyYW1zOlxuICAgICAgICB0eENvbnRyb2xsZXIudXBkYXRlUHJldmlvdXNHYXNQYXJhbXMuYmluZCh0eENvbnRyb2xsZXIpLFxuXG4gICAgICAvLyBzaWduYXR1cmVDb250cm9sbGVyXG4gICAgICBzaWduTWVzc2FnZTogdGhpcy5zaWduYXR1cmVDb250cm9sbGVyLnNpZ25NZXNzYWdlLmJpbmQoXG4gICAgICAgIHRoaXMuc2lnbmF0dXJlQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBjYW5jZWxNZXNzYWdlOiB0aGlzLnNpZ25hdHVyZUNvbnRyb2xsZXIuY2FuY2VsTWVzc2FnZS5iaW5kKFxuICAgICAgICB0aGlzLnNpZ25hdHVyZUNvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2lnblBlcnNvbmFsTWVzc2FnZTogdGhpcy5zaWduYXR1cmVDb250cm9sbGVyLnNpZ25QZXJzb25hbE1lc3NhZ2UuYmluZChcbiAgICAgICAgdGhpcy5zaWduYXR1cmVDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIGNhbmNlbFBlcnNvbmFsTWVzc2FnZTpcbiAgICAgICAgdGhpcy5zaWduYXR1cmVDb250cm9sbGVyLmNhbmNlbFBlcnNvbmFsTWVzc2FnZS5iaW5kKFxuICAgICAgICAgIHRoaXMuc2lnbmF0dXJlQ29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgIHNpZ25UeXBlZE1lc3NhZ2U6IHRoaXMuc2lnbmF0dXJlQ29udHJvbGxlci5zaWduVHlwZWRNZXNzYWdlLmJpbmQoXG4gICAgICAgIHRoaXMuc2lnbmF0dXJlQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBjYW5jZWxUeXBlZE1lc3NhZ2U6IHRoaXMuc2lnbmF0dXJlQ29udHJvbGxlci5jYW5jZWxUeXBlZE1lc3NhZ2UuYmluZChcbiAgICAgICAgdGhpcy5zaWduYXR1cmVDb250cm9sbGVyLFxuICAgICAgKSxcblxuICAgICAgLy8gZGVjcnlwdE1lc3NhZ2VDb250cm9sbGVyXG4gICAgICBkZWNyeXB0TWVzc2FnZTogdGhpcy5kZWNyeXB0TWVzc2FnZUNvbnRyb2xsZXIuZGVjcnlwdE1lc3NhZ2UuYmluZChcbiAgICAgICAgdGhpcy5kZWNyeXB0TWVzc2FnZUNvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgZGVjcnlwdE1lc3NhZ2VJbmxpbmU6XG4gICAgICAgIHRoaXMuZGVjcnlwdE1lc3NhZ2VDb250cm9sbGVyLmRlY3J5cHRNZXNzYWdlSW5saW5lLmJpbmQoXG4gICAgICAgICAgdGhpcy5kZWNyeXB0TWVzc2FnZUNvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICBjYW5jZWxEZWNyeXB0TWVzc2FnZTpcbiAgICAgICAgdGhpcy5kZWNyeXB0TWVzc2FnZUNvbnRyb2xsZXIuY2FuY2VsRGVjcnlwdE1lc3NhZ2UuYmluZChcbiAgICAgICAgICB0aGlzLmRlY3J5cHRNZXNzYWdlQ29udHJvbGxlcixcbiAgICAgICAgKSxcblxuICAgICAgLy8gRW5jcnlwdGlvblB1YmxpY0tleUNvbnRyb2xsZXJcbiAgICAgIGVuY3J5cHRpb25QdWJsaWNLZXk6XG4gICAgICAgIHRoaXMuZW5jcnlwdGlvblB1YmxpY0tleUNvbnRyb2xsZXIuZW5jcnlwdGlvblB1YmxpY0tleS5iaW5kKFxuICAgICAgICAgIHRoaXMuZW5jcnlwdGlvblB1YmxpY0tleUNvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICBjYW5jZWxFbmNyeXB0aW9uUHVibGljS2V5OlxuICAgICAgICB0aGlzLmVuY3J5cHRpb25QdWJsaWNLZXlDb250cm9sbGVyLmNhbmNlbEVuY3J5cHRpb25QdWJsaWNLZXkuYmluZChcbiAgICAgICAgICB0aGlzLmVuY3J5cHRpb25QdWJsaWNLZXlDb250cm9sbGVyLFxuICAgICAgICApLFxuXG4gICAgICAvLyBvbmJvYXJkaW5nIGNvbnRyb2xsZXJcbiAgICAgIHNldFNlZWRQaHJhc2VCYWNrZWRVcDpcbiAgICAgICAgb25ib2FyZGluZ0NvbnRyb2xsZXIuc2V0U2VlZFBocmFzZUJhY2tlZFVwLmJpbmQob25ib2FyZGluZ0NvbnRyb2xsZXIpLFxuICAgICAgY29tcGxldGVPbmJvYXJkaW5nOlxuICAgICAgICBvbmJvYXJkaW5nQ29udHJvbGxlci5jb21wbGV0ZU9uYm9hcmRpbmcuYmluZChvbmJvYXJkaW5nQ29udHJvbGxlciksXG4gICAgICBzZXRGaXJzdFRpbWVGbG93VHlwZTpcbiAgICAgICAgb25ib2FyZGluZ0NvbnRyb2xsZXIuc2V0Rmlyc3RUaW1lRmxvd1R5cGUuYmluZChvbmJvYXJkaW5nQ29udHJvbGxlciksXG5cbiAgICAgIC8vIGFsZXJ0IGNvbnRyb2xsZXJcbiAgICAgIHNldEFsZXJ0RW5hYmxlZG5lc3M6XG4gICAgICAgIGFsZXJ0Q29udHJvbGxlci5zZXRBbGVydEVuYWJsZWRuZXNzLmJpbmQoYWxlcnRDb250cm9sbGVyKSxcbiAgICAgIHNldFVuY29ubmVjdGVkQWNjb3VudEFsZXJ0U2hvd246XG4gICAgICAgIGFsZXJ0Q29udHJvbGxlci5zZXRVbmNvbm5lY3RlZEFjY291bnRBbGVydFNob3duLmJpbmQoYWxlcnRDb250cm9sbGVyKSxcbiAgICAgIHNldFdlYjNTaGltVXNhZ2VBbGVydERpc21pc3NlZDpcbiAgICAgICAgYWxlcnRDb250cm9sbGVyLnNldFdlYjNTaGltVXNhZ2VBbGVydERpc21pc3NlZC5iaW5kKGFsZXJ0Q29udHJvbGxlciksXG5cbiAgICAgIC8vIHBlcm1pc3Npb25zXG4gICAgICByZW1vdmVQZXJtaXNzaW9uc0ZvcjogdGhpcy5yZW1vdmVQZXJtaXNzaW9uc0ZvcixcbiAgICAgIGFwcHJvdmVQZXJtaXNzaW9uc1JlcXVlc3Q6IHRoaXMuYWNjZXB0UGVybWlzc2lvbnNSZXF1ZXN0LFxuICAgICAgcmVqZWN0UGVybWlzc2lvbnNSZXF1ZXN0OiB0aGlzLnJlamVjdFBlcm1pc3Npb25zUmVxdWVzdCxcbiAgICAgIC4uLmdldFBlcm1pc3Npb25CYWNrZ3JvdW5kQXBpTWV0aG9kcyhwZXJtaXNzaW9uQ29udHJvbGxlciksXG5cblxuICAgICAgLy8gc3dhcHNcbiAgICAgIGZldGNoQW5kU2V0UXVvdGVzOlxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIuZmV0Y2hBbmRTZXRRdW90ZXMuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgc2V0U2VsZWN0ZWRRdW90ZUFnZ0lkOlxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIuc2V0U2VsZWN0ZWRRdW90ZUFnZ0lkLmJpbmQoc3dhcHNDb250cm9sbGVyKSxcbiAgICAgIHJlc2V0U3dhcHNTdGF0ZTogc3dhcHNDb250cm9sbGVyLnJlc2V0U3dhcHNTdGF0ZS5iaW5kKHN3YXBzQ29udHJvbGxlciksXG4gICAgICBzZXRTd2Fwc1Rva2Vuczogc3dhcHNDb250cm9sbGVyLnNldFN3YXBzVG9rZW5zLmJpbmQoc3dhcHNDb250cm9sbGVyKSxcbiAgICAgIGNsZWFyU3dhcHNRdW90ZXM6IHN3YXBzQ29udHJvbGxlci5jbGVhclN3YXBzUXVvdGVzLmJpbmQoc3dhcHNDb250cm9sbGVyKSxcbiAgICAgIHNldEFwcHJvdmVUeElkOiBzd2Fwc0NvbnRyb2xsZXIuc2V0QXBwcm92ZVR4SWQuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgc2V0VHJhZGVUeElkOiBzd2Fwc0NvbnRyb2xsZXIuc2V0VHJhZGVUeElkLmJpbmQoc3dhcHNDb250cm9sbGVyKSxcbiAgICAgIHNldFN3YXBzVHhHYXNQcmljZTpcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLnNldFN3YXBzVHhHYXNQcmljZS5iaW5kKHN3YXBzQ29udHJvbGxlciksXG4gICAgICBzZXRTd2Fwc1R4R2FzTGltaXQ6XG4gICAgICAgIHN3YXBzQ29udHJvbGxlci5zZXRTd2Fwc1R4R2FzTGltaXQuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgc2V0U3dhcHNUeE1heEZlZVBlckdhczpcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLnNldFN3YXBzVHhNYXhGZWVQZXJHYXMuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgc2V0U3dhcHNUeE1heEZlZVByaW9yaXR5UGVyR2FzOlxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIuc2V0U3dhcHNUeE1heEZlZVByaW9yaXR5UGVyR2FzLmJpbmQoc3dhcHNDb250cm9sbGVyKSxcbiAgICAgIHNhZmVSZWZldGNoUXVvdGVzOlxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIuc2FmZVJlZmV0Y2hRdW90ZXMuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgc3RvcFBvbGxpbmdGb3JRdW90ZXM6XG4gICAgICAgIHN3YXBzQ29udHJvbGxlci5zdG9wUG9sbGluZ0ZvclF1b3Rlcy5iaW5kKHN3YXBzQ29udHJvbGxlciksXG4gICAgICBzZXRCYWNrZ3JvdW5kU3dhcFJvdXRlU3RhdGU6XG4gICAgICAgIHN3YXBzQ29udHJvbGxlci5zZXRCYWNrZ3JvdW5kU3dhcFJvdXRlU3RhdGUuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgcmVzZXRQb3N0RmV0Y2hTdGF0ZTpcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLnJlc2V0UG9zdEZldGNoU3RhdGUuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgc2V0U3dhcHNFcnJvcktleTogc3dhcHNDb250cm9sbGVyLnNldFN3YXBzRXJyb3JLZXkuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgc2V0SW5pdGlhbEdhc0VzdGltYXRlOlxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIuc2V0SW5pdGlhbEdhc0VzdGltYXRlLmJpbmQoc3dhcHNDb250cm9sbGVyKSxcbiAgICAgIHNldEN1c3RvbUFwcHJvdmVUeERhdGE6XG4gICAgICAgIHN3YXBzQ29udHJvbGxlci5zZXRDdXN0b21BcHByb3ZlVHhEYXRhLmJpbmQoc3dhcHNDb250cm9sbGVyKSxcbiAgICAgIHNldFN3YXBzTGl2ZW5lc3M6IHN3YXBzQ29udHJvbGxlci5zZXRTd2Fwc0xpdmVuZXNzLmJpbmQoc3dhcHNDb250cm9sbGVyKSxcbiAgICAgIHNldFN3YXBzRmVhdHVyZUZsYWdzOlxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIuc2V0U3dhcHNGZWF0dXJlRmxhZ3MuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgc2V0U3dhcHNVc2VyRmVlTGV2ZWw6XG4gICAgICAgIHN3YXBzQ29udHJvbGxlci5zZXRTd2Fwc1VzZXJGZWVMZXZlbC5iaW5kKHN3YXBzQ29udHJvbGxlciksXG4gICAgICBzZXRTd2Fwc1F1b3Rlc1BvbGxpbmdMaW1pdEVuYWJsZWQ6XG4gICAgICAgIHN3YXBzQ29udHJvbGxlci5zZXRTd2Fwc1F1b3Rlc1BvbGxpbmdMaW1pdEVuYWJsZWQuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuXG4gICAgICAvLyBTbWFydCBUcmFuc2FjdGlvbnNcbiAgICAgIHNldFNtYXJ0VHJhbnNhY3Rpb25zT3B0SW5TdGF0dXM6XG4gICAgICAgIHNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlci5zZXRPcHRJblN0YXRlLmJpbmQoXG4gICAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgZmV0Y2hTbWFydFRyYW5zYWN0aW9uRmVlczogc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLmdldEZlZXMuYmluZChcbiAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIGNsZWFyU21hcnRUcmFuc2FjdGlvbkZlZXM6IHNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlci5jbGVhckZlZXMuYmluZChcbiAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHN1Ym1pdFNpZ25lZFRyYW5zYWN0aW9uczpcbiAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLnN1Ym1pdFNpZ25lZFRyYW5zYWN0aW9ucy5iaW5kKFxuICAgICAgICAgIHNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgIGNhbmNlbFNtYXJ0VHJhbnNhY3Rpb246XG4gICAgICAgIHNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlci5jYW5jZWxTbWFydFRyYW5zYWN0aW9uLmJpbmQoXG4gICAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgZmV0Y2hTbWFydFRyYW5zYWN0aW9uc0xpdmVuZXNzOlxuICAgICAgICBzbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIuZmV0Y2hMaXZlbmVzcy5iaW5kKFxuICAgICAgICAgIHNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgIHVwZGF0ZVNtYXJ0VHJhbnNhY3Rpb246XG4gICAgICAgIHNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlci51cGRhdGVTbWFydFRyYW5zYWN0aW9uLmJpbmQoXG4gICAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgc2V0U3RhdHVzUmVmcmVzaEludGVydmFsOlxuICAgICAgICBzbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIuc2V0U3RhdHVzUmVmcmVzaEludGVydmFsLmJpbmQoXG4gICAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxuICAgICAgICApLFxuXG4gICAgICAvLyBNZXRhTWV0cmljc1xuICAgICAgdHJhY2tNZXRhTWV0cmljc0V2ZW50OiBtZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tFdmVudC5iaW5kKFxuICAgICAgICBtZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgdHJhY2tNZXRhTWV0cmljc1BhZ2U6IG1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja1BhZ2UuYmluZChcbiAgICAgICAgbWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIGNyZWF0ZUV2ZW50RnJhZ21lbnQ6IG1ldGFNZXRyaWNzQ29udHJvbGxlci5jcmVhdGVFdmVudEZyYWdtZW50LmJpbmQoXG4gICAgICAgIG1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICB1cGRhdGVFdmVudEZyYWdtZW50OiBtZXRhTWV0cmljc0NvbnRyb2xsZXIudXBkYXRlRXZlbnRGcmFnbWVudC5iaW5kKFxuICAgICAgICBtZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgZmluYWxpemVFdmVudEZyYWdtZW50OiBtZXRhTWV0cmljc0NvbnRyb2xsZXIuZmluYWxpemVFdmVudEZyYWdtZW50LmJpbmQoXG4gICAgICAgIG1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgICksXG5cbiAgICAgIC8vIGFwcHJvdmFsIGNvbnRyb2xsZXJcbiAgICAgIHJlc29sdmVQZW5kaW5nQXBwcm92YWw6IHRoaXMucmVzb2x2ZVBlbmRpbmdBcHByb3ZhbCxcbiAgICAgIHJlamVjdFBlbmRpbmdBcHByb3ZhbDogdGhpcy5yZWplY3RQZW5kaW5nQXBwcm92YWwsXG5cbiAgICAgIC8vIE5vdGlmaWNhdGlvbnNcbiAgICAgIHVwZGF0ZVZpZXdlZE5vdGlmaWNhdGlvbnM6IGFubm91bmNlbWVudENvbnRyb2xsZXIudXBkYXRlVmlld2VkLmJpbmQoXG4gICAgICAgIGFubm91bmNlbWVudENvbnRyb2xsZXIsXG4gICAgICApLFxuXG4gICAgICAvLyBHYXNGZWVDb250cm9sbGVyXG4gICAgICBnZXRHYXNGZWVFc3RpbWF0ZXNBbmRTdGFydFBvbGxpbmc6XG4gICAgICAgIGdhc0ZlZUNvbnRyb2xsZXIuZ2V0R2FzRmVlRXN0aW1hdGVzQW5kU3RhcnRQb2xsaW5nLmJpbmQoXG4gICAgICAgICAgZ2FzRmVlQ29udHJvbGxlcixcbiAgICAgICAgKSxcblxuICAgICAgZGlzY29ubmVjdEdhc0ZlZUVzdGltYXRlUG9sbGVyOlxuICAgICAgICBnYXNGZWVDb250cm9sbGVyLmRpc2Nvbm5lY3RQb2xsZXIuYmluZChnYXNGZWVDb250cm9sbGVyKSxcblxuICAgICAgZ2V0R2FzRmVlVGltZUVzdGltYXRlOlxuICAgICAgICBnYXNGZWVDb250cm9sbGVyLmdldFRpbWVFc3RpbWF0ZS5iaW5kKGdhc0ZlZUNvbnRyb2xsZXIpLFxuXG4gICAgICBhZGRQb2xsaW5nVG9rZW5Ub0FwcFN0YXRlOlxuICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIuYWRkUG9sbGluZ1Rva2VuLmJpbmQoYXBwU3RhdGVDb250cm9sbGVyKSxcblxuICAgICAgcmVtb3ZlUG9sbGluZ1Rva2VuRnJvbUFwcFN0YXRlOlxuICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIucmVtb3ZlUG9sbGluZ1Rva2VuLmJpbmQoYXBwU3RhdGVDb250cm9sbGVyKSxcblxuICAgICAgLy8gQmFja3VwQ29udHJvbGxlclxuICAgICAgYmFja3VwVXNlckRhdGE6IGJhY2t1cENvbnRyb2xsZXIuYmFja3VwVXNlckRhdGEuYmluZChiYWNrdXBDb250cm9sbGVyKSxcbiAgICAgIHJlc3RvcmVVc2VyRGF0YTogYmFja3VwQ29udHJvbGxlci5yZXN0b3JlVXNlckRhdGEuYmluZChiYWNrdXBDb250cm9sbGVyKSxcblxuICAgICAgLy8gRGV0ZWN0VG9rZW5Db250cm9sbGVyXG4gICAgICBkZXRlY3ROZXdUb2tlbnM6IGRldGVjdFRva2Vuc0NvbnRyb2xsZXIuZGV0ZWN0TmV3VG9rZW5zLmJpbmQoXG4gICAgICAgIGRldGVjdFRva2Vuc0NvbnRyb2xsZXIsXG4gICAgICApLFxuXG4gICAgICAvLyBEZXRlY3RDb2xsZWN0aWJsZUNvbnRyb2xsZXJcbiAgICAgIGRldGVjdE5mdHM6IG5mdERldGVjdGlvbkNvbnRyb2xsZXIuZGV0ZWN0TmZ0cy5iaW5kKFxuICAgICAgICBuZnREZXRlY3Rpb25Db250cm9sbGVyLFxuICAgICAgKSxcblxuICAgICAgLyoqIFRva2VuIERldGVjdGlvbiBWMiAqL1xuICAgICAgYWRkRGV0ZWN0ZWRUb2tlbnM6XG4gICAgICAgIHRva2Vuc0NvbnRyb2xsZXIuYWRkRGV0ZWN0ZWRUb2tlbnMuYmluZCh0b2tlbnNDb250cm9sbGVyKSxcbiAgICAgIGFkZEltcG9ydGVkVG9rZW5zOiB0b2tlbnNDb250cm9sbGVyLmFkZFRva2Vucy5iaW5kKHRva2Vuc0NvbnRyb2xsZXIpLFxuICAgICAgaWdub3JlVG9rZW5zOiB0b2tlbnNDb250cm9sbGVyLmlnbm9yZVRva2Vucy5iaW5kKHRva2Vuc0NvbnRyb2xsZXIpLFxuICAgICAgZ2V0QmFsYW5jZXNJblNpbmdsZUNhbGw6XG4gICAgICAgIGFzc2V0c0NvbnRyYWN0Q29udHJvbGxlci5nZXRCYWxhbmNlc0luU2luZ2xlQ2FsbC5iaW5kKFxuICAgICAgICAgIGFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgZXhwb3J0QWNjb3VudChhZGRyZXNzLCBwYXNzd29yZCkge1xuICAgIGF3YWl0IHRoaXMudmVyaWZ5UGFzc3dvcmQocGFzc3dvcmQpO1xuICAgIHJldHVybiB0aGlzLmtleXJpbmdDb250cm9sbGVyLmV4cG9ydEFjY291bnQoYWRkcmVzcywgcGFzc3dvcmQpO1xuICB9XG5cbiAgYXN5bmMgZ2V0VG9rZW5TdGFuZGFyZEFuZERldGFpbHMoYWRkcmVzcywgdXNlckFkZHJlc3MsIHRva2VuSWQpIHtcbiAgICBjb25zdCB7IHRva2VuTGlzdCB9ID0gdGhpcy50b2tlbkxpc3RDb250cm9sbGVyLnN0YXRlO1xuICAgIGNvbnN0IHsgdG9rZW5zIH0gPSB0aGlzLnRva2Vuc0NvbnRyb2xsZXIuc3RhdGU7XG5cbiAgICBjb25zdCBzdGF0aWNUb2tlbkxpc3REZXRhaWxzID1cbiAgICAgIFNUQVRJQ19NQUlOTkVUX1RPS0VOX0xJU1RbYWRkcmVzcy50b0xvd2VyQ2FzZSgpXSB8fCB7fTtcbiAgICBjb25zdCB0b2tlbkxpc3REZXRhaWxzID0gdG9rZW5MaXN0W2FkZHJlc3MudG9Mb3dlckNhc2UoKV0gfHwge307XG4gICAgY29uc3QgdXNlckRlZmluZWRUb2tlbkRldGFpbHMgPVxuICAgICAgdG9rZW5zLmZpbmQoKHsgYWRkcmVzczogX2FkZHJlc3MgfSkgPT5cbiAgICAgICAgaXNFcXVhbENhc2VJbnNlbnNpdGl2ZShfYWRkcmVzcywgYWRkcmVzcyksXG4gICAgICApIHx8IHt9O1xuXG4gICAgY29uc3QgdG9rZW5EZXRhaWxzID0ge1xuICAgICAgLi4uc3RhdGljVG9rZW5MaXN0RGV0YWlscyxcbiAgICAgIC4uLnRva2VuTGlzdERldGFpbHMsXG4gICAgICAuLi51c2VyRGVmaW5lZFRva2VuRGV0YWlscyxcbiAgICB9O1xuICAgIGNvbnN0IHRva2VuRGV0YWlsc1N0YW5kYXJkSXNFUkMyMCA9XG4gICAgICBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlKHRva2VuRGV0YWlscy5zdGFuZGFyZCwgVG9rZW5TdGFuZGFyZC5FUkMyMCkgfHxcbiAgICAgIHRva2VuRGV0YWlscy5lcmMyMCA9PT0gdHJ1ZTtcbiAgICBjb25zdCBub0V2aWRlbmNlVGhhdFRva2VuSXNBbk5GVCA9XG4gICAgICAhdG9rZW5JZCAmJlxuICAgICAgIWlzRXF1YWxDYXNlSW5zZW5zaXRpdmUodG9rZW5EZXRhaWxzLnN0YW5kYXJkLCBUb2tlblN0YW5kYXJkLkVSQzExNTUpICYmXG4gICAgICAhaXNFcXVhbENhc2VJbnNlbnNpdGl2ZSh0b2tlbkRldGFpbHMuc3RhbmRhcmQsIFRva2VuU3RhbmRhcmQuRVJDNzIxKSAmJlxuICAgICAgIXRva2VuRGV0YWlscy5lcmM3MjE7XG5cbiAgICBjb25zdCBvdGhlckRldGFpbHNBcmVFUkMyMExpa2UgPVxuICAgICAgdG9rZW5EZXRhaWxzLmRlY2ltYWxzICE9PSB1bmRlZmluZWQgJiYgdG9rZW5EZXRhaWxzLnN5bWJvbDtcblxuICAgIGNvbnN0IHRva2VuQ2FuQmVUcmVhdGVkQXNBbkVSQzIwID1cbiAgICAgIHRva2VuRGV0YWlsc1N0YW5kYXJkSXNFUkMyMCB8fFxuICAgICAgKG5vRXZpZGVuY2VUaGF0VG9rZW5Jc0FuTkZUICYmIG90aGVyRGV0YWlsc0FyZUVSQzIwTGlrZSk7XG5cbiAgICBsZXQgZGV0YWlscztcbiAgICBpZiAodG9rZW5DYW5CZVRyZWF0ZWRBc0FuRVJDMjApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBmZXRjaFRva2VuQmFsYW5jZShcbiAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgIHVzZXJBZGRyZXNzLFxuICAgICAgICAgIHRoaXMucHJvdmlkZXIsXG4gICAgICAgICk7XG5cbiAgICAgICAgZGV0YWlscyA9IHtcbiAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgIGJhbGFuY2UsXG4gICAgICAgICAgc3RhbmRhcmQ6IFRva2VuU3RhbmRhcmQuRVJDMjAsXG4gICAgICAgICAgZGVjaW1hbHM6IHRva2VuRGV0YWlscy5kZWNpbWFscyxcbiAgICAgICAgICBzeW1ib2w6IHRva2VuRGV0YWlscy5zeW1ib2wsXG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIElmIHRoZSBgZmV0Y2hUb2tlbkJhbGFuY2VgIGNhbGwgZmFpbGVkLCBgZGV0YWlsc2AgcmVtYWlucyB1bmRlZmluZWQsIGFuZCB3ZVxuICAgICAgICAvLyBmYWxsIGJhY2sgdG8gdGhlIGJlbG93IGBhc3NldHNDb250cmFjdENvbnRyb2xsZXIuZ2V0VG9rZW5TdGFuZGFyZEFuZERldGFpbHNgIGNhbGxcbiAgICAgICAgbG9nLndhcm5pbmcoYEZhaWxlZCB0byBnZXQgdG9rZW4gYmFsYW5jZS4gRXJyb3I6ICR7ZX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBgZGV0YWlsc2BgIHdpbGwgYmUgdW5kZWZpbmVkIGlmIGB0b2tlbkNhbkJlVHJlYXRlZEFzQW5FUkMyMGBgIGlzIGZhbHNlLFxuICAgIC8vIG9yIGlmIGl0IGlzIHRydWUgYnV0IHRoZSBgZmV0Y2hUb2tlbkJhbGFuY2VgYCBjYWxsIGZhaWxlZC4gSW4gZWl0aGVyIGNhc2UsIHdlIHNob3VsZFxuICAgIC8vIGF0dGVtcHQgdG8gcmV0cmlldmUgZGV0YWlscyBmcm9tIGBhc3NldHNDb250cmFjdENvbnRyb2xsZXIuZ2V0VG9rZW5TdGFuZGFyZEFuZERldGFpbHNgXG4gICAgaWYgKGRldGFpbHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZGV0YWlscyA9IGF3YWl0IHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLmdldFRva2VuU3RhbmRhcmRBbmREZXRhaWxzKFxuICAgICAgICBhZGRyZXNzLFxuICAgICAgICB1c2VyQWRkcmVzcyxcbiAgICAgICAgdG9rZW5JZCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRldGFpbHMsXG4gICAgICBkZWNpbWFsczogZGV0YWlscz8uZGVjaW1hbHM/LnRvU3RyaW5nKDEwKSxcbiAgICAgIGJhbGFuY2U6IGRldGFpbHM/LmJhbGFuY2U/LnRvU3RyaW5nKDEwKSxcbiAgICB9O1xuICB9XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBWQVVMVCAvIEtFWVJJTkcgUkVMQVRFRCBNRVRIT0RTXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBWYXVsdCBhbmQgY3JlYXRlIGEgbmV3IGtleWNoYWluLlxuICAgKlxuICAgKiBBIHZhdWx0LCBvciBLZXlyaW5nQ29udHJvbGxlciwgaXMgYSBjb250cm9sbGVyIHRoYXQgY29udGFpbnNcbiAgICogbWFueSBkaWZmZXJlbnQgYWNjb3VudCBzdHJhdGVnaWVzLCBjdXJyZW50bHkgY2FsbGVkIEtleXJpbmdzLlxuICAgKiBDcmVhdGluZyBpdCBuZXcgbWVhbnMgd2lwaW5nIGFsbCBwcmV2aW91cyBrZXlyaW5ncy5cbiAgICpcbiAgICogQSBrZXljaGFpbiwgb3Iga2V5cmluZywgY29udHJvbHMgbWFueSBhY2NvdW50cyB3aXRoIGEgc2luZ2xlIGJhY2t1cCBhbmQgc2lnbmluZyBzdHJhdGVneS5cbiAgICogRm9yIGV4YW1wbGUsIGEgbW5lbW9uaWMgcGhyYXNlIGNhbiBnZW5lcmF0ZSBtYW55IGFjY291bnRzLCBhbmQgaXMgYSBrZXlyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRcbiAgICogQHJldHVybnMge29iamVjdH0gdmF1bHRcbiAgICovXG4gIGFzeW5jIGNyZWF0ZU5ld1ZhdWx0QW5kS2V5Y2hhaW4ocGFzc3dvcmQpIHtcbiAgICBjb25zdCByZWxlYXNlTG9jayA9IGF3YWl0IHRoaXMuY3JlYXRlVmF1bHRNdXRleC5hY3F1aXJlKCk7XG4gICAgdHJ5IHtcbiAgICAgIGxldCB2YXVsdDtcbiAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRBY2NvdW50cygpO1xuICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmF1bHQgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmZ1bGxVcGRhdGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhdWx0ID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5jcmVhdGVOZXdWYXVsdEFuZEtleWNoYWluKFxuICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzKCk7XG4gICAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnNldEFkZHJlc3NlcyhhZGRyZXNzZXMpO1xuICAgICAgICB0aGlzLnNlbGVjdEZpcnN0SWRlbnRpdHkoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhdWx0O1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZWxlYXNlTG9jaygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgVmF1bHQgYW5kIHJlc3RvcmUgYW4gZXhpc3RlbnQga2V5cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IGVuY29kZWRTZWVkUGhyYXNlIC0gVGhlIHNlZWQgcGhyYXNlLCBlbmNvZGVkIGFzIGFuIGFycmF5XG4gICAqIG9mIFVURi04IGJ5dGVzLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlTmV3VmF1bHRBbmRSZXN0b3JlKHBhc3N3b3JkLCBlbmNvZGVkU2VlZFBocmFzZSkge1xuICAgIGNvbnN0IHJlbGVhc2VMb2NrID0gYXdhaXQgdGhpcy5jcmVhdGVWYXVsdE11dGV4LmFjcXVpcmUoKTtcbiAgICB0cnkge1xuICAgICAgbGV0IGFjY291bnRzLCBsYXN0QmFsYW5jZTtcblxuICAgICAgY29uc3Qgc2VlZFBocmFzZUFzQnVmZmVyID0gQnVmZmVyLmZyb20oZW5jb2RlZFNlZWRQaHJhc2UpO1xuXG4gICAgICBjb25zdCB7IGtleXJpbmdDb250cm9sbGVyIH0gPSB0aGlzO1xuXG4gICAgICAvLyBjbGVhciBrbm93biBpZGVudGl0aWVzXG4gICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRBZGRyZXNzZXMoW10pO1xuXG4gICAgICAvLyBjbGVhciBwZXJtaXNzaW9uc1xuICAgICAgdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlci5jbGVhclN0YXRlKCk7XG5cblxuICAgICAgLy8gY2xlYXIgYWNjb3VudHMgaW4gYWNjb3VudFRyYWNrZXJcbiAgICAgIHRoaXMuYWNjb3VudFRyYWNrZXIuY2xlYXJBY2NvdW50cygpO1xuXG4gICAgICAvLyBjbGVhciBjYWNoZWRCYWxhbmNlc1xuICAgICAgdGhpcy5jYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXIuY2xlYXJDYWNoZWRCYWxhbmNlcygpO1xuXG4gICAgICAvLyBjbGVhciB1bmFwcHJvdmVkIHRyYW5zYWN0aW9uc1xuICAgICAgdGhpcy50eENvbnRyb2xsZXIudHhTdGF0ZU1hbmFnZXIuY2xlYXJVbmFwcHJvdmVkVHhzKCk7XG5cbiAgICAgIC8vIGNyZWF0ZSBuZXcgdmF1bHRcbiAgICAgIGNvbnN0IHZhdWx0ID0gYXdhaXQga2V5cmluZ0NvbnRyb2xsZXIuY3JlYXRlTmV3VmF1bHRBbmRSZXN0b3JlKFxuICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgc2VlZFBocmFzZUFzQnVmZmVyLFxuICAgICAgKTtcblxuICAgICAgY29uc3QgZXRoUXVlcnkgPSBuZXcgRXRoUXVlcnkodGhpcy5wcm92aWRlcik7XG4gICAgICBhY2NvdW50cyA9IGF3YWl0IGtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzKCk7XG4gICAgICBsYXN0QmFsYW5jZSA9IGF3YWl0IHRoaXMuZ2V0QmFsYW5jZShcbiAgICAgICAgYWNjb3VudHNbYWNjb3VudHMubGVuZ3RoIC0gMV0sXG4gICAgICAgIGV0aFF1ZXJ5LFxuICAgICAgKTtcblxuICAgICAgY29uc3QgW3ByaW1hcnlLZXlyaW5nXSA9IGtleXJpbmdDb250cm9sbGVyLmdldEtleXJpbmdzQnlUeXBlKFxuICAgICAgICBLZXlyaW5nVHlwZS5oZEtleVRyZWUsXG4gICAgICApO1xuICAgICAgaWYgKCFwcmltYXJ5S2V5cmluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFtYXNrQ29udHJvbGxlciAtIE5vIEhEIEtleSBUcmVlIGZvdW5kJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNlZWsgb3V0IHRoZSBmaXJzdCB6ZXJvIGJhbGFuY2VcbiAgICAgIHdoaWxlIChsYXN0QmFsYW5jZSAhPT0gJzB4MCcpIHtcbiAgICAgICAgYXdhaXQga2V5cmluZ0NvbnRyb2xsZXIuYWRkTmV3QWNjb3VudChwcmltYXJ5S2V5cmluZyk7XG4gICAgICAgIGFjY291bnRzID0gYXdhaXQga2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMoKTtcbiAgICAgICAgbGFzdEJhbGFuY2UgPSBhd2FpdCB0aGlzLmdldEJhbGFuY2UoXG4gICAgICAgICAgYWNjb3VudHNbYWNjb3VudHMubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgZXRoUXVlcnksXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlbW92ZSBleHRyYSB6ZXJvIGJhbGFuY2UgYWNjb3VudCBwb3RlbnRpYWxseSBjcmVhdGVkIGZyb20gc2Vla2luZyBhaGVhZFxuICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA+IDEgJiYgbGFzdEJhbGFuY2UgPT09ICcweDAnKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVtb3ZlQWNjb3VudChhY2NvdW50c1thY2NvdW50cy5sZW5ndGggLSAxXSk7XG4gICAgICAgIGFjY291bnRzID0gYXdhaXQga2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMoKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBtdXN0IGJlIHNldCBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIGNvbW11bmljYXRlIHRvIHRoZVxuICAgICAgLy8ga2V5cmluZydzIGlmcmFtZSBhbmQgaGF2ZSB0aGUgc2V0dGluZyBpbml0aWFsaXplZCBwcm9wZXJseVxuICAgICAgLy8gT3B0aW1pc3RpY2FsbHkgY2FsbGVkIHRvIG5vdCBibG9jayBNZXRhTWFzayBsb2dpbiBkdWUgdG9cbiAgICAgIC8vIExlZGdlciBLZXlyaW5nIEdpdEh1YiBkb3dudGltZVxuICAgICAgY29uc3QgdHJhbnNwb3J0UHJlZmVyZW5jZSA9XG4gICAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLmdldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UoKTtcbiAgICAgIHRoaXMuc2V0TGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZSh0cmFuc3BvcnRQcmVmZXJlbmNlKTtcblxuICAgICAgLy8gc2V0IG5ldyBpZGVudGl0aWVzXG4gICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRBZGRyZXNzZXMoYWNjb3VudHMpO1xuICAgICAgdGhpcy5zZWxlY3RGaXJzdElkZW50aXR5KCk7XG4gICAgICByZXR1cm4gdmF1bHQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBhY2NvdW50IGJhbGFuY2UgZnJvbSB0aGUgQWNjb3VudFRyYWNrZXIgb3IgcmVxdWVzdCBpdCBkaXJlY3RseSBmcm9tIHRoZSBuZXR3b3JrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBhY2NvdW50IGFkZHJlc3NcbiAgICogQHBhcmFtIHtFdGhRdWVyeX0gZXRoUXVlcnkgLSBUaGUgRXRoUXVlcnkgaW5zdGFuY2UgdG8gdXNlIHdoZW4gYXNraW5nIHRoZSBuZXR3b3JrXG4gICAqL1xuICBnZXRCYWxhbmNlKGFkZHJlc3MsIGV0aFF1ZXJ5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuYWNjb3VudFRyYWNrZXIuc3RvcmUuZ2V0U3RhdGUoKS5hY2NvdW50c1thZGRyZXNzXTtcblxuICAgICAgaWYgKGNhY2hlZCAmJiBjYWNoZWQuYmFsYW5jZSkge1xuICAgICAgICByZXNvbHZlKGNhY2hlZC5iYWxhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV0aFF1ZXJ5LmdldEJhbGFuY2UoYWRkcmVzcywgKGVycm9yLCBiYWxhbmNlKSA9PiB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgbG9nLmVycm9yKGVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShiYWxhbmNlIHx8ICcweDAnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1Ym1pdHMgdGhlIHVzZXIncyBwYXNzd29yZCBhbmQgYXR0ZW1wdHMgdG8gdW5sb2NrIHRoZSB2YXVsdC5cbiAgICogQWxzbyBzeW5jaHJvbml6ZXMgdGhlIHByZWZlcmVuY2VzQ29udHJvbGxlciwgdG8gZW5zdXJlIGl0cyBzY2hlbWFcbiAgICogaXMgdXAgdG8gZGF0ZSB3aXRoIGtub3duIGFjY291bnRzIG9uY2UgdGhlIHZhdWx0IGlzIGRlY3J5cHRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIC0gVGhlIHVzZXIncyBwYXNzd29yZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBUaGUga2V5cmluZ0NvbnRyb2xsZXIgdXBkYXRlLlxuICAgKi9cbiAgYXN5bmMgc3VibWl0UGFzc3dvcmQocGFzc3dvcmQpIHtcbiAgICBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLnN1Ym1pdFBhc3N3b3JkKHBhc3N3b3JkKTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmJsb2NrVHJhY2tlci5jaGVja0ZvckxhdGVzdEJsb2NrKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcignRXJyb3Igd2hpbGUgdW5sb2NraW5nIGV4dGVuc2lvbi4nLCBlcnJvcik7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBtdXN0IGJlIHNldCBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIGNvbW11bmljYXRlIHRvIHRoZVxuICAgIC8vIGtleXJpbmcncyBpZnJhbWUgYW5kIGhhdmUgdGhlIHNldHRpbmcgaW5pdGlhbGl6ZWQgcHJvcGVybHlcbiAgICAvLyBPcHRpbWlzdGljYWxseSBjYWxsZWQgdG8gbm90IGJsb2NrIE1ldGFNYXNrIGxvZ2luIGR1ZSB0b1xuICAgIC8vIExlZGdlciBLZXlyaW5nIEdpdEh1YiBkb3dudGltZVxuICAgIGNvbnN0IHRyYW5zcG9ydFByZWZlcmVuY2UgPVxuICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuZ2V0TGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuXG4gICAgdGhpcy5zZXRMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlKHRyYW5zcG9ydFByZWZlcmVuY2UpO1xuXG4gICAgcmV0dXJuIHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZnVsbFVwZGF0ZSgpO1xuICB9XG5cbiAgYXN5bmMgX2xvZ2luVXNlcigpIHtcbiAgICB0cnkge1xuICAgICAgLy8gQXV0b21hdGljIGxvZ2luIHZpYSBjb25maWcgcGFzc3dvcmRcbiAgICAgIGNvbnN0IHBhc3N3b3JkID0gcHJvY2Vzcy5lbnYuUEFTU1dPUkQ7XG4gICAgICBpZiAocGFzc3dvcmQgJiYgIXByb2Nlc3MuZW52LklOX1RFU1QpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zdWJtaXRQYXNzd29yZChwYXNzd29yZCk7XG4gICAgICB9XG4gICAgICAvLyBBdXRvbWF0aWMgbG9naW4gdmlhIHN0b3JhZ2UgZW5jcnlwdGlvbiBrZXlcbiAgICAgIGVsc2UgaWYgKGlzTWFuaWZlc3RWMykge1xuICAgICAgICBhd2FpdCB0aGlzLnN1Ym1pdEVuY3J5cHRpb25LZXkoKTtcbiAgICAgIH1cbiAgICAgIC8vIFVwZGF0aW5nIGFjY291bnRzIGluIHRoaXMuYWNjb3VudFRyYWNrZXIgYmVmb3JlIHN0YXJ0aW5nIFVJIHN5bmNpbmcgZW5zdXJlIHRoYXRcbiAgICAgIC8vIHN0YXRlIGhhcyBhY2NvdW50IGJhbGFuY2UgYmVmb3JlIGl0IGlzIHN5bmNlZCB3aXRoIFVJXG4gICAgICBhd2FpdCB0aGlzLmFjY291bnRUcmFja2VyLl91cGRhdGVBY2NvdW50cygpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9zdGFydFVJU3luYygpO1xuICAgIH1cbiAgfVxuXG4gIF9zdGFydFVJU3luYygpIHtcbiAgICAvLyBNZXNzYWdlIHN0YXJ0VUlTeW5jIGlzIHVzZWQgaW4gTVYzIHRvIHN0YXJ0IHN5bmNpbmcgc3RhdGUgd2l0aCBVSVxuICAgIC8vIFNlbmRpbmcgdGhpcyBtZXNzYWdlIGFmdGVyIGxvZ2luIGlzIGNvbXBsZXRlZCBoZWxwcyB0byBlbnN1cmUgdGhhdCBpbmNvbXBsZXRlIHN0YXRlIHdpdGhvdXRcbiAgICAvLyBhY2NvdW50IGRldGFpbHMgYXJlIG5vdCBmbHVzaGVkIHRvIFVJLlxuICAgIHRoaXMuZW1pdCgnc3RhcnRVSVN5bmMnKTtcbiAgICB0aGlzLnN0YXJ0VUlTeW5jID0gdHJ1ZTtcbiAgICB0aGlzLm1lbVN0b3JlLnN1YnNjcmliZSh0aGlzLnNlbmRVcGRhdGUuYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogU3VibWl0cyBhIHVzZXIncyBlbmNyeXB0aW9uIGtleSB0byBsb2cgdGhlIHVzZXIgaW4gdmlhIGxvZ2luIHRva2VuXG4gICAqL1xuICBhc3luYyBzdWJtaXRFbmNyeXB0aW9uS2V5KCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGxvZ2luVG9rZW4sIGxvZ2luU2FsdCB9ID1cbiAgICAgICAgYXdhaXQgdGhpcy5leHRlbnNpb24uc3RvcmFnZS5zZXNzaW9uLmdldChbJ2xvZ2luVG9rZW4nLCAnbG9naW5TYWx0J10pO1xuICAgICAgaWYgKGxvZ2luVG9rZW4gJiYgbG9naW5TYWx0KSB7XG4gICAgICAgIGNvbnN0IHsgdmF1bHQgfSA9IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgICBjb25zdCBqc29uVmF1bHQgPSBKU09OLnBhcnNlKHZhdWx0KTtcblxuICAgICAgICBpZiAoanNvblZhdWx0LnNhbHQgIT09IGxvZ2luU2FsdCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdzdWJtaXRFbmNyeXB0aW9uS2V5OiBTdG9yZWQgc2FsdCBhbmQgdmF1bHQgc2FsdCBkbyBub3QgbWF0Y2gnLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYXdhaXQgdGhpcy5jbGVhckxvZ2luQXJ0aWZhY3RzKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5zdWJtaXRFbmNyeXB0aW9uS2V5KGxvZ2luVG9rZW4sIGxvZ2luU2FsdCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSWYgc29tZWhvdyB0aGlzIGxvZ2luIHRva2VuIGRvZXNuJ3Qgd29yayBwcm9wZXJseSxcbiAgICAgIC8vIHJlbW92ZSBpdCBhbmQgdGhlIHVzZXIgd2lsbCBnZXQgc2hvd24gYmFjayB0byB0aGUgdW5sb2NrIHNjcmVlblxuICAgICAgYXdhaXQgdGhpcy5jbGVhckxvZ2luQXJ0aWZhY3RzKCk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNsZWFyTG9naW5BcnRpZmFjdHMoKSB7XG4gICAgYXdhaXQgdGhpcy5leHRlbnNpb24uc3RvcmFnZS5zZXNzaW9uLnJlbW92ZShbJ2xvZ2luVG9rZW4nLCAnbG9naW5TYWx0J10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1Ym1pdHMgYSB1c2VyJ3MgcGFzc3dvcmQgdG8gY2hlY2sgaXRzIHZhbGlkaXR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBUaGUgdXNlcidzIHBhc3N3b3JkXG4gICAqL1xuICBhc3luYyB2ZXJpZnlQYXNzd29yZChwYXNzd29yZCkge1xuICAgIGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIudmVyaWZ5UGFzc3dvcmQocGFzc3dvcmQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIElkZW50aXR5XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGFjY291bnQgbmlja25hbWUuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGFjY291bnQncyBldGhlcmV1bSBhZGRyZXNzLCBpbiBsb3dlciBjYXNlLlxuICAgKiByZWNlaXZpbmcgZnVuZHMgZnJvbSBvdXIgYXV0b21hdGljIFJvcHN0ZW4gZmF1Y2V0LlxuICAgKi9cblxuICAvKipcbiAgICogU2V0cyB0aGUgZmlyc3QgYWRkcmVzcyBpbiB0aGUgc3RhdGUgdG8gdGhlIHNlbGVjdGVkIGFkZHJlc3NcbiAgICovXG4gIHNlbGVjdEZpcnN0SWRlbnRpdHkoKSB7XG4gICAgY29uc3QgeyBpZGVudGl0aWVzIH0gPSB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IFthZGRyZXNzXSA9IE9iamVjdC5rZXlzKGlkZW50aXRpZXMpO1xuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFNlbGVjdGVkQWRkcmVzcyhhZGRyZXNzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBtbmVtb25pYyBvZiB0aGUgdXNlcidzIHByaW1hcnkga2V5cmluZy5cbiAgICovXG4gIGdldFByaW1hcnlLZXlyaW5nTW5lbW9uaWMoKSB7XG4gICAgY29uc3QgW2tleXJpbmddID0gdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRLZXlyaW5nc0J5VHlwZShcbiAgICAgIEtleXJpbmdUeXBlLmhkS2V5VHJlZSxcbiAgICApO1xuICAgIGlmICgha2V5cmluZy5tbmVtb25pYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcmltYXJ5IGtleXJpbmcgbW5lbW9uaWMgdW5hdmFpbGFibGUuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXJpbmcubW5lbW9uaWM7XG4gIH1cblxuICAvL1xuICAvLyBIYXJkd2FyZVxuICAvL1xuXG4gIGFzeW5jIGdldEtleXJpbmdGb3JEZXZpY2UoZGV2aWNlTmFtZSwgaGRQYXRoID0gbnVsbCkge1xuICAgIGNvbnN0IGtleXJpbmdPdmVycmlkZXMgPSB0aGlzLm9wdHMub3ZlcnJpZGVzPy5rZXlyaW5ncztcbiAgICBsZXQga2V5cmluZ05hbWUgPSBudWxsO1xuICAgIGlmIChcbiAgICAgIGRldmljZU5hbWUgIT09IEhhcmR3YXJlRGV2aWNlTmFtZXMuUVIgJiZcbiAgICAgICF0aGlzLmNhblVzZUhhcmR3YXJlV2FsbGV0cygpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhcmR3YXJlIHdhbGxldHMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyB2ZXJzaW9uLicpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRldmljZU5hbWUpIHtcbiAgICAgIGNhc2UgSGFyZHdhcmVEZXZpY2VOYW1lcy50cmV6b3I6XG4gICAgICAgIGtleXJpbmdOYW1lID0ga2V5cmluZ092ZXJyaWRlcz8udHJlem9yPy50eXBlIHx8IFRyZXpvcktleXJpbmcudHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhhcmR3YXJlRGV2aWNlTmFtZXMubGVkZ2VyOlxuICAgICAgICBrZXlyaW5nTmFtZSA9XG4gICAgICAgICAga2V5cmluZ092ZXJyaWRlcz8ubGVkZ2VyPy50eXBlIHx8IExlZGdlckJyaWRnZUtleXJpbmcudHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhhcmR3YXJlRGV2aWNlTmFtZXMucXI6XG4gICAgICAgIGtleXJpbmdOYW1lID0gUVJIYXJkd2FyZUtleXJpbmcudHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhhcmR3YXJlRGV2aWNlTmFtZXMubGF0dGljZTpcbiAgICAgICAga2V5cmluZ05hbWUgPSBrZXlyaW5nT3ZlcnJpZGVzPy5sYXR0aWNlPy50eXBlIHx8IExhdHRpY2VLZXlyaW5nLnR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdNZXRhbWFza0NvbnRyb2xsZXI6Z2V0S2V5cmluZ0ZvckRldmljZSAtIFVua25vd24gZGV2aWNlJyxcbiAgICAgICAgKTtcbiAgICB9XG4gICAgbGV0IFtrZXlyaW5nXSA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ3NCeVR5cGUoa2V5cmluZ05hbWUpO1xuICAgIGlmICgha2V5cmluZykge1xuICAgICAga2V5cmluZyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuYWRkTmV3S2V5cmluZyhrZXlyaW5nTmFtZSk7XG4gICAgfVxuICAgIGlmIChoZFBhdGggJiYga2V5cmluZy5zZXRIZFBhdGgpIHtcbiAgICAgIGtleXJpbmcuc2V0SGRQYXRoKGhkUGF0aCk7XG4gICAgfVxuICAgIGlmIChkZXZpY2VOYW1lID09PSBIYXJkd2FyZURldmljZU5hbWVzLmxhdHRpY2UpIHtcbiAgICAgIGtleXJpbmcuYXBwTmFtZSA9ICdNZXRhTWFzayc7XG4gICAgfVxuICAgIGlmIChkZXZpY2VOYW1lID09PSBIYXJkd2FyZURldmljZU5hbWVzLnRyZXpvcikge1xuICAgICAgY29uc3QgbW9kZWwgPSBrZXlyaW5nLmdldE1vZGVsKCk7XG4gICAgICB0aGlzLmFwcFN0YXRlQ29udHJvbGxlci5zZXRUcmV6b3JNb2RlbChtb2RlbCk7XG4gICAgfVxuXG4gICAga2V5cmluZy5uZXR3b3JrID1cbiAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5wcm92aWRlckNvbmZpZy50eXBlO1xuXG4gICAgcmV0dXJuIGtleXJpbmc7XG4gIH1cblxuICBhc3luYyBhdHRlbXB0TGVkZ2VyVHJhbnNwb3J0Q3JlYXRpb24oKSB7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuZ2V0S2V5cmluZ0ZvckRldmljZShIYXJkd2FyZURldmljZU5hbWVzLmxlZGdlcik7XG4gICAgcmV0dXJuIGF3YWl0IGtleXJpbmcuYXR0ZW1wdE1ha2VBcHAoKTtcbiAgfVxuXG4gIGFzeW5jIGVzdGFibGlzaExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UoKSB7XG4gICAgY29uc3QgdHJhbnNwb3J0UHJlZmVyZW5jZSA9XG4gICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5nZXRMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2V0TGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZSh0cmFuc3BvcnRQcmVmZXJlbmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhY2NvdW50IGxpc3QgZnJvbSBhIHRyZXpvciBkZXZpY2UuXG4gICAqXG4gICAqIEBwYXJhbSBkZXZpY2VOYW1lXG4gICAqIEBwYXJhbSBwYWdlXG4gICAqIEBwYXJhbSBoZFBhdGhcbiAgICogQHJldHVybnMgW10gYWNjb3VudHNcbiAgICovXG4gIGFzeW5jIGNvbm5lY3RIYXJkd2FyZShkZXZpY2VOYW1lLCBwYWdlLCBoZFBhdGgpIHtcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5nZXRLZXlyaW5nRm9yRGV2aWNlKGRldmljZU5hbWUsIGhkUGF0aCk7XG4gICAgbGV0IGFjY291bnRzID0gW107XG4gICAgc3dpdGNoIChwYWdlKSB7XG4gICAgICBjYXNlIC0xOlxuICAgICAgICBhY2NvdW50cyA9IGF3YWl0IGtleXJpbmcuZ2V0UHJldmlvdXNQYWdlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBhY2NvdW50cyA9IGF3YWl0IGtleXJpbmcuZ2V0TmV4dFBhZ2UoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhY2NvdW50cyA9IGF3YWl0IGtleXJpbmcuZ2V0Rmlyc3RQYWdlKCk7XG4gICAgfVxuXG4gICAgLy8gTWVyZ2Ugd2l0aCBleGlzdGluZyBhY2NvdW50c1xuICAgIC8vIGFuZCBtYWtlIHN1cmUgYWRkcmVzc2VzIGFyZSBub3QgcmVwZWF0ZWRcbiAgICBjb25zdCBvbGRBY2NvdW50cyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMoKTtcbiAgICBjb25zdCBhY2NvdW50c1RvVHJhY2sgPSBbXG4gICAgICAuLi5uZXcgU2V0KFxuICAgICAgICBvbGRBY2NvdW50cy5jb25jYXQoYWNjb3VudHMubWFwKChhKSA9PiBhLmFkZHJlc3MudG9Mb3dlckNhc2UoKSkpLFxuICAgICAgKSxcbiAgICBdO1xuICAgIHRoaXMuYWNjb3VudFRyYWNrZXIuc3luY1dpdGhBZGRyZXNzZXMoYWNjb3VudHNUb1RyYWNrKTtcbiAgICByZXR1cm4gYWNjb3VudHM7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGRldmljZSBpcyB1bmxvY2tlZFxuICAgKlxuICAgKiBAcGFyYW0gZGV2aWNlTmFtZVxuICAgKiBAcGFyYW0gaGRQYXRoXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgKi9cbiAgYXN5bmMgY2hlY2tIYXJkd2FyZVN0YXR1cyhkZXZpY2VOYW1lLCBoZFBhdGgpIHtcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5nZXRLZXlyaW5nRm9yRGV2aWNlKGRldmljZU5hbWUsIGhkUGF0aCk7XG4gICAgcmV0dXJuIGtleXJpbmcuaXNVbmxvY2tlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyXG4gICAqXG4gICAqIEBwYXJhbSBkZXZpY2VOYW1lXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgKi9cbiAgYXN5bmMgZm9yZ2V0RGV2aWNlKGRldmljZU5hbWUpIHtcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5nZXRLZXlyaW5nRm9yRGV2aWNlKGRldmljZU5hbWUpO1xuICAgIGtleXJpbmcuZm9yZ2V0RGV2aWNlKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBrZXlyaW5nIGZvciB0aGUgc2VsZWN0ZWQgYWRkcmVzcyBhbmQgdXNpbmcgdGhlIC50eXBlIHJldHVybnNcbiAgICogYSBzdWJ0eXBlIGZvciB0aGUgYWNjb3VudC4gRWl0aGVyICdoYXJkd2FyZScsICdpbXBvcnRlZCcgb3IgJ01ldGFNYXNrJy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBBZGRyZXNzIHRvIHJldHJpZXZlIGtleXJpbmcgZm9yXG4gICAqIEByZXR1cm5zIHsnaGFyZHdhcmUnIHwgJ2ltcG9ydGVkJyB8ICdNZXRhTWFzayd9XG4gICAqL1xuICBhc3luYyBnZXRBY2NvdW50VHlwZShhZGRyZXNzKSB7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ0ZvckFjY291bnQoYWRkcmVzcyk7XG4gICAgc3dpdGNoIChrZXlyaW5nLnR5cGUpIHtcbiAgICAgIGNhc2UgS2V5cmluZ1R5cGUudHJlem9yOlxuICAgICAgY2FzZSBLZXlyaW5nVHlwZS5sYXR0aWNlOlxuICAgICAgY2FzZSBLZXlyaW5nVHlwZS5xcjpcbiAgICAgIGNhc2UgS2V5cmluZ1R5cGUubGVkZ2VyOlxuICAgICAgICByZXR1cm4gJ2hhcmR3YXJlJztcbiAgICAgIGNhc2UgS2V5cmluZ1R5cGUuaW1wb3J0ZWQ6XG4gICAgICAgIHJldHVybiAnaW1wb3J0ZWQnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICdNZXRhTWFzayc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUga2V5cmluZyBmb3IgdGhlIHNlbGVjdGVkIGFkZHJlc3MgYW5kIHVzaW5nIHRoZSAudHlwZVxuICAgKiBkZXRlcm1pbmVzIGlmIGEgbW9yZSBzcGVjaWZpYyBuYW1lIGZvciB0aGUgZGV2aWNlIGlzIGF2YWlsYWJsZS4gUmV0dXJuc1xuICAgKiAnTi9BJyBmb3Igbm9uIGhhcmR3YXJlIHdhbGxldHMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gQWRkcmVzcyB0byByZXRyaWV2ZSBrZXlyaW5nIGZvclxuICAgKiBAcmV0dXJucyB7J2xlZGdlcicgfCAnbGF0dGljZScgfCAnTi9BJyB8IHN0cmluZ31cbiAgICovXG4gIGFzeW5jIGdldERldmljZU1vZGVsKGFkZHJlc3MpIHtcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRLZXlyaW5nRm9yQWNjb3VudChhZGRyZXNzKTtcbiAgICBzd2l0Y2ggKGtleXJpbmcudHlwZSkge1xuICAgICAgY2FzZSBLZXlyaW5nVHlwZS50cmV6b3I6XG4gICAgICAgIHJldHVybiBrZXlyaW5nLmdldE1vZGVsKCk7XG4gICAgICBjYXNlIEtleXJpbmdUeXBlLnFyOlxuICAgICAgICByZXR1cm4ga2V5cmluZy5nZXROYW1lKCk7XG4gICAgICBjYXNlIEtleXJpbmdUeXBlLmxlZGdlcjpcbiAgICAgICAgLy8gVE9ETzogZ2V0IG1vZGVsIGFmdGVyIGxlZGdlciBrZXlyaW5nIGV4cG9zZXMgbWV0aG9kXG4gICAgICAgIHJldHVybiBIYXJkd2FyZURldmljZU5hbWVzLmxlZGdlcjtcbiAgICAgIGNhc2UgS2V5cmluZ1R5cGUubGF0dGljZTpcbiAgICAgICAgLy8gVE9ETzogZ2V0IG1vZGVsIGFmdGVyIGxhdHRpY2Uga2V5cmluZyBleHBvc2VzIG1ldGhvZFxuICAgICAgICByZXR1cm4gSGFyZHdhcmVEZXZpY2VOYW1lcy5sYXR0aWNlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICdOL0EnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgaGFyZHdhcmUgYWNjb3VudCBsYWJlbFxuICAgKlxuICAgKiBAcmV0dXJucyBzdHJpbmcgbGFiZWxcbiAgICovXG5cbiAgZ2V0QWNjb3VudExhYmVsKG5hbWUsIGluZGV4LCBoZFBhdGhEZXNjcmlwdGlvbikge1xuICAgIHJldHVybiBgJHtuYW1lWzBdLnRvVXBwZXJDYXNlKCl9JHtuYW1lLnNsaWNlKDEpfSAke1xuICAgICAgcGFyc2VJbnQoaW5kZXgsIDEwKSArIDFcbiAgICB9ICR7aGRQYXRoRGVzY3JpcHRpb24gfHwgJyd9YC50cmltKCk7XG4gIH1cblxuICAvKipcbiAgICogSW1wb3J0cyBhbiBhY2NvdW50IGZyb20gYSBUcmV6b3Igb3IgTGVkZ2VyIGRldmljZS5cbiAgICpcbiAgICogQHBhcmFtIGluZGV4XG4gICAqIEBwYXJhbSBkZXZpY2VOYW1lXG4gICAqIEBwYXJhbSBoZFBhdGhcbiAgICogQHBhcmFtIGhkUGF0aERlc2NyaXB0aW9uXG4gICAqIEByZXR1cm5zIHt9IGtleVN0YXRlXG4gICAqL1xuICBhc3luYyB1bmxvY2tIYXJkd2FyZVdhbGxldEFjY291bnQoXG4gICAgaW5kZXgsXG4gICAgZGV2aWNlTmFtZSxcbiAgICBoZFBhdGgsXG4gICAgaGRQYXRoRGVzY3JpcHRpb24sXG4gICkge1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmdldEtleXJpbmdGb3JEZXZpY2UoZGV2aWNlTmFtZSwgaGRQYXRoKTtcblxuICAgIGtleXJpbmcuc2V0QWNjb3VudFRvVW5sb2NrKGluZGV4KTtcbiAgICBjb25zdCBvbGRBY2NvdW50cyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMoKTtcbiAgICBjb25zdCBrZXlTdGF0ZSA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuYWRkTmV3QWNjb3VudChrZXlyaW5nKTtcbiAgICBjb25zdCBuZXdBY2NvdW50cyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMoKTtcbiAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRBZGRyZXNzZXMobmV3QWNjb3VudHMpO1xuICAgIG5ld0FjY291bnRzLmZvckVhY2goKGFkZHJlc3MpID0+IHtcbiAgICAgIGlmICghb2xkQWNjb3VudHMuaW5jbHVkZXMoYWRkcmVzcykpIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldEFjY291bnRMYWJlbChcbiAgICAgICAgICBkZXZpY2VOYW1lID09PSBIYXJkd2FyZURldmljZU5hbWVzLnFyXG4gICAgICAgICAgICA/IGtleXJpbmcuZ2V0TmFtZSgpXG4gICAgICAgICAgICA6IGRldmljZU5hbWUsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgaGRQYXRoRGVzY3JpcHRpb24sXG4gICAgICAgICk7XG4gICAgICAgIC8vIFNldCB0aGUgYWNjb3VudCBsYWJlbCB0byBUcmV6b3IgMSAvICBMZWRnZXIgMSAvIFFSIEhhcmR3YXJlIDEsIGV0Y1xuICAgICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRBY2NvdW50TGFiZWwoYWRkcmVzcywgbGFiZWwpO1xuICAgICAgICAvLyBTZWxlY3QgdGhlIGFjY291bnRcbiAgICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0U2VsZWN0ZWRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyBpZGVudGl0aWVzIH0gPSB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHJldHVybiB7IC4uLmtleVN0YXRlLCBpZGVudGl0aWVzIH07XG4gIH1cblxuICAvL1xuICAvLyBBY2NvdW50IE1hbmFnZW1lbnRcbiAgLy9cblxuICAvKipcbiAgICogQWRkcyBhIG5ldyBhY2NvdW50IHRvIHRoZSBkZWZhdWx0IChmaXJzdCkgSEQgc2VlZCBwaHJhc2UgS2V5cmluZy5cbiAgICpcbiAgICogQHBhcmFtIGFjY291bnRDb3VudFxuICAgKiBAcmV0dXJucyB7fSBrZXlTdGF0ZVxuICAgKi9cbiAgYXN5bmMgYWRkTmV3QWNjb3VudChhY2NvdW50Q291bnQpIHtcbiAgICBjb25zdCBpc0FjdGlvbk1ldHJpY3NRdWV1ZUUyRVRlc3QgPVxuICAgICAgdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKVtBQ1RJT05fUVVFVUVfTUVUUklDU19FMkVfVEVTVF07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuSU5fVEVTVCAmJiBpc0FjdGlvbk1ldHJpY3NRdWV1ZUUyRVRlc3QpIHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDVfMDAwKSk7XG4gICAgfVxuXG4gICAgY29uc3QgW3ByaW1hcnlLZXlyaW5nXSA9IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ3NCeVR5cGUoXG4gICAgICBLZXlyaW5nVHlwZS5oZEtleVRyZWUsXG4gICAgKTtcbiAgICBpZiAoIXByaW1hcnlLZXlyaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFtYXNrQ29udHJvbGxlciAtIE5vIEhEIEtleSBUcmVlIGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IHsga2V5cmluZ0NvbnRyb2xsZXIgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBpZGVudGl0aWVzOiBvbGRJZGVudGl0aWVzIH0gPVxuICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgIGlmIChPYmplY3Qua2V5cyhvbGRJZGVudGl0aWVzKS5sZW5ndGggPT09IGFjY291bnRDb3VudCkge1xuICAgICAgY29uc3Qgb2xkQWNjb3VudHMgPSBhd2FpdCBrZXlyaW5nQ29udHJvbGxlci5nZXRBY2NvdW50cygpO1xuICAgICAgY29uc3Qga2V5U3RhdGUgPSBhd2FpdCBrZXlyaW5nQ29udHJvbGxlci5hZGROZXdBY2NvdW50KHByaW1hcnlLZXlyaW5nKTtcbiAgICAgIGNvbnN0IG5ld0FjY291bnRzID0gYXdhaXQga2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMoKTtcblxuICAgICAgYXdhaXQgdGhpcy52ZXJpZnlTZWVkUGhyYXNlKCk7XG5cbiAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnNldEFkZHJlc3NlcyhuZXdBY2NvdW50cyk7XG4gICAgICBuZXdBY2NvdW50cy5mb3JFYWNoKChhZGRyZXNzKSA9PiB7XG4gICAgICAgIGlmICghb2xkQWNjb3VudHMuaW5jbHVkZXMoYWRkcmVzcykpIHtcbiAgICAgICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRTZWxlY3RlZEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7IGlkZW50aXRpZXMgfSA9IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICByZXR1cm4geyAuLi5rZXlTdGF0ZSwgaWRlbnRpdGllcyB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi5rZXlyaW5nQ29udHJvbGxlci5tZW1TdG9yZS5nZXRTdGF0ZSgpLFxuICAgICAgaWRlbnRpdGllczogb2xkSWRlbnRpdGllcyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIHRoZSB2YWxpZGl0eSBvZiB0aGUgY3VycmVudCB2YXVsdCdzIHNlZWQgcGhyYXNlLlxuICAgKlxuICAgKiBWYWxpZGl0eTogc2VlZCBwaHJhc2UgcmVzdG9yZXMgdGhlIGFjY291bnRzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCB2YXVsdC5cbiAgICpcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGZpcnN0IGFjY291bnQgaXMgY3JlYXRlZCBhbmQgb24gdW5sb2NraW5nIHRoZSB2YXVsdC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyW10+fSBUaGUgc2VlZCBwaHJhc2UgdG8gYmUgY29uZmlybWVkIGJ5IHRoZSB1c2VyLFxuICAgKiBlbmNvZGVkIGFzIGFuIGFycmF5IG9mIFVURi04IGJ5dGVzLlxuICAgKi9cbiAgYXN5bmMgdmVyaWZ5U2VlZFBocmFzZSgpIHtcbiAgICBjb25zdCBbcHJpbWFyeUtleXJpbmddID0gdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRLZXlyaW5nc0J5VHlwZShcbiAgICAgIEtleXJpbmdUeXBlLmhkS2V5VHJlZSxcbiAgICApO1xuICAgIGlmICghcHJpbWFyeUtleXJpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWV0YW1hc2tDb250cm9sbGVyIC0gTm8gSEQgS2V5IFRyZWUgZm91bmQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZXJpYWxpemVkID0gYXdhaXQgcHJpbWFyeUtleXJpbmcuc2VyaWFsaXplKCk7XG4gICAgY29uc3Qgc2VlZFBocmFzZUFzQnVmZmVyID0gQnVmZmVyLmZyb20oc2VyaWFsaXplZC5tbmVtb25pYyk7XG5cbiAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHByaW1hcnlLZXlyaW5nLmdldEFjY291bnRzKCk7XG4gICAgaWYgKGFjY291bnRzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWV0YW1hc2tDb250cm9sbGVyIC0gTm8gYWNjb3VudHMgZm91bmQnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgc2VlZFBocmFzZVZlcmlmaWVyLnZlcmlmeUFjY291bnRzKGFjY291bnRzLCBzZWVkUGhyYXNlQXNCdWZmZXIpO1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20oc2VlZFBocmFzZUFzQnVmZmVyLnZhbHVlcygpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy5lcnJvcihlcnIubWVzc2FnZSk7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgdHJhbnNhY3Rpb24gaGlzdG9yeSwgdG8gYWxsb3cgdXNlcnMgdG8gZm9yY2UtcmVzZXQgdGhlaXIgbm9uY2VzLlxuICAgKiBNb3N0bHkgdXNlZCBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMsIHdoZW4gbmV0d29ya3MgYXJlIHJlc3RhcnRlZCB3aXRoXG4gICAqIHRoZSBzYW1lIG5ldHdvcmsgSUQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFRoZSBjdXJyZW50IHNlbGVjdGVkIGFkZHJlc3MuXG4gICAqL1xuICBhc3luYyByZXNldEFjY291bnQoKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRBZGRyZXNzID0gdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuZ2V0U2VsZWN0ZWRBZGRyZXNzKCk7XG4gICAgdGhpcy50eENvbnRyb2xsZXIud2lwZVRyYW5zYWN0aW9ucyhzZWxlY3RlZEFkZHJlc3MpO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIucmVzZXRDb25uZWN0aW9uKCk7XG5cbiAgICByZXR1cm4gc2VsZWN0ZWRBZGRyZXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHBlcm1pdHRlZCBhY2NvdW50cyBmb3IgdGhlIHNwZWNpZmllZCBvcmlnaW4uIFJldHVybnMgYW4gZW1wdHlcbiAgICogYXJyYXkgaWYgbm8gYWNjb3VudHMgYXJlIHBlcm1pdHRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBvcmlnaW4gd2hvc2UgZXhwb3NlZCBhY2NvdW50cyB0byByZXRyaWV2ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbc3VwcHJlc3NVbmF1dGhvcml6ZWRFcnJvcl0gLSBTdXBwcmVzc2VzIHRoZSB1bmF1dGhvcml6ZWQgZXJyb3IuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ1tdPn0gVGhlIG9yaWdpbidzIHBlcm1pdHRlZCBhY2NvdW50cywgb3IgYW4gZW1wdHlcbiAgICogYXJyYXkuXG4gICAqL1xuICBhc3luYyBnZXRQZXJtaXR0ZWRBY2NvdW50cyhcbiAgICBvcmlnaW4sXG4gICAgeyBzdXBwcmVzc1VuYXV0aG9yaXplZEVycm9yID0gdHJ1ZSB9ID0ge30sXG4gICkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlci5leGVjdXRlUmVzdHJpY3RlZE1ldGhvZChcbiAgICAgICAgb3JpZ2luLFxuICAgICAgICBSZXN0cmljdGVkTWV0aG9kcy5ldGhfYWNjb3VudHMsXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHN1cHByZXNzVW5hdXRob3JpemVkRXJyb3IgJiZcbiAgICAgICAgZXJyb3IuY29kZSA9PT0gcnBjRXJyb3JDb2Rlcy5wcm92aWRlci51bmF1dGhvcml6ZWRcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgZXhwb3NpbmcgdGhlIGFjY291bnQgd2l0aCB0aGUgc3BlY2lmaWVkIGFkZHJlc3MgdG8gYWxsIHRoaXJkIHBhcnRpZXMuXG4gICAqIEV4cG9zZWQgYWNjb3VudHMgYXJlIHN0b3JlZCBpbiBjYXZlYXRzIG9mIHRoZSBldGhfYWNjb3VudHMgcGVybWlzc2lvbi4gVGhpc1xuICAgKiBtZXRob2QgdXNlcyBgUGVybWlzc2lvbkNvbnRyb2xsZXIudXBkYXRlUGVybWlzc2lvbnNCeUNhdmVhdGAgdG9cbiAgICogcmVtb3ZlIHRoZSBzcGVjaWZpZWQgYWRkcmVzcyBmcm9tIGV2ZXJ5IGV0aF9hY2NvdW50cyBwZXJtaXNzaW9uLiBJZiBhXG4gICAqIHBlcm1pc3Npb24gb25seSBpbmNsdWRlZCB0aGlzIGFkZHJlc3MsIHRoZSBwZXJtaXNzaW9uIGlzIHJldm9rZWQgZW50aXJlbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRBY2NvdW50IC0gVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdG8gc3RvcCBleHBvc2luZ1xuICAgKiB0byB0aGlyZCBwYXJ0aWVzLlxuICAgKi9cbiAgcmVtb3ZlQWxsQWNjb3VudFBlcm1pc3Npb25zKHRhcmdldEFjY291bnQpIHtcbiAgICB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLnVwZGF0ZVBlcm1pc3Npb25zQnlDYXZlYXQoXG4gICAgICBDYXZlYXRUeXBlcy5yZXN0cmljdFJldHVybmVkQWNjb3VudHMsXG4gICAgICAoZXhpc3RpbmdBY2NvdW50cykgPT5cbiAgICAgICAgQ2F2ZWF0TXV0YXRvckZhY3Rvcmllc1tcbiAgICAgICAgICBDYXZlYXRUeXBlcy5yZXN0cmljdFJldHVybmVkQWNjb3VudHNcbiAgICAgICAgXS5yZW1vdmVBY2NvdW50KHRhcmdldEFjY291bnQsIGV4aXN0aW5nQWNjb3VudHMpLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhY2NvdW50IGZyb20gc3RhdGUgLyBzdG9yYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBhZGRyZXNzIC0gQSBoZXggYWRkcmVzc1xuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQWNjb3VudChhZGRyZXNzKSB7XG4gICAgLy8gUmVtb3ZlIGFsbCBhc3NvY2lhdGVkIHBlcm1pc3Npb25zXG4gICAgdGhpcy5yZW1vdmVBbGxBY2NvdW50UGVybWlzc2lvbnMoYWRkcmVzcyk7XG4gICAgLy8gUmVtb3ZlIGFjY291bnQgZnJvbSB0aGUgcHJlZmVyZW5jZXMgY29udHJvbGxlclxuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnJlbW92ZUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgLy8gUmVtb3ZlIGFjY291bnQgZnJvbSB0aGUgYWNjb3VudCB0cmFja2VyIGNvbnRyb2xsZXJcbiAgICB0aGlzLmFjY291bnRUcmFja2VyLnJlbW92ZUFjY291bnQoW2FkZHJlc3NdKTtcblxuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEtleXJpbmdGb3JBY2NvdW50KGFkZHJlc3MpO1xuICAgIC8vIFJlbW92ZSBhY2NvdW50IGZyb20gdGhlIGtleXJpbmdcbiAgICBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLnJlbW92ZUFjY291bnQoYWRkcmVzcyk7XG4gICAgY29uc3QgdXBkYXRlZEtleXJpbmdBY2NvdW50cyA9IGtleXJpbmcgPyBhd2FpdCBrZXlyaW5nLmdldEFjY291bnRzKCkgOiB7fTtcbiAgICBpZiAodXBkYXRlZEtleXJpbmdBY2NvdW50cz8ubGVuZ3RoID09PSAwKSB7XG4gICAgICBrZXlyaW5nLmRlc3Ryb3k/LigpO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRyZXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcG9ydHMgYW4gYWNjb3VudCB3aXRoIHRoZSBzcGVjaWZpZWQgaW1wb3J0IHN0cmF0ZWd5LlxuICAgKiBUaGVzZSBhcmUgZGVmaW5lZCBpbiBhcHAvc2NyaXB0cy9hY2NvdW50LWltcG9ydC1zdHJhdGVnaWVzXG4gICAqIEVhY2ggc3RyYXRlZ3kgcmVwcmVzZW50cyBhIGRpZmZlcmVudCB3YXkgb2Ygc2VyaWFsaXppbmcgYW4gRXRoZXJldW0ga2V5IHBhaXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJhdGVneSAtIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIGFuIGFjY291bnQgaW1wb3J0IHN0cmF0ZWd5LlxuICAgKiBAcGFyYW0ge2FueX0gYXJncyAtIFRoZSBkYXRhIHJlcXVpcmVkIGJ5IHRoYXQgc3RyYXRlZ3kgdG8gaW1wb3J0IGFuIGFjY291bnQuXG4gICAqL1xuICBhc3luYyBpbXBvcnRBY2NvdW50V2l0aFN0cmF0ZWd5KHN0cmF0ZWd5LCBhcmdzKSB7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IGF3YWl0IGFjY291bnRJbXBvcnRlci5pbXBvcnRBY2NvdW50KHN0cmF0ZWd5LCBhcmdzKTtcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5hZGROZXdLZXlyaW5nKFxuICAgICAgS2V5cmluZ1R5cGUuaW1wb3J0ZWQsXG4gICAgICBbcHJpdmF0ZUtleV0sXG4gICAgKTtcbiAgICBjb25zdCBbZmlyc3RBY2NvdW50XSA9IGF3YWl0IGtleXJpbmcuZ2V0QWNjb3VudHMoKTtcbiAgICAvLyB1cGRhdGUgYWNjb3VudHMgaW4gcHJlZmVyZW5jZXMgY29udHJvbGxlclxuICAgIGNvbnN0IGFsbEFjY291bnRzID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRBY2NvdW50cygpO1xuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnNldEFkZHJlc3NlcyhhbGxBY2NvdW50cyk7XG4gICAgLy8gc2V0IG5ldyBhY2NvdW50IGFzIHNlbGVjdGVkXG4gICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0U2VsZWN0ZWRBZGRyZXNzKGZpcnN0QWNjb3VudCk7XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gSWRlbnRpdHkgTWFuYWdlbWVudCAoc2lnbmF0dXJlIG9wZXJhdGlvbnMpXG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgRGFwcCBzdWdnZXN0cyBhIG5ldyB0eCB0byBiZSBzaWduZWQuXG4gICAqIHRoaXMgd3JhcHBlciBuZWVkcyB0byBleGlzdCBzbyB3ZSBjYW4gcHJvdmlkZSBhIHJlZmVyZW5jZSB0b1xuICAgKiAgXCJuZXdVbmFwcHJvdmVkVHJhbnNhY3Rpb25cIiBiZWZvcmUgXCJ0eENvbnRyb2xsZXJcIiBpcyBpbnN0YW50aWF0ZWRcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHR4UGFyYW1zIC0gVGhlIHRyYW5zYWN0aW9uIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbcmVxXSAtIFRoZSBvcmlnaW5hbCByZXF1ZXN0LCBjb250YWluaW5nIHRoZSBvcmlnaW4uXG4gICAqL1xuICBhc3luYyBuZXdVbmFwcHJvdmVkVHJhbnNhY3Rpb24odHhQYXJhbXMsIHJlcSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnR4Q29udHJvbGxlci5uZXdVbmFwcHJvdmVkVHJhbnNhY3Rpb24odHhQYXJhbXMsIHJlcSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGtleXJpbmcgdHlwZSBzdXBwb3J0cyBFSVAtMTU1OVxuICAgKi9cbiAgYXN5bmMgZ2V0Q3VycmVudEFjY291bnRFSVAxNTU5Q29tcGF0aWJpbGl0eSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRU5EIChWQVVMVCAvIEtFWVJJTkcgUkVMQVRFRCBNRVRIT0RTKVxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLyoqXG4gICAqIEFsbG93cyBhIHVzZXIgdG8gYXR0ZW1wdCB0byBjYW5jZWwgYSBwcmV2aW91c2x5IHN1Ym1pdHRlZCB0cmFuc2FjdGlvblxuICAgKiBieSBjcmVhdGluZyBhIG5ldyB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9yaWdpbmFsVHhJZCAtIHRoZSBpZCBvZiB0aGUgdHhNZXRhIHRoYXQgeW91IHdhbnQgdG9cbiAgICogIGF0dGVtcHQgdG8gY2FuY2VsXG4gICAqIEBwYXJhbSB7aW1wb3J0KFxuICAgKiAgJy4vY29udHJvbGxlcnMvdHJhbnNhY3Rpb25zJ1xuICAgKiApLkN1c3RvbUdhc1NldHRpbmdzfSBbY3VzdG9tR2FzU2V0dGluZ3NdIC0gb3ZlcnJpZGVzIHRvIHVzZSBmb3IgZ2FzIHBhcmFtc1xuICAgKiAgaW5zdGVhZCBvZiBhbGxvd2luZyB0aGlzIG1ldGhvZCB0byBnZW5lcmF0ZSB0aGVtXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IE1ldGFNYXNrIHN0YXRlXG4gICAqL1xuICBhc3luYyBjcmVhdGVDYW5jZWxUcmFuc2FjdGlvbihvcmlnaW5hbFR4SWQsIGN1c3RvbUdhc1NldHRpbmdzLCBvcHRpb25zKSB7XG4gICAgYXdhaXQgdGhpcy50eENvbnRyb2xsZXIuY3JlYXRlQ2FuY2VsVHJhbnNhY3Rpb24oXG4gICAgICBvcmlnaW5hbFR4SWQsXG4gICAgICBjdXN0b21HYXNTZXR0aW5ncyxcbiAgICAgIG9wdGlvbnMsXG4gICAgKTtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIGEgdXNlciB0byBhdHRlbXB0IHRvIHNwZWVkIHVwIGEgcHJldmlvdXNseSBzdWJtaXR0ZWQgdHJhbnNhY3Rpb25cbiAgICogYnkgY3JlYXRpbmcgYSBuZXcgdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW5hbFR4SWQgLSB0aGUgaWQgb2YgdGhlIHR4TWV0YSB0aGF0IHlvdSB3YW50IHRvXG4gICAqICBhdHRlbXB0IHRvIHNwZWVkIHVwXG4gICAqIEBwYXJhbSB7aW1wb3J0KFxuICAgKiAgJy4vY29udHJvbGxlcnMvdHJhbnNhY3Rpb25zJ1xuICAgKiApLkN1c3RvbUdhc1NldHRpbmdzfSBbY3VzdG9tR2FzU2V0dGluZ3NdIC0gb3ZlcnJpZGVzIHRvIHVzZSBmb3IgZ2FzIHBhcmFtc1xuICAgKiAgaW5zdGVhZCBvZiBhbGxvd2luZyB0aGlzIG1ldGhvZCB0byBnZW5lcmF0ZSB0aGVtXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IE1ldGFNYXNrIHN0YXRlXG4gICAqL1xuICBhc3luYyBjcmVhdGVTcGVlZFVwVHJhbnNhY3Rpb24ob3JpZ2luYWxUeElkLCBjdXN0b21HYXNTZXR0aW5ncywgb3B0aW9ucykge1xuICAgIGF3YWl0IHRoaXMudHhDb250cm9sbGVyLmNyZWF0ZVNwZWVkVXBUcmFuc2FjdGlvbihcbiAgICAgIG9yaWdpbmFsVHhJZCxcbiAgICAgIGN1c3RvbUdhc1NldHRpbmdzLFxuICAgICAgb3B0aW9ucyxcbiAgICApO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGVzdGltYXRlR2FzKGVzdGltYXRlR2FzUGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnR4Q29udHJvbGxlci50eEdhc1V0aWwucXVlcnkuZXN0aW1hdGVHYXMoXG4gICAgICAgIGVzdGltYXRlR2FzUGFyYW1zLFxuICAgICAgICAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQQVNTV09SRCBNQU5BR0VNRU5UXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAvKipcbiAgICogQWxsb3dzIGEgdXNlciB0byBiZWdpbiB0aGUgc2VlZCBwaHJhc2UgcmVjb3ZlcnkgcHJvY2Vzcy5cbiAgICovXG4gIG1hcmtQYXNzd29yZEZvcmdvdHRlbigpIHtcbiAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRQYXNzd29yZEZvcmdvdHRlbih0cnVlKTtcbiAgICB0aGlzLnNlbmRVcGRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvd3MgYSB1c2VyIHRvIGVuZCB0aGUgc2VlZCBwaHJhc2UgcmVjb3ZlcnkgcHJvY2Vzcy5cbiAgICovXG4gIHVuTWFya1Bhc3N3b3JkRm9yZ290dGVuKCkge1xuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFBhc3N3b3JkRm9yZ290dGVuKGZhbHNlKTtcbiAgICB0aGlzLnNlbmRVcGRhdGUoKTtcbiAgfVxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gU0VUVVBcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8qKlxuICAgKiBBIHJ1bnRpbWUuTWVzc2FnZVNlbmRlciBvYmplY3QsIGFzIHByb3ZpZGVkIGJ5IHRoZSBicm93c2VyOlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvTW96aWxsYS9BZGQtb25zL1dlYkV4dGVuc2lvbnMvQVBJL3J1bnRpbWUvTWVzc2FnZVNlbmRlclxuICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBNZXNzYWdlU2VuZGVyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAtIFRoZSBVUkwgb2YgdGhlIHBhZ2Ugb3IgZnJhbWUgaG9zdGluZyB0aGUgc2NyaXB0IHRoYXQgc2VudCB0aGUgbWVzc2FnZS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEEgU25hcCBzZW5kZXIgb2JqZWN0LlxuICAgKlxuICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBTbmFwU2VuZGVyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzbmFwSWQgLSBUaGUgSUQgb2YgdGhlIHNuYXAuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGNyZWF0ZSBhIG11bHRpcGxleGVkIHN0cmVhbSBmb3IgY29ubmVjdGluZyB0byBhbiB1bnRydXN0ZWQgY29udGV4dFxuICAgKiBsaWtlIGEgRGFwcCBvciBvdGhlciBleHRlbnNpb24uXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBiYWcuXG4gICAqIEBwYXJhbSB7UmVhZGFibGVTdHJlYW19IG9wdGlvbnMuY29ubmVjdGlvblN0cmVhbSAtIFRoZSBEdXBsZXggc3RyZWFtIHRvIGNvbm5lY3QgdG8uXG4gICAqIEBwYXJhbSB7TWVzc2FnZVNlbmRlciB8IFNuYXBTZW5kZXJ9IG9wdGlvbnMuc2VuZGVyIC0gVGhlIHNlbmRlciBvZiB0aGUgbWVzc2FnZXMgb24gdGhpcyBzdHJlYW0uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zdWJqZWN0VHlwZV0gLSBUaGUgdHlwZSBvZiB0aGUgc2VuZGVyLCBpLmUuIHN1YmplY3QuXG4gICAqL1xuICBzZXR1cFVudHJ1c3RlZENvbW11bmljYXRpb24oeyBjb25uZWN0aW9uU3RyZWFtLCBzZW5kZXIsIHN1YmplY3RUeXBlIH0pIHtcbiAgICBjb25zdCB7IHVzZVBoaXNoRGV0ZWN0IH0gPSB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgbGV0IF9zdWJqZWN0VHlwZTtcbiAgICBpZiAoc3ViamVjdFR5cGUpIHtcbiAgICAgIF9zdWJqZWN0VHlwZSA9IHN1YmplY3RUeXBlO1xuICAgIH0gZWxzZSBpZiAoc2VuZGVyLmlkICYmIHNlbmRlci5pZCAhPT0gdGhpcy5leHRlbnNpb24ucnVudGltZS5pZCkge1xuICAgICAgX3N1YmplY3RUeXBlID0gU3ViamVjdFR5cGUuRXh0ZW5zaW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBfc3ViamVjdFR5cGUgPSBTdWJqZWN0VHlwZS5XZWJzaXRlO1xuICAgIH1cblxuICAgIGlmIChzZW5kZXIudXJsKSB7XG4gICAgICBjb25zdCB7IGhvc3RuYW1lIH0gPSBuZXcgVVJMKHNlbmRlci51cmwpO1xuICAgICAgdGhpcy5waGlzaGluZ0NvbnRyb2xsZXIubWF5YmVVcGRhdGVTdGF0ZSgpO1xuICAgICAgLy8gQ2hlY2sgaWYgbmV3IGNvbm5lY3Rpb24gaXMgYmxvY2tlZCBpZiBwaGlzaGluZyBkZXRlY3Rpb24gaXMgb25cbiAgICAgIGNvbnN0IHBoaXNoaW5nVGVzdFJlc3BvbnNlID0gdGhpcy5waGlzaGluZ0NvbnRyb2xsZXIudGVzdChob3N0bmFtZSk7XG4gICAgICBpZiAodXNlUGhpc2hEZXRlY3QgJiYgcGhpc2hpbmdUZXN0UmVzcG9uc2U/LnJlc3VsdCkge1xuICAgICAgICB0aGlzLnNlbmRQaGlzaGluZ1dhcm5pbmcoY29ubmVjdGlvblN0cmVhbSwgaG9zdG5hbWUpO1xuICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50KHtcbiAgICAgICAgICBldmVudDogTWV0YU1ldHJpY3NFdmVudE5hbWUuUGhpc2hpbmdQYWdlRGlzcGxheWVkLFxuICAgICAgICAgIGNhdGVnb3J5OiBNZXRhTWV0cmljc0V2ZW50Q2F0ZWdvcnkuUGhpc2hpbmcsXG4gICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgdXJsOiBob3N0bmFtZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNldHVwIG11bHRpcGxleGluZ1xuICAgIGNvbnN0IG11eCA9IHNldHVwTXVsdGlwbGV4KGNvbm5lY3Rpb25TdHJlYW0pO1xuXG4gICAgLy8gbWVzc2FnZXMgYmV0d2VlbiBpbnBhZ2UgYW5kIGJhY2tncm91bmRcbiAgICB0aGlzLnNldHVwUHJvdmlkZXJDb25uZWN0aW9uKFxuICAgICAgbXV4LmNyZWF0ZVN0cmVhbSgnbWV0YW1hc2stcHJvdmlkZXInKSxcbiAgICAgIHNlbmRlcixcbiAgICAgIF9zdWJqZWN0VHlwZSxcbiAgICApO1xuXG4gICAgLy8gVE9ETzpMZWdhY3lQcm92aWRlcjogRGVsZXRlXG4gICAgaWYgKHNlbmRlci51cmwpIHtcbiAgICAgIC8vIGxlZ2FjeSBzdHJlYW1zXG4gICAgICB0aGlzLnNldHVwUHVibGljQ29uZmlnKG11eC5jcmVhdGVTdHJlYW0oJ3B1YmxpY0NvbmZpZycpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBjcmVhdGUgYSBtdWx0aXBsZXhlZCBzdHJlYW0gZm9yIGNvbm5lY3RpbmcgdG8gYSB0cnVzdGVkIGNvbnRleHQsXG4gICAqIGxpa2Ugb3VyIG93biB1c2VyIGludGVyZmFjZXMsIHdoaWNoIGhhdmUgdGhlIHByb3ZpZGVyIEFQSXMsIGJ1dCBhbHNvXG4gICAqIHJlY2VpdmUgdGhlIGV4cG9ydGVkIEFQSSBmcm9tIHRoaXMgY29udHJvbGxlciwgd2hpY2ggaW5jbHVkZXMgdHJ1c3RlZFxuICAgKiBmdW5jdGlvbnMsIGxpa2UgdGhlIGFiaWxpdHkgdG8gYXBwcm92ZSB0cmFuc2FjdGlvbnMgb3Igc2lnbiBtZXNzYWdlcy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBjb25uZWN0aW9uU3RyZWFtIC0gVGhlIGR1cGxleCBzdHJlYW0gdG8gY29ubmVjdCB0by5cbiAgICogQHBhcmFtIHtNZXNzYWdlU2VuZGVyfSBzZW5kZXIgLSBUaGUgc2VuZGVyIG9mIHRoZSBtZXNzYWdlcyBvbiB0aGlzIHN0cmVhbVxuICAgKi9cbiAgc2V0dXBUcnVzdGVkQ29tbXVuaWNhdGlvbihjb25uZWN0aW9uU3RyZWFtLCBzZW5kZXIpIHtcbiAgICAvLyBzZXR1cCBtdWx0aXBsZXhpbmdcbiAgICBjb25zdCBtdXggPSBzZXR1cE11bHRpcGxleChjb25uZWN0aW9uU3RyZWFtKTtcbiAgICAvLyBjb25uZWN0IGZlYXR1cmVzXG4gICAgdGhpcy5zZXR1cENvbnRyb2xsZXJDb25uZWN0aW9uKG11eC5jcmVhdGVTdHJlYW0oJ2NvbnRyb2xsZXInKSk7XG4gICAgdGhpcy5zZXR1cFByb3ZpZGVyQ29ubmVjdGlvbihcbiAgICAgIG11eC5jcmVhdGVTdHJlYW0oJ3Byb3ZpZGVyJyksXG4gICAgICBzZW5kZXIsXG4gICAgICBTdWJqZWN0VHlwZS5JbnRlcm5hbCxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gY3JlYXRlIGEgbXVsdGlwbGV4ZWQgc3RyZWFtIGZvciBjb25uZWN0aW5nIHRvIHRoZSBwaGlzaGluZyB3YXJuaW5nIHBhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBiYWcuXG4gICAqIEBwYXJhbSB7UmVhZGFibGVTdHJlYW19IG9wdGlvbnMuY29ubmVjdGlvblN0cmVhbSAtIFRoZSBEdXBsZXggc3RyZWFtIHRvIGNvbm5lY3QgdG8uXG4gICAqL1xuICBzZXR1cFBoaXNoaW5nQ29tbXVuaWNhdGlvbih7IGNvbm5lY3Rpb25TdHJlYW0gfSkge1xuICAgIGNvbnN0IHsgdXNlUGhpc2hEZXRlY3QgfSA9IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICBpZiAoIXVzZVBoaXNoRGV0ZWN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc2V0dXAgbXVsdGlwbGV4aW5nXG4gICAgY29uc3QgbXV4ID0gc2V0dXBNdWx0aXBsZXgoY29ubmVjdGlvblN0cmVhbSk7XG4gICAgY29uc3QgcGhpc2hpbmdTdHJlYW0gPSBtdXguY3JlYXRlU3RyZWFtKFBISVNISU5HX1NBRkVMSVNUKTtcblxuICAgIC8vIHNldCB1cCBwb3N0U3RyZWFtIHRyYW5zcG9ydFxuICAgIHBoaXNoaW5nU3RyZWFtLm9uKFxuICAgICAgJ2RhdGEnLFxuICAgICAgY3JlYXRlTWV0YVJQQ0hhbmRsZXIoXG4gICAgICAgIHtcbiAgICAgICAgICBzYWZlbGlzdFBoaXNoaW5nRG9tYWluOiB0aGlzLnNhZmVsaXN0UGhpc2hpbmdEb21haW4uYmluZCh0aGlzKSxcbiAgICAgICAgICBiYWNrVG9TYWZldHlQaGlzaGluZ1dhcm5pbmc6XG4gICAgICAgICAgICB0aGlzLmJhY2tUb1NhZmV0eVBoaXNoaW5nV2FybmluZy5iaW5kKHRoaXMpLFxuICAgICAgICB9LFxuICAgICAgICBwaGlzaGluZ1N0cmVhbSxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB3ZSBkZXRlY3QgYSBzdXNwaWNpb3VzIGRvbWFpbi4gUmVxdWVzdHMgdGhlIGJyb3dzZXIgcmVkaXJlY3RzXG4gICAqIHRvIG91ciBhbnRpLXBoaXNoaW5nIHBhZ2UuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gY29ubmVjdGlvblN0cmVhbSAtIFRoZSBkdXBsZXggc3RyZWFtIHRvIHRoZSBwZXItcGFnZSBzY3JpcHQsXG4gICAqIGZvciBzZW5kaW5nIHRoZSByZWxvYWQgYXR0ZW1wdCB0by5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhvc3RuYW1lIC0gVGhlIGhvc3RuYW1lIHRoYXQgdHJpZ2dlcmVkIHRoZSBzdXNwaWNpb24uXG4gICAqL1xuICBzZW5kUGhpc2hpbmdXYXJuaW5nKGNvbm5lY3Rpb25TdHJlYW0sIGhvc3RuYW1lKSB7XG4gICAgY29uc3QgbXV4ID0gc2V0dXBNdWx0aXBsZXgoY29ubmVjdGlvblN0cmVhbSk7XG4gICAgY29uc3QgcGhpc2hpbmdTdHJlYW0gPSBtdXguY3JlYXRlU3RyZWFtKCdwaGlzaGluZycpO1xuICAgIHBoaXNoaW5nU3RyZWFtLndyaXRlKHsgaG9zdG5hbWUgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSBtZXRob2QgZm9yIHByb3ZpZGluZyBvdXIgQVBJIG92ZXIgYSBzdHJlYW0gdXNpbmcgSlNPTi1SUEMuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gb3V0U3RyZWFtIC0gVGhlIHN0cmVhbSB0byBwcm92aWRlIG91ciBBUEkgb3Zlci5cbiAgICovXG4gIHNldHVwQ29udHJvbGxlckNvbm5lY3Rpb24ob3V0U3RyZWFtKSB7XG4gICAgY29uc3QgYXBpID0gdGhpcy5nZXRBcGkoKTtcblxuICAgIC8vIHJlcG9ydCBuZXcgYWN0aXZlIGNvbnRyb2xsZXIgY29ubmVjdGlvblxuICAgIHRoaXMuYWN0aXZlQ29udHJvbGxlckNvbm5lY3Rpb25zICs9IDE7XG4gICAgdGhpcy5lbWl0KCdjb250cm9sbGVyQ29ubmVjdGlvbkNoYW5nZWQnLCB0aGlzLmFjdGl2ZUNvbnRyb2xsZXJDb25uZWN0aW9ucyk7XG5cbiAgICAvLyBzZXQgdXAgcG9zdFN0cmVhbSB0cmFuc3BvcnRcbiAgICBvdXRTdHJlYW0ub24oXG4gICAgICAnZGF0YScsXG4gICAgICBjcmVhdGVNZXRhUlBDSGFuZGxlcihcbiAgICAgICAgYXBpLFxuICAgICAgICBvdXRTdHJlYW0sXG4gICAgICAgIHRoaXMuc3RvcmUsXG4gICAgICAgIHRoaXMubG9jYWxTdG9yZUFwaVdyYXBwZXIsXG4gICAgICApLFxuICAgICk7XG4gICAgY29uc3QgaGFuZGxlVXBkYXRlID0gKHVwZGF0ZSkgPT4ge1xuICAgICAgaWYgKG91dFN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lbmRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBzZW5kIG5vdGlmaWNhdGlvbiB0byBjbGllbnQtc2lkZVxuICAgICAgb3V0U3RyZWFtLndyaXRlKHtcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIG1ldGhvZDogJ3NlbmRVcGRhdGUnLFxuICAgICAgICBwYXJhbXM6IFt1cGRhdGVdLFxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLm9uKCd1cGRhdGUnLCBoYW5kbGVVcGRhdGUpO1xuICAgIGNvbnN0IHN0YXJ0VUlTeW5jID0gKCkgPT4ge1xuICAgICAgaWYgKG91dFN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lbmRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBzZW5kIG5vdGlmaWNhdGlvbiB0byBjbGllbnQtc2lkZVxuICAgICAgb3V0U3RyZWFtLndyaXRlKHtcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIG1ldGhvZDogJ3N0YXJ0VUlTeW5jJyxcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAodGhpcy5zdGFydFVJU3luYykge1xuICAgICAgc3RhcnRVSVN5bmMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbmNlKCdzdGFydFVJU3luYycsIHN0YXJ0VUlTeW5jKTtcbiAgICB9XG5cbiAgICBvdXRTdHJlYW0ub24oJ2VuZCcsICgpID0+IHtcbiAgICAgIHRoaXMuYWN0aXZlQ29udHJvbGxlckNvbm5lY3Rpb25zIC09IDE7XG4gICAgICB0aGlzLmVtaXQoXG4gICAgICAgICdjb250cm9sbGVyQ29ubmVjdGlvbkNoYW5nZWQnLFxuICAgICAgICB0aGlzLmFjdGl2ZUNvbnRyb2xsZXJDb25uZWN0aW9ucyxcbiAgICAgICk7XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCd1cGRhdGUnLCBoYW5kbGVVcGRhdGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIGZvciBzZXJ2aW5nIG91ciBldGhlcmV1bSBwcm92aWRlciBvdmVyIGEgZ2l2ZW4gc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IG91dFN0cmVhbSAtIFRoZSBzdHJlYW0gdG8gcHJvdmlkZSBvdmVyLlxuICAgKiBAcGFyYW0ge01lc3NhZ2VTZW5kZXIgfCBTbmFwU2VuZGVyfSBzZW5kZXIgLSBUaGUgc2VuZGVyIG9mIHRoZSBtZXNzYWdlcyBvbiB0aGlzIHN0cmVhbVxuICAgKiBAcGFyYW0ge1N1YmplY3RUeXBlfSBzdWJqZWN0VHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBzZW5kZXIsIGkuZS4gc3ViamVjdC5cbiAgICovXG4gIHNldHVwUHJvdmlkZXJDb25uZWN0aW9uKG91dFN0cmVhbSwgc2VuZGVyLCBzdWJqZWN0VHlwZSkge1xuICAgIGxldCBvcmlnaW47XG4gICAgaWYgKHN1YmplY3RUeXBlID09PSBTdWJqZWN0VHlwZS5JbnRlcm5hbCkge1xuICAgICAgb3JpZ2luID0gT1JJR0lOX01FVEFNQVNLO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG9yaWdpbiA9IG5ldyBVUkwoc2VuZGVyLnVybCkub3JpZ2luO1xuICAgIH1cblxuICAgIGlmIChzZW5kZXIuaWQgJiYgc2VuZGVyLmlkICE9PSB0aGlzLmV4dGVuc2lvbi5ydW50aW1lLmlkKSB7XG4gICAgICB0aGlzLnN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIuYWRkU3ViamVjdE1ldGFkYXRhKHtcbiAgICAgICAgb3JpZ2luLFxuICAgICAgICBleHRlbnNpb25JZDogc2VuZGVyLmlkLFxuICAgICAgICBzdWJqZWN0VHlwZTogU3ViamVjdFR5cGUuRXh0ZW5zaW9uLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGV0IHRhYklkO1xuICAgIGlmIChzZW5kZXIudGFiICYmIHNlbmRlci50YWIuaWQpIHtcbiAgICAgIHRhYklkID0gc2VuZGVyLnRhYi5pZDtcbiAgICB9XG5cbiAgICBjb25zdCBlbmdpbmUgPSB0aGlzLnNldHVwUHJvdmlkZXJFbmdpbmUoe1xuICAgICAgb3JpZ2luLFxuICAgICAgc2VuZGVyLFxuICAgICAgc3ViamVjdFR5cGUsXG4gICAgICB0YWJJZCxcbiAgICB9KTtcblxuICAgIC8vIHNldHVwIGNvbm5lY3Rpb25cbiAgICBjb25zdCBwcm92aWRlclN0cmVhbSA9IGNyZWF0ZUVuZ2luZVN0cmVhbSh7IGVuZ2luZSB9KTtcblxuICAgIGNvbnN0IGNvbm5lY3Rpb25JZCA9IHRoaXMuYWRkQ29ubmVjdGlvbihvcmlnaW4sIHsgZW5naW5lIH0pO1xuXG4gICAgcHVtcChvdXRTdHJlYW0sIHByb3ZpZGVyU3RyZWFtLCBvdXRTdHJlYW0sIChlcnIpID0+IHtcbiAgICAgIC8vIGhhbmRsZSBhbnkgbWlkZGxld2FyZSBjbGVhbnVwXG4gICAgICBlbmdpbmUuX21pZGRsZXdhcmUuZm9yRWFjaCgobWlkKSA9PiB7XG4gICAgICAgIGlmIChtaWQuZGVzdHJveSAmJiB0eXBlb2YgbWlkLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBtaWQuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbm5lY3Rpb25JZCAmJiB0aGlzLnJlbW92ZUNvbm5lY3Rpb24ob3JpZ2luLCBjb25uZWN0aW9uSWQpO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBsb2cuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIGZvciBjcmVhdGluZyBhIHByb3ZpZGVyIHRoYXQgaXMgc2FmZWx5IHJlc3RyaWN0ZWQgZm9yIHRoZSByZXF1ZXN0aW5nIHN1YmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gUHJvdmlkZXIgZW5naW5lIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMub3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgc2VuZGVyXG4gICAqIEBwYXJhbSB7TWVzc2FnZVNlbmRlciB8IFNuYXBTZW5kZXJ9IG9wdGlvbnMuc2VuZGVyIC0gVGhlIHNlbmRlciBvYmplY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnN1YmplY3RUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHNlbmRlciBzdWJqZWN0LlxuICAgKiBAcGFyYW0ge3RhYklkfSBbb3B0aW9ucy50YWJJZF0gLSBUaGUgdGFiIElEIG9mIHRoZSBzZW5kZXIgLSBpZiB0aGUgc2VuZGVyIGlzIHdpdGhpbiBhIHRhYlxuICAgKi9cbiAgc2V0dXBQcm92aWRlckVuZ2luZSh7IG9yaWdpbiwgc3ViamVjdFR5cGUsIHNlbmRlciwgdGFiSWQgfSkge1xuICAgIC8vIHNldHVwIGpzb24gcnBjIGVuZ2luZSBzdGFja1xuICAgIGNvbnN0IGVuZ2luZSA9IG5ldyBKc29uUnBjRW5naW5lKCk7XG4gICAgY29uc3QgeyBibG9ja1RyYWNrZXIsIHByb3ZpZGVyIH0gPSB0aGlzO1xuXG4gICAgLy8gY3JlYXRlIGZpbHRlciBwb2x5ZmlsbCBtaWRkbGV3YXJlXG4gICAgY29uc3QgZmlsdGVyTWlkZGxld2FyZSA9IGNyZWF0ZUZpbHRlck1pZGRsZXdhcmUoeyBwcm92aWRlciwgYmxvY2tUcmFja2VyIH0pO1xuXG4gICAgLy8gY3JlYXRlIHN1YnNjcmlwdGlvbiBwb2x5ZmlsbCBtaWRkbGV3YXJlXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uTWFuYWdlciA9IGNyZWF0ZVN1YnNjcmlwdGlvbk1hbmFnZXIoe1xuICAgICAgcHJvdmlkZXIsXG4gICAgICBibG9ja1RyYWNrZXIsXG4gICAgfSk7XG4gICAgc3Vic2NyaXB0aW9uTWFuYWdlci5ldmVudHMub24oJ25vdGlmaWNhdGlvbicsIChtZXNzYWdlKSA9PlxuICAgICAgZW5naW5lLmVtaXQoJ25vdGlmaWNhdGlvbicsIG1lc3NhZ2UpLFxuICAgICk7XG5cbiAgICBpZiAoaXNNYW5pZmVzdFYzKSB7XG4gICAgICBlbmdpbmUucHVzaChjcmVhdGVEdXBlUmVxRmlsdGVyTWlkZGxld2FyZSgpKTtcbiAgICB9XG5cbiAgICAvLyBhcHBlbmQgb3JpZ2luIHRvIGVhY2ggcmVxdWVzdFxuICAgIGVuZ2luZS5wdXNoKGNyZWF0ZU9yaWdpbk1pZGRsZXdhcmUoeyBvcmlnaW4gfSkpO1xuXG4gICAgLy8gYXBwZW5kIHRhYklkIHRvIGVhY2ggcmVxdWVzdCBpZiBpdCBleGlzdHNcbiAgICBpZiAodGFiSWQpIHtcbiAgICAgIGVuZ2luZS5wdXNoKGNyZWF0ZVRhYklkTWlkZGxld2FyZSh7IHRhYklkIH0pKTtcbiAgICB9XG5cbiAgICAvLyBsb2dnaW5nXG4gICAgZW5naW5lLnB1c2goY3JlYXRlTG9nZ2VyTWlkZGxld2FyZSh7IG9yaWdpbiB9KSk7XG4gICAgZW5naW5lLnB1c2godGhpcy5wZXJtaXNzaW9uTG9nQ29udHJvbGxlci5jcmVhdGVNaWRkbGV3YXJlKCkpO1xuXG4gICAgZW5naW5lLnB1c2goXG4gICAgICBjcmVhdGVSUENNZXRob2RUcmFja2luZ01pZGRsZXdhcmUoe1xuICAgICAgICB0cmFja0V2ZW50OiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50LmJpbmQoXG4gICAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICAgIGdldE1ldHJpY3NTdGF0ZTogdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUuYmluZChcbiAgICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICAgKSxcbiAgICAgICAgc2VjdXJpdHlQcm92aWRlclJlcXVlc3Q6IHRoaXMuc2VjdXJpdHlQcm92aWRlclJlcXVlc3QuYmluZCh0aGlzKSxcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICAvLyBvbmJvYXJkaW5nXG4gICAgaWYgKHN1YmplY3RUeXBlID09PSBTdWJqZWN0VHlwZS5XZWJzaXRlKSB7XG4gICAgICBlbmdpbmUucHVzaChcbiAgICAgICAgY3JlYXRlT25ib2FyZGluZ01pZGRsZXdhcmUoe1xuICAgICAgICAgIGxvY2F0aW9uOiBzZW5kZXIudXJsLFxuICAgICAgICAgIHJlZ2lzdGVyT25ib2FyZGluZzogdGhpcy5vbmJvYXJkaW5nQ29udHJvbGxlci5yZWdpc3Rlck9uYm9hcmRpbmcsXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBVbnJlc3RyaWN0ZWQvcGVybWlzc2lvbmxlc3MgUlBDIG1ldGhvZCBpbXBsZW1lbnRhdGlvbnNcbiAgICBlbmdpbmUucHVzaChcbiAgICAgIGNyZWF0ZU1ldGhvZE1pZGRsZXdhcmUoe1xuICAgICAgICBvcmlnaW4sXG5cbiAgICAgICAgc3ViamVjdFR5cGUsXG5cbiAgICAgICAgLy8gTWlzY2VsbGFuZW91c1xuICAgICAgICBhZGRTdWJqZWN0TWV0YWRhdGE6XG4gICAgICAgICAgdGhpcy5zdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLmFkZFN1YmplY3RNZXRhZGF0YS5iaW5kKFxuICAgICAgICAgICAgdGhpcy5zdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLFxuICAgICAgICAgICksXG4gICAgICAgIGdldFByb3ZpZGVyU3RhdGU6IHRoaXMuZ2V0UHJvdmlkZXJTdGF0ZS5iaW5kKHRoaXMpLFxuICAgICAgICBnZXRVbmxvY2tQcm9taXNlOiB0aGlzLmFwcFN0YXRlQ29udHJvbGxlci5nZXRVbmxvY2tQcm9taXNlLmJpbmQoXG4gICAgICAgICAgdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICAgIGhhbmRsZVdhdGNoQXNzZXRSZXF1ZXN0OiB0aGlzLnRva2Vuc0NvbnRyb2xsZXIud2F0Y2hBc3NldC5iaW5kKFxuICAgICAgICAgIHRoaXMudG9rZW5zQ29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgICAgcmVxdWVzdFVzZXJBcHByb3ZhbDpcbiAgICAgICAgICB0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5hZGRBbmRTaG93QXBwcm92YWxSZXF1ZXN0LmJpbmQoXG4gICAgICAgICAgICB0aGlzLmFwcHJvdmFsQ29udHJvbGxlcixcbiAgICAgICAgICApLFxuICAgICAgICBzZW5kTWV0cmljczogdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tFdmVudC5iaW5kKFxuICAgICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgICAvLyBQZXJtaXNzaW9uLXJlbGF0ZWRcbiAgICAgICAgZ2V0QWNjb3VudHM6IHRoaXMuZ2V0UGVybWl0dGVkQWNjb3VudHMuYmluZCh0aGlzLCBvcmlnaW4pLFxuICAgICAgICBnZXRQZXJtaXNzaW9uc0Zvck9yaWdpbjogdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlci5nZXRQZXJtaXNzaW9ucy5iaW5kKFxuICAgICAgICAgIHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIsXG4gICAgICAgICAgb3JpZ2luLFxuICAgICAgICApLFxuICAgICAgICBoYXNQZXJtaXNzaW9uOiB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLmhhc1Blcm1pc3Npb24uYmluZChcbiAgICAgICAgICB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLFxuICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgKSxcbiAgICAgICAgcmVxdWVzdEFjY291bnRzUGVybWlzc2lvbjpcbiAgICAgICAgICB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLnJlcXVlc3RQZXJtaXNzaW9ucy5iaW5kKFxuICAgICAgICAgICAgdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlcixcbiAgICAgICAgICAgIHsgb3JpZ2luIH0sXG4gICAgICAgICAgICB7IGV0aF9hY2NvdW50czoge30gfSxcbiAgICAgICAgICApLFxuICAgICAgICByZXF1ZXN0UGVybWlzc2lvbnNGb3JPcmlnaW46XG4gICAgICAgICAgdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlci5yZXF1ZXN0UGVybWlzc2lvbnMuYmluZChcbiAgICAgICAgICAgIHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIsXG4gICAgICAgICAgICB7IG9yaWdpbiB9LFxuICAgICAgICAgICksXG5cbiAgICAgICAgZ2V0Q3VycmVudENoYWluSWQ6ICgpID0+XG4gICAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLnByb3ZpZGVyQ29uZmlnLmNoYWluSWQsXG4gICAgICAgIGdldEN1cnJlbnRScGNVcmw6ICgpID0+XG4gICAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLnByb3ZpZGVyQ29uZmlnLnJwY1VybCxcbiAgICAgICAgLy8gbmV0d29yayBjb25maWd1cmF0aW9uLXJlbGF0ZWRcbiAgICAgICAgZ2V0TmV0d29ya0NvbmZpZ3VyYXRpb25zOiAoKSA9PlxuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5uZXR3b3JrQ29uZmlndXJhdGlvbnMsXG4gICAgICAgIHVwc2VydE5ldHdvcmtDb25maWd1cmF0aW9uOlxuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIudXBzZXJ0TmV0d29ya0NvbmZpZ3VyYXRpb24uYmluZChcbiAgICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICAgICAgKSxcbiAgICAgICAgc2V0QWN0aXZlTmV0d29yazogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zZXRBY3RpdmVOZXR3b3JrLmJpbmQoXG4gICAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgICAgZmluZE5ldHdvcmtDb25maWd1cmF0aW9uQnk6IHRoaXMuZmluZE5ldHdvcmtDb25maWd1cmF0aW9uQnkuYmluZCh0aGlzKSxcbiAgICAgICAgc2V0UHJvdmlkZXJUeXBlOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnNldFByb3ZpZGVyVHlwZS5iaW5kKFxuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICAgICksXG5cbiAgICAgICAgLy8gV2ViMyBzaGltLXJlbGF0ZWRcbiAgICAgICAgZ2V0V2ViM1NoaW1Vc2FnZVN0YXRlOiB0aGlzLmFsZXJ0Q29udHJvbGxlci5nZXRXZWIzU2hpbVVzYWdlU3RhdGUuYmluZChcbiAgICAgICAgICB0aGlzLmFsZXJ0Q29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgICAgc2V0V2ViM1NoaW1Vc2FnZVJlY29yZGVkOlxuICAgICAgICAgIHRoaXMuYWxlcnRDb250cm9sbGVyLnNldFdlYjNTaGltVXNhZ2VSZWNvcmRlZC5iaW5kKFxuICAgICAgICAgICAgdGhpcy5hbGVydENvbnRyb2xsZXIsXG4gICAgICAgICAgKSxcbiAgICAgIH0pLFxuICAgICk7XG5cblxuICAgIC8vIGZpbHRlciBhbmQgc3Vic2NyaXB0aW9uIHBvbHlmaWxsc1xuICAgIGVuZ2luZS5wdXNoKGZpbHRlck1pZGRsZXdhcmUpO1xuICAgIGVuZ2luZS5wdXNoKHN1YnNjcmlwdGlvbk1hbmFnZXIubWlkZGxld2FyZSk7XG4gICAgaWYgKHN1YmplY3RUeXBlICE9PSBTdWJqZWN0VHlwZS5JbnRlcm5hbCkge1xuICAgICAgLy8gcGVybWlzc2lvbnNcbiAgICAgIGVuZ2luZS5wdXNoKFxuICAgICAgICB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLmNyZWF0ZVBlcm1pc3Npb25NaWRkbGV3YXJlKHtcbiAgICAgICAgICBvcmlnaW4sXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBlbmdpbmUucHVzaCh0aGlzLm1ldGFtYXNrTWlkZGxld2FyZSk7XG5cbiAgICAvLyBmb3J3YXJkIHRvIG1ldGFtYXNrIHByaW1hcnkgcHJvdmlkZXJcbiAgICBlbmdpbmUucHVzaChwcm92aWRlckFzTWlkZGxld2FyZShwcm92aWRlcikpO1xuICAgIHJldHVybiBlbmdpbmU7XG4gIH1cblxuICAvKipcbiAgICogVE9ETzpMZWdhY3lQcm92aWRlcjogRGVsZXRlXG4gICAqIEEgbWV0aG9kIGZvciBwcm92aWRpbmcgb3VyIHB1YmxpYyBjb25maWcgaW5mbyBvdmVyIGEgc3RyZWFtLlxuICAgKiBUaGlzIGluY2x1ZGVzIGluZm8gd2UgbGlrZSB0byBiZSBzeW5jaHJvbm91cyBpZiBwb3NzaWJsZSwgbGlrZVxuICAgKiB0aGUgY3VycmVudCBzZWxlY3RlZCBhY2NvdW50LCBhbmQgbmV0d29yayBJRC5cbiAgICpcbiAgICogU2luY2Ugc3luY2hyb25vdXMgbWV0aG9kcyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBpbiB3ZWIzLFxuICAgKiB0aGlzIGlzIGEgZ29vZCBjYW5kaWRhdGUgZm9yIGRlcHJlY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IG91dFN0cmVhbSAtIFRoZSBzdHJlYW0gdG8gcHJvdmlkZSBwdWJsaWMgY29uZmlnIG92ZXIuXG4gICAqL1xuICBzZXR1cFB1YmxpY0NvbmZpZyhvdXRTdHJlYW0pIHtcbiAgICBjb25zdCBjb25maWdTdHJlYW0gPSBzdG9yZUFzU3RyZWFtKHRoaXMucHVibGljQ29uZmlnU3RvcmUpO1xuXG4gICAgcHVtcChjb25maWdTdHJlYW0sIG91dFN0cmVhbSwgKGVycikgPT4ge1xuICAgICAgY29uZmlnU3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgbG9nLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHJlZmVyZW5jZSB0byBhIGNvbm5lY3Rpb24gYnkgb3JpZ2luLiBJZ25vcmVzIHRoZSAnbWV0YW1hc2snIG9yaWdpbi5cbiAgICogQ2FsbGVyIG11c3QgZW5zdXJlIHRoYXQgdGhlIHJldHVybmVkIGlkIGlzIHN0b3JlZCBzdWNoIHRoYXQgdGhlIHJlZmVyZW5jZVxuICAgKiBjYW4gYmUgZGVsZXRlZCBsYXRlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBjb25uZWN0aW9uJ3Mgb3JpZ2luIHN0cmluZy5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBEYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgY29ubmVjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5lbmdpbmUgLSBUaGUgY29ubmVjdGlvbidzIEpTT04gUnBjIEVuZ2luZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29ubmVjdGlvbidzIGlkIChzbyB0aGF0IGl0IGNhbiBiZSBkZWxldGVkIGxhdGVyKVxuICAgKi9cbiAgYWRkQ29ubmVjdGlvbihvcmlnaW4sIHsgZW5naW5lIH0pIHtcbiAgICBpZiAob3JpZ2luID09PSBPUklHSU5fTUVUQU1BU0spIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jb25uZWN0aW9uc1tvcmlnaW5dKSB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25zW29yaWdpbl0gPSB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBpZCA9IG5hbm9pZCgpO1xuICAgIHRoaXMuY29ubmVjdGlvbnNbb3JpZ2luXVtpZF0gPSB7XG4gICAgICBlbmdpbmUsXG4gICAgfTtcblxuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgcmVmZXJlbmNlIHRvIGEgY29ubmVjdGlvbiwgYnkgb3JpZ2luIGFuZCBpZC5cbiAgICogSWdub3JlcyB1bmtub3duIG9yaWdpbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW4gLSBUaGUgY29ubmVjdGlvbidzIG9yaWdpbiBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIFRoZSBjb25uZWN0aW9uJ3MgaWQsIGFzIHJldHVybmVkIGZyb20gYWRkQ29ubmVjdGlvbi5cbiAgICovXG4gIHJlbW92ZUNvbm5lY3Rpb24ob3JpZ2luLCBpZCkge1xuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gdGhpcy5jb25uZWN0aW9uc1tvcmlnaW5dO1xuICAgIGlmICghY29ubmVjdGlvbnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZWxldGUgY29ubmVjdGlvbnNbaWRdO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKGNvbm5lY3Rpb25zKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmNvbm5lY3Rpb25zW29yaWdpbl07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyBhbGwgY29ubmVjdGlvbnMgZm9yIHRoZSBnaXZlbiBvcmlnaW4sIGFuZCByZW1vdmVzIHRoZSByZWZlcmVuY2VzXG4gICAqIHRvIHRoZW0uXG4gICAqIElnbm9yZXMgdW5rbm93biBvcmlnaW5zLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luIC0gVGhlIG9yaWdpbiBzdHJpbmcuXG4gICAqL1xuICByZW1vdmVBbGxDb25uZWN0aW9ucyhvcmlnaW4pIHtcbiAgICBjb25zdCBjb25uZWN0aW9ucyA9IHRoaXMuY29ubmVjdGlvbnNbb3JpZ2luXTtcbiAgICBpZiAoIWNvbm5lY3Rpb25zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMoY29ubmVjdGlvbnMpLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZUNvbm5lY3Rpb24ob3JpZ2luLCBpZCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2F1c2VzIHRoZSBSUEMgZW5naW5lcyBhc3NvY2lhdGVkIHdpdGggdGhlIGNvbm5lY3Rpb25zIHRvIHRoZSBnaXZlbiBvcmlnaW5cbiAgICogdG8gZW1pdCBhIG5vdGlmaWNhdGlvbiBldmVudCB3aXRoIHRoZSBnaXZlbiBwYXlsb2FkLlxuICAgKlxuICAgKiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyB0aGF0IG9ubHkgcGVybWl0dGVkIG5vdGlmaWNhdGlvbnNcbiAgICogYXJlIHNlbnQuXG4gICAqXG4gICAqIElnbm9yZXMgdW5rbm93biBvcmlnaW5zLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luIC0gVGhlIGNvbm5lY3Rpb24ncyBvcmlnaW4gc3RyaW5nLlxuICAgKiBAcGFyYW0ge3Vua25vd259IHBheWxvYWQgLSBUaGUgZXZlbnQgcGF5bG9hZC5cbiAgICovXG4gIG5vdGlmeUNvbm5lY3Rpb25zKG9yaWdpbiwgcGF5bG9hZCkge1xuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gdGhpcy5jb25uZWN0aW9uc1tvcmlnaW5dO1xuXG4gICAgaWYgKGNvbm5lY3Rpb25zKSB7XG4gICAgICBPYmplY3QudmFsdWVzKGNvbm5lY3Rpb25zKS5mb3JFYWNoKChjb25uKSA9PiB7XG4gICAgICAgIGlmIChjb25uLmVuZ2luZSkge1xuICAgICAgICAgIGNvbm4uZW5naW5lLmVtaXQoJ25vdGlmaWNhdGlvbicsIHBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2F1c2VzIHRoZSBSUEMgZW5naW5lcyBhc3NvY2lhdGVkIHdpdGggYWxsIGNvbm5lY3Rpb25zIHRvIGVtaXQgYVxuICAgKiBub3RpZmljYXRpb24gZXZlbnQgd2l0aCB0aGUgZ2l2ZW4gcGF5bG9hZC5cbiAgICpcbiAgICogSWYgdGhlIFwicGF5bG9hZFwiIHBhcmFtZXRlciBpcyBhIGZ1bmN0aW9uLCB0aGUgcGF5bG9hZCBmb3IgZWFjaCBjb25uZWN0aW9uXG4gICAqIHdpbGwgYmUgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGF0IGZ1bmN0aW9uIGNhbGxlZCB3aXRoIHRoZSBjb25uZWN0aW9uJ3NcbiAgICogb3JpZ2luLlxuICAgKlxuICAgKiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyB0aGF0IG9ubHkgcGVybWl0dGVkIG5vdGlmaWNhdGlvbnNcbiAgICogYXJlIHNlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gcGF5bG9hZCAtIFRoZSBldmVudCBwYXlsb2FkLCBvciBwYXlsb2FkIGdldHRlciBmdW5jdGlvbi5cbiAgICovXG4gIG5vdGlmeUFsbENvbm5lY3Rpb25zKHBheWxvYWQpIHtcbiAgICBjb25zdCBnZXRQYXlsb2FkID1cbiAgICAgIHR5cGVvZiBwYXlsb2FkID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gKG9yaWdpbikgPT4gcGF5bG9hZChvcmlnaW4pXG4gICAgICAgIDogKCkgPT4gcGF5bG9hZDtcblxuICAgIE9iamVjdC5rZXlzKHRoaXMuY29ubmVjdGlvbnMpLmZvckVhY2goKG9yaWdpbikgPT4ge1xuICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLmNvbm5lY3Rpb25zW29yaWdpbl0pLmZvckVhY2goYXN5bmMgKGNvbm4pID0+IHtcbiAgICAgICAgaWYgKGNvbm4uZW5naW5lKSB7XG4gICAgICAgICAgY29ubi5lbmdpbmUuZW1pdCgnbm90aWZpY2F0aW9uJywgYXdhaXQgZ2V0UGF5bG9hZChvcmlnaW4pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBoYW5kbGVyc1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBLZXlyaW5nQ29udHJvbGxlciB1cGRhdGVcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIC0gdGhlIEtDIHN0YXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgX29uS2V5cmluZ0NvbnRyb2xsZXJVcGRhdGUoc3RhdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBrZXlyaW5ncyxcbiAgICAgIGVuY3J5cHRpb25LZXk6IGxvZ2luVG9rZW4sXG4gICAgICBlbmNyeXB0aW9uU2FsdDogbG9naW5TYWx0LFxuICAgIH0gPSBzdGF0ZTtcbiAgICBjb25zdCBhZGRyZXNzZXMgPSBrZXlyaW5ncy5yZWR1Y2UoXG4gICAgICAoYWNjLCB7IGFjY291bnRzIH0pID0+IGFjYy5jb25jYXQoYWNjb3VudHMpLFxuICAgICAgW10sXG4gICAgKTtcblxuICAgIGlmIChpc01hbmlmZXN0VjMpIHtcbiAgICAgIGF3YWl0IHRoaXMuZXh0ZW5zaW9uLnN0b3JhZ2Uuc2Vzc2lvbi5zZXQoeyBsb2dpblRva2VuLCBsb2dpblNhbHQgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFhZGRyZXNzZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHByZWZlcmVuY2VzICsgaWRlbnRpdGllcyBjb250cm9sbGVyIGtub3cgYWJvdXQgYWxsIGFkZHJlc3Nlc1xuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN5bmNBZGRyZXNzZXMoYWRkcmVzc2VzKTtcbiAgICB0aGlzLmFjY291bnRUcmFja2VyLnN5bmNXaXRoQWRkcmVzc2VzKGFkZHJlc3Nlcyk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGdsb2JhbCBhcHBsaWNhdGlvbiB1bmxvY2suXG4gICAqIE5vdGlmaWVzIGFsbCBjb25uZWN0aW9ucyB0aGF0IHRoZSBleHRlbnNpb24gaXMgdW5sb2NrZWQsIGFuZCB3aGljaFxuICAgKiBhY2NvdW50KHMpIGFyZSBjdXJyZW50bHkgYWNjZXNzaWJsZSwgaWYgYW55LlxuICAgKi9cbiAgX29uVW5sb2NrKCkge1xuICAgIHRoaXMubm90aWZ5QWxsQ29ubmVjdGlvbnMoYXN5bmMgKG9yaWdpbikgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kOiBOT1RJRklDQVRJT05fTkFNRVMudW5sb2NrU3RhdGVDaGFuZ2VkLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBpc1VubG9ja2VkOiB0cnVlLFxuICAgICAgICAgIGFjY291bnRzOiBhd2FpdCB0aGlzLmdldFBlcm1pdHRlZEFjY291bnRzKG9yaWdpbiksXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgdGhpcy51bk1hcmtQYXNzd29yZEZvcmdvdHRlbigpO1xuXG4gICAgLy8gSW4gdGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24sIHRoaXMgaGFuZGxlciBpcyB0cmlnZ2VyZWQgYnkgYVxuICAgIC8vIEtleXJpbmdDb250cm9sbGVyIGV2ZW50LiBPdGhlciBjb250cm9sbGVycyBzdWJzY3JpYmUgdG8gdGhlICd1bmxvY2snXG4gICAgLy8gZXZlbnQgb2YgdGhlIE1ldGFNYXNrQ29udHJvbGxlciBpdHNlbGYuXG4gICAgdGhpcy5lbWl0KCd1bmxvY2snKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgZ2xvYmFsIGFwcGxpY2F0aW9uIGxvY2suXG4gICAqIE5vdGlmaWVzIGFsbCBjb25uZWN0aW9ucyB0aGF0IHRoZSBleHRlbnNpb24gaXMgbG9ja2VkLlxuICAgKi9cbiAgX29uTG9jaygpIHtcbiAgICB0aGlzLm5vdGlmeUFsbENvbm5lY3Rpb25zKHtcbiAgICAgIG1ldGhvZDogTk9USUZJQ0FUSU9OX05BTUVTLnVubG9ja1N0YXRlQ2hhbmdlZCxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBpc1VubG9ja2VkOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBJbiB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiwgdGhpcyBoYW5kbGVyIGlzIHRyaWdnZXJlZCBieSBhXG4gICAgLy8gS2V5cmluZ0NvbnRyb2xsZXIgZXZlbnQuIE90aGVyIGNvbnRyb2xsZXJzIHN1YnNjcmliZSB0byB0aGUgJ2xvY2snXG4gICAgLy8gZXZlbnQgb2YgdGhlIE1ldGFNYXNrQ29udHJvbGxlciBpdHNlbGYuXG4gICAgdGhpcy5lbWl0KCdsb2NrJyk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIG1lbW9yeSBzdGF0ZSB1cGRhdGVzLlxuICAgKiAtIEVuc3VyZSBpc0NsaWVudE9wZW5BbmRVbmxvY2tlZCBpcyB1cGRhdGVkXG4gICAqIC0gTm90aWZpZXMgYWxsIGNvbm5lY3Rpb25zIHdpdGggdGhlIG5ldyBwcm92aWRlciBuZXR3b3JrIHN0YXRlXG4gICAqICAgLSBUaGUgZXh0ZXJuYWwgcHJvdmlkZXJzIGhhbmRsZSBkaWZmaW5nIHRoZSBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gbmV3U3RhdGVcbiAgICovXG4gIF9vblN0YXRlVXBkYXRlKG5ld1N0YXRlKSB7XG4gICAgdGhpcy5pc0NsaWVudE9wZW5BbmRVbmxvY2tlZCA9IG5ld1N0YXRlLmlzVW5sb2NrZWQgJiYgdGhpcy5faXNDbGllbnRPcGVuO1xuICAgIHRoaXMubm90aWZ5QWxsQ29ubmVjdGlvbnMoe1xuICAgICAgbWV0aG9kOiBOT1RJRklDQVRJT05fTkFNRVMuY2hhaW5DaGFuZ2VkLFxuICAgICAgcGFyYW1zOiB0aGlzLmdldFByb3ZpZGVyTmV0d29ya1N0YXRlKG5ld1N0YXRlKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIG1pc2NcblxuICAvKipcbiAgICogQSBtZXRob2QgZm9yIGVtaXR0aW5nIHRoZSBmdWxsIE1ldGFNYXNrIHN0YXRlIHRvIGFsbCByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGVTZW5kVXBkYXRlKCkge1xuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5nZXRTdGF0ZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZXh0ZW5zaW9uIGlzIHVubG9ja2VkLlxuICAgKi9cbiAgaXNVbmxvY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5rZXlyaW5nQ29udHJvbGxlci5tZW1TdG9yZS5nZXRTdGF0ZSgpLmlzVW5sb2NrZWQ7XG4gIH1cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIE1JU0NFTExBTkVPVVNcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGdldEV4dGVybmFsUGVuZGluZ1RyYW5zYWN0aW9ucyhhZGRyZXNzKSB7XG4gICAgcmV0dXJuIHRoaXMuc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLmdldFRyYW5zYWN0aW9ucyh7XG4gICAgICBhZGRyZXNzRnJvbTogYWRkcmVzcyxcbiAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5vbmNlIHRoYXQgd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGggYSB0cmFuc2FjdGlvbiBvbmNlIGFwcHJvdmVkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGhleCBzdHJpbmcgYWRkcmVzcyBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59XG4gICAqL1xuICBhc3luYyBnZXRQZW5kaW5nTm9uY2UoYWRkcmVzcykge1xuICAgIGNvbnN0IHsgbm9uY2VEZXRhaWxzLCByZWxlYXNlTG9jayB9ID1cbiAgICAgIGF3YWl0IHRoaXMudHhDb250cm9sbGVyLm5vbmNlVHJhY2tlci5nZXROb25jZUxvY2soYWRkcmVzcyk7XG4gICAgY29uc3QgcGVuZGluZ05vbmNlID0gbm9uY2VEZXRhaWxzLnBhcmFtcy5oaWdoZXN0U3VnZ2VzdGVkO1xuXG4gICAgcmVsZWFzZUxvY2soKTtcbiAgICByZXR1cm4gcGVuZGluZ05vbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5leHQgbm9uY2UgYWNjb3JkaW5nIHRvIHRoZSBub25jZS10cmFja2VyXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGhleCBzdHJpbmcgYWRkcmVzcyBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59XG4gICAqL1xuICBhc3luYyBnZXROZXh0Tm9uY2UoYWRkcmVzcykge1xuICAgIGNvbnN0IG5vbmNlTG9jayA9IGF3YWl0IHRoaXMudHhDb250cm9sbGVyLm5vbmNlVHJhY2tlci5nZXROb25jZUxvY2soXG4gICAgICBhZGRyZXNzLFxuICAgICk7XG4gICAgbm9uY2VMb2NrLnJlbGVhc2VMb2NrKCk7XG4gICAgcmV0dXJuIG5vbmNlTG9jay5uZXh0Tm9uY2U7XG4gIH1cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIENPTkZJR1xuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IG5ldHdvcmsgY29uZmlndXJhdGlvbiBvYmplY3QgdGhhdCBtYXRjaGVzIGF0IGxlYXN0IG9uZSBmaWVsZCBvZiB0aGVcbiAgICogcHJvdmlkZWQgc2VhcmNoIGNyaXRlcmlhLiBSZXR1cm5zIG51bGwgaWYgbm8gbWF0Y2ggaXMgZm91bmRcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHJwY0luZm8gLSBUaGUgUlBDIGVuZHBvaW50IHByb3BlcnRpZXMgYW5kIHZhbHVlcyB0byBjaGVjay5cbiAgICogQHJldHVybnMge29iamVjdH0gcnBjSW5mbyBmb3VuZCBpbiB0aGUgbmV0d29yayBjb25maWd1cmF0aW9ucyBsaXN0XG4gICAqL1xuICBmaW5kTmV0d29ya0NvbmZpZ3VyYXRpb25CeShycGNJbmZvKSB7XG4gICAgY29uc3QgeyBuZXR3b3JrQ29uZmlndXJhdGlvbnMgfSA9IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBuZXR3b3JrQ29uZmlndXJhdGlvbiA9IE9iamVjdC52YWx1ZXMobmV0d29ya0NvbmZpZ3VyYXRpb25zKS5maW5kKFxuICAgICAgKGNvbmZpZ3VyYXRpb24pID0+IHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJwY0luZm8pLnNvbWUoKGtleSkgPT4ge1xuICAgICAgICAgIHJldHVybiBjb25maWd1cmF0aW9uW2tleV0gPT09IHJwY0luZm9ba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICk7XG5cbiAgICByZXR1cm4gbmV0d29ya0NvbmZpZ3VyYXRpb24gfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBMZWRnZXIgTGl2ZSBwcmVmZXJlbmNlIHRvIHVzZSBmb3IgTGVkZ2VyIGhhcmR3YXJlIHdhbGxldCBzdXBwb3J0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc3BvcnRUeXBlIC0gVGhlIExlZGdlciB0cmFuc3BvcnQgdHlwZS5cbiAgICovXG4gIGFzeW5jIHNldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UodHJhbnNwb3J0VHlwZSkge1xuICAgIGlmICghdGhpcy5jYW5Vc2VIYXJkd2FyZVdhbGxldHMoKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPVxuICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuZ2V0TGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuICAgIGNvbnN0IG5ld1ZhbHVlID1cbiAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnNldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UodHJhbnNwb3J0VHlwZSk7XG5cbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5nZXRLZXlyaW5nRm9yRGV2aWNlKEhhcmR3YXJlRGV2aWNlTmFtZXMubGVkZ2VyKTtcbiAgICBpZiAoa2V5cmluZz8udXBkYXRlVHJhbnNwb3J0TWV0aG9kKSB7XG4gICAgICByZXR1cm4ga2V5cmluZy51cGRhdGVUcmFuc3BvcnRNZXRob2QobmV3VmFsdWUpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBlcnJvciB1cGRhdGluZyB0aGUgdHJhbnNwb3J0LCB3ZSBzaG91bGRcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZVxuICAgICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlKGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIGZvciBpbml0aWFsaXppbmcgc3RvcmFnZSB0aGUgZmlyc3QgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluaXRTdGF0ZSAtIFRoZSBkZWZhdWx0IHN0YXRlIHRvIGluaXRpYWxpemUgd2l0aC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlY29yZEZpcnN0VGltZUluZm8oaW5pdFN0YXRlKSB7XG4gICAgaWYgKCEoJ2ZpcnN0VGltZUluZm8nIGluIGluaXRTdGF0ZSkpIHtcbiAgICAgIGNvbnN0IHZlcnNpb24gPSB0aGlzLnBsYXRmb3JtLmdldFZlcnNpb24oKTtcbiAgICAgIGluaXRTdGF0ZS5maXJzdFRpbWVJbmZvID0ge1xuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBkYXRlOiBEYXRlLm5vdygpLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBSZXBsYWNlIGlzQ2xpZW50T3BlbiBtZXRob2RzIHdpdGggYGNvbnRyb2xsZXJDb25uZWN0aW9uQ2hhbmdlZGAgZXZlbnRzLlxuICAvKiBlc2xpbnQtZGlzYWJsZSBhY2Nlc3Nvci1wYWlycyAqL1xuICAvKipcbiAgICogQSBtZXRob2QgZm9yIHJlY29yZGluZyB3aGV0aGVyIHRoZSBNZXRhTWFzayB1c2VyIGludGVyZmFjZSBpcyBvcGVuIG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBvcGVuXG4gICAqL1xuICBzZXQgaXNDbGllbnRPcGVuKG9wZW4pIHtcbiAgICB0aGlzLl9pc0NsaWVudE9wZW4gPSBvcGVuO1xuICAgIHRoaXMuZGV0ZWN0VG9rZW5zQ29udHJvbGxlci5pc09wZW4gPSBvcGVuO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgYWNjZXNzb3ItcGFpcnMgKi9cblxuICAvKipcbiAgICogQSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgYnkgdGhlIGJhY2tncm91bmQgd2hlbiBhbGwgaW5zdGFuY2VzIG9mIG1ldGFtYXNrIGFyZSBjbG9zZWQuXG4gICAqIEN1cnJlbnRseSB1c2VkIHRvIHN0b3AgcG9sbGluZyBpbiB0aGUgZ2FzRmVlQ29udHJvbGxlci5cbiAgICovXG4gIG9uQ2xpZW50Q2xvc2VkKCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmdhc0ZlZUNvbnRyb2xsZXIuc3RvcFBvbGxpbmcoKTtcbiAgICAgIHRoaXMuYXBwU3RhdGVDb250cm9sbGVyLmNsZWFyUG9sbGluZ1Rva2VucygpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgYnkgdGhlIGJhY2tncm91bmQgd2hlbiBhIHBhcnRpY3VsYXIgZW52aXJvbm1lbnQgdHlwZSBpcyBjbG9zZWQgKGZ1bGxzY3JlZW4sIHBvcHVwLCBub3RpZmljYXRpb24pLlxuICAgKiBDdXJyZW50bHkgdXNlZCB0byBzdG9wIHBvbGxpbmcgaW4gdGhlIGdhc0ZlZUNvbnRyb2xsZXIgZm9yIG9ubHkgdGhhdCBlbnZpcm9uZW1lbnQgdHlwZVxuICAgKlxuICAgKiBAcGFyYW0gZW52aXJvbm1lbnRUeXBlXG4gICAqL1xuICBvbkVudmlyb25tZW50VHlwZUNsb3NlZChlbnZpcm9ubWVudFR5cGUpIHtcbiAgICBjb25zdCBhcHBTdGF0ZVBvbGxpbmdUb2tlblR5cGUgPVxuICAgICAgUE9MTElOR19UT0tFTl9FTlZJUk9OTUVOVF9UWVBFU1tlbnZpcm9ubWVudFR5cGVdO1xuICAgIGNvbnN0IHBvbGxpbmdUb2tlbnNUb0Rpc2Nvbm5lY3QgPVxuICAgICAgdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKVthcHBTdGF0ZVBvbGxpbmdUb2tlblR5cGVdO1xuICAgIHBvbGxpbmdUb2tlbnNUb0Rpc2Nvbm5lY3QuZm9yRWFjaCgocG9sbGluZ1Rva2VuKSA9PiB7XG4gICAgICB0aGlzLmdhc0ZlZUNvbnRyb2xsZXIuZGlzY29ubmVjdFBvbGxlcihwb2xsaW5nVG9rZW4pO1xuICAgICAgdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIucmVtb3ZlUG9sbGluZ1Rva2VuKFxuICAgICAgICBwb2xsaW5nVG9rZW4sXG4gICAgICAgIGFwcFN0YXRlUG9sbGluZ1Rva2VuVHlwZSxcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGRvbWFpbiB0byB0aGUgUGhpc2hpbmdDb250cm9sbGVyIHNhZmVsaXN0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBob3N0bmFtZSAtIHRoZSBkb21haW4gdG8gc2FmZWxpc3RcbiAgICovXG4gIHNhZmVsaXN0UGhpc2hpbmdEb21haW4oaG9zdG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5waGlzaGluZ0NvbnRyb2xsZXIuYnlwYXNzKGhvc3RuYW1lKTtcbiAgfVxuXG4gIGFzeW5jIGJhY2tUb1NhZmV0eVBoaXNoaW5nV2FybmluZygpIHtcbiAgICBjb25zdCBleHRlbnNpb25VUkwgPSB0aGlzLnBsYXRmb3JtLmdldEV4dGVuc2lvblVSTCgpO1xuICAgIGF3YWl0IHRoaXMucGxhdGZvcm0uc3dpdGNoVG9Bbm90aGVyVVJMKHVuZGVmaW5lZCwgZXh0ZW5zaW9uVVJMKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2NrcyBNZXRhTWFza1xuICAgKi9cbiAgc2V0TG9ja2VkKCkge1xuICAgIGNvbnN0IFt0cmV6b3JLZXlyaW5nXSA9IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ3NCeVR5cGUoXG4gICAgICBLZXlyaW5nVHlwZS50cmV6b3IsXG4gICAgKTtcbiAgICBpZiAodHJlem9yS2V5cmluZykge1xuICAgICAgdHJlem9yS2V5cmluZy5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgW2xlZGdlcktleXJpbmddID0gdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRLZXlyaW5nc0J5VHlwZShcbiAgICAgIEtleXJpbmdUeXBlLmxlZGdlcixcbiAgICApO1xuICAgIGxlZGdlcktleXJpbmc/LmRlc3Ryb3k/LigpO1xuXG4gICAgaWYgKGlzTWFuaWZlc3RWMykge1xuICAgICAgdGhpcy5jbGVhckxvZ2luQXJ0aWZhY3RzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuc2V0TG9ja2VkKCk7XG4gIH1cblxuICByZW1vdmVQZXJtaXNzaW9uc0ZvciA9IChzdWJqZWN0cykgPT4ge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLnJldm9rZVBlcm1pc3Npb25zKHN1YmplY3RzKTtcbiAgICB9IGNhdGNoIChleHApIHtcbiAgICAgIGlmICghKGV4cCBpbnN0YW5jZW9mIFBlcm1pc3Npb25zUmVxdWVzdE5vdEZvdW5kRXJyb3IpKSB7XG4gICAgICAgIHRocm93IGV4cDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cblxuICByZWplY3RQZXJtaXNzaW9uc1JlcXVlc3QgPSAocmVxdWVzdElkKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIucmVqZWN0UGVybWlzc2lvbnNSZXF1ZXN0KHJlcXVlc3RJZCk7XG4gICAgfSBjYXRjaCAoZXhwKSB7XG4gICAgICBpZiAoIShleHAgaW5zdGFuY2VvZiBQZXJtaXNzaW9uc1JlcXVlc3ROb3RGb3VuZEVycm9yKSkge1xuICAgICAgICB0aHJvdyBleHA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGFjY2VwdFBlcm1pc3Npb25zUmVxdWVzdCA9IChyZXF1ZXN0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIuYWNjZXB0UGVybWlzc2lvbnNSZXF1ZXN0KHJlcXVlc3QpO1xuICAgIH0gY2F0Y2ggKGV4cCkge1xuICAgICAgaWYgKCEoZXhwIGluc3RhbmNlb2YgUGVybWlzc2lvbnNSZXF1ZXN0Tm90Rm91bmRFcnJvcikpIHtcbiAgICAgICAgdGhyb3cgZXhwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXNvbHZlUGVuZGluZ0FwcHJvdmFsID0gKGlkLCB2YWx1ZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5hY2NlcHQoaWQsIHZhbHVlKTtcbiAgICB9IGNhdGNoIChleHApIHtcbiAgICAgIGlmICghKGV4cCBpbnN0YW5jZW9mIEFwcHJvdmFsUmVxdWVzdE5vdEZvdW5kRXJyb3IpKSB7XG4gICAgICAgIHRocm93IGV4cDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmVqZWN0UGVuZGluZ0FwcHJvdmFsID0gKGlkLCBlcnJvcikgPT4ge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5yZWplY3QoXG4gICAgICAgIGlkLFxuICAgICAgICBuZXcgRXRoZXJldW1ScGNFcnJvcihlcnJvci5jb2RlLCBlcnJvci5tZXNzYWdlLCBlcnJvci5kYXRhKSxcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXhwKSB7XG4gICAgICBpZiAoIShleHAgaW5zdGFuY2VvZiBBcHByb3ZhbFJlcXVlc3ROb3RGb3VuZEVycm9yKSkge1xuICAgICAgICB0aHJvdyBleHA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGFzeW5jIHNlY3VyaXR5UHJvdmlkZXJSZXF1ZXN0KHJlcXVlc3REYXRhLCBtZXRob2ROYW1lKSB7XG4gICAgY29uc3QgeyBjdXJyZW50TG9jYWxlLCB0cmFuc2FjdGlvblNlY3VyaXR5Q2hlY2tFbmFibGVkIH0gPVxuICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgIGlmICh0cmFuc2FjdGlvblNlY3VyaXR5Q2hlY2tFbmFibGVkKSB7XG4gICAgICBjb25zdCBjaGFpbklkID0gTnVtYmVyKFxuICAgICAgICBoZXhUb0RlY2ltYWwoXG4gICAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLnByb3ZpZGVyQ29uZmlnLmNoYWluSWQsXG4gICAgICAgICksXG4gICAgICApO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzZWN1cml0eVByb3ZpZGVyUmVzcG9uc2UgPSBhd2FpdCBzZWN1cml0eVByb3ZpZGVyQ2hlY2soXG4gICAgICAgICAgcmVxdWVzdERhdGEsXG4gICAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgIGN1cnJlbnRMb2NhbGUsXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHNlY3VyaXR5UHJvdmlkZXJSZXNwb25zZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cuZXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSAyO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBpZiAodmVyc2lvbmVkRGF0YS5kYXRhLmNvbmZpZy5wcm92aWRlci50eXBlID09PSAnZXRoZXJzY2FuJykge1xuICAgICAgICB2ZXJzaW9uZWREYXRhLmRhdGEuY29uZmlnLnByb3ZpZGVyLnR5cGUgPSAncnBjJztcbiAgICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhLmNvbmZpZy5wcm92aWRlci5ycGNUYXJnZXQgPVxuICAgICAgICAgICdodHRwczovL3JwYy5tZXRhbWFzay5pby8nO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIC8vIGVtcHR5XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XG4gIH0sXG59O1xuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDM7XG5jb25zdCBvbGRUZXN0UnBjID0gJ2h0dHBzOi8vcmF3dGVzdHJwYy5tZXRhbWFzay5pby8nO1xuY29uc3QgbmV3VGVzdFJwYyA9ICdodHRwczovL3Rlc3RycGMubWV0YW1hc2suaW8vJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgaWYgKHZlcnNpb25lZERhdGEuZGF0YS5jb25maWcucHJvdmlkZXIucnBjVGFyZ2V0ID09PSBvbGRUZXN0UnBjKSB7XG4gICAgICAgIHZlcnNpb25lZERhdGEuZGF0YS5jb25maWcucHJvdmlkZXIucnBjVGFyZ2V0ID0gbmV3VGVzdFJwYztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAvLyBlbXB0eVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA0O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZSh2ZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3Qgc2FmZVZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAodmVyc2lvbmVkRGF0YSk7XG4gICAgc2FmZVZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgaWYgKHNhZmVWZXJzaW9uZWREYXRhLmRhdGEuY29uZmlnLnByb3ZpZGVyLnR5cGUgIT09ICdycGMnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2FmZVZlcnNpb25lZERhdGEpO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChzYWZlVmVyc2lvbmVkRGF0YS5kYXRhLmNvbmZpZy5wcm92aWRlci5ycGNUYXJnZXQpIHtcbiAgICAgICAgY2FzZSAnaHR0cHM6Ly90ZXN0cnBjLm1ldGFtYXNrLmlvLyc6XG4gICAgICAgICAgc2FmZVZlcnNpb25lZERhdGEuZGF0YS5jb25maWcucHJvdmlkZXIgPSB7XG4gICAgICAgICAgICB0eXBlOiAndGVzdG5ldCcsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaHR0cHM6Ly9ycGMubWV0YW1hc2suaW8vJzpcbiAgICAgICAgICBzYWZlVmVyc2lvbmVkRGF0YS5kYXRhLmNvbmZpZy5wcm92aWRlciA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdtYWlubmV0JyxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBObyBkZWZhdWx0XG4gICAgICB9XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgLy8gZW1wdHlcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzYWZlVmVyc2lvbmVkRGF0YSk7XG4gIH0sXG59O1xuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gbW92ZXMgc3RhdGUgZnJvbSB0aGUgZmxhdCBzdGF0ZSB0cmllIGludG8gS2V5cmluZ0NvbnRyb2xsZXIgc3Vic3RhdGVcblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDU7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSBzZWxlY3RTdWJzdGF0ZUZvcktleXJpbmdDb250cm9sbGVyKHN0YXRlKTtcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIzUke2Vyci5zdGFja31gKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHNlbGVjdFN1YnN0YXRlRm9yS2V5cmluZ0NvbnRyb2xsZXIoc3RhdGUpIHtcbiAgY29uc3QgeyBjb25maWcgfSA9IHN0YXRlO1xuICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBLZXlyaW5nQ29udHJvbGxlcjoge1xuICAgICAgdmF1bHQ6IHN0YXRlLnZhdWx0LFxuICAgICAgc2VsZWN0ZWRBY2NvdW50OiBjb25maWcuc2VsZWN0ZWRBY2NvdW50LFxuICAgICAgd2FsbGV0Tmlja25hbWVzOiBzdGF0ZS53YWxsZXROaWNrbmFtZXMsXG4gICAgfSxcbiAgfTtcbiAgZGVsZXRlIG5ld1N0YXRlLnZhdWx0O1xuICBkZWxldGUgbmV3U3RhdGUud2FsbGV0Tmlja25hbWVzO1xuICBkZWxldGUgbmV3U3RhdGUuY29uZmlnLnNlbGVjdGVkQWNjb3VudDtcblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCIvKlxuXG5UaGlzIG1pZ3JhdGlvbiBtb3ZlcyBLZXlyaW5nQ29udHJvbGxlci5zZWxlY3RlZEFkZHJlc3MgdG8gUHJlZmVyZW5jZXNDb250cm9sbGVyLnNlbGVjdGVkQWRkcmVzc1xuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IG1pZ3JhdGVTdGF0ZShzdGF0ZSk7XG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiBtaWdyYXRlU3RhdGUoc3RhdGUpIHtcbiAgY29uc3Qga2V5cmluZ1N1YnN0YXRlID0gc3RhdGUuS2V5cmluZ0NvbnRyb2xsZXI7XG5cbiAgLy8gYWRkIG5ldyBzdGF0ZVxuICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXI6IHtcbiAgICAgIHNlbGVjdGVkQWRkcmVzczoga2V5cmluZ1N1YnN0YXRlLnNlbGVjdGVkQWNjb3VudCxcbiAgICB9LFxuICB9O1xuXG4gIC8vIHJtIG9sZCBzdGF0ZVxuICBkZWxldGUgbmV3U3RhdGUuS2V5cmluZ0NvbnRyb2xsZXIuc2VsZWN0ZWRBY2NvdW50O1xuXG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsIi8qXG5cblRoaXMgbWlncmF0aW9uIGJyZWFrcyBvdXQgdGhlIFRyYW5zYWN0aW9uTWFuYWdlciBzdWJzdGF0ZVxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNztcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIFRyYW5zYWN0aW9uTWFuYWdlcjoge1xuICAgICAgdHJhbnNhY3Rpb25zOiBzdGF0ZS50cmFuc2FjdGlvbnMgfHwgW10sXG4gICAgICBnYXNNdWx0aXBsaWVyOiBzdGF0ZS5nYXNNdWx0aXBsaWVyIHx8IDEsXG4gICAgfSxcbiAgfTtcbiAgZGVsZXRlIG5ld1N0YXRlLnRyYW5zYWN0aW9ucztcbiAgZGVsZXRlIG5ld1N0YXRlLmdhc011bHRpcGxpZXI7XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gYnJlYWtzIG91dCB0aGUgTm90aWNlQ29udHJvbGxlciBzdWJzdGF0ZVxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gODtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIE5vdGljZUNvbnRyb2xsZXI6IHtcbiAgICAgIG5vdGljZXNMaXN0OiBzdGF0ZS5ub3RpY2VzTGlzdCB8fCBbXSxcbiAgICB9LFxuICB9O1xuICBkZWxldGUgbmV3U3RhdGUubm90aWNlc0xpc3Q7XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gYnJlYWtzIG91dCB0aGUgQ3VycmVuY3lDb250cm9sbGVyIHN1YnN0YXRlXG5cbiovXG5cbmltcG9ydCB7IGNsb25lRGVlcCwgbWVyZ2UgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gOTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5ld1N0YXRlID0gbWVyZ2Uoe30sIHN0YXRlLCB7XG4gICAgQ3VycmVuY3lDb250cm9sbGVyOiB7XG4gICAgICBjdXJyZW50Q3VycmVuY3k6IHN0YXRlLmN1cnJlbnRGaWF0IHx8IHN0YXRlLmZpYXRDdXJyZW5jeSB8fCAnVVNEJyxcbiAgICAgIGNvbnZlcnNpb25SYXRlOiBzdGF0ZS5jb252ZXJzaW9uUmF0ZSxcbiAgICAgIGNvbnZlcnNpb25EYXRlOiBzdGF0ZS5jb252ZXJzaW9uRGF0ZSxcbiAgICB9LFxuICB9KTtcbiAgZGVsZXRlIG5ld1N0YXRlLmN1cnJlbnRGaWF0O1xuICBkZWxldGUgbmV3U3RhdGUuZmlhdEN1cnJlbmN5O1xuICBkZWxldGUgbmV3U3RhdGUuY29udmVyc2lvblJhdGU7XG4gIGRlbGV0ZSBuZXdTdGF0ZS5jb252ZXJzaW9uRGF0ZTtcblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCIvKlxuXG5UaGlzIG1pZ3JhdGlvbiBicmVha3Mgb3V0IHRoZSBTaGFwZVNoaWZ0Q29udHJvbGxlciBzdWJzdGF0ZVxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAsIG1lcmdlIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDEwO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBtZXJnZSh7fSwgc3RhdGUsIHtcbiAgICBTaGFwZVNoaWZ0Q29udHJvbGxlcjoge1xuICAgICAgc2hhcGVTaGlmdFR4TGlzdDogc3RhdGUuc2hhcGVTaGlmdFR4TGlzdCB8fCBbXSxcbiAgICB9LFxuICB9KTtcbiAgZGVsZXRlIG5ld1N0YXRlLnNoYXBlU2hpZnRUeExpc3Q7XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gcmVtb3ZlcyB0aGUgZGlzY2FpbWVyIHN0YXRlIGZyb20gb3VyIGFwcCwgd2hpY2ggd2FzIGludGVncmF0ZWQgaW50byBvdXIgbm90aWNlcy5cblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDExO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgZGVsZXRlIG5ld1N0YXRlLlRPU0hhc2g7XG4gIGRlbGV0ZSBuZXdTdGF0ZS5pc0Rpc2NsYWltZXJDb25maXJtZWQ7XG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsIi8qXG5cblRoaXMgbWlncmF0aW9uIG1vZGlmaWVzIG91ciBub3RpY2VzIHRvIGRlbGV0ZSB0aGVpciBib2R5IGFmdGVyIGJlaW5nIHJlYWQuXG5cbiovXG5cbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSAxMjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XG4gIG5ld1N0YXRlLk5vdGljZUNvbnRyb2xsZXIubm90aWNlc0xpc3QuZm9yRWFjaCgobm90aWNlKSA9PiB7XG4gICAgaWYgKG5vdGljZS5yZWFkKSB7XG4gICAgICBub3RpY2UuYm9keSA9ICcnO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsIi8qXG5cblRoaXMgbWlncmF0aW9uIG1vZGlmaWVzIHRoZSBuZXR3b3JrIGNvbmZpZyBmcm9tIGFtYmlndW91cyAndGVzdG5ldCcgdG8gZXhwbGljaXQgJ3JvcHN0ZW4nXG5cbiovXG5cbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSAxMztcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XG4gIGNvbnN0IHsgY29uZmlnIH0gPSBuZXdTdGF0ZTtcbiAgaWYgKGNvbmZpZyAmJiBjb25maWcucHJvdmlkZXIpIHtcbiAgICBpZiAoY29uZmlnLnByb3ZpZGVyLnR5cGUgPT09ICd0ZXN0bmV0Jykge1xuICAgICAgbmV3U3RhdGUuY29uZmlnLnByb3ZpZGVyLnR5cGUgPSAncm9wc3Rlbic7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsIi8qXG5cblRoaXMgbWlncmF0aW9uIHJlbW92ZXMgcHJvdmlkZXIgZnJvbSBjb25maWcgYW5kIG1vdmVzIGl0IHRvbyBOZXR3b3JrQ29udHJvbGxlci5cblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDE0O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgbmV3U3RhdGUuTmV0d29ya0NvbnRyb2xsZXIgPSB7fTtcbiAgbmV3U3RhdGUuTmV0d29ya0NvbnRyb2xsZXIucHJvdmlkZXIgPSBuZXdTdGF0ZS5jb25maWcucHJvdmlkZXI7XG4gIGRlbGV0ZSBuZXdTdGF0ZS5jb25maWcucHJvdmlkZXI7XG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsIi8qXG5cblRoaXMgbWlncmF0aW9uIHNldHMgdHJhbnNhY3Rpb25zIHdpdGggdGhlICdHYXZlIHVwIHN1Ym1pdHRpbmcgdHguJyBlcnIgbWVzc2FnZVxudG8gYSAnZmFpbGVkJyBzdGF0ZWRcblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uU3RhdHVzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5cbmNvbnN0IHZlcnNpb24gPSAxNTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XG4gIGNvbnN0IHsgVHJhbnNhY3Rpb25Db250cm9sbGVyIH0gPSBuZXdTdGF0ZTtcbiAgaWYgKFRyYW5zYWN0aW9uQ29udHJvbGxlciAmJiBUcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zKSB7XG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IFRyYW5zYWN0aW9uQ29udHJvbGxlcjtcbiAgICBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zLm1hcCgodHhNZXRhKSA9PiB7XG4gICAgICBpZiAoIXR4TWV0YS5lcnIpIHtcbiAgICAgICAgcmV0dXJuIHR4TWV0YTtcbiAgICAgIH0gZWxzZSBpZiAodHhNZXRhLmVyci5tZXNzYWdlID09PSAnR2F2ZSB1cCBzdWJtaXR0aW5nIHR4LicpIHtcbiAgICAgICAgdHhNZXRhLnN0YXR1cyA9IFRyYW5zYWN0aW9uU3RhdHVzLmZhaWxlZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eE1ldGE7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gc2V0cyB0cmFuc2FjdGlvbnMgd2l0aCB0aGUgJ0dhdmUgdXAgc3VibWl0dGluZyB0eC4nIGVyciBtZXNzYWdlXG50byBhICdmYWlsZWQnIHN0YXRlZFxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25TdGF0dXMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcblxuY29uc3QgdmVyc2lvbiA9IDE2O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgY29uc3QgeyBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgfSA9IG5ld1N0YXRlO1xuICBpZiAoVHJhbnNhY3Rpb25Db250cm9sbGVyICYmIFRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyO1xuXG4gICAgbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5tYXAoKHR4TWV0YSkgPT4ge1xuICAgICAgaWYgKCF0eE1ldGEuZXJyKSB7XG4gICAgICAgIHJldHVybiB0eE1ldGE7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIHR4TWV0YS5lcnIgPT09ICd0cmFuc2FjdGlvbiB3aXRoIHRoZSBzYW1lIGhhc2ggd2FzIGFscmVhZHkgaW1wb3J0ZWQuJ1xuICAgICAgKSB7XG4gICAgICAgIHR4TWV0YS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5zdWJtaXR0ZWQ7XG4gICAgICAgIGRlbGV0ZSB0eE1ldGEuZXJyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR4TWV0YTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCIvKlxuXG5UaGlzIG1pZ3JhdGlvbiBzZXRzIHRyYW5zYWN0aW9ucyB3aG8gd2VyZSByZXRyaWVkIGFuZCBtYXJrZWQgYXMgZmFpbGVkIHRvIHN1Ym1pdHRlZFxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25TdGF0dXMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcblxuY29uc3QgdmVyc2lvbiA9IDE3O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgY29uc3QgeyBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgfSA9IG5ld1N0YXRlO1xuICBpZiAoVHJhbnNhY3Rpb25Db250cm9sbGVyICYmIFRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyO1xuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKCh0eE1ldGEpID0+IHtcbiAgICAgIGlmICghdHhNZXRhLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuZmFpbGVkKSB7XG4gICAgICAgIHJldHVybiB0eE1ldGE7XG4gICAgICB9XG4gICAgICBpZiAodHhNZXRhLnJldHJ5Q291bnQgPiAwICYmIHR4TWV0YS5yZXRyeUNvdW50IDwgMikge1xuICAgICAgICB0eE1ldGEuc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuc3VibWl0dGVkO1xuICAgICAgICBkZWxldGUgdHhNZXRhLmVycjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eE1ldGE7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gdXBkYXRlcyBcInRyYW5zYWN0aW9uIHN0YXRlIGhpc3RvcnlcIiB0byBkaWZmcyBzdHlsZVxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHtcbiAgc25hcHNob3RGcm9tVHhNZXRhLFxuICBtaWdyYXRlRnJvbVNuYXBzaG90c1RvRGlmZnMsXG59IGZyb20gJy4uL2NvbnRyb2xsZXJzL3RyYW5zYWN0aW9ucy9saWIvdHgtc3RhdGUtaGlzdG9yeS1oZWxwZXJzJztcblxuY29uc3QgdmVyc2lvbiA9IDE4O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgY29uc3QgeyBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgfSA9IG5ld1N0YXRlO1xuICBpZiAoVHJhbnNhY3Rpb25Db250cm9sbGVyICYmIFRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyO1xuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKCh0eE1ldGEpID0+IHtcbiAgICAgIC8vIG5vIGhpc3Rvcnk6IGluaXRpYWxpemVcbiAgICAgIGlmICghdHhNZXRhLmhpc3RvcnkgfHwgdHhNZXRhLmhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IHNuYXBzaG90ID0gc25hcHNob3RGcm9tVHhNZXRhKHR4TWV0YSk7XG4gICAgICAgIHR4TWV0YS5oaXN0b3J5ID0gW3NuYXBzaG90XTtcbiAgICAgICAgcmV0dXJuIHR4TWV0YTtcbiAgICAgIH1cbiAgICAgIC8vIGhhcyBoaXN0b3J5OiBtaWdyYXRlXG4gICAgICBjb25zdCBuZXdIaXN0b3J5ID0gbWlncmF0ZUZyb21TbmFwc2hvdHNUb0RpZmZzKHR4TWV0YS5oaXN0b3J5KVxuICAgICAgICAvLyByZW1vdmUgZW1wdHkgZGlmZnNcbiAgICAgICAgLmZpbHRlcigoZW50cnkpID0+IHtcbiAgICAgICAgICByZXR1cm4gIUFycmF5LmlzQXJyYXkoZW50cnkpIHx8IGVudHJ5Lmxlbmd0aCA+IDA7XG4gICAgICAgIH0pO1xuICAgICAgdHhNZXRhLmhpc3RvcnkgPSBuZXdIaXN0b3J5O1xuICAgICAgcmV0dXJuIHR4TWV0YTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCIvKlxuXG5UaGlzIG1pZ3JhdGlvbiBzZXRzIHRyYW5zYWN0aW9ucyBhcyBmYWlsZWRcbndob3Mgbm9uY2UgaXMgdG9vIGhpZ2hcblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uU3RhdHVzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5cbmNvbnN0IHZlcnNpb24gPSAxOTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XG4gIGNvbnN0IHsgVHJhbnNhY3Rpb25Db250cm9sbGVyIH0gPSBuZXdTdGF0ZTtcbiAgaWYgKFRyYW5zYWN0aW9uQ29udHJvbGxlciAmJiBUcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zKSB7XG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcjtcblxuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKFxuICAgICAgKHR4TWV0YSwgXywgdHhMaXN0KSA9PiB7XG4gICAgICAgIGlmICh0eE1ldGEuc3RhdHVzICE9PSBUcmFuc2FjdGlvblN0YXR1cy5zdWJtaXR0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gdHhNZXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29uZmlybWVkVHhzID0gdHhMaXN0XG4gICAgICAgICAgLmZpbHRlcigodHgpID0+IHR4LnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuY29uZmlybWVkKVxuICAgICAgICAgIC5maWx0ZXIoKHR4KSA9PiB0eC50eFBhcmFtcy5mcm9tID09PSB0eE1ldGEudHhQYXJhbXMuZnJvbSlcbiAgICAgICAgICAuZmlsdGVyKFxuICAgICAgICAgICAgKHR4KSA9PiB0eC5tZXRhbWFza05ldHdvcmtJZC5mcm9tID09PSB0eE1ldGEubWV0YW1hc2tOZXR3b3JrSWQuZnJvbSxcbiAgICAgICAgICApO1xuICAgICAgICBjb25zdCBoaWdoZXN0Q29uZmlybWVkTm9uY2UgPSBnZXRIaWdoZXN0Tm9uY2UoY29uZmlybWVkVHhzKTtcblxuICAgICAgICBjb25zdCBwZW5kaW5nVHhzID0gdHhMaXN0XG4gICAgICAgICAgLmZpbHRlcigodHgpID0+IHR4LnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuc3VibWl0dGVkKVxuICAgICAgICAgIC5maWx0ZXIoKHR4KSA9PiB0eC50eFBhcmFtcy5mcm9tID09PSB0eE1ldGEudHhQYXJhbXMuZnJvbSlcbiAgICAgICAgICAuZmlsdGVyKFxuICAgICAgICAgICAgKHR4KSA9PiB0eC5tZXRhbWFza05ldHdvcmtJZC5mcm9tID09PSB0eE1ldGEubWV0YW1hc2tOZXR3b3JrSWQuZnJvbSxcbiAgICAgICAgICApO1xuICAgICAgICBjb25zdCBoaWdoZXN0Q29udGludW91c05vbmNlID0gZ2V0SGlnaGVzdENvbnRpbnVvdXNGcm9tKFxuICAgICAgICAgIHBlbmRpbmdUeHMsXG4gICAgICAgICAgaGlnaGVzdENvbmZpcm1lZE5vbmNlLFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IG1heE5vbmNlID0gTWF0aC5tYXgoXG4gICAgICAgICAgaGlnaGVzdENvbnRpbnVvdXNOb25jZSxcbiAgICAgICAgICBoaWdoZXN0Q29uZmlybWVkTm9uY2UsXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHBhcnNlSW50KHR4TWV0YS50eFBhcmFtcy5ub25jZSwgMTYpID4gbWF4Tm9uY2UgKyAxKSB7XG4gICAgICAgICAgdHhNZXRhLnN0YXR1cyA9IFRyYW5zYWN0aW9uU3RhdHVzLmZhaWxlZDtcbiAgICAgICAgICB0eE1ldGEuZXJyID0ge1xuICAgICAgICAgICAgbWVzc2FnZTogJ25vbmNlIHRvbyBoaWdoJyxcbiAgICAgICAgICAgIG5vdGU6ICdtaWdyYXRpb24gMDE5IGN1c3RvbSBlcnJvcicsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHhNZXRhO1xuICAgICAgfSxcbiAgICApO1xuICB9XG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0SGlnaGVzdENvbnRpbnVvdXNGcm9tKHR4TGlzdCwgc3RhcnRQb2ludCkge1xuICBjb25zdCBub25jZXMgPSB0eExpc3QubWFwKCh0eE1ldGEpID0+IHtcbiAgICBjb25zdCB7IG5vbmNlIH0gPSB0eE1ldGEudHhQYXJhbXM7XG4gICAgcmV0dXJuIHBhcnNlSW50KG5vbmNlLCAxNik7XG4gIH0pO1xuXG4gIGxldCBoaWdoZXN0ID0gc3RhcnRQb2ludDtcbiAgd2hpbGUgKG5vbmNlcy5pbmNsdWRlcyhoaWdoZXN0KSkge1xuICAgIGhpZ2hlc3QgKz0gMTtcbiAgfVxuXG4gIHJldHVybiBoaWdoZXN0O1xufVxuXG5mdW5jdGlvbiBnZXRIaWdoZXN0Tm9uY2UodHhMaXN0KSB7XG4gIGNvbnN0IG5vbmNlcyA9IHR4TGlzdC5tYXAoKHR4TWV0YSkgPT4ge1xuICAgIGNvbnN0IHsgbm9uY2UgfSA9IHR4TWV0YS50eFBhcmFtcztcbiAgICByZXR1cm4gcGFyc2VJbnQobm9uY2UgfHwgJzB4MCcsIDE2KTtcbiAgfSk7XG4gIGNvbnN0IGhpZ2hlc3ROb25jZSA9IE1hdGgubWF4LmFwcGx5KG51bGwsIG5vbmNlcyk7XG4gIHJldHVybiBoaWdoZXN0Tm9uY2U7XG59XG4iLCIvKlxuXG5UaGlzIG1pZ3JhdGlvbiBlbnN1cmVzIHByZXZpb3VzIGluc3RhbGxhdGlvbnNcbmdldCBhIGBmaXJzdFRpbWVJbmZvYCBrZXkgb24gdGhlIG1ldGFtYXNrIHN0YXRlLFxuc28gdGhhdCB3ZSBjYW4gdmVyc2lvbiBub3RpY2VzIGluIHRoZSBmdXR1cmUuXG5cbiovXG5cbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSAyMDtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XG4gIGlmICgnbWV0YW1hc2snIGluIG5ld1N0YXRlICYmICEoJ2ZpcnN0VGltZUluZm8nIGluIG5ld1N0YXRlLm1ldGFtYXNrKSkge1xuICAgIG5ld1N0YXRlLm1ldGFtYXNrLmZpcnN0VGltZUluZm8gPSB7XG4gICAgICB2ZXJzaW9uOiAnMy4xMi4wJyxcbiAgICAgIGRhdGU6IERhdGUubm93KCksXG4gICAgfTtcbiAgfVxuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCIvKlxuXG5UaGlzIG1pZ3JhdGlvbiByZW1vdmVzIHRoZSBCbGFja0xpc3RDb250cm9sbGVyIGZyb20gZGlzayBzdGF0ZVxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gMjE7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xuICBkZWxldGUgbmV3U3RhdGUuQmxhY2tsaXN0Q29udHJvbGxlcjtcbiAgZGVsZXRlIG5ld1N0YXRlLlJlY2VudEJsb2NrcztcbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gYWRkcyBzdWJtaXR0ZWRUaW1lIHRvIHRoZSB0eE1ldGEgaWYgaXQgaXMgbm90IHRoZWlyXG5cbiovXG5cbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvblN0YXR1cyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuXG5jb25zdCB2ZXJzaW9uID0gMjI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xuICBjb25zdCB7IFRyYW5zYWN0aW9uQ29udHJvbGxlciB9ID0gbmV3U3RhdGU7XG4gIGlmIChUcmFuc2FjdGlvbkNvbnRyb2xsZXIgJiYgVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucykge1xuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXI7XG5cbiAgICBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zLm1hcCgodHhNZXRhKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIHR4TWV0YS5zdGF0dXMgIT09IFRyYW5zYWN0aW9uU3RhdHVzLnN1Ym1pdHRlZCB8fFxuICAgICAgICB0eE1ldGEuc3VibWl0dGVkVGltZVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0eE1ldGE7XG4gICAgICB9XG4gICAgICB0eE1ldGEuc3VibWl0dGVkVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgcmV0dXJuIHR4TWV0YTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCIvKlxuXG5UaGlzIG1pZ3JhdGlvbiByZW1vdmVzIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBubyBsb25nZXIgdXNlZnVsbCBkb3duIHRvIDQwIHRvdGFsXG5cbiovXG5cbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvblN0YXR1cyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuXG5jb25zdCB2ZXJzaW9uID0gMjM7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xuXG4gIGNvbnN0IHsgVHJhbnNhY3Rpb25Db250cm9sbGVyIH0gPSBuZXdTdGF0ZTtcbiAgaWYgKFRyYW5zYWN0aW9uQ29udHJvbGxlciAmJiBUcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zKSB7XG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcjtcblxuICAgIGlmICh0cmFuc2FjdGlvbnMubGVuZ3RoIDw9IDQwKSB7XG4gICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgfVxuXG4gICAgY29uc3QgcmV2ZXJzZVR4TGlzdCA9IHRyYW5zYWN0aW9ucy5yZXZlcnNlKCk7XG4gICAgbGV0IHN0cmlwcGluZyA9IHRydWU7XG4gICAgd2hpbGUgKHJldmVyc2VUeExpc3QubGVuZ3RoID4gNDAgJiYgc3RyaXBwaW5nKSB7XG4gICAgICBjb25zdCB0eEluZGV4ID0gcmV2ZXJzZVR4TGlzdC5maW5kSW5kZXgoKHR4TWV0YSkgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHR4TWV0YS5zdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLmZhaWxlZCB8fFxuICAgICAgICAgIHR4TWV0YS5zdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLnJlamVjdGVkIHx8XG4gICAgICAgICAgdHhNZXRhLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuY29uZmlybWVkIHx8XG4gICAgICAgICAgdHhNZXRhLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuZHJvcHBlZFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgICBpZiAodHhJbmRleCA8IDApIHtcbiAgICAgICAgc3RyaXBwaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXZlcnNlVHhMaXN0LnNwbGljZSh0eEluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zID0gcmV2ZXJzZVR4TGlzdC5yZXZlcnNlKCk7XG4gIH1cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gZW5zdXJlcyB0aGF0IHRoZSBmcm9tIGFkZHJlc3MgaW4gdHhQYXJhbXMgaXMgdG8gbG93ZXIgY2FzZSBmb3JcbmFsbCB1bmFwcHJvdmVkIHRyYW5zYWN0aW9uc1xuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25TdGF0dXMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcblxuY29uc3QgdmVyc2lvbiA9IDI0O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgaWYgKCFuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIpIHtcbiAgICByZXR1cm4gbmV3U3RhdGU7XG4gIH1cbiAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcjtcbiAgbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5tYXAoXG4gICAgKHR4TWV0YSwgXykgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICB0eE1ldGEuc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy51bmFwcHJvdmVkICYmXG4gICAgICAgIHR4TWV0YS50eFBhcmFtcyAmJlxuICAgICAgICB0eE1ldGEudHhQYXJhbXMuZnJvbVxuICAgICAgKSB7XG4gICAgICAgIHR4TWV0YS50eFBhcmFtcy5mcm9tID0gdHhNZXRhLnR4UGFyYW1zLmZyb20udG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eE1ldGE7XG4gICAgfSxcbiAgKTtcbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLy8gbmV4dCB2ZXJzaW9uIG51bWJlclxuLypcblxubm9ybWFsaXplcyB0eFBhcmFtcyBvbiB1bmNvbmZpcm1lZCB0eHNcblxuKi9cbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBhZGRIZXhQcmVmaXggfSBmcm9tICcuLi9saWIvdXRpbCc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvblN0YXR1cyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuXG5jb25zdCB2ZXJzaW9uID0gMjU7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xuXG4gIGlmIChuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIpIHtcbiAgICBpZiAobmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucykge1xuICAgICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcjtcbiAgICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKFxuICAgICAgICAodHhNZXRhKSA9PiB7XG4gICAgICAgICAgaWYgKHR4TWV0YS5zdGF0dXMgIT09IFRyYW5zYWN0aW9uU3RhdHVzLnVuYXBwcm92ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0eE1ldGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHR4TWV0YS50eFBhcmFtcyA9IG5vcm1hbGl6ZVR4UGFyYW1zKHR4TWV0YS50eFBhcmFtcyk7XG4gICAgICAgICAgcmV0dXJuIHR4TWV0YTtcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVUeFBhcmFtcyh0eFBhcmFtcykge1xuICAvLyBmdW5jdGlvbnMgdGhhdCBoYW5kbGUgbm9ybWFsaXppbmcgb2YgdGhhdCBrZXkgaW4gdHhQYXJhbXNcbiAgY29uc3Qgd2hpdGVMaXN0ID0ge1xuICAgIGZyb206IChmcm9tKSA9PiBhZGRIZXhQcmVmaXgoZnJvbSkudG9Mb3dlckNhc2UoKSxcbiAgICB0bzogKCkgPT4gYWRkSGV4UHJlZml4KHR4UGFyYW1zLnRvKS50b0xvd2VyQ2FzZSgpLFxuICAgIG5vbmNlOiAobm9uY2UpID0+IGFkZEhleFByZWZpeChub25jZSksXG4gICAgdmFsdWU6ICh2YWx1ZSkgPT4gYWRkSGV4UHJlZml4KHZhbHVlKSxcbiAgICBkYXRhOiAoZGF0YSkgPT4gYWRkSGV4UHJlZml4KGRhdGEpLFxuICAgIGdhczogKGdhcykgPT4gYWRkSGV4UHJlZml4KGdhcyksXG4gICAgZ2FzUHJpY2U6IChnYXNQcmljZSkgPT4gYWRkSGV4UHJlZml4KGdhc1ByaWNlKSxcbiAgfTtcblxuICAvLyBhcHBseSBvbmx5IGtleXMgaW4gdGhlIHdoaXRlTGlzdFxuICBjb25zdCBub3JtYWxpemVkVHhQYXJhbXMgPSB7fTtcbiAgT2JqZWN0LmtleXMod2hpdGVMaXN0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAodHhQYXJhbXNba2V5XSkge1xuICAgICAgbm9ybWFsaXplZFR4UGFyYW1zW2tleV0gPSB3aGl0ZUxpc3Rba2V5XSh0eFBhcmFtc1trZXldKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBub3JtYWxpemVkVHhQYXJhbXM7XG59XG4iLCIvKlxuXG5UaGlzIG1pZ3JhdGlvbiBtb3ZlcyB0aGUgaWRlbnRpdGllcyBzdG9yZWQgaW4gdGhlIEtleXJpbmdDb250cm9sbGVyXG4gaW50byB0aGUgUHJlZmVyZW5jZXNDb250cm9sbGVyXG5cbiovXG5cbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSAyNjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5LZXlyaW5nQ29udHJvbGxlciB8fCAhc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgaWYgKCFzdGF0ZS5LZXlyaW5nQ29udHJvbGxlci53YWxsZXROaWNrbmFtZXMpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuaWRlbnRpdGllcyA9IE9iamVjdC5rZXlzKFxuICAgIHN0YXRlLktleXJpbmdDb250cm9sbGVyLndhbGxldE5pY2tuYW1lcyxcbiAgKS5yZWR1Y2UoKGlkZW50aXRpZXMsIGFkZHJlc3MpID0+IHtcbiAgICBpZGVudGl0aWVzW2FkZHJlc3NdID0ge1xuICAgICAgbmFtZTogc3RhdGUuS2V5cmluZ0NvbnRyb2xsZXIud2FsbGV0Tmlja25hbWVzW2FkZHJlc3NdLFxuICAgICAgYWRkcmVzcyxcbiAgICB9O1xuICAgIHJldHVybiBpZGVudGl0aWVzO1xuICB9LCB7fSk7XG4gIGRlbGV0ZSBzdGF0ZS5LZXlyaW5nQ29udHJvbGxlci53YWxsZXROaWNrbmFtZXM7XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsIi8vIG5leHQgdmVyc2lvbiBudW1iZXJcbi8qXG5cbm5vcm1hbGl6ZXMgdHhQYXJhbXMgb24gdW5jb25maXJtZWQgdHhzXG5cbiovXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25TdGF0dXMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcblxuY29uc3QgdmVyc2lvbiA9IDI3O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcblxuICBpZiAobmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyKSB7XG4gICAgaWYgKG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcbiAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXI7XG4gICAgICBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zLmZpbHRlcihcbiAgICAgICAgKHR4TWV0YSkgPT4gdHhNZXRhLnN0YXR1cyAhPT0gVHJhbnNhY3Rpb25TdGF0dXMucmVqZWN0ZWQsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsIi8vIG5leHQgdmVyc2lvbiBudW1iZXJcbi8qXG5cbm5vcm1hbGl6ZXMgdHhQYXJhbXMgb24gdW5jb25maXJtZWQgdHhzXG5cbiovXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gMjg7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xuXG4gIGlmIChuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIpIHtcbiAgICBpZiAoXG4gICAgICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIudG9rZW5zICYmXG4gICAgICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuaWRlbnRpdGllc1xuICAgICkge1xuICAgICAgY29uc3QgeyBpZGVudGl0aWVzLCB0b2tlbnMgfSA9IG5ld1N0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcjtcbiAgICAgIG5ld1N0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5hY2NvdW50VG9rZW5zID0ge307XG4gICAgICBPYmplY3Qua2V5cyhpZGVudGl0aWVzKS5mb3JFYWNoKChpZGVudGl0eSkgPT4ge1xuICAgICAgICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWNjb3VudFRva2Vuc1tpZGVudGl0eV0gPSB7XG4gICAgICAgICAgbWFpbm5ldDogdG9rZW5zLFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIudG9rZW5zID0gW107XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLy8gbmV4dCB2ZXJzaW9uIG51bWJlclxuaW1wb3J0IHsgVHJhbnNhY3Rpb25TdGF0dXMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcbmltcG9ydCBmYWlsVHhzVGhhdCBmcm9tICcuL2ZhaWwtdHgnO1xuXG5jb25zdCB2ZXJzaW9uID0gMjk7XG5cbi8vIHRpbWVcbmNvbnN0IHNlY29uZHMgPSAxMDAwO1xuY29uc3QgbWludXRlcyA9IDYwICogc2Vjb25kcztcbmNvbnN0IGhvdXJzID0gNjAgKiBtaW51dGVzO1xuY29uc3QgdW5hY2NlcHRhYmxlRGVsYXkgPSAxMiAqIGhvdXJzO1xuXG4vKlxuXG5ub3JtYWxpemVzIHR4UGFyYW1zIG9uIHVuY29uZmlybWVkIHR4c1xuXG4qL1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZTogZmFpbFR4c1RoYXQoXG4gICAgdmVyc2lvbixcbiAgICAnU3R1Y2sgaW4gYXBwcm92ZWQgc3RhdGUgZm9yIHRvbyBsb25nLicsXG4gICAgKHR4TWV0YSkgPT4ge1xuICAgICAgY29uc3QgaXNBcHByb3ZlZCA9IHR4TWV0YS5zdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLmFwcHJvdmVkO1xuICAgICAgY29uc3QgY3JlYXRlZFRpbWUgPSB0eE1ldGEuc3VibWl0dGVkVGltZTtcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICByZXR1cm4gaXNBcHByb3ZlZCAmJiBub3cgLSBjcmVhdGVkVGltZSA+IHVuYWNjZXB0YWJsZURlbGF5O1xuICAgIH0sXG4gICksXG59O1xuIiwiLy8gbmV4dCB2ZXJzaW9uIG51bWJlclxuLypcblxucmVtb3ZlcyBpbnZhbGlkIGNoYWlkcyBmcm9tIHByZWZlcmVuY2VzIGFuZCBuZXR3b3JrQ29udHJvbGxlciBmb3IgY3VzdG9tIHJwY3NcblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDMwO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgaWYgKHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcikge1xuICAgIGNvbnN0IHsgZnJlcXVlbnRScGNMaXN0RGV0YWlsIH0gPSBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXI7XG4gICAgaWYgKGZyZXF1ZW50UnBjTGlzdERldGFpbCkge1xuICAgICAgZnJlcXVlbnRScGNMaXN0RGV0YWlsLmZvckVhY2goKHJwYywgaW5kZXgpID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJhZGl4XG4gICAgICAgIGlmIChCb29sZWFuKHJwYy5jaGFpbklkKSAmJiBOdW1iZXIuaXNOYU4ocGFyc2VJbnQocnBjLmNoYWluSWQpKSkge1xuICAgICAgICAgIGRlbGV0ZSBmcmVxdWVudFJwY0xpc3REZXRhaWxbaW5kZXhdLmNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmZyZXF1ZW50UnBjTGlzdERldGFpbCA9XG4gICAgICAgIGZyZXF1ZW50UnBjTGlzdERldGFpbDtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRlLk5ldHdvcmtDb250cm9sbGVyKSB7XG4gICAgaWYgKFxuICAgICAgbmV3U3RhdGUuTmV0d29ya0NvbnRyb2xsZXIubmV0d29yayAmJlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJhZGl4XG4gICAgICBOdW1iZXIuaXNOYU4ocGFyc2VJbnQobmV3U3RhdGUuTmV0d29ya0NvbnRyb2xsZXIubmV0d29yaykpXG4gICAgKSB7XG4gICAgICBkZWxldGUgbmV3U3RhdGUuTmV0d29ya0NvbnRyb2xsZXIubmV0d29yaztcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBuZXdTdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5wcm92aWRlciAmJlxuICAgICAgbmV3U3RhdGUuTmV0d29ya0NvbnRyb2xsZXIucHJvdmlkZXIuY2hhaW5JZCAmJlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJhZGl4XG4gICAgICBOdW1iZXIuaXNOYU4ocGFyc2VJbnQobmV3U3RhdGUuTmV0d29ya0NvbnRyb2xsZXIucHJvdmlkZXIuY2hhaW5JZCkpXG4gICAgKSB7XG4gICAgICBkZWxldGUgbmV3U3RhdGUuTmV0d29ya0NvbnRyb2xsZXIucHJvdmlkZXIuY2hhaW5JZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCIvLyBuZXh0IHZlcnNpb24gbnVtYmVyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gMzE7XG5cbi8qXG4gKiBUaGUgcHVycG9zZSBvZiB0aGlzIG1pZ3JhdGlvbiBpcyB0byBwcm9wZXJseSBzZXQgdGhlIGNvbXBsZXRlZE9uYm9hcmRpbmcgZmxhZyBiYXNlZCBvbiB0aGUgc3RhdGVcbiAqIG9mIHRoZSBLZXlyaW5nQ29udHJvbGxlci5cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IHsgS2V5cmluZ0NvbnRyb2xsZXIsIFByZWZlcmVuY2VzQ29udHJvbGxlciB9ID0gc3RhdGU7XG5cbiAgaWYgKEtleXJpbmdDb250cm9sbGVyICYmIFByZWZlcmVuY2VzQ29udHJvbGxlcikge1xuICAgIGNvbnN0IHsgdmF1bHQgfSA9IEtleXJpbmdDb250cm9sbGVyO1xuICAgIFByZWZlcmVuY2VzQ29udHJvbGxlci5jb21wbGV0ZWRPbmJvYXJkaW5nID0gQm9vbGVhbih2YXVsdCk7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gMzI7XG5cbi8qKlxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtaWdyYXRpb24gaXMgdG8gc2V0IHRoZSB7QGNvZGUgY29tcGxldGVkVWlNaWdyYXRpb259IGZsYWcgYmFzZWQgb24gdGhlIHVzZXIncyBVSSBwcmVmZXJlbmNlc1xuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCB7IFByZWZlcmVuY2VzQ29udHJvbGxlciB9ID0gc3RhdGU7XG5cbiAgaWYgKFByZWZlcmVuY2VzQ29udHJvbGxlcikge1xuICAgIGNvbnN0IHsgYmV0YVVJIH0gPSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuZmVhdHVyZUZsYWdzIHx8IHt9O1xuICAgIC8vIFVzZXJzIHdobyBoYXZlIGJlZW4gdXNpbmcgdGhlIFwiYmV0YVwiIFVJIGFyZSBjb25zaWRlcmVkIHRvIGhhdmUgY29tcGxldGVkIHRoZSBtaWdyYXRpb25cbiAgICAvLyBhcyB0aGV5J2xsIHNlZSBubyBkaWZmZXJlbmNlIGluIHRoaXMgdmVyc2lvblxuICAgIFByZWZlcmVuY2VzQ29udHJvbGxlci5jb21wbGV0ZWRVaU1pZ3JhdGlvbiA9IGJldGFVSTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsIi8vIG5leHQgdmVyc2lvbiBudW1iZXJcbi8qXG5cbkNsZWFucyB1cCBub3RpY2VzIGFuZCBhc3NvY2F0ZWQgbm90aWNlIGNvbnRyb2xsZXIgY29kZVxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gMzM7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xuICAvLyB0cmFuc2Zvcm0gc3RhdGUgaGVyZVxuICBpZiAoc3RhdGUuTm90aWNlQ29udHJvbGxlcikge1xuICAgIGRlbGV0ZSBuZXdTdGF0ZS5Ob3RpY2VDb250cm9sbGVyO1xuICB9XG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSAzNDtcblxuLyoqXG4gKiBUaGUgcHVycG9zZSBvZiB0aGlzIG1pZ3JhdGlvbiBpcyB0byBlbmFibGUgdGhlIHtAY29kZSBwcml2YWN5TW9kZX0gZmVhdHVyZSBmbGFnIGFuZCBzZXQgdGhlIHVzZXIgYXMgYmVpbmcgbWlncmF0ZWRcbiAqIGlmIGl0IHdhcyB7QGNvZGUgZmFsc2V9LlxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCB7IFByZWZlcmVuY2VzQ29udHJvbGxlciB9ID0gc3RhdGU7XG5cbiAgaWYgKFByZWZlcmVuY2VzQ29udHJvbGxlcikge1xuICAgIGNvbnN0IGZlYXR1cmVGbGFncyA9IFByZWZlcmVuY2VzQ29udHJvbGxlci5mZWF0dXJlRmxhZ3MgfHwge307XG5cbiAgICBpZiAoXG4gICAgICAhZmVhdHVyZUZsYWdzLnByaXZhY3lNb2RlICYmXG4gICAgICB0eXBlb2YgUHJlZmVyZW5jZXNDb250cm9sbGVyLm1pZ3JhdGVkUHJpdmFjeU1vZGUgPT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICAvLyBNYXJrIHRoZSBzdGF0ZSBoYXMgYmVpbmcgbWlncmF0ZWQgYW5kIGVuYWJsZSBQcml2YWN5IE1vZGVcbiAgICAgIFByZWZlcmVuY2VzQ29udHJvbGxlci5taWdyYXRlZFByaXZhY3lNb2RlID0gdHJ1ZTtcbiAgICAgIGZlYXR1cmVGbGFncy5wcml2YWN5TW9kZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiLy8gbmV4dCB2ZXJzaW9uIG51bWJlclxuLypcblxuUmVtb3ZlcyB0aGUgZGVwcmVjYXRlZCAnc2VlZFdvcmRzJyBzdGF0ZVxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gMzU7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUodmVyc2lvbmVkRGF0YS5kYXRhKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGlmIChcbiAgICBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIgJiZcbiAgICBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2VlZFdvcmRzICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgZGVsZXRlIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5zZWVkV29yZHM7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDM2O1xuXG4vKipcbiAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWlncmF0aW9uIGlzIHRvIHJlbW92ZSB0aGUge0Bjb2RlIHByaXZhY3lNb2RlfSBmZWF0dXJlIGZsYWcuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IHsgUHJlZmVyZW5jZXNDb250cm9sbGVyIH0gPSBzdGF0ZTtcblxuICBpZiAoUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XG4gICAgY29uc3QgZmVhdHVyZUZsYWdzID0gUHJlZmVyZW5jZXNDb250cm9sbGVyLmZlYXR1cmVGbGFncyB8fCB7fTtcblxuICAgIGlmICh0eXBlb2YgZmVhdHVyZUZsYWdzLnByaXZhY3lNb2RlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZGVsZXRlIGZlYXR1cmVGbGFncy5wcml2YWN5TW9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgbm9ybWFsaXplRW5zTmFtZSB9IGZyb20gJ0BtZXRhbWFzay9jb250cm9sbGVyLXV0aWxzJztcblxuY29uc3QgdmVyc2lvbiA9IDM3O1xuXG4vKipcbiAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWlncmF0aW9uIGlzIHRvIHVwZGF0ZSB0aGUgYWRkcmVzcyBib29rIHN0YXRlXG4gKiB0byB0aGUgbmV3IHNjaGVtYSB3aXRoIGNoYWluSWQgYXMgYSBrZXkuXG4gKiBhbmQgdG8gYWRkIHRoZSBpc0VucyBmbGFnIHRvIGFsbCBlbnRyaWVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5BZGRyZXNzQm9va0NvbnRyb2xsZXIpIHtcbiAgICBjb25zdCBhYiA9IHN0YXRlLkFkZHJlc3NCb29rQ29udHJvbGxlci5hZGRyZXNzQm9vaztcblxuICAgIGNvbnN0IGNoYWluSWRzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IG5ld0FkZHJlc3NCb29rID0ge307XG5cbiAgICAvLyBhZGQgYWxsIG9mIHRoZSBjaGFpbklkcyB0byBhIHNldFxuICAgIE9iamVjdC52YWx1ZXMoYWIpLmZvckVhY2goKHYpID0+IHtcbiAgICAgIGNoYWluSWRzLmFkZCh2LmNoYWluSWQpO1xuICAgIH0pO1xuXG4gICAgLy8gZmlsbCB0aGUgY2hhaW5JZCBvYmplY3Qgd2l0aCB0aGUgZW50cmllcyB3aXRoIHRoZSBtYXRjaGluZyBjaGFpbklkXG4gICAgZm9yIChjb25zdCBpZCBvZiBjaGFpbklkcy52YWx1ZXMoKSkge1xuICAgICAgLy8gbWFrZSBhbiBlbXB0eSBvYmplY3QgZW50cnkgZm9yIGVhY2ggY2hhaW5JZFxuICAgICAgbmV3QWRkcmVzc0Jvb2tbaWRdID0ge307XG4gICAgICBmb3IgKGNvbnN0IGFkZHJlc3MgaW4gYWIpIHtcbiAgICAgICAgaWYgKGFiW2FkZHJlc3NdLmNoYWluSWQgPT09IGlkKSB7XG4gICAgICAgICAgYWJbYWRkcmVzc10uaXNFbnMgPSBmYWxzZTtcbiAgICAgICAgICBpZiAobm9ybWFsaXplRW5zTmFtZShhYlthZGRyZXNzXS5uYW1lKSkge1xuICAgICAgICAgICAgYWJbYWRkcmVzc10uaXNFbnMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXdBZGRyZXNzQm9va1tpZF1bYWRkcmVzc10gPSBhYlthZGRyZXNzXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLkFkZHJlc3NCb29rQ29udHJvbGxlci5hZGRyZXNzQm9vayA9IG5ld0FkZHJlc3NCb29rO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDM4O1xuXG4vKipcbiAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWlncmF0aW9uIGlzIHRvIGFzc2lnbiBhbGwgdXNlcnMgdG8gYSB0ZXN0IGdyb3VwIGZvciB0aGUgZnVsbFNjcmVlblZzUG9wdXAgYS9iIHRlc3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgeyBBQlRlc3RDb250cm9sbGVyOiBBQlRlc3RDb250cm9sbGVyU3RhdGUgPSB7fSB9ID0gc3RhdGU7XG4gIGNvbnN0IHsgYWJUZXN0cyA9IHt9IH0gPSBBQlRlc3RDb250cm9sbGVyU3RhdGU7XG5cbiAgaWYgKGFiVGVzdHMuZnVsbFNjcmVlblZzUG9wdXApIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIEFCVGVzdENvbnRyb2xsZXI6IHtcbiAgICAgIC4uLkFCVGVzdENvbnRyb2xsZXJTdGF0ZSxcbiAgICAgIGFiVGVzdHM6IHtcbiAgICAgICAgLi4uYWJUZXN0cyxcbiAgICAgICAgZnVsbFNjcmVlblZzUG9wdXA6ICdjb250cm9sJyxcbiAgICAgIH0sXG4gICAgfSxcbiAgfTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyB0b0NoZWNrc3VtSGV4QWRkcmVzcyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL2hleHN0cmluZy11dGlscyc7XG5cbmNvbnN0IHZlcnNpb24gPSAzOTtcblxuY29uc3QgREFJX1YxX0NPTlRSQUNUX0FERFJFU1MgPSAnMHg4OWQyNEE2YjRDY0IxQjZmQUEyNjI1ZkU1NjJiREQ5YTIzMjYwMzU5JztcbmNvbnN0IERBSV9WMV9UT0tFTl9TWU1CT0wgPSAnREFJJztcbmNvbnN0IFNBSV9UT0tFTl9TWU1CT0wgPSAnU0FJJztcblxuZnVuY3Rpb24gaXNPbGREYWkodG9rZW4gPSB7fSkge1xuICByZXR1cm4gKFxuICAgIHRva2VuICYmXG4gICAgdHlwZW9mIHRva2VuID09PSAnb2JqZWN0JyAmJlxuICAgIHRva2VuLnN5bWJvbCA9PT0gREFJX1YxX1RPS0VOX1NZTUJPTCAmJlxuICAgIHRvQ2hlY2tzdW1IZXhBZGRyZXNzKHRva2VuLmFkZHJlc3MpID09PSBEQUlfVjFfQ09OVFJBQ1RfQUREUkVTU1xuICApO1xufVxuXG4vKipcbiAqIFRoaXMgbWlncmF0aW9uIHJlbmFtZXMgdGhlIERhaSB0b2tlbiB0byBTYWkuXG4gKlxuICogQXMgb2YgMjAxOS0xMS0xOCBEYWkgaXMgbm93IGNhbGxlZCBTYWkgKHJlZnMgaHR0cHM6Ly9naXQuaW8vSmVvb1ApIHRvIGZhY2lsaXRhdGVcbiAqIE1ha2VyJ3MgdXBncmFkZSB0byBNdWx0aS1Db2xsYXRlcmFsIERhaSBhbmQgdGhpcyBtaWdyYXRpb24gcmVuYW1lcyB0aGUgdG9rZW5cbiAqIGF0IHRoZSBvbGQgYWRkcmVzcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgeyBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgfSA9IHN0YXRlO1xuXG4gIGlmIChQcmVmZXJlbmNlc0NvbnRyb2xsZXIpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIudG9rZW5zIHx8IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRva2VucykpIHtcbiAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgIGlmIChpc09sZERhaSh0b2tlbikpIHtcbiAgICAgICAgICB0b2tlbi5zeW1ib2wgPSBTQUlfVE9LRU5fU1lNQk9MO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYWNjb3VudFRva2VucyA9IFByZWZlcmVuY2VzQ29udHJvbGxlci5hY2NvdW50VG9rZW5zIHx8IHt9O1xuICAgIGlmIChhY2NvdW50VG9rZW5zICYmIHR5cGVvZiBhY2NvdW50VG9rZW5zID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIE9iamVjdC5rZXlzKGFjY291bnRUb2tlbnMpKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtUb2tlbnMgPSBhY2NvdW50VG9rZW5zW2FkZHJlc3NdO1xuICAgICAgICBpZiAobmV0d29ya1Rva2VucyAmJiB0eXBlb2YgbmV0d29ya1Rva2VucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG5ldHdvcmsgb2YgT2JqZWN0LmtleXMobmV0d29ya1Rva2VucykpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2Vuc09uTmV0d29yayA9IG5ldHdvcmtUb2tlbnNbbmV0d29ya107XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0b2tlbnNPbk5ldHdvcmspKSB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zT25OZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2xkRGFpKHRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgdG9rZW4uc3ltYm9sID0gU0FJX1RPS0VOX1NZTUJPTDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNDA7XG5cbi8qKlxuICogU2l0ZSBjb25uZWN0aW9ucyBhcmUgbm93IG1hbmFnZWQgYnkgdGhlIFBlcm1pc3Npb25zQ29udHJvbGxlciwgYW5kIHRoZVxuICogUHJvdmlkZXJBcHByb3ZhbENvbnRyb2xsZXIgaXMgcmVtb3ZlZC4gVGhpcyBtaWdyYXRpb24gZGVsZXRlcyBhbGxcbiAqIFByb3ZpZGVyQXBwcm92YWxDb250cm9sbGVyIHN0YXRlLlxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBkZWxldGUgc3RhdGUuUHJvdmlkZXJBcHByb3ZhbENvbnRyb2xsZXI7XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA0MTtcblxuLyoqXG4gKiBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuYXV0b0xvZ291dFRpbWVMaW1pdCAtPiBhdXRvTG9ja1RpbWVMaW1pdFxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBpZiAoc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyICYmIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5wcmVmZXJlbmNlcykge1xuICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5wcmVmZXJlbmNlcy5hdXRvTG9ja1RpbWVMaW1pdCA9XG4gICAgICBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIucHJlZmVyZW5jZXMuYXV0b0xvZ291dFRpbWVMaW1pdDtcbiAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnByZWZlcmVuY2VzLmF1dG9Mb2dvdXRUaW1lTGltaXQ7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDQyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYGNvbm5lY3RlZFN0YXR1c1BvcG92ZXJIYXNCZWVuU2hvd25gIHRvIGBmYWxzZWAgaWYgaXQgaGFzbid0IHlldCBiZWVuIHNldCxcbiAqIHNvIHRoYXQgZXhpc3RpbmcgdXNlcnMgYXJlIGludHJvZHVjZWQgdG8gdGhlIG5ldyBjb25uZWN0ZWQgc3RhdHVzIGluZGljYXRvclxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBpZiAoc3RhdGUuQXBwU3RhdGVDb250cm9sbGVyKSB7XG4gICAgc3RhdGUuQXBwU3RhdGVDb250cm9sbGVyLmNvbm5lY3RlZFN0YXR1c1BvcG92ZXJIYXNCZWVuU2hvd24gPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXIgPSB7XG4gICAgICBjb25uZWN0ZWRTdGF0dXNQb3BvdmVySGFzQmVlblNob3duOiBmYWxzZSxcbiAgICB9O1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA0MztcblxuLyoqXG4gKiBSZW1vdmUgdW51c2VkICdjdXJyZW50QWNjb3VudFRhYicgc3RhdGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgaWYgKHN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LmN1cnJlbnRBY2NvdW50VGFiKSB7XG4gICAgZGVsZXRlIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5jdXJyZW50QWNjb3VudFRhYjtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNDQ7XG5cbi8qKlxuICogUmVtb3ZlIHVudXNlZCAnbWtyTWlncmF0aW9uUmVtaW5kZXJUaW1lc3RhbXAnIHN0YXRlIGZyb20gdGhlIGBBcHBTdGF0ZUNvbnRyb2xsZXJgXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGlmIChcbiAgICB0eXBlb2Ygc3RhdGU/LkFwcFN0YXRlQ29udHJvbGxlcj8ubWtyTWlncmF0aW9uUmVtaW5kZXJUaW1lc3RhbXAgIT09XG4gICAgJ3VuZGVmaW5lZCdcbiAgKSB7XG4gICAgZGVsZXRlIHN0YXRlLkFwcFN0YXRlQ29udHJvbGxlci5ta3JNaWdyYXRpb25SZW1pbmRlclRpbWVzdGFtcDtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNDU7XG5cbi8qKlxuICogUmVwbGFjZXMge0Bjb2RlIFByZWZlcmVuY2VzQ29udHJvbGxlci5pcGZzR2F0ZXdheX0gd2l0aCAnZHdlYi5saW5rJyBpZiBzZXRcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuY29uc3Qgb3V0ZGF0ZWRHYXRld2F5cyA9IFsnaXBmcy5pbycsICdpcGZzLmR3ZWIubGluayddO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBpZiAob3V0ZGF0ZWRHYXRld2F5cy5pbmNsdWRlcyhzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5pcGZzR2F0ZXdheSkpIHtcbiAgICBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuaXBmc0dhdGV3YXkgPSAnZHdlYi5saW5rJztcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNDY7XG5cbi8qKlxuICogRGVsZXRlIHtAY29kZSBBQlRlc3RDb250cm9sbGVyfSBzdGF0ZVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBpZiAodHlwZW9mIHN0YXRlPy5BQlRlc3RDb250cm9sbGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGRlbGV0ZSBzdGF0ZS5BQlRlc3RDb250cm9sbGVyO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA0NztcblxuLyoqXG4gKiBTdHJpbmdpZnkgdGhlIGBtZXRhbWFza05ldHdvcmtJZGAgcHJvcGVydHkgb2YgYWxsIHRyYW5zYWN0aW9uc1xuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCB0cmFuc2FjdGlvbnMgPSBzdGF0ZT8uVHJhbnNhY3Rpb25Db250cm9sbGVyPy50cmFuc2FjdGlvbnM7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyYW5zYWN0aW9ucykpIHtcbiAgICB0cmFuc2FjdGlvbnMuZm9yRWFjaCgodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24ubWV0YW1hc2tOZXR3b3JrSWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLm1ldGFtYXNrTmV0d29ya0lkID1cbiAgICAgICAgICB0cmFuc2FjdGlvbi5tZXRhbWFza05ldHdvcmtJZC50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA0ODtcblxuLyoqXG4gKiAxLiAgRGVsZXRlIE5ldHdvcmtDb250cm9sbGVyLnNldHRpbmdzXG4gKiAyYS4gTWlncmF0ZSBOZXR3b3JrQ29udHJvbGxlci5wcm92aWRlciB0byBSaW5rZWJ5IGlmIHNldCB0byB0eXBlICdycGMnIG9yXG4gKiAgICAgJ2xvY2FsaG9zdCcuXG4gKiAyYi4gUmUta2V5IHByb3ZpZGVyLnJwY1RhcmdldCB0byBwcm92aWRlci5ycGNVcmxcbiAqIDMuICBBZGQgbG9jYWxob3N0IG5ldHdvcmsgdG8gZnJlcXVlbnRScGNMaXN0RGV0YWlsLlxuICogNC4gIERlbGV0ZSBDYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXIuY2FjaGVkQmFsYW5jZXNcbiAqIDUuICBDb252ZXJ0IHRyYW5zYWN0aW9ucyBtZXRhbWFza05ldHdvcmtJZCB0byBkZWNpbWFsIGlmIHRoZXkgYXJlIGhleFxuICogNi4gIENvbnZlcnQgYWRkcmVzcyBib29rIGtleXMgZnJvbSBkZWNpbWFsIHRvIGhleFxuICogNy4gIERlbGV0ZSBsb2NhbGhvc3Qga2V5IGluIEluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlclxuICogOC4gIE1lcmdlICdsb2NhbGhvc3QnIHRva2VucyBpbnRvICdycGMnIHRva2Vuc1xuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5jb25zdCBoZXhSZWdFeCA9IC9eMHhbMC05YS1mXSskL2l1O1xuY29uc3QgY2hhaW5JZFJlZ0V4ID0gL14weFsxLTlhLWZdK1swLTlhLWZdKiQvaXU7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlID0ge30pIHtcbiAgLy8gMS4gRGVsZXRlIE5ldHdvcmtDb250cm9sbGVyLnNldHRpbmdzXG4gIGRlbGV0ZSBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcj8uc2V0dGluZ3M7XG5cbiAgLy8gMi4gTWlncmF0ZSBOZXR3b3JrQ29udHJvbGxlci5wcm92aWRlciB0byBSaW5rZWJ5IG9yIHJlbmFtZSBycGNUYXJnZXQga2V5XG4gIGNvbnN0IHByb3ZpZGVyID0gc3RhdGUuTmV0d29ya0NvbnRyb2xsZXI/LnByb3ZpZGVyIHx8IHt9O1xuICBjb25zdCBpc0N1c3RvbVJwY1dpdGhJbnZhbGlkQ2hhaW5JZCA9XG4gICAgcHJvdmlkZXIudHlwZSA9PT0gJ3JwYycgJiZcbiAgICAodHlwZW9mIHByb3ZpZGVyLmNoYWluSWQgIT09ICdzdHJpbmcnIHx8XG4gICAgICAhY2hhaW5JZFJlZ0V4LnRlc3QocHJvdmlkZXIuY2hhaW5JZCkpO1xuICBpZiAoaXNDdXN0b21ScGNXaXRoSW52YWxpZENoYWluSWQgfHwgcHJvdmlkZXIudHlwZSA9PT0gJ2xvY2FsaG9zdCcpIHtcbiAgICBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5wcm92aWRlciA9IHtcbiAgICAgIHR5cGU6ICdyaW5rZWJ5JyxcbiAgICAgIHJwY1VybDogJycsXG4gICAgICBjaGFpbklkOiAnMHg0JyxcbiAgICAgIG5pY2tuYW1lOiAnJyxcbiAgICAgIHJwY1ByZWZzOiB7fSxcbiAgICAgIHRpY2tlcjogJ0VUSCcsXG4gICAgfTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcj8ucHJvdmlkZXIpIHtcbiAgICBpZiAoJ3JwY1RhcmdldCcgaW4gc3RhdGUuTmV0d29ya0NvbnRyb2xsZXIucHJvdmlkZXIpIHtcbiAgICAgIGNvbnN0IHJwY1VybCA9IHN0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyLnJwY1RhcmdldDtcbiAgICAgIHN0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyLnJwY1VybCA9IHJwY1VybDtcbiAgICB9XG4gICAgZGVsZXRlIHN0YXRlLk5ldHdvcmtDb250cm9sbGVyPy5wcm92aWRlcj8ucnBjVGFyZ2V0O1xuICB9XG5cbiAgLy8gMy4gIEFkZCBsb2NhbGhvc3QgbmV0d29yayB0byBmcmVxdWVudFJwY0xpc3REZXRhaWwuXG4gIGlmICghc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XG4gICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyID0ge307XG4gIH1cbiAgaWYgKCFzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuZnJlcXVlbnRScGNMaXN0RGV0YWlsKSB7XG4gICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmZyZXF1ZW50UnBjTGlzdERldGFpbCA9IFtdO1xuICB9XG4gIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5mcmVxdWVudFJwY0xpc3REZXRhaWwudW5zaGlmdCh7XG4gICAgcnBjVXJsOiAnaHR0cDovL2xvY2FsaG9zdDo4NTQ1JyxcbiAgICBjaGFpbklkOiAnMHg1MzknLFxuICAgIHRpY2tlcjogJ0VUSCcsXG4gICAgbmlja25hbWU6ICdMb2NhbGhvc3QgODU0NScsXG4gICAgcnBjUHJlZnM6IHt9LFxuICB9KTtcblxuICAvLyA0LiAgRGVsZXRlIENhY2hlZEJhbGFuY2VzQ29udHJvbGxlci5jYWNoZWRCYWxhbmNlc1xuICBkZWxldGUgc3RhdGUuQ2FjaGVkQmFsYW5jZXNDb250cm9sbGVyPy5jYWNoZWRCYWxhbmNlcztcblxuICAvLyA1LiAgQ29udmVydCB0cmFuc2FjdGlvbnMgbWV0YW1hc2tOZXR3b3JrSWQgdG8gZGVjaW1hbCBpZiB0aGV5IGFyZSBoZXhcbiAgY29uc3QgdHJhbnNhY3Rpb25zID0gc3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyPy50cmFuc2FjdGlvbnM7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyYW5zYWN0aW9ucykpIHtcbiAgICB0cmFuc2FjdGlvbnMuZm9yRWFjaCgodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IG1ldGFtYXNrTmV0d29ya0lkID0gdHJhbnNhY3Rpb24/Lm1ldGFtYXNrTmV0d29ya0lkO1xuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgbWV0YW1hc2tOZXR3b3JrSWQgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIGhleFJlZ0V4LnRlc3QobWV0YW1hc2tOZXR3b3JrSWQpXG4gICAgICApIHtcbiAgICAgICAgdHJhbnNhY3Rpb24ubWV0YW1hc2tOZXR3b3JrSWQgPSBwYXJzZUludChcbiAgICAgICAgICBtZXRhbWFza05ldHdvcmtJZCxcbiAgICAgICAgICAxNixcbiAgICAgICAgKS50b1N0cmluZygxMCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyA2LiAgQ29udmVydCBhZGRyZXNzIGJvb2sga2V5cyBmcm9tIGRlY2ltYWwgdG8gaGV4XG4gIGNvbnN0IGFkZHJlc3NCb29rID0gc3RhdGUuQWRkcmVzc0Jvb2tDb250cm9sbGVyPy5hZGRyZXNzQm9vayB8fCB7fTtcbiAgT2JqZWN0LmtleXMoYWRkcmVzc0Jvb2spLmZvckVhY2goKG5ldHdvcmtLZXkpID0+IHtcbiAgICBpZiAoL15cXGQrJC9pdS50ZXN0KG5ldHdvcmtLZXkpKSB7XG4gICAgICBjb25zdCBjaGFpbklkID0gYDB4JHtwYXJzZUludChuZXR3b3JrS2V5LCAxMCkudG9TdHJpbmcoMTYpfWA7XG4gICAgICB1cGRhdGVDaGFpbklkcyhhZGRyZXNzQm9va1tuZXR3b3JrS2V5XSwgY2hhaW5JZCk7XG5cbiAgICAgIGlmIChhZGRyZXNzQm9va1tjaGFpbklkXSkge1xuICAgICAgICBtZXJnZUFkZHJlc3NCb29rS2V5cyhhZGRyZXNzQm9vaywgbmV0d29ya0tleSwgY2hhaW5JZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRyZXNzQm9va1tjaGFpbklkXSA9IGFkZHJlc3NCb29rW25ldHdvcmtLZXldO1xuICAgICAgfVxuICAgICAgZGVsZXRlIGFkZHJlc3NCb29rW25ldHdvcmtLZXldO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gNy4gIERlbGV0ZSBsb2NhbGhvc3Qga2V5IGluIEluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlclxuICBkZWxldGUgc3RhdGUuSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyXG4gICAgPy5pbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja3NCeU5ldHdvcms/LmxvY2FsaG9zdDtcblxuICAvLyA4LiAgTWVyZ2UgJ2xvY2FsaG9zdCcgdG9rZW5zIGludG8gJ3JwYycgdG9rZW5zXG4gIGNvbnN0IGFjY291bnRUb2tlbnMgPSBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LmFjY291bnRUb2tlbnM7XG4gIGlmIChhY2NvdW50VG9rZW5zKSB7XG4gICAgT2JqZWN0LmtleXMoYWNjb3VudFRva2VucykuZm9yRWFjaCgoYWNjb3VudCkgPT4ge1xuICAgICAgY29uc3QgbG9jYWxob3N0VG9rZW5zID0gYWNjb3VudFRva2Vuc1thY2NvdW50XT8ubG9jYWxob3N0IHx8IFtdO1xuXG4gICAgICBpZiAobG9jYWxob3N0VG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgcnBjVG9rZW5zID0gYWNjb3VudFRva2Vuc1thY2NvdW50XS5ycGMgfHwgW107XG5cbiAgICAgICAgaWYgKHJwY1Rva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYWNjb3VudFRva2Vuc1thY2NvdW50XS5ycGMgPSBtZXJnZVRva2VuQXJyYXlzKFxuICAgICAgICAgICAgbG9jYWxob3N0VG9rZW5zLFxuICAgICAgICAgICAgcnBjVG9rZW5zLFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWNjb3VudFRva2Vuc1thY2NvdW50XS5ycGMgPSBsb2NhbGhvc3RUb2tlbnM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBhY2NvdW50VG9rZW5zW2FjY291bnRdPy5sb2NhbGhvc3Q7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogTWVyZ2VzIHRoZSB0d28gZ2l2ZW4ga2V5cyBmb3IgdGhlIGdpdmVuIGFkZHJlc3MgYm9vayBpbiBwbGFjZS5cbiAqXG4gKiBAcGFyYW0gYWRkcmVzc0Jvb2tcbiAqIEBwYXJhbSBuZXR3b3JrS2V5XG4gKiBAcGFyYW0gY2hhaW5JZEtleVxuICovXG5mdW5jdGlvbiBtZXJnZUFkZHJlc3NCb29rS2V5cyhhZGRyZXNzQm9vaywgbmV0d29ya0tleSwgY2hhaW5JZEtleSkge1xuICBjb25zdCBuZXR3b3JrS2V5RW50cmllcyA9IGFkZHJlc3NCb29rW25ldHdvcmtLZXldIHx8IHt9O1xuICAvLyBGb3IgdGhlIG5ldyBlbnRyaWVzLCBzdGFydCBieSBjb3B5aW5nIHRoZSBleGlzdGluZyBlbnRyaWVzIGZvciB0aGUgY2hhaW5JZFxuICBjb25zdCBuZXdFbnRyaWVzID0geyAuLi5hZGRyZXNzQm9va1tjaGFpbklkS2V5XSB9O1xuXG4gIC8vIEZvciBlYWNoIGFkZHJlc3Mgb2YgdGhlIG9sZC9uZXR3b3JrSWQga2V5IGVudHJpZXNcbiAgT2JqZWN0LmtleXMobmV0d29ya0tleUVudHJpZXMpLmZvckVhY2goKGFkZHJlc3MpID0+IHtcbiAgICBpZiAobmV3RW50cmllc1thZGRyZXNzXSAmJiB0eXBlb2YgbmV3RW50cmllc1thZGRyZXNzXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IG1lcmdlZEVudHJ5ID0ge307XG5cbiAgICAgIC8vIENvbGxlY3QgYWxsIGtleXMgZnJvbSBib3RoIGVudHJpZXMgYW5kIG1lcmdlIHRoZSBjb3JyZXNwb25kaW5nIGNoYWluSWRcbiAgICAgIC8vIGVudHJ5IHdpdGggdGhlIG5ldHdvcmtJZCBlbnRyeVxuICAgICAgbmV3IFNldChbXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKG5ld0VudHJpZXNbYWRkcmVzc10pLFxuICAgICAgICAuLi5PYmplY3Qua2V5cyhuZXR3b3JrS2V5RW50cmllc1thZGRyZXNzXSB8fCB7fSksXG4gICAgICBdKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgLy8gVXNlIG5vbi1lbXB0eSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQga2V5LCBpZiBhbnlcbiAgICAgICAgbWVyZ2VkRW50cnlba2V5XSA9XG4gICAgICAgICAgbmV3RW50cmllc1thZGRyZXNzXVtrZXldIHx8IG5ldHdvcmtLZXlFbnRyaWVzW2FkZHJlc3NdPy5ba2V5XSB8fCAnJztcbiAgICAgIH0pO1xuXG4gICAgICBuZXdFbnRyaWVzW2FkZHJlc3NdID0gbWVyZ2VkRW50cnk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIG5ldHdvcmtLZXlFbnRyaWVzW2FkZHJlc3NdICYmXG4gICAgICB0eXBlb2YgbmV0d29ya0tleUVudHJpZXNbYWRkcmVzc10gPT09ICdvYmplY3QnXG4gICAgKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBjb3JyZXNwb25kaW5nIGNoYWluSWQgZW50cnksIGp1c3QgdXNlIHRoZSBuZXR3b3JrSWQgZW50cnlcbiAgICAgIC8vIGRpcmVjdGx5XG4gICAgICBuZXdFbnRyaWVzW2FkZHJlc3NdID0gbmV0d29ya0tleUVudHJpZXNbYWRkcmVzc107XG4gICAgfVxuICB9KTtcblxuICBhZGRyZXNzQm9va1tjaGFpbklkS2V5XSA9IG5ld0VudHJpZXM7XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgY2hhaW5JZCBrZXkgdmFsdWVzIHRvIHRoZSBnaXZlbiBjaGFpbklkIGluIHBsYWNlIGZvciBhbGwgdmFsdWVzXG4gKiBvZiB0aGUgZ2l2ZW4gbmV0d29ya0VudHJpZXMgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBuZXR3b3JrRW50cmllc1xuICogQHBhcmFtIGNoYWluSWRcbiAqL1xuZnVuY3Rpb24gdXBkYXRlQ2hhaW5JZHMobmV0d29ya0VudHJpZXMsIGNoYWluSWQpIHtcbiAgT2JqZWN0LnZhbHVlcyhuZXR3b3JrRW50cmllcykuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICBpZiAoZW50cnkgJiYgdHlwZW9mIGVudHJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgZW50cnkuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBNZXJnZXMgdGhlIHR3byBnaXZlbiwgbm9uLWVtcHR5IGFycmF5cyBvZiB0b2tlbiBvYmplY3RzIGFuZCByZXR1cm5zIGEgbmV3XG4gKiBhcnJheS5cbiAqXG4gKiBAcGFyYW0gbG9jYWxob3N0VG9rZW5zXG4gKiBAcGFyYW0gcnBjVG9rZW5zXG4gKiBAcmV0dXJucyB7QXJyYXk8b2JqZWN0Pn1cbiAqL1xuZnVuY3Rpb24gbWVyZ2VUb2tlbkFycmF5cyhsb2NhbGhvc3RUb2tlbnMsIHJwY1Rva2Vucykge1xuICBjb25zdCBsb2NhbGhvc3RUb2tlbnNNYXAgPSB0b2tlbkFycmF5VG9NYXAobG9jYWxob3N0VG9rZW5zKTtcbiAgY29uc3QgcnBjVG9rZW5zTWFwID0gdG9rZW5BcnJheVRvTWFwKHJwY1Rva2Vucyk7XG5cbiAgY29uc3QgbWVyZ2VkVG9rZW5zID0gW107XG4gIG5ldyBTZXQoW1xuICAgIC4uLk9iamVjdC5rZXlzKGxvY2FsaG9zdFRva2Vuc01hcCksXG4gICAgLi4uT2JqZWN0LmtleXMocnBjVG9rZW5zTWFwKSxcbiAgXSkuZm9yRWFjaCgodG9rZW5BZGRyZXNzKSA9PiB7XG4gICAgbWVyZ2VkVG9rZW5zLnB1c2goe1xuICAgICAgLi4ubG9jYWxob3N0VG9rZW5zTWFwW3Rva2VuQWRkcmVzc10sXG4gICAgICAuLi5ycGNUb2tlbnNNYXBbdG9rZW5BZGRyZXNzXSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG1lcmdlZFRva2VucztcblxuICBmdW5jdGlvbiB0b2tlbkFycmF5VG9NYXAoYXJyYXkpIHtcbiAgICByZXR1cm4gYXJyYXkucmVkdWNlKChtYXAsIHRva2VuKSA9PiB7XG4gICAgICBpZiAodG9rZW4/LmFkZHJlc3MgJiYgdHlwZW9mIHRva2VuPy5hZGRyZXNzID09PSAnc3RyaW5nJykge1xuICAgICAgICBtYXBbdG9rZW4uYWRkcmVzc10gPSB0b2tlbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfSwge30pO1xuICB9XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNDk7XG5cbi8qKlxuICogTWlncmF0ZSBtZXRhTWV0cmljcyBzdGF0ZSB0byB0aGUgbmV3IE1ldGFNZXRyaWNzIGNvbnRyb2xsZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUgPSB7fSkge1xuICBpZiAoc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XG4gICAgY29uc3QgeyBtZXRhTWV0cmljc0lkLCBwYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3MsIG1ldGFNZXRyaWNzU2VuZENvdW50IH0gPVxuICAgICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyO1xuICAgIHN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlciA9IHN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlciA/PyB7fTtcblxuICAgIGlmIChtZXRhTWV0cmljc0lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlci5tZXRhTWV0cmljc0lkID0gbWV0YU1ldHJpY3NJZDtcbiAgICAgIGRlbGV0ZSBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIubWV0YU1ldHJpY3NJZDtcbiAgICB9XG5cbiAgICBpZiAocGFydGljaXBhdGVJbk1ldGFNZXRyaWNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlci5wYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3MgPVxuICAgICAgICBwYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3M7XG4gICAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnBhcnRpY2lwYXRlSW5NZXRhTWV0cmljcztcbiAgICB9XG5cbiAgICBpZiAobWV0YU1ldHJpY3NTZW5kQ291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RhdGUuTWV0YU1ldHJpY3NDb250cm9sbGVyLm1ldGFNZXRyaWNzU2VuZENvdW50ID0gbWV0YU1ldHJpY3NTZW5kQ291bnQ7XG4gICAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLm1ldGFNZXRyaWNzU2VuZENvdW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNTA7XG5cbmNvbnN0IExFR0FDWV9MT0NBTF9TVE9SQUdFX0tFWVMgPSBbXG4gICdNRVRBU1dBUF9HQVNfUFJJQ0VfRVNUSU1BVEVTX0xBU1RfUkVUUklFVkVEJyxcbiAgJ01FVEFTV0FQX0dBU19QUklDRV9FU1RJTUFURVMnLFxuICAnY2FjaGVkRmV0Y2gnLFxuICAnQkFTSUNfUFJJQ0VfRVNUSU1BVEVTX0xBU1RfUkVUUklFVkVEJyxcbiAgJ0JBU0lDX1BSSUNFX0VTVElNQVRFUycsXG4gICdCQVNJQ19HQVNfQU5EX1RJTUVfQVBJX0VTVElNQVRFUycsXG4gICdCQVNJQ19HQVNfQU5EX1RJTUVfQVBJX0VTVElNQVRFU19MQVNUX1JFVFJJRVZFRCcsXG4gICdHQVNfQVBJX0VTVElNQVRFU19MQVNUX1JFVFJJRVZFRCcsXG4gICdHQVNfQVBJX0VTVElNQVRFUycsXG5dO1xuXG4vKipcbiAqIE1pZ3JhdGUgbWV0YU1ldHJpY3Mgc3RhdGUgdG8gdGhlIG5ldyBNZXRhTWV0cmljcyBjb250cm9sbGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG4gICAgTEVHQUNZX0xPQ0FMX1NUT1JBR0VfS0VZUy5mb3JFYWNoKChrZXkpID0+XG4gICAgICB3aW5kb3cubG9jYWxTdG9yYWdlPy5yZW1vdmVJdGVtKGtleSksXG4gICAgKTtcblxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBCVUlMVF9JTl9ORVRXT1JLUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XG5cbmNvbnN0IHZlcnNpb24gPSA1MTtcblxuLyoqXG4gKiBTZXQgdGhlIGNoYWluSWQgaW4gdGhlIE5ldHdvcmsgQ29udHJvbGxlciBwcm92aWRlciBkYXRhIGZvciBhbGwgaW5mdXJhIG5ldHdvcmtzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IHsgY2hhaW5JZCwgdHlwZSB9ID0gc3RhdGU/Lk5ldHdvcmtDb250cm9sbGVyPy5wcm92aWRlciB8fCB7fTtcbiAgY29uc3QgZW51bUNoYWluSWQgPSBCVUlMVF9JTl9ORVRXT1JLU1t0eXBlXT8uY2hhaW5JZDtcblxuICBpZiAoZW51bUNoYWluSWQgJiYgY2hhaW5JZCAhPT0gZW51bUNoYWluSWQpIHtcbiAgICBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5wcm92aWRlci5jaGFpbklkID0gZW51bUNoYWluSWQ7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IENIQUlOX0lEUywgTkVUV09SS19UWVBFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XG5cbmNvbnN0IHZlcnNpb24gPSA1MjtcblxuLyoqXG4gKiBNaWdyYXRlIHRva2VucyBpbiBQcmVmZXJlbmNlcyB0byBiZSBrZXllZCBieSBjaGFpbklkIGluc3RlYWQgb2ZcbiAqIHByb3ZpZGVyVHlwZS4gVG8gcHJldmVudCBicmVha2luZyB1c2VyJ3MgTWV0YU1hc2sgYW5kIHNlbGVjdGVkXG4gKiB0b2tlbnMsIHRoaXMgbWlncmF0aW9uIGNvcGllcyB0aGUgUlBDIGVudHJ5IGludG8gKmV2ZXJ5KiBjdXN0b20gUlBDXG4gKiBjaGFpbklkLlxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSA9IHt9KSB7XG4gIGlmIChzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIpIHtcbiAgICBjb25zdCB7IGFjY291bnRUb2tlbnMsIGFjY291bnRIaWRkZW5Ub2tlbnMsIGZyZXF1ZW50UnBjTGlzdERldGFpbCB9ID1cbiAgICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcjtcblxuICAgIGNvbnN0IG5ld0FjY291bnRUb2tlbnMgPSB7fTtcbiAgICBjb25zdCBuZXdBY2NvdW50SGlkZGVuVG9rZW5zID0ge307XG5cbiAgICBpZiAoYWNjb3VudFRva2VucyAmJiBPYmplY3Qua2V5cyhhY2NvdW50VG9rZW5zKS5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgT2JqZWN0LmtleXMoYWNjb3VudFRva2VucykpIHtcbiAgICAgICAgbmV3QWNjb3VudFRva2Vuc1thZGRyZXNzXSA9IHt9O1xuICAgICAgICBpZiAoYWNjb3VudFRva2Vuc1thZGRyZXNzXVtORVRXT1JLX1RZUEVTLlJQQ10pIHtcbiAgICAgICAgICBmcmVxdWVudFJwY0xpc3REZXRhaWwuZm9yRWFjaCgoZGV0YWlsKSA9PiB7XG4gICAgICAgICAgICBuZXdBY2NvdW50VG9rZW5zW2FkZHJlc3NdW2RldGFpbC5jaGFpbklkXSA9XG4gICAgICAgICAgICAgIGFjY291bnRUb2tlbnNbYWRkcmVzc11bTkVUV09SS19UWVBFUy5SUENdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcHJvdmlkZXJUeXBlIG9mIE9iamVjdC5rZXlzKGFjY291bnRUb2tlbnNbYWRkcmVzc10pKSB7XG4gICAgICAgICAgc3dpdGNoIChwcm92aWRlclR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgTkVUV09SS19UWVBFUy5NQUlOTkVUOlxuICAgICAgICAgICAgICBuZXdBY2NvdW50VG9rZW5zW2FkZHJlc3NdW0NIQUlOX0lEUy5NQUlOTkVUXSA9XG4gICAgICAgICAgICAgICAgYWNjb3VudFRva2Vuc1thZGRyZXNzXVtORVRXT1JLX1RZUEVTLk1BSU5ORVRdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JvcHN0ZW4nOlxuICAgICAgICAgICAgICBuZXdBY2NvdW50VG9rZW5zW2FkZHJlc3NdWycweDMnXSA9IGFjY291bnRUb2tlbnNbYWRkcmVzc10ucm9wc3RlbjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaW5rZWJ5JzpcbiAgICAgICAgICAgICAgbmV3QWNjb3VudFRva2Vuc1thZGRyZXNzXVsnMHg0J10gPSBhY2NvdW50VG9rZW5zW2FkZHJlc3NdLnJpbmtlYnk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBORVRXT1JLX1RZUEVTLkdPRVJMSTpcbiAgICAgICAgICAgICAgbmV3QWNjb3VudFRva2Vuc1thZGRyZXNzXVtDSEFJTl9JRFMuR09FUkxJXSA9XG4gICAgICAgICAgICAgICAgYWNjb3VudFRva2Vuc1thZGRyZXNzXVtORVRXT1JLX1RZUEVTLkdPRVJMSV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAna292YW4nOlxuICAgICAgICAgICAgICBuZXdBY2NvdW50VG9rZW5zW2FkZHJlc3NdWycweDJhJ10gPSBhY2NvdW50VG9rZW5zW2FkZHJlc3NdLmtvdmFuO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnMgPSBuZXdBY2NvdW50VG9rZW5zO1xuICAgIH1cblxuICAgIGlmIChhY2NvdW50SGlkZGVuVG9rZW5zICYmIE9iamVjdC5rZXlzKGFjY291bnRIaWRkZW5Ub2tlbnMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBPYmplY3Qua2V5cyhhY2NvdW50SGlkZGVuVG9rZW5zKSkge1xuICAgICAgICBuZXdBY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdID0ge307XG4gICAgICAgIGlmIChhY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdW05FVFdPUktfVFlQRVMuUlBDXSkge1xuICAgICAgICAgIGZyZXF1ZW50UnBjTGlzdERldGFpbC5mb3JFYWNoKChkZXRhaWwpID0+IHtcbiAgICAgICAgICAgIG5ld0FjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bZGV0YWlsLmNoYWluSWRdID1cbiAgICAgICAgICAgICAgYWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVtORVRXT1JLX1RZUEVTLlJQQ107XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwcm92aWRlclR5cGUgb2YgT2JqZWN0LmtleXMoYWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXSkpIHtcbiAgICAgICAgICBzd2l0Y2ggKHByb3ZpZGVyVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBORVRXT1JLX1RZUEVTLk1BSU5ORVQ6XG4gICAgICAgICAgICAgIG5ld0FjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bQ0hBSU5fSURTLk1BSU5ORVRdID1cbiAgICAgICAgICAgICAgICBhY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdW05FVFdPUktfVFlQRVMuTUFJTk5FVF07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncm9wc3Rlbic6XG4gICAgICAgICAgICAgIG5ld0FjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bJzB4MyddID1cbiAgICAgICAgICAgICAgICBhY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdLnJvcHN0ZW47XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmlua2VieSc6XG4gICAgICAgICAgICAgIG5ld0FjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bJzB4NCddID1cbiAgICAgICAgICAgICAgICBhY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdLnJpbmtlYnk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBORVRXT1JLX1RZUEVTLkdPRVJMSTpcbiAgICAgICAgICAgICAgbmV3QWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVtDSEFJTl9JRFMuR09FUkxJXSA9XG4gICAgICAgICAgICAgICAgYWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVtORVRXT1JLX1RZUEVTLkdPRVJMSV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAna292YW4nOlxuICAgICAgICAgICAgICBuZXdBY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdWycweDJhJ10gPVxuICAgICAgICAgICAgICAgIGFjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc10ua292YW47XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWNjb3VudEhpZGRlblRva2VucyA9IG5ld0FjY291bnRIaWRkZW5Ub2tlbnM7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcblxuY29uc3QgdmVyc2lvbiA9IDUzO1xuXG4vKipcbiAqIERlcHJlY2F0ZSB0cmFuc2FjdGlvbkNhdGVnb3J5IGFuZCBjb25zb2xpZGF0ZSBvbiAndHlwZSdcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgdHJhbnNhY3Rpb25zID0gc3RhdGU/LlRyYW5zYWN0aW9uQ29udHJvbGxlcj8udHJhbnNhY3Rpb25zO1xuICBjb25zdCBpbmNvbWluZ1RyYW5zYWN0aW9ucyA9XG4gICAgc3RhdGU/LkluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlcj8uaW5jb21pbmdUcmFuc2FjdGlvbnM7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyYW5zYWN0aW9ucykpIHtcbiAgICB0cmFuc2FjdGlvbnMuZm9yRWFjaCgodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgIGlmICh0cmFuc2FjdGlvbikge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdHJhbnNhY3Rpb24udHlwZSAhPT0gVHJhbnNhY3Rpb25UeXBlLnJldHJ5ICYmXG4gICAgICAgICAgdHJhbnNhY3Rpb24udHlwZSAhPT0gVHJhbnNhY3Rpb25UeXBlLmNhbmNlbFxuICAgICAgICApIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi50eXBlID0gdHJhbnNhY3Rpb24udHJhbnNhY3Rpb25DYXRlZ29yeTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdHJhbnNhY3Rpb24udHJhbnNhY3Rpb25DYXRlZ29yeTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpZiAoaW5jb21pbmdUcmFuc2FjdGlvbnMpIHtcbiAgICBjb25zdCBpbmNvbWluZ1RyYW5zYWN0aW9uc0VudHJpZXMgPSBPYmplY3QuZW50cmllcyhpbmNvbWluZ1RyYW5zYWN0aW9ucyk7XG4gICAgaW5jb21pbmdUcmFuc2FjdGlvbnNFbnRyaWVzLmZvckVhY2goKFtrZXksIHRyYW5zYWN0aW9uXSkgPT4ge1xuICAgICAgaWYgKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGRlbGV0ZSB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbkNhdGVnb3J5O1xuICAgICAgICBzdGF0ZS5JbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXIuaW5jb21pbmdUcmFuc2FjdGlvbnNba2V5XSA9IHtcbiAgICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgICB0eXBlOiBUcmFuc2FjdGlvblR5cGUuaW5jb21pbmcsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDU0O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRGVjaW1hbHMoZGVjaW1hbHMpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgZGVjaW1hbHMgPT09ICdudW1iZXInIHx8XG4gICAgKHR5cGVvZiBkZWNpbWFscyA9PT0gJ3N0cmluZycgJiYgZGVjaW1hbHMubWF0Y2goL14oMHgpP1xcZCskL3UpKVxuICApO1xufVxuXG4vKipcbiAqIE1pZ3JhdGVzIHByZWZlcmVuY2UgdG9rZW5zIHdpdGggZGVjaW1hbHMgdHlwZWQgYXMgc3RyaW5nIHRvIG51bWJlci5cbiAqIEl0IGFsc28gcmVtb3ZlcyBhbnkgdG9rZW5zIHdpdGggY29ycnVwdGVkIG9yIGluY29udmVydGlibGUgZGVjaW1hbCB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcblxuICBpZiAoIW5ld1N0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcikge1xuICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IHRva2VucyA9IG5ld1N0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci50b2tlbnMgfHwgW107XG4gIC8vIEZpbHRlciBvdXQgYW55IHRva2VucyB3aXRoIGNvcnJ1cHRlZCBkZWNpbWFsIHZhbHVlc1xuICBjb25zdCB2YWxpZFRva2VucyA9IHRva2Vucy5maWx0ZXIoKHsgZGVjaW1hbHMgfSkgPT5cbiAgICBpc1ZhbGlkRGVjaW1hbHMoZGVjaW1hbHMpLFxuICApO1xuICBmb3IgKGNvbnN0IHRva2VuIG9mIHZhbGlkVG9rZW5zKSB7XG4gICAgLy8gSW4gdGhlIGNhc2Ugb2YgYSBkZWNpbWFsIHZhbHVlIHR5cGUgc3RyaW5nLCBjb252ZXJ0IHRvIGEgbnVtYmVyLlxuICAgIGlmICh0eXBlb2YgdG9rZW4uZGVjaW1hbHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmFkaXhcbiAgICAgIHRva2VuLmRlY2ltYWxzID0gcGFyc2VJbnQodG9rZW4uZGVjaW1hbHMpO1xuICAgIH1cbiAgfVxuICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIudG9rZW5zID0gdmFsaWRUb2tlbnM7XG5cbiAgY29uc3QgeyBhY2NvdW50VG9rZW5zIH0gPSBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXI7XG4gIGlmIChhY2NvdW50VG9rZW5zICYmIHR5cGVvZiBhY2NvdW50VG9rZW5zID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBPYmplY3Qua2V5cyhhY2NvdW50VG9rZW5zKSkge1xuICAgICAgY29uc3QgbmV0d29ya1Rva2VucyA9IGFjY291bnRUb2tlbnNbYWRkcmVzc107XG4gICAgICBpZiAobmV0d29ya1Rva2VucyAmJiB0eXBlb2YgbmV0d29ya1Rva2VucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yIChjb25zdCBuZXR3b3JrIG9mIE9iamVjdC5rZXlzKG5ldHdvcmtUb2tlbnMpKSB7XG4gICAgICAgICAgY29uc3QgdG9rZW5zT25OZXR3b3JrID0gbmV0d29ya1Rva2Vuc1tuZXR3b3JrXSB8fCBbXTtcbiAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGFueSB0b2tlbnMgd2l0aCBjb3JydXB0ZWQgZGVjaW1hbCB2YWx1ZXNcbiAgICAgICAgICBjb25zdCB2YWxpZFRva2Vuc09uTmV0d29yayA9IHRva2Vuc09uTmV0d29yay5maWx0ZXIoKHsgZGVjaW1hbHMgfSkgPT5cbiAgICAgICAgICAgIGlzVmFsaWREZWNpbWFscyhkZWNpbWFscyksXG4gICAgICAgICAgKTtcbiAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhIGRlY2ltYWwgdmFsdWUgdHlwZSBzdHJpbmcsIGNvbnZlcnQgdG8gYSBudW1iZXIuXG4gICAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiB2YWxpZFRva2Vuc09uTmV0d29yaykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbi5kZWNpbWFscyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJhZGl4XG4gICAgICAgICAgICAgIHRva2VuLmRlY2ltYWxzID0gcGFyc2VJbnQodG9rZW4uZGVjaW1hbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBuZXR3b3JrVG9rZW5zW25ldHdvcmtdID0gdmFsaWRUb2tlbnNPbk5ldHdvcms7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnMgPSBhY2NvdW50VG9rZW5zO1xuXG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCwgbWFwS2V5cyB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBCVUlMVF9JTl9ORVRXT1JLUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XG5cbmNvbnN0IHZlcnNpb24gPSA1NTtcblxuLyoqXG4gKiByZXBsYWNlICdpbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja3NCeU5ldHdvcmsnIHdpdGggJ2luY29taW5nVHhMYXN0RmV0Y2hlZEJsb2NrQnlDaGFpbklkJ1xuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5jb25zdCBVTktOT1dOX0NIQUlOX0lEX0tFWSA9ICdVTktOT1dOJztcblxuQlVJTFRfSU5fTkVUV09SS1Mucmlua2VieSA9IHtcbiAgbmV0d29ya0lkOiAnNCcsXG4gIGNoYWluSWQ6ICcweDQnLFxuICB0aWNrZXI6ICdFVEgnLFxufTtcbkJVSUxUX0lOX05FVFdPUktTLnJvcHN0ZW4gPSB7XG4gIG5ldHdvcmtJZDogJzMnLFxuICBjaGFpbklkOiAnMHgzJyxcbiAgdGlja2VyOiAnRVRIJyxcbn07XG5CVUlMVF9JTl9ORVRXT1JLUy5rb3ZhbiA9IHtcbiAgbmV0d29ya0lkOiAnNDInLFxuICBjaGFpbklkOiAnMHgyYScsXG4gIHRpY2tlcjogJ0VUSCcsXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBpZiAoXG4gICAgc3RhdGU/LkluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlcj8uaW5jb21pbmdUeExhc3RGZXRjaGVkQmxvY2tzQnlOZXR3b3JrXG4gICkge1xuICAgIHN0YXRlLkluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlci5pbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja0J5Q2hhaW5JZCA9XG4gICAgICBtYXBLZXlzKFxuICAgICAgICBzdGF0ZS5JbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXJcbiAgICAgICAgICAuaW5jb21pbmdUeExhc3RGZXRjaGVkQmxvY2tzQnlOZXR3b3JrLFxuICAgICAgICAvLyB1c2luZyBvcHRpb25hbCBjaGFpbmluZyBpbiBjYXNlIHVzZXIncyBzdGF0ZSBoYXMgZmV0Y2hlZCBibG9ja3MgZm9yXG4gICAgICAgIC8vIFJQQyBuZXR3b3JrIHR5cGVzICh3aGljaCBkb24ndCBtYXAgdG8gYSBzaW5nbGUgY2hhaW5JZCkuIFRoaXMgc2hvdWxkXG4gICAgICAgIC8vIG5vdCBiZSBwb3NzaWJsZSwgYnV0IGl0J3Mgc2FmZXJcbiAgICAgICAgKF8sIGtleSkgPT4gQlVJTFRfSU5fTkVUV09SS1Nba2V5XT8uY2hhaW5JZCA/PyBVTktOT1dOX0NIQUlOX0lEX0tFWSxcbiAgICAgICk7XG4gICAgLy8gTm93IHRoYXQgbWFpbm5ldCBhbmQgdGVzdCBuZXQgbGFzdCBmZXRjaGVkIGJsb2NrcyBhcmUga2V5ZWQgYnkgdGhlaXJcbiAgICAvLyByZXNwZWN0aXZlIGNoYWluSWRzLCB3ZSBjYW4gc2FmZWx5IGRlbGV0ZSBhbnl0aGluZyB3ZSBoYWQgZm9yIGN1c3RvbVxuICAgIC8vIG5ldHdvcmtzLiBBbnkgY3VzdG9tIG5ldHdvcmsgdGhhdCBzaGFyZXMgYSBjaGFpbklkIHdpdGggb25lIG9mIHRoZVxuICAgIC8vIGFmb3JlbWVudGlvbmVkIG5ldHdvcmtzIHdpbGwgdXNlIHRoZSB2YWx1ZSBzdG9yZWQgYnkgY2hhaW5JZC5cbiAgICBkZWxldGUgc3RhdGUuSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyXG4gICAgICAuaW5jb21pbmdUeExhc3RGZXRjaGVkQmxvY2tCeUNoYWluSWRbVU5LTk9XTl9DSEFJTl9JRF9LRVldO1xuICAgIGRlbGV0ZSBzdGF0ZS5JbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXJcbiAgICAgIC5pbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja3NCeU5ldHdvcms7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDU2O1xuXG4vKipcbiAqIFJlbW92ZSB0b2tlbnMgdGhhdCBkb24ndCBoYXZlIGFuIGFkZHJlc3MgZHVlIHRvXG4gKiBsYWNrIG9mIHByZXZpb3VzIGFkZFRva2VuIHZhbGlkYXRpb24uICBBbHNvIHJlbW92ZXNcbiAqIGFuIHVud2FudGVkLCB1bmRlZmluZWQgaW1hZ2UgcHJvcGVydHlcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG5cbiAgICBjb25zdCB7IFByZWZlcmVuY2VzQ29udHJvbGxlciB9ID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoUHJlZmVyZW5jZXNDb250cm9sbGVyPy50b2tlbnMpKSB7XG4gICAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXIudG9rZW5zID0gUHJlZmVyZW5jZXNDb250cm9sbGVyLnRva2Vucy5maWx0ZXIoXG4gICAgICAgICh7IGFkZHJlc3MgfSkgPT4gYWRkcmVzcyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hY2NvdW50VG9rZW5zICYmXG4gICAgICB0eXBlb2YgUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnMgPT09ICdvYmplY3QnXG4gICAgKSB7XG4gICAgICBPYmplY3Qua2V5cyhQcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWNjb3VudFRva2VucykuZm9yRWFjaCgoYWNjb3VudCkgPT4ge1xuICAgICAgICBjb25zdCBjaGFpbnMgPSBPYmplY3Qua2V5cyhcbiAgICAgICAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWNjb3VudFRva2Vuc1thY2NvdW50XSxcbiAgICAgICAgKTtcbiAgICAgICAgY2hhaW5zLmZvckVhY2goKGNoYWluKSA9PiB7XG4gICAgICAgICAgUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnNbYWNjb3VudF1bY2hhaW5dID1cbiAgICAgICAgICAgIFByZWZlcmVuY2VzQ29udHJvbGxlci5hY2NvdW50VG9rZW5zW2FjY291bnRdW2NoYWluXS5maWx0ZXIoXG4gICAgICAgICAgICAgICh7IGFkZHJlc3MgfSkgPT4gYWRkcmVzcyxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hc3NldEltYWdlcyAmJlxuICAgICAgJ3VuZGVmaW5lZCcgaW4gUHJlZmVyZW5jZXNDb250cm9sbGVyLmFzc2V0SW1hZ2VzXG4gICAgKSB7XG4gICAgICBkZWxldGUgUHJlZmVyZW5jZXNDb250cm9sbGVyLmFzc2V0SW1hZ2VzLnVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAsIGtleUJ5IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBjcmVhdGVJZCBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9yYW5kb20taWQnO1xuXG5jb25zdCB2ZXJzaW9uID0gNTc7XG5cbi8qKlxuICogcmVwbGFjZSAnaW5jb21pbmdUeExhc3RGZXRjaGVkQmxvY2tzQnlOZXR3b3JrJyB3aXRoICdpbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja0J5Q2hhaW5JZCdcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgaWYgKFxuICAgIHN0YXRlPy5UcmFuc2FjdGlvbkNvbnRyb2xsZXI/LnRyYW5zYWN0aW9ucyAmJlxuICAgIEFycmF5LmlzQXJyYXkoc3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucykgJiZcbiAgICAhc3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucy5zb21lKFxuICAgICAgKGl0ZW0pID0+XG4gICAgICAgIHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgaXRlbS50eFBhcmFtcyA9PT0gJ3VuZGVmaW5lZCcsXG4gICAgKVxuICApIHtcbiAgICBzdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zID0ga2V5QnkoXG4gICAgICBzdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zLFxuICAgICAgLy8gSW4gY2FzZSBmb3Igc29tZSByZWFzb24gYW55IG9mIGEgdXNlcidzIHRyYW5zYWN0aW9ucyBkbyBub3QgaGF2ZSBhbiBpZFxuICAgICAgLy8gZ2VuZXJhdGUgYSBuZXcgb25lIGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAodHgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eC5pZCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHguaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUaGlzIG11dGF0ZXMgdGhlIGl0ZW0gaW4gdGhlIGFycmF5LCBzbyB3aWxsIHJlc3VsdCBpbiBhIGNoYW5nZSB0b1xuICAgICAgICAgIC8vIHRoZSBzdGF0ZS5cbiAgICAgICAgICB0eC5pZCA9IGNyZWF0ZUlkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR4LmlkO1xuICAgICAgfSxcbiAgICApO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA1ODtcblxuLyoqXG4gKiBEZWxldGVzIHRoZSBzd2Fwc1dlbGNvbWVNZXNzYWdlSGFzQmVlblNob3duIHByb3BlcnR5IGZyb20gc3RhdGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgZGVsZXRlIHN0YXRlLkFwcFN0YXRlQ29udHJvbGxlcj8uc3dhcHNXZWxjb21lTWVzc2FnZUhhc0JlZW5TaG93bjtcblxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQge1xuICBjbG9uZURlZXAsXG4gIGNvbmNhdCxcbiAgZ3JvdXBCeSxcbiAga2V5QnksXG4gIHBpY2tCeSxcbiAgaXNQbGFpbk9iamVjdCxcbn0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuXG5jb25zdCB2ZXJzaW9uID0gNTk7XG5cbi8qKlxuICogUmVtb3ZlcyBvcnBoYW5lZCBjYW5jZWwgYW5kIHJldHJ5IHRyYW5zYWN0aW9ucyB0aGF0IG5vIGxvbmdlciBoYXZlIHRoZVxuICogb3JpZ2luYWwgdHJhbnNhY3Rpb24gaW4gc3RhdGUsIHdoaWNoIHJlc3VsdHMgaW4gYnVncy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgdHJhbnNhY3Rpb25zID0gc3RhdGU/LlRyYW5zYWN0aW9uQ29udHJvbGxlcj8udHJhbnNhY3Rpb25zO1xuICBpZiAoaXNQbGFpbk9iamVjdCh0cmFuc2FjdGlvbnMpKSB7XG4gICAgY29uc3Qgbm9uY2VOZXR3b3JrR3JvdXBlZE9iamVjdCA9IGdyb3VwQnkoXG4gICAgICBPYmplY3QudmFsdWVzKHRyYW5zYWN0aW9ucyksXG4gICAgICAodHgpID0+IHtcbiAgICAgICAgcmV0dXJuIGAke3R4LnR4UGFyYW1zPy5ub25jZX0tJHt0eC5jaGFpbklkID8/IHR4Lm1ldGFtYXNrTmV0d29ya0lkfWA7XG4gICAgICB9LFxuICAgICk7XG5cbiAgICBjb25zdCB3aXRob3V0T3JwaGFucyA9IHBpY2tCeShub25jZU5ldHdvcmtHcm91cGVkT2JqZWN0LCAoZ3JvdXApID0+IHtcbiAgICAgIHJldHVybiBncm91cC5zb21lKFxuICAgICAgICAodHgpID0+XG4gICAgICAgICAgdHgudHlwZSAhPT0gVHJhbnNhY3Rpb25UeXBlLmNhbmNlbCAmJlxuICAgICAgICAgIHR4LnR5cGUgIT09IFRyYW5zYWN0aW9uVHlwZS5yZXRyeSxcbiAgICAgICk7XG4gICAgfSk7XG4gICAgc3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IGtleUJ5KFxuICAgICAgY29uY2F0KC4uLk9iamVjdC52YWx1ZXMod2l0aG91dE9ycGhhbnMpKSxcbiAgICAgICh0eCkgPT4gdHguaWQsXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCwgaXNQbGFpbk9iamVjdCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA2MDtcbmNvbnN0IFNVUFBPUlRfTk9USUZJQ0FUSU9OX0tFWSA9IDI7XG5jb25zdCBTVVBQT1JUX05PVElGSUNBVElPTl9EQVRFID0gJzIwMjAtMDgtMzEnO1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIHN1cHBvcnQgc3VydmV5IG5vdGlmaWNhdGlvblxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5vdGlmaWNhdGlvbnMgPSBzdGF0ZT8uTm90aWZpY2F0aW9uQ29udHJvbGxlcj8ubm90aWZpY2F0aW9ucztcbiAgaWYgKGlzUGxhaW5PYmplY3Qobm90aWZpY2F0aW9ucykpIHtcbiAgICBpZiAoXG4gICAgICBub3RpZmljYXRpb25zW1NVUFBPUlRfTk9USUZJQ0FUSU9OX0tFWV0/LmRhdGUgPT09XG4gICAgICBTVVBQT1JUX05PVElGSUNBVElPTl9EQVRFXG4gICAgKSB7XG4gICAgICBkZWxldGUgc3RhdGUuTm90aWZpY2F0aW9uQ29udHJvbGxlci5ub3RpZmljYXRpb25zW1xuICAgICAgICBTVVBQT1JUX05PVElGSUNBVElPTl9LRVlcbiAgICAgIF07XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA2MTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGF0dHJpYnV0ZXMgcmVsYXRlZCB0byByZWNvdmVyeSBzZWVkIHBocmFzZSByZW1pbmRlclxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIGlmIChzdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXIpIHtcbiAgICBzdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXIucmVjb3ZlcnlQaHJhc2VSZW1pbmRlckhhc0JlZW5TaG93biA9IGZhbHNlO1xuICAgIHN0YXRlLkFwcFN0YXRlQ29udHJvbGxlci5yZWNvdmVyeVBocmFzZVJlbWluZGVyTGFzdFNob3duID0gY3VycmVudFRpbWU7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuQXBwU3RhdGVDb250cm9sbGVyID0ge1xuICAgICAgcmVjb3ZlcnlQaHJhc2VSZW1pbmRlckhhc0JlZW5TaG93bjogZmFsc2UsXG4gICAgICByZWNvdmVyeVBocmFzZVJlbWluZGVyTGFzdFNob3duOiBjdXJyZW50VGltZSxcbiAgICB9O1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA2MjtcblxuLyoqXG4gKiBSZW1vdmVzIG1ldGFNZXRyaWNzU2VuZENvdW50IGZyb20gTWV0YU1ldHJpY3MgY29udHJvbGxlclxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5NZXRhTWV0cmljc0NvbnRyb2xsZXIpIHtcbiAgICBjb25zdCB7IG1ldGFNZXRyaWNzU2VuZENvdW50IH0gPSBzdGF0ZS5NZXRhTWV0cmljc0NvbnRyb2xsZXI7XG4gICAgaWYgKG1ldGFNZXRyaWNzU2VuZENvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlbGV0ZSBzdGF0ZS5NZXRhTWV0cmljc0NvbnRyb2xsZXIubWV0YU1ldHJpY3NTZW5kQ291bnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA2MztcblxuLyoqXG4gKiBNb3ZlcyB0b2tlbiBzdGF0ZSBmcm9tIHByZWZlcmVuY2VzIGNvbnRyb2xsZXIgdG8gVG9rZW5zQ29udHJvbGxlclxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IGFjY291bnRUb2tlbnMgPSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hY2NvdW50VG9rZW5zO1xuICBjb25zdCBhY2NvdW50SGlkZGVuVG9rZW5zID0gc3RhdGU/LlByZWZlcmVuY2VzQ29udHJvbGxlcj8uYWNjb3VudEhpZGRlblRva2VucztcblxuICBjb25zdCBuZXdBbGxUb2tlbnMgPSB7fTtcbiAgaWYgKGFjY291bnRUb2tlbnMpIHtcbiAgICBPYmplY3Qua2V5cyhhY2NvdW50VG9rZW5zKS5mb3JFYWNoKChhY2NvdW50QWRkcmVzcykgPT4ge1xuICAgICAgT2JqZWN0LmtleXMoYWNjb3VudFRva2Vuc1thY2NvdW50QWRkcmVzc10pLmZvckVhY2goKGNoYWluSWQpID0+IHtcbiAgICAgICAgY29uc3QgdG9rZW5zQXJyYXkgPSBhY2NvdW50VG9rZW5zW2FjY291bnRBZGRyZXNzXVtjaGFpbklkXTtcbiAgICAgICAgaWYgKG5ld0FsbFRva2Vuc1tjaGFpbklkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbmV3QWxsVG9rZW5zW2NoYWluSWRdID0geyBbYWNjb3VudEFkZHJlc3NdOiB0b2tlbnNBcnJheSB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0FsbFRva2Vuc1tjaGFpbklkXSA9IHtcbiAgICAgICAgICAgIC4uLm5ld0FsbFRva2Vuc1tjaGFpbklkXSxcbiAgICAgICAgICAgIFthY2NvdW50QWRkcmVzc106IHRva2Vuc0FycmF5LFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgbmV3QWxsSWdub3JlZFRva2VucyA9IHt9O1xuICBpZiAoYWNjb3VudEhpZGRlblRva2Vucykge1xuICAgIE9iamVjdC5rZXlzKGFjY291bnRIaWRkZW5Ub2tlbnMpLmZvckVhY2goKGFjY291bnRBZGRyZXNzKSA9PiB7XG4gICAgICBPYmplY3Qua2V5cyhhY2NvdW50SGlkZGVuVG9rZW5zW2FjY291bnRBZGRyZXNzXSkuZm9yRWFjaCgoY2hhaW5JZCkgPT4ge1xuICAgICAgICBjb25zdCBpZ25vcmVkVG9rZW5zQXJyYXkgPSBhY2NvdW50SGlkZGVuVG9rZW5zW2FjY291bnRBZGRyZXNzXVtjaGFpbklkXTtcbiAgICAgICAgaWYgKG5ld0FsbElnbm9yZWRUb2tlbnNbY2hhaW5JZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5ld0FsbElnbm9yZWRUb2tlbnNbY2hhaW5JZF0gPSB7XG4gICAgICAgICAgICBbYWNjb3VudEFkZHJlc3NdOiBpZ25vcmVkVG9rZW5zQXJyYXksXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdBbGxJZ25vcmVkVG9rZW5zW2NoYWluSWRdID0ge1xuICAgICAgICAgICAgLi4ubmV3QWxsSWdub3JlZFRva2Vuc1tjaGFpbklkXSxcbiAgICAgICAgICAgIFthY2NvdW50QWRkcmVzc106IGlnbm9yZWRUb2tlbnNBcnJheSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5Ub2tlbnNDb250cm9sbGVyKSB7XG4gICAgc3RhdGUuVG9rZW5zQ29udHJvbGxlci5hbGxUb2tlbnMgPSBuZXdBbGxUb2tlbnM7XG4gICAgc3RhdGUuVG9rZW5zQ29udHJvbGxlci5hbGxJZ25vcmVkVG9rZW5zID0gbmV3QWxsSWdub3JlZFRva2VucztcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5Ub2tlbnNDb250cm9sbGVyID0ge1xuICAgICAgYWxsVG9rZW5zOiBuZXdBbGxUb2tlbnMsXG4gICAgICBhbGxJZ25vcmVkVG9rZW5zOiBuZXdBbGxJZ25vcmVkVG9rZW5zLFxuICAgIH07XG4gIH1cblxuICBkZWxldGUgc3RhdGU/LlByZWZlcmVuY2VzQ29udHJvbGxlcj8uYWNjb3VudEhpZGRlblRva2VucztcbiAgZGVsZXRlIHN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LmFjY291bnRUb2tlbnM7XG4gIGRlbGV0ZSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hc3NldEltYWdlcztcbiAgZGVsZXRlIHN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LmhpZGRlblRva2VucztcbiAgZGVsZXRlIHN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LnRva2VucztcbiAgZGVsZXRlIHN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LnN1Z2dlc3RlZFRva2VucztcblxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAsIGlzUGxhaW5PYmplY3QgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5cbmNvbnN0IHZlcnNpb24gPSA2NDtcblxuY29uc3QgU0VOVF9FVEhFUiA9ICdzZW50RXRoZXInOyAvLyB0aGUgbGVnYWN5IHRyYW5zYWN0aW9uIHR5cGUgYmVpbmcgcmVwbGFjZWQgaW4gdGhpcyBtaWdyYXRpb24gd2l0aCBUcmFuc2FjdGlvblR5cGUuc2ltcGxlU2VuZFxuXG4vKipcbiAqIFJlbW92ZXMgbWV0YU1ldHJpY3NTZW5kQ291bnQgZnJvbSBNZXRhTWV0cmljcyBjb250cm9sbGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgdHJhbnNhY3Rpb25zID0gc3RhdGU/LlRyYW5zYWN0aW9uQ29udHJvbGxlcj8udHJhbnNhY3Rpb25zO1xuICBpZiAoaXNQbGFpbk9iamVjdCh0cmFuc2FjdGlvbnMpKSB7XG4gICAgZm9yIChjb25zdCB0eCBvZiBPYmplY3QudmFsdWVzKHRyYW5zYWN0aW9ucykpIHtcbiAgICAgIGlmICh0eC50eXBlID09PSBTRU5UX0VUSEVSKSB7XG4gICAgICAgIHR4LnR5cGUgPSBUcmFuc2FjdGlvblR5cGUuc2ltcGxlU2VuZDtcbiAgICAgIH1cbiAgICAgIGlmICh0eC5oaXN0b3J5KSB7XG4gICAgICAgIHR4Lmhpc3RvcnkubWFwKCh0eEV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKHR4RXZlbnQudHlwZSAmJiB0eEV2ZW50LnR5cGUgPT09IFNFTlRfRVRIRVIpIHtcbiAgICAgICAgICAgIHR4RXZlbnQudHlwZSA9IFRyYW5zYWN0aW9uVHlwZS5zaW1wbGVTZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHhFdmVudDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA2NTtcblxuLyoqXG4gKiBSZW1vdmVzIG1ldGFNZXRyaWNzU2VuZENvdW50IGZyb20gTWV0YU1ldHJpY3MgY29udHJvbGxlclxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIpIHtcbiAgICBjb25zdCB7IGNvbXBsZXRlZE9uYm9hcmRpbmcsIGZpcnN0VGltZUZsb3dUeXBlIH0gPVxuICAgICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyO1xuICAgIHN0YXRlLk9uYm9hcmRpbmdDb250cm9sbGVyID0gc3RhdGUuT25ib2FyZGluZ0NvbnRyb2xsZXIgPz8ge307XG5cbiAgICBpZiAoY29tcGxldGVkT25ib2FyZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdGF0ZS5PbmJvYXJkaW5nQ29udHJvbGxlci5jb21wbGV0ZWRPbmJvYXJkaW5nID0gY29tcGxldGVkT25ib2FyZGluZztcbiAgICAgIGRlbGV0ZSBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuY29tcGxldGVkT25ib2FyZGluZztcbiAgICB9XG4gICAgaWYgKGZpcnN0VGltZUZsb3dUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0YXRlLk9uYm9hcmRpbmdDb250cm9sbGVyLmZpcnN0VGltZUZsb3dUeXBlID0gZmlyc3RUaW1lRmxvd1R5cGU7XG4gICAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmZpcnN0VGltZUZsb3dUeXBlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBMZWRnZXJUcmFuc3BvcnRUeXBlcyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvaGFyZHdhcmUtd2FsbGV0cyc7XG5cbmNvbnN0IHZlcnNpb24gPSA2NjtcblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSB1c2VMZWRnZXJMaXZlIGJvb2xlYW4gcHJvcGVydHkgdG8gdGhlIGxlZGdlclRyYW5zcG9ydFR5cGUgZW51bVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IGRlZmF1bHRUcmFuc3BvcnRUeXBlID0gd2luZG93Lm5hdmlnYXRvci5oaWRcbiAgICA/IExlZGdlclRyYW5zcG9ydFR5cGVzLndlYmhpZFxuICAgIDogTGVkZ2VyVHJhbnNwb3J0VHlwZXMudTJmO1xuICBjb25zdCB1c2VMZWRnZXJMaXZlID0gQm9vbGVhbihzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LnVzZUxlZGdlckxpdmUpO1xuICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXI6IHtcbiAgICAgIC4uLnN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICBsZWRnZXJUcmFuc3BvcnRUeXBlOiB1c2VMZWRnZXJMaXZlXG4gICAgICAgID8gTGVkZ2VyVHJhbnNwb3J0VHlwZXMubGl2ZVxuICAgICAgICA6IGRlZmF1bHRUcmFuc3BvcnRUeXBlLFxuICAgIH0sXG4gIH07XG4gIGRlbGV0ZSBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIudXNlTGVkZ2VyTGl2ZTtcbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IFRFU1RfQ0hBSU5TIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcblxuY29uc3QgaGV4TnVtYmVySXNHcmVhdGVyVGhhblplcm8gPSAoaGV4TnVtYmVyKSA9PlxuICBuZXcgQmlnTnVtYmVyKGhleE51bWJlciB8fCAnMHgwJywgMTYpLmd0KDApO1xuXG5jb25zdCB2ZXJzaW9uID0gNjc7XG5cbi8qKlxuICogU2V0cyB0aGUgc2hvd1Rlc3ROZXR3b3JrcyBwcm9wZXJ0eSB0byB0cnVlIGlmIGl0IHdhcyBmYWxzZSBvciB1bmRlZmluZWQsIGFuZCB0aGVyZSBpcyBldmlkZW5jZVxuICogdGhhdCB0aGUgdXNlciBoYXMgdXNlZCBhIHRlc3QgbmV0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgUHJlZmVyZW5jZXNDb250cm9sbGVyID0gc3RhdGU/LlByZWZlcmVuY2VzQ29udHJvbGxlciB8fCB7fTtcbiAgY29uc3QgcHJlZmVyZW5jZXMgPSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIucHJlZmVyZW5jZXMgfHwge307XG5cbiAgaWYgKHByZWZlcmVuY2VzLnNob3dUZXN0TmV0d29ya3MpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCB0cmFuc2FjdGlvbnMgPSBzdGF0ZT8uVHJhbnNhY3Rpb25Db250cm9sbGVyPy50cmFuc2FjdGlvbnMgfHwge307XG4gIGNvbnN0IHByb3ZpZGVyID0gc3RhdGUuTmV0d29ya0NvbnRyb2xsZXI/LnByb3ZpZGVyIHx8IHt9O1xuICBjb25zdCBjYWNoZWRCYWxhbmNlcyA9IHN0YXRlLkNhY2hlZEJhbGFuY2VzQ29udHJvbGxlcj8uY2FjaGVkQmFsYW5jZXMgfHwge307XG5cbiAgY29uc3QgdXNlcklzQ3VycmVudGx5T25BVGVzdE5ldCA9IFRFU1RfQ0hBSU5TLmluY2x1ZGVzKHByb3ZpZGVyPy5jaGFpbklkKTtcbiAgY29uc3QgdXNlckhhc01hZGVBVGVzdE5ldFRyYW5zYWN0aW9uID0gT2JqZWN0LnZhbHVlcyh0cmFuc2FjdGlvbnMpLnNvbWUoXG4gICAgKHsgY2hhaW5JZCB9KSA9PiBURVNUX0NIQUlOUy5pbmNsdWRlcyhjaGFpbklkKSxcbiAgKTtcbiAgY29uc3QgdXNlckhhc0FDYWNoZWRCYWxhbmNlT25BVGVzdG5ldCA9IFRFU1RfQ0hBSU5TLnNvbWUoKGNoYWluSWQpID0+IHtcbiAgICBjb25zdCBjYWNoZWRCYWxhbmNlc0ZvckNoYWluID0gT2JqZWN0LnZhbHVlcyhjYWNoZWRCYWxhbmNlc1tjaGFpbklkXSB8fCB7fSk7XG4gICAgY29uc3QgdXNlckhhc0FCYWxhbmNlR3JlYXRlclRoYW5aZXJvT25UaGlzQ2hhaW4gPVxuICAgICAgY2FjaGVkQmFsYW5jZXNGb3JDaGFpbi5zb21lKGhleE51bWJlcklzR3JlYXRlclRoYW5aZXJvKTtcbiAgICByZXR1cm4gdXNlckhhc0FCYWxhbmNlR3JlYXRlclRoYW5aZXJvT25UaGlzQ2hhaW47XG4gIH0pO1xuICBjb25zdCB1c2VySGFzVXNlZEFUZXN0bmV0ID1cbiAgICB1c2VySXNDdXJyZW50bHlPbkFUZXN0TmV0IHx8XG4gICAgdXNlckhhc01hZGVBVGVzdE5ldFRyYW5zYWN0aW9uIHx8XG4gICAgdXNlckhhc0FDYWNoZWRCYWxhbmNlT25BVGVzdG5ldDtcblxuICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXI6IHtcbiAgICAgIC4uLlByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgIHByZWZlcmVuY2VzOiB7XG4gICAgICAgIC4uLnByZWZlcmVuY2VzLFxuICAgICAgICBzaG93VGVzdE5ldHdvcmtzOiB1c2VySGFzVXNlZEFUZXN0bmV0LFxuICAgICAgfSxcbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA2ODtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSBQZXJtaXNzaW9uc0NvbnRyb2xsZXIgYW5kIFBlcm1pc3Npb25zTWV0YWRhdGEgc3Vic3RhdGVzXG4gKiB0byBtYXRjaCB0aGUgbmV3IHBlcm1pc3Npb24gc3lzdGVtLlxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IHtcbiAgICBQZXJtaXNzaW9uc0NvbnRyb2xsZXIgPSB7fSxcbiAgICBQZXJtaXNzaW9uc01ldGFkYXRhID0ge30sXG4gICAgLi4ucmVtYWluaW5nU3RhdGVcbiAgfSA9IHN0YXRlO1xuXG4gIGNvbnN0IHtcbiAgICBkb21haW5NZXRhZGF0YSA9IHt9LFxuICAgIHBlcm1pc3Npb25zSGlzdG9yeSA9IHt9LFxuICAgIHBlcm1pc3Npb25zTG9nID0gW10sXG4gIH0gPSBQZXJtaXNzaW9uc01ldGFkYXRhO1xuXG4gIHJldHVybiB7XG4gICAgLi4ucmVtYWluaW5nU3RhdGUsXG4gICAgUGVybWlzc2lvbkNvbnRyb2xsZXI6IGdldFBlcm1pc3Npb25Db250cm9sbGVyU3RhdGUoUGVybWlzc2lvbnNDb250cm9sbGVyKSxcbiAgICBQZXJtaXNzaW9uTG9nQ29udHJvbGxlcjoge1xuICAgICAgcGVybWlzc2lvbkFjdGl2aXR5TG9nOiBwZXJtaXNzaW9uc0xvZyxcbiAgICAgIHBlcm1pc3Npb25IaXN0b3J5OiBwZXJtaXNzaW9uc0hpc3RvcnksXG4gICAgfSxcbiAgICBTdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyOlxuICAgICAgZ2V0U3ViamVjdE1ldGFkYXRhQ29udHJvbGxlclN0YXRlKGRvbWFpbk1ldGFkYXRhKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UGVybWlzc2lvbkNvbnRyb2xsZXJTdGF0ZShQZXJtaXNzaW9uc0NvbnRyb2xsZXIpIHtcbiAgY29uc3QgeyBkb21haW5zID0ge30gfSA9IFBlcm1pc3Npb25zQ29udHJvbGxlcjtcblxuICAvKipcbiAgICogRXhhbXBsZSBleGlzdGluZyBkb21haW4gZW50cnkuIEV2ZXJ5IGV4aXN0aW5nIGRvbWFpbiB3aWxsIGhhdmUgYSBzaW5nbGVcbiAgICogZXRoX2FjY291bnRzIHBlcm1pc3Npb24sIHdoaWNoIHNpbXBsaWZpZXMgdGhlIHRyYW5zZm9ybS5cbiAgICpcbiAgICogJ2h0dHBzOi8vbWV0YW1hc2suZ2l0aHViLmlvJzoge1xuICAgKiAgIHBlcm1pc3Npb25zOiBbXG4gICAqICAgICB7XG4gICAqICAgICAgICdAY29udGV4dCc6IFsnaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL3JwYy1jYXAnXSxcbiAgICogICAgICAgJ2NhdmVhdHMnOiBbXG4gICAqICAgICAgICAge1xuICAgKiAgICAgICAgICAgbmFtZTogJ3ByaW1hcnlBY2NvdW50T25seScsXG4gICAqICAgICAgICAgICB0eXBlOiAnbGltaXRSZXNwb25zZUxlbmd0aCcsXG4gICAqICAgICAgICAgICB2YWx1ZTogMSxcbiAgICogICAgICAgICB9LFxuICAgKiAgICAgICAgIHtcbiAgICogICAgICAgICAgIG5hbWU6ICdleHBvc2VkQWNjb3VudHMnLFxuICAgKiAgICAgICAgICAgdHlwZTogJ2ZpbHRlclJlc3BvbnNlJyxcbiAgICogICAgICAgICAgIHZhbHVlOiBbJzB4MGM5N2E1YzgxZTUwYTAyZmY4YmU3M2NjM2YwYTA1NjllNjFmNGVkOCddLFxuICAgKiAgICAgICAgIH0sXG4gICAqICAgICAgIF0sXG4gICAqICAgICAgICdkYXRlJzogMTYxNjAwNjM2OTQ5OCxcbiAgICogICAgICAgJ2lkJzogJzNkMGJkYzI3LWU4ZTQtNGZiMC1hMjRiLTM0MGQ2MWY2YTNmYScsXG4gICAqICAgICAgICdpbnZva2VyJzogJ2h0dHBzOi8vbWV0YW1hc2suZ2l0aHViLmlvJyxcbiAgICogICAgICAgJ3BhcmVudENhcGFiaWxpdHknOiAnZXRoX2FjY291bnRzJyxcbiAgICogICAgIH0sXG4gICAqICAgXSxcbiAgICogfSxcbiAgICovXG5cbiAgY29uc3QgRVRIX0FDQ09VTlRTID0gJ2V0aF9hY2NvdW50cyc7XG4gIGNvbnN0IE5FV19DQVZFQVRfVFlQRSA9ICdyZXN0cmljdFJldHVybmVkQWNjb3VudHMnO1xuICBjb25zdCBPTERfQ0FWRUFUX05BTUUgPSAnZXhwb3NlZEFjY291bnRzJztcblxuICBjb25zdCBzdWJqZWN0cyA9IE9iamVjdC5lbnRyaWVzKGRvbWFpbnMpLnJlZHVjZShcbiAgICAodHJhbnNmb3JtZWQsIFtvcmlnaW4sIGRvbWFpbkVudHJ5XSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwZXJtaXNzaW9uczogW2V0aEFjY291bnRzUGVybWlzc2lvbl0sXG4gICAgICB9ID0gZG9tYWluRW50cnk7XG5cbiAgICAgIC8vIFRoZXJlIGFyZSB0d28gY2F2ZWF0cyBmb3IgZWFjaCBldGhfYWNjb3VudHMgcGVybWlzc2lvbiwgYnV0IHdlIG9ubHlcbiAgICAgIC8vIG5lZWQgdGhlIHZhbHVlIG9mIG9uZSBvZiB0aGVtIGluIHRoZSBuZXcgcGVybWlzc2lvbiBzeXN0ZW0uXG4gICAgICBjb25zdCBvbGRDYXZlYXQgPSBldGhBY2NvdW50c1Blcm1pc3Npb24uY2F2ZWF0cy5maW5kKFxuICAgICAgICAoY2F2ZWF0KSA9PiBjYXZlYXQubmFtZSA9PT0gT0xEX0NBVkVBVF9OQU1FLFxuICAgICAgKTtcblxuICAgICAgY29uc3QgbmV3UGVybWlzc2lvbiA9IHtcbiAgICAgICAgLi4uZXRoQWNjb3VudHNQZXJtaXNzaW9uLFxuICAgICAgICBjYXZlYXRzOiBbeyB0eXBlOiBORVdfQ0FWRUFUX1RZUEUsIHZhbHVlOiBvbGRDYXZlYXQudmFsdWUgfV0sXG4gICAgICB9O1xuXG4gICAgICAvLyBXZSBuZXZlciB1c2VkIHRoaXMsIGFuZCBqdXN0IG9taXQgaXQgaW4gdGhlIG5ldyBzeXN0ZW0uXG4gICAgICBkZWxldGUgbmV3UGVybWlzc2lvblsnQGNvbnRleHQnXTtcblxuICAgICAgdHJhbnNmb3JtZWRbb3JpZ2luXSA9IHtcbiAgICAgICAgb3JpZ2luLFxuICAgICAgICBwZXJtaXNzaW9uczoge1xuICAgICAgICAgIFtFVEhfQUNDT1VOVFNdOiBuZXdQZXJtaXNzaW9uLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgICB9LFxuICAgIHt9LFxuICApO1xuXG4gIHJldHVybiB7XG4gICAgc3ViamVjdHMsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXJTdGF0ZShkb21haW5NZXRhZGF0YSkge1xuICAvKipcbiAgICogRXhhbXBsZSBleGlzdGluZyBkb21haW5NZXRhZGF0YSBlbnRyeS5cbiAgICpcbiAgICogXCJodHRwczovL3d3dy55b3V0dWJlLmNvbVwiOiB7XG4gICAqICAgXCJob3N0XCI6IFwid3d3LnlvdXR1YmUuY29tXCIsXG4gICAqICAgXCJpY29uXCI6IG51bGwsXG4gICAqICAgXCJsYXN0VXBkYXRlZFwiOiAxNjM3Njk3OTE0OTA4LFxuICAgKiAgIFwibmFtZVwiOiBcIllvdVR1YmVcIlxuICAgKiB9XG4gICAqL1xuXG4gIGNvbnN0IHN1YmplY3RNZXRhZGF0YSA9IE9iamVjdC5lbnRyaWVzKGRvbWFpbk1ldGFkYXRhKS5yZWR1Y2UoXG4gICAgKHRyYW5zZm9ybWVkLCBbb3JpZ2luLCBtZXRhZGF0YV0pID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSA9IG51bGwsXG4gICAgICAgIGljb24gPSBudWxsLFxuICAgICAgICBleHRlbnNpb25JZCA9IG51bGwsXG4gICAgICAgIC4uLm90aGVyXG4gICAgICB9ID0gbWV0YWRhdGE7XG5cbiAgICAgIC8vIFdlJ3JlIGdldHRpbmcgcmlkIG9mIHRoZXNlLlxuICAgICAgZGVsZXRlIG90aGVyLmxhc3RVcGRhdGVkO1xuICAgICAgZGVsZXRlIG90aGVyLmhvc3Q7XG5cbiAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgdHJhbnNmb3JtZWRbb3JpZ2luXSA9IHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGljb25Vcmw6IGljb24sXG4gICAgICAgICAgZXh0ZW5zaW9uSWQsXG4gICAgICAgICAgLi4ub3RoZXIsXG4gICAgICAgICAgb3JpZ2luLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xuICAgIH0sXG4gICAge30sXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICBzdWJqZWN0TWV0YWRhdGEsXG4gIH07XG59XG4iLCJpbXBvcnQgeyBTdWJqZWN0VHlwZSB9IGZyb20gJ0BtZXRhbWFzay9zdWJqZWN0LW1ldGFkYXRhLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDY5O1xuXG4vKipcbiAqIEFkZHMgdGhlIGBzdWJqZWN0VHlwZWAgcHJvcGVydHkgdG8gYWxsIHN1YmplY3QgbWV0YWRhdGEuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgaWYgKHR5cGVvZiBzdGF0ZT8uU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcj8uc3ViamVjdE1ldGFkYXRhID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IHtcbiAgICAgIFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXI6IHsgc3ViamVjdE1ldGFkYXRhIH0sXG4gICAgfSA9IHN0YXRlO1xuXG4gICAgLy8gbXV0YXRlIFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIuc3ViamVjdE1ldGFkYXRhIGluIHBsYWNlXG4gICAgT2JqZWN0LnZhbHVlcyhzdWJqZWN0TWV0YWRhdGEpLmZvckVhY2goKG1ldGFkYXRhKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIG1ldGFkYXRhICYmXG4gICAgICAgIHR5cGVvZiBtZXRhZGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgIUFycmF5LmlzQXJyYXkobWV0YWRhdGEpXG4gICAgICApIHtcbiAgICAgICAgbWV0YWRhdGEuc3ViamVjdFR5cGUgPSBtZXRhZGF0YS5leHRlbnNpb25JZFxuICAgICAgICAgID8gU3ViamVjdFR5cGUuRXh0ZW5zaW9uXG4gICAgICAgICAgOiBTdWJqZWN0VHlwZS5XZWJzaXRlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA3MDtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBgcmVxdWVzdGAgYW5kIGByZXNwb25zZWAgcHJvcGVydGllcyBmcm9tXG4gKiBgUGVybWlzc2lvbkxvZ0NvbnRyb2xsZXIucGVybWlzc2lvbkFjdGl2aXR5TG9nYCBvYmplY3RzLlxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHN0YXRlPy5QZXJtaXNzaW9uTG9nQ29udHJvbGxlcj8ucGVybWlzc2lvbkFjdGl2aXR5TG9nKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIFBlcm1pc3Npb25Mb2dDb250cm9sbGVyOiB7IHBlcm1pc3Npb25BY3Rpdml0eUxvZyB9LFxuICAgIH0gPSBzdGF0ZTtcblxuICAgIC8vIG11dGF0ZSBhY3Rpdml0eSBsb2cgZW50cmllcyBpbiBwbGFjZVxuICAgIHBlcm1pc3Npb25BY3Rpdml0eUxvZy5mb3JFYWNoKChsb2dFbnRyeSkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBsb2dFbnRyeSAmJlxuICAgICAgICB0eXBlb2YgbG9nRW50cnkgPT09ICdvYmplY3QnICYmXG4gICAgICAgICFBcnJheS5pc0FycmF5KGxvZ0VudHJ5KVxuICAgICAgKSB7XG4gICAgICAgIGRlbGV0ZSBsb2dFbnRyeS5yZXF1ZXN0O1xuICAgICAgICBkZWxldGUgbG9nRW50cnkucmVzcG9uc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDcxO1xuXG4vKipcbiAqIFJlbmFtZXMgTm90aWZpY2F0aW9uQ29udHJvbGxlciB0byBBbm5vdW5jZW1lbnRDb250cm9sbGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgaWYgKHN0YXRlLk5vdGlmaWNhdGlvbkNvbnRyb2xsZXIpIHtcbiAgICBzdGF0ZS5Bbm5vdW5jZW1lbnRDb250cm9sbGVyID0ge1xuICAgICAgYW5ub3VuY2VtZW50czogc3RhdGUuTm90aWZpY2F0aW9uQ29udHJvbGxlci5ub3RpZmljYXRpb25zLFxuICAgIH07XG4gICAgZGVsZXRlIHN0YXRlLk5vdGlmaWNhdGlvbkNvbnRyb2xsZXI7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDcyO1xuXG4vKipcbiAqIFNob3VsZCBlbXB0eSB0aGUgYGtub3duTWV0aG9kRGF0YWAgb2JqZWN0IGluIFByZWZlcmVuY2VzQ29udHJvbGxlclxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IFByZWZlcmVuY2VzQ29udHJvbGxlciA9IHN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXIgfHwge307XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXI6IHtcbiAgICAgIC4uLlByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgIGtub3duTWV0aG9kRGF0YToge30sXG4gICAgfSxcbiAgfTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA3MztcblxuLyoqXG4gKiBTaG91bGQgZW1wdHkgdGhlIGBrbm93bk1ldGhvZERhdGFgIG9iamVjdCBpbiBQcmVmZXJlbmNlc0NvbnRyb2xsZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgPSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyIHx8IHt9O1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgUHJlZmVyZW5jZXNDb250cm9sbGVyOiB7XG4gICAgICAuLi5QcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICBrbm93bk1ldGhvZERhdGE6IHt9LFxuICAgIH0sXG4gIH07XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAsIHVuaXEgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgZ2V0UnBjVXJsIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcblxuY29uc3QgdmVyc2lvbiA9IDc0O1xuXG5jb25zdCBoZXhOdW1iZXJJc0dyZWF0ZXJUaGFuWmVybyA9IChoZXhOdW1iZXIpID0+XG4gIG5ldyBCaWdOdW1iZXIoaGV4TnVtYmVyIHx8ICcweDAnLCAxNikuZ3QoMCk7XG5cbmNvbnN0IERFUFJFQ0FURURfVEVTVF9ORVRfQ0hBSU5JRFMgPSBbJzB4MycsICcweDJhJywgJzB4NCddO1xuY29uc3QgREVQUkVDQVRFRF9URVNUX05FVF9ERVRBSUxTID0ge1xuICAnMHgzJzoge1xuICAgIHJwY1VybDogZ2V0UnBjVXJsKHsgbmV0d29yazogJ3JvcHN0ZW4nIH0pLFxuICAgIG5pY2tuYW1lOiAnUm9wc3RlbicsXG4gICAgdGlja2VyOiAnUm9wc3RlbkVUSCcsXG4gIH0sXG4gICcweDJhJzoge1xuICAgIHJwY1VybDogZ2V0UnBjVXJsKHsgbmV0d29yazogJ2tvdmFuJyB9KSxcbiAgICBuaWNrbmFtZTogJ0tvdmFuJyxcbiAgICB0aWNrZXI6ICdLb3ZhbkVUSCcsXG4gIH0sXG4gICcweDQnOiB7XG4gICAgcnBjVXJsOiBnZXRScGNVcmwoeyBuZXR3b3JrOiAncmlua2VieScgfSksXG4gICAgbmlja25hbWU6ICdSaW5rZWJ5JyxcbiAgICB0aWNrZXI6ICdSaW5rZWJ5RVRIJyxcbiAgfSxcbn07XG5cbi8qKlxuICogTWlncmF0ZXMgdGhlIHVzZXIgZGVmYXVsdCBidXQgZGVwcmVjYXRlZCB0ZXN0bmV0IG5ldHdvcmtzIHRvIGN1c3RvbSBuZXR3b3JrcywgYW5kXG4gKiBpZiB0aGUgY3VycmVudCBuZXR3b3JrIGlzIG9uZSBzdWNoIG5ldHdvcmssIHVwZGF0ZXMgdGhlIG5ldHdvcmsgcHJvdmlkZXIgZGV0YWlscyBzbyB0aGF0IGl0XG4gKiB3aWxsIHdvcmsgYXMgYSBjdXN0b20gcnBjXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgUHJlZmVyZW5jZXNDb250cm9sbGVyID0gc3RhdGU/LlByZWZlcmVuY2VzQ29udHJvbGxlciB8fCB7fTtcbiAgY29uc3QgcHJlZmVyZW5jZXMgPSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIucHJlZmVyZW5jZXMgfHwge307XG4gIGNvbnN0IE5ldHdvcmtDb250cm9sbGVyID0gc3RhdGU/Lk5ldHdvcmtDb250cm9sbGVyIHx8IHt9O1xuICBjb25zdCBwcm92aWRlciA9IE5ldHdvcmtDb250cm9sbGVyPy5wcm92aWRlciB8fCB7fTtcblxuICBjb25zdCBjdXJyZW50bHlPbkRlcHJlY2F0ZWROZXR3b3JrID0gREVQUkVDQVRFRF9URVNUX05FVF9DSEFJTklEUy5maWx0ZXIoXG4gICAgKGNoYWluSWQpID0+IGNoYWluSWQgPT09IHByb3ZpZGVyPy5jaGFpbklkLFxuICApO1xuXG4gIC8vIElmIHRoZSB1c2VyIGRvZXMgbm90IHdhbnQgdG8gc2VlIHRlc3QgbmV0d29ya3MsIGFuZCBpZiB0aGUgdGhlIHVzZXIgaXMgbm90IG9uIGEgZGVwcmVjYXRlZCB0ZXN0IG5ldHdvcmssIHRoZW5cbiAgLy8gbm8gbmVlZCB0byBtaWdyYXRlIHRoZSB0ZXN0IG5ldHdvcmsgZGF0YSB0byBhIGN1c3RvbSBuZXR3b3JrXG4gIGlmIChcbiAgICAhcHJlZmVyZW5jZXMuc2hvd1Rlc3ROZXR3b3JrcyAmJlxuICAgIGN1cnJlbnRseU9uRGVwcmVjYXRlZE5ldHdvcmsubGVuZ3RoID09PSAwXG4gICkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IHRyYW5zYWN0aW9ucyA9IHN0YXRlPy5UcmFuc2FjdGlvbkNvbnRyb2xsZXI/LnRyYW5zYWN0aW9ucyB8fCB7fTtcbiAgY29uc3QgY2FjaGVkQmFsYW5jZXMgPSBzdGF0ZS5DYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXI/LmNhY2hlZEJhbGFuY2VzIHx8IHt9O1xuXG4gIGNvbnN0IGRlcHJlY2F0ZWRUZXN0bmV0c09uV2hpY2hUaGVVc2VySGFzTWFkZUFUcmFuc2FjdGlvbiA9IE9iamVjdC52YWx1ZXMoXG4gICAgdHJhbnNhY3Rpb25zLFxuICApXG4gICAgLmZpbHRlcigoeyBjaGFpbklkIH0pID0+IERFUFJFQ0FURURfVEVTVF9ORVRfQ0hBSU5JRFMuaW5jbHVkZXMoY2hhaW5JZCkpXG4gICAgLm1hcCgoeyBjaGFpbklkIH0pID0+IGNoYWluSWQpO1xuICBjb25zdCBkZXByZWNhdGVkVGVzdG5ldHNPbldoaWNoVGhlVXNlckhhc0NhY2hlZEJhbGFuY2UgPVxuICAgIERFUFJFQ0FURURfVEVTVF9ORVRfQ0hBSU5JRFMuZmlsdGVyKChjaGFpbklkKSA9PiB7XG4gICAgICBjb25zdCBjYWNoZWRCYWxhbmNlc0ZvckNoYWluID0gT2JqZWN0LnZhbHVlcyhcbiAgICAgICAgY2FjaGVkQmFsYW5jZXNbY2hhaW5JZF0gfHwge30sXG4gICAgICApO1xuICAgICAgY29uc3QgdXNlckhhc0FCYWxhbmNlR3JlYXRlclRoYW5aZXJvT25UaGlzQ2hhaW4gPVxuICAgICAgICBjYWNoZWRCYWxhbmNlc0ZvckNoYWluLnNvbWUoaGV4TnVtYmVySXNHcmVhdGVyVGhhblplcm8pO1xuICAgICAgcmV0dXJuIHVzZXJIYXNBQmFsYW5jZUdyZWF0ZXJUaGFuWmVyb09uVGhpc0NoYWluO1xuICAgIH0pO1xuICBjb25zdCBkZXByZWNhdGVkVGVzdG5ldHNUaGF0SGF2ZUJlZW5Vc2VkID0gdW5pcShbXG4gICAgLi4uZGVwcmVjYXRlZFRlc3RuZXRzT25XaGljaFRoZVVzZXJIYXNDYWNoZWRCYWxhbmNlLFxuICAgIC4uLmRlcHJlY2F0ZWRUZXN0bmV0c09uV2hpY2hUaGVVc2VySGFzTWFkZUFUcmFuc2FjdGlvbixcbiAgICAuLi5jdXJyZW50bHlPbkRlcHJlY2F0ZWROZXR3b3JrLFxuICBdKTtcblxuICBjb25zdCBuZXdGcmVxdWVudFJwY0xpc3REZXRhaWwgPVxuICAgIFByZWZlcmVuY2VzQ29udHJvbGxlci5mcmVxdWVudFJwY0xpc3REZXRhaWwgPz8gW107XG5cbiAgZGVwcmVjYXRlZFRlc3RuZXRzVGhhdEhhdmVCZWVuVXNlZC5mb3JFYWNoKChjaGFpbklkKSA9PiB7XG4gICAgaWYgKFxuICAgICAgIW5ld0ZyZXF1ZW50UnBjTGlzdERldGFpbC5maW5kKFxuICAgICAgICAocnBjRGV0YWlscykgPT4gcnBjRGV0YWlscy5jaGFpbklkID09PSBjaGFpbklkLFxuICAgICAgKVxuICAgICkge1xuICAgICAgbmV3RnJlcXVlbnRScGNMaXN0RGV0YWlsLnVuc2hpZnQoe1xuICAgICAgICBycGNVcmw6IERFUFJFQ0FURURfVEVTVF9ORVRfREVUQUlMU1tjaGFpbklkXS5ycGNVcmwsXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIHRpY2tlcjogREVQUkVDQVRFRF9URVNUX05FVF9ERVRBSUxTW2NoYWluSWRdLnRpY2tlcixcbiAgICAgICAgbmlja25hbWU6IERFUFJFQ0FURURfVEVTVF9ORVRfREVUQUlMU1tjaGFpbklkXS5uaWNrbmFtZSxcbiAgICAgICAgcnBjUHJlZnM6IHt9LFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBpZiAobmV3RnJlcXVlbnRScGNMaXN0RGV0YWlsLmxlbmd0aCkge1xuICAgIFByZWZlcmVuY2VzQ29udHJvbGxlci5mcmVxdWVudFJwY0xpc3REZXRhaWwgPSBuZXdGcmVxdWVudFJwY0xpc3REZXRhaWw7XG4gIH1cblxuICBpZiAoY3VycmVudGx5T25EZXByZWNhdGVkTmV0d29yay5sZW5ndGgpIHtcbiAgICBjb25zdCBzZWxlY3RlZE5ldHdvcmtDaGFpbklkID0gY3VycmVudGx5T25EZXByZWNhdGVkTmV0d29ya1swXTtcbiAgICBOZXR3b3JrQ29udHJvbGxlci5wcm92aWRlciA9IHtcbiAgICAgIC4uLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyLFxuICAgICAgdHlwZTogJ3JwYycsXG4gICAgICBycGNVcmw6IERFUFJFQ0FURURfVEVTVF9ORVRfREVUQUlMU1tzZWxlY3RlZE5ldHdvcmtDaGFpbklkXS5ycGNVcmwsXG4gICAgICBjaGFpbklkOiBzZWxlY3RlZE5ldHdvcmtDaGFpbklkLFxuICAgICAgbmlja25hbWU6IERFUFJFQ0FURURfVEVTVF9ORVRfREVUQUlMU1tzZWxlY3RlZE5ldHdvcmtDaGFpbklkXS5uaWNrbmFtZSxcbiAgICAgIHRpY2tlcjogREVQUkVDQVRFRF9URVNUX05FVF9ERVRBSUxTW3NlbGVjdGVkTmV0d29ya0NoYWluSWRdLnRpY2tlcixcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXI6IHtcbiAgICAgIC4uLlByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICB9LFxuICAgIE5ldHdvcmtDb250cm9sbGVyOiB7XG4gICAgICAuLi5OZXR3b3JrQ29udHJvbGxlcixcbiAgICB9LFxuICB9O1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDc1O1xuXG4vKipcbiAqIERlbGV0ZSB0aGUgVGhyZWVCb3hDb250cm9sbGVyLlxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGRlbGV0ZSBzdGF0ZS5UaHJlZUJveENvbnRyb2xsZXI7XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA3NjtcblxuLyoqXG4gKiBVcGRhdGUgdG8gYEBtZXRhbWFzay9jb250cm9sbGVyc0AzMy4wLjBgIChyZW5hbWUgXCJDb2xsZWN0aWJsZVwiIHRvIFwiTkZUXCIpLlxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5Db2xsZWN0aWJsZXNDb250cm9sbGVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgYWxsQ29sbGVjdGlibGVDb250cmFjdHMsXG4gICAgICBhbGxDb2xsZWN0aWJsZXMsXG4gICAgICBpZ25vcmVkQ29sbGVjdGlibGVzLFxuICAgICAgLi4ucmVtYWluaW5nU3RhdGVcbiAgICB9ID0gc3RhdGUuQ29sbGVjdGlibGVzQ29udHJvbGxlcjtcbiAgICBzdGF0ZS5OZnRDb250cm9sbGVyID0ge1xuICAgICAgLi4uKGFsbENvbGxlY3RpYmxlQ29udHJhY3RzXG4gICAgICAgID8geyBhbGxOZnRDb250cmFjdHM6IGFsbENvbGxlY3RpYmxlQ29udHJhY3RzIH1cbiAgICAgICAgOiB7fSksXG4gICAgICAuLi4oYWxsQ29sbGVjdGlibGVzID8geyBhbGxOZnRzOiBhbGxDb2xsZWN0aWJsZXMgfSA6IHt9KSxcbiAgICAgIC4uLihpZ25vcmVkQ29sbGVjdGlibGVzID8geyBpZ25vcmVkTmZ0czogaWdub3JlZENvbGxlY3RpYmxlcyB9IDoge30pLFxuICAgICAgLi4ucmVtYWluaW5nU3RhdGUsXG4gICAgfTtcbiAgICBkZWxldGUgc3RhdGUuQ29sbGVjdGlibGVzQ29udHJvbGxlcjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LnVzZUNvbGxlY3RpYmxlRGV0ZWN0aW9uKSB7XG4gICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnVzZU5mdERldGVjdGlvbiA9XG4gICAgICBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIudXNlQ29sbGVjdGlibGVEZXRlY3Rpb247XG4gICAgZGVsZXRlIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci51c2VDb2xsZWN0aWJsZURldGVjdGlvbjtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA3NztcblxuLyoqXG4gKiBQcmlvciB0byB0b2tlbiBkZXRlY3Rpb24gdjIgdGhlIGRhdGEgcHJvcGVydHkgaW4gdG9rZW5zQ2hhaW5zQ2FjaGUgd2FzIGFuIGFycmF5LFxuICogaW4gdjIgd2UgY2hhbmdlcyB0aGF0IHRvIGFuIG9iamVjdC4gSW4gdGhpcyBtaWdyYXRpb24gd2UgYXJlIGNvbnZlcnRpbmcgdGhlIGRhdGEgYXMgYXJyYXkgdG8gb2JqZWN0LlxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IFRva2VuTGlzdENvbnRyb2xsZXIgPSBzdGF0ZT8uVG9rZW5MaXN0Q29udHJvbGxlciB8fCB7fTtcblxuICBjb25zdCB7IHRva2Vuc0NoYWluc0NhY2hlIH0gPSBUb2tlbkxpc3RDb250cm9sbGVyO1xuXG4gIGxldCBkYXRhQ2FjaGU7XG4gIGxldCBkYXRhT2JqZWN0O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgZm9yIChjb25zdCBjaGFpbklkIGluIHRva2Vuc0NoYWluc0NhY2hlKSB7XG4gICAgZGF0YUNhY2hlID0gdG9rZW5zQ2hhaW5zQ2FjaGVbY2hhaW5JZF0uZGF0YTtcbiAgICBkYXRhT2JqZWN0ID0ge307XG4gICAgLy8gaWYgdGhlIGRhdGEgaXMgYXJyYXkgY29udmVyIHRoYXQgdG8gb2JqZWN0XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YUNhY2hlKSkge1xuICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBkYXRhQ2FjaGUpIHtcbiAgICAgICAgZGF0YU9iamVjdFt0b2tlbi5hZGRyZXNzXSA9IHRva2VuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBPYmplY3Qua2V5cyhkYXRhQ2FjaGUpWzBdLnRvTG93ZXJDYXNlKCkgIT09XG4gICAgICBkYXRhQ2FjaGVbT2JqZWN0LmtleXMoZGF0YUNhY2hlKVswXV0uYWRkcmVzcy50b0xvd2VyQ2FzZSgpXG4gICAgKSB7XG4gICAgICAvLyBmb3IgdGhlIHVzZXJzIHdobyBhbHJlYWR5IHVwZGF0ZWQgdG8gdGhlIHJlY2VudCB2ZXJzaW9uXG4gICAgICAvLyBhbmQgdGhlIGRhdGFDYWNoZSBpcyBhbHJlYWR5IGFuIG9iamVjdCBrZXllZCB3aXRoIDAsMSwyLDMgZXRjXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGZvciAoY29uc3QgdG9rZW5BZGRyZXNzIGluIGRhdGFDYWNoZSkge1xuICAgICAgICBkYXRhT2JqZWN0W2RhdGFDYWNoZVt0b2tlbkFkZHJlc3NdLmFkZHJlc3NdID0gZGF0YUNhY2hlW3Rva2VuQWRkcmVzc107XG4gICAgICB9XG4gICAgfVxuICAgIHRva2Vuc0NoYWluc0NhY2hlW2NoYWluSWRdLmRhdGEgPVxuICAgICAgT2JqZWN0LmtleXMoZGF0YU9iamVjdCkubGVuZ3RoID4gMCA/IGRhdGFPYmplY3QgOiBkYXRhQ2FjaGU7XG4gIH1cbiAgVG9rZW5MaXN0Q29udHJvbGxlci50b2tlbnNDaGFpbnNDYWNoZSA9IHRva2Vuc0NoYWluc0NhY2hlO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgVG9rZW5MaXN0Q29udHJvbGxlcjoge1xuICAgICAgLi4uVG9rZW5MaXN0Q29udHJvbGxlcixcbiAgICB9LFxuICB9O1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGhhc1Byb3BlcnR5LCBpc09iamVjdCB9IGZyb20gJ0BtZXRhbWFzay91dGlscyc7XG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gNzg7XG5cbi8qKlxuICogVGhlYEBtZXRhbWFzay9waGlzaGluZy1jb250cm9sbGVyYCBzdGF0ZSB3YXMgdXBkYXRlZCBpbiB2Mi4wLjAuXG4gKlxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YSAtIFZlcnNpb25lZCBNZXRhTWFzayBleHRlbnNpb24gc3RhdGUsIGV4YWN0bHkgd2hhdCB3ZSBwZXJzaXN0IHRvIGRpc3QuXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhLm1ldGEgLSBTdGF0ZSBtZXRhZGF0YS5cbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uIC0gVGhlIGN1cnJlbnQgc3RhdGUgdmVyc2lvbi5cbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEuZGF0YSAtIFRoZSBwZXJzaXN0ZWQgTWV0YU1hc2sgc3RhdGUsIGtleWVkIGJ5IGNvbnRyb2xsZXIuXG4gKiBAcmV0dXJucyBVcGRhdGVkIHZlcnNpb25lZCBNZXRhTWFzayBleHRlbnNpb24gc3RhdGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YToge1xuICBtZXRhOiB7IHZlcnNpb246IG51bWJlciB9O1xuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbn0pIHtcbiAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHZlcnNpb25lZERhdGEuZGF0YSk7XG4gIHJldHVybiB2ZXJzaW9uZWREYXRhO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcbiAgaWYgKFxuICAgICFoYXNQcm9wZXJ0eShzdGF0ZSwgJ1BoaXNoaW5nQ29udHJvbGxlcicpIHx8XG4gICAgIWlzT2JqZWN0KHN0YXRlLlBoaXNoaW5nQ29udHJvbGxlcilcbiAgKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGNvbnN0IHsgUGhpc2hpbmdDb250cm9sbGVyIH0gPSBzdGF0ZTtcblxuICBkZWxldGUgUGhpc2hpbmdDb250cm9sbGVyLnBoaXNoaW5nO1xuICBkZWxldGUgUGhpc2hpbmdDb250cm9sbGVyLmxhc3RGZXRjaGVkO1xuXG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA3OTtcblxuLyoqXG4gKiBSZW1vdmUgY29sbGVjdGlibGVzRHJvcGRvd25TdGF0ZSBhbmQgY29sbGVjdGlibGVzRGV0ZWN0aW9uTm90aWNlRGlzbWlzc2VkOi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBpZiAoXG4gICAgc3RhdGU/LkFwcFN0YXRlQ29udHJvbGxlcj8uY29sbGVjdGlibGVzRGV0ZWN0aW9uTm90aWNlRGlzbWlzc2VkICE9PVxuICAgIHVuZGVmaW5lZFxuICApIHtcbiAgICBkZWxldGUgc3RhdGUuQXBwU3RhdGVDb250cm9sbGVyLmNvbGxlY3RpYmxlc0RldGVjdGlvbk5vdGljZURpc21pc3NlZDtcbiAgfVxuICBpZiAoc3RhdGU/Lm1ldGFtYXNrPy5jb2xsZWN0aWJsZXNEcm9wZG93blN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWxldGUgc3RhdGUubWV0YW1hc2suY29sbGVjdGlibGVzRHJvcGRvd25TdGF0ZTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gODA7XG5cbi8qKlxuICogVGhlIHBvcnRmb2xpbyB0b29sdGlwIGhhcyBiZWVuIG1vdmVkIHRvIGEgYnV0dG9uIG9uIHRoZSBob21lIHNjcmVlbiBzb1xuICogdGhpcyBwcm9wZXJ0eSBpcyBubyBsb25nZXIgbmVlZGVkIGluIHN0YXRlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgaWYgKHN0YXRlPy5tZXRhbWFzaz8uc2hvd1BvcnRmb2xpb1Rvb2x0aXAgIT09IHVuZGVmaW5lZCkge1xuICAgIGRlbGV0ZSBzdGF0ZS5tZXRhbWFzay5zaG93UG9ydGZvbGlvVG9vbHRpcDtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCwgaXNBcnJheSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBoYXNQcm9wZXJ0eSwgaXNPYmplY3QgfSBmcm9tICdAbWV0YW1hc2svdXRpbHMnO1xuXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IDgxO1xuXG4vKipcbiAqIFByaW9yIHRvIHRoaXMgbWlncmF0aW9uLCBzbmFwIDw+IGRhcHAgcGVybWlzc2lvbnMgd2VyZSB3aWxkY2FyZHMgaS5lLiBgd2FsbGV0X3NuYXBfKmAuXG4gKiBOb3cgdGhlIHBlcm1pc3Npb24gaGFzIGJlZW4gY2hhbmdlZCB0byBgd2FsbGV0X3NuYXBgIGFuZCB0aGUgY3VycmVudCBzbmFwIHBlcm1pc3Npb25zXG4gKiB0aGF0IGFyZSB1bmRlciB3aWxkY2FyZHMgd2lsbCBiZSBhZGRlZCBhcyBjYXZlYXRzIHRvIGEgcGFyZW50IGB3YWxsZXRfc25hcGAgcGVybWlzc2lvbi5cbiAqXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhIC0gVmVyc2lvbmVkIE1ldGFNYXNrIGV4dGVuc2lvbiBzdGF0ZSwgZXhhY3RseSB3aGF0IHdlIHBlcnNpc3QgdG8gZGlzdC5cbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEubWV0YSAtIFN0YXRlIG1ldGFkYXRhLlxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gLSBUaGUgY3VycmVudCBzdGF0ZSB2ZXJzaW9uLlxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5kYXRhIC0gVGhlIHBlcnNpc3RlZCBNZXRhTWFzayBzdGF0ZSwga2V5ZWQgYnkgY29udHJvbGxlci5cbiAqIEByZXR1cm5zIFVwZGF0ZWQgdmVyc2lvbmVkIE1ldGFNYXNrIGV4dGVuc2lvbiBzdGF0ZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhOiB7XG4gIG1ldGE6IHsgdmVyc2lvbjogbnVtYmVyIH07XG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xufSkge1xuICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG59XG5cbi8vIFdlIHJldHVybiBzdGF0ZSBBUyBJUyBpZiB0aGVyZSBpcyBhbnkgY29ycnVwdGlvblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XG4gIGlmIChcbiAgICAhaGFzUHJvcGVydHkoc3RhdGUsICdTbmFwQ29udHJvbGxlcicpIHx8XG4gICAgIWhhc1Byb3BlcnR5KHN0YXRlLCAnUGVybWlzc2lvbkNvbnRyb2xsZXInKSB8fFxuICAgICFpc09iamVjdChzdGF0ZS5QZXJtaXNzaW9uQ29udHJvbGxlcilcbiAgKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGNvbnN0IHsgUGVybWlzc2lvbkNvbnRyb2xsZXIgfSA9IHN0YXRlO1xuXG4gIGNvbnN0IHsgc3ViamVjdHMgfSA9IFBlcm1pc3Npb25Db250cm9sbGVyO1xuXG4gIGlmICghaXNPYmplY3Qoc3ViamVjdHMpKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgY29uc3Qgc25hcFByZWZpeCA9ICd3YWxsZXRfc25hcF8nO1xuXG4gIGZvciAoY29uc3QgW3N1YmplY3ROYW1lLCBzdWJqZWN0XSBvZiBPYmplY3QuZW50cmllcyhzdWJqZWN0cykpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHN1YmplY3QpIHx8ICFpc09iamVjdChzdWJqZWN0LnBlcm1pc3Npb25zKSkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAvLyBXZSBrZWVwIHRyYWNrIG9mIHRoZSBsYXRlc3QgcGVybWlzc2lvbidzIGRhdGUgYW5kIGFzc29jaWF0ZWQgaWRcbiAgICAvLyB0byBhc3NpZ24gdG8gdGhlIHdhbGxldF9zbmFwIHBlcm1pc3Npb24gYWZ0ZXIgaXRlcmF0aW5nIHRocm91Z2ggYWxsIHBlcm1pc3Npb25zXG4gICAgbGV0IGRhdGUgPSAxO1xuICAgIGxldCBpZDtcbiAgICBjb25zdCB7IHBlcm1pc3Npb25zIH0gPSBzdWJqZWN0O1xuICAgIC8vIE5ldyBwZXJtaXNzaW9ucyBvYmplY3QgdGhhdCB3ZSB1c2UgdG8gdGFjayBvbiB0aGUgYHdhbGxldF9zbmFwYCBwZXJtaXNzaW9uXG4gICAgY29uc3QgdXBkYXRlZFBlcm1pc3Npb25zID0geyAuLi5wZXJtaXNzaW9ucyB9O1xuICAgIGZvciAoY29uc3QgW3Blcm1pc3Npb25OYW1lLCBwZXJtaXNzaW9uXSBvZiBPYmplY3QuZW50cmllcyhwZXJtaXNzaW9ucykpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBwZXJtaXNzaW9uIGlzIG5hbWVzcGFjZWRcbiAgICAgIGlmIChwZXJtaXNzaW9uTmFtZS5zdGFydHNXaXRoKHNuYXBQcmVmaXgpKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaXNPYmplY3QocGVybWlzc2lvbikgfHxcbiAgICAgICAgICAhaGFzUHJvcGVydHkocGVybWlzc2lvbiwgJ2lkJykgfHxcbiAgICAgICAgICAhaGFzUHJvcGVydHkocGVybWlzc2lvbiwgJ2RhdGUnKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgY3JlYXRlIGEgd2FsbGV0X3NuYXAga2V5IGlmIHdlIGFscmVhZHkgZG9uJ3QgaGF2ZSBvbmVcbiAgICAgICAgaWYgKCFoYXNQcm9wZXJ0eSh1cGRhdGVkUGVybWlzc2lvbnMsICd3YWxsZXRfc25hcCcpKSB7XG4gICAgICAgICAgdXBkYXRlZFBlcm1pc3Npb25zLndhbGxldF9zbmFwID0ge1xuICAgICAgICAgICAgY2F2ZWF0czogW3sgdHlwZTogJ3NuYXBJZHMnLCB2YWx1ZToge30gfV0sXG4gICAgICAgICAgICBpbnZva2VyOiBzdWJqZWN0TmFtZSxcbiAgICAgICAgICAgIHBhcmVudENhcGFiaWxpdHk6ICd3YWxsZXRfc25hcCcsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBleGlzdGluZyBwZXJtaXNzaW9uIGlzIHZhbGlkXG4gICAgICAgIGlmICghaXNPYmplY3QodXBkYXRlZFBlcm1pc3Npb25zLndhbGxldF9zbmFwKSkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaXNBcnJheShcbiAgICAgICAgICAgICh1cGRhdGVkUGVybWlzc2lvbnMud2FsbGV0X3NuYXAgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pLmNhdmVhdHMsXG4gICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGRpbmcgdGhlIHNuYXAgbmFtZSB0byB0aGUgd2FsbGV0X3NuYXAgcGVybWlzc2lvbidzIGNhdmVhdCB2YWx1ZVxuICAgICAgICBjb25zdCBzbmFwSWQgPSBwZXJtaXNzaW9uTmFtZS5zbGljZShzbmFwUHJlZml4Lmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGNhdmVhdCA9IChcbiAgICAgICAgICAodXBkYXRlZFBlcm1pc3Npb25zLndhbGxldF9zbmFwIGFzIFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgICAgICAgICAuY2F2ZWF0cyBhcyB1bmtub3duW11cbiAgICAgICAgKVswXTtcblxuICAgICAgICBpZiAoIWlzT2JqZWN0KGNhdmVhdCkpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWhhc1Byb3BlcnR5KGNhdmVhdCwgJ3R5cGUnKSB8fFxuICAgICAgICAgIGNhdmVhdC50eXBlICE9PSAnc25hcElkcycgfHxcbiAgICAgICAgICAhaGFzUHJvcGVydHkoY2F2ZWF0LCAndmFsdWUnKSB8fFxuICAgICAgICAgICFpc09iamVjdChjYXZlYXQudmFsdWUpXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXZlYXQudmFsdWVbc25hcElkXSA9IHt9O1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0eXBlb2YgcGVybWlzc2lvbi5kYXRlICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgIHR5cGVvZiBwZXJtaXNzaW9uLmlkICE9PSAnc3RyaW5nJ1xuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGluZyB0aGUgZGF0ZSAmIGlkIGFzIHdlIGl0ZXJhdGUgdGhyb3VnaCBhbGwgcGVybWlzc2lvbnNcbiAgICAgICAgaWYgKHBlcm1pc3Npb24uZGF0ZSA+IGRhdGUpIHtcbiAgICAgICAgICBkYXRlID0gcGVybWlzc2lvbi5kYXRlO1xuICAgICAgICAgIGlkID0gcGVybWlzc2lvbi5pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmFsbHkgZGVsZXRpbmcgdGhlIHN0YWxlIHBlcm1pc3Npb25cbiAgICAgICAgZGVsZXRlIHVwZGF0ZWRQZXJtaXNzaW9uc1twZXJtaXNzaW9uTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gd2UgcmVhc3NpZ24gdGhlIGRhdGUgYW5kIGlkIGhlcmUgYWZ0ZXIgaXRlcmF0aW5nIHRocm91Z2ggYWxsIHBlcm1pc3Npb25zXG4gICAgLy8gYW5kIHVwZGF0ZSB0aGUgc3ViamVjdCB3aXRoIHRoZSB1cGRhdGVkIHBlcm1pc3Npb25zXG4gICAgaWYgKHVwZGF0ZWRQZXJtaXNzaW9ucy53YWxsZXRfc25hcCkge1xuICAgICAgKHVwZGF0ZWRQZXJtaXNzaW9ucy53YWxsZXRfc25hcCBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikuZGF0ZSA9IGRhdGU7XG4gICAgICAodXBkYXRlZFBlcm1pc3Npb25zLndhbGxldF9zbmFwIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KS5pZCA9IGlkO1xuICAgICAgc3ViamVjdC5wZXJtaXNzaW9ucyA9IHVwZGF0ZWRQZXJtaXNzaW9ucztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgaGFzUHJvcGVydHksIGlzT2JqZWN0IH0gZnJvbSAnQG1ldGFtYXNrL3V0aWxzJztcbmltcG9ydCB7IHY0IH0gZnJvbSAndXVpZCc7XG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gODI7XG5cbi8qKlxuICogTWlncmF0ZSB0aGUgZnJlcXVlbnRScGNMaXN0RGV0YWlsIGZyb20gdGhlIFByZWZlcmVuY2VzQ29udHJvbGxlciB0byB0aGUgTmV0d29ya0NvbnRyb2xsZXIsIGNvbnZlcnQgaXQgZnJvbSBhbiBhcnJheSB0byBhbiBvYmplY3RcbiAqIGtleWVkIGJ5IHJhbmRvbSB1dWlkcy5cbiAqXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhIC0gVmVyc2lvbmVkIE1ldGFNYXNrIGV4dGVuc2lvbiBzdGF0ZSwgZXhhY3RseSB3aGF0IHdlIHBlcnNpc3QgdG8gZGlzdC5cbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEubWV0YSAtIFN0YXRlIG1ldGFkYXRhLlxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gLSBUaGUgY3VycmVudCBzdGF0ZSB2ZXJzaW9uLlxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5kYXRhIC0gVGhlIHBlcnNpc3RlZCBNZXRhTWFzayBzdGF0ZSwga2V5ZWQgYnkgY29udHJvbGxlci5cbiAqIEByZXR1cm5zIFVwZGF0ZWQgdmVyc2lvbmVkIE1ldGFNYXNrIGV4dGVuc2lvbiBzdGF0ZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhOiB7XG4gIG1ldGE6IHsgdmVyc2lvbjogbnVtYmVyIH07XG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xufSkge1xuICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUodmVyc2lvbmVkRGF0YS5kYXRhKTtcbiAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikge1xuICBpZiAoXG4gICAgIWhhc1Byb3BlcnR5KHN0YXRlLCAnUHJlZmVyZW5jZXNDb250cm9sbGVyJykgfHxcbiAgICAhaXNPYmplY3Qoc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB8fFxuICAgICFpc09iamVjdChzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcikgfHxcbiAgICAhaGFzUHJvcGVydHkoc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLCAnZnJlcXVlbnRScGNMaXN0RGV0YWlsJykgfHxcbiAgICAhQXJyYXkuaXNBcnJheShzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuZnJlcXVlbnRScGNMaXN0RGV0YWlsKSB8fFxuICAgICFzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuZnJlcXVlbnRScGNMaXN0RGV0YWlsLmV2ZXJ5KGlzT2JqZWN0KVxuICApIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgY29uc3QgeyBQcmVmZXJlbmNlc0NvbnRyb2xsZXIsIE5ldHdvcmtDb250cm9sbGVyIH0gPSBzdGF0ZTtcbiAgY29uc3QgeyBmcmVxdWVudFJwY0xpc3REZXRhaWwgfSA9IFByZWZlcmVuY2VzQ29udHJvbGxlcjtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGZyZXF1ZW50UnBjTGlzdERldGFpbCkpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCBuZXR3b3JrQ29uZmlndXJhdGlvbnMgPSBmcmVxdWVudFJwY0xpc3REZXRhaWwucmVkdWNlKFxuICAgIChcbiAgICAgIG5ldHdvcmtDb25maWd1cmF0aW9uc0FjYyxcbiAgICAgIHsgcnBjVXJsLCBjaGFpbklkLCB0aWNrZXIsIG5pY2tuYW1lLCBycGNQcmVmcyB9LFxuICAgICkgPT4ge1xuICAgICAgY29uc3QgbmV0d29ya0NvbmZpZ3VyYXRpb25JZCA9IHY0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5uZXR3b3JrQ29uZmlndXJhdGlvbnNBY2MsXG4gICAgICAgIFtuZXR3b3JrQ29uZmlndXJhdGlvbklkXToge1xuICAgICAgICAgIHJwY1VybCxcbiAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgIHRpY2tlcixcbiAgICAgICAgICBycGNQcmVmcyxcbiAgICAgICAgICBuaWNrbmFtZSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSxcbiAgICB7fSxcbiAgKTtcblxuICBkZWxldGUgUHJlZmVyZW5jZXNDb250cm9sbGVyLmZyZXF1ZW50UnBjTGlzdERldGFpbDtcblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIE5ldHdvcmtDb250cm9sbGVyOiB7XG4gICAgICAuLi5OZXR3b3JrQ29udHJvbGxlcixcbiAgICAgIG5ldHdvcmtDb25maWd1cmF0aW9ucyxcbiAgICB9LFxuICAgIFByZWZlcmVuY2VzQ29udHJvbGxlcjoge1xuICAgICAgLi4uUHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgIH0sXG4gIH07XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdAbWV0YW1hc2svdXRpbHMnO1xuXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IDgzO1xuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGVhY2ggbmV0d29ya0NvbmZpZ3VyYXRpb25zIG9iamVjdCBpbiBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5uZXR3b3JrQ29uZmlndXJhdGlvbnMgaGFzIGFuXG4gKiBgaWRgIHByb3BlcnR5IHdoaWNoIG1hdGNoZXMgdGhlIGtleSBwb2ludGluZyB0aGF0IG9iamVjdFxuICpcbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEgLSBWZXJzaW9uZWQgTWV0YU1hc2sgZXh0ZW5zaW9uIHN0YXRlLCBleGFjdGx5IHdoYXQgd2UgcGVyc2lzdCB0byBkaXN0LlxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5tZXRhIC0gU3RhdGUgbWV0YWRhdGEuXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiAtIFRoZSBjdXJyZW50IHN0YXRlIHZlcnNpb24uXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhLmRhdGEgLSBUaGUgcGVyc2lzdGVkIE1ldGFNYXNrIHN0YXRlLCBrZXllZCBieSBjb250cm9sbGVyLlxuICogQHJldHVybnMgVXBkYXRlZCB2ZXJzaW9uZWQgTWV0YU1hc2sgZXh0ZW5zaW9uIHN0YXRlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGE6IHtcbiAgbWV0YTogeyB2ZXJzaW9uOiBudW1iZXIgfTtcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG59KSB7XG4gIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZSh2ZXJzaW9uZWREYXRhLmRhdGEpO1xuICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XG4gIGlmICghaXNPYmplY3Qoc3RhdGUuTmV0d29ya0NvbnRyb2xsZXIpKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGNvbnN0IHsgTmV0d29ya0NvbnRyb2xsZXIgfSA9IHN0YXRlO1xuXG4gIGlmICghaXNPYmplY3QoTmV0d29ya0NvbnRyb2xsZXIubmV0d29ya0NvbmZpZ3VyYXRpb25zKSkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IHsgbmV0d29ya0NvbmZpZ3VyYXRpb25zIH0gPSBOZXR3b3JrQ29udHJvbGxlcjtcblxuICBjb25zdCBuZXdOZXR3b3JrQ29uZmlndXJhdGlvbnM6IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIHVua25vd24+PiA9IHt9O1xuXG4gIGZvciAoY29uc3QgbmV0d29ya0NvbmZpZ3VyYXRpb25JZCBvZiBPYmplY3Qua2V5cyhuZXR3b3JrQ29uZmlndXJhdGlvbnMpKSB7XG4gICAgY29uc3QgbmV0d29ya0NvbmZpZ3VyYXRpb24gPSBuZXR3b3JrQ29uZmlndXJhdGlvbnNbbmV0d29ya0NvbmZpZ3VyYXRpb25JZF07XG4gICAgaWYgKCFpc09iamVjdChuZXR3b3JrQ29uZmlndXJhdGlvbikpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgbmV3TmV0d29ya0NvbmZpZ3VyYXRpb25zW25ldHdvcmtDb25maWd1cmF0aW9uSWRdID0ge1xuICAgICAgLi4ubmV0d29ya0NvbmZpZ3VyYXRpb24sXG4gICAgICBpZDogbmV0d29ya0NvbmZpZ3VyYXRpb25JZCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBOZXR3b3JrQ29udHJvbGxlcjoge1xuICAgICAgLi4uTmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICBuZXR3b3JrQ29uZmlndXJhdGlvbnM6IG5ld05ldHdvcmtDb25maWd1cmF0aW9ucyxcbiAgICB9LFxuICB9O1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGhhc1Byb3BlcnR5LCBpc09iamVjdCB9IGZyb20gJ0BtZXRhbWFzay91dGlscyc7XG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gODQ7XG5cbi8qKlxuICogVGhlIGBuZXR3b3JrYCBwcm9wZXJ0eSBpbiBzdGF0ZSB3YXMgcmVwbGFjZWQgd2l0aCBgbmV0d29ya0lkYCBhbmQgYG5ldHdvcmtTdGF0dXNgLlxuICpcbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEgLSBWZXJzaW9uZWQgTWV0YU1hc2sgZXh0ZW5zaW9uIHN0YXRlLCBleGFjdGx5IHdoYXQgd2UgcGVyc2lzdCB0byBkaXN0LlxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5tZXRhIC0gU3RhdGUgbWV0YWRhdGEuXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiAtIFRoZSBjdXJyZW50IHN0YXRlIHZlcnNpb24uXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhLmRhdGEgLSBUaGUgcGVyc2lzdGVkIE1ldGFNYXNrIHN0YXRlLCBrZXllZCBieSBjb250cm9sbGVyLlxuICogQHJldHVybnMgVXBkYXRlZCB2ZXJzaW9uZWQgTWV0YU1hc2sgZXh0ZW5zaW9uIHN0YXRlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGE6IHtcbiAgbWV0YTogeyB2ZXJzaW9uOiBudW1iZXIgfTtcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG59KSB7XG4gIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZSh2ZXJzaW9uZWREYXRhLmRhdGEpO1xuICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XG4gIGlmIChcbiAgICAhaGFzUHJvcGVydHkoc3RhdGUsICdOZXR3b3JrQ29udHJvbGxlcicpIHx8XG4gICAgIWlzT2JqZWN0KHN0YXRlLk5ldHdvcmtDb250cm9sbGVyKSB8fFxuICAgICFoYXNQcm9wZXJ0eShzdGF0ZS5OZXR3b3JrQ29udHJvbGxlciwgJ25ldHdvcmsnKVxuICApIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCBOZXR3b3JrQ29udHJvbGxlciA9IHsgLi4uc3RhdGUuTmV0d29ya0NvbnRyb2xsZXIgfTtcblxuICBpZiAoTmV0d29ya0NvbnRyb2xsZXIubmV0d29yayA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgTmV0d29ya0NvbnRyb2xsZXIubmV0d29ya0lkID0gbnVsbDtcbiAgICBOZXR3b3JrQ29udHJvbGxlci5uZXR3b3JrU3RhdHVzID0gJ3Vua25vd24nO1xuICB9IGVsc2Uge1xuICAgIE5ldHdvcmtDb250cm9sbGVyLm5ldHdvcmtJZCA9IE5ldHdvcmtDb250cm9sbGVyLm5ldHdvcms7XG4gICAgTmV0d29ya0NvbnRyb2xsZXIubmV0d29ya1N0YXR1cyA9ICdhdmFpbGFibGUnO1xuICB9XG5cbiAgZGVsZXRlIE5ldHdvcmtDb250cm9sbGVyLm5ldHdvcms7XG5cbiAgcmV0dXJuIHsgLi4uc3RhdGUsIE5ldHdvcmtDb250cm9sbGVyIH07XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdAbWV0YW1hc2svdXRpbHMnO1xuXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IDg1O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbm93LW9ic29sZXRlIG5ldHdvcmsgY29udHJvbGxlciBgcHJldmlvdXNQcm92aWRlclN0b3JlYCBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhIC0gVmVyc2lvbmVkIE1ldGFNYXNrIGV4dGVuc2lvbiBzdGF0ZSwgZXhhY3RseSB3aGF0IHdlIHBlcnNpc3QgdG8gZGlzdC5cbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEubWV0YSAtIFN0YXRlIG1ldGFkYXRhLlxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gLSBUaGUgY3VycmVudCBzdGF0ZSB2ZXJzaW9uLlxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5kYXRhIC0gVGhlIHBlcnNpc3RlZCBNZXRhTWFzayBzdGF0ZSwga2V5ZWQgYnkgY29udHJvbGxlci5cbiAqIEByZXR1cm5zIFVwZGF0ZWQgdmVyc2lvbmVkIE1ldGFNYXNrIGV4dGVuc2lvbiBzdGF0ZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhOiB7XG4gIG1ldGE6IHsgdmVyc2lvbjogbnVtYmVyIH07XG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xufSkge1xuICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUodmVyc2lvbmVkRGF0YS5kYXRhKTtcbiAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikge1xuICBpZiAoIWlzT2JqZWN0KHN0YXRlLk5ldHdvcmtDb250cm9sbGVyKSkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGRlbGV0ZSBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5wcmV2aW91c1Byb3ZpZGVyU3RvcmU7XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgaGFzUHJvcGVydHksIGlzT2JqZWN0IH0gZnJvbSAnQG1ldGFtYXNrL3V0aWxzJztcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gODY7XG5cbi8qKlxuICogUmVuYW1lIG5ldHdvcmsgY29udHJvbGxlciBgcHJvdmlkZXJgIHN0YXRlIHRvIGBwcm92aWRlckNvbmZpZ2AuXG4gKlxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YSAtIFZlcnNpb25lZCBNZXRhTWFzayBleHRlbnNpb24gc3RhdGUsIGV4YWN0bHkgd2hhdCB3ZSBwZXJzaXN0IHRvIGRpc3QuXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhLm1ldGEgLSBTdGF0ZSBtZXRhZGF0YS5cbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uIC0gVGhlIGN1cnJlbnQgc3RhdGUgdmVyc2lvbi5cbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEuZGF0YSAtIFRoZSBwZXJzaXN0ZWQgTWV0YU1hc2sgc3RhdGUsIGtleWVkIGJ5IGNvbnRyb2xsZXIuXG4gKiBAcmV0dXJucyBVcGRhdGVkIHZlcnNpb25lZCBNZXRhTWFzayBleHRlbnNpb24gc3RhdGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YToge1xuICBtZXRhOiB7IHZlcnNpb246IG51bWJlciB9O1xuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbn0pIHtcbiAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHZlcnNpb25lZERhdGEuZGF0YSk7XG4gIHJldHVybiB2ZXJzaW9uZWREYXRhO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcbiAgaWYgKFxuICAgIGhhc1Byb3BlcnR5KHN0YXRlLCAnTmV0d29ya0NvbnRyb2xsZXInKSAmJlxuICAgIGlzT2JqZWN0KHN0YXRlLk5ldHdvcmtDb250cm9sbGVyKSAmJlxuICAgIGhhc1Byb3BlcnR5KHN0YXRlLk5ldHdvcmtDb250cm9sbGVyLCAncHJvdmlkZXInKVxuICApIHtcbiAgICBjb25zdCBuZXR3b3JrQ29udHJvbGxlclN0YXRlID0gc3RhdGUuTmV0d29ya0NvbnRyb2xsZXI7XG4gICAgbmV0d29ya0NvbnRyb2xsZXJTdGF0ZS5wcm92aWRlckNvbmZpZyA9IG5ldHdvcmtDb250cm9sbGVyU3RhdGUucHJvdmlkZXI7XG4gICAgZGVsZXRlIG5ldHdvcmtDb250cm9sbGVyU3RhdGUucHJvdmlkZXI7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBOZXR3b3JrQ29udHJvbGxlcjogbmV0d29ya0NvbnRyb2xsZXJTdGF0ZSxcbiAgICB9O1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvblN0YXR1cyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmYWlsVHhzVGhhdCh2ZXJzaW9uLCByZWFzb24sIGNvbmRpdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSwgY29uZGl0aW9uLCByZWFzb24pO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSwgY29uZGl0aW9uLCByZWFzb24pIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgY29uc3QgeyBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgfSA9IG5ld1N0YXRlO1xuICBpZiAoVHJhbnNhY3Rpb25Db250cm9sbGVyICYmIFRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gVHJhbnNhY3Rpb25Db250cm9sbGVyO1xuXG4gICAgbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5tYXAoKHR4TWV0YSkgPT4ge1xuICAgICAgaWYgKCFjb25kaXRpb24odHhNZXRhKSkge1xuICAgICAgICByZXR1cm4gdHhNZXRhO1xuICAgICAgfVxuXG4gICAgICB0eE1ldGEuc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuZmFpbGVkO1xuICAgICAgdHhNZXRhLmVyciA9IHtcbiAgICAgICAgbWVzc2FnZTogcmVhc29uLFxuICAgICAgICBub3RlOiBgVHggYXV0b21hdGljYWxseSBmYWlsZWQgYnkgbWlncmF0aW9uIGJlY2F1c2UgJHtyZWFzb259YCxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0eE1ldGE7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLy8gTWlncmF0aW9ucyBtdXN0IHN0YXJ0IGF0IHZlcnNpb24gMSBvciBsYXRlci5cbi8vIFRoZXkgYXJlIG9iamVjdHMgd2l0aCBhIGB2ZXJzaW9uYCBudW1iZXJcbi8vIGFuZCBhIGBtaWdyYXRlYCBmdW5jdGlvbi5cbi8vXG4vLyBUaGUgYG1pZ3JhdGVgIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBwcmV2aW91c1xuLy8gY29uZmlnIGRhdGEgZm9ybWF0LCBhbmQgcmV0dXJucyB0aGUgbmV3IG9uZS5cblxuaW1wb3J0IG0wMDIgZnJvbSAnLi8wMDInO1xuaW1wb3J0IG0wMDMgZnJvbSAnLi8wMDMnO1xuaW1wb3J0IG0wMDQgZnJvbSAnLi8wMDQnO1xuaW1wb3J0IG0wMDUgZnJvbSAnLi8wMDUnO1xuaW1wb3J0IG0wMDYgZnJvbSAnLi8wMDYnO1xuaW1wb3J0IG0wMDcgZnJvbSAnLi8wMDcnO1xuaW1wb3J0IG0wMDggZnJvbSAnLi8wMDgnO1xuaW1wb3J0IG0wMDkgZnJvbSAnLi8wMDknO1xuaW1wb3J0IG0wMTAgZnJvbSAnLi8wMTAnO1xuaW1wb3J0IG0wMTEgZnJvbSAnLi8wMTEnO1xuaW1wb3J0IG0wMTIgZnJvbSAnLi8wMTInO1xuaW1wb3J0IG0wMTMgZnJvbSAnLi8wMTMnO1xuaW1wb3J0IG0wMTQgZnJvbSAnLi8wMTQnO1xuaW1wb3J0IG0wMTUgZnJvbSAnLi8wMTUnO1xuaW1wb3J0IG0wMTYgZnJvbSAnLi8wMTYnO1xuaW1wb3J0IG0wMTcgZnJvbSAnLi8wMTcnO1xuaW1wb3J0IG0wMTggZnJvbSAnLi8wMTgnO1xuaW1wb3J0IG0wMTkgZnJvbSAnLi8wMTknO1xuaW1wb3J0IG0wMjAgZnJvbSAnLi8wMjAnO1xuaW1wb3J0IG0wMjEgZnJvbSAnLi8wMjEnO1xuaW1wb3J0IG0wMjIgZnJvbSAnLi8wMjInO1xuaW1wb3J0IG0wMjMgZnJvbSAnLi8wMjMnO1xuaW1wb3J0IG0wMjQgZnJvbSAnLi8wMjQnO1xuaW1wb3J0IG0wMjUgZnJvbSAnLi8wMjUnO1xuaW1wb3J0IG0wMjYgZnJvbSAnLi8wMjYnO1xuaW1wb3J0IG0wMjcgZnJvbSAnLi8wMjcnO1xuaW1wb3J0IG0wMjggZnJvbSAnLi8wMjgnO1xuaW1wb3J0IG0wMjkgZnJvbSAnLi8wMjknO1xuaW1wb3J0IG0wMzAgZnJvbSAnLi8wMzAnO1xuaW1wb3J0IG0wMzEgZnJvbSAnLi8wMzEnO1xuaW1wb3J0IG0wMzIgZnJvbSAnLi8wMzInO1xuaW1wb3J0IG0wMzMgZnJvbSAnLi8wMzMnO1xuaW1wb3J0IG0wMzQgZnJvbSAnLi8wMzQnO1xuaW1wb3J0IG0wMzUgZnJvbSAnLi8wMzUnO1xuaW1wb3J0IG0wMzYgZnJvbSAnLi8wMzYnO1xuaW1wb3J0IG0wMzcgZnJvbSAnLi8wMzcnO1xuaW1wb3J0IG0wMzggZnJvbSAnLi8wMzgnO1xuaW1wb3J0IG0wMzkgZnJvbSAnLi8wMzknO1xuaW1wb3J0IG0wNDAgZnJvbSAnLi8wNDAnO1xuaW1wb3J0IG0wNDEgZnJvbSAnLi8wNDEnO1xuaW1wb3J0IG0wNDIgZnJvbSAnLi8wNDInO1xuaW1wb3J0IG0wNDMgZnJvbSAnLi8wNDMnO1xuaW1wb3J0IG0wNDQgZnJvbSAnLi8wNDQnO1xuaW1wb3J0IG0wNDUgZnJvbSAnLi8wNDUnO1xuaW1wb3J0IG0wNDYgZnJvbSAnLi8wNDYnO1xuaW1wb3J0IG0wNDcgZnJvbSAnLi8wNDcnO1xuaW1wb3J0IG0wNDggZnJvbSAnLi8wNDgnO1xuaW1wb3J0IG0wNDkgZnJvbSAnLi8wNDknO1xuaW1wb3J0IG0wNTAgZnJvbSAnLi8wNTAnO1xuaW1wb3J0IG0wNTEgZnJvbSAnLi8wNTEnO1xuaW1wb3J0IG0wNTIgZnJvbSAnLi8wNTInO1xuaW1wb3J0IG0wNTMgZnJvbSAnLi8wNTMnO1xuaW1wb3J0IG0wNTQgZnJvbSAnLi8wNTQnO1xuaW1wb3J0IG0wNTUgZnJvbSAnLi8wNTUnO1xuaW1wb3J0IG0wNTYgZnJvbSAnLi8wNTYnO1xuaW1wb3J0IG0wNTcgZnJvbSAnLi8wNTcnO1xuaW1wb3J0IG0wNTggZnJvbSAnLi8wNTgnO1xuaW1wb3J0IG0wNTkgZnJvbSAnLi8wNTknO1xuaW1wb3J0IG0wNjAgZnJvbSAnLi8wNjAnO1xuaW1wb3J0IG0wNjEgZnJvbSAnLi8wNjEnO1xuaW1wb3J0IG0wNjIgZnJvbSAnLi8wNjInO1xuaW1wb3J0IG0wNjMgZnJvbSAnLi8wNjMnO1xuaW1wb3J0IG0wNjQgZnJvbSAnLi8wNjQnO1xuaW1wb3J0IG0wNjUgZnJvbSAnLi8wNjUnO1xuaW1wb3J0IG0wNjYgZnJvbSAnLi8wNjYnO1xuaW1wb3J0IG0wNjcgZnJvbSAnLi8wNjcnO1xuaW1wb3J0IG0wNjggZnJvbSAnLi8wNjgnO1xuaW1wb3J0IG0wNjkgZnJvbSAnLi8wNjknO1xuaW1wb3J0IG0wNzAgZnJvbSAnLi8wNzAnO1xuaW1wb3J0IG0wNzEgZnJvbSAnLi8wNzEnO1xuaW1wb3J0IG0wNzIgZnJvbSAnLi8wNzInO1xuaW1wb3J0IG0wNzMgZnJvbSAnLi8wNzMnO1xuaW1wb3J0IG0wNzQgZnJvbSAnLi8wNzQnO1xuaW1wb3J0IG0wNzUgZnJvbSAnLi8wNzUnO1xuaW1wb3J0IG0wNzYgZnJvbSAnLi8wNzYnO1xuaW1wb3J0IG0wNzcgZnJvbSAnLi8wNzcnO1xuaW1wb3J0ICogYXMgbTA3OCBmcm9tICcuLzA3OCc7XG5pbXBvcnQgbTA3OSBmcm9tICcuLzA3OSc7XG5pbXBvcnQgbTA4MCBmcm9tICcuLzA4MCc7XG5pbXBvcnQgKiBhcyBtMDgxIGZyb20gJy4vMDgxJztcbmltcG9ydCAqIGFzIG0wODIgZnJvbSAnLi8wODInO1xuaW1wb3J0ICogYXMgbTA4MyBmcm9tICcuLzA4Myc7XG5pbXBvcnQgKiBhcyBtMDg0IGZyb20gJy4vMDg0JztcbmltcG9ydCAqIGFzIG0wODUgZnJvbSAnLi8wODUnO1xuaW1wb3J0ICogYXMgbTA4NiBmcm9tICcuLzA4Nic7XG5cbmNvbnN0IG1pZ3JhdGlvbnMgPSBbXG4gIG0wMDIsXG4gIG0wMDMsXG4gIG0wMDQsXG4gIG0wMDUsXG4gIG0wMDYsXG4gIG0wMDcsXG4gIG0wMDgsXG4gIG0wMDksXG4gIG0wMTAsXG4gIG0wMTEsXG4gIG0wMTIsXG4gIG0wMTMsXG4gIG0wMTQsXG4gIG0wMTUsXG4gIG0wMTYsXG4gIG0wMTcsXG4gIG0wMTgsXG4gIG0wMTksXG4gIG0wMjAsXG4gIG0wMjEsXG4gIG0wMjIsXG4gIG0wMjMsXG4gIG0wMjQsXG4gIG0wMjUsXG4gIG0wMjYsXG4gIG0wMjcsXG4gIG0wMjgsXG4gIG0wMjksXG4gIG0wMzAsXG4gIG0wMzEsXG4gIG0wMzIsXG4gIG0wMzMsXG4gIG0wMzQsXG4gIG0wMzUsXG4gIG0wMzYsXG4gIG0wMzcsXG4gIG0wMzgsXG4gIG0wMzksXG4gIG0wNDAsXG4gIG0wNDEsXG4gIG0wNDIsXG4gIG0wNDMsXG4gIG0wNDQsXG4gIG0wNDUsXG4gIG0wNDYsXG4gIG0wNDcsXG4gIG0wNDgsXG4gIG0wNDksXG4gIG0wNTAsXG4gIG0wNTEsXG4gIG0wNTIsXG4gIG0wNTMsXG4gIG0wNTQsXG4gIG0wNTUsXG4gIG0wNTYsXG4gIG0wNTcsXG4gIG0wNTgsXG4gIG0wNTksXG4gIG0wNjAsXG4gIG0wNjEsXG4gIG0wNjIsXG4gIG0wNjMsXG4gIG0wNjQsXG4gIG0wNjUsXG4gIG0wNjYsXG4gIG0wNjcsXG4gIG0wNjgsXG4gIG0wNjksXG4gIG0wNzAsXG4gIG0wNzEsXG4gIG0wNzIsXG4gIG0wNzMsXG4gIG0wNzQsXG4gIG0wNzUsXG4gIG0wNzYsXG4gIG0wNzcsXG4gIG0wNzgsXG4gIG0wNzksXG4gIG0wODAsXG4gIG0wODEsXG4gIG0wODIsXG4gIG0wODMsXG4gIG0wODQsXG4gIG0wODUsXG4gIG0wODYsXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBtaWdyYXRpb25zO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgZW5jb2RlVGV4dCB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL3R5cGVzJykuQ29kZWNGYWN0b3J5fSBDb2RlY0ZhY3RvcnkgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXyhcIi4vdHlwZXNcIikuQmFzZU5hbWV9IEJhc2VOYW1lICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oXCIuL3R5cGVzXCIpLkJhc2VDb2RlfSBCYXNlQ29kZSAqL1xuXG4vKipcbiAqIENsYXNzIHRvIGVuY29kZS9kZWNvZGUgaW4gdGhlIHN1cHBvcnRlZCBCYXNlc1xuICpcbiAqL1xuY2xhc3MgQmFzZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Jhc2VOYW1lfSBuYW1lXG4gICAqIEBwYXJhbSB7QmFzZUNvZGV9IGNvZGVcbiAgICogQHBhcmFtIHtDb2RlY0ZhY3Rvcnl9IGZhY3RvcnlcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFscGhhYmV0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAobmFtZSwgY29kZSwgZmFjdG9yeSwgYWxwaGFiZXQpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy5jb2RlID0gY29kZVxuICAgIHRoaXMuY29kZUJ1ZiA9IGVuY29kZVRleHQodGhpcy5jb2RlKVxuICAgIHRoaXMuYWxwaGFiZXQgPSBhbHBoYWJldFxuICAgIHRoaXMuY29kZWMgPSBmYWN0b3J5KGFscGhhYmV0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBlbmNvZGUgKGJ1Zikge1xuICAgIHJldHVybiB0aGlzLmNvZGVjLmVuY29kZShidWYpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICovXG4gIGRlY29kZSAoc3RyaW5nKSB7XG4gICAgZm9yIChjb25zdCBjaGFyIG9mIHN0cmluZykge1xuICAgICAgaWYgKHRoaXMuYWxwaGFiZXQgJiYgdGhpcy5hbHBoYWJldC5pbmRleE9mKGNoYXIpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgY2hhcmFjdGVyICcke2NoYXJ9JyBpbiAnJHtzdHJpbmd9J2ApXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvZGVjLmRlY29kZShzdHJpbmcpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgYmFzZVggPSByZXF1aXJlKCdAbXVsdGlmb3JtYXRzL2Jhc2UteCcpXG5jb25zdCBCYXNlID0gcmVxdWlyZSgnLi9iYXNlLmpzJylcbmNvbnN0IHsgcmZjNDY0OCB9ID0gcmVxdWlyZSgnLi9yZmM0NjQ4JylcbmNvbnN0IHsgZGVjb2RlVGV4dCwgZW5jb2RlVGV4dCB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL3R5cGVzJykuQ29kZWNGYWN0b3J5fSBDb2RlY0ZhY3RvcnkgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi90eXBlcycpLkNvZGVjfSBDb2RlYyAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL3R5cGVzJykuQmFzZU5hbWV9IEJhc2VOYW1lICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vdHlwZXMnKS5CYXNlQ29kZX0gQmFzZUNvZGUgKi9cblxuLyoqIEB0eXBlIHtDb2RlY0ZhY3Rvcnl9ICovXG5jb25zdCBpZGVudGl0eSA9ICgpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGRlY29kZVRleHQsXG4gICAgZGVjb2RlOiBlbmNvZGVUZXh0XG4gIH1cbn1cblxuLyoqXG4gKlxuICogbmFtZSwgY29kZSwgaW1wbGVtZW50YXRpb24sIGFscGhhYmV0XG4gKlxuICogQHR5cGUge0FycmF5PFtCYXNlTmFtZSwgQmFzZUNvZGUsIENvZGVjRmFjdG9yeSwgc3RyaW5nXT59XG4gKi9cbmNvbnN0IGNvbnN0YW50cyA9IFtcbiAgWydpZGVudGl0eScsICdcXHgwMCcsIGlkZW50aXR5LCAnJ10sXG4gIFsnYmFzZTInLCAnMCcsIHJmYzQ2NDgoMSksICcwMSddLFxuICBbJ2Jhc2U4JywgJzcnLCByZmM0NjQ4KDMpLCAnMDEyMzQ1NjcnXSxcbiAgWydiYXNlMTAnLCAnOScsIGJhc2VYLCAnMDEyMzQ1Njc4OSddLFxuICBbJ2Jhc2UxNicsICdmJywgcmZjNDY0OCg0KSwgJzAxMjM0NTY3ODlhYmNkZWYnXSxcbiAgWydiYXNlMTZ1cHBlcicsICdGJywgcmZjNDY0OCg0KSwgJzAxMjM0NTY3ODlBQkNERUYnXSxcbiAgWydiYXNlMzJoZXgnLCAndicsIHJmYzQ2NDgoNSksICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1diddLFxuICBbJ2Jhc2UzMmhleHVwcGVyJywgJ1YnLCByZmM0NjQ4KDUpLCAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnXSxcbiAgWydiYXNlMzJoZXhwYWQnLCAndCcsIHJmYzQ2NDgoNSksICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dj0nXSxcbiAgWydiYXNlMzJoZXhwYWR1cHBlcicsICdUJywgcmZjNDY0OCg1KSwgJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWPSddLFxuICBbJ2Jhc2UzMicsICdiJywgcmZjNDY0OCg1KSwgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3J10sXG4gIFsnYmFzZTMydXBwZXInLCAnQicsIHJmYzQ2NDgoNSksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NyddLFxuICBbJ2Jhc2UzMnBhZCcsICdjJywgcmZjNDY0OCg1KSwgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3PSddLFxuICBbJ2Jhc2UzMnBhZHVwcGVyJywgJ0MnLCByZmM0NjQ4KDUpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1Njc9J10sXG4gIFsnYmFzZTMyeicsICdoJywgcmZjNDY0OCg1KSwgJ3libmRyZmc4ZWprbWNwcXhvdDF1d2lzemEzNDVoNzY5J10sXG4gIFsnYmFzZTM2JywgJ2snLCBiYXNlWCwgJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eiddLFxuICBbJ2Jhc2UzNnVwcGVyJywgJ0snLCBiYXNlWCwgJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiddLFxuICBbJ2Jhc2U1OGJ0YycsICd6JywgYmFzZVgsICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6J10sXG4gIFsnYmFzZTU4ZmxpY2tyJywgJ1onLCBiYXNlWCwgJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonXSxcbiAgWydiYXNlNjQnLCAnbScsIHJmYzQ2NDgoNiksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ10sXG4gIFsnYmFzZTY0cGFkJywgJ00nLCByZmM0NjQ4KDYpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nXSxcbiAgWydiYXNlNjR1cmwnLCAndScsIHJmYzQ2NDgoNiksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJ10sXG4gIFsnYmFzZTY0dXJscGFkJywgJ1UnLCByZmM0NjQ4KDYpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXz0nXVxuXVxuXG4vKiogQHR5cGUge1JlY29yZDxCYXNlTmFtZSxCYXNlPn0gKi9cbmNvbnN0IG5hbWVzID0gY29uc3RhbnRzLnJlZHVjZSgocHJldiwgdHVwcGxlKSA9PiB7XG4gIHByZXZbdHVwcGxlWzBdXSA9IG5ldyBCYXNlKHR1cHBsZVswXSwgdHVwcGxlWzFdLCB0dXBwbGVbMl0sIHR1cHBsZVszXSlcbiAgcmV0dXJuIHByZXZcbn0sIC8qKiBAdHlwZSB7UmVjb3JkPEJhc2VOYW1lLEJhc2U+fSAqLyh7fSkpXG5cbi8qKiBAdHlwZSB7UmVjb3JkPEJhc2VDb2RlLEJhc2U+fSAqL1xuY29uc3QgY29kZXMgPSBjb25zdGFudHMucmVkdWNlKChwcmV2LCB0dXBwbGUpID0+IHtcbiAgcHJldlt0dXBwbGVbMV1dID0gbmFtZXNbdHVwcGxlWzBdXVxuICByZXR1cm4gcHJldlxufSwgLyoqIEB0eXBlIHtSZWNvcmQ8QmFzZUNvZGUsQmFzZT59ICovKHt9KSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWVzLFxuICBjb2Rlc1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi90eXBlcycpLkNvZGVjRmFjdG9yeX0gQ29kZWNGYWN0b3J5ICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGFscGhhYmV0XG4gKiBAcGFyYW0ge251bWJlcn0gYml0c1BlckNoYXJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBkZWNvZGUgPSAoc3RyaW5nLCBhbHBoYWJldCwgYml0c1BlckNoYXIpID0+IHtcbiAgLy8gQnVpbGQgdGhlIGNoYXJhY3RlciBsb29rdXAgdGFibGU6XG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgbnVtYmVyPn0gKi9cbiAgY29uc3QgY29kZXMgPSB7fVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29kZXNbYWxwaGFiZXRbaV1dID0gaVxuICB9XG5cbiAgLy8gQ291bnQgdGhlIHBhZGRpbmcgYnl0ZXM6XG4gIGxldCBlbmQgPSBzdHJpbmcubGVuZ3RoXG4gIHdoaWxlIChzdHJpbmdbZW5kIC0gMV0gPT09ICc9Jykge1xuICAgIC0tZW5kXG4gIH1cblxuICAvLyBBbGxvY2F0ZSB0aGUgb3V0cHV0OlxuICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSgoZW5kICogYml0c1BlckNoYXIgLyA4KSB8IDApXG5cbiAgLy8gUGFyc2UgdGhlIGRhdGE6XG4gIGxldCBiaXRzID0gMCAvLyBOdW1iZXIgb2YgYml0cyBjdXJyZW50bHkgaW4gdGhlIGJ1ZmZlclxuICBsZXQgYnVmZmVyID0gMCAvLyBCaXRzIHdhaXRpbmcgdG8gYmUgd3JpdHRlbiBvdXQsIE1TQiBmaXJzdFxuICBsZXQgd3JpdHRlbiA9IDAgLy8gTmV4dCBieXRlIHRvIHdyaXRlXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5kOyArK2kpIHtcbiAgICAvLyBSZWFkIG9uZSBjaGFyYWN0ZXIgZnJvbSB0aGUgc3RyaW5nOlxuICAgIGNvbnN0IHZhbHVlID0gY29kZXNbc3RyaW5nW2ldXVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyICcgKyBzdHJpbmdbaV0pXG4gICAgfVxuXG4gICAgLy8gQXBwZW5kIHRoZSBiaXRzIHRvIHRoZSBidWZmZXI6XG4gICAgYnVmZmVyID0gKGJ1ZmZlciA8PCBiaXRzUGVyQ2hhcikgfCB2YWx1ZVxuICAgIGJpdHMgKz0gYml0c1BlckNoYXJcblxuICAgIC8vIFdyaXRlIG91dCBzb21lIGJpdHMgaWYgdGhlIGJ1ZmZlciBoYXMgYSBieXRlJ3Mgd29ydGg6XG4gICAgaWYgKGJpdHMgPj0gOCkge1xuICAgICAgYml0cyAtPSA4XG4gICAgICBvdXRbd3JpdHRlbisrXSA9IDB4ZmYgJiAoYnVmZmVyID4+IGJpdHMpXG4gICAgfVxuICB9XG5cbiAgLy8gVmVyaWZ5IHRoYXQgd2UgaGF2ZSByZWNlaXZlZCBqdXN0IGVub3VnaCBiaXRzOlxuICBpZiAoYml0cyA+PSBiaXRzUGVyQ2hhciB8fCAweGZmICYgKGJ1ZmZlciA8PCAoOCAtIGJpdHMpKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgZGF0YScpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYWxwaGFiZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRzUGVyQ2hhclxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuY29uc3QgZW5jb2RlID0gKGRhdGEsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcikgPT4ge1xuICBjb25zdCBwYWQgPSBhbHBoYWJldFthbHBoYWJldC5sZW5ndGggLSAxXSA9PT0gJz0nXG4gIGNvbnN0IG1hc2sgPSAoMSA8PCBiaXRzUGVyQ2hhcikgLSAxXG4gIGxldCBvdXQgPSAnJ1xuXG4gIGxldCBiaXRzID0gMCAvLyBOdW1iZXIgb2YgYml0cyBjdXJyZW50bHkgaW4gdGhlIGJ1ZmZlclxuICBsZXQgYnVmZmVyID0gMCAvLyBCaXRzIHdhaXRpbmcgdG8gYmUgd3JpdHRlbiBvdXQsIE1TQiBmaXJzdFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBTbHVycCBkYXRhIGludG8gdGhlIGJ1ZmZlcjpcbiAgICBidWZmZXIgPSAoYnVmZmVyIDw8IDgpIHwgZGF0YVtpXVxuICAgIGJpdHMgKz0gOFxuXG4gICAgLy8gV3JpdGUgb3V0IGFzIG11Y2ggYXMgd2UgY2FuOlxuICAgIHdoaWxlIChiaXRzID4gYml0c1BlckNoYXIpIHtcbiAgICAgIGJpdHMgLT0gYml0c1BlckNoYXJcbiAgICAgIG91dCArPSBhbHBoYWJldFttYXNrICYgKGJ1ZmZlciA+PiBiaXRzKV1cbiAgICB9XG4gIH1cblxuICAvLyBQYXJ0aWFsIGNoYXJhY3RlcjpcbiAgaWYgKGJpdHMpIHtcbiAgICBvdXQgKz0gYWxwaGFiZXRbbWFzayAmIChidWZmZXIgPDwgKGJpdHNQZXJDaGFyIC0gYml0cykpXVxuICB9XG5cbiAgLy8gQWRkIHBhZGRpbmcgY2hhcmFjdGVycyB1bnRpbCB3ZSBoaXQgYSBieXRlIGJvdW5kYXJ5OlxuICBpZiAocGFkKSB7XG4gICAgd2hpbGUgKChvdXQubGVuZ3RoICogYml0c1BlckNoYXIpICYgNykge1xuICAgICAgb3V0ICs9ICc9J1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBSRkM0NjQ4IEZhY3RvcnlcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYml0c1BlckNoYXJcbiAqIEByZXR1cm5zIHtDb2RlY0ZhY3Rvcnl9XG4gKi9cbmNvbnN0IHJmYzQ2NDggPSAoYml0c1BlckNoYXIpID0+IChhbHBoYWJldCkgPT4ge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGVuY29kZSAoaW5wdXQpIHtcbiAgICAgIHJldHVybiBlbmNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcilcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIGRlY29kZSAoaW5wdXQpIHtcbiAgICAgIHJldHVybiBkZWNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcilcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IHJmYzQ2NDggfVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IHsgVGV4dEVuY29kZXIsIFRleHREZWNvZGVyIH0gPSByZXF1aXJlKCd3ZWItZW5jb2RpbmcnKVxuXG5jb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG4vKipcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fEFycmF5QnVmZmVyfSBieXRlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuY29uc3QgZGVjb2RlVGV4dCA9IChieXRlcykgPT4gdGV4dERlY29kZXIuZGVjb2RlKGJ5dGVzKVxuXG5jb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZW5jb2RlVGV4dCA9ICh0ZXh0KSA9PiB0ZXh0RW5jb2Rlci5lbmNvZGUodGV4dClcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IFVpbnQ4QXJyYXkgY3JlYXRlZCBieSBjb25jYXRlbmF0aW5nIHRoZSBwYXNzZWQgQXJyYXlzXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheUxpa2U8bnVtYmVyPj59IGFycnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBjb25jYXQgKGFycnMsIGxlbmd0aCkge1xuICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGxldCBvZmZzZXQgPSAwXG5cbiAgZm9yIChjb25zdCBhcnIgb2YgYXJycykge1xuICAgIG91dHB1dC5zZXQoYXJyLCBvZmZzZXQpXG4gICAgb2Zmc2V0ICs9IGFyci5sZW5ndGhcbiAgfVxuXG4gIHJldHVybiBvdXRwdXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IGRlY29kZVRleHQsIGVuY29kZVRleHQsIGNvbmNhdCB9XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlYWRcblxudmFyIE1TQiA9IDB4ODBcbiAgLCBSRVNUID0gMHg3RlxuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciByZXMgICAgPSAwXG4gICAgLCBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICAgICwgc2hpZnQgID0gMFxuICAgICwgY291bnRlciA9IG9mZnNldFxuICAgICwgYlxuICAgICwgbCA9IGJ1Zi5sZW5ndGhcblxuICBkbyB7XG4gICAgaWYgKGNvdW50ZXIgPj0gbCB8fCBzaGlmdCA+IDQ5KSB7XG4gICAgICByZWFkLmJ5dGVzID0gMFxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NvdWxkIG5vdCBkZWNvZGUgdmFyaW50JylcbiAgICB9XG4gICAgYiA9IGJ1Zltjb3VudGVyKytdXG4gICAgcmVzICs9IHNoaWZ0IDwgMjhcbiAgICAgID8gKGIgJiBSRVNUKSA8PCBzaGlmdFxuICAgICAgOiAoYiAmIFJFU1QpICogTWF0aC5wb3coMiwgc2hpZnQpXG4gICAgc2hpZnQgKz0gN1xuICB9IHdoaWxlIChiID49IE1TQilcblxuICByZWFkLmJ5dGVzID0gY291bnRlciAtIG9mZnNldFxuXG4gIHJldHVybiByZXNcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZW5jb2RlXG5cbnZhciBNU0IgPSAweDgwXG4gICwgUkVTVCA9IDB4N0ZcbiAgLCBNU0JBTEwgPSB+UkVTVFxuICAsIElOVCA9IE1hdGgucG93KDIsIDMxKVxuXG5mdW5jdGlvbiBlbmNvZGUobnVtLCBvdXQsIG9mZnNldCkge1xuICBpZiAoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgJiYgbnVtID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICBlbmNvZGUuYnl0ZXMgPSAwXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NvdWxkIG5vdCBlbmNvZGUgdmFyaW50JylcbiAgfVxuICBvdXQgPSBvdXQgfHwgW11cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDBcbiAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuXG4gIHdoaWxlKG51bSA+PSBJTlQpIHtcbiAgICBvdXRbb2Zmc2V0KytdID0gKG51bSAmIDB4RkYpIHwgTVNCXG4gICAgbnVtIC89IDEyOFxuICB9XG4gIHdoaWxlKG51bSAmIE1TQkFMTCkge1xuICAgIG91dFtvZmZzZXQrK10gPSAobnVtICYgMHhGRikgfCBNU0JcbiAgICBudW0gPj4+PSA3XG4gIH1cbiAgb3V0W29mZnNldF0gPSBudW0gfCAwXG4gIFxuICBlbmNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXQgKyAxXG4gIFxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBlbmNvZGU6IHJlcXVpcmUoJy4vZW5jb2RlLmpzJylcbiAgLCBkZWNvZGU6IHJlcXVpcmUoJy4vZGVjb2RlLmpzJylcbiAgLCBlbmNvZGluZ0xlbmd0aDogcmVxdWlyZSgnLi9sZW5ndGguanMnKVxufVxuIiwiXG52YXIgTjEgPSBNYXRoLnBvdygyLCAgNylcbnZhciBOMiA9IE1hdGgucG93KDIsIDE0KVxudmFyIE4zID0gTWF0aC5wb3coMiwgMjEpXG52YXIgTjQgPSBNYXRoLnBvdygyLCAyOClcbnZhciBONSA9IE1hdGgucG93KDIsIDM1KVxudmFyIE42ID0gTWF0aC5wb3coMiwgNDIpXG52YXIgTjcgPSBNYXRoLnBvdygyLCA0OSlcbnZhciBOOCA9IE1hdGgucG93KDIsIDU2KVxudmFyIE45ID0gTWF0aC5wb3coMiwgNjMpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgPCBOMSA/IDFcbiAgOiB2YWx1ZSA8IE4yID8gMlxuICA6IHZhbHVlIDwgTjMgPyAzXG4gIDogdmFsdWUgPCBONCA/IDRcbiAgOiB2YWx1ZSA8IE41ID8gNVxuICA6IHZhbHVlIDwgTjYgPyA2XG4gIDogdmFsdWUgPCBONyA/IDdcbiAgOiB2YWx1ZSA8IE44ID8gOFxuICA6IHZhbHVlIDwgTjkgPyA5XG4gIDogICAgICAgICAgICAgIDEwXG4gIClcbn1cbiIsIi8vIERPIE5PVCBDSEFOR0UgVEhJUyBGSUxFLiBJVCBJUyBHRU5FUkFURUQgQlkgdG9vbHMvdXBkYXRlLXRhYmxlLmpzXG4vKiBlc2xpbnQgcXVvdGUtcHJvcHM6IG9mZiAqL1xuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQHR5cGUge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuTmFtZU51bWJlck1hcH1cbiAqL1xuY29uc3QgYmFzZVRhYmxlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICdpZGVudGl0eSc6IDB4MDAsXG4gICdjaWR2MSc6IDB4MDEsXG4gICdjaWR2Mic6IDB4MDIsXG4gICdjaWR2Myc6IDB4MDMsXG4gICdpcDQnOiAweDA0LFxuICAndGNwJzogMHgwNixcbiAgJ3NoYTEnOiAweDExLFxuICAnc2hhMi0yNTYnOiAweDEyLFxuICAnc2hhMi01MTInOiAweDEzLFxuICAnc2hhMy01MTInOiAweDE0LFxuICAnc2hhMy0zODQnOiAweDE1LFxuICAnc2hhMy0yNTYnOiAweDE2LFxuICAnc2hhMy0yMjQnOiAweDE3LFxuICAnc2hha2UtMTI4JzogMHgxOCxcbiAgJ3NoYWtlLTI1Nic6IDB4MTksXG4gICdrZWNjYWstMjI0JzogMHgxYSxcbiAgJ2tlY2Nhay0yNTYnOiAweDFiLFxuICAna2VjY2FrLTM4NCc6IDB4MWMsXG4gICdrZWNjYWstNTEyJzogMHgxZCxcbiAgJ2JsYWtlMyc6IDB4MWUsXG4gICdkY2NwJzogMHgyMSxcbiAgJ211cm11cjMtMTI4JzogMHgyMixcbiAgJ211cm11cjMtMzInOiAweDIzLFxuICAnaXA2JzogMHgyOSxcbiAgJ2lwNnpvbmUnOiAweDJhLFxuICAncGF0aCc6IDB4MmYsXG4gICdtdWx0aWNvZGVjJzogMHgzMCxcbiAgJ211bHRpaGFzaCc6IDB4MzEsXG4gICdtdWx0aWFkZHInOiAweDMyLFxuICAnbXVsdGliYXNlJzogMHgzMyxcbiAgJ2Rucyc6IDB4MzUsXG4gICdkbnM0JzogMHgzNixcbiAgJ2RuczYnOiAweDM3LFxuICAnZG5zYWRkcic6IDB4MzgsXG4gICdwcm90b2J1Zic6IDB4NTAsXG4gICdjYm9yJzogMHg1MSxcbiAgJ3Jhdyc6IDB4NTUsXG4gICdkYmwtc2hhMi0yNTYnOiAweDU2LFxuICAncmxwJzogMHg2MCxcbiAgJ2JlbmNvZGUnOiAweDYzLFxuICAnZGFnLXBiJzogMHg3MCxcbiAgJ2RhZy1jYm9yJzogMHg3MSxcbiAgJ2xpYnAycC1rZXknOiAweDcyLFxuICAnZ2l0LXJhdyc6IDB4NzgsXG4gICd0b3JyZW50LWluZm8nOiAweDdiLFxuICAndG9ycmVudC1maWxlJzogMHg3YyxcbiAgJ2xlb2Zjb2luLWJsb2NrJzogMHg4MSxcbiAgJ2xlb2Zjb2luLXR4JzogMHg4MixcbiAgJ2xlb2Zjb2luLXByJzogMHg4MyxcbiAgJ3NjdHAnOiAweDg0LFxuICAnZGFnLWpvc2UnOiAweDg1LFxuICAnZGFnLWNvc2UnOiAweDg2LFxuICAnZXRoLWJsb2NrJzogMHg5MCxcbiAgJ2V0aC1ibG9jay1saXN0JzogMHg5MSxcbiAgJ2V0aC10eC10cmllJzogMHg5MixcbiAgJ2V0aC10eCc6IDB4OTMsXG4gICdldGgtdHgtcmVjZWlwdC10cmllJzogMHg5NCxcbiAgJ2V0aC10eC1yZWNlaXB0JzogMHg5NSxcbiAgJ2V0aC1zdGF0ZS10cmllJzogMHg5NixcbiAgJ2V0aC1hY2NvdW50LXNuYXBzaG90JzogMHg5NyxcbiAgJ2V0aC1zdG9yYWdlLXRyaWUnOiAweDk4LFxuICAnYml0Y29pbi1ibG9jayc6IDB4YjAsXG4gICdiaXRjb2luLXR4JzogMHhiMSxcbiAgJ2JpdGNvaW4td2l0bmVzcy1jb21taXRtZW50JzogMHhiMixcbiAgJ3pjYXNoLWJsb2NrJzogMHhjMCxcbiAgJ3pjYXNoLXR4JzogMHhjMSxcbiAgJ2RvY2lkJzogMHhjZSxcbiAgJ3N0ZWxsYXItYmxvY2snOiAweGQwLFxuICAnc3RlbGxhci10eCc6IDB4ZDEsXG4gICdtZDQnOiAweGQ0LFxuICAnbWQ1JzogMHhkNSxcbiAgJ2JtdCc6IDB4ZDYsXG4gICdkZWNyZWQtYmxvY2snOiAweGUwLFxuICAnZGVjcmVkLXR4JzogMHhlMSxcbiAgJ2lwbGQtbnMnOiAweGUyLFxuICAnaXBmcy1ucyc6IDB4ZTMsXG4gICdzd2FybS1ucyc6IDB4ZTQsXG4gICdpcG5zLW5zJzogMHhlNSxcbiAgJ3plcm9uZXQnOiAweGU2LFxuICAnc2VjcDI1NmsxLXB1Yic6IDB4ZTcsXG4gICdibHMxMl8zODEtZzEtcHViJzogMHhlYSxcbiAgJ2JsczEyXzM4MS1nMi1wdWInOiAweGViLFxuICAneDI1NTE5LXB1Yic6IDB4ZWMsXG4gICdlZDI1NTE5LXB1Yic6IDB4ZWQsXG4gICdibHMxMl8zODEtZzFnMi1wdWInOiAweGVlLFxuICAnZGFzaC1ibG9jayc6IDB4ZjAsXG4gICdkYXNoLXR4JzogMHhmMSxcbiAgJ3N3YXJtLW1hbmlmZXN0JzogMHhmYSxcbiAgJ3N3YXJtLWZlZWQnOiAweGZiLFxuICAndWRwJzogMHgwMTExLFxuICAncDJwLXdlYnJ0Yy1zdGFyJzogMHgwMTEzLFxuICAncDJwLXdlYnJ0Yy1kaXJlY3QnOiAweDAxMTQsXG4gICdwMnAtc3RhcmR1c3QnOiAweDAxMTUsXG4gICdwMnAtY2lyY3VpdCc6IDB4MDEyMixcbiAgJ2RhZy1qc29uJzogMHgwMTI5LFxuICAndWR0JzogMHgwMTJkLFxuICAndXRwJzogMHgwMTJlLFxuICAndW5peCc6IDB4MDE5MCxcbiAgJ3AycCc6IDB4MDFhNSxcbiAgJ2lwZnMnOiAweDAxYTUsXG4gICdodHRwcyc6IDB4MDFiYixcbiAgJ29uaW9uJzogMHgwMWJjLFxuICAnb25pb24zJzogMHgwMWJkLFxuICAnZ2FybGljNjQnOiAweDAxYmUsXG4gICdnYXJsaWMzMic6IDB4MDFiZixcbiAgJ3Rscyc6IDB4MDFjMCxcbiAgJ3F1aWMnOiAweDAxY2MsXG4gICd3cyc6IDB4MDFkZCxcbiAgJ3dzcyc6IDB4MDFkZSxcbiAgJ3AycC13ZWJzb2NrZXQtc3Rhcic6IDB4MDFkZixcbiAgJ2h0dHAnOiAweDAxZTAsXG4gICdqc29uJzogMHgwMjAwLFxuICAnbWVzc2FnZXBhY2snOiAweDAyMDEsXG4gICdsaWJwMnAtcGVlci1yZWNvcmQnOiAweDAzMDEsXG4gICdzaGEyLTI1Ni10cnVuYzI1NC1wYWRkZWQnOiAweDEwMTIsXG4gICdyaXBlbWQtMTI4JzogMHgxMDUyLFxuICAncmlwZW1kLTE2MCc6IDB4MTA1MyxcbiAgJ3JpcGVtZC0yNTYnOiAweDEwNTQsXG4gICdyaXBlbWQtMzIwJzogMHgxMDU1LFxuICAneDExJzogMHgxMTAwLFxuICAncDI1Ni1wdWInOiAweDEyMDAsXG4gICdwMzg0LXB1Yic6IDB4MTIwMSxcbiAgJ3A1MjEtcHViJzogMHgxMjAyLFxuICAnZWQ0NDgtcHViJzogMHgxMjAzLFxuICAneDQ0OC1wdWInOiAweDEyMDQsXG4gICdlZDI1NTE5LXByaXYnOiAweDEzMDAsXG4gICdrYW5nYXJvb3R3ZWx2ZSc6IDB4MWQwMSxcbiAgJ3NtMy0yNTYnOiAweDUzNGQsXG4gICdibGFrZTJiLTgnOiAweGIyMDEsXG4gICdibGFrZTJiLTE2JzogMHhiMjAyLFxuICAnYmxha2UyYi0yNCc6IDB4YjIwMyxcbiAgJ2JsYWtlMmItMzInOiAweGIyMDQsXG4gICdibGFrZTJiLTQwJzogMHhiMjA1LFxuICAnYmxha2UyYi00OCc6IDB4YjIwNixcbiAgJ2JsYWtlMmItNTYnOiAweGIyMDcsXG4gICdibGFrZTJiLTY0JzogMHhiMjA4LFxuICAnYmxha2UyYi03Mic6IDB4YjIwOSxcbiAgJ2JsYWtlMmItODAnOiAweGIyMGEsXG4gICdibGFrZTJiLTg4JzogMHhiMjBiLFxuICAnYmxha2UyYi05Nic6IDB4YjIwYyxcbiAgJ2JsYWtlMmItMTA0JzogMHhiMjBkLFxuICAnYmxha2UyYi0xMTInOiAweGIyMGUsXG4gICdibGFrZTJiLTEyMCc6IDB4YjIwZixcbiAgJ2JsYWtlMmItMTI4JzogMHhiMjEwLFxuICAnYmxha2UyYi0xMzYnOiAweGIyMTEsXG4gICdibGFrZTJiLTE0NCc6IDB4YjIxMixcbiAgJ2JsYWtlMmItMTUyJzogMHhiMjEzLFxuICAnYmxha2UyYi0xNjAnOiAweGIyMTQsXG4gICdibGFrZTJiLTE2OCc6IDB4YjIxNSxcbiAgJ2JsYWtlMmItMTc2JzogMHhiMjE2LFxuICAnYmxha2UyYi0xODQnOiAweGIyMTcsXG4gICdibGFrZTJiLTE5Mic6IDB4YjIxOCxcbiAgJ2JsYWtlMmItMjAwJzogMHhiMjE5LFxuICAnYmxha2UyYi0yMDgnOiAweGIyMWEsXG4gICdibGFrZTJiLTIxNic6IDB4YjIxYixcbiAgJ2JsYWtlMmItMjI0JzogMHhiMjFjLFxuICAnYmxha2UyYi0yMzInOiAweGIyMWQsXG4gICdibGFrZTJiLTI0MCc6IDB4YjIxZSxcbiAgJ2JsYWtlMmItMjQ4JzogMHhiMjFmLFxuICAnYmxha2UyYi0yNTYnOiAweGIyMjAsXG4gICdibGFrZTJiLTI2NCc6IDB4YjIyMSxcbiAgJ2JsYWtlMmItMjcyJzogMHhiMjIyLFxuICAnYmxha2UyYi0yODAnOiAweGIyMjMsXG4gICdibGFrZTJiLTI4OCc6IDB4YjIyNCxcbiAgJ2JsYWtlMmItMjk2JzogMHhiMjI1LFxuICAnYmxha2UyYi0zMDQnOiAweGIyMjYsXG4gICdibGFrZTJiLTMxMic6IDB4YjIyNyxcbiAgJ2JsYWtlMmItMzIwJzogMHhiMjI4LFxuICAnYmxha2UyYi0zMjgnOiAweGIyMjksXG4gICdibGFrZTJiLTMzNic6IDB4YjIyYSxcbiAgJ2JsYWtlMmItMzQ0JzogMHhiMjJiLFxuICAnYmxha2UyYi0zNTInOiAweGIyMmMsXG4gICdibGFrZTJiLTM2MCc6IDB4YjIyZCxcbiAgJ2JsYWtlMmItMzY4JzogMHhiMjJlLFxuICAnYmxha2UyYi0zNzYnOiAweGIyMmYsXG4gICdibGFrZTJiLTM4NCc6IDB4YjIzMCxcbiAgJ2JsYWtlMmItMzkyJzogMHhiMjMxLFxuICAnYmxha2UyYi00MDAnOiAweGIyMzIsXG4gICdibGFrZTJiLTQwOCc6IDB4YjIzMyxcbiAgJ2JsYWtlMmItNDE2JzogMHhiMjM0LFxuICAnYmxha2UyYi00MjQnOiAweGIyMzUsXG4gICdibGFrZTJiLTQzMic6IDB4YjIzNixcbiAgJ2JsYWtlMmItNDQwJzogMHhiMjM3LFxuICAnYmxha2UyYi00NDgnOiAweGIyMzgsXG4gICdibGFrZTJiLTQ1Nic6IDB4YjIzOSxcbiAgJ2JsYWtlMmItNDY0JzogMHhiMjNhLFxuICAnYmxha2UyYi00NzInOiAweGIyM2IsXG4gICdibGFrZTJiLTQ4MCc6IDB4YjIzYyxcbiAgJ2JsYWtlMmItNDg4JzogMHhiMjNkLFxuICAnYmxha2UyYi00OTYnOiAweGIyM2UsXG4gICdibGFrZTJiLTUwNCc6IDB4YjIzZixcbiAgJ2JsYWtlMmItNTEyJzogMHhiMjQwLFxuICAnYmxha2Uycy04JzogMHhiMjQxLFxuICAnYmxha2Uycy0xNic6IDB4YjI0MixcbiAgJ2JsYWtlMnMtMjQnOiAweGIyNDMsXG4gICdibGFrZTJzLTMyJzogMHhiMjQ0LFxuICAnYmxha2Uycy00MCc6IDB4YjI0NSxcbiAgJ2JsYWtlMnMtNDgnOiAweGIyNDYsXG4gICdibGFrZTJzLTU2JzogMHhiMjQ3LFxuICAnYmxha2Uycy02NCc6IDB4YjI0OCxcbiAgJ2JsYWtlMnMtNzInOiAweGIyNDksXG4gICdibGFrZTJzLTgwJzogMHhiMjRhLFxuICAnYmxha2Uycy04OCc6IDB4YjI0YixcbiAgJ2JsYWtlMnMtOTYnOiAweGIyNGMsXG4gICdibGFrZTJzLTEwNCc6IDB4YjI0ZCxcbiAgJ2JsYWtlMnMtMTEyJzogMHhiMjRlLFxuICAnYmxha2Uycy0xMjAnOiAweGIyNGYsXG4gICdibGFrZTJzLTEyOCc6IDB4YjI1MCxcbiAgJ2JsYWtlMnMtMTM2JzogMHhiMjUxLFxuICAnYmxha2Uycy0xNDQnOiAweGIyNTIsXG4gICdibGFrZTJzLTE1Mic6IDB4YjI1MyxcbiAgJ2JsYWtlMnMtMTYwJzogMHhiMjU0LFxuICAnYmxha2Uycy0xNjgnOiAweGIyNTUsXG4gICdibGFrZTJzLTE3Nic6IDB4YjI1NixcbiAgJ2JsYWtlMnMtMTg0JzogMHhiMjU3LFxuICAnYmxha2Uycy0xOTInOiAweGIyNTgsXG4gICdibGFrZTJzLTIwMCc6IDB4YjI1OSxcbiAgJ2JsYWtlMnMtMjA4JzogMHhiMjVhLFxuICAnYmxha2Uycy0yMTYnOiAweGIyNWIsXG4gICdibGFrZTJzLTIyNCc6IDB4YjI1YyxcbiAgJ2JsYWtlMnMtMjMyJzogMHhiMjVkLFxuICAnYmxha2Uycy0yNDAnOiAweGIyNWUsXG4gICdibGFrZTJzLTI0OCc6IDB4YjI1ZixcbiAgJ2JsYWtlMnMtMjU2JzogMHhiMjYwLFxuICAnc2tlaW4yNTYtOCc6IDB4YjMwMSxcbiAgJ3NrZWluMjU2LTE2JzogMHhiMzAyLFxuICAnc2tlaW4yNTYtMjQnOiAweGIzMDMsXG4gICdza2VpbjI1Ni0zMic6IDB4YjMwNCxcbiAgJ3NrZWluMjU2LTQwJzogMHhiMzA1LFxuICAnc2tlaW4yNTYtNDgnOiAweGIzMDYsXG4gICdza2VpbjI1Ni01Nic6IDB4YjMwNyxcbiAgJ3NrZWluMjU2LTY0JzogMHhiMzA4LFxuICAnc2tlaW4yNTYtNzInOiAweGIzMDksXG4gICdza2VpbjI1Ni04MCc6IDB4YjMwYSxcbiAgJ3NrZWluMjU2LTg4JzogMHhiMzBiLFxuICAnc2tlaW4yNTYtOTYnOiAweGIzMGMsXG4gICdza2VpbjI1Ni0xMDQnOiAweGIzMGQsXG4gICdza2VpbjI1Ni0xMTInOiAweGIzMGUsXG4gICdza2VpbjI1Ni0xMjAnOiAweGIzMGYsXG4gICdza2VpbjI1Ni0xMjgnOiAweGIzMTAsXG4gICdza2VpbjI1Ni0xMzYnOiAweGIzMTEsXG4gICdza2VpbjI1Ni0xNDQnOiAweGIzMTIsXG4gICdza2VpbjI1Ni0xNTInOiAweGIzMTMsXG4gICdza2VpbjI1Ni0xNjAnOiAweGIzMTQsXG4gICdza2VpbjI1Ni0xNjgnOiAweGIzMTUsXG4gICdza2VpbjI1Ni0xNzYnOiAweGIzMTYsXG4gICdza2VpbjI1Ni0xODQnOiAweGIzMTcsXG4gICdza2VpbjI1Ni0xOTInOiAweGIzMTgsXG4gICdza2VpbjI1Ni0yMDAnOiAweGIzMTksXG4gICdza2VpbjI1Ni0yMDgnOiAweGIzMWEsXG4gICdza2VpbjI1Ni0yMTYnOiAweGIzMWIsXG4gICdza2VpbjI1Ni0yMjQnOiAweGIzMWMsXG4gICdza2VpbjI1Ni0yMzInOiAweGIzMWQsXG4gICdza2VpbjI1Ni0yNDAnOiAweGIzMWUsXG4gICdza2VpbjI1Ni0yNDgnOiAweGIzMWYsXG4gICdza2VpbjI1Ni0yNTYnOiAweGIzMjAsXG4gICdza2VpbjUxMi04JzogMHhiMzIxLFxuICAnc2tlaW41MTItMTYnOiAweGIzMjIsXG4gICdza2VpbjUxMi0yNCc6IDB4YjMyMyxcbiAgJ3NrZWluNTEyLTMyJzogMHhiMzI0LFxuICAnc2tlaW41MTItNDAnOiAweGIzMjUsXG4gICdza2VpbjUxMi00OCc6IDB4YjMyNixcbiAgJ3NrZWluNTEyLTU2JzogMHhiMzI3LFxuICAnc2tlaW41MTItNjQnOiAweGIzMjgsXG4gICdza2VpbjUxMi03Mic6IDB4YjMyOSxcbiAgJ3NrZWluNTEyLTgwJzogMHhiMzJhLFxuICAnc2tlaW41MTItODgnOiAweGIzMmIsXG4gICdza2VpbjUxMi05Nic6IDB4YjMyYyxcbiAgJ3NrZWluNTEyLTEwNCc6IDB4YjMyZCxcbiAgJ3NrZWluNTEyLTExMic6IDB4YjMyZSxcbiAgJ3NrZWluNTEyLTEyMCc6IDB4YjMyZixcbiAgJ3NrZWluNTEyLTEyOCc6IDB4YjMzMCxcbiAgJ3NrZWluNTEyLTEzNic6IDB4YjMzMSxcbiAgJ3NrZWluNTEyLTE0NCc6IDB4YjMzMixcbiAgJ3NrZWluNTEyLTE1Mic6IDB4YjMzMyxcbiAgJ3NrZWluNTEyLTE2MCc6IDB4YjMzNCxcbiAgJ3NrZWluNTEyLTE2OCc6IDB4YjMzNSxcbiAgJ3NrZWluNTEyLTE3Nic6IDB4YjMzNixcbiAgJ3NrZWluNTEyLTE4NCc6IDB4YjMzNyxcbiAgJ3NrZWluNTEyLTE5Mic6IDB4YjMzOCxcbiAgJ3NrZWluNTEyLTIwMCc6IDB4YjMzOSxcbiAgJ3NrZWluNTEyLTIwOCc6IDB4YjMzYSxcbiAgJ3NrZWluNTEyLTIxNic6IDB4YjMzYixcbiAgJ3NrZWluNTEyLTIyNCc6IDB4YjMzYyxcbiAgJ3NrZWluNTEyLTIzMic6IDB4YjMzZCxcbiAgJ3NrZWluNTEyLTI0MCc6IDB4YjMzZSxcbiAgJ3NrZWluNTEyLTI0OCc6IDB4YjMzZixcbiAgJ3NrZWluNTEyLTI1Nic6IDB4YjM0MCxcbiAgJ3NrZWluNTEyLTI2NCc6IDB4YjM0MSxcbiAgJ3NrZWluNTEyLTI3Mic6IDB4YjM0MixcbiAgJ3NrZWluNTEyLTI4MCc6IDB4YjM0MyxcbiAgJ3NrZWluNTEyLTI4OCc6IDB4YjM0NCxcbiAgJ3NrZWluNTEyLTI5Nic6IDB4YjM0NSxcbiAgJ3NrZWluNTEyLTMwNCc6IDB4YjM0NixcbiAgJ3NrZWluNTEyLTMxMic6IDB4YjM0NyxcbiAgJ3NrZWluNTEyLTMyMCc6IDB4YjM0OCxcbiAgJ3NrZWluNTEyLTMyOCc6IDB4YjM0OSxcbiAgJ3NrZWluNTEyLTMzNic6IDB4YjM0YSxcbiAgJ3NrZWluNTEyLTM0NCc6IDB4YjM0YixcbiAgJ3NrZWluNTEyLTM1Mic6IDB4YjM0YyxcbiAgJ3NrZWluNTEyLTM2MCc6IDB4YjM0ZCxcbiAgJ3NrZWluNTEyLTM2OCc6IDB4YjM0ZSxcbiAgJ3NrZWluNTEyLTM3Nic6IDB4YjM0ZixcbiAgJ3NrZWluNTEyLTM4NCc6IDB4YjM1MCxcbiAgJ3NrZWluNTEyLTM5Mic6IDB4YjM1MSxcbiAgJ3NrZWluNTEyLTQwMCc6IDB4YjM1MixcbiAgJ3NrZWluNTEyLTQwOCc6IDB4YjM1MyxcbiAgJ3NrZWluNTEyLTQxNic6IDB4YjM1NCxcbiAgJ3NrZWluNTEyLTQyNCc6IDB4YjM1NSxcbiAgJ3NrZWluNTEyLTQzMic6IDB4YjM1NixcbiAgJ3NrZWluNTEyLTQ0MCc6IDB4YjM1NyxcbiAgJ3NrZWluNTEyLTQ0OCc6IDB4YjM1OCxcbiAgJ3NrZWluNTEyLTQ1Nic6IDB4YjM1OSxcbiAgJ3NrZWluNTEyLTQ2NCc6IDB4YjM1YSxcbiAgJ3NrZWluNTEyLTQ3Mic6IDB4YjM1YixcbiAgJ3NrZWluNTEyLTQ4MCc6IDB4YjM1YyxcbiAgJ3NrZWluNTEyLTQ4OCc6IDB4YjM1ZCxcbiAgJ3NrZWluNTEyLTQ5Nic6IDB4YjM1ZSxcbiAgJ3NrZWluNTEyLTUwNCc6IDB4YjM1ZixcbiAgJ3NrZWluNTEyLTUxMic6IDB4YjM2MCxcbiAgJ3NrZWluMTAyNC04JzogMHhiMzYxLFxuICAnc2tlaW4xMDI0LTE2JzogMHhiMzYyLFxuICAnc2tlaW4xMDI0LTI0JzogMHhiMzYzLFxuICAnc2tlaW4xMDI0LTMyJzogMHhiMzY0LFxuICAnc2tlaW4xMDI0LTQwJzogMHhiMzY1LFxuICAnc2tlaW4xMDI0LTQ4JzogMHhiMzY2LFxuICAnc2tlaW4xMDI0LTU2JzogMHhiMzY3LFxuICAnc2tlaW4xMDI0LTY0JzogMHhiMzY4LFxuICAnc2tlaW4xMDI0LTcyJzogMHhiMzY5LFxuICAnc2tlaW4xMDI0LTgwJzogMHhiMzZhLFxuICAnc2tlaW4xMDI0LTg4JzogMHhiMzZiLFxuICAnc2tlaW4xMDI0LTk2JzogMHhiMzZjLFxuICAnc2tlaW4xMDI0LTEwNCc6IDB4YjM2ZCxcbiAgJ3NrZWluMTAyNC0xMTInOiAweGIzNmUsXG4gICdza2VpbjEwMjQtMTIwJzogMHhiMzZmLFxuICAnc2tlaW4xMDI0LTEyOCc6IDB4YjM3MCxcbiAgJ3NrZWluMTAyNC0xMzYnOiAweGIzNzEsXG4gICdza2VpbjEwMjQtMTQ0JzogMHhiMzcyLFxuICAnc2tlaW4xMDI0LTE1Mic6IDB4YjM3MyxcbiAgJ3NrZWluMTAyNC0xNjAnOiAweGIzNzQsXG4gICdza2VpbjEwMjQtMTY4JzogMHhiMzc1LFxuICAnc2tlaW4xMDI0LTE3Nic6IDB4YjM3NixcbiAgJ3NrZWluMTAyNC0xODQnOiAweGIzNzcsXG4gICdza2VpbjEwMjQtMTkyJzogMHhiMzc4LFxuICAnc2tlaW4xMDI0LTIwMCc6IDB4YjM3OSxcbiAgJ3NrZWluMTAyNC0yMDgnOiAweGIzN2EsXG4gICdza2VpbjEwMjQtMjE2JzogMHhiMzdiLFxuICAnc2tlaW4xMDI0LTIyNCc6IDB4YjM3YyxcbiAgJ3NrZWluMTAyNC0yMzInOiAweGIzN2QsXG4gICdza2VpbjEwMjQtMjQwJzogMHhiMzdlLFxuICAnc2tlaW4xMDI0LTI0OCc6IDB4YjM3ZixcbiAgJ3NrZWluMTAyNC0yNTYnOiAweGIzODAsXG4gICdza2VpbjEwMjQtMjY0JzogMHhiMzgxLFxuICAnc2tlaW4xMDI0LTI3Mic6IDB4YjM4MixcbiAgJ3NrZWluMTAyNC0yODAnOiAweGIzODMsXG4gICdza2VpbjEwMjQtMjg4JzogMHhiMzg0LFxuICAnc2tlaW4xMDI0LTI5Nic6IDB4YjM4NSxcbiAgJ3NrZWluMTAyNC0zMDQnOiAweGIzODYsXG4gICdza2VpbjEwMjQtMzEyJzogMHhiMzg3LFxuICAnc2tlaW4xMDI0LTMyMCc6IDB4YjM4OCxcbiAgJ3NrZWluMTAyNC0zMjgnOiAweGIzODksXG4gICdza2VpbjEwMjQtMzM2JzogMHhiMzhhLFxuICAnc2tlaW4xMDI0LTM0NCc6IDB4YjM4YixcbiAgJ3NrZWluMTAyNC0zNTInOiAweGIzOGMsXG4gICdza2VpbjEwMjQtMzYwJzogMHhiMzhkLFxuICAnc2tlaW4xMDI0LTM2OCc6IDB4YjM4ZSxcbiAgJ3NrZWluMTAyNC0zNzYnOiAweGIzOGYsXG4gICdza2VpbjEwMjQtMzg0JzogMHhiMzkwLFxuICAnc2tlaW4xMDI0LTM5Mic6IDB4YjM5MSxcbiAgJ3NrZWluMTAyNC00MDAnOiAweGIzOTIsXG4gICdza2VpbjEwMjQtNDA4JzogMHhiMzkzLFxuICAnc2tlaW4xMDI0LTQxNic6IDB4YjM5NCxcbiAgJ3NrZWluMTAyNC00MjQnOiAweGIzOTUsXG4gICdza2VpbjEwMjQtNDMyJzogMHhiMzk2LFxuICAnc2tlaW4xMDI0LTQ0MCc6IDB4YjM5NyxcbiAgJ3NrZWluMTAyNC00NDgnOiAweGIzOTgsXG4gICdza2VpbjEwMjQtNDU2JzogMHhiMzk5LFxuICAnc2tlaW4xMDI0LTQ2NCc6IDB4YjM5YSxcbiAgJ3NrZWluMTAyNC00NzInOiAweGIzOWIsXG4gICdza2VpbjEwMjQtNDgwJzogMHhiMzljLFxuICAnc2tlaW4xMDI0LTQ4OCc6IDB4YjM5ZCxcbiAgJ3NrZWluMTAyNC00OTYnOiAweGIzOWUsXG4gICdza2VpbjEwMjQtNTA0JzogMHhiMzlmLFxuICAnc2tlaW4xMDI0LTUxMic6IDB4YjNhMCxcbiAgJ3NrZWluMTAyNC01MjAnOiAweGIzYTEsXG4gICdza2VpbjEwMjQtNTI4JzogMHhiM2EyLFxuICAnc2tlaW4xMDI0LTUzNic6IDB4YjNhMyxcbiAgJ3NrZWluMTAyNC01NDQnOiAweGIzYTQsXG4gICdza2VpbjEwMjQtNTUyJzogMHhiM2E1LFxuICAnc2tlaW4xMDI0LTU2MCc6IDB4YjNhNixcbiAgJ3NrZWluMTAyNC01NjgnOiAweGIzYTcsXG4gICdza2VpbjEwMjQtNTc2JzogMHhiM2E4LFxuICAnc2tlaW4xMDI0LTU4NCc6IDB4YjNhOSxcbiAgJ3NrZWluMTAyNC01OTInOiAweGIzYWEsXG4gICdza2VpbjEwMjQtNjAwJzogMHhiM2FiLFxuICAnc2tlaW4xMDI0LTYwOCc6IDB4YjNhYyxcbiAgJ3NrZWluMTAyNC02MTYnOiAweGIzYWQsXG4gICdza2VpbjEwMjQtNjI0JzogMHhiM2FlLFxuICAnc2tlaW4xMDI0LTYzMic6IDB4YjNhZixcbiAgJ3NrZWluMTAyNC02NDAnOiAweGIzYjAsXG4gICdza2VpbjEwMjQtNjQ4JzogMHhiM2IxLFxuICAnc2tlaW4xMDI0LTY1Nic6IDB4YjNiMixcbiAgJ3NrZWluMTAyNC02NjQnOiAweGIzYjMsXG4gICdza2VpbjEwMjQtNjcyJzogMHhiM2I0LFxuICAnc2tlaW4xMDI0LTY4MCc6IDB4YjNiNSxcbiAgJ3NrZWluMTAyNC02ODgnOiAweGIzYjYsXG4gICdza2VpbjEwMjQtNjk2JzogMHhiM2I3LFxuICAnc2tlaW4xMDI0LTcwNCc6IDB4YjNiOCxcbiAgJ3NrZWluMTAyNC03MTInOiAweGIzYjksXG4gICdza2VpbjEwMjQtNzIwJzogMHhiM2JhLFxuICAnc2tlaW4xMDI0LTcyOCc6IDB4YjNiYixcbiAgJ3NrZWluMTAyNC03MzYnOiAweGIzYmMsXG4gICdza2VpbjEwMjQtNzQ0JzogMHhiM2JkLFxuICAnc2tlaW4xMDI0LTc1Mic6IDB4YjNiZSxcbiAgJ3NrZWluMTAyNC03NjAnOiAweGIzYmYsXG4gICdza2VpbjEwMjQtNzY4JzogMHhiM2MwLFxuICAnc2tlaW4xMDI0LTc3Nic6IDB4YjNjMSxcbiAgJ3NrZWluMTAyNC03ODQnOiAweGIzYzIsXG4gICdza2VpbjEwMjQtNzkyJzogMHhiM2MzLFxuICAnc2tlaW4xMDI0LTgwMCc6IDB4YjNjNCxcbiAgJ3NrZWluMTAyNC04MDgnOiAweGIzYzUsXG4gICdza2VpbjEwMjQtODE2JzogMHhiM2M2LFxuICAnc2tlaW4xMDI0LTgyNCc6IDB4YjNjNyxcbiAgJ3NrZWluMTAyNC04MzInOiAweGIzYzgsXG4gICdza2VpbjEwMjQtODQwJzogMHhiM2M5LFxuICAnc2tlaW4xMDI0LTg0OCc6IDB4YjNjYSxcbiAgJ3NrZWluMTAyNC04NTYnOiAweGIzY2IsXG4gICdza2VpbjEwMjQtODY0JzogMHhiM2NjLFxuICAnc2tlaW4xMDI0LTg3Mic6IDB4YjNjZCxcbiAgJ3NrZWluMTAyNC04ODAnOiAweGIzY2UsXG4gICdza2VpbjEwMjQtODg4JzogMHhiM2NmLFxuICAnc2tlaW4xMDI0LTg5Nic6IDB4YjNkMCxcbiAgJ3NrZWluMTAyNC05MDQnOiAweGIzZDEsXG4gICdza2VpbjEwMjQtOTEyJzogMHhiM2QyLFxuICAnc2tlaW4xMDI0LTkyMCc6IDB4YjNkMyxcbiAgJ3NrZWluMTAyNC05MjgnOiAweGIzZDQsXG4gICdza2VpbjEwMjQtOTM2JzogMHhiM2Q1LFxuICAnc2tlaW4xMDI0LTk0NCc6IDB4YjNkNixcbiAgJ3NrZWluMTAyNC05NTInOiAweGIzZDcsXG4gICdza2VpbjEwMjQtOTYwJzogMHhiM2Q4LFxuICAnc2tlaW4xMDI0LTk2OCc6IDB4YjNkOSxcbiAgJ3NrZWluMTAyNC05NzYnOiAweGIzZGEsXG4gICdza2VpbjEwMjQtOTg0JzogMHhiM2RiLFxuICAnc2tlaW4xMDI0LTk5Mic6IDB4YjNkYyxcbiAgJ3NrZWluMTAyNC0xMDAwJzogMHhiM2RkLFxuICAnc2tlaW4xMDI0LTEwMDgnOiAweGIzZGUsXG4gICdza2VpbjEwMjQtMTAxNic6IDB4YjNkZixcbiAgJ3NrZWluMTAyNC0xMDI0JzogMHhiM2UwLFxuICAncG9zZWlkb24tYmxzMTJfMzgxLWEyLWZjMSc6IDB4YjQwMSxcbiAgJ3Bvc2VpZG9uLWJsczEyXzM4MS1hMi1mYzEtc2MnOiAweGI0MDIsXG4gICd6ZXJveGNlcnQtaW1wcmludC0yNTYnOiAweGNlMTEsXG4gICdmaWwtY29tbWl0bWVudC11bnNlYWxlZCc6IDB4ZjEwMSxcbiAgJ2ZpbC1jb21taXRtZW50LXNlYWxlZCc6IDB4ZjEwMixcbiAgJ2hvbG9jaGFpbi1hZHItdjAnOiAweDgwNzEyNCxcbiAgJ2hvbG9jaGFpbi1hZHItdjEnOiAweDgxNzEyNCxcbiAgJ2hvbG9jaGFpbi1rZXktdjAnOiAweDk0NzEyNCxcbiAgJ2hvbG9jaGFpbi1rZXktdjEnOiAweDk1NzEyNCxcbiAgJ2hvbG9jaGFpbi1zaWctdjAnOiAweGEyNzEyNCxcbiAgJ2hvbG9jaGFpbi1zaWctdjEnOiAweGEzNzEyNCxcbiAgJ3NreW5ldC1ucyc6IDB4YjE5OTEwXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgYmFzZVRhYmxlIH1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuQ29uc3RhbnROdW1iZXJNYXB9IENvbnN0YW50TnVtYmVyTWFwICovXG5cbmNvbnN0IHsgYmFzZVRhYmxlIH0gPSByZXF1aXJlKCcuL2Jhc2UtdGFibGUnKVxuXG5jb25zdCBjb25zdGFudHMgPSAvKiogQHR5cGUge0NvbnN0YW50TnVtYmVyTWFwfSAqLyh7fSlcblxuZm9yIChjb25zdCBbbmFtZSwgY29kZV0gb2YgT2JqZWN0LmVudHJpZXMoYmFzZVRhYmxlKSkge1xuICBjb25zdCBjb25zdGFudCA9IG5hbWUudG9VcHBlckNhc2UoKS5yZXBsYWNlKC8tL2csICdfJylcbiAgY29uc3RhbnRzW2NvbnN0YW50XSA9IGNvZGVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKGNvbnN0YW50cylcbiIsIi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIG11bHRpY29kZWMgc3BlY2lmaWNhdGlvbi5cbiAqXG4gKiBAbW9kdWxlIG11bHRpY29kZWNcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBtdWx0aWNvZGVjID0gcmVxdWlyZSgnbXVsdGljb2RlYycpXG4gKlxuICogY29uc3QgcHJlZml4ZWRQcm90b2J1ZiA9IG11bHRpY29kZWMuYWRkUHJlZml4KCdwcm90b2J1ZicsIHByb3RvYnVmQnVmZmVyKVxuICogLy8gcHJlZml4ZWRQcm90b2J1ZiAweDUwLi4uXG4gKlxuICovXG4ndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2dlbmVyYXRlZC10eXBlcycpLkNvZGVjTmFtZX0gQ29kZWNOYW1lICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuQ29kZWNOdW1iZXJ9IENvZGVjTnVtYmVyICovXG5cbmNvbnN0IHZhcmludCA9IHJlcXVpcmUoJ3ZhcmludCcpXG5jb25zdCBpbnRUYWJsZSA9IHJlcXVpcmUoJy4vaW50LXRhYmxlJylcbmNvbnN0IGNvZGVjTmFtZVRvQ29kZVZhcmludCA9IHJlcXVpcmUoJy4vdmFyaW50LXRhYmxlJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgdWludDhBcnJheUNvbmNhdCA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL2NvbmNhdCcpXG5cbi8qKlxuICogUHJlZml4IGEgYnVmZmVyIHdpdGggYSBtdWx0aWNvZGVjLXBhY2tlZC5cbiAqXG4gKiBAcGFyYW0ge0NvZGVjTmFtZXxVaW50OEFycmF5fSBtdWx0aWNvZGVjU3RyT3JDb2RlXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGFcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBhZGRQcmVmaXggKG11bHRpY29kZWNTdHJPckNvZGUsIGRhdGEpIHtcbiAgbGV0IHByZWZpeFxuXG4gIGlmIChtdWx0aWNvZGVjU3RyT3JDb2RlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHByZWZpeCA9IHV0aWwudmFyaW50VWludDhBcnJheUVuY29kZShtdWx0aWNvZGVjU3RyT3JDb2RlKVxuICB9IGVsc2Uge1xuICAgIGlmIChjb2RlY05hbWVUb0NvZGVWYXJpbnRbbXVsdGljb2RlY1N0ck9yQ29kZV0pIHtcbiAgICAgIHByZWZpeCA9IGNvZGVjTmFtZVRvQ29kZVZhcmludFttdWx0aWNvZGVjU3RyT3JDb2RlXVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpY29kZWMgbm90IHJlY29nbml6ZWQnKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdWludDhBcnJheUNvbmNhdChbcHJlZml4LCBkYXRhXSwgcHJlZml4Lmxlbmd0aCArIGRhdGEubGVuZ3RoKVxufVxuXG4vKipcbiAqIERlY2Fwc3VsYXRlIHRoZSBtdWx0aWNvZGVjLXBhY2tlZCBwcmVmaXggZnJvbSB0aGUgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGFcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBybVByZWZpeCAoZGF0YSkge1xuICB2YXJpbnQuZGVjb2RlKGRhdGEpXG4gIHJldHVybiBkYXRhLnNsaWNlKHZhcmludC5kZWNvZGUuYnl0ZXMpXG59XG5cbi8qKlxuICogR2V0IHRoZSBjb2RlYyBvZiB0aGUgcHJlZml4ZWQgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHByZWZpeGVkRGF0YVxuICogQHJldHVybnMge0NvZGVjTmFtZX1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29kZWMgKHByZWZpeGVkRGF0YSkge1xuICBjb25zdCBjb2RlID0gdmFyaW50LmRlY29kZShwcmVmaXhlZERhdGEpXG4gIGNvbnN0IGNvZGVjTmFtZSA9IGludFRhYmxlLmdldChjb2RlKVxuICBpZiAoY29kZWNOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGUgJHtjb2RlfSBub3QgZm91bmRgKVxuICB9XG4gIHJldHVybiBjb2RlY05hbWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5hbWUgb2YgdGhlIGNvZGVjLlxuICpcbiAqIEBwYXJhbSB7Q29kZWNOdW1iZXJ9IGNvZGVjXG4gKiBAcmV0dXJucyB7Q29kZWNOYW1lfHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gZ2V0TmFtZSAoY29kZWMpIHtcbiAgcmV0dXJuIGludFRhYmxlLmdldChjb2RlYylcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGUgb2YgdGhlIGNvZGVjXG4gKlxuICogQHBhcmFtIHtDb2RlY05hbWV9IG5hbWVcbiAqIEByZXR1cm5zIHtDb2RlY051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0TnVtYmVyIChuYW1lKSB7XG4gIGNvbnN0IGNvZGUgPSBjb2RlY05hbWVUb0NvZGVWYXJpbnRbbmFtZV1cbiAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29kZWMgYCcgKyBuYW1lICsgJ2Agbm90IGZvdW5kJylcbiAgfVxuICByZXR1cm4gdmFyaW50LmRlY29kZShjb2RlKVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29kZSBvZiB0aGUgcHJlZml4ZWQgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHByZWZpeGVkRGF0YVxuICogQHJldHVybnMge0NvZGVjTnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRDb2RlIChwcmVmaXhlZERhdGEpIHtcbiAgcmV0dXJuIHZhcmludC5kZWNvZGUocHJlZml4ZWREYXRhKVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29kZSBhcyB2YXJpbnQgb2YgYSBjb2RlYyBuYW1lLlxuICpcbiAqIEBwYXJhbSB7Q29kZWNOYW1lfSBjb2RlY05hbWVcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBnZXRDb2RlVmFyaW50IChjb2RlY05hbWUpIHtcbiAgY29uc3QgY29kZSA9IGNvZGVjTmFtZVRvQ29kZVZhcmludFtjb2RlY05hbWVdXG4gIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVjIGAnICsgY29kZWNOYW1lICsgJ2Agbm90IGZvdW5kJylcbiAgfVxuICByZXR1cm4gY29kZVxufVxuXG4vKipcbiAqIEdldCB0aGUgdmFyaW50IG9mIGEgY29kZS5cbiAqXG4gKiBAcGFyYW0ge0NvZGVjTnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59XG4gKi9cbmZ1bmN0aW9uIGdldFZhcmludCAoY29kZSkge1xuICByZXR1cm4gdmFyaW50LmVuY29kZShjb2RlKVxufVxuXG4vLyBNYWtlIHRoZSBjb25zdGFudHMgdG9wLWxldmVsIGNvbnN0YW50c1xuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuXG4vLyBIdW1hbiBmcmllbmRseSBuYW1lcyBmb3IgcHJpbnRpbmcsIGUuZy4gaW4gZXJyb3IgbWVzc2FnZXNcbmNvbnN0IHByaW50ID0gcmVxdWlyZSgnLi9wcmludCcpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGRQcmVmaXgsXG4gIHJtUHJlZml4LFxuICBnZXRDb2RlYyxcbiAgZ2V0TmFtZSxcbiAgZ2V0TnVtYmVyLFxuICBnZXRDb2RlLFxuICBnZXRDb2RlVmFyaW50LFxuICBnZXRWYXJpbnQsXG4gIHByaW50LFxuICAuLi5jb25zdGFudHNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuQ29kZWNOYW1lfSBDb2RlY05hbWUgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5Db2RlY051bWJlcn0gQ29kZWNOdW1iZXIgKi9cblxuY29uc3QgeyBiYXNlVGFibGUgfSA9IHJlcXVpcmUoJy4vYmFzZS10YWJsZScpXG5cbi8qKlxuICogQHR5cGUge01hcDxDb2RlY051bWJlcixDb2RlY05hbWU+fVxuICovXG5jb25zdCBuYW1lVGFibGUgPSBuZXcgTWFwKClcblxuZm9yIChjb25zdCBlbmNvZGluZ05hbWUgaW4gYmFzZVRhYmxlKSB7XG4gIGNvbnN0IGNvZGUgPSBiYXNlVGFibGVbZW5jb2RpbmdOYW1lXVxuICBuYW1lVGFibGUuc2V0KGNvZGUsIC8qKiBAdHlwZSB7Q29kZWNOYW1lfSAqLyhlbmNvZGluZ05hbWUpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5mcmVlemUobmFtZVRhYmxlKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5Db2RlY05hbWV9IENvZGVjTmFtZSAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2dlbmVyYXRlZC10eXBlcycpLk51bWJlck5hbWVNYXB9IE51bWJlck5hbWVNYXAgKi9cblxuY29uc3QgeyBiYXNlVGFibGUgfSA9IHJlcXVpcmUoJy4vYmFzZS10YWJsZScpXG5cbmNvbnN0IHRhYmxlQnlDb2RlID0gLyoqIEB0eXBlIHtOdW1iZXJOYW1lTWFwfSAqLyh7fSlcblxuZm9yIChjb25zdCBbbmFtZSwgY29kZV0gb2YgT2JqZWN0LmVudHJpZXMoYmFzZVRhYmxlKSkge1xuICBpZiAodGFibGVCeUNvZGVbY29kZV0gPT09IHVuZGVmaW5lZCkge1xuICAgIHRhYmxlQnlDb2RlW2NvZGVdID0gLyoqIEB0eXBlIHtDb2RlY05hbWV9ICoqLyhuYW1lKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gLyoqIEB0eXBlIHtOdW1iZXJOYW1lTWFwfSAqLyhPYmplY3QuZnJlZXplKHRhYmxlQnlDb2RlKSlcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuY29uc3QgdWludDhBcnJheVRvU3RyaW5nID0gcmVxdWlyZSgndWludDhhcnJheXMvdG8tc3RyaW5nJylcbmNvbnN0IHVpbnQ4QXJyYXlGcm9tU3RyaW5nID0gcmVxdWlyZSgndWludDhhcnJheXMvZnJvbS1zdHJpbmcnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbnVtYmVyVG9VaW50OEFycmF5LFxuICB1aW50OEFycmF5VG9OdW1iZXIsXG4gIHZhcmludFVpbnQ4QXJyYXlFbmNvZGUsXG4gIHZhcmludEVuY29kZVxufVxuXG5mdW5jdGlvbiB1aW50OEFycmF5VG9OdW1iZXIgKGJ1Zikge1xuICByZXR1cm4gcGFyc2VJbnQodWludDhBcnJheVRvU3RyaW5nKGJ1ZiwgJ2Jhc2UxNicpLCAxNilcbn1cblxuZnVuY3Rpb24gbnVtYmVyVG9VaW50OEFycmF5IChudW0pIHtcbiAgbGV0IGhleFN0cmluZyA9IG51bS50b1N0cmluZygxNilcbiAgaWYgKGhleFN0cmluZy5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgaGV4U3RyaW5nID0gJzAnICsgaGV4U3RyaW5nXG4gIH1cbiAgcmV0dXJuIHVpbnQ4QXJyYXlGcm9tU3RyaW5nKGhleFN0cmluZywgJ2Jhc2UxNicpXG59XG5cbmZ1bmN0aW9uIHZhcmludFVpbnQ4QXJyYXlFbmNvZGUgKGlucHV0KSB7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20odmFyaW50LmVuY29kZSh1aW50OEFycmF5VG9OdW1iZXIoaW5wdXQpKSlcbn1cblxuZnVuY3Rpb24gdmFyaW50RW5jb2RlIChudW0pIHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbSh2YXJpbnQuZW5jb2RlKG51bSkpXG59XG4iLCIndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2dlbmVyYXRlZC10eXBlcycpLk5hbWVVaW50OEFycmF5TWFwfSBOYW1lVWludDhBcnJheU1hcCAqL1xuXG5jb25zdCB7IGJhc2VUYWJsZSB9ID0gcmVxdWlyZSgnLi9iYXNlLXRhYmxlJylcbmNvbnN0IHZhcmludEVuY29kZSA9IHJlcXVpcmUoJy4vdXRpbCcpLnZhcmludEVuY29kZVxuXG5jb25zdCB2YXJpbnRUYWJsZSA9IC8qKiBAdHlwZSB7TmFtZVVpbnQ4QXJyYXlNYXB9ICovICh7fSlcblxuZm9yIChjb25zdCBlbmNvZGluZ05hbWUgaW4gYmFzZVRhYmxlKSB7XG4gIGNvbnN0IGNvZGUgPSBiYXNlVGFibGVbZW5jb2RpbmdOYW1lXVxuICB2YXJpbnRUYWJsZVtlbmNvZGluZ05hbWVdID0gdmFyaW50RW5jb2RlKGNvZGUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmZyZWV6ZSh2YXJpbnRUYWJsZSlcbiIsIi8vIEB0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb2RlY1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihVaW50OEFycmF5KTpzdHJpbmd9IGVuY29kZVxuICogQHByb3BlcnR5IHtmdW5jdGlvbihzdHJpbmcpOlVpbnQ4QXJyYXl9IGRlY29kZVxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihzdHJpbmcpOkNvZGVjfSBDb2RlY0ZhY3RvcnlcbiAqL1xuXG5jbGFzcyBCYXNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gICAqIEBwYXJhbSB7Q29kZWNGYWN0b3J5fSBpbXBsZW1lbnRhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWxwaGFiZXRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChuYW1lLCBjb2RlLCBpbXBsZW1lbnRhdGlvbiwgYWxwaGFiZXQpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy5jb2RlID0gY29kZVxuICAgIHRoaXMuY29kZUJ1ZiA9IEJ1ZmZlci5mcm9tKHRoaXMuY29kZSlcbiAgICB0aGlzLmFscGhhYmV0ID0gYWxwaGFiZXRcbiAgICB0aGlzLmVuZ2luZSA9IGltcGxlbWVudGF0aW9uKGFscGhhYmV0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBlbmNvZGUgKGJ1Zikge1xuICAgIHJldHVybiB0aGlzLmVuZ2luZS5lbmNvZGUoYnVmKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAqL1xuICBkZWNvZGUgKHN0cmluZykge1xuICAgIGZvciAoY29uc3QgY2hhciBvZiBzdHJpbmcpIHtcbiAgICAgIGlmICh0aGlzLmFscGhhYmV0ICYmIHRoaXMuYWxwaGFiZXQuaW5kZXhPZihjaGFyKSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGNoYXJhY3RlciAnJHtjaGFyfScgaW4gJyR7c3RyaW5nfSdgKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbmdpbmUuZGVjb2RlKHN0cmluZylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VcbiIsIi8vIEB0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJhc2VYID0gcmVxdWlyZSgnYmFzZS14JylcbmNvbnN0IEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UuanMnKVxuY29uc3QgcmZjNDY0OCA9IHJlcXVpcmUoJy4vcmZjNDY0OCcpXG5jb25zdCB7IGRlY29kZVRleHQsIGVuY29kZVRleHQgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbmNvbnN0IGlkZW50aXR5ID0gKCkgPT4ge1xuICByZXR1cm4ge1xuICAgIGVuY29kZTogZGVjb2RlVGV4dCxcbiAgICBkZWNvZGU6IGVuY29kZVRleHRcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2Jhc2UnKS5Db2RlY0ZhY3Rvcnl9IENvZGVjRmFjdG9yeVxuICpcbiAqIG5hbWUsIGNvZGUsIGltcGxlbWVudGF0aW9uLCBhbHBoYWJldFxuICogQHR5cGUge0FycmF5PFtzdHJpbmcsIHN0cmluZywgQ29kZWNGYWN0b3J5LCBzdHJpbmddPn1cbiAqL1xuY29uc3QgY29uc3RhbnRzID0gW1xuICBbJ2lkZW50aXR5JywgJ1xceDAwJywgaWRlbnRpdHksICcnXSxcbiAgWydiYXNlMicsICcwJywgcmZjNDY0OCgxKSwgJzAxJ10sXG4gIFsnYmFzZTgnLCAnNycsIHJmYzQ2NDgoMyksICcwMTIzNDU2NyddLFxuICBbJ2Jhc2UxMCcsICc5JywgYmFzZVgsICcwMTIzNDU2Nzg5J10sXG4gIFsnYmFzZTE2JywgJ2YnLCByZmM0NjQ4KDQpLCAnMDEyMzQ1Njc4OWFiY2RlZiddLFxuICBbJ2Jhc2UxNnVwcGVyJywgJ0YnLCByZmM0NjQ4KDQpLCAnMDEyMzQ1Njc4OUFCQ0RFRiddLFxuICBbJ2Jhc2UzMmhleCcsICd2JywgcmZjNDY0OCg1KSwgJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2J10sXG4gIFsnYmFzZTMyaGV4dXBwZXInLCAnVicsIHJmYzQ2NDgoNSksICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVViddLFxuICBbJ2Jhc2UzMmhleHBhZCcsICd0JywgcmZjNDY0OCg1KSwgJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2PSddLFxuICBbJ2Jhc2UzMmhleHBhZHVwcGVyJywgJ1QnLCByZmM0NjQ4KDUpLCAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVY9J10sXG4gIFsnYmFzZTMyJywgJ2InLCByZmM0NjQ4KDUpLCAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1NjcnXSxcbiAgWydiYXNlMzJ1cHBlcicsICdCJywgcmZjNDY0OCg1KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3J10sXG4gIFsnYmFzZTMycGFkJywgJ2MnLCByZmM0NjQ4KDUpLCAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1Njc9J10sXG4gIFsnYmFzZTMycGFkdXBwZXInLCAnQycsIHJmYzQ2NDgoNSksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2Nz0nXSxcbiAgWydiYXNlMzJ6JywgJ2gnLCByZmM0NjQ4KDUpLCAneWJuZHJmZzhlamttY3BxeG90MXV3aXN6YTM0NWg3NjknXSxcbiAgWydiYXNlMzYnLCAnaycsIGJhc2VYLCAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6J10sXG4gIFsnYmFzZTM2dXBwZXInLCAnSycsIGJhc2VYLCAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJ10sXG4gIFsnYmFzZTU4YnRjJywgJ3onLCBiYXNlWCwgJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXSxcbiAgWydiYXNlNThmbGlja3InLCAnWicsIGJhc2VYLCAnMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWiddLFxuICBbJ2Jhc2U2NCcsICdtJywgcmZjNDY0OCg2KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXSxcbiAgWydiYXNlNjRwYWQnLCAnTScsIHJmYzQ2NDgoNiksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSddLFxuICBbJ2Jhc2U2NHVybCcsICd1JywgcmZjNDY0OCg2KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nXSxcbiAgWydiYXNlNjR1cmxwYWQnLCAnVScsIHJmYzQ2NDgoNiksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fPSddXG5dXG5cbmNvbnN0IG5hbWVzID0gY29uc3RhbnRzLnJlZHVjZSgocHJldiwgdHVwcGxlKSA9PiB7XG4gIHByZXZbdHVwcGxlWzBdXSA9IG5ldyBCYXNlKHR1cHBsZVswXSwgdHVwcGxlWzFdLCB0dXBwbGVbMl0sIHR1cHBsZVszXSlcbiAgcmV0dXJuIHByZXZcbn0sIHt9KVxuXG5jb25zdCBjb2RlcyA9IGNvbnN0YW50cy5yZWR1Y2UoKHByZXYsIHR1cHBsZSkgPT4ge1xuICBwcmV2W3R1cHBsZVsxXV0gPSBuYW1lc1t0dXBwbGVbMF1dXG4gIHJldHVybiBwcmV2XG59LCB7fSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWVzLFxuICBjb2Rlc1xufVxuIiwiLy8gQHRzLWNoZWNrXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBbbXVsdGliYXNlXShodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL211bHRpYmFzZSkgc3BlY2lmaWNhdGlvbi5cbiAqXG4gKiBAbW9kdWxlIE11bHRpYmFzZVxuICovXG4ndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGRlY29kZVRleHQsIGFzQnVmZmVyIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oXCIuL2Jhc2VcIil9IEJhc2UgKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYnVmZmVyIHdpdGggdGhlIG11bHRpYmFzZSB2YXJpbnQrY29kZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG5hbWVPckNvZGUgLSBUaGUgbXVsdGliYXNlIG5hbWUgb3IgY29kZSBudW1iZXIuXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiAtIFRoZSBkYXRhIHRvIGJlIHByZWZpeGVkIHdpdGggbXVsdGliYXNlLlxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IGlmIHRoZSBlbmNvZGluZyBpcyBub3Qgc3VwcG9ydGVkXG4gKi9cbmZ1bmN0aW9uIG11bHRpYmFzZSAobmFtZU9yQ29kZSwgYnVmKSB7XG4gIGlmICghYnVmKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlcyBhbiBlbmNvZGVkIGJ1ZmZlcicpXG4gIH1cbiAgY29uc3QgeyBuYW1lLCBjb2RlQnVmIH0gPSBlbmNvZGluZyhuYW1lT3JDb2RlKVxuICB2YWxpZEVuY29kZShuYW1lLCBidWYpXG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKGNvZGVCdWYubGVuZ3RoICsgYnVmLmxlbmd0aClcbiAgYnVmZmVyLnNldChjb2RlQnVmLCAwKVxuICBidWZmZXIuc2V0KGJ1ZiwgY29kZUJ1Zi5sZW5ndGgpXG5cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG4vKipcbiAqIEVuY29kZSBkYXRhIHdpdGggdGhlIHNwZWNpZmllZCBiYXNlIGFuZCBhZGQgdGhlIG11bHRpYmFzZSBwcmVmaXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBuYW1lT3JDb2RlIC0gVGhlIG11bHRpYmFzZSBuYW1lIG9yIGNvZGUgbnVtYmVyLlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgLSBUaGUgZGF0YSB0byBiZSBlbmNvZGVkLlxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IGlmIHRoZSBlbmNvZGluZyBpcyBub3Qgc3VwcG9ydGVkXG4gKlxuICovXG5mdW5jdGlvbiBlbmNvZGUgKG5hbWVPckNvZGUsIGJ1Zikge1xuICBjb25zdCBlbmMgPSBlbmNvZGluZyhuYW1lT3JDb2RlKVxuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtlbmMuY29kZUJ1ZiwgQnVmZmVyLmZyb20oZW5jLmVuY29kZShidWYpKV0pXG59XG5cbi8qKlxuICogVGFrZXMgYSBVaW50OEFycmF5IG9yIHN0cmluZyBlbmNvZGVkIHdpdGggbXVsdGliYXNlIGhlYWRlciwgZGVjb2RlcyBpdCBhbmRcbiAqIHJldHVybnMgdGhlIGRlY29kZWQgYnVmZmVyXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fHN0cmluZ30gZGF0YVxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IGlmIHRoZSBlbmNvZGluZyBpcyBub3Qgc3VwcG9ydGVkXG4gKlxuICovXG5mdW5jdGlvbiBkZWNvZGUgKGRhdGEpIHtcbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgIGRhdGEgPSBkZWNvZGVUZXh0KGRhdGEpXG4gIH1cbiAgY29uc3QgcHJlZml4ID0gZGF0YVswXVxuXG4gIC8vIE1ha2UgYWxsIGVuY29kaW5ncyBjYXNlLWluc2Vuc2l0aXZlIGV4Y2VwdCB0aGUgb25lcyB0aGF0IGluY2x1ZGUgdXBwZXIgYW5kIGxvd2VyIGNoYXJzIGluIHRoZSBhbHBoYWJldFxuICBpZiAoWydmJywgJ0YnLCAndicsICdWJywgJ3QnLCAnVCcsICdiJywgJ0InLCAnYycsICdDJywgJ2gnLCAnaycsICdLJ10uaW5jbHVkZXMocHJlZml4KSkge1xuICAgIGRhdGEgPSBkYXRhLnRvTG93ZXJDYXNlKClcbiAgfVxuICBjb25zdCBlbmMgPSBlbmNvZGluZyhkYXRhWzBdKVxuICByZXR1cm4gYXNCdWZmZXIoZW5jLmRlY29kZShkYXRhLnN1YnN0cmluZygxKSkpXG59XG5cbi8qKlxuICogSXMgdGhlIGdpdmVuIGRhdGEgbXVsdGliYXNlIGVuY29kZWQ/XG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fHN0cmluZ30gZGF0YVxuICogQHJldHVybnMge2ZhbHNlfHN0cmluZ31cbiAqL1xuZnVuY3Rpb24gaXNFbmNvZGVkIChkYXRhKSB7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIGRhdGEgPSBkZWNvZGVUZXh0KGRhdGEpXG4gIH1cblxuICAvLyBFbnN1cmUgYnVmT3JTdHJpbmcgaXMgYSBzdHJpbmdcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSAhPT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgZW5jID0gZW5jb2RpbmcoZGF0YVswXSlcbiAgICByZXR1cm4gZW5jLm5hbWVcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBlbmNvZGVkIGRhdGFcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgaWYgdGhlIGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcbiAqL1xuZnVuY3Rpb24gdmFsaWRFbmNvZGUgKG5hbWUsIGJ1Zikge1xuICBjb25zdCBlbmMgPSBlbmNvZGluZyhuYW1lKVxuICBlbmMuZGVjb2RlKGRlY29kZVRleHQoYnVmKSlcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGVuY29kaW5nIGJ5IG5hbWUgb3IgY29kZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbmFtZU9yQ29kZVxuICogQHJldHVybnMge0Jhc2V9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiBlbmNvZGluZyAobmFtZU9yQ29kZSkge1xuICBpZiAoY29uc3RhbnRzLm5hbWVzW25hbWVPckNvZGVdKSB7XG4gICAgcmV0dXJuIGNvbnN0YW50cy5uYW1lc1tuYW1lT3JDb2RlXVxuICB9IGVsc2UgaWYgKGNvbnN0YW50cy5jb2Rlc1tuYW1lT3JDb2RlXSkge1xuICAgIHJldHVybiBjb25zdGFudHMuY29kZXNbbmFtZU9yQ29kZV1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGVuY29kaW5nOiAke25hbWVPckNvZGV9YClcbiAgfVxufVxuXG4vKipcbiAqIEdldCBlbmNvZGluZyBmcm9tIGRhdGFcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xVaW50OEFycmF5fSBkYXRhXG4gKiBAcmV0dXJucyB7QmFzZX1cbiAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IGlmIHRoZSBlbmNvZGluZyBpcyBub3Qgc3VwcG9ydGVkXG4gKi9cbmZ1bmN0aW9uIGVuY29kaW5nRnJvbURhdGEgKGRhdGEpIHtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgZGF0YSA9IGRlY29kZVRleHQoZGF0YSlcbiAgfVxuXG4gIHJldHVybiBlbmNvZGluZyhkYXRhWzBdKVxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBtdWx0aWJhc2VcbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlXG5leHBvcnRzLmRlY29kZSA9IGRlY29kZVxuZXhwb3J0cy5pc0VuY29kZWQgPSBpc0VuY29kZWRcbmV4cG9ydHMuZW5jb2RpbmcgPSBlbmNvZGluZ1xuZXhwb3J0cy5lbmNvZGluZ0Zyb21EYXRhID0gZW5jb2RpbmdGcm9tRGF0YVxuZXhwb3J0cy5uYW1lcyA9IE9iamVjdC5mcmVlemUoY29uc3RhbnRzLm5hbWVzKVxuZXhwb3J0cy5jb2RlcyA9IE9iamVjdC5mcmVlemUoY29uc3RhbnRzLmNvZGVzKVxuIiwiLy8gQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2Jhc2UnKS5Db2RlY0ZhY3Rvcnl9IENvZGVjRmFjdG9yeSAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbHBoYWJldFxuICogQHBhcmFtIHtudW1iZXJ9IGJpdHNQZXJDaGFyXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZGVjb2RlID0gKHN0cmluZywgYWxwaGFiZXQsIGJpdHNQZXJDaGFyKSA9PiB7XG4gIC8vIEJ1aWxkIHRoZSBjaGFyYWN0ZXIgbG9va3VwIHRhYmxlOlxuICBjb25zdCBjb2RlcyA9IHt9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYWxwaGFiZXQubGVuZ3RoOyArK2kpIHtcbiAgICBjb2Rlc1thbHBoYWJldFtpXV0gPSBpXG4gIH1cblxuICAvLyBDb3VudCB0aGUgcGFkZGluZyBieXRlczpcbiAgbGV0IGVuZCA9IHN0cmluZy5sZW5ndGhcbiAgd2hpbGUgKHN0cmluZ1tlbmQgLSAxXSA9PT0gJz0nKSB7XG4gICAgLS1lbmRcbiAgfVxuXG4gIC8vIEFsbG9jYXRlIHRoZSBvdXRwdXQ6XG4gIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KChlbmQgKiBiaXRzUGVyQ2hhciAvIDgpIHwgMClcblxuICAvLyBQYXJzZSB0aGUgZGF0YTpcbiAgbGV0IGJpdHMgPSAwIC8vIE51bWJlciBvZiBiaXRzIGN1cnJlbnRseSBpbiB0aGUgYnVmZmVyXG4gIGxldCBidWZmZXIgPSAwIC8vIEJpdHMgd2FpdGluZyB0byBiZSB3cml0dGVuIG91dCwgTVNCIGZpcnN0XG4gIGxldCB3cml0dGVuID0gMCAvLyBOZXh0IGJ5dGUgdG8gd3JpdGVcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmQ7ICsraSkge1xuICAgIC8vIFJlYWQgb25lIGNoYXJhY3RlciBmcm9tIHRoZSBzdHJpbmc6XG4gICAgY29uc3QgdmFsdWUgPSBjb2Rlc1tzdHJpbmdbaV1dXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgJyArIHN0cmluZ1tpXSlcbiAgICB9XG5cbiAgICAvLyBBcHBlbmQgdGhlIGJpdHMgdG8gdGhlIGJ1ZmZlcjpcbiAgICBidWZmZXIgPSAoYnVmZmVyIDw8IGJpdHNQZXJDaGFyKSB8IHZhbHVlXG4gICAgYml0cyArPSBiaXRzUGVyQ2hhclxuXG4gICAgLy8gV3JpdGUgb3V0IHNvbWUgYml0cyBpZiB0aGUgYnVmZmVyIGhhcyBhIGJ5dGUncyB3b3J0aDpcbiAgICBpZiAoYml0cyA+PSA4KSB7XG4gICAgICBiaXRzIC09IDhcbiAgICAgIG91dFt3cml0dGVuKytdID0gMHhmZiAmIChidWZmZXIgPj4gYml0cylcbiAgICB9XG4gIH1cblxuICAvLyBWZXJpZnkgdGhhdCB3ZSBoYXZlIHJlY2VpdmVkIGp1c3QgZW5vdWdoIGJpdHM6XG4gIGlmIChiaXRzID49IGJpdHNQZXJDaGFyIHx8IDB4ZmYgJiAoYnVmZmVyIDw8ICg4IC0gYml0cykpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBkYXRhJylcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbHBoYWJldFxuICogQHBhcmFtIHtudW1iZXJ9IGJpdHNQZXJDaGFyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBlbmNvZGUgPSAoZGF0YSwgYWxwaGFiZXQsIGJpdHNQZXJDaGFyKSA9PiB7XG4gIGNvbnN0IHBhZCA9IGFscGhhYmV0W2FscGhhYmV0Lmxlbmd0aCAtIDFdID09PSAnPSdcbiAgY29uc3QgbWFzayA9ICgxIDw8IGJpdHNQZXJDaGFyKSAtIDFcbiAgbGV0IG91dCA9ICcnXG5cbiAgbGV0IGJpdHMgPSAwIC8vIE51bWJlciBvZiBiaXRzIGN1cnJlbnRseSBpbiB0aGUgYnVmZmVyXG4gIGxldCBidWZmZXIgPSAwIC8vIEJpdHMgd2FpdGluZyB0byBiZSB3cml0dGVuIG91dCwgTVNCIGZpcnN0XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIC8vIFNsdXJwIGRhdGEgaW50byB0aGUgYnVmZmVyOlxuICAgIGJ1ZmZlciA9IChidWZmZXIgPDwgOCkgfCBkYXRhW2ldXG4gICAgYml0cyArPSA4XG5cbiAgICAvLyBXcml0ZSBvdXQgYXMgbXVjaCBhcyB3ZSBjYW46XG4gICAgd2hpbGUgKGJpdHMgPiBiaXRzUGVyQ2hhcikge1xuICAgICAgYml0cyAtPSBiaXRzUGVyQ2hhclxuICAgICAgb3V0ICs9IGFscGhhYmV0W21hc2sgJiAoYnVmZmVyID4+IGJpdHMpXVxuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnRpYWwgY2hhcmFjdGVyOlxuICBpZiAoYml0cykge1xuICAgIG91dCArPSBhbHBoYWJldFttYXNrICYgKGJ1ZmZlciA8PCAoYml0c1BlckNoYXIgLSBiaXRzKSldXG4gIH1cblxuICAvLyBBZGQgcGFkZGluZyBjaGFyYWN0ZXJzIHVudGlsIHdlIGhpdCBhIGJ5dGUgYm91bmRhcnk6XG4gIGlmIChwYWQpIHtcbiAgICB3aGlsZSAoKG91dC5sZW5ndGggKiBiaXRzUGVyQ2hhcikgJiA3KSB7XG4gICAgICBvdXQgKz0gJz0nXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRzUGVyQ2hhclxuICogQHJldHVybnMge0NvZGVjRmFjdG9yeX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAoYml0c1BlckNoYXIpID0+IChhbHBoYWJldCkgPT4ge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGVuY29kZSAoaW5wdXQpIHtcbiAgICAgIHJldHVybiBlbmNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcilcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIGRlY29kZSAoaW5wdXQpIHtcbiAgICAgIHJldHVybiBkZWNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcilcbiAgICB9XG4gIH1cbn1cbiIsIi8vIEB0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgeyBUZXh0RW5jb2RlciwgVGV4dERlY29kZXIgfSA9IHJlcXVpcmUoJ3dlYi1lbmNvZGluZycpXG5cbmNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbi8qKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd8QXJyYXlCdWZmZXJ9IGJ5dGVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBkZWNvZGVUZXh0ID0gKGJ5dGVzKSA9PiB0ZXh0RGVjb2Rlci5kZWNvZGUoYnl0ZXMpXG5cbmNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBlbmNvZGVUZXh0ID0gKHRleHQpID0+IHRleHRFbmNvZGVyLmVuY29kZSh0ZXh0KVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBieXRlc1xuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuY29uc3QgYXNCdWZmZXIgPSAoeyBidWZmZXIsIGJ5dGVMZW5ndGgsIGJ5dGVPZmZzZXQgfSkgPT5cbiAgQnVmZmVyLmZyb20oYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZGVjb2RlVGV4dCwgZW5jb2RlVGV4dCwgYXNCdWZmZXIgfVxuIiwiLyogZXNsaW50IHF1b3RlLXByb3BzOiBvZmYgKi9cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBuYW1lcyA9IE9iamVjdC5mcmVlemUoe1xuICAnaWRlbnRpdHknOiAweDAwLFxuICAnc2hhMSc6IDB4MTEsXG4gICdzaGEyLTI1Nic6IDB4MTIsXG4gICdzaGEyLTUxMic6IDB4MTMsXG4gICdzaGEzLTUxMic6IDB4MTQsXG4gICdzaGEzLTM4NCc6IDB4MTUsXG4gICdzaGEzLTI1Nic6IDB4MTYsXG4gICdzaGEzLTIyNCc6IDB4MTcsXG4gICdzaGFrZS0xMjgnOiAweDE4LFxuICAnc2hha2UtMjU2JzogMHgxOSxcbiAgJ2tlY2Nhay0yMjQnOiAweDFhLFxuICAna2VjY2FrLTI1Nic6IDB4MWIsXG4gICdrZWNjYWstMzg0JzogMHgxYyxcbiAgJ2tlY2Nhay01MTInOiAweDFkLFxuICAnYmxha2UzJzogMHgxZSxcbiAgJ211cm11cjMtMTI4JzogMHgyMixcbiAgJ211cm11cjMtMzInOiAweDIzLFxuICAnZGJsLXNoYTItMjU2JzogMHg1NixcbiAgJ21kNCc6IDB4ZDQsXG4gICdtZDUnOiAweGQ1LFxuICAnYm10JzogMHhkNixcbiAgJ3NoYTItMjU2LXRydW5jMjU0LXBhZGRlZCc6IDB4MTAxMixcbiAgJ3JpcGVtZC0xMjgnOiAweDEwNTIsXG4gICdyaXBlbWQtMTYwJzogMHgxMDUzLFxuICAncmlwZW1kLTI1Nic6IDB4MTA1NCxcbiAgJ3JpcGVtZC0zMjAnOiAweDEwNTUsXG4gICd4MTEnOiAweDExMDAsXG4gICdzbTMtMjU2JzogMHg1MzRkLFxuICAnYmxha2UyYi04JzogMHhiMjAxLFxuICAnYmxha2UyYi0xNic6IDB4YjIwMixcbiAgJ2JsYWtlMmItMjQnOiAweGIyMDMsXG4gICdibGFrZTJiLTMyJzogMHhiMjA0LFxuICAnYmxha2UyYi00MCc6IDB4YjIwNSxcbiAgJ2JsYWtlMmItNDgnOiAweGIyMDYsXG4gICdibGFrZTJiLTU2JzogMHhiMjA3LFxuICAnYmxha2UyYi02NCc6IDB4YjIwOCxcbiAgJ2JsYWtlMmItNzInOiAweGIyMDksXG4gICdibGFrZTJiLTgwJzogMHhiMjBhLFxuICAnYmxha2UyYi04OCc6IDB4YjIwYixcbiAgJ2JsYWtlMmItOTYnOiAweGIyMGMsXG4gICdibGFrZTJiLTEwNCc6IDB4YjIwZCxcbiAgJ2JsYWtlMmItMTEyJzogMHhiMjBlLFxuICAnYmxha2UyYi0xMjAnOiAweGIyMGYsXG4gICdibGFrZTJiLTEyOCc6IDB4YjIxMCxcbiAgJ2JsYWtlMmItMTM2JzogMHhiMjExLFxuICAnYmxha2UyYi0xNDQnOiAweGIyMTIsXG4gICdibGFrZTJiLTE1Mic6IDB4YjIxMyxcbiAgJ2JsYWtlMmItMTYwJzogMHhiMjE0LFxuICAnYmxha2UyYi0xNjgnOiAweGIyMTUsXG4gICdibGFrZTJiLTE3Nic6IDB4YjIxNixcbiAgJ2JsYWtlMmItMTg0JzogMHhiMjE3LFxuICAnYmxha2UyYi0xOTInOiAweGIyMTgsXG4gICdibGFrZTJiLTIwMCc6IDB4YjIxOSxcbiAgJ2JsYWtlMmItMjA4JzogMHhiMjFhLFxuICAnYmxha2UyYi0yMTYnOiAweGIyMWIsXG4gICdibGFrZTJiLTIyNCc6IDB4YjIxYyxcbiAgJ2JsYWtlMmItMjMyJzogMHhiMjFkLFxuICAnYmxha2UyYi0yNDAnOiAweGIyMWUsXG4gICdibGFrZTJiLTI0OCc6IDB4YjIxZixcbiAgJ2JsYWtlMmItMjU2JzogMHhiMjIwLFxuICAnYmxha2UyYi0yNjQnOiAweGIyMjEsXG4gICdibGFrZTJiLTI3Mic6IDB4YjIyMixcbiAgJ2JsYWtlMmItMjgwJzogMHhiMjIzLFxuICAnYmxha2UyYi0yODgnOiAweGIyMjQsXG4gICdibGFrZTJiLTI5Nic6IDB4YjIyNSxcbiAgJ2JsYWtlMmItMzA0JzogMHhiMjI2LFxuICAnYmxha2UyYi0zMTInOiAweGIyMjcsXG4gICdibGFrZTJiLTMyMCc6IDB4YjIyOCxcbiAgJ2JsYWtlMmItMzI4JzogMHhiMjI5LFxuICAnYmxha2UyYi0zMzYnOiAweGIyMmEsXG4gICdibGFrZTJiLTM0NCc6IDB4YjIyYixcbiAgJ2JsYWtlMmItMzUyJzogMHhiMjJjLFxuICAnYmxha2UyYi0zNjAnOiAweGIyMmQsXG4gICdibGFrZTJiLTM2OCc6IDB4YjIyZSxcbiAgJ2JsYWtlMmItMzc2JzogMHhiMjJmLFxuICAnYmxha2UyYi0zODQnOiAweGIyMzAsXG4gICdibGFrZTJiLTM5Mic6IDB4YjIzMSxcbiAgJ2JsYWtlMmItNDAwJzogMHhiMjMyLFxuICAnYmxha2UyYi00MDgnOiAweGIyMzMsXG4gICdibGFrZTJiLTQxNic6IDB4YjIzNCxcbiAgJ2JsYWtlMmItNDI0JzogMHhiMjM1LFxuICAnYmxha2UyYi00MzInOiAweGIyMzYsXG4gICdibGFrZTJiLTQ0MCc6IDB4YjIzNyxcbiAgJ2JsYWtlMmItNDQ4JzogMHhiMjM4LFxuICAnYmxha2UyYi00NTYnOiAweGIyMzksXG4gICdibGFrZTJiLTQ2NCc6IDB4YjIzYSxcbiAgJ2JsYWtlMmItNDcyJzogMHhiMjNiLFxuICAnYmxha2UyYi00ODAnOiAweGIyM2MsXG4gICdibGFrZTJiLTQ4OCc6IDB4YjIzZCxcbiAgJ2JsYWtlMmItNDk2JzogMHhiMjNlLFxuICAnYmxha2UyYi01MDQnOiAweGIyM2YsXG4gICdibGFrZTJiLTUxMic6IDB4YjI0MCxcbiAgJ2JsYWtlMnMtOCc6IDB4YjI0MSxcbiAgJ2JsYWtlMnMtMTYnOiAweGIyNDIsXG4gICdibGFrZTJzLTI0JzogMHhiMjQzLFxuICAnYmxha2Uycy0zMic6IDB4YjI0NCxcbiAgJ2JsYWtlMnMtNDAnOiAweGIyNDUsXG4gICdibGFrZTJzLTQ4JzogMHhiMjQ2LFxuICAnYmxha2Uycy01Nic6IDB4YjI0NyxcbiAgJ2JsYWtlMnMtNjQnOiAweGIyNDgsXG4gICdibGFrZTJzLTcyJzogMHhiMjQ5LFxuICAnYmxha2Uycy04MCc6IDB4YjI0YSxcbiAgJ2JsYWtlMnMtODgnOiAweGIyNGIsXG4gICdibGFrZTJzLTk2JzogMHhiMjRjLFxuICAnYmxha2Uycy0xMDQnOiAweGIyNGQsXG4gICdibGFrZTJzLTExMic6IDB4YjI0ZSxcbiAgJ2JsYWtlMnMtMTIwJzogMHhiMjRmLFxuICAnYmxha2Uycy0xMjgnOiAweGIyNTAsXG4gICdibGFrZTJzLTEzNic6IDB4YjI1MSxcbiAgJ2JsYWtlMnMtMTQ0JzogMHhiMjUyLFxuICAnYmxha2Uycy0xNTInOiAweGIyNTMsXG4gICdibGFrZTJzLTE2MCc6IDB4YjI1NCxcbiAgJ2JsYWtlMnMtMTY4JzogMHhiMjU1LFxuICAnYmxha2Uycy0xNzYnOiAweGIyNTYsXG4gICdibGFrZTJzLTE4NCc6IDB4YjI1NyxcbiAgJ2JsYWtlMnMtMTkyJzogMHhiMjU4LFxuICAnYmxha2Uycy0yMDAnOiAweGIyNTksXG4gICdibGFrZTJzLTIwOCc6IDB4YjI1YSxcbiAgJ2JsYWtlMnMtMjE2JzogMHhiMjViLFxuICAnYmxha2Uycy0yMjQnOiAweGIyNWMsXG4gICdibGFrZTJzLTIzMic6IDB4YjI1ZCxcbiAgJ2JsYWtlMnMtMjQwJzogMHhiMjVlLFxuICAnYmxha2Uycy0yNDgnOiAweGIyNWYsXG4gICdibGFrZTJzLTI1Nic6IDB4YjI2MCxcbiAgJ3NrZWluMjU2LTgnOiAweGIzMDEsXG4gICdza2VpbjI1Ni0xNic6IDB4YjMwMixcbiAgJ3NrZWluMjU2LTI0JzogMHhiMzAzLFxuICAnc2tlaW4yNTYtMzInOiAweGIzMDQsXG4gICdza2VpbjI1Ni00MCc6IDB4YjMwNSxcbiAgJ3NrZWluMjU2LTQ4JzogMHhiMzA2LFxuICAnc2tlaW4yNTYtNTYnOiAweGIzMDcsXG4gICdza2VpbjI1Ni02NCc6IDB4YjMwOCxcbiAgJ3NrZWluMjU2LTcyJzogMHhiMzA5LFxuICAnc2tlaW4yNTYtODAnOiAweGIzMGEsXG4gICdza2VpbjI1Ni04OCc6IDB4YjMwYixcbiAgJ3NrZWluMjU2LTk2JzogMHhiMzBjLFxuICAnc2tlaW4yNTYtMTA0JzogMHhiMzBkLFxuICAnc2tlaW4yNTYtMTEyJzogMHhiMzBlLFxuICAnc2tlaW4yNTYtMTIwJzogMHhiMzBmLFxuICAnc2tlaW4yNTYtMTI4JzogMHhiMzEwLFxuICAnc2tlaW4yNTYtMTM2JzogMHhiMzExLFxuICAnc2tlaW4yNTYtMTQ0JzogMHhiMzEyLFxuICAnc2tlaW4yNTYtMTUyJzogMHhiMzEzLFxuICAnc2tlaW4yNTYtMTYwJzogMHhiMzE0LFxuICAnc2tlaW4yNTYtMTY4JzogMHhiMzE1LFxuICAnc2tlaW4yNTYtMTc2JzogMHhiMzE2LFxuICAnc2tlaW4yNTYtMTg0JzogMHhiMzE3LFxuICAnc2tlaW4yNTYtMTkyJzogMHhiMzE4LFxuICAnc2tlaW4yNTYtMjAwJzogMHhiMzE5LFxuICAnc2tlaW4yNTYtMjA4JzogMHhiMzFhLFxuICAnc2tlaW4yNTYtMjE2JzogMHhiMzFiLFxuICAnc2tlaW4yNTYtMjI0JzogMHhiMzFjLFxuICAnc2tlaW4yNTYtMjMyJzogMHhiMzFkLFxuICAnc2tlaW4yNTYtMjQwJzogMHhiMzFlLFxuICAnc2tlaW4yNTYtMjQ4JzogMHhiMzFmLFxuICAnc2tlaW4yNTYtMjU2JzogMHhiMzIwLFxuICAnc2tlaW41MTItOCc6IDB4YjMyMSxcbiAgJ3NrZWluNTEyLTE2JzogMHhiMzIyLFxuICAnc2tlaW41MTItMjQnOiAweGIzMjMsXG4gICdza2VpbjUxMi0zMic6IDB4YjMyNCxcbiAgJ3NrZWluNTEyLTQwJzogMHhiMzI1LFxuICAnc2tlaW41MTItNDgnOiAweGIzMjYsXG4gICdza2VpbjUxMi01Nic6IDB4YjMyNyxcbiAgJ3NrZWluNTEyLTY0JzogMHhiMzI4LFxuICAnc2tlaW41MTItNzInOiAweGIzMjksXG4gICdza2VpbjUxMi04MCc6IDB4YjMyYSxcbiAgJ3NrZWluNTEyLTg4JzogMHhiMzJiLFxuICAnc2tlaW41MTItOTYnOiAweGIzMmMsXG4gICdza2VpbjUxMi0xMDQnOiAweGIzMmQsXG4gICdza2VpbjUxMi0xMTInOiAweGIzMmUsXG4gICdza2VpbjUxMi0xMjAnOiAweGIzMmYsXG4gICdza2VpbjUxMi0xMjgnOiAweGIzMzAsXG4gICdza2VpbjUxMi0xMzYnOiAweGIzMzEsXG4gICdza2VpbjUxMi0xNDQnOiAweGIzMzIsXG4gICdza2VpbjUxMi0xNTInOiAweGIzMzMsXG4gICdza2VpbjUxMi0xNjAnOiAweGIzMzQsXG4gICdza2VpbjUxMi0xNjgnOiAweGIzMzUsXG4gICdza2VpbjUxMi0xNzYnOiAweGIzMzYsXG4gICdza2VpbjUxMi0xODQnOiAweGIzMzcsXG4gICdza2VpbjUxMi0xOTInOiAweGIzMzgsXG4gICdza2VpbjUxMi0yMDAnOiAweGIzMzksXG4gICdza2VpbjUxMi0yMDgnOiAweGIzM2EsXG4gICdza2VpbjUxMi0yMTYnOiAweGIzM2IsXG4gICdza2VpbjUxMi0yMjQnOiAweGIzM2MsXG4gICdza2VpbjUxMi0yMzInOiAweGIzM2QsXG4gICdza2VpbjUxMi0yNDAnOiAweGIzM2UsXG4gICdza2VpbjUxMi0yNDgnOiAweGIzM2YsXG4gICdza2VpbjUxMi0yNTYnOiAweGIzNDAsXG4gICdza2VpbjUxMi0yNjQnOiAweGIzNDEsXG4gICdza2VpbjUxMi0yNzInOiAweGIzNDIsXG4gICdza2VpbjUxMi0yODAnOiAweGIzNDMsXG4gICdza2VpbjUxMi0yODgnOiAweGIzNDQsXG4gICdza2VpbjUxMi0yOTYnOiAweGIzNDUsXG4gICdza2VpbjUxMi0zMDQnOiAweGIzNDYsXG4gICdza2VpbjUxMi0zMTInOiAweGIzNDcsXG4gICdza2VpbjUxMi0zMjAnOiAweGIzNDgsXG4gICdza2VpbjUxMi0zMjgnOiAweGIzNDksXG4gICdza2VpbjUxMi0zMzYnOiAweGIzNGEsXG4gICdza2VpbjUxMi0zNDQnOiAweGIzNGIsXG4gICdza2VpbjUxMi0zNTInOiAweGIzNGMsXG4gICdza2VpbjUxMi0zNjAnOiAweGIzNGQsXG4gICdza2VpbjUxMi0zNjgnOiAweGIzNGUsXG4gICdza2VpbjUxMi0zNzYnOiAweGIzNGYsXG4gICdza2VpbjUxMi0zODQnOiAweGIzNTAsXG4gICdza2VpbjUxMi0zOTInOiAweGIzNTEsXG4gICdza2VpbjUxMi00MDAnOiAweGIzNTIsXG4gICdza2VpbjUxMi00MDgnOiAweGIzNTMsXG4gICdza2VpbjUxMi00MTYnOiAweGIzNTQsXG4gICdza2VpbjUxMi00MjQnOiAweGIzNTUsXG4gICdza2VpbjUxMi00MzInOiAweGIzNTYsXG4gICdza2VpbjUxMi00NDAnOiAweGIzNTcsXG4gICdza2VpbjUxMi00NDgnOiAweGIzNTgsXG4gICdza2VpbjUxMi00NTYnOiAweGIzNTksXG4gICdza2VpbjUxMi00NjQnOiAweGIzNWEsXG4gICdza2VpbjUxMi00NzInOiAweGIzNWIsXG4gICdza2VpbjUxMi00ODAnOiAweGIzNWMsXG4gICdza2VpbjUxMi00ODgnOiAweGIzNWQsXG4gICdza2VpbjUxMi00OTYnOiAweGIzNWUsXG4gICdza2VpbjUxMi01MDQnOiAweGIzNWYsXG4gICdza2VpbjUxMi01MTInOiAweGIzNjAsXG4gICdza2VpbjEwMjQtOCc6IDB4YjM2MSxcbiAgJ3NrZWluMTAyNC0xNic6IDB4YjM2MixcbiAgJ3NrZWluMTAyNC0yNCc6IDB4YjM2MyxcbiAgJ3NrZWluMTAyNC0zMic6IDB4YjM2NCxcbiAgJ3NrZWluMTAyNC00MCc6IDB4YjM2NSxcbiAgJ3NrZWluMTAyNC00OCc6IDB4YjM2NixcbiAgJ3NrZWluMTAyNC01Nic6IDB4YjM2NyxcbiAgJ3NrZWluMTAyNC02NCc6IDB4YjM2OCxcbiAgJ3NrZWluMTAyNC03Mic6IDB4YjM2OSxcbiAgJ3NrZWluMTAyNC04MCc6IDB4YjM2YSxcbiAgJ3NrZWluMTAyNC04OCc6IDB4YjM2YixcbiAgJ3NrZWluMTAyNC05Nic6IDB4YjM2YyxcbiAgJ3NrZWluMTAyNC0xMDQnOiAweGIzNmQsXG4gICdza2VpbjEwMjQtMTEyJzogMHhiMzZlLFxuICAnc2tlaW4xMDI0LTEyMCc6IDB4YjM2ZixcbiAgJ3NrZWluMTAyNC0xMjgnOiAweGIzNzAsXG4gICdza2VpbjEwMjQtMTM2JzogMHhiMzcxLFxuICAnc2tlaW4xMDI0LTE0NCc6IDB4YjM3MixcbiAgJ3NrZWluMTAyNC0xNTInOiAweGIzNzMsXG4gICdza2VpbjEwMjQtMTYwJzogMHhiMzc0LFxuICAnc2tlaW4xMDI0LTE2OCc6IDB4YjM3NSxcbiAgJ3NrZWluMTAyNC0xNzYnOiAweGIzNzYsXG4gICdza2VpbjEwMjQtMTg0JzogMHhiMzc3LFxuICAnc2tlaW4xMDI0LTE5Mic6IDB4YjM3OCxcbiAgJ3NrZWluMTAyNC0yMDAnOiAweGIzNzksXG4gICdza2VpbjEwMjQtMjA4JzogMHhiMzdhLFxuICAnc2tlaW4xMDI0LTIxNic6IDB4YjM3YixcbiAgJ3NrZWluMTAyNC0yMjQnOiAweGIzN2MsXG4gICdza2VpbjEwMjQtMjMyJzogMHhiMzdkLFxuICAnc2tlaW4xMDI0LTI0MCc6IDB4YjM3ZSxcbiAgJ3NrZWluMTAyNC0yNDgnOiAweGIzN2YsXG4gICdza2VpbjEwMjQtMjU2JzogMHhiMzgwLFxuICAnc2tlaW4xMDI0LTI2NCc6IDB4YjM4MSxcbiAgJ3NrZWluMTAyNC0yNzInOiAweGIzODIsXG4gICdza2VpbjEwMjQtMjgwJzogMHhiMzgzLFxuICAnc2tlaW4xMDI0LTI4OCc6IDB4YjM4NCxcbiAgJ3NrZWluMTAyNC0yOTYnOiAweGIzODUsXG4gICdza2VpbjEwMjQtMzA0JzogMHhiMzg2LFxuICAnc2tlaW4xMDI0LTMxMic6IDB4YjM4NyxcbiAgJ3NrZWluMTAyNC0zMjAnOiAweGIzODgsXG4gICdza2VpbjEwMjQtMzI4JzogMHhiMzg5LFxuICAnc2tlaW4xMDI0LTMzNic6IDB4YjM4YSxcbiAgJ3NrZWluMTAyNC0zNDQnOiAweGIzOGIsXG4gICdza2VpbjEwMjQtMzUyJzogMHhiMzhjLFxuICAnc2tlaW4xMDI0LTM2MCc6IDB4YjM4ZCxcbiAgJ3NrZWluMTAyNC0zNjgnOiAweGIzOGUsXG4gICdza2VpbjEwMjQtMzc2JzogMHhiMzhmLFxuICAnc2tlaW4xMDI0LTM4NCc6IDB4YjM5MCxcbiAgJ3NrZWluMTAyNC0zOTInOiAweGIzOTEsXG4gICdza2VpbjEwMjQtNDAwJzogMHhiMzkyLFxuICAnc2tlaW4xMDI0LTQwOCc6IDB4YjM5MyxcbiAgJ3NrZWluMTAyNC00MTYnOiAweGIzOTQsXG4gICdza2VpbjEwMjQtNDI0JzogMHhiMzk1LFxuICAnc2tlaW4xMDI0LTQzMic6IDB4YjM5NixcbiAgJ3NrZWluMTAyNC00NDAnOiAweGIzOTcsXG4gICdza2VpbjEwMjQtNDQ4JzogMHhiMzk4LFxuICAnc2tlaW4xMDI0LTQ1Nic6IDB4YjM5OSxcbiAgJ3NrZWluMTAyNC00NjQnOiAweGIzOWEsXG4gICdza2VpbjEwMjQtNDcyJzogMHhiMzliLFxuICAnc2tlaW4xMDI0LTQ4MCc6IDB4YjM5YyxcbiAgJ3NrZWluMTAyNC00ODgnOiAweGIzOWQsXG4gICdza2VpbjEwMjQtNDk2JzogMHhiMzllLFxuICAnc2tlaW4xMDI0LTUwNCc6IDB4YjM5ZixcbiAgJ3NrZWluMTAyNC01MTInOiAweGIzYTAsXG4gICdza2VpbjEwMjQtNTIwJzogMHhiM2ExLFxuICAnc2tlaW4xMDI0LTUyOCc6IDB4YjNhMixcbiAgJ3NrZWluMTAyNC01MzYnOiAweGIzYTMsXG4gICdza2VpbjEwMjQtNTQ0JzogMHhiM2E0LFxuICAnc2tlaW4xMDI0LTU1Mic6IDB4YjNhNSxcbiAgJ3NrZWluMTAyNC01NjAnOiAweGIzYTYsXG4gICdza2VpbjEwMjQtNTY4JzogMHhiM2E3LFxuICAnc2tlaW4xMDI0LTU3Nic6IDB4YjNhOCxcbiAgJ3NrZWluMTAyNC01ODQnOiAweGIzYTksXG4gICdza2VpbjEwMjQtNTkyJzogMHhiM2FhLFxuICAnc2tlaW4xMDI0LTYwMCc6IDB4YjNhYixcbiAgJ3NrZWluMTAyNC02MDgnOiAweGIzYWMsXG4gICdza2VpbjEwMjQtNjE2JzogMHhiM2FkLFxuICAnc2tlaW4xMDI0LTYyNCc6IDB4YjNhZSxcbiAgJ3NrZWluMTAyNC02MzInOiAweGIzYWYsXG4gICdza2VpbjEwMjQtNjQwJzogMHhiM2IwLFxuICAnc2tlaW4xMDI0LTY0OCc6IDB4YjNiMSxcbiAgJ3NrZWluMTAyNC02NTYnOiAweGIzYjIsXG4gICdza2VpbjEwMjQtNjY0JzogMHhiM2IzLFxuICAnc2tlaW4xMDI0LTY3Mic6IDB4YjNiNCxcbiAgJ3NrZWluMTAyNC02ODAnOiAweGIzYjUsXG4gICdza2VpbjEwMjQtNjg4JzogMHhiM2I2LFxuICAnc2tlaW4xMDI0LTY5Nic6IDB4YjNiNyxcbiAgJ3NrZWluMTAyNC03MDQnOiAweGIzYjgsXG4gICdza2VpbjEwMjQtNzEyJzogMHhiM2I5LFxuICAnc2tlaW4xMDI0LTcyMCc6IDB4YjNiYSxcbiAgJ3NrZWluMTAyNC03MjgnOiAweGIzYmIsXG4gICdza2VpbjEwMjQtNzM2JzogMHhiM2JjLFxuICAnc2tlaW4xMDI0LTc0NCc6IDB4YjNiZCxcbiAgJ3NrZWluMTAyNC03NTInOiAweGIzYmUsXG4gICdza2VpbjEwMjQtNzYwJzogMHhiM2JmLFxuICAnc2tlaW4xMDI0LTc2OCc6IDB4YjNjMCxcbiAgJ3NrZWluMTAyNC03NzYnOiAweGIzYzEsXG4gICdza2VpbjEwMjQtNzg0JzogMHhiM2MyLFxuICAnc2tlaW4xMDI0LTc5Mic6IDB4YjNjMyxcbiAgJ3NrZWluMTAyNC04MDAnOiAweGIzYzQsXG4gICdza2VpbjEwMjQtODA4JzogMHhiM2M1LFxuICAnc2tlaW4xMDI0LTgxNic6IDB4YjNjNixcbiAgJ3NrZWluMTAyNC04MjQnOiAweGIzYzcsXG4gICdza2VpbjEwMjQtODMyJzogMHhiM2M4LFxuICAnc2tlaW4xMDI0LTg0MCc6IDB4YjNjOSxcbiAgJ3NrZWluMTAyNC04NDgnOiAweGIzY2EsXG4gICdza2VpbjEwMjQtODU2JzogMHhiM2NiLFxuICAnc2tlaW4xMDI0LTg2NCc6IDB4YjNjYyxcbiAgJ3NrZWluMTAyNC04NzInOiAweGIzY2QsXG4gICdza2VpbjEwMjQtODgwJzogMHhiM2NlLFxuICAnc2tlaW4xMDI0LTg4OCc6IDB4YjNjZixcbiAgJ3NrZWluMTAyNC04OTYnOiAweGIzZDAsXG4gICdza2VpbjEwMjQtOTA0JzogMHhiM2QxLFxuICAnc2tlaW4xMDI0LTkxMic6IDB4YjNkMixcbiAgJ3NrZWluMTAyNC05MjAnOiAweGIzZDMsXG4gICdza2VpbjEwMjQtOTI4JzogMHhiM2Q0LFxuICAnc2tlaW4xMDI0LTkzNic6IDB4YjNkNSxcbiAgJ3NrZWluMTAyNC05NDQnOiAweGIzZDYsXG4gICdza2VpbjEwMjQtOTUyJzogMHhiM2Q3LFxuICAnc2tlaW4xMDI0LTk2MCc6IDB4YjNkOCxcbiAgJ3NrZWluMTAyNC05NjgnOiAweGIzZDksXG4gICdza2VpbjEwMjQtOTc2JzogMHhiM2RhLFxuICAnc2tlaW4xMDI0LTk4NCc6IDB4YjNkYixcbiAgJ3NrZWluMTAyNC05OTInOiAweGIzZGMsXG4gICdza2VpbjEwMjQtMTAwMCc6IDB4YjNkZCxcbiAgJ3NrZWluMTAyNC0xMDA4JzogMHhiM2RlLFxuICAnc2tlaW4xMDI0LTEwMTYnOiAweGIzZGYsXG4gICdza2VpbjEwMjQtMTAyNCc6IDB4YjNlMCxcbiAgJ3Bvc2VpZG9uLWJsczEyXzM4MS1hMi1mYzEnOiAweGI0MDEsXG4gICdwb3NlaWRvbi1ibHMxMl8zODEtYTItZmMxLXNjJzogMHhiNDAyXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgbmFtZXMgfVxuIiwiLy8gQHRzLWNoZWNrXG4vKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cbi8qKlxuICogTXVsdGloYXNoIGltcGxlbWVudGF0aW9uIGluIEphdmFTY3JpcHQuXG4gKlxuICogQG1vZHVsZSBtdWx0aWhhc2hcbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgbXVsdGliYXNlID0gcmVxdWlyZSgnbXVsdGliYXNlJylcbmNvbnN0IHZhcmludCA9IHJlcXVpcmUoJ3ZhcmludCcpXG5jb25zdCB7IG5hbWVzIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IFRleHREZWNvZGVyIH0gPSByZXF1aXJlKCd3ZWItZW5jb2RpbmcnKVxuXG5jb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG5jb25zdCBjb2RlcyA9IHt9XG5cbmZvciAoY29uc3Qga2V5IGluIG5hbWVzKSB7XG4gIGNvZGVzW25hbWVzW2tleV1dID0ga2V5XG59XG5leHBvcnRzLm5hbWVzID0gbmFtZXNcbmV4cG9ydHMuY29kZXMgPSBPYmplY3QuZnJlZXplKGNvZGVzKVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIG11bHRpaGFzaCB0byBhIGhleCBlbmNvZGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGhhc2hcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMudG9IZXhTdHJpbmcgPSBmdW5jdGlvbiB0b0hleFN0cmluZyAoaGFzaCkge1xuICBpZiAoIShoYXNoIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgYmUgcGFzc2VkIGEgVWludDhBcnJheScpXG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuaXNCdWZmZXIoaGFzaClcbiAgICA/IGhhc2hcbiAgICA6IEJ1ZmZlci5mcm9tKGhhc2guYnVmZmVyLCBoYXNoLmJ5dGVPZmZzZXQsIGhhc2guYnl0ZUxlbmd0aClcblxuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKCdoZXgnKVxufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGhleCBlbmNvZGVkIHN0cmluZyB0byBhIG11bHRpaGFzaC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaFxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5mcm9tSGV4U3RyaW5nID0gZnVuY3Rpb24gZnJvbUhleFN0cmluZyAoaGFzaCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oaGFzaCwgJ2hleCcpXG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gbXVsdGloYXNoIHRvIGEgYmFzZTU4IGVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gaGFzaFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy50b0I1OFN0cmluZyA9IGZ1bmN0aW9uIHRvQjU4U3RyaW5nIChoYXNoKSB7XG4gIGlmICghKGhhc2ggaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBiZSBwYXNzZWQgYSBVaW50OEFycmF5JylcbiAgfVxuXG4gIHJldHVybiB0ZXh0RGVjb2Rlci5kZWNvZGUobXVsdGliYXNlLmVuY29kZSgnYmFzZTU4YnRjJywgaGFzaCkpLnNsaWNlKDEpXG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gYmFzZTU4IGVuY29kZWQgc3RyaW5nIHRvIGEgbXVsdGloYXNoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFVpbnQ4QXJyYXl9IGhhc2hcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuZnJvbUI1OFN0cmluZyA9IGZ1bmN0aW9uIGZyb21CNThTdHJpbmcgKGhhc2gpIHtcbiAgY29uc3QgZW5jb2RlZCA9IGhhc2ggaW5zdGFuY2VvZiBVaW50OEFycmF5XG4gICAgPyB0ZXh0RGVjb2Rlci5kZWNvZGUoaGFzaClcbiAgICA6IGhhc2hcblxuICByZXR1cm4gbXVsdGliYXNlLmRlY29kZSgneicgKyBlbmNvZGVkKVxufVxuXG4vKipcbiAqIERlY29kZSBhIGhhc2ggZnJvbSB0aGUgZ2l2ZW4gbXVsdGloYXNoLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAqIEByZXR1cm5zIHt7Y29kZTogbnVtYmVyLCBuYW1lOiBzdHJpbmcsIGxlbmd0aDogbnVtYmVyLCBkaWdlc3Q6IEJ1ZmZlcn19IHJlc3VsdFxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZSAoYnl0ZXMpIHtcbiAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVsdGloYXNoIG11c3QgYmUgYSBVaW50OEFycmF5JylcbiAgfVxuICBsZXQgYnVmID0gQnVmZmVyLmlzQnVmZmVyKGJ5dGVzKVxuICAgID8gYnl0ZXNcbiAgICA6IEJ1ZmZlci5mcm9tKGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aClcblxuICBpZiAoYnVmLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpaGFzaCB0b28gc2hvcnQuIG11c3QgYmUgPiAyIGJ5dGVzLicpXG4gIH1cblxuICBjb25zdCBjb2RlID0gdmFyaW50LmRlY29kZShidWYpXG4gIGlmICghZXhwb3J0cy5pc1ZhbGlkQ29kZShjb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgbXVsdGloYXNoIHVua25vd24gZnVuY3Rpb24gY29kZTogMHgke2NvZGUudG9TdHJpbmcoMTYpfWApXG4gIH1cbiAgYnVmID0gYnVmLnNsaWNlKHZhcmludC5kZWNvZGUuYnl0ZXMpXG5cbiAgY29uc3QgbGVuID0gdmFyaW50LmRlY29kZShidWYpXG4gIGlmIChsZW4gPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBtdWx0aWhhc2ggaW52YWxpZCBsZW5ndGg6ICR7bGVufWApXG4gIH1cbiAgYnVmID0gYnVmLnNsaWNlKHZhcmludC5kZWNvZGUuYnl0ZXMpXG5cbiAgaWYgKGJ1Zi5sZW5ndGggIT09IGxlbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgbXVsdGloYXNoIGxlbmd0aCBpbmNvbnNpc3RlbnQ6IDB4JHtidWYudG9TdHJpbmcoJ2hleCcpfWApXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvZGUsXG4gICAgbmFtZTogY29kZXNbY29kZV0sXG4gICAgbGVuZ3RoOiBsZW4sXG4gICAgZGlnZXN0OiBidWZcbiAgfVxufVxuXG4vKipcbiAqICBFbmNvZGUgYSBoYXNoIGRpZ2VzdCBhbG9uZyB3aXRoIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gY29kZS5cbiAqXG4gKiA+ICoqTm90ZToqKiB0aGUgbGVuZ3RoIGlzIGRlcml2ZWQgZnJvbSB0aGUgbGVuZ3RoIG9mIHRoZSBkaWdlc3QgaXRzZWxmLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGlnZXN0XG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGNvZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXVxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUgKGRpZ2VzdCwgY29kZSwgbGVuZ3RoKSB7XG4gIGlmICghZGlnZXN0IHx8IGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVsdGloYXNoIGVuY29kZSByZXF1aXJlcyBhdCBsZWFzdCB0d28gYXJnczogZGlnZXN0LCBjb2RlJylcbiAgfVxuXG4gIC8vIGVuc3VyZSBpdCdzIGEgaGFzaGZ1bmN0aW9uIGNvZGUuXG4gIGNvbnN0IGhhc2hmbiA9IGV4cG9ydHMuY29lcmNlQ29kZShjb2RlKVxuXG4gIGlmICghKGRpZ2VzdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3Qgc2hvdWxkIGJlIGEgVWludDhBcnJheScpXG4gIH1cblxuICBpZiAobGVuZ3RoID09IG51bGwpIHtcbiAgICBsZW5ndGggPSBkaWdlc3QubGVuZ3RoXG4gIH1cblxuICBpZiAobGVuZ3RoICYmIGRpZ2VzdC5sZW5ndGggIT09IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGlnZXN0IGxlbmd0aCBzaG91bGQgYmUgZXF1YWwgdG8gc3BlY2lmaWVkIGxlbmd0aC4nKVxuICB9XG5cbiAgY29uc3QgaGFzaCA9IHZhcmludC5lbmNvZGUoaGFzaGZuKVxuICBjb25zdCBsZW4gPSB2YXJpbnQuZW5jb2RlKGxlbmd0aClcbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKGhhc2gubGVuZ3RoICsgbGVuLmxlbmd0aCArIGRpZ2VzdC5sZW5ndGgpXG4gIGJ1ZmZlci5zZXQoaGFzaCwgMClcbiAgYnVmZmVyLnNldChsZW4sIGhhc2gubGVuZ3RoKVxuICBidWZmZXIuc2V0KGRpZ2VzdCwgaGFzaC5sZW5ndGggKyBsZW4ubGVuZ3RoKVxuICByZXR1cm4gYnVmZmVyXG59XG5cbi8qKlxuICogQ29udmVydHMgYSBoYXNoIGZ1bmN0aW9uIG5hbWUgaW50byB0aGUgbWF0Y2hpbmcgY29kZS5cbiAqIElmIHBhc3NlZCBhIG51bWJlciBpdCB3aWxsIHJldHVybiB0aGUgbnVtYmVyIGlmIGl0J3MgYSB2YWxpZCBjb2RlLlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBuYW1lXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnRzLmNvZXJjZUNvZGUgPSBmdW5jdGlvbiBjb2VyY2VDb2RlIChuYW1lKSB7XG4gIGxldCBjb2RlID0gbmFtZVxuXG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAobmFtZXNbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgaGFzaCBmdW5jdGlvbiBuYW1lZDogJHtuYW1lfWApXG4gICAgfVxuICAgIGNvZGUgPSBuYW1lc1tuYW1lXVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgSGFzaCBmdW5jdGlvbiBjb2RlIHNob3VsZCBiZSBhIG51bWJlci4gR290OiAke2NvZGV9YClcbiAgfVxuXG4gIGlmIChjb2Rlc1tjb2RlXSA9PT0gdW5kZWZpbmVkICYmICFleHBvcnRzLmlzQXBwQ29kZShjb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGZ1bmN0aW9uIGNvZGU6ICR7Y29kZX1gKVxuICB9XG5cbiAgcmV0dXJuIGNvZGVcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2V0aGVyIGEgY29kZSBpcyBwYXJ0IG9mIHRoZSBhcHAgcmFuZ2VcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNBcHBDb2RlID0gZnVuY3Rpb24gYXBwQ29kZSAoY29kZSkge1xuICByZXR1cm4gY29kZSA+IDAgJiYgY29kZSA8IDB4MTBcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIG11bHRpaGFzaCBjb2RlIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkQ29kZSA9IGZ1bmN0aW9uIHZhbGlkQ29kZSAoY29kZSkge1xuICBpZiAoZXhwb3J0cy5pc0FwcENvZGUoY29kZSkpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKGNvZGVzW2NvZGVdKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBidWZmZXIgaXMgYSB2YWxpZCBtdWx0aWhhc2guIFRocm93cyBhbiBlcnJvciBpZiBpdCBpcyBub3QgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBtdWx0aWhhc2hcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHRocm93cyB7RXJyb3J9XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlIChtdWx0aWhhc2gpIHtcbiAgZXhwb3J0cy5kZWNvZGUobXVsdGloYXNoKSAvLyB0aHJvd3MgaWYgYmFkLlxufVxuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlXG5cbi8qKlxuICogUmV0dXJucyBhIHByZWZpeCBmcm9tIGEgdmFsaWQgbXVsdGloYXNoLiBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgaXMgbm90IHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gbXVsdGloYXNoXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICogQHRocm93cyB7RXJyb3J9XG4gKi9cbmV4cG9ydHMucHJlZml4ID0gZnVuY3Rpb24gcHJlZml4IChtdWx0aWhhc2gpIHtcbiAgdmFsaWRhdGUobXVsdGloYXNoKVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShtdWx0aWhhc2guYnVmZmVyLCBtdWx0aWhhc2guYnl0ZU9mZnNldCwgMilcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgVWludDhBcnJheSBjcmVhdGVkIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIHBhc3NlZCBBcnJheUxpa2VzXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheUxpa2U8bnVtYmVyPj59IGFycmF5c1xuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGNvbmNhdCAoYXJyYXlzLCBsZW5ndGgpIHtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSBhcnJheXMucmVkdWNlKChhY2MsIGN1cnIpID0+IGFjYyArIGN1cnIubGVuZ3RoLCAwKVxuICB9XG5cbiAgY29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBsZXQgb2Zmc2V0ID0gMFxuXG4gIGZvciAoY29uc3QgYXJyIG9mIGFycmF5cykge1xuICAgIG91dHB1dC5zZXQoYXJyLCBvZmZzZXQpXG4gICAgb2Zmc2V0ICs9IGFyci5sZW5ndGhcbiAgfVxuXG4gIHJldHVybiBvdXRwdXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25jYXRcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IG5hbWVzIH0gPSByZXF1aXJlKCdtdWx0aWJhc2Uvc3JjL2NvbnN0YW50cycpXG5jb25zdCB7IFRleHRFbmNvZGVyIH0gPSByZXF1aXJlKCd3ZWItZW5jb2RpbmcnKVxuY29uc3QgdXRmOEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuXG4vKipcbiAqIEludGVycGVyZXRzIGVhY2ggY2hhcmFjdGVyIGluIGEgc3RyaW5nIGFzIGEgYnl0ZSBhbmRcbiAqIHJldHVybnMgYSBVaW50OEFycmF5IG9mIHRob3NlIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byB0dXJuIGludG8gYW4gYXJyYXlcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBhc2NpaVN0cmluZ1RvVWludDhBcnJheSAoc3RyaW5nKSB7XG4gIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoc3RyaW5nLmxlbmd0aClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgIGFycmF5W2ldID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcbiAgfVxuXG4gIHJldHVybiBhcnJheVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGBVaW50OEFycmF5YCBmcm9tIHRoZSBwYXNzZWQgc3RyaW5nXG4gKlxuICogU3VwcG9ydHMgYHV0ZjhgLCBgdXRmLThgIGFuZCBhbnkgZW5jb2Rpbmcgc3VwcG9ydGVkIGJ5IHRoZSBtdWx0aWJhc2UgbW9kdWxlLlxuICpcbiAqIEFsc28gYGFzY2lpYCB3aGljaCBpcyBzaW1pbGFyIHRvIG5vZGUncyAnYmluYXJ5JyBlbmNvZGluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gW2VuY29kaW5nPXV0ZjhdIHV0ZjgsIGJhc2UxNiwgYmFzZTY0LCBiYXNlNjR1cmxwYWQsIGV0Y1xuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tdWx0aWJhc2V8bXVsdGliYXNlfSBmb3Igc3VwcG9ydGVkIGVuY29kaW5ncyBvdGhlciB0aGFuIGB1dGY4YFxuICovXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nID0gJ3V0ZjgnKSB7XG4gIGlmIChlbmNvZGluZyA9PT0gJ3V0ZjgnIHx8IGVuY29kaW5nID09PSAndXRmLTgnKSB7XG4gICAgcmV0dXJuIHV0ZjhFbmNvZGVyLmVuY29kZShzdHJpbmcpXG4gIH1cblxuICBpZiAoZW5jb2RpbmcgPT09ICdhc2NpaScpIHtcbiAgICByZXR1cm4gYXNjaWlTdHJpbmdUb1VpbnQ4QXJyYXkoc3RyaW5nKVxuICB9XG5cbiAgY29uc3QgY29kZWMgPSBuYW1lc1tlbmNvZGluZ11cblxuICBpZiAoIWNvZGVjKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGJhc2UnKVxuICB9XG5cbiAgcmV0dXJuIGNvZGVjLmRlY29kZShzdHJpbmcpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnJvbVN0cmluZ1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgbmFtZXMgfSA9IHJlcXVpcmUoJ211bHRpYmFzZS9zcmMvY29uc3RhbnRzJylcbmNvbnN0IHsgVGV4dERlY29kZXIgfSA9IHJlcXVpcmUoJ3dlYi1lbmNvZGluZycpXG5jb25zdCB1dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmOCcpXG5cbi8qKlxuICogVHVybnMgYSBVaW50OEFycmF5IG9mIGJ5dGVzIGludG8gYSBzdHJpbmcgd2l0aCBlYWNoXG4gKiBjaGFyYWN0ZXIgYmVpbmcgdGhlIGNoYXIgY29kZSBvZiB0aGUgY29ycmVzcG9uZGluZyBieXRlXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gdHVybiBpbnRvIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiB1aW50OEFycmF5VG9Bc2NpaVN0cmluZyAoYXJyYXkpIHtcbiAgbGV0IHN0cmluZyA9ICcnXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycmF5W2ldKVxuICB9XG4gIHJldHVybiBzdHJpbmdcbn1cblxuLyoqXG4gKiBUdXJucyBhIGBVaW50OEFycmF5YCBpbnRvIGEgc3RyaW5nLlxuICpcbiAqIFN1cHBvcnRzIGB1dGY4YCwgYHV0Zi04YCBhbmQgYW55IGVuY29kaW5nIHN1cHBvcnRlZCBieSB0aGUgbXVsdGliYXNlIG1vZHVsZS5cbiAqXG4gKiBBbHNvIGBhc2NpaWAgd2hpY2ggaXMgc2ltaWxhciB0byBub2RlJ3MgJ2JpbmFyeScgZW5jb2RpbmcuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gdHVybiBpbnRvIGEgc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gW2VuY29kaW5nPXV0ZjhdIFRoZSBlbmNvZGluZyB0byB1c2VcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tdWx0aWJhc2V8bXVsdGliYXNlfSBmb3Igc3VwcG9ydGVkIGVuY29kaW5ncyBvdGhlciB0aGFuIGB1dGY4YFxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAoYXJyYXksIGVuY29kaW5nID0gJ3V0ZjgnKSB7XG4gIGlmIChlbmNvZGluZyA9PT0gJ3V0ZjgnIHx8IGVuY29kaW5nID09PSAndXRmLTgnKSB7XG4gICAgcmV0dXJuIHV0ZjhEZWNvZGVyLmRlY29kZShhcnJheSlcbiAgfVxuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2FzY2lpJykge1xuICAgIHJldHVybiB1aW50OEFycmF5VG9Bc2NpaVN0cmluZyhhcnJheSlcbiAgfVxuXG4gIGNvbnN0IGNvZGVjID0gbmFtZXNbZW5jb2RpbmddXG5cbiAgaWYgKCFjb2RlYykge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBiYXNlJylcbiAgfVxuXG4gIHJldHVybiBjb2RlYy5lbmNvZGUoYXJyYXkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9TdHJpbmdcbiIsIi8qXG5cdElTQyBMaWNlbnNlXG5cblx0Q29weXJpZ2h0IChjKSAyMDE5LCBQaWVycmUtTG91aXMgRGVzcGFpZ25lXG5cblx0UGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5cdHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcblx0Y29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cblxuXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuXHRXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG5cdE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG5cdEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcblx0V0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG5cdEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG5cdE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qL1xuXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJyk7XG5cbi8vIExhYmVsJ3MgbWF4IGxlbmd0aCBpbiBETlMgKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxMDM0I3BhZ2UtNylcbmNvbnN0IGRuc0xhYmVsTWF4TGVuZ3RoID0gNjM7XG5cbi8qKlxuICogVGFrZSBhbnkgaXBmc0hhc2ggYW5kIGNvbnZlcnQgaXQgdG8gRE5TLWNvbXBhdGlibGUgQ0lEXG4gKiBAcGFyYW0ge3N0cmluZ30gaXBmc0hhc2ggYSByZWd1bGFyIGlwZnMgaGFzaCBlaXRoZXIgYSBjaWQgdjAgb3IgdjFcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHJlc3VsdGluZyBpcGZzIGhhc2ggYXMgYSBjaWQgdjFcbiAqL1xuY29uc3QgY2lkRm9yV2ViID0gKGlwZnNIYXNoKSA9PiB7XG5cdGxldCBjaWQgPSBuZXcgQ0lEKGlwZnNIYXNoKTtcblx0aWYgKGNpZC52ZXJzaW9uID09PSAwKSB7XG5cdFx0Y2lkID0gY2lkLnRvVjEoKTtcblx0fVxuICBsZXQgZG5zTGFiZWwgPSBjaWQudG9TdHJpbmcoJ2Jhc2UzMicpO1xuICBpZiAoZG5zTGFiZWwubGVuZ3RoID4gZG5zTGFiZWxNYXhMZW5ndGgpIHtcbiAgICBjb25zdCBiMzYgPSBjaWQudG9TdHJpbmcoJ2Jhc2UzNicpO1xuICAgIGlmIChiMzYubGVuZ3RoIDw9IGRuc0xhYmVsTWF4TGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYjM2O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yICgnQ0lEIGlzIGxvbmdlciB0aGFuIEROUyBsaW1pdCBvZiA2MyBjaGFyYWN0ZXJzIGFuZCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHB1YmxpYyBnYXRld2F5cycpO1xuICB9XG5cdHJldHVybiBkbnNMYWJlbDtcbn1cblxuZXhwb3J0cy5jaWRGb3JXZWIgPSBjaWRGb3JXZWI7XG5cblxuLyoqXG4gKiBUYWtlIGFueSBpcGZzSGFzaCBhbmQgY29udmVydCBpdCB0byBhIENJRCB2MSBlbmNvZGVkIGluIGJhc2UzMi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpcGZzSGFzaCBhIHJlZ3VsYXIgaXBmcyBoYXNoIGVpdGhlciBhIGNpZCB2MCBvciB2MSAodjEgd2lsbCByZW1haW4gdW5jaGFuZ2VkKVxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgcmVzdWx0aW5nIGlwZnMgaGFzaCBhcyBhIGNpZCB2MVxuICovXG5jb25zdCBjaWRWMFRvVjFCYXNlMzIgPSAoaXBmc0hhc2gpID0+IHtcblx0bGV0IGNpZCA9IG5ldyBDSUQoaXBmc0hhc2gpO1xuXHRpZiAoY2lkLnZlcnNpb24gPT09IDApIHtcblx0XHRjaWQgPSBjaWQudG9WMSgpO1xuXHR9XG5cdHJldHVybiBjaWQudG9TdHJpbmcoJ2Jhc2UzMicpO1xufVxuXG5leHBvcnRzLmNpZFYwVG9WMUJhc2UzMiA9IGNpZFYwVG9WMUJhc2UzMjtcbiIsIi8qXG5cdElTQyBMaWNlbnNlXG5cblx0Q29weXJpZ2h0IChjKSAyMDE5LCBQaWVycmUtTG91aXMgRGVzcGFpZ25lXG5cblx0UGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5cdHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcblx0Y29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cblxuXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuXHRXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG5cdE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG5cdEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcblx0V0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG5cdEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG5cdE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qL1xuXG5jb25zdCBtdWx0aUMgPSByZXF1aXJlKCdtdWx0aWNvZGVjJyk7XG5jb25zdCBtdWx0aUggPSByZXF1aXJlKCdtdWx0aWhhc2hlcycpO1xuXG5jb25zdCB7IGhleFN0cmluZ1RvQnVmZmVyLCBwcm9maWxlcyB9ID0gcmVxdWlyZSgnLi9wcm9maWxlcycpO1xuY29uc3QgeyBjaWRGb3JXZWIsIGNpZFYwVG9WMUJhc2UzMiB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdC8vZXhwb3J0IHNvbWUgaGVscGVycyBmdW5jdGlvbnNcblx0aGVscGVyczoge1xuXHRcdGNpZEZvcldlYixcblx0XHRjaWRWMFRvVjFCYXNlMzIsXG5cdH0sXG5cblx0LyoqXG5cdCogRGVjb2RlIGEgQ29udGVudCBIYXNoLlxuXHQqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIGFuIGhleCBzdHJpbmcgY29udGFpbmluZyBhIGNvbnRlbnQgaGFzaFxuXHQqIEByZXR1cm4ge3N0cmluZ30gdGhlIGRlY29kZWQgY29udGVudFxuXHQqL1xuXHRkZWNvZGU6IGZ1bmN0aW9uIChjb250ZW50SGFzaCkge1xuXHRcdGNvbnN0IGJ1ZmZlciA9IGhleFN0cmluZ1RvQnVmZmVyKGNvbnRlbnRIYXNoKTtcblx0XHRjb25zdCBjb2RlYyA9IG11bHRpQy5nZXRDb2RlYyhidWZmZXIpO1xuXHRcdGNvbnN0IHZhbHVlID0gbXVsdGlDLnJtUHJlZml4KGJ1ZmZlcik7XG5cdFx0bGV0IHByb2ZpbGUgPSBwcm9maWxlc1tjb2RlY107XG5cdFx0aWYgKCFwcm9maWxlKSBwcm9maWxlID0gcHJvZmlsZXNbJ2RlZmF1bHQnXTtcblx0XHRyZXR1cm4gcHJvZmlsZS5kZWNvZGUodmFsdWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEVuY29kZSBhbiBJUEZTIGFkZHJlc3MgaW50byBhIGNvbnRlbnQgaGFzaFxuXHQqIEBwYXJhbSB7c3RyaW5nfSBpcGZzSGFzaCBzdHJpbmcgY29udGFpbmluZyBhbiBJUEZTIGFkZHJlc3Ncblx0KiBAcmV0dXJuIHtzdHJpbmd9IHRoZSByZXN1bHRpbmcgY29udGVudCBoYXNoXG5cdCovXG5cdGZyb21JcGZzOiBmdW5jdGlvbiAoaXBmc0hhc2gpIHtcblx0XHRyZXR1cm4gdGhpcy5lbmNvZGUoJ2lwZnMtbnMnLCBpcGZzSGFzaCk7XG5cdH0sXG5cblx0LyoqXG5cdCogRW5jb2RlIGEgU2t5bGluayBpbnRvIGEgY29udGVudCBoYXNoXG5cdCogQHBhcmFtIHtzdHJpbmd9IHNreWxpbmsgc3RyaW5nIGNvbnRhaW5pbmcgYSBTa3lsaW5rXG5cdCogQHJldHVybiB7c3RyaW5nfSB0aGUgcmVzdWx0aW5nIGNvbnRlbnQgaGFzaFxuXHQqL1xuXHRmcm9tU2t5bGluazogZnVuY3Rpb24gKHNreWxpbmspIHtcblx0XHRyZXR1cm4gdGhpcy5lbmNvZGUoJ3NreW5ldC1ucycsIHNreWxpbmspO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEVuY29kZSBhIFN3YXJtIGFkZHJlc3MgaW50byBhIGNvbnRlbnQgaGFzaFxuXHQqIEBwYXJhbSB7c3RyaW5nfSBzd2FybUhhc2ggc3RyaW5nIGNvbnRhaW5pbmcgYSBTd2FybSBhZGRyZXNzXG5cdCogQHJldHVybiB7c3RyaW5nfSB0aGUgcmVzdWx0aW5nIGNvbnRlbnQgaGFzaFxuXHQqL1xuXHRmcm9tU3dhcm06IGZ1bmN0aW9uIChzd2FybUhhc2gpIHtcblx0XHRyZXR1cm4gdGhpcy5lbmNvZGUoJ3N3YXJtLW5zJywgc3dhcm1IYXNoKTtcblx0fSxcblxuXHQvKipcblx0KiBHZW5lcmFsIHB1cnBvc2UgZW5jb2RpbmcgZnVuY3Rpb25cbiAgKiBAcGFyYW0ge3N0cmluZ30gY29kZWMgXG4gICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFxuICAqL1xuXHRlbmNvZGU6IGZ1bmN0aW9uIChjb2RlYywgdmFsdWUpIHtcblx0XHRsZXQgcHJvZmlsZSA9IHByb2ZpbGVzW2NvZGVjXTtcblx0XHRpZiAoIXByb2ZpbGUpIHByb2ZpbGUgPSBwcm9maWxlc1snZGVmYXVsdCddO1xuXHRcdGNvbnN0IGVuY29kZWRWYWx1ZSA9IHByb2ZpbGUuZW5jb2RlKHZhbHVlKTtcblx0XHRyZXR1cm4gbXVsdGlILnRvSGV4U3RyaW5nKG11bHRpQy5hZGRQcmVmaXgoY29kZWMsIGVuY29kZWRWYWx1ZSkpXG5cdH0sXG5cblx0LyoqXG5cdCogRXh0cmFjdCB0aGUgY29kZWMgb2YgYSBjb250ZW50IGhhc2hcblx0KiBAcGFyYW0ge3N0cmluZ30gaGFzaCBoZXggc3RyaW5nIGNvbnRhaW5pbmcgYSBjb250ZW50IGhhc2hcblx0KiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBleHRyYWN0ZWQgY29kZWNcblx0Ki9cblx0Z2V0Q29kZWM6IGZ1bmN0aW9uIChoYXNoKSB7XG5cdFx0bGV0IGJ1ZmZlciA9IGhleFN0cmluZ1RvQnVmZmVyKGhhc2gpO1xuXHRcdHJldHVybiBtdWx0aUMuZ2V0Q29kZWMoYnVmZmVyKTtcblx0fSxcbn1cbiIsIi8qXG5cdElTQyBMaWNlbnNlXG5cblx0Q29weXJpZ2h0IChjKSAyMDE5LCBQaWVycmUtTG91aXMgRGVzcGFpZ25lXG5cblx0UGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5cdHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcblx0Y29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cblxuXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuXHRXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG5cdE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG5cdEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcblx0V0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG5cdEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG5cdE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qL1xuXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJyk7XG5jb25zdCBtdWx0aUggPSByZXF1aXJlKCdtdWx0aWhhc2hlcycpO1xuY29uc3QgYmFzZTY0ID0gcmVxdWlyZSgnanMtYmFzZTY0JylcblxuLyoqXG4gKiBDb252ZXJ0IGFuIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIEJ1ZmZlciwgdGhlIHN0cmluZyBjYW4gc3RhcnQgd2l0aCBvciB3aXRob3V0ICcweCdcbiAqIEBwYXJhbSB7c3RyaW5nfSBoZXggYW4gaGV4YWRlY2ltYWwgdmFsdWVcbiAqIEByZXR1cm4ge0J1ZmZlcn0gdGhlIHJlc3VsdGluZyBCdWZmZXJcbiAqL1xuY29uc3QgaGV4U3RyaW5nVG9CdWZmZXIgPSAoaGV4KSA9PiB7XG5cdGxldCBwcmVmaXggPSBoZXguc2xpY2UoMCwgMik7XG5cdGxldCB2YWx1ZSA9IGhleC5zbGljZSgyKTtcblx0bGV0IHJlcyA9ICcnO1xuXHRpZiAocHJlZml4ID09PSAnMHgnKSByZXMgPSB2YWx1ZTtcblx0ZWxzZSByZXMgPSBoZXg7XG5cdHJldHVybiBtdWx0aUguZnJvbUhleFN0cmluZyhyZXMpO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBJUE5TIGlkZW50aWZpZXIgIHRvIHNhZmVndWFyZCBhZ2FpbnN0IGluc2VjdXJlIG5hbWVzLlxuICogQHBhcmFtIHtDSUR9IG5hbWUgaXNlZCBpbiBpcG5zLW5zXG4gKiBAcmV0dXJuIHtib29sfVxuICovXG5jb25zdCBpc0NyeXB0b2dyYXBoaWNJUE5TID0gIChjaWQpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IG11bHRpaGFzaCB9ID0gY2lkXG4gICAgLy8gQWRkaXRpb25hbCBjaGVjayBmb3IgaWRlbnRpZmllcnMgc2hvcnRlclxuICAgIC8vIHRoYW4gd2hhdCBpbmxpbmVkIEVEMjU1MTkgcHVia2V5IHdvdWxkIGJlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Vuc2RvbWFpbnMvZW5zLWFwcC9pc3N1ZXMvODQ5I2lzc3VlY29tbWVudC03NzcwODg5NTBcbiAgICBpZiAobXVsdGloYXNoLmxlbmd0aCA8IDM4KSB7XG4gICAgICBjb25zdCBtaCA9IG11bHRpSC5kZWNvZGUobXVsdGloYXNoKVxuICAgICAgLy8gRUQyNTUxOSBwdWJrZXlzIGFyZSBpbmxpbmVkIHVzaW5nIGlkZW50aXR5IGhhc2ggZnVuY3Rpb25cbiAgICAgIC8vIGFuZCB3ZSBzaG91bGQgbm90IHNlZSBhbnl0aGluZyBzaG9ydGVyIHRoYW4gdGhhdFxuICAgICAgaWYgKG1oLm5hbWUgPT09ICdpZGVudGl0eScgJiYgbWgubGVuZ3RoIDwgMzYpIHtcbiAgICAgICAgLy8gT25lIGNhbiByZWFkIGlubGluZWQgc3RyaW5nIHZhbHVlIHZpYTpcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2lwbnMtbnMgaWQ6JywgU3RyaW5nKG11bHRpSC5kZWNvZGUobmV3IENJRCh2YWx1ZSkubXVsdGloYXNoKS5kaWdlc3QpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gb2ssIENJRCBsb29rcyBmaW5lXG4gICAgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCAoXykgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4qIGxpc3Qgb2Yga25vd24gZW5jb2RpbmcsXG4qIGVuY29kaW5nIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBgc3RyaW5nYCBpbnB1dCxcbiogYW5kIHJldHVybiBhIGBCdWZmZXJgIHJlc3VsdFxuKi9cbmNvbnN0IGVuY29kZXMgPSB7XG4gIC8qKlxuICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAqIEByZXR1cm4ge0J1ZmZlcn1cbiAgKi9cbiAgc2t5bmV0OiAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gYmFzZTY0LnRvVWludDhBcnJheSh2YWx1ZSlcbiAgfSxcbiAgLyoqXG4gICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICogQHJldHVybiB7QnVmZmVyfVxuICAqL1xuICBzd2FybTogKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgbXVsdGloYXNoID0gbXVsdGlILmVuY29kZShoZXhTdHJpbmdUb0J1ZmZlcih2YWx1ZSksICdrZWNjYWstMjU2Jyk7XG5cdFx0cmV0dXJuIG5ldyBDSUQoMSwgJ3N3YXJtLW1hbmlmZXN0JywgbXVsdGloYXNoKS5ieXRlcztcbiAgfSxcbiAgLyoqXG4gICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICogQHJldHVybiB7QnVmZmVyfVxuICAqL1xuICBpcGZzOiAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gbmV3IENJRCh2YWx1ZSkudG9WMSgpLmJ5dGVzO1xuICB9LFxuICAvKipcbiAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgKiBAcmV0dXJuIHtCdWZmZXJ9XG4gICovXG4gIGlwbnM6ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGNpZCA9IG5ldyBDSUQodmFsdWUpXG4gICAgaWYgKCFpc0NyeXB0b2dyYXBoaWNJUE5TKGNpZCkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2lwbnMtbnMgYWxsb3dzIG9ubHkgdmFsaWQgY3J5cHRvZ3JhcGhpYyBsaWJwMnAta2V5IGlkZW50aWZpZXJzLCB0cnkgdXNpbmcgRUQyNTUxOSBwdWJrZXkgaW5zdGVhZCcpXG4gICAgfVxuICAgIC8vIFJlcHJlc2VudCBJUE5TIG5hbWUgYXMgYSBDSUQgd2l0aCBsaWJwMnAta2V5IGNvZGVjXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2xpYnAycC9zcGVjcy9ibG9iL21hc3Rlci9SRkMvMDAwMS10ZXh0LXBlZXJpZC1jaWQubWRcbiAgICByZXR1cm4gbmV3IENJRCgxLCAnbGlicDJwLWtleScsIGNpZC5tdWx0aWhhc2gpLmJ5dGVzXG4gIH0sXG4gIC8qKlxuICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAqIEByZXR1cm4ge0J1ZmZlcn1cbiAgKi9cbiAgdXRmODogKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlLCAndXRmOCcpO1xuICB9LFxufTtcblxuLyoqIFxuKiBsaXN0IG9mIGtub3duIGRlY29kaW5nLFxuKiBkZWNvZGluZyBzaG91bGQgYmUgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgYEJ1ZmZlcmAgaW5wdXQsXG4qIGFuZCByZXR1cm4gYSBgc3RyaW5nYCByZXN1bHRcbiovXG5jb25zdCBkZWNvZGVzID0ge1xuICAvKipcbiAgKiBAcGFyYW0ge0J1ZmZlcn0gdmFsdWUgXG4gICovXG4gIGhleE11bHRpSGFzaDogKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgY2lkID0gbmV3IENJRCh2YWx1ZSk7XG4gICAgcmV0dXJuIG11bHRpSC5kZWNvZGUoY2lkLm11bHRpaGFzaCkuZGlnZXN0LnRvU3RyaW5nKCdoZXgnKTtcbiAgfSxcbiAgLyoqXG4gICogQHBhcmFtIHtCdWZmZXJ9IHZhbHVlIFxuICAqL1xuICBpcGZzOiAodmFsdWUpID0+IHtcbiAgICBjb25zdCBjaWQgPSBuZXcgQ0lEKHZhbHVlKS50b1YxKCk7XG4gICAgcmV0dXJuIGNpZC50b1N0cmluZyhjaWQuY29kZWMgPT09ICdsaWJwMnAta2V5JyA/ICdiYXNlMzYnIDogJ2Jhc2UzMicpXG4gIH0sXG4gIC8qKlxuICAqIEBwYXJhbSB7QnVmZmVyfSB2YWx1ZSBcbiAgKi9cbiAgaXBuczogKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgY2lkID0gbmV3IENJRCh2YWx1ZSkudG9WMSgpXG4gICAgaWYgKCFpc0NyeXB0b2dyYXBoaWNJUE5TKGNpZCkpIHtcbiAgICAgICAgLy8gVmFsdWUgaXMgbm90IGEgbGlicDJwLWtleSwgcmV0dXJuIG9yaWdpbmFsIHN0cmluZ1xuICAgICAgICBjb25zb2xlLndhcm4oJ1tlbnNkb21haW5zL2NvbnRlbnQtaGFzaF0gdXNlIG9mIG5vbi1jcnlwdG9ncmFwaGljIGlkZW50aWZpZXJzIGluIGlwbnMtbnMgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkLCBtaWdyYXRlIHRvIEVEMjU1MTkgbGlicDJwLWtleScpXG4gICAgICAgIHJldHVybiBTdHJpbmcobXVsdGlILmRlY29kZShuZXcgQ0lEKHZhbHVlKS5tdWx0aWhhc2gpLmRpZ2VzdClcbiAgICAgICAgLy8gVE9ETzogc3RhcnQgdGhyb3dpbmcgYW4gZXJyb3IgKGFmdGVyIHNvbWUgZGVwcmVjYXRpb24gcGVyaW9kKVxuICAgICAgICAvLyB0aHJvdyBFcnJvcignaXBucy1ucyBhbGxvd3Mgb25seSB2YWxpZCBjcnlwdG9ncmFwaGljIGxpYnAycC1rZXkgaWRlbnRpZmllcnMsIHRyeSB1c2luZyBFRDI1NTE5IHB1YmtleSBpbnN0ZWFkJylcbiAgICB9XG4gICAgcmV0dXJuIGNpZC50b1N0cmluZygnYmFzZTM2JylcbiAgfSxcbiAgLyoqXG4gICogQHBhcmFtIHtCdWZmZXJ9IHZhbHVlIFxuICAqL1xuICB1dGY4OiAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgfSxcbiAgYmFzZTY0OiAodmFsdWUpID0+IHtcbiAgICAvLyBgdHJ1ZWAgb3B0aW9uIG1ha2VzIGl0IFVSTCBzYWZlIChyZXBsYWNlcyAvIGFuZCArIHdpdGggLSBhbmQgXyApXG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tVWludDhBcnJheSh2YWx1ZSwgdHJ1ZSlcbiAgfVxufTtcblxuLyoqXG4qIGxpc3Qgb2Yga25vd24gZW5jb2RpbmcvZGVjb2RpbmcgZm9yIGEgZ2l2ZW4gY29kZWMsXG4qIGBlbmNvZGVgIHNob3VsZCBiZSBjaG9zZW4gYW1vbmcgdGhlIGBlbmNvZGVzYCBmdW5jdGlvbnNcbiogYGRlY29kZWAgc2hvdWxkIGJlIGNob3NlbiBhbW9uZyB0aGUgYGRlY29kZXNgIGZ1bmN0aW9uc1xuKi9cbmNvbnN0IHByb2ZpbGVzID0ge1xuICAnc2t5bmV0LW5zJzoge1xuICAgIGVuY29kZTogZW5jb2Rlcy5za3luZXQsXG4gICAgZGVjb2RlOiBkZWNvZGVzLmJhc2U2NCxcbiAgfSxcbiAgJ3N3YXJtLW5zJzoge1xuICAgIGVuY29kZTogZW5jb2Rlcy5zd2FybSxcbiAgICBkZWNvZGU6IGRlY29kZXMuaGV4TXVsdGlIYXNoLFxuICB9LFxuICAnaXBmcy1ucyc6IHtcbiAgICBlbmNvZGU6IGVuY29kZXMuaXBmcyxcbiAgICBkZWNvZGU6IGRlY29kZXMuaXBmcyxcbiAgfSxcbiAgJ2lwbnMtbnMnOiB7XG4gICAgZW5jb2RlOiBlbmNvZGVzLmlwbnMsXG4gICAgZGVjb2RlOiBkZWNvZGVzLmlwbnMsXG4gIH0sXG4gICdkZWZhdWx0Jzoge1xuICAgIGVuY29kZTogZW5jb2Rlcy51dGY4LFxuICAgIGRlY29kZTogZGVjb2Rlcy51dGY4LFxuICB9LFxufTtcblxuZXhwb3J0cy5oZXhTdHJpbmdUb0J1ZmZlciA9IGhleFN0cmluZ1RvQnVmZmVyO1xuZXhwb3J0cy5wcm9maWxlcyA9IHByb2ZpbGVzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIEhES2V5ID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2hka2V5JykpO1xudmFyIHV0aWwgPSByZXF1aXJlKCdAZXRoZXJldW1qcy91dGlsJyk7XG52YXIgcmxwID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3JscCcpKTtcbnZhciB0eCA9IHJlcXVpcmUoJ0BldGhlcmV1bWpzL3R4Jyk7XG52YXIgYmNVclJlZ2lzdHJ5RXRoID0gcmVxdWlyZSgnQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnktZXRoJyk7XG52YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQnKTtcblxuY29uc3Qga2V5cmluZ1R5cGUgPSBcIlFSIEhhcmR3YXJlIFdhbGxldCBEZXZpY2VcIjtcbmNvbnN0IHBhdGhCYXNlID0gXCJtXCI7XG5jb25zdCBNQVhfSU5ERVggPSAxMDAwO1xuY29uc3QgREVGQVVMVF9DSElMRFJFTl9QQVRIID0gXCIwLypcIjtcbnZhciBLRVlSSU5HX01PREU7XG5cbihmdW5jdGlvbiAoS0VZUklOR19NT0RFKSB7XG4gIEtFWVJJTkdfTU9ERVtcImhkXCJdID0gXCJoZFwiO1xuICBLRVlSSU5HX01PREVbXCJwdWJrZXlcIl0gPSBcInB1YmtleVwiO1xufSkoS0VZUklOR19NT0RFIHx8IChLRVlSSU5HX01PREUgPSB7fSkpO1xuXG52YXIgS0VZUklOR19BQ0NPVU5UO1xuXG4oZnVuY3Rpb24gKEtFWVJJTkdfQUNDT1VOVCkge1xuICBLRVlSSU5HX0FDQ09VTlRbXCJzdGFuZGFyZFwiXSA9IFwiYWNjb3VudC5zdGFuZGFyZFwiO1xuICBLRVlSSU5HX0FDQ09VTlRbXCJsZWRnZXJfbGl2ZVwiXSA9IFwiYWNjb3VudC5sZWRnZXJfbGl2ZVwiO1xuICBLRVlSSU5HX0FDQ09VTlRbXCJsZWRnZXJfbGVnYWN5XCJdID0gXCJhY2NvdW50LmxlZGdlcl9sZWdhY3lcIjtcbn0pKEtFWVJJTkdfQUNDT1VOVCB8fCAoS0VZUklOR19BQ0NPVU5UID0ge30pKTtcblxuY2xhc3MgQmFzZUtleXJpbmcge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMudmVyc2lvbiA9IDE7XG5cbiAgICB0aGlzLmdldEludGVyYWN0aW9uID0gKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2V4dGVuZHM6IG1ldGhvZCBnZXRJbnRlcmFjdGlvbiBub3QgaW1wbGVtZW50ZWQsIHBsZWFzZSBleHRlbmQgQmFzZUtleXJpbmcgYnkgb3ZlcndyaXRpbmcgdGhpcyBtZXRob2QuXCIpO1xuICAgIH07XG5cbiAgICB0aGlzLnR5cGUgPSBrZXlyaW5nVHlwZTtcblxuICAgIHRoaXMucmVxdWVzdFNpZ25hdHVyZSA9IGFzeW5jIChfcmVxdWVzdElkLCBzaWduUmVxdWVzdCwgcmVxdWVzdFRpdGxlLCByZXF1ZXN0RGVzY3JpcHRpb24pID0+IHtcbiAgICAgIGNvbnN0IGV0aFNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5yZXF1ZXN0U2lnbmF0dXJlKHNpZ25SZXF1ZXN0LCByZXF1ZXN0VGl0bGUsIHJlcXVlc3REZXNjcmlwdGlvbik7XG4gICAgICBjb25zdCByZXF1ZXN0SWRCdWZmZXIgPSBldGhTaWduYXR1cmUuZ2V0UmVxdWVzdElkKCk7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBldGhTaWduYXR1cmUuZ2V0U2lnbmF0dXJlKCk7XG5cbiAgICAgIGlmIChyZXF1ZXN0SWRCdWZmZXIpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gdXVpZC5zdHJpbmdpZnkocmVxdWVzdElkQnVmZmVyKTtcblxuICAgICAgICBpZiAocmVxdWVzdElkICE9PSBfcmVxdWVzdElkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6IHJlYWQgc2lnbmF0dXJlIGVycm9yOiBtaXNtYXRjaGVkIHJlcXVlc3RJZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCByID0gc2lnbmF0dXJlLnNsaWNlKDAsIDMyKTtcbiAgICAgIGNvbnN0IHMgPSBzaWduYXR1cmUuc2xpY2UoMzIsIDY0KTtcbiAgICAgIGNvbnN0IHYgPSBzaWduYXR1cmUuc2xpY2UoNjQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcixcbiAgICAgICAgcyxcbiAgICAgICAgdlxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdGhpcy5fX3JlYWRDcnlwdG9IREtleSA9IGNyeXB0b0hES2V5ID0+IHtcbiAgICAgIHZhciBfY3J5cHRvSERLZXkkZ2V0T3JpZ2ksIF9jcnlwdG9IREtleSRnZXRDaGlsZDtcblxuICAgICAgY29uc3QgaGRQYXRoID0gYG0vJHtjcnlwdG9IREtleS5nZXRPcmlnaW4oKS5nZXRQYXRoKCl9YDtcbiAgICAgIGNvbnN0IHhmcCA9IChfY3J5cHRvSERLZXkkZ2V0T3JpZ2kgPSBjcnlwdG9IREtleS5nZXRPcmlnaW4oKS5nZXRTb3VyY2VGaW5nZXJwcmludCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2NyeXB0b0hES2V5JGdldE9yaWdpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgY29uc3QgY2hpbGRyZW5QYXRoID0gKChfY3J5cHRvSERLZXkkZ2V0Q2hpbGQgPSBjcnlwdG9IREtleS5nZXRDaGlsZHJlbigpKSA9PSBudWxsID8gdm9pZCAwIDogX2NyeXB0b0hES2V5JGdldENoaWxkLmdldFBhdGgoKSkgfHwgREVGQVVMVF9DSElMRFJFTl9QQVRIO1xuICAgICAgY29uc3QgbmFtZSA9IGNyeXB0b0hES2V5LmdldE5hbWUoKTtcblxuICAgICAgaWYgKGNyeXB0b0hES2V5LmdldE5vdGUoKSA9PT0gS0VZUklOR19BQ0NPVU5ULnN0YW5kYXJkKSB7XG4gICAgICAgIHRoaXMua2V5cmluZ0FjY291bnQgPSBLRVlSSU5HX0FDQ09VTlQuc3RhbmRhcmQ7XG4gICAgICB9IGVsc2UgaWYgKGNyeXB0b0hES2V5LmdldE5vdGUoKSA9PT0gS0VZUklOR19BQ0NPVU5ULmxlZGdlcl9sZWdhY3kpIHtcbiAgICAgICAgdGhpcy5rZXlyaW5nQWNjb3VudCA9IEtFWVJJTkdfQUNDT1VOVC5sZWRnZXJfbGVnYWN5O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXhmcCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogaW52YWxpZCBjcnlwdG8taGRrZXksIGNhbm5vdCBnZXQgc291cmNlIGZpbmdlcnByaW50XCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB4cHViID0gY3J5cHRvSERLZXkuZ2V0QmlwMzJLZXkoKTtcbiAgICAgIHRoaXMueGZwID0geGZwO1xuICAgICAgdGhpcy54cHViID0geHB1YjtcbiAgICAgIHRoaXMuaGRQYXRoID0gaGRQYXRoO1xuICAgICAgdGhpcy5jaGlsZHJlblBhdGggPSBjaGlsZHJlblBhdGg7XG5cbiAgICAgIGlmIChuYW1lICE9PSB1bmRlZmluZWQgJiYgbmFtZSAhPT0gXCJcIikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdGhpcy5fX3JlYWRDcnlwdG9BY2NvdW50ID0gY3J5cHRvQWNjb3VudCA9PiB7XG4gICAgICB2YXIgX2NyeXB0b0FjY291bnQkZ2V0TWFzLCBfY3J5cHRvQWNjb3VudCRnZXRPdXQ7XG5cbiAgICAgIGNvbnN0IHhmcCA9IChfY3J5cHRvQWNjb3VudCRnZXRNYXMgPSBjcnlwdG9BY2NvdW50LmdldE1hc3RlckZpbmdlcnByaW50KCkpID09IG51bGwgPyB2b2lkIDAgOiBfY3J5cHRvQWNjb3VudCRnZXRNYXMudG9TdHJpbmcoXCJoZXhcIik7XG5cbiAgICAgIGlmICgheGZwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjaW52YWxpZF9kYXRhOiBpbnZhbGlkIGNyeXB0by1hY2NvdW50LCBjYW5ub3QgZ2V0IG1hc3RlciBmaW5nZXJwcmludFwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy54ZnAgPSB4ZnA7XG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICBjb25zdCBvdXRwdXRzID0gY3J5cHRvQWNjb3VudC5nZXRPdXRwdXREZXNjcmlwdG9ycygpO1xuXG4gICAgICBpZiAoIW91dHB1dHMgfHwgb3V0cHV0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6IGludmFsaWQgY3J5cHRvLWFjY291bnQsIG5vIGNyeXB0byBvdXRwdXQgZm91bmRcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChvdXRwdXRzLmxlbmd0aCAlIDUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6IG9ubHkgc3VwcG9ydCA1eCBwdWJrZXkgYWNjb3VudHMgZm9yIG5vd1wiKTtcbiAgICAgIH1cblxuICAgICAgKF9jcnlwdG9BY2NvdW50JGdldE91dCA9IGNyeXB0b0FjY291bnQuZ2V0T3V0cHV0RGVzY3JpcHRvcnMoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jcnlwdG9BY2NvdW50JGdldE91dC5mb3JFYWNoKG9kID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjcnlwdG9IREtleSA9IG9kLmdldEhES2V5KCk7XG5cbiAgICAgICAgICBpZiAoY3J5cHRvSERLZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGNyeXB0b0hES2V5LmdldEtleSgpO1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGBNLyR7Y3J5cHRvSERLZXkuZ2V0T3JpZ2luKCkuZ2V0UGF0aCgpfWA7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gXCIweFwiICsgdXRpbC5wdWJsaWNUb0FkZHJlc3Moa2V5LCB0cnVlKS50b1N0cmluZyhcImhleFwiKTtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IGNyeXB0b0hES2V5LmdldE5hbWUoKTtcblxuICAgICAgICAgICAgaWYgKGNyeXB0b0hES2V5LmdldE5vdGUoKSA9PT0gS0VZUklOR19BQ0NPVU5ULmxlZGdlcl9saXZlKSB7XG4gICAgICAgICAgICAgIHRoaXMua2V5cmluZ0FjY291bnQgPSBLRVlSSU5HX0FDQ09VTlQubGVkZ2VyX2xpdmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnBhdGhzW3V0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcyldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucGF0aHNbdXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKV0gPSBwYXRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9OyAvLyBwcml2YXRlIF9fcmVhZExlZGdlckxpdmVBY2NvdW50cyA9IGFzeW5jICgpID0+IHtcbiAgICAvLyAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXRJbnRlcmFjdGlvbigpLnJlYWRDcnlwdG9IREtleU9yQ3J5cHRvQWNjb3VudCgpO1xuICAgIC8vICAgICBpZiAocmVzdWx0LmdldFJlZ2lzdHJ5VHlwZSgpID09PSBleHRlbmQuUmVnaXN0cnlUeXBlcy5DUllQVE9fQUNDT1VOVCkge1xuICAgIC8vICAgICAgICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuX19yZWFkQ3J5cHRvQWNjb3VudChyZXN1bHQgYXMgQ3J5cHRvQWNjb3VudCk7XG4gICAgLy8gICAgICAgICBpZiAoIWNoYW5nZWQpIHtcbiAgICAvLyAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCNLZXlzdG9uZUVycm9yI3B1YmtleV9hY2NvdW50Lm5vX25ld19hY2NvdW50YCk7XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleXN0b25lRXJyb3IjcHVia2V5X2FjY291bnQudW5leHBlY3RlZF91cnR5cGVgKTtcbiAgICAvLyAgICAgfVxuICAgIC8vIH07XG5cblxuICAgIHRoaXMuZ2V0TmFtZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0QWNjb3VudFRvVW5sb2NrID0gaW5kZXggPT4ge1xuICAgICAgdGhpcy51bmxvY2tlZEFjY291bnQgPSBwYXJzZUludChpbmRleCwgMTApO1xuICAgIH07XG5cbiAgICB0aGlzLl9fZ2V0Tm9ybWFsUGFnZSA9IGFzeW5jIGluY3JlbWVudCA9PiB7XG4gICAgICB0aGlzLnBhZ2UgKz0gaW5jcmVtZW50O1xuXG4gICAgICBpZiAodGhpcy5wYWdlIDw9IDApIHtcbiAgICAgICAgdGhpcy5wYWdlID0gMTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZnJvbSA9ICh0aGlzLnBhZ2UgLSAxKSAqIHRoaXMucGVyUGFnZTtcbiAgICAgIGNvbnN0IHRvID0gZnJvbSArIHRoaXMucGVyUGFnZTtcbiAgICAgIGNvbnN0IGFjY291bnRzID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdGhpcy5fX2FkZHJlc3NGcm9tSW5kZXgocGF0aEJhc2UsIGkpO1xuICAgICAgICBhY2NvdW50cy5wdXNoKHtcbiAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgIGJhbGFuY2U6IG51bGwsXG4gICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5kZXhlc1t1dGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpXSA9IGk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2NvdW50cztcbiAgICB9O1xuXG4gICAgdGhpcy5fX2dldExlZGdlckxpdmVQYWdlID0gYXN5bmMgaW5jcmVtZW50ID0+IHtcbiAgICAgIGNvbnN0IG5leHRQYWdlID0gdGhpcy5wYWdlICsgaW5jcmVtZW50O1xuICAgICAgY29uc3QgZnJvbSA9IChuZXh0UGFnZSAtIDEpICogdGhpcy5wZXJQYWdlO1xuICAgICAgY29uc3QgdG8gPSBmcm9tICsgdGhpcy5wZXJQYWdlO1xuICAgICAgY29uc3QgYWNjb3VudHMgPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB0aGlzLl9fYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSk7XG4gICAgICAgIGFjY291bnRzLnB1c2goe1xuICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgYmFsYW5jZTogbnVsbCxcbiAgICAgICAgICBpbmRleDogaVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYWdlICs9IGluY3JlbWVudDtcbiAgICAgIHJldHVybiBhY2NvdW50cztcbiAgICB9O1xuXG4gICAgdGhpcy5fX2FkZHJlc3NGcm9tSW5kZXggPSBhc3luYyAocGIsIGkpID0+IHtcbiAgICAgIGlmICh0aGlzLmtleXJpbmdNb2RlID09PSBLRVlSSU5HX01PREUuaGQpIHtcbiAgICAgICAgdGhpcy5jaGVja0tleXJpbmcoKTtcblxuICAgICAgICBpZiAoIXRoaXMuaGRrKSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIHRoaXMuaGRrID0gSERLZXkuZnJvbUV4dGVuZGVkS2V5KHRoaXMueHB1Yik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaGlsZHJlblBhdGggPSB0aGlzLmNoaWxkcmVuUGF0aC5yZXBsYWNlKFwiKlwiLCBTdHJpbmcoaSkpLnJlcGxhY2UoL1xcKi9nLCBcIjBcIik7XG4gICAgICAgIGNvbnN0IGRrZXkgPSB0aGlzLmhkay5kZXJpdmUoYCR7cGJ9LyR7Y2hpbGRyZW5QYXRofWApO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gXCIweFwiICsgdXRpbC5wdWJsaWNUb0FkZHJlc3MoZGtleS5wdWJsaWNLZXksIHRydWUpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgICByZXR1cm4gdXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5rZXlzKHRoaXMucGF0aHMpW2ldO1xuXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbC50b0NoZWNrc3VtQWRkcmVzcyhyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5c3RvbmVFcnJvciNwdWJrZXlfYWNjb3VudC5ub19leHBlY3RlZF9hY2NvdW50YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9OyAvL2NvbW1vbiBwcm9wc1xuXG5cbiAgICB0aGlzLnBhZ2UgPSAwO1xuICAgIHRoaXMucGVyUGFnZSA9IDU7XG4gICAgdGhpcy5hY2NvdW50cyA9IFtdO1xuICAgIHRoaXMuY3VycmVudEFjY291bnQgPSAwO1xuICAgIHRoaXMudW5sb2NrZWRBY2NvdW50ID0gMDtcbiAgICB0aGlzLm5hbWUgPSBcIlFSIEhhcmR3YXJlXCI7XG4gICAgdGhpcy5rZXlyaW5nTW9kZSA9IEtFWVJJTkdfTU9ERS5oZDtcbiAgICB0aGlzLmtleXJpbmdBY2NvdW50ID0gS0VZUklOR19BQ0NPVU5ULnN0YW5kYXJkO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTsgLy9oZCBwcm9wcztcblxuICAgIHRoaXMueGZwID0gXCJcIjtcbiAgICB0aGlzLnhwdWIgPSBcIlwiO1xuICAgIHRoaXMuaGRQYXRoID0gXCJcIjtcbiAgICB0aGlzLmNoaWxkcmVuUGF0aCA9IERFRkFVTFRfQ0hJTERSRU5fUEFUSDtcbiAgICB0aGlzLmluZGV4ZXMgPSB7fTsgLy9wdWJrZXkgcHJvcHM7XG5cbiAgICB0aGlzLnBhdGhzID0ge307XG4gICAgdGhpcy5kZXNlcmlhbGl6ZShvcHRzKTtcbiAgfSAvL2luaXRpYWwgcmVhZFxuXG5cbiAgYXN5bmMgcmVhZEtleXJpbmcoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXRJbnRlcmFjdGlvbigpLnJlYWRDcnlwdG9IREtleU9yQ3J5cHRvQWNjb3VudCgpO1xuICAgIHRoaXMuc3luY0tleXJpbmcocmVzdWx0KTtcbiAgfVxuXG4gIHN5bmNLZXlyaW5nKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5nZXRSZWdpc3RyeVR5cGUoKS5nZXRUeXBlKCkgPT09IGJjVXJSZWdpc3RyeUV0aC5leHRlbmQuUmVnaXN0cnlUeXBlcy5DUllQVE9fSERLRVkuZ2V0VHlwZSgpKSB7XG4gICAgICB0aGlzLmtleXJpbmdNb2RlID0gS0VZUklOR19NT0RFLmhkO1xuXG4gICAgICB0aGlzLl9fcmVhZENyeXB0b0hES2V5KGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtleXJpbmdNb2RlID0gS0VZUklOR19NT0RFLnB1YmtleTtcblxuICAgICAgdGhpcy5fX3JlYWRDcnlwdG9BY2NvdW50KGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrS2V5cmluZygpIHtcbiAgICBpZiAoIXRoaXMueGZwIHx8ICF0aGlzLnhwdWIgfHwgIXRoaXMuaGRQYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfa2V5cmluZzoga2V5cmluZyBub3QgZnVsZmlsbGVkLCBwbGVhc2UgY2FsbCBmdW5jdGlvbiBgcmVhZEtleXJpbmdgIGZpcnN0bHlcIik7XG4gICAgfVxuICB9XG5cbiAgc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgLy9jb21tb25cbiAgICAgIGluaXRpYWxpemVkOiB0aGlzLmluaXRpYWxpemVkLFxuICAgICAgYWNjb3VudHM6IHRoaXMuYWNjb3VudHMsXG4gICAgICBjdXJyZW50QWNjb3VudDogdGhpcy5jdXJyZW50QWNjb3VudCxcbiAgICAgIHBhZ2U6IHRoaXMucGFnZSxcbiAgICAgIHBlclBhZ2U6IHRoaXMucGVyUGFnZSxcbiAgICAgIGtleXJpbmdBY2NvdW50OiB0aGlzLmtleXJpbmdBY2NvdW50LFxuICAgICAga2V5cmluZ01vZGU6IHRoaXMua2V5cmluZ01vZGUsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb24sXG4gICAgICB4ZnA6IHRoaXMueGZwLFxuICAgICAgLy9oZFxuICAgICAgeHB1YjogdGhpcy54cHViLFxuICAgICAgaGRQYXRoOiB0aGlzLmhkUGF0aCxcbiAgICAgIGNoaWxkcmVuUGF0aDogdGhpcy5jaGlsZHJlblBhdGgsXG4gICAgICBpbmRleGVzOiB0aGlzLmluZGV4ZXMsXG4gICAgICAvL3B1YmtleVxuICAgICAgcGF0aHM6IHRoaXMucGF0aHNcbiAgICB9KTtcbiAgfVxuXG4gIGRlc2VyaWFsaXplKG9wdHMpIHtcbiAgICBpZiAob3B0cykge1xuICAgICAgLy9jb21tb24gcHJvcHM7XG4gICAgICB0aGlzLmFjY291bnRzID0gb3B0cy5hY2NvdW50cztcbiAgICAgIHRoaXMuY3VycmVudEFjY291bnQgPSBvcHRzLmN1cnJlbnRBY2NvdW50O1xuICAgICAgdGhpcy5wYWdlID0gb3B0cy5wYWdlO1xuICAgICAgdGhpcy5wZXJQYWdlID0gb3B0cy5wZXJQYWdlO1xuICAgICAgdGhpcy5uYW1lID0gb3B0cy5uYW1lO1xuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IG9wdHMuaW5pdGlhbGl6ZWQ7XG4gICAgICB0aGlzLmtleXJpbmdNb2RlID0gb3B0cy5rZXlyaW5nTW9kZSB8fCBLRVlSSU5HX01PREUuaGQ7XG4gICAgICB0aGlzLmtleXJpbmdBY2NvdW50ID0gb3B0cy5rZXlyaW5nQWNjb3VudCB8fCBLRVlSSU5HX0FDQ09VTlQuc3RhbmRhcmQ7XG4gICAgICB0aGlzLnhmcCA9IG9wdHMueGZwOyAvL2hkIHByb3BzO1xuXG4gICAgICB0aGlzLnhwdWIgPSBvcHRzLnhwdWI7XG4gICAgICB0aGlzLmhkUGF0aCA9IG9wdHMuaGRQYXRoO1xuICAgICAgdGhpcy5pbmRleGVzID0gb3B0cy5pbmRleGVzO1xuICAgICAgdGhpcy5wYXRocyA9IG9wdHMucGF0aHM7XG4gICAgICB0aGlzLmNoaWxkcmVuUGF0aCA9IG9wdHMuY2hpbGRyZW5QYXRoIHx8IERFRkFVTFRfQ0hJTERSRU5fUEFUSDtcbiAgICB9XG4gIH1cblxuICBzZXRDdXJyZW50QWNjb3VudChpbmRleCkge1xuICAgIHRoaXMuY3VycmVudEFjY291bnQgPSBpbmRleDtcbiAgfVxuXG4gIGdldEN1cnJlbnRBY2NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRBY2NvdW50O1xuICB9XG5cbiAgZ2V0Q3VycmVudEFkZHJlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWNjb3VudHNbdGhpcy5jdXJyZW50QWNjb3VudF07XG4gIH1cblxuICBhc3luYyBhZGRBY2NvdW50cyhuID0gMSkge1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLnVubG9ja2VkQWNjb3VudDtcbiAgICBjb25zdCB0byA9IGZyb20gKyBuO1xuICAgIGNvbnN0IG5ld0FjY291bnRzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB0aGlzLl9fYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSk7XG4gICAgICBuZXdBY2NvdW50cy5wdXNoKGFkZHJlc3MpO1xuICAgICAgdGhpcy5wYWdlID0gMDtcbiAgICAgIHRoaXMudW5sb2NrZWRBY2NvdW50Kys7XG4gICAgfVxuXG4gICAgdGhpcy5hY2NvdW50cyA9IHRoaXMuYWNjb3VudHMuY29uY2F0KG5ld0FjY291bnRzKTtcbiAgICByZXR1cm4gdGhpcy5hY2NvdW50cztcbiAgfVxuXG4gIGdldEZpcnN0UGFnZSgpIHtcbiAgICB0aGlzLnBhZ2UgPSAwO1xuICAgIHJldHVybiB0aGlzLl9fZ2V0UGFnZSgxKTtcbiAgfVxuXG4gIGdldE5leHRQYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9fZ2V0UGFnZSgxKTtcbiAgfVxuXG4gIGdldFByZXZpb3VzUGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2dldFBhZ2UoLTEpO1xuICB9XG5cbiAgYXN5bmMgX19nZXRQYWdlKGluY3JlbWVudCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgYXdhaXQgdGhpcy5yZWFkS2V5cmluZygpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmtleXJpbmdNb2RlID09PSBLRVlSSU5HX01PREUuaGQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZ2V0Tm9ybWFsUGFnZShpbmNyZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2dldExlZGdlckxpdmVQYWdlKGluY3JlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0QWNjb3VudHMoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmFjY291bnRzKTtcbiAgfVxuXG4gIHJlbW92ZUFjY291bnQoYWRkcmVzcykge1xuICAgIGlmICghdGhpcy5hY2NvdW50cy5tYXAoYSA9PiBhLnRvTG93ZXJDYXNlKCkpLmluY2x1ZGVzKGFkZHJlc3MudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQWRkcmVzcyAke2FkZHJlc3N9IG5vdCBmb3VuZCBpbiB0aGlzIGtleXJpbmdgKTtcbiAgICB9XG5cbiAgICB0aGlzLmFjY291bnRzID0gdGhpcy5hY2NvdW50cy5maWx0ZXIoYSA9PiBhLnRvTG93ZXJDYXNlKCkgIT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gIH1cblxuICBhc3luYyBzaWduVHJhbnNhY3Rpb24oYWRkcmVzcywgdHgkMSkge1xuICAgIGNvbnN0IGRhdGFUeXBlID0gdHgkMS50eXBlID09PSAwID8gYmNVclJlZ2lzdHJ5RXRoLkRhdGFUeXBlLnRyYW5zYWN0aW9uIDogYmNVclJlZ2lzdHJ5RXRoLkRhdGFUeXBlLnR5cGVkVHJhbnNhY3Rpb247XG4gICAgbGV0IG1lc3NhZ2VUb1NpZ247XG5cbiAgICBpZiAodHgkMS50eXBlID09PSAwKSB7XG4gICAgICBtZXNzYWdlVG9TaWduID0gQnVmZmVyLmZyb20ocmxwLmVuY29kZSh0eCQxLmdldE1lc3NhZ2VUb1NpZ24oZmFsc2UpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2VUb1NpZ24gPSB0eCQxLmdldE1lc3NhZ2VUb1NpZ24oZmFsc2UpO1xuICAgIH1cblxuICAgIGNvbnN0IGhkUGF0aCA9IGF3YWl0IHRoaXMuX3BhdGhGcm9tQWRkcmVzcyhhZGRyZXNzKTtcbiAgICBjb25zdCBjaGFpbklkID0gTnVtYmVyKHR4JDEuY29tbW9uLmNoYWluSWQoKSk7XG4gICAgY29uc3QgcmVxdWVzdElkID0gdXVpZC52NCgpO1xuICAgIGNvbnN0IGV0aFNpZ25SZXF1ZXN0ID0gYmNVclJlZ2lzdHJ5RXRoLkV0aFNpZ25SZXF1ZXN0LmNvbnN0cnVjdEVUSFJlcXVlc3QobWVzc2FnZVRvU2lnbiwgZGF0YVR5cGUsIGhkUGF0aCwgdGhpcy54ZnAsIHJlcXVlc3RJZCwgY2hhaW5JZCk7XG4gICAgY29uc3Qge1xuICAgICAgcixcbiAgICAgIHMsXG4gICAgICB2XG4gICAgfSA9IGF3YWl0IHRoaXMucmVxdWVzdFNpZ25hdHVyZShyZXF1ZXN0SWQsIGV0aFNpZ25SZXF1ZXN0LCBcIlNjYW4gd2l0aCB5b3VyIEtleXN0b25lXCIsICdBZnRlciB5b3VyIEtleXN0b25lIGhhcyBzaWduZWQgdGhlIHRyYW5zYWN0aW9uLCBjbGljayBvbiBcIlNjYW4gS2V5c3RvbmVcIiB0byByZWNlaXZlIHRoZSBzaWduYXR1cmUnKTtcbiAgICByZXR1cm4gdHguVHJhbnNhY3Rpb25GYWN0b3J5LmZyb21UeERhdGEoeyAuLi50eCQxLnRvSlNPTigpLFxuICAgICAgdHlwZTogdHgkMS50eXBlLFxuICAgICAgcixcbiAgICAgIHMsXG4gICAgICB2XG4gICAgfSwge1xuICAgICAgY29tbW9uOiB0eCQxLmNvbW1vblxuICAgIH0pO1xuICB9XG5cbiAgc2lnbk1lc3NhZ2Uod2l0aEFjY291bnQsIGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5zaWduUGVyc29uYWxNZXNzYWdlKHdpdGhBY2NvdW50LCBkYXRhKTtcbiAgfVxuXG4gIGFzeW5jIHNpZ25QZXJzb25hbE1lc3NhZ2Uod2l0aEFjY291bnQsIG1lc3NhZ2VIZXgpIHtcbiAgICBjb25zdCB1c2lnbmVkSGV4ID0gdXRpbC5zdHJpcEhleFByZWZpeChtZXNzYWdlSGV4KTtcbiAgICBjb25zdCBoZFBhdGggPSBhd2FpdCB0aGlzLl9wYXRoRnJvbUFkZHJlc3Mod2l0aEFjY291bnQpO1xuICAgIGNvbnN0IHJlcXVlc3RJZCA9IHV1aWQudjQoKTtcbiAgICBjb25zdCBldGhTaWduUmVxdWVzdCA9IGJjVXJSZWdpc3RyeUV0aC5FdGhTaWduUmVxdWVzdC5jb25zdHJ1Y3RFVEhSZXF1ZXN0KEJ1ZmZlci5mcm9tKHVzaWduZWRIZXgsIFwiaGV4XCIpLCBiY1VyUmVnaXN0cnlFdGguRGF0YVR5cGUucGVyc29uYWxNZXNzYWdlLCBoZFBhdGgsIHRoaXMueGZwLCByZXF1ZXN0SWQsIHVuZGVmaW5lZCwgd2l0aEFjY291bnQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHIsXG4gICAgICBzLFxuICAgICAgdlxuICAgIH0gPSBhd2FpdCB0aGlzLnJlcXVlc3RTaWduYXR1cmUocmVxdWVzdElkLCBldGhTaWduUmVxdWVzdCwgXCJTY2FuIHdpdGggeW91ciBLZXlzdG9uZVwiLCAnQWZ0ZXIgeW91ciBLZXlzdG9uZSBoYXMgc2lnbmVkIHRoaXMgbWVzc2FnZSwgY2xpY2sgb24gXCJTY2FuIEtleXN0b25lXCIgdG8gcmVjZWl2ZSB0aGUgc2lnbmF0dXJlJyk7XG4gICAgcmV0dXJuIFwiMHhcIiArIEJ1ZmZlci5jb25jYXQoW3IsIHMsIHZdKS50b1N0cmluZyhcImhleFwiKTtcbiAgfVxuXG4gIGFzeW5jIHNpZ25UeXBlZERhdGEod2l0aEFjY291bnQsIHR5cGVkRGF0YSkge1xuICAgIGNvbnN0IGhkUGF0aCA9IGF3YWl0IHRoaXMuX3BhdGhGcm9tQWRkcmVzcyh3aXRoQWNjb3VudCk7XG4gICAgY29uc3QgcmVxdWVzdElkID0gdXVpZC52NCgpO1xuICAgIGNvbnN0IGV0aFNpZ25SZXF1ZXN0ID0gYmNVclJlZ2lzdHJ5RXRoLkV0aFNpZ25SZXF1ZXN0LmNvbnN0cnVjdEVUSFJlcXVlc3QoQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkodHlwZWREYXRhKSwgXCJ1dGYtOFwiKSwgYmNVclJlZ2lzdHJ5RXRoLkRhdGFUeXBlLnR5cGVkRGF0YSwgaGRQYXRoLCB0aGlzLnhmcCwgcmVxdWVzdElkLCB1bmRlZmluZWQsIHdpdGhBY2NvdW50KTtcbiAgICBjb25zdCB7XG4gICAgICByLFxuICAgICAgcyxcbiAgICAgIHZcbiAgICB9ID0gYXdhaXQgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlKHJlcXVlc3RJZCwgZXRoU2lnblJlcXVlc3QsIFwiU2NhbiB3aXRoIHlvdXIgS2V5c3RvbmVcIiwgJ0FmdGVyIHlvdXIgS2V5c3RvbmUgaGFzIHNpZ25lZCB0aGlzIGRhdGEsIGNsaWNrIG9uIFwiU2NhbiBLZXlzdG9uZVwiIHRvIHJlY2VpdmUgdGhlIHNpZ25hdHVyZScpO1xuICAgIHJldHVybiBcIjB4XCIgKyBCdWZmZXIuY29uY2F0KFtyLCBzLCB2XSkudG9TdHJpbmcoXCJoZXhcIik7XG4gIH1cblxuICBhc3luYyBfcGF0aEZyb21BZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBpZiAodGhpcy5rZXlyaW5nTW9kZSA9PT0gS0VZUklOR19NT0RFLmhkKSB7XG4gICAgICBjb25zdCBjaGVja3N1bW1lZEFkZHJlc3MgPSB1dGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgbGV0IGluZGV4ID0gdGhpcy5pbmRleGVzW2NoZWNrc3VtbWVkQWRkcmVzc107XG5cbiAgICAgIGlmICh0eXBlb2YgaW5kZXggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVhfSU5ERVg7IGkrKykge1xuICAgICAgICAgIGlmIChjaGVja3N1bW1lZEFkZHJlc3MgPT09IChhd2FpdCB0aGlzLl9fYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSkpKSB7XG4gICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGFkZHJlc3NcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBgJHt0aGlzLmhkUGF0aH0vJHt0aGlzLmNoaWxkcmVuUGF0aC5yZXBsYWNlKFwiKlwiLCBpbmRleC50b1N0cmluZygpKS5yZXBsYWNlKC9cXCovZywgXCIwXCIpfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoZWNrc3VtbWVkQWRkcmVzcyA9IHV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICBjb25zdCBwYXRoID0gdGhpcy5wYXRoc1tjaGVja3N1bW1lZEFkZHJlc3NdO1xuXG4gICAgICBpZiAodHlwZW9mIHBhdGggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBhZGRyZXNzXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gIH1cblxufVxuQmFzZUtleXJpbmcudHlwZSA9IGtleXJpbmdUeXBlO1xuXG5leHBvcnRzLkJhc2VLZXlyaW5nID0gQmFzZUtleXJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLWV0aC1rZXlyaW5nLmNqcy5kZXZlbG9wbWVudC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO2Z1bmN0aW9uIGUoZSl7cmV0dXJuIGUmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZcImRlZmF1bHRcImluIGU/ZS5kZWZhdWx0OmV9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHQscixpPWUocmVxdWlyZShcImhka2V5XCIpKSxzPXJlcXVpcmUoXCJAZXRoZXJldW1qcy91dGlsXCIpLG49ZShyZXF1aXJlKFwicmxwXCIpKSxhPXJlcXVpcmUoXCJAZXRoZXJldW1qcy90eFwiKSxvPXJlcXVpcmUoXCJAa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS1ldGhcIiksaD1yZXF1aXJlKFwidXVpZFwiKTshZnVuY3Rpb24oZSl7ZS5oZD1cImhkXCIsZS5wdWJrZXk9XCJwdWJrZXlcIn0odHx8KHQ9e30pKSxmdW5jdGlvbihlKXtlLnN0YW5kYXJkPVwiYWNjb3VudC5zdGFuZGFyZFwiLGUubGVkZ2VyX2xpdmU9XCJhY2NvdW50LmxlZGdlcl9saXZlXCIsZS5sZWRnZXJfbGVnYWN5PVwiYWNjb3VudC5sZWRnZXJfbGVnYWN5XCJ9KHJ8fChyPXt9KSk7Y2xhc3MgY3tjb25zdHJ1Y3RvcihlKXt0aGlzLnZlcnNpb249MSx0aGlzLmdldEludGVyYWN0aW9uPSgpPT57dGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2V4dGVuZHM6IG1ldGhvZCBnZXRJbnRlcmFjdGlvbiBub3QgaW1wbGVtZW50ZWQsIHBsZWFzZSBleHRlbmQgQmFzZUtleXJpbmcgYnkgb3ZlcndyaXRpbmcgdGhpcyBtZXRob2QuXCIpfSx0aGlzLnR5cGU9XCJRUiBIYXJkd2FyZSBXYWxsZXQgRGV2aWNlXCIsdGhpcy5yZXF1ZXN0U2lnbmF0dXJlPWFzeW5jKGUsdCxyLGkpPT57Y29uc3Qgcz1hd2FpdCB0aGlzLmdldEludGVyYWN0aW9uKCkucmVxdWVzdFNpZ25hdHVyZSh0LHIsaSksbj1zLmdldFJlcXVlc3RJZCgpLGE9cy5nZXRTaWduYXR1cmUoKTtpZihuJiZoLnN0cmluZ2lmeShuKSE9PWUpdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6IHJlYWQgc2lnbmF0dXJlIGVycm9yOiBtaXNtYXRjaGVkIHJlcXVlc3RJZFwiKTtyZXR1cm57cjphLnNsaWNlKDAsMzIpLHM6YS5zbGljZSgzMiw2NCksdjphLnNsaWNlKDY0KX19LHRoaXMuX19yZWFkQ3J5cHRvSERLZXk9ZT0+e3ZhciB0LGk7Y29uc3Qgcz1cIm0vXCIrZS5nZXRPcmlnaW4oKS5nZXRQYXRoKCksbj1udWxsPT0odD1lLmdldE9yaWdpbigpLmdldFNvdXJjZUZpbmdlcnByaW50KCkpP3ZvaWQgMDp0LnRvU3RyaW5nKFwiaGV4XCIpLGE9KG51bGw9PShpPWUuZ2V0Q2hpbGRyZW4oKSk/dm9pZCAwOmkuZ2V0UGF0aCgpKXx8XCIwLypcIixvPWUuZ2V0TmFtZSgpO2lmKGUuZ2V0Tm90ZSgpPT09ci5zdGFuZGFyZD90aGlzLmtleXJpbmdBY2NvdW50PXIuc3RhbmRhcmQ6ZS5nZXROb3RlKCk9PT1yLmxlZGdlcl9sZWdhY3kmJih0aGlzLmtleXJpbmdBY2NvdW50PXIubGVkZ2VyX2xlZ2FjeSksIW4pdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6IGludmFsaWQgY3J5cHRvLWhka2V5LCBjYW5ub3QgZ2V0IHNvdXJjZSBmaW5nZXJwcmludFwiKTtjb25zdCBoPWUuZ2V0QmlwMzJLZXkoKTt0aGlzLnhmcD1uLHRoaXMueHB1Yj1oLHRoaXMuaGRQYXRoPXMsdGhpcy5jaGlsZHJlblBhdGg9YSx2b2lkIDAhPT1vJiZcIlwiIT09byYmKHRoaXMubmFtZT1vKSx0aGlzLmluaXRpYWxpemVkPSEwfSx0aGlzLl9fcmVhZENyeXB0b0FjY291bnQ9ZT0+e3ZhciB0LGk7Y29uc3Qgbj1udWxsPT0odD1lLmdldE1hc3RlckZpbmdlcnByaW50KCkpP3ZvaWQgMDp0LnRvU3RyaW5nKFwiaGV4XCIpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjaW52YWxpZF9kYXRhOiBpbnZhbGlkIGNyeXB0by1hY2NvdW50LCBjYW5ub3QgZ2V0IG1hc3RlciBmaW5nZXJwcmludFwiKTt0aGlzLnhmcD1uLHRoaXMuaW5pdGlhbGl6ZWQ9ITA7bGV0IGE9ITE7Y29uc3Qgbz1lLmdldE91dHB1dERlc2NyaXB0b3JzKCk7aWYoIW98fDA9PT1vLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogaW52YWxpZCBjcnlwdG8tYWNjb3VudCwgbm8gY3J5cHRvIG91dHB1dCBmb3VuZFwiKTtpZihvLmxlbmd0aCU1IT0wKXRocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjaW52YWxpZF9kYXRhOiBvbmx5IHN1cHBvcnQgNXggcHVia2V5IGFjY291bnRzIGZvciBub3dcIik7cmV0dXJuIG51bGw9PShpPWUuZ2V0T3V0cHV0RGVzY3JpcHRvcnMoKSl8fGkuZm9yRWFjaChlPT57dHJ5e2NvbnN0IHQ9ZS5nZXRIREtleSgpO2lmKHQpe2NvbnN0IGU9dC5nZXRLZXkoKSxpPVwiTS9cIit0LmdldE9yaWdpbigpLmdldFBhdGgoKSxuPVwiMHhcIitzLnB1YmxpY1RvQWRkcmVzcyhlLCEwKS50b1N0cmluZyhcImhleFwiKTt0aGlzLm5hbWU9dC5nZXROYW1lKCksdC5nZXROb3RlKCk9PT1yLmxlZGdlcl9saXZlJiYodGhpcy5rZXlyaW5nQWNjb3VudD1yLmxlZGdlcl9saXZlKSx2b2lkIDA9PT10aGlzLnBhdGhzW3MudG9DaGVja3N1bUFkZHJlc3MobildJiYoYT0hMCksdGhpcy5wYXRoc1tzLnRvQ2hlY2tzdW1BZGRyZXNzKG4pXT1pfX1jYXRjaChlKXt0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogXCIrZSl9fSksYX0sdGhpcy5nZXROYW1lPSgpPT50aGlzLm5hbWUsdGhpcy5zZXRBY2NvdW50VG9VbmxvY2s9ZT0+e3RoaXMudW5sb2NrZWRBY2NvdW50PXBhcnNlSW50KGUsMTApfSx0aGlzLl9fZ2V0Tm9ybWFsUGFnZT1hc3luYyBlPT57dGhpcy5wYWdlKz1lLHRoaXMucGFnZTw9MCYmKHRoaXMucGFnZT0xKTtjb25zdCB0PSh0aGlzLnBhZ2UtMSkqdGhpcy5wZXJQYWdlLHI9dCt0aGlzLnBlclBhZ2UsaT1bXTtmb3IobGV0IGU9dDtlPHI7ZSsrKXtjb25zdCB0PWF3YWl0IHRoaXMuX19hZGRyZXNzRnJvbUluZGV4KFwibVwiLGUpO2kucHVzaCh7YWRkcmVzczp0LGJhbGFuY2U6bnVsbCxpbmRleDplfSksdGhpcy5pbmRleGVzW3MudG9DaGVja3N1bUFkZHJlc3ModCldPWV9cmV0dXJuIGl9LHRoaXMuX19nZXRMZWRnZXJMaXZlUGFnZT1hc3luYyBlPT57Y29uc3QgdD0odGhpcy5wYWdlK2UtMSkqdGhpcy5wZXJQYWdlLHI9dCt0aGlzLnBlclBhZ2UsaT1bXTtmb3IobGV0IGU9dDtlPHI7ZSsrKXtjb25zdCB0PWF3YWl0IHRoaXMuX19hZGRyZXNzRnJvbUluZGV4KFwibVwiLGUpO2kucHVzaCh7YWRkcmVzczp0LGJhbGFuY2U6bnVsbCxpbmRleDplfSl9cmV0dXJuIHRoaXMucGFnZSs9ZSxpfSx0aGlzLl9fYWRkcmVzc0Zyb21JbmRleD1hc3luYyhlLHIpPT57aWYodGhpcy5rZXlyaW5nTW9kZT09PXQuaGQpe3RoaXMuY2hlY2tLZXlyaW5nKCksdGhpcy5oZGt8fCh0aGlzLmhkaz1pLmZyb21FeHRlbmRlZEtleSh0aGlzLnhwdWIpKTtjb25zdCB0PXRoaXMuY2hpbGRyZW5QYXRoLnJlcGxhY2UoXCIqXCIsU3RyaW5nKHIpKS5yZXBsYWNlKC9cXCovZyxcIjBcIiksbj10aGlzLmhkay5kZXJpdmUoYCR7ZX0vJHt0fWApLGE9XCIweFwiK3MucHVibGljVG9BZGRyZXNzKG4ucHVibGljS2V5LCEwKS50b1N0cmluZyhcImhleFwiKTtyZXR1cm4gcy50b0NoZWNrc3VtQWRkcmVzcyhhKX17Y29uc3QgZT1PYmplY3Qua2V5cyh0aGlzLnBhdGhzKVtyXTtpZihlKXJldHVybiBzLnRvQ2hlY2tzdW1BZGRyZXNzKGUpO3Rocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjcHVia2V5X2FjY291bnQubm9fZXhwZWN0ZWRfYWNjb3VudFwiKX19LHRoaXMucGFnZT0wLHRoaXMucGVyUGFnZT01LHRoaXMuYWNjb3VudHM9W10sdGhpcy5jdXJyZW50QWNjb3VudD0wLHRoaXMudW5sb2NrZWRBY2NvdW50PTAsdGhpcy5uYW1lPVwiUVIgSGFyZHdhcmVcIix0aGlzLmtleXJpbmdNb2RlPXQuaGQsdGhpcy5rZXlyaW5nQWNjb3VudD1yLnN0YW5kYXJkLHRoaXMuaW5pdGlhbGl6ZWQ9ITEsdGhpcy54ZnA9XCJcIix0aGlzLnhwdWI9XCJcIix0aGlzLmhkUGF0aD1cIlwiLHRoaXMuY2hpbGRyZW5QYXRoPVwiMC8qXCIsdGhpcy5pbmRleGVzPXt9LHRoaXMucGF0aHM9e30sdGhpcy5kZXNlcmlhbGl6ZShlKX1hc3luYyByZWFkS2V5cmluZygpe2NvbnN0IGU9YXdhaXQgdGhpcy5nZXRJbnRlcmFjdGlvbigpLnJlYWRDcnlwdG9IREtleU9yQ3J5cHRvQWNjb3VudCgpO3RoaXMuc3luY0tleXJpbmcoZSl9c3luY0tleXJpbmcoZSl7ZS5nZXRSZWdpc3RyeVR5cGUoKS5nZXRUeXBlKCk9PT1vLmV4dGVuZC5SZWdpc3RyeVR5cGVzLkNSWVBUT19IREtFWS5nZXRUeXBlKCk/KHRoaXMua2V5cmluZ01vZGU9dC5oZCx0aGlzLl9fcmVhZENyeXB0b0hES2V5KGUpKToodGhpcy5rZXlyaW5nTW9kZT10LnB1YmtleSx0aGlzLl9fcmVhZENyeXB0b0FjY291bnQoZSkpfWNoZWNrS2V5cmluZygpe2lmKCF0aGlzLnhmcHx8IXRoaXMueHB1Ynx8IXRoaXMuaGRQYXRoKXRocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjaW52YWxpZF9rZXlyaW5nOiBrZXlyaW5nIG5vdCBmdWxmaWxsZWQsIHBsZWFzZSBjYWxsIGZ1bmN0aW9uIGByZWFkS2V5cmluZ2AgZmlyc3RseVwiKX1zZXJpYWxpemUoKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtpbml0aWFsaXplZDp0aGlzLmluaXRpYWxpemVkLGFjY291bnRzOnRoaXMuYWNjb3VudHMsY3VycmVudEFjY291bnQ6dGhpcy5jdXJyZW50QWNjb3VudCxwYWdlOnRoaXMucGFnZSxwZXJQYWdlOnRoaXMucGVyUGFnZSxrZXlyaW5nQWNjb3VudDp0aGlzLmtleXJpbmdBY2NvdW50LGtleXJpbmdNb2RlOnRoaXMua2V5cmluZ01vZGUsbmFtZTp0aGlzLm5hbWUsdmVyc2lvbjp0aGlzLnZlcnNpb24seGZwOnRoaXMueGZwLHhwdWI6dGhpcy54cHViLGhkUGF0aDp0aGlzLmhkUGF0aCxjaGlsZHJlblBhdGg6dGhpcy5jaGlsZHJlblBhdGgsaW5kZXhlczp0aGlzLmluZGV4ZXMscGF0aHM6dGhpcy5wYXRoc30pfWRlc2VyaWFsaXplKGUpe2UmJih0aGlzLmFjY291bnRzPWUuYWNjb3VudHMsdGhpcy5jdXJyZW50QWNjb3VudD1lLmN1cnJlbnRBY2NvdW50LHRoaXMucGFnZT1lLnBhZ2UsdGhpcy5wZXJQYWdlPWUucGVyUGFnZSx0aGlzLm5hbWU9ZS5uYW1lLHRoaXMuaW5pdGlhbGl6ZWQ9ZS5pbml0aWFsaXplZCx0aGlzLmtleXJpbmdNb2RlPWUua2V5cmluZ01vZGV8fHQuaGQsdGhpcy5rZXlyaW5nQWNjb3VudD1lLmtleXJpbmdBY2NvdW50fHxyLnN0YW5kYXJkLHRoaXMueGZwPWUueGZwLHRoaXMueHB1Yj1lLnhwdWIsdGhpcy5oZFBhdGg9ZS5oZFBhdGgsdGhpcy5pbmRleGVzPWUuaW5kZXhlcyx0aGlzLnBhdGhzPWUucGF0aHMsdGhpcy5jaGlsZHJlblBhdGg9ZS5jaGlsZHJlblBhdGh8fFwiMC8qXCIpfXNldEN1cnJlbnRBY2NvdW50KGUpe3RoaXMuY3VycmVudEFjY291bnQ9ZX1nZXRDdXJyZW50QWNjb3VudCgpe3JldHVybiB0aGlzLmN1cnJlbnRBY2NvdW50fWdldEN1cnJlbnRBZGRyZXNzKCl7cmV0dXJuIHRoaXMuYWNjb3VudHNbdGhpcy5jdXJyZW50QWNjb3VudF19YXN5bmMgYWRkQWNjb3VudHMoZT0xKXtjb25zdCB0PXRoaXMudW5sb2NrZWRBY2NvdW50LHI9dCtlLGk9W107Zm9yKGxldCBlPXQ7ZTxyO2UrKyl7Y29uc3QgdD1hd2FpdCB0aGlzLl9fYWRkcmVzc0Zyb21JbmRleChcIm1cIixlKTtpLnB1c2godCksdGhpcy5wYWdlPTAsdGhpcy51bmxvY2tlZEFjY291bnQrK31yZXR1cm4gdGhpcy5hY2NvdW50cz10aGlzLmFjY291bnRzLmNvbmNhdChpKSx0aGlzLmFjY291bnRzfWdldEZpcnN0UGFnZSgpe3JldHVybiB0aGlzLnBhZ2U9MCx0aGlzLl9fZ2V0UGFnZSgxKX1nZXROZXh0UGFnZSgpe3JldHVybiB0aGlzLl9fZ2V0UGFnZSgxKX1nZXRQcmV2aW91c1BhZ2UoKXtyZXR1cm4gdGhpcy5fX2dldFBhZ2UoLTEpfWFzeW5jIF9fZ2V0UGFnZShlKXtyZXR1cm4gdGhpcy5pbml0aWFsaXplZHx8YXdhaXQgdGhpcy5yZWFkS2V5cmluZygpLHRoaXMua2V5cmluZ01vZGU9PT10LmhkP3RoaXMuX19nZXROb3JtYWxQYWdlKGUpOnRoaXMuX19nZXRMZWRnZXJMaXZlUGFnZShlKX1nZXRBY2NvdW50cygpe3JldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5hY2NvdW50cyl9cmVtb3ZlQWNjb3VudChlKXtpZighdGhpcy5hY2NvdW50cy5tYXAoZT0+ZS50b0xvd2VyQ2FzZSgpKS5pbmNsdWRlcyhlLnRvTG93ZXJDYXNlKCkpKXRocm93IG5ldyBFcnJvcihgQWRkcmVzcyAke2V9IG5vdCBmb3VuZCBpbiB0aGlzIGtleXJpbmdgKTt0aGlzLmFjY291bnRzPXRoaXMuYWNjb3VudHMuZmlsdGVyKHQ9PnQudG9Mb3dlckNhc2UoKSE9PWUudG9Mb3dlckNhc2UoKSl9YXN5bmMgc2lnblRyYW5zYWN0aW9uKGUsdCl7Y29uc3Qgcj0wPT09dC50eXBlP28uRGF0YVR5cGUudHJhbnNhY3Rpb246by5EYXRhVHlwZS50eXBlZFRyYW5zYWN0aW9uO2xldCBpO2k9MD09PXQudHlwZT9CdWZmZXIuZnJvbShuLmVuY29kZSh0LmdldE1lc3NhZ2VUb1NpZ24oITEpKSk6dC5nZXRNZXNzYWdlVG9TaWduKCExKTtjb25zdCBzPWF3YWl0IHRoaXMuX3BhdGhGcm9tQWRkcmVzcyhlKSxjPU51bWJlcih0LmNvbW1vbi5jaGFpbklkKCkpLGQ9aC52NCgpLHU9by5FdGhTaWduUmVxdWVzdC5jb25zdHJ1Y3RFVEhSZXF1ZXN0KGkscixzLHRoaXMueGZwLGQsYykse3I6ZyxzOnksdjpwfT1hd2FpdCB0aGlzLnJlcXVlc3RTaWduYXR1cmUoZCx1LFwiU2NhbiB3aXRoIHlvdXIgS2V5c3RvbmVcIiwnQWZ0ZXIgeW91ciBLZXlzdG9uZSBoYXMgc2lnbmVkIHRoZSB0cmFuc2FjdGlvbiwgY2xpY2sgb24gXCJTY2FuIEtleXN0b25lXCIgdG8gcmVjZWl2ZSB0aGUgc2lnbmF0dXJlJyk7cmV0dXJuIGEuVHJhbnNhY3Rpb25GYWN0b3J5LmZyb21UeERhdGEoey4uLnQudG9KU09OKCksdHlwZTp0LnR5cGUscjpnLHM6eSx2OnB9LHtjb21tb246dC5jb21tb259KX1zaWduTWVzc2FnZShlLHQpe3JldHVybiB0aGlzLnNpZ25QZXJzb25hbE1lc3NhZ2UoZSx0KX1hc3luYyBzaWduUGVyc29uYWxNZXNzYWdlKGUsdCl7Y29uc3Qgcj1zLnN0cmlwSGV4UHJlZml4KHQpLGk9YXdhaXQgdGhpcy5fcGF0aEZyb21BZGRyZXNzKGUpLG49aC52NCgpLGE9by5FdGhTaWduUmVxdWVzdC5jb25zdHJ1Y3RFVEhSZXF1ZXN0KEJ1ZmZlci5mcm9tKHIsXCJoZXhcIiksby5EYXRhVHlwZS5wZXJzb25hbE1lc3NhZ2UsaSx0aGlzLnhmcCxuLHZvaWQgMCxlKSx7cjpjLHM6ZCx2OnV9PWF3YWl0IHRoaXMucmVxdWVzdFNpZ25hdHVyZShuLGEsXCJTY2FuIHdpdGggeW91ciBLZXlzdG9uZVwiLCdBZnRlciB5b3VyIEtleXN0b25lIGhhcyBzaWduZWQgdGhpcyBtZXNzYWdlLCBjbGljayBvbiBcIlNjYW4gS2V5c3RvbmVcIiB0byByZWNlaXZlIHRoZSBzaWduYXR1cmUnKTtyZXR1cm5cIjB4XCIrQnVmZmVyLmNvbmNhdChbYyxkLHVdKS50b1N0cmluZyhcImhleFwiKX1hc3luYyBzaWduVHlwZWREYXRhKGUsdCl7Y29uc3Qgcj1hd2FpdCB0aGlzLl9wYXRoRnJvbUFkZHJlc3MoZSksaT1oLnY0KCkscz1vLkV0aFNpZ25SZXF1ZXN0LmNvbnN0cnVjdEVUSFJlcXVlc3QoQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkodCksXCJ1dGYtOFwiKSxvLkRhdGFUeXBlLnR5cGVkRGF0YSxyLHRoaXMueGZwLGksdm9pZCAwLGUpLHtyOm4sczphLHY6Y309YXdhaXQgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlKGkscyxcIlNjYW4gd2l0aCB5b3VyIEtleXN0b25lXCIsJ0FmdGVyIHlvdXIgS2V5c3RvbmUgaGFzIHNpZ25lZCB0aGlzIGRhdGEsIGNsaWNrIG9uIFwiU2NhbiBLZXlzdG9uZVwiIHRvIHJlY2VpdmUgdGhlIHNpZ25hdHVyZScpO3JldHVyblwiMHhcIitCdWZmZXIuY29uY2F0KFtuLGEsY10pLnRvU3RyaW5nKFwiaGV4XCIpfWFzeW5jIF9wYXRoRnJvbUFkZHJlc3MoZSl7aWYodGhpcy5rZXlyaW5nTW9kZT09PXQuaGQpe2NvbnN0IHQ9cy50b0NoZWNrc3VtQWRkcmVzcyhlKTtsZXQgcj10aGlzLmluZGV4ZXNbdF07aWYodm9pZCAwPT09cilmb3IobGV0IGU9MDtlPDFlMztlKyspaWYodD09PWF3YWl0IHRoaXMuX19hZGRyZXNzRnJvbUluZGV4KFwibVwiLGUpKXtyPWU7YnJlYWt9aWYodm9pZCAwPT09cil0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGFkZHJlc3NcIik7cmV0dXJuYCR7dGhpcy5oZFBhdGh9LyR7dGhpcy5jaGlsZHJlblBhdGgucmVwbGFjZShcIipcIixyLnRvU3RyaW5nKCkpLnJlcGxhY2UoL1xcKi9nLFwiMFwiKX1gfXtjb25zdCB0PXMudG9DaGVja3N1bUFkZHJlc3MoZSkscj10aGlzLnBhdGhzW3RdO2lmKHZvaWQgMD09PXIpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBhZGRyZXNzXCIpO3JldHVybiByfX19Yy50eXBlPVwiUVIgSGFyZHdhcmUgV2FsbGV0IERldmljZVwiLGV4cG9ydHMuQmFzZUtleXJpbmc9Yztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UtZXRoLWtleXJpbmcuY2pzLnByb2R1Y3Rpb24ubWluLmpzLm1hcFxuIiwiXG4ndXNlIHN0cmljdCdcblxuaWYgKFwiZGV2ZWxvcG1lbnRcIiA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9iYXNlLWV0aC1rZXlyaW5nLmNqcy5wcm9kdWN0aW9uLm1pbi5qcycpXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYmFzZS1ldGgta2V5cmluZy5janMuZGV2ZWxvcG1lbnQuanMnKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIGJjVXJSZWdpc3RyeSA9IHJlcXVpcmUoJ0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5Jyk7XG52YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQnKTtcbnZhciBIREtleSA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdoZGtleScpKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnQGV0aGVyZXVtanMvdXRpbCcpO1xuXG5jb25zdCBFeHRlbmRlZFJlZ2lzdHJ5VHlwZXMgPSB7XG4gIEVUSF9TSUdOX1JFUVVFU1Q6IC8qI19fUFVSRV9fKi9uZXcgYmNVclJlZ2lzdHJ5LlJlZ2lzdHJ5VHlwZShcImV0aC1zaWduLXJlcXVlc3RcIiwgNDAxKSxcbiAgRVRIX1NJR05BVFVSRTogLyojX19QVVJFX18qL25ldyBiY1VyUmVnaXN0cnkuUmVnaXN0cnlUeXBlKFwiZXRoLXNpZ25hdHVyZVwiLCA0MDIpLFxuICBFVEhfTkZUX0lURU06IC8qI19fUFVSRV9fKi9uZXcgYmNVclJlZ2lzdHJ5LlJlZ2lzdHJ5VHlwZShcImV0aC1uZnQtaXRlbVwiLCA0MDMpXG59O1xuXG5jb25zdCB7XG4gIGRlY29kZVRvRGF0YUl0ZW0sXG4gIFJlZ2lzdHJ5VHlwZXNcbn0gPSBiY1VyUmVnaXN0cnkuZXh0ZW5kO1xudmFyIEtleXM7XG5cbihmdW5jdGlvbiAoS2V5cykge1xuICBLZXlzW0tleXNbXCJyZXF1ZXN0SWRcIl0gPSAxXSA9IFwicmVxdWVzdElkXCI7XG4gIEtleXNbS2V5c1tcInNpZ25EYXRhXCJdID0gMl0gPSBcInNpZ25EYXRhXCI7XG4gIEtleXNbS2V5c1tcImRhdGFUeXBlXCJdID0gM10gPSBcImRhdGFUeXBlXCI7XG4gIEtleXNbS2V5c1tcImNoYWluSWRcIl0gPSA0XSA9IFwiY2hhaW5JZFwiO1xuICBLZXlzW0tleXNbXCJkZXJpdmF0aW9uUGF0aFwiXSA9IDVdID0gXCJkZXJpdmF0aW9uUGF0aFwiO1xuICBLZXlzW0tleXNbXCJhZGRyZXNzXCJdID0gNl0gPSBcImFkZHJlc3NcIjtcbiAgS2V5c1tLZXlzW1wib3JpZ2luXCJdID0gN10gPSBcIm9yaWdpblwiO1xufSkoS2V5cyB8fCAoS2V5cyA9IHt9KSk7XG5cbihmdW5jdGlvbiAoRGF0YVR5cGUpIHtcbiAgRGF0YVR5cGVbRGF0YVR5cGVbXCJ0cmFuc2FjdGlvblwiXSA9IDFdID0gXCJ0cmFuc2FjdGlvblwiO1xuICBEYXRhVHlwZVtEYXRhVHlwZVtcInR5cGVkRGF0YVwiXSA9IDJdID0gXCJ0eXBlZERhdGFcIjtcbiAgRGF0YVR5cGVbRGF0YVR5cGVbXCJwZXJzb25hbE1lc3NhZ2VcIl0gPSAzXSA9IFwicGVyc29uYWxNZXNzYWdlXCI7XG4gIERhdGFUeXBlW0RhdGFUeXBlW1widHlwZWRUcmFuc2FjdGlvblwiXSA9IDRdID0gXCJ0eXBlZFRyYW5zYWN0aW9uXCI7XG59KShleHBvcnRzLkRhdGFUeXBlIHx8IChleHBvcnRzLkRhdGFUeXBlID0ge30pKTtcblxuY2xhc3MgRXRoU2lnblJlcXVlc3QgZXh0ZW5kcyBiY1VyUmVnaXN0cnkuUmVnaXN0cnlJdGVtIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IEV4dGVuZGVkUmVnaXN0cnlUeXBlcy5FVEhfU0lHTl9SRVFVRVNUO1xuXG4gICAgdGhpcy5nZXRSZXF1ZXN0SWQgPSAoKSA9PiB0aGlzLnJlcXVlc3RJZDtcblxuICAgIHRoaXMuZ2V0U2lnbkRhdGEgPSAoKSA9PiB0aGlzLnNpZ25EYXRhO1xuXG4gICAgdGhpcy5nZXREYXRhVHlwZSA9ICgpID0+IHRoaXMuZGF0YVR5cGU7XG5cbiAgICB0aGlzLmdldENoYWluSWQgPSAoKSA9PiB0aGlzLmNoYWluSWQ7XG5cbiAgICB0aGlzLmdldERlcml2YXRpb25QYXRoID0gKCkgPT4gdGhpcy5kZXJpdmF0aW9uUGF0aC5nZXRQYXRoKCk7XG5cbiAgICB0aGlzLmdldFNvdXJjZUZpbmdlcnByaW50ID0gKCkgPT4gdGhpcy5kZXJpdmF0aW9uUGF0aC5nZXRTb3VyY2VGaW5nZXJwcmludCgpO1xuXG4gICAgdGhpcy5nZXRTaWduUmVxdWVzdEFkZHJlc3MgPSAoKSA9PiB0aGlzLmFkZHJlc3M7XG5cbiAgICB0aGlzLmdldE9yaWdpbiA9ICgpID0+IHRoaXMub3JpZ2luO1xuXG4gICAgdGhpcy50b0RhdGFJdGVtID0gKCkgPT4ge1xuICAgICAgY29uc3QgbWFwID0ge307XG5cbiAgICAgIGlmICh0aGlzLnJlcXVlc3RJZCkge1xuICAgICAgICBtYXBbS2V5cy5yZXF1ZXN0SWRdID0gbmV3IGJjVXJSZWdpc3RyeS5EYXRhSXRlbSh0aGlzLnJlcXVlc3RJZCwgUmVnaXN0cnlUeXBlcy5VVUlELmdldFRhZygpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYWRkcmVzcykge1xuICAgICAgICBtYXBbS2V5cy5hZGRyZXNzXSA9IHRoaXMuYWRkcmVzcztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2hhaW5JZCkge1xuICAgICAgICBtYXBbS2V5cy5jaGFpbklkXSA9IHRoaXMuY2hhaW5JZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3JpZ2luKSB7XG4gICAgICAgIG1hcFtLZXlzLm9yaWdpbl0gPSB0aGlzLm9yaWdpbjtcbiAgICAgIH1cblxuICAgICAgbWFwW0tleXMuc2lnbkRhdGFdID0gdGhpcy5zaWduRGF0YTtcbiAgICAgIG1hcFtLZXlzLmRhdGFUeXBlXSA9IHRoaXMuZGF0YVR5cGU7XG4gICAgICBjb25zdCBrZXlQYXRoID0gdGhpcy5kZXJpdmF0aW9uUGF0aC50b0RhdGFJdGVtKCk7XG4gICAgICBrZXlQYXRoLnNldFRhZyh0aGlzLmRlcml2YXRpb25QYXRoLmdldFJlZ2lzdHJ5VHlwZSgpLmdldFRhZygpKTtcbiAgICAgIG1hcFtLZXlzLmRlcml2YXRpb25QYXRoXSA9IGtleVBhdGg7XG4gICAgICByZXR1cm4gbmV3IGJjVXJSZWdpc3RyeS5EYXRhSXRlbShtYXApO1xuICAgIH07XG5cbiAgICB0aGlzLnJlcXVlc3RJZCA9IGFyZ3MucmVxdWVzdElkO1xuICAgIHRoaXMuc2lnbkRhdGEgPSBhcmdzLnNpZ25EYXRhO1xuICAgIHRoaXMuZGF0YVR5cGUgPSBhcmdzLmRhdGFUeXBlO1xuICAgIHRoaXMuY2hhaW5JZCA9IGFyZ3MuY2hhaW5JZDtcbiAgICB0aGlzLmRlcml2YXRpb25QYXRoID0gYXJncy5kZXJpdmF0aW9uUGF0aDtcbiAgICB0aGlzLmFkZHJlc3MgPSBhcmdzLmFkZHJlc3M7XG4gICAgdGhpcy5vcmlnaW4gPSBhcmdzLm9yaWdpbjtcbiAgfVxuXG4gIHN0YXRpYyBjb25zdHJ1Y3RFVEhSZXF1ZXN0KHNpZ25EYXRhLCBzaWduRGF0YVR5cGUsIGhkUGF0aCwgeGZwLCB1dWlkU3RyaW5nLCBjaGFpbklkLCBhZGRyZXNzLCBvcmlnaW4pIHtcbiAgICBjb25zdCBwYXRocyA9IGhkUGF0aC5yZXBsYWNlKC9bbXxNXVxcLy8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICBjb25zdCBoZHBhdGhPYmplY3QgPSBuZXcgYmNVclJlZ2lzdHJ5LkNyeXB0b0tleXBhdGgocGF0aHMubWFwKHBhdGggPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChwYXRoLnJlcGxhY2UoXCInXCIsIFwiXCIpKTtcbiAgICAgIGxldCBpc0hhcmRlbmVkID0gZmFsc2U7XG5cbiAgICAgIGlmIChwYXRoLmVuZHNXaXRoKFwiJ1wiKSkge1xuICAgICAgICBpc0hhcmRlbmVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBiY1VyUmVnaXN0cnkuUGF0aENvbXBvbmVudCh7XG4gICAgICAgIGluZGV4LFxuICAgICAgICBoYXJkZW5lZDogaXNIYXJkZW5lZFxuICAgICAgfSk7XG4gICAgfSksIEJ1ZmZlci5mcm9tKHhmcCwgXCJoZXhcIikpO1xuICAgIHJldHVybiBuZXcgRXRoU2lnblJlcXVlc3Qoe1xuICAgICAgcmVxdWVzdElkOiB1dWlkU3RyaW5nID8gQnVmZmVyLmZyb20odXVpZC5wYXJzZSh1dWlkU3RyaW5nKSkgOiB1bmRlZmluZWQsXG4gICAgICBzaWduRGF0YSxcbiAgICAgIGRhdGFUeXBlOiBzaWduRGF0YVR5cGUsXG4gICAgICBkZXJpdmF0aW9uUGF0aDogaGRwYXRoT2JqZWN0LFxuICAgICAgY2hhaW5JZCxcbiAgICAgIGFkZHJlc3M6IGFkZHJlc3MgPyBCdWZmZXIuZnJvbShhZGRyZXNzLnJlcGxhY2UoXCIweFwiLCBcIlwiKSwgXCJoZXhcIikgOiB1bmRlZmluZWQsXG4gICAgICBvcmlnaW46IG9yaWdpbiB8fCB1bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuXG59XG5cbkV0aFNpZ25SZXF1ZXN0LmZyb21EYXRhSXRlbSA9IGRhdGFJdGVtID0+IHtcbiAgY29uc3QgbWFwID0gZGF0YUl0ZW0uZ2V0RGF0YSgpO1xuICBjb25zdCBzaWduRGF0YSA9IG1hcFtLZXlzLnNpZ25EYXRhXTtcbiAgY29uc3QgZGF0YVR5cGUgPSBtYXBbS2V5cy5kYXRhVHlwZV07XG4gIGNvbnN0IGRlcml2YXRpb25QYXRoID0gYmNVclJlZ2lzdHJ5LkNyeXB0b0tleXBhdGguZnJvbURhdGFJdGVtKG1hcFtLZXlzLmRlcml2YXRpb25QYXRoXSk7XG4gIGNvbnN0IGNoYWluSWQgPSBtYXBbS2V5cy5jaGFpbklkXSA/IG1hcFtLZXlzLmNoYWluSWRdIDogdW5kZWZpbmVkO1xuICBjb25zdCBhZGRyZXNzID0gbWFwW0tleXMuYWRkcmVzc10gPyBtYXBbS2V5cy5hZGRyZXNzXSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgcmVxdWVzdElkID0gbWFwW0tleXMucmVxdWVzdElkXSA/IG1hcFtLZXlzLnJlcXVlc3RJZF0uZ2V0RGF0YSgpIDogdW5kZWZpbmVkO1xuICBjb25zdCBvcmlnaW4gPSBtYXBbS2V5cy5vcmlnaW5dID8gbWFwW0tleXMub3JpZ2luXSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG5ldyBFdGhTaWduUmVxdWVzdCh7XG4gICAgcmVxdWVzdElkLFxuICAgIHNpZ25EYXRhLFxuICAgIGRhdGFUeXBlLFxuICAgIGNoYWluSWQsXG4gICAgZGVyaXZhdGlvblBhdGgsXG4gICAgYWRkcmVzcyxcbiAgICBvcmlnaW5cbiAgfSk7XG59O1xuXG5FdGhTaWduUmVxdWVzdC5mcm9tQ0JPUiA9IF9jYm9yUGF5bG9hZCA9PiB7XG4gIGNvbnN0IGRhdGFJdGVtID0gZGVjb2RlVG9EYXRhSXRlbShfY2JvclBheWxvYWQpO1xuICByZXR1cm4gRXRoU2lnblJlcXVlc3QuZnJvbURhdGFJdGVtKGRhdGFJdGVtKTtcbn07XG5cbmNvbnN0IHtcbiAgUmVnaXN0cnlUeXBlczogUmVnaXN0cnlUeXBlcyQxLFxuICBkZWNvZGVUb0RhdGFJdGVtOiBkZWNvZGVUb0RhdGFJdGVtJDFcbn0gPSBiY1VyUmVnaXN0cnkuZXh0ZW5kO1xudmFyIEtleXMkMTtcblxuKGZ1bmN0aW9uIChLZXlzKSB7XG4gIEtleXNbS2V5c1tcInJlcXVlc3RJZFwiXSA9IDFdID0gXCJyZXF1ZXN0SWRcIjtcbiAgS2V5c1tLZXlzW1wic2lnbmF0dXJlXCJdID0gMl0gPSBcInNpZ25hdHVyZVwiO1xuICBLZXlzW0tleXNbXCJvcmlnaW5cIl0gPSAzXSA9IFwib3JpZ2luXCI7XG59KShLZXlzJDEgfHwgKEtleXMkMSA9IHt9KSk7XG5cbmNsYXNzIEVUSFNpZ25hdHVyZSBleHRlbmRzIGJjVXJSZWdpc3RyeS5SZWdpc3RyeUl0ZW0ge1xuICBjb25zdHJ1Y3RvcihzaWduYXR1cmUsIHJlcXVlc3RJZCwgb3JpZ2luKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuZ2V0UmVnaXN0cnlUeXBlID0gKCkgPT4gRXh0ZW5kZWRSZWdpc3RyeVR5cGVzLkVUSF9TSUdOQVRVUkU7XG5cbiAgICB0aGlzLmdldFJlcXVlc3RJZCA9ICgpID0+IHRoaXMucmVxdWVzdElkO1xuXG4gICAgdGhpcy5nZXRTaWduYXR1cmUgPSAoKSA9PiB0aGlzLnNpZ25hdHVyZTtcblxuICAgIHRoaXMuZ2V0T3JpZ2luID0gKCkgPT4gdGhpcy5vcmlnaW47XG5cbiAgICB0aGlzLnRvRGF0YUl0ZW0gPSAoKSA9PiB7XG4gICAgICBjb25zdCBtYXAgPSB7fTtcblxuICAgICAgaWYgKHRoaXMucmVxdWVzdElkKSB7XG4gICAgICAgIG1hcFtLZXlzJDEucmVxdWVzdElkXSA9IG5ldyBiY1VyUmVnaXN0cnkuRGF0YUl0ZW0odGhpcy5yZXF1ZXN0SWQsIFJlZ2lzdHJ5VHlwZXMkMS5VVUlELmdldFRhZygpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3JpZ2luKSBtYXBbS2V5cyQxLm9yaWdpbl0gPSB0aGlzLm9yaWdpbjtcbiAgICAgIG1hcFtLZXlzJDEuc2lnbmF0dXJlXSA9IHRoaXMuc2lnbmF0dXJlO1xuICAgICAgcmV0dXJuIG5ldyBiY1VyUmVnaXN0cnkuRGF0YUl0ZW0obWFwKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gICAgdGhpcy5yZXF1ZXN0SWQgPSByZXF1ZXN0SWQ7XG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW47XG4gIH1cblxufVxuXG5FVEhTaWduYXR1cmUuZnJvbURhdGFJdGVtID0gZGF0YUl0ZW0gPT4ge1xuICBjb25zdCBtYXAgPSBkYXRhSXRlbS5nZXREYXRhKCk7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IG1hcFtLZXlzJDEuc2lnbmF0dXJlXTtcbiAgY29uc3QgcmVxdWVzdElkID0gbWFwW0tleXMkMS5yZXF1ZXN0SWRdID8gbWFwW0tleXMkMS5yZXF1ZXN0SWRdLmdldERhdGEoKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG5ldyBFVEhTaWduYXR1cmUoc2lnbmF0dXJlLCByZXF1ZXN0SWQsIG1hcFtLZXlzJDEub3JpZ2luXSk7XG59O1xuXG5FVEhTaWduYXR1cmUuZnJvbUNCT1IgPSBfY2JvclBheWxvYWQgPT4ge1xuICBjb25zdCBkYXRhSXRlbSA9IGRlY29kZVRvRGF0YUl0ZW0kMShfY2JvclBheWxvYWQpO1xuICByZXR1cm4gRVRIU2lnbmF0dXJlLmZyb21EYXRhSXRlbShkYXRhSXRlbSk7XG59O1xuXG5jb25zdCB7XG4gIGRlY29kZVRvRGF0YUl0ZW06IGRlY29kZVRvRGF0YUl0ZW0kMlxufSA9IGJjVXJSZWdpc3RyeS5leHRlbmQ7XG52YXIgS2V5cyQyO1xuXG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgS2V5c1tLZXlzW1wiY2hhaW5JZFwiXSA9IDFdID0gXCJjaGFpbklkXCI7XG4gIEtleXNbS2V5c1tcImNvbnRyYWN0QWRkcmVzc1wiXSA9IDJdID0gXCJjb250cmFjdEFkZHJlc3NcIjtcbiAgS2V5c1tLZXlzW1wiY29udHJhY3ROYW1lXCJdID0gM10gPSBcImNvbnRyYWN0TmFtZVwiO1xuICBLZXlzW0tleXNbXCJuYW1lXCJdID0gNF0gPSBcIm5hbWVcIjtcbiAgS2V5c1tLZXlzW1wibWVkaWFEYXRhXCJdID0gNV0gPSBcIm1lZGlhRGF0YVwiO1xufSkoS2V5cyQyIHx8IChLZXlzJDIgPSB7fSkpO1xuXG5jbGFzcyBFVEhORlRJdGVtIGV4dGVuZHMgYmNVclJlZ2lzdHJ5LlJlZ2lzdHJ5SXRlbSB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5nZXRSZWdpc3RyeVR5cGUgPSAoKSA9PiBFeHRlbmRlZFJlZ2lzdHJ5VHlwZXMuRVRIX05GVF9JVEVNO1xuXG4gICAgdGhpcy5nZXRDaGFpbklkID0gKCkgPT4gdGhpcy5jaGFpbklkO1xuXG4gICAgdGhpcy5nZXROYW1lID0gKCkgPT4gdGhpcy5uYW1lO1xuXG4gICAgdGhpcy5nZXRtZWRpYURhdGEgPSAoKSA9PiB0aGlzLm1lZGlhRGF0YTtcblxuICAgIHRoaXMuZ2V0Q29udHJhY3RBZGRyZXNzID0gKCkgPT4gdGhpcy5jb250cmFjdEFkZHJlc3M7XG5cbiAgICB0aGlzLmdldENvbnRyYWN0TmFtZSA9ICgpID0+IHRoaXMuY29udHJhY3ROYW1lO1xuXG4gICAgdGhpcy50b0RhdGFJdGVtID0gKCkgPT4ge1xuICAgICAgY29uc3QgbWFwID0ge307XG4gICAgICBtYXBbS2V5cyQyLmNoYWluSWRdID0gdGhpcy5jaGFpbklkO1xuICAgICAgbWFwW0tleXMkMi5uYW1lXSA9IHRoaXMubmFtZTtcbiAgICAgIG1hcFtLZXlzJDIuY29udHJhY3RBZGRyZXNzXSA9IHRoaXMuY29udHJhY3RBZGRyZXNzO1xuICAgICAgbWFwW0tleXMkMi5jb250cmFjdE5hbWVdID0gdGhpcy5jb250cmFjdE5hbWU7XG4gICAgICBtYXBbS2V5cyQyLm1lZGlhRGF0YV0gPSB0aGlzLm1lZGlhRGF0YTtcbiAgICAgIHJldHVybiBuZXcgYmNVclJlZ2lzdHJ5LkRhdGFJdGVtKG1hcCk7XG4gICAgfTtcblxuICAgIHRoaXMuY2hhaW5JZCA9IGFyZ3MuY2hhaW5JZDtcbiAgICB0aGlzLm5hbWUgPSBhcmdzLm5hbWU7XG4gICAgdGhpcy5jb250cmFjdEFkZHJlc3MgPSBhcmdzLmNvbnRyYWN0QWRkcmVzcztcbiAgICB0aGlzLmNvbnRyYWN0TmFtZSA9IGFyZ3MuY29udHJhY3ROYW1lO1xuICAgIHRoaXMubWVkaWFEYXRhID0gYXJncy5tZWRpYURhdGE7IC8vIHJlbW92ZSB0aGUgZGF0YSBwZXJmaXggZm9yIGFuZHJvaWQgdXNhZ2VcbiAgfVxuXG4gIHN0YXRpYyBjb25zdHJ1Y3RFVEhORlRJdGVtKGNoYWluSWQsIGNvbnRyYWN0QWRkcmVzcywgY29udHJhY3ROYW1lLCBuYW1lLCBtZWRpYURhdGEpIHtcbiAgICByZXR1cm4gbmV3IEVUSE5GVEl0ZW0oe1xuICAgICAgY2hhaW5JZCxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGNvbnRyYWN0TmFtZSxcbiAgICAgIG1lZGlhRGF0YSxcbiAgICAgIG5hbWVcbiAgICB9KTtcbiAgfVxuXG59XG5cbkVUSE5GVEl0ZW0uZnJvbURhdGFJdGVtID0gZGF0YUl0ZW0gPT4ge1xuICBjb25zdCBtYXAgPSBkYXRhSXRlbS5nZXREYXRhKCk7XG4gIGNvbnN0IGNoYWluSWQgPSBtYXBbS2V5cyQyLmNoYWluSWRdO1xuICBjb25zdCBuYW1lID0gbWFwW0tleXMkMi5uYW1lXTtcbiAgY29uc3QgbWVkaWFEYXRhID0gbWFwW0tleXMkMi5tZWRpYURhdGFdO1xuICBjb25zdCBjb250cmFjdEFkZHJlc3MgPSBtYXBbS2V5cyQyLmNvbnRyYWN0QWRkcmVzc107XG4gIGNvbnN0IGNvbnRyYWN0TmFtZSA9IG1hcFtLZXlzJDIuY29udHJhY3ROYW1lXTtcbiAgcmV0dXJuIG5ldyBFVEhORlRJdGVtKHtcbiAgICBjaGFpbklkLFxuICAgIG5hbWUsXG4gICAgY29udHJhY3RBZGRyZXNzLFxuICAgIGNvbnRyYWN0TmFtZSxcbiAgICBtZWRpYURhdGFcbiAgfSk7XG59O1xuXG5FVEhORlRJdGVtLmZyb21DQk9SID0gX2Nib3JQYXlsb2FkID0+IHtcbiAgY29uc3QgZGF0YUl0ZW0gPSBkZWNvZGVUb0RhdGFJdGVtJDIoX2Nib3JQYXlsb2FkKTtcbiAgcmV0dXJuIEVUSE5GVEl0ZW0uZnJvbURhdGFJdGVtKGRhdGFJdGVtKTtcbn07XG5cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGdlbmVyYXRlQWRkcmVzc0Zyb21YcHViID0gKHhwdWIsIGRlcml2ZVBhdGgpID0+IHtcbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBub2RlID0gSERLZXkuZnJvbUV4dGVuZGVkS2V5KHhwdWIpO1xuICBjb25zdCBwdWJsaWNLZXkgPSBub2RlLmRlcml2ZShkZXJpdmVQYXRoKTtcbiAgY29uc3QgYWRkcmVzcyA9IFwiMHhcIiArIHV0aWwucHVibGljVG9BZGRyZXNzKHB1YmxpY0tleS5wdWJsaWNLZXksIHRydWUpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICByZXR1cm4gdXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbn07XG5jb25zdCBmaW5kSERQYXRoRnJvbUFkZHJlc3MgPSAoYWRkcmVzcywgeHB1YiwgbnVtYmVyTGltaXQsIHJvb3RQYXRoKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyTGltaXQ7IGkrKykge1xuICAgIGNvbnN0IHBhdGggPSBgTS8wLyR7aX1gO1xuXG4gICAgY29uc3QgX2FkZHJlc3MgPSBnZW5lcmF0ZUFkZHJlc3NGcm9tWHB1Yih4cHViLCBwYXRoKTtcblxuICAgIGlmIChhZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT0gX2FkZHJlc3MudG9Mb3dlckNhc2UoKSkge1xuICAgICAgcmV0dXJuIGAke3Jvb3RQYXRofS8wLyR7aX1gO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuYmNVclJlZ2lzdHJ5LnBhdGNoVGFncyhPYmplY3QudmFsdWVzKEV4dGVuZGVkUmVnaXN0cnlUeXBlcykuZmlsdGVyKHJ0ID0+ICEhcnQuZ2V0VGFnKCkpLm1hcChydCA9PiBydC5nZXRUYWcoKSkpO1xuXG5PYmplY3Qua2V5cyhiY1VyUmVnaXN0cnkpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgaWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGJjVXJSZWdpc3RyeVtrXTtcbiAgICB9XG4gIH0pO1xufSk7XG5leHBvcnRzLkVUSE5GVEl0ZW0gPSBFVEhORlRJdGVtO1xuZXhwb3J0cy5FVEhTaWduYXR1cmUgPSBFVEhTaWduYXR1cmU7XG5leHBvcnRzLkV0aFNpZ25SZXF1ZXN0ID0gRXRoU2lnblJlcXVlc3Q7XG5leHBvcnRzLmZpbmRIRFBhdGhGcm9tQWRkcmVzcyA9IGZpbmRIRFBhdGhGcm9tQWRkcmVzcztcbmV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzRnJvbVhwdWIgPSBnZW5lcmF0ZUFkZHJlc3NGcm9tWHB1Yjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJjLXVyLXJlZ2lzdHJ5LWV0aC5janMuZGV2ZWxvcG1lbnQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdCxlPXJlcXVpcmUoXCJAa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeVwiKSxhPXJlcXVpcmUoXCJ1dWlkXCIpLHM9KHQ9cmVxdWlyZShcImhka2V5XCIpKSYmXCJvYmplY3RcIj09dHlwZW9mIHQmJlwiZGVmYXVsdFwiaW4gdD90LmRlZmF1bHQ6dCxpPXJlcXVpcmUoXCJAZXRoZXJldW1qcy91dGlsXCIpO2NvbnN0IHI9e0VUSF9TSUdOX1JFUVVFU1Q6bmV3IGUuUmVnaXN0cnlUeXBlKFwiZXRoLXNpZ24tcmVxdWVzdFwiLDQwMSksRVRIX1NJR05BVFVSRTpuZXcgZS5SZWdpc3RyeVR5cGUoXCJldGgtc2lnbmF0dXJlXCIsNDAyKSxFVEhfTkZUX0lURU06bmV3IGUuUmVnaXN0cnlUeXBlKFwiZXRoLW5mdC1pdGVtXCIsNDAzKX0se2RlY29kZVRvRGF0YUl0ZW06bixSZWdpc3RyeVR5cGVzOmR9PWUuZXh0ZW5kO3ZhciBvLGg7IWZ1bmN0aW9uKHQpe3RbdC5yZXF1ZXN0SWQ9MV09XCJyZXF1ZXN0SWRcIix0W3Quc2lnbkRhdGE9Ml09XCJzaWduRGF0YVwiLHRbdC5kYXRhVHlwZT0zXT1cImRhdGFUeXBlXCIsdFt0LmNoYWluSWQ9NF09XCJjaGFpbklkXCIsdFt0LmRlcml2YXRpb25QYXRoPTVdPVwiZGVyaXZhdGlvblBhdGhcIix0W3QuYWRkcmVzcz02XT1cImFkZHJlc3NcIix0W3Qub3JpZ2luPTddPVwib3JpZ2luXCJ9KG98fChvPXt9KSksKGg9ZXhwb3J0cy5EYXRhVHlwZXx8KGV4cG9ydHMuRGF0YVR5cGU9e30pKVtoLnRyYW5zYWN0aW9uPTFdPVwidHJhbnNhY3Rpb25cIixoW2gudHlwZWREYXRhPTJdPVwidHlwZWREYXRhXCIsaFtoLnBlcnNvbmFsTWVzc2FnZT0zXT1cInBlcnNvbmFsTWVzc2FnZVwiLGhbaC50eXBlZFRyYW5zYWN0aW9uPTRdPVwidHlwZWRUcmFuc2FjdGlvblwiO2NsYXNzIGMgZXh0ZW5kcyBlLlJlZ2lzdHJ5SXRlbXtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuZ2V0UmVnaXN0cnlUeXBlPSgpPT5yLkVUSF9TSUdOX1JFUVVFU1QsdGhpcy5nZXRSZXF1ZXN0SWQ9KCk9PnRoaXMucmVxdWVzdElkLHRoaXMuZ2V0U2lnbkRhdGE9KCk9PnRoaXMuc2lnbkRhdGEsdGhpcy5nZXREYXRhVHlwZT0oKT0+dGhpcy5kYXRhVHlwZSx0aGlzLmdldENoYWluSWQ9KCk9PnRoaXMuY2hhaW5JZCx0aGlzLmdldERlcml2YXRpb25QYXRoPSgpPT50aGlzLmRlcml2YXRpb25QYXRoLmdldFBhdGgoKSx0aGlzLmdldFNvdXJjZUZpbmdlcnByaW50PSgpPT50aGlzLmRlcml2YXRpb25QYXRoLmdldFNvdXJjZUZpbmdlcnByaW50KCksdGhpcy5nZXRTaWduUmVxdWVzdEFkZHJlc3M9KCk9PnRoaXMuYWRkcmVzcyx0aGlzLmdldE9yaWdpbj0oKT0+dGhpcy5vcmlnaW4sdGhpcy50b0RhdGFJdGVtPSgpPT57Y29uc3QgdD17fTt0aGlzLnJlcXVlc3RJZCYmKHRbby5yZXF1ZXN0SWRdPW5ldyBlLkRhdGFJdGVtKHRoaXMucmVxdWVzdElkLGQuVVVJRC5nZXRUYWcoKSkpLHRoaXMuYWRkcmVzcyYmKHRbby5hZGRyZXNzXT10aGlzLmFkZHJlc3MpLHRoaXMuY2hhaW5JZCYmKHRbby5jaGFpbklkXT10aGlzLmNoYWluSWQpLHRoaXMub3JpZ2luJiYodFtvLm9yaWdpbl09dGhpcy5vcmlnaW4pLHRbby5zaWduRGF0YV09dGhpcy5zaWduRGF0YSx0W28uZGF0YVR5cGVdPXRoaXMuZGF0YVR5cGU7Y29uc3QgYT10aGlzLmRlcml2YXRpb25QYXRoLnRvRGF0YUl0ZW0oKTtyZXR1cm4gYS5zZXRUYWcodGhpcy5kZXJpdmF0aW9uUGF0aC5nZXRSZWdpc3RyeVR5cGUoKS5nZXRUYWcoKSksdFtvLmRlcml2YXRpb25QYXRoXT1hLG5ldyBlLkRhdGFJdGVtKHQpfSx0aGlzLnJlcXVlc3RJZD10LnJlcXVlc3RJZCx0aGlzLnNpZ25EYXRhPXQuc2lnbkRhdGEsdGhpcy5kYXRhVHlwZT10LmRhdGFUeXBlLHRoaXMuY2hhaW5JZD10LmNoYWluSWQsdGhpcy5kZXJpdmF0aW9uUGF0aD10LmRlcml2YXRpb25QYXRoLHRoaXMuYWRkcmVzcz10LmFkZHJlc3MsdGhpcy5vcmlnaW49dC5vcmlnaW59c3RhdGljIGNvbnN0cnVjdEVUSFJlcXVlc3QodCxzLGkscixuLGQsbyxoKXtjb25zdCBnPWkucmVwbGFjZSgvW218TV1cXC8vLFwiXCIpLnNwbGl0KFwiL1wiKSx1PW5ldyBlLkNyeXB0b0tleXBhdGgoZy5tYXAodD0+e2NvbnN0IGE9cGFyc2VJbnQodC5yZXBsYWNlKFwiJ1wiLFwiXCIpKTtsZXQgcz0hMTtyZXR1cm4gdC5lbmRzV2l0aChcIidcIikmJihzPSEwKSxuZXcgZS5QYXRoQ29tcG9uZW50KHtpbmRleDphLGhhcmRlbmVkOnN9KX0pLEJ1ZmZlci5mcm9tKHIsXCJoZXhcIikpO3JldHVybiBuZXcgYyh7cmVxdWVzdElkOm4/QnVmZmVyLmZyb20oYS5wYXJzZShuKSk6dm9pZCAwLHNpZ25EYXRhOnQsZGF0YVR5cGU6cyxkZXJpdmF0aW9uUGF0aDp1LGNoYWluSWQ6ZCxhZGRyZXNzOm8/QnVmZmVyLmZyb20oby5yZXBsYWNlKFwiMHhcIixcIlwiKSxcImhleFwiKTp2b2lkIDAsb3JpZ2luOmh8fHZvaWQgMH0pfX1jLmZyb21EYXRhSXRlbT10PT57Y29uc3QgYT10LmdldERhdGEoKSxzPWFbby5zaWduRGF0YV0saT1hW28uZGF0YVR5cGVdLHI9ZS5DcnlwdG9LZXlwYXRoLmZyb21EYXRhSXRlbShhW28uZGVyaXZhdGlvblBhdGhdKSxuPWFbby5jaGFpbklkXT9hW28uY2hhaW5JZF06dm9pZCAwLGQ9YVtvLmFkZHJlc3NdP2Fbby5hZGRyZXNzXTp2b2lkIDAsaD1hW28ucmVxdWVzdElkXT9hW28ucmVxdWVzdElkXS5nZXREYXRhKCk6dm9pZCAwO3JldHVybiBuZXcgYyh7cmVxdWVzdElkOmgsc2lnbkRhdGE6cyxkYXRhVHlwZTppLGNoYWluSWQ6bixkZXJpdmF0aW9uUGF0aDpyLGFkZHJlc3M6ZCxvcmlnaW46YVtvLm9yaWdpbl0/YVtvLm9yaWdpbl06dm9pZCAwfSl9LGMuZnJvbUNCT1I9dD0+e2NvbnN0IGU9bih0KTtyZXR1cm4gYy5mcm9tRGF0YUl0ZW0oZSl9O2NvbnN0e1JlZ2lzdHJ5VHlwZXM6ZyxkZWNvZGVUb0RhdGFJdGVtOnV9PWUuZXh0ZW5kO3ZhciBtOyFmdW5jdGlvbih0KXt0W3QucmVxdWVzdElkPTFdPVwicmVxdWVzdElkXCIsdFt0LnNpZ25hdHVyZT0yXT1cInNpZ25hdHVyZVwiLHRbdC5vcmlnaW49M109XCJvcmlnaW5cIn0obXx8KG09e30pKTtjbGFzcyBJIGV4dGVuZHMgZS5SZWdpc3RyeUl0ZW17Y29uc3RydWN0b3IodCxhLHMpe3N1cGVyKCksdGhpcy5nZXRSZWdpc3RyeVR5cGU9KCk9PnIuRVRIX1NJR05BVFVSRSx0aGlzLmdldFJlcXVlc3RJZD0oKT0+dGhpcy5yZXF1ZXN0SWQsdGhpcy5nZXRTaWduYXR1cmU9KCk9PnRoaXMuc2lnbmF0dXJlLHRoaXMuZ2V0T3JpZ2luPSgpPT50aGlzLm9yaWdpbix0aGlzLnRvRGF0YUl0ZW09KCk9Pntjb25zdCB0PXt9O3JldHVybiB0aGlzLnJlcXVlc3RJZCYmKHRbbS5yZXF1ZXN0SWRdPW5ldyBlLkRhdGFJdGVtKHRoaXMucmVxdWVzdElkLGcuVVVJRC5nZXRUYWcoKSkpLHRoaXMub3JpZ2luJiYodFttLm9yaWdpbl09dGhpcy5vcmlnaW4pLHRbbS5zaWduYXR1cmVdPXRoaXMuc2lnbmF0dXJlLG5ldyBlLkRhdGFJdGVtKHQpfSx0aGlzLnNpZ25hdHVyZT10LHRoaXMucmVxdWVzdElkPWEsdGhpcy5vcmlnaW49c319SS5mcm9tRGF0YUl0ZW09dD0+e2NvbnN0IGU9dC5nZXREYXRhKCksYT1lW20uc2lnbmF0dXJlXSxzPWVbbS5yZXF1ZXN0SWRdP2VbbS5yZXF1ZXN0SWRdLmdldERhdGEoKTp2b2lkIDA7cmV0dXJuIG5ldyBJKGEscyxlW20ub3JpZ2luXSl9LEkuZnJvbUNCT1I9dD0+e2NvbnN0IGU9dSh0KTtyZXR1cm4gSS5mcm9tRGF0YUl0ZW0oZSl9O2NvbnN0e2RlY29kZVRvRGF0YUl0ZW06cH09ZS5leHRlbmQ7dmFyIEQ7IWZ1bmN0aW9uKHQpe3RbdC5jaGFpbklkPTFdPVwiY2hhaW5JZFwiLHRbdC5jb250cmFjdEFkZHJlc3M9Ml09XCJjb250cmFjdEFkZHJlc3NcIix0W3QuY29udHJhY3ROYW1lPTNdPVwiY29udHJhY3ROYW1lXCIsdFt0Lm5hbWU9NF09XCJuYW1lXCIsdFt0Lm1lZGlhRGF0YT01XT1cIm1lZGlhRGF0YVwifShEfHwoRD17fSkpO2NsYXNzIFQgZXh0ZW5kcyBlLlJlZ2lzdHJ5SXRlbXtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuZ2V0UmVnaXN0cnlUeXBlPSgpPT5yLkVUSF9ORlRfSVRFTSx0aGlzLmdldENoYWluSWQ9KCk9PnRoaXMuY2hhaW5JZCx0aGlzLmdldE5hbWU9KCk9PnRoaXMubmFtZSx0aGlzLmdldG1lZGlhRGF0YT0oKT0+dGhpcy5tZWRpYURhdGEsdGhpcy5nZXRDb250cmFjdEFkZHJlc3M9KCk9PnRoaXMuY29udHJhY3RBZGRyZXNzLHRoaXMuZ2V0Q29udHJhY3ROYW1lPSgpPT50aGlzLmNvbnRyYWN0TmFtZSx0aGlzLnRvRGF0YUl0ZW09KCk9Pntjb25zdCB0PXt9O3JldHVybiB0W0QuY2hhaW5JZF09dGhpcy5jaGFpbklkLHRbRC5uYW1lXT10aGlzLm5hbWUsdFtELmNvbnRyYWN0QWRkcmVzc109dGhpcy5jb250cmFjdEFkZHJlc3MsdFtELmNvbnRyYWN0TmFtZV09dGhpcy5jb250cmFjdE5hbWUsdFtELm1lZGlhRGF0YV09dGhpcy5tZWRpYURhdGEsbmV3IGUuRGF0YUl0ZW0odCl9LHRoaXMuY2hhaW5JZD10LmNoYWluSWQsdGhpcy5uYW1lPXQubmFtZSx0aGlzLmNvbnRyYWN0QWRkcmVzcz10LmNvbnRyYWN0QWRkcmVzcyx0aGlzLmNvbnRyYWN0TmFtZT10LmNvbnRyYWN0TmFtZSx0aGlzLm1lZGlhRGF0YT10Lm1lZGlhRGF0YX1zdGF0aWMgY29uc3RydWN0RVRITkZUSXRlbSh0LGUsYSxzLGkpe3JldHVybiBuZXcgVCh7Y2hhaW5JZDp0LGNvbnRyYWN0QWRkcmVzczplLGNvbnRyYWN0TmFtZTphLG1lZGlhRGF0YTppLG5hbWU6c30pfX1ULmZyb21EYXRhSXRlbT10PT57Y29uc3QgZT10LmdldERhdGEoKTtyZXR1cm4gbmV3IFQoe2NoYWluSWQ6ZVtELmNoYWluSWRdLG5hbWU6ZVtELm5hbWVdLGNvbnRyYWN0QWRkcmVzczplW0QuY29udHJhY3RBZGRyZXNzXSxjb250cmFjdE5hbWU6ZVtELmNvbnRyYWN0TmFtZV0sbWVkaWFEYXRhOmVbRC5tZWRpYURhdGFdfSl9LFQuZnJvbUNCT1I9dD0+e2NvbnN0IGU9cCh0KTtyZXR1cm4gVC5mcm9tRGF0YUl0ZW0oZSl9O2NvbnN0IHk9KHQsZSk9Pntjb25zdCBhPXMuZnJvbUV4dGVuZGVkS2V5KHQpLmRlcml2ZShlKSxyPVwiMHhcIitpLnB1YmxpY1RvQWRkcmVzcyhhLnB1YmxpY0tleSwhMCkudG9TdHJpbmcoXCJoZXhcIik7cmV0dXJuIGkudG9DaGVja3N1bUFkZHJlc3Mocil9O2UucGF0Y2hUYWdzKE9iamVjdC52YWx1ZXMocikuZmlsdGVyKHQ9PiEhdC5nZXRUYWcoKSkubWFwKHQ9PnQuZ2V0VGFnKCkpKSxPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChmdW5jdGlvbih0KXtcImRlZmF1bHRcIiE9PXQmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLHQse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGVbdF19fSl9KSksZXhwb3J0cy5FVEhORlRJdGVtPVQsZXhwb3J0cy5FVEhTaWduYXR1cmU9SSxleHBvcnRzLkV0aFNpZ25SZXF1ZXN0PWMsZXhwb3J0cy5maW5kSERQYXRoRnJvbUFkZHJlc3M9KHQsZSxhLHMpPT57Zm9yKGxldCBpPTA7aTxhO2krKyl7Y29uc3QgYT15KGUsXCJNLzAvXCIraSk7aWYodC50b0xvd2VyQ2FzZSgpPT1hLnRvTG93ZXJDYXNlKCkpcmV0dXJuYCR7c30vMC8ke2l9YH1yZXR1cm4gbnVsbH0sZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3NGcm9tWHB1Yj15O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmMtdXItcmVnaXN0cnktZXRoLmNqcy5wcm9kdWN0aW9uLm1pbi5qcy5tYXBcbiIsIlxuJ3VzZSBzdHJpY3QnXG5cbmlmIChcImRldmVsb3BtZW50XCIgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYmMtdXItcmVnaXN0cnktZXRoLmNqcy5wcm9kdWN0aW9uLm1pbi5qcycpXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYmMtdXItcmVnaXN0cnktZXRoLmNqcy5kZXZlbG9wbWVudC5qcycpXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnl0ZXMgPSB2b2lkIDA7XG5jb25zdCBsaWJfMSA9IHJlcXVpcmUoXCIuL2xpYlwiKTtcbmNvbnN0IFJlZ2lzdHJ5SXRlbV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlJdGVtXCIpO1xuY29uc3QgUmVnaXN0cnlUeXBlXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeVR5cGVcIik7XG5jbGFzcyBCeXRlcyBleHRlbmRzIFJlZ2lzdHJ5SXRlbV8xLlJlZ2lzdHJ5SXRlbSB7XG4gICAgY29uc3RydWN0b3IoYnl0ZXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ieXRlcyA9IGJ5dGVzO1xuICAgICAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkJZVEVTO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldERhdGEgPSAoKSA9PiB0aGlzLmJ5dGVzO1xuICAgICAgICB0aGlzLnRvRGF0YUl0ZW0gPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGxpYl8xLkRhdGFJdGVtKHRoaXMuYnl0ZXMpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQnl0ZXMgPSBCeXRlcztcbkJ5dGVzLmZyb21EYXRhSXRlbSA9IChkYXRhSXRlbSkgPT4ge1xuICAgIGNvbnN0IGJ5dGVzID0gZGF0YUl0ZW0uZ2V0RGF0YSgpO1xuICAgIGlmICghYnl0ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAjW3VyLXJlZ2lzdHJ5XVtCeXRlc11bZm4uZnJvbURhdGFJdGVtXTogZGVjb2RlZCBbZGF0YUl0ZW1dWyNkYXRhXSBpcyB1bmRlZmluZWQ6ICR7ZGF0YUl0ZW19YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQnl0ZXMoYnl0ZXMpO1xufTtcbkJ5dGVzLmZyb21DQk9SID0gKF9jYm9yUGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IGRhdGFJdGVtID0gKDAsIGxpYl8xLmRlY29kZVRvRGF0YUl0ZW0pKF9jYm9yUGF5bG9hZCk7XG4gICAgcmV0dXJuIEJ5dGVzLmZyb21EYXRhSXRlbShkYXRhSXRlbSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qnl0ZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNyeXB0b0FjY291bnQgPSB2b2lkIDA7XG5jb25zdCBfMSA9IHJlcXVpcmUoXCIuXCIpO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi9saWJcIik7XG5jb25zdCBSZWdpc3RyeUl0ZW1fMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5SXRlbVwiKTtcbmNvbnN0IFJlZ2lzdHJ5VHlwZV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlUeXBlXCIpO1xudmFyIEtleXM7XG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgICBLZXlzW0tleXNbXCJtYXN0ZXJGaW5nZXJwcmludFwiXSA9IDFdID0gXCJtYXN0ZXJGaW5nZXJwcmludFwiO1xuICAgIEtleXNbS2V5c1tcIm91dHB1dERlc2NyaXB0b3JzXCJdID0gMl0gPSBcIm91dHB1dERlc2NyaXB0b3JzXCI7XG59KShLZXlzIHx8IChLZXlzID0ge30pKTtcbmNsYXNzIENyeXB0b0FjY291bnQgZXh0ZW5kcyBSZWdpc3RyeUl0ZW1fMS5SZWdpc3RyeUl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKG1hc3RlckZpbmdlcnByaW50LCBvdXRwdXREZXNjcmlwdG9ycykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1hc3RlckZpbmdlcnByaW50ID0gbWFzdGVyRmluZ2VycHJpbnQ7XG4gICAgICAgIHRoaXMub3V0cHV0RGVzY3JpcHRvcnMgPSBvdXRwdXREZXNjcmlwdG9ycztcbiAgICAgICAgdGhpcy5nZXRSZWdpc3RyeVR5cGUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fQUNDT1VOVDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRNYXN0ZXJGaW5nZXJwcmludCA9ICgpID0+IHRoaXMubWFzdGVyRmluZ2VycHJpbnQ7XG4gICAgICAgIHRoaXMuZ2V0T3V0cHV0RGVzY3JpcHRvcnMgPSAoKSA9PiB0aGlzLm91dHB1dERlc2NyaXB0b3JzO1xuICAgICAgICB0aGlzLnRvRGF0YUl0ZW0gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hc3RlckZpbmdlcnByaW50KSB7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMubWFzdGVyRmluZ2VycHJpbnRdID0gdGhpcy5tYXN0ZXJGaW5nZXJwcmludC5yZWFkVUludDMyQkUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXREZXNjcmlwdG9ycykge1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLm91dHB1dERlc2NyaXB0b3JzXSA9IHRoaXMub3V0cHV0RGVzY3JpcHRvcnMubWFwKChpdGVtKSA9PiBpdGVtLnRvRGF0YUl0ZW0oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IGxpYl8xLkRhdGFJdGVtKG1hcCk7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5DcnlwdG9BY2NvdW50ID0gQ3J5cHRvQWNjb3VudDtcbkNyeXB0b0FjY291bnQuZnJvbURhdGFJdGVtID0gKGRhdGFJdGVtKSA9PiB7XG4gICAgY29uc3QgbWFwID0gZGF0YUl0ZW0uZ2V0RGF0YSgpO1xuICAgIGNvbnN0IG1hc3RlckZpbmdlcnByaW50ID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIGNvbnN0IF9tYXN0ZXJGaW5nZXJwcmludCA9IG1hcFtLZXlzLm1hc3RlckZpbmdlcnByaW50XTtcbiAgICBpZiAoX21hc3RlckZpbmdlcnByaW50KSB7XG4gICAgICAgIG1hc3RlckZpbmdlcnByaW50LndyaXRlVUludDMyQkUoX21hc3RlckZpbmdlcnByaW50LCAwKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0RGVzY3JpcHRvcnMgPSBtYXBbS2V5cy5vdXRwdXREZXNjcmlwdG9yc107XG4gICAgY29uc3QgY3J5cHRvT3V0cHV0cyA9IG91dHB1dERlc2NyaXB0b3JzLm1hcCgoaXRlbSkgPT4gXzEuQ3J5cHRvT3V0cHV0LmZyb21EYXRhSXRlbShpdGVtKSk7XG4gICAgcmV0dXJuIG5ldyBDcnlwdG9BY2NvdW50KG1hc3RlckZpbmdlcnByaW50LCBjcnlwdG9PdXRwdXRzKTtcbn07XG5DcnlwdG9BY2NvdW50LmZyb21DQk9SID0gKF9jYm9yUGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IGRhdGFJdGVtID0gKDAsIGxpYl8xLmRlY29kZVRvRGF0YUl0ZW0pKF9jYm9yUGF5bG9hZCk7XG4gICAgcmV0dXJuIENyeXB0b0FjY291bnQuZnJvbURhdGFJdGVtKGRhdGFJdGVtKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DcnlwdG9BY2NvdW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DcnlwdG9Db2luSW5mbyA9IGV4cG9ydHMuTmV0d29yayA9IGV4cG9ydHMuVHlwZSA9IHZvaWQgMDtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4vbGliXCIpO1xuY29uc3QgUmVnaXN0cnlJdGVtXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeUl0ZW1cIik7XG5jb25zdCBSZWdpc3RyeVR5cGVfMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5VHlwZVwiKTtcbnZhciBLZXlzO1xuKGZ1bmN0aW9uIChLZXlzKSB7XG4gICAgS2V5c1tcInR5cGVcIl0gPSBcIjFcIjtcbiAgICBLZXlzW1wibmV0d29ya1wiXSA9IFwiMlwiO1xufSkoS2V5cyB8fCAoS2V5cyA9IHt9KSk7XG52YXIgVHlwZTtcbihmdW5jdGlvbiAoVHlwZSkge1xuICAgIFR5cGVbVHlwZVtcImJpdGNvaW5cIl0gPSAwXSA9IFwiYml0Y29pblwiO1xufSkoVHlwZSA9IGV4cG9ydHMuVHlwZSB8fCAoZXhwb3J0cy5UeXBlID0ge30pKTtcbnZhciBOZXR3b3JrO1xuKGZ1bmN0aW9uIChOZXR3b3JrKSB7XG4gICAgTmV0d29ya1tOZXR3b3JrW1wibWFpbm5ldFwiXSA9IDBdID0gXCJtYWlubmV0XCI7XG4gICAgTmV0d29ya1tOZXR3b3JrW1widGVzdG5ldFwiXSA9IDFdID0gXCJ0ZXN0bmV0XCI7XG59KShOZXR3b3JrID0gZXhwb3J0cy5OZXR3b3JrIHx8IChleHBvcnRzLk5ldHdvcmsgPSB7fSkpO1xuY2xhc3MgQ3J5cHRvQ29pbkluZm8gZXh0ZW5kcyBSZWdpc3RyeUl0ZW1fMS5SZWdpc3RyeUl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIG5ldHdvcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5uZXR3b3JrID0gbmV0d29yaztcbiAgICAgICAgdGhpcy5nZXRSZWdpc3RyeVR5cGUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fQ09JTl9JTkZPO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFR5cGUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlIHx8IFR5cGUuYml0Y29pbjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXROZXR3b3JrID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV0d29yayB8fCBOZXR3b3JrLm1haW5uZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudG9EYXRhSXRlbSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLnR5cGVdID0gdGhpcy50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubmV0d29yaykge1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLm5ldHdvcmtdID0gdGhpcy5uZXR3b3JrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBsaWJfMS5EYXRhSXRlbShtYXApO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ3J5cHRvQ29pbkluZm8gPSBDcnlwdG9Db2luSW5mbztcbkNyeXB0b0NvaW5JbmZvLmZyb21EYXRhSXRlbSA9IChkYXRhSXRlbSkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IGRhdGFJdGVtLmdldERhdGEoKTtcbiAgICBjb25zdCB0eXBlID0gbWFwW0tleXMudHlwZV07XG4gICAgY29uc3QgbmV0d29yayA9IG1hcFtLZXlzLm5ldHdvcmtdO1xuICAgIHJldHVybiBuZXcgQ3J5cHRvQ29pbkluZm8odHlwZSwgbmV0d29yayk7XG59O1xuQ3J5cHRvQ29pbkluZm8uZnJvbUNCT1IgPSAoX2Nib3JQYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgZGF0YUl0ZW0gPSAoMCwgbGliXzEuZGVjb2RlVG9EYXRhSXRlbSkoX2Nib3JQYXlsb2FkKTtcbiAgICByZXR1cm4gQ3J5cHRvQ29pbkluZm8uZnJvbURhdGFJdGVtKGRhdGFJdGVtKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DcnlwdG9Db2luSW5mby5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ3J5cHRvRUNLZXkgPSB2b2lkIDA7XG5jb25zdCBsaWJfMSA9IHJlcXVpcmUoXCIuL2xpYlwiKTtcbmNvbnN0IFJlZ2lzdHJ5SXRlbV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlJdGVtXCIpO1xuY29uc3QgUmVnaXN0cnlUeXBlXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeVR5cGVcIik7XG52YXIgS2V5cztcbihmdW5jdGlvbiAoS2V5cykge1xuICAgIEtleXNbS2V5c1tcImN1cnZlXCJdID0gMV0gPSBcImN1cnZlXCI7XG4gICAgS2V5c1tLZXlzW1wicHJpdmF0ZVwiXSA9IDJdID0gXCJwcml2YXRlXCI7XG4gICAgS2V5c1tLZXlzW1wiZGF0YVwiXSA9IDNdID0gXCJkYXRhXCI7XG59KShLZXlzIHx8IChLZXlzID0ge30pKTtcbmNsYXNzIENyeXB0b0VDS2V5IGV4dGVuZHMgUmVnaXN0cnlJdGVtXzEuUmVnaXN0cnlJdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaXNFQ0tleSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldEN1cnZlID0gKCkgPT4gdGhpcy5jdXJ2ZSB8fCAwO1xuICAgICAgICB0aGlzLmlzUHJpdmF0ZUtleSA9ICgpID0+IHRoaXMucHJpdmF0ZUtleSB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5nZXREYXRhID0gKCkgPT4gdGhpcy5kYXRhO1xuICAgICAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19FQ0tFWTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b0RhdGFJdGVtID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWFwID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJ2ZSkge1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLmN1cnZlXSA9IHRoaXMuY3VydmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wcml2YXRlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXBbS2V5cy5wcml2YXRlXSA9IHRoaXMucHJpdmF0ZUtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcFtLZXlzLmRhdGFdID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBsaWJfMS5EYXRhSXRlbShtYXApO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE91dHB1dERlc2NyaXB0b3JDb250ZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGF0YSA9IGFyZ3MuZGF0YTtcbiAgICAgICAgdGhpcy5jdXJ2ZSA9IGFyZ3MuY3VydmU7XG4gICAgICAgIHRoaXMucHJpdmF0ZUtleSA9IGFyZ3MucHJpdmF0ZUtleSB8fCB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5DcnlwdG9FQ0tleSA9IENyeXB0b0VDS2V5O1xuQ3J5cHRvRUNLZXkuZnJvbURhdGFJdGVtID0gKGRhdGFJdGVtKSA9PiB7XG4gICAgY29uc3QgbWFwID0gZGF0YUl0ZW0uZ2V0RGF0YSgpO1xuICAgIGNvbnN0IGN1cnZlID0gbWFwW0tleXMuY3VydmVdO1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBtYXBbS2V5cy5wcml2YXRlXTtcbiAgICBjb25zdCBkYXRhID0gbWFwW0tleXMuZGF0YV07XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgI1t1ci1yZWdpc3RyeV1bQ3J5cHRvRUNLZXldW2ZuLmZyb21EYXRhSXRlbV06IGRlY29kZWQgW2RhdGFJdGVtXVsjZGF0YS5kYXRhXSBpcyB1bmRlZmluZWQ6ICR7ZGF0YUl0ZW19YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ3J5cHRvRUNLZXkoeyBkYXRhLCBjdXJ2ZSwgcHJpdmF0ZUtleSB9KTtcbn07XG5DcnlwdG9FQ0tleS5mcm9tQ0JPUiA9IChfY2JvclBheWxvYWQpID0+IHtcbiAgICBjb25zdCBkYXRhSXRlbSA9ICgwLCBsaWJfMS5kZWNvZGVUb0RhdGFJdGVtKShfY2JvclBheWxvYWQpO1xuICAgIHJldHVybiBDcnlwdG9FQ0tleS5mcm9tRGF0YUl0ZW0oZGF0YUl0ZW0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNyeXB0b0VDS2V5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DcnlwdG9IREtleSA9IHZvaWQgMDtcbmNvbnN0IGJzNThjaGVja18xID0gcmVxdWlyZShcImJzNThjaGVja1wiKTtcbmNvbnN0IENyeXB0b0NvaW5JbmZvXzEgPSByZXF1aXJlKFwiLi9DcnlwdG9Db2luSW5mb1wiKTtcbmNvbnN0IENyeXB0b0tleXBhdGhfMSA9IHJlcXVpcmUoXCIuL0NyeXB0b0tleXBhdGhcIik7XG5jb25zdCBsaWJfMSA9IHJlcXVpcmUoXCIuL2xpYlwiKTtcbmNvbnN0IFJlZ2lzdHJ5SXRlbV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlJdGVtXCIpO1xuY29uc3QgUmVnaXN0cnlUeXBlXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeVR5cGVcIik7XG52YXIgS2V5cztcbihmdW5jdGlvbiAoS2V5cykge1xuICAgIEtleXNbS2V5c1tcImlzX21hc3RlclwiXSA9IDFdID0gXCJpc19tYXN0ZXJcIjtcbiAgICBLZXlzW0tleXNbXCJpc19wcml2YXRlXCJdID0gMl0gPSBcImlzX3ByaXZhdGVcIjtcbiAgICBLZXlzW0tleXNbXCJrZXlfZGF0YVwiXSA9IDNdID0gXCJrZXlfZGF0YVwiO1xuICAgIEtleXNbS2V5c1tcImNoYWluX2NvZGVcIl0gPSA0XSA9IFwiY2hhaW5fY29kZVwiO1xuICAgIEtleXNbS2V5c1tcInVzZV9pbmZvXCJdID0gNV0gPSBcInVzZV9pbmZvXCI7XG4gICAgS2V5c1tLZXlzW1wib3JpZ2luXCJdID0gNl0gPSBcIm9yaWdpblwiO1xuICAgIEtleXNbS2V5c1tcImNoaWxkcmVuXCJdID0gN10gPSBcImNoaWxkcmVuXCI7XG4gICAgS2V5c1tLZXlzW1wicGFyZW50X2ZpbmdlcnByaW50XCJdID0gOF0gPSBcInBhcmVudF9maW5nZXJwcmludFwiO1xuICAgIEtleXNbS2V5c1tcIm5hbWVcIl0gPSA5XSA9IFwibmFtZVwiO1xuICAgIEtleXNbS2V5c1tcIm5vdGVcIl0gPSAxMF0gPSBcIm5vdGVcIjtcbn0pKEtleXMgfHwgKEtleXMgPSB7fSkpO1xuY2xhc3MgQ3J5cHRvSERLZXkgZXh0ZW5kcyBSZWdpc3RyeUl0ZW1fMS5SZWdpc3RyeUl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pc0VDS2V5ID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldEtleSA9ICgpID0+IHRoaXMua2V5O1xuICAgICAgICB0aGlzLmdldENoYWluQ29kZSA9ICgpID0+IHRoaXMuY2hhaW5Db2RlO1xuICAgICAgICB0aGlzLmlzTWFzdGVyID0gKCkgPT4gdGhpcy5tYXN0ZXI7XG4gICAgICAgIHRoaXMuaXNQcml2YXRlS2V5ID0gKCkgPT4gISF0aGlzLnByaXZhdGVLZXk7XG4gICAgICAgIHRoaXMuZ2V0VXNlSW5mbyA9ICgpID0+IHRoaXMudXNlSW5mbztcbiAgICAgICAgdGhpcy5nZXRPcmlnaW4gPSAoKSA9PiB0aGlzLm9yaWdpbjtcbiAgICAgICAgdGhpcy5nZXRDaGlsZHJlbiA9ICgpID0+IHRoaXMuY2hpbGRyZW47XG4gICAgICAgIHRoaXMuZ2V0UGFyZW50RmluZ2VycHJpbnQgPSAoKSA9PiB0aGlzLnBhcmVudEZpbmdlcnByaW50O1xuICAgICAgICB0aGlzLmdldE5hbWUgPSAoKSA9PiB0aGlzLm5hbWU7XG4gICAgICAgIHRoaXMuZ2V0Tm90ZSA9ICgpID0+IHRoaXMubm90ZTtcbiAgICAgICAgdGhpcy5nZXRCaXAzMktleSA9ICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgbGV0IHZlcnNpb247XG4gICAgICAgICAgICBsZXQgZGVwdGg7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgbGV0IHBhcmVudEZpbmdlcnByaW50ID0gQnVmZmVyLmFsbG9jKDQpLmZpbGwoMCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc01hc3RlcigpKSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbiA9IEJ1ZmZlci5mcm9tKCcwNDg4QURFNCcsICdoZXgnKTtcbiAgICAgICAgICAgICAgICBkZXB0aCA9IDA7XG4gICAgICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVwdGggPSAoKF9hID0gdGhpcy5nZXRPcmlnaW4oKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldENvbXBvbmVudHMoKS5sZW5ndGgpIHx8ICgoX2IgPSB0aGlzLmdldE9yaWdpbigpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0RGVwdGgoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aHMgPSAoX2MgPSB0aGlzLmdldE9yaWdpbigpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZ2V0Q29tcG9uZW50cygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RQYXRoID0gcGF0aHNbcGF0aHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gbGFzdFBhdGguaXNIYXJkZW5lZCgpID8gbGFzdFBhdGguZ2V0SW5kZXgoKSArIDB4ODAwMDAwMDAgOiBsYXN0UGF0aC5nZXRJbmRleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRQYXJlbnRGaW5nZXJwcmludCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRGaW5nZXJwcmludCA9IHRoaXMuZ2V0UGFyZW50RmluZ2VycHJpbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ByaXZhdGVLZXkoKSkge1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uID0gQnVmZmVyLmZyb20oJzA0ODhBREU0JywgJ2hleCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbiA9IEJ1ZmZlci5mcm9tKCcwNDg4QjIxRScsICdoZXgnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXB0aEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxKTtcbiAgICAgICAgICAgIGRlcHRoQnVmZmVyLndyaXRlVUludDgoZGVwdGgsIDApO1xuICAgICAgICAgICAgY29uc3QgaW5kZXhCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgICAgICAgICBpbmRleEJ1ZmZlci53cml0ZVVJbnQzMkJFKGluZGV4LCAwKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluQ29kZSA9IHRoaXMuZ2V0Q2hhaW5Db2RlKCk7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleSgpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBiczU4Y2hlY2tfMS5lbmNvZGUpKEJ1ZmZlci5jb25jYXQoW3ZlcnNpb24sIGRlcHRoQnVmZmVyLCBwYXJlbnRGaW5nZXJwcmludCwgaW5kZXhCdWZmZXIsIGNoYWluQ29kZSwga2V5XSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19IREtFWTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRPdXRwdXREZXNjcmlwdG9yQ29udGVudCA9ICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLmdldE9yaWdpbigpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLmdldE9yaWdpbigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U291cmNlRmluZ2VycHJpbnQoKSkgJiYgKChfYiA9IHRoaXMuZ2V0T3JpZ2luKCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXRQYXRoKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBgJHsoX2QgPSAoX2MgPSB0aGlzLmdldE9yaWdpbigpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZ2V0U291cmNlRmluZ2VycHJpbnQoKSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnRvU3RyaW5nKCdoZXgnKX0vJHsoX2UgPSB0aGlzLmdldE9yaWdpbigpKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuZ2V0UGF0aCgpfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuZ2V0QmlwMzJLZXkoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldENoaWxkcmVuKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKF9mID0gdGhpcy5nZXRDaGlsZHJlbigpKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuZ2V0UGF0aCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBgLyR7KF9nID0gdGhpcy5nZXRDaGlsZHJlbigpKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuZ2V0UGF0aCgpfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXR1cE1hc3RlcktleSA9IChhcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1hc3RlciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmtleSA9IGFyZ3Mua2V5O1xuICAgICAgICAgICAgdGhpcy5jaGFpbkNvZGUgPSBhcmdzLmNoYWluQ29kZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXR1cERlcml2ZUtleSA9IChhcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1hc3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wcml2YXRlS2V5ID0gYXJncy5pc1ByaXZhdGVLZXk7XG4gICAgICAgICAgICB0aGlzLmtleSA9IGFyZ3Mua2V5O1xuICAgICAgICAgICAgdGhpcy5jaGFpbkNvZGUgPSBhcmdzLmNoYWluQ29kZTtcbiAgICAgICAgICAgIHRoaXMudXNlSW5mbyA9IGFyZ3MudXNlSW5mbztcbiAgICAgICAgICAgIHRoaXMub3JpZ2luID0gYXJncy5vcmlnaW47XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gYXJncy5jaGlsZHJlbjtcbiAgICAgICAgICAgIHRoaXMucGFyZW50RmluZ2VycHJpbnQgPSBhcmdzLnBhcmVudEZpbmdlcnByaW50O1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gYXJncy5uYW1lO1xuICAgICAgICAgICAgdGhpcy5ub3RlID0gYXJncy5ub3RlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRvRGF0YUl0ZW0gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hc3Rlcikge1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLmlzX21hc3Rlcl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLmtleV9kYXRhXSA9IHRoaXMua2V5O1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLmNoYWluX2NvZGVdID0gdGhpcy5jaGFpbkNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcml2YXRlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwW0tleXMuaXNfcHJpdmF0ZV0gPSB0aGlzLnByaXZhdGVLZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcFtLZXlzLmtleV9kYXRhXSA9IHRoaXMua2V5O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYWluQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICBtYXBbS2V5cy5jaGFpbl9jb2RlXSA9IHRoaXMuY2hhaW5Db2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy51c2VJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZUluZm8gPSB0aGlzLnVzZUluZm8udG9EYXRhSXRlbSgpO1xuICAgICAgICAgICAgICAgICAgICB1c2VJbmZvLnNldFRhZyh0aGlzLnVzZUluZm8uZ2V0UmVnaXN0cnlUeXBlKCkuZ2V0VGFnKCkpO1xuICAgICAgICAgICAgICAgICAgICBtYXBbS2V5cy51c2VfaW5mb10gPSB1c2VJbmZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luID0gdGhpcy5vcmlnaW4udG9EYXRhSXRlbSgpO1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW4uc2V0VGFnKHRoaXMub3JpZ2luLmdldFJlZ2lzdHJ5VHlwZSgpLmdldFRhZygpKTtcbiAgICAgICAgICAgICAgICAgICAgbWFwW0tleXMub3JpZ2luXSA9IG9yaWdpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnRvRGF0YUl0ZW0oKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uc2V0VGFnKHRoaXMuY2hpbGRyZW4uZ2V0UmVnaXN0cnlUeXBlKCkuZ2V0VGFnKCkpO1xuICAgICAgICAgICAgICAgICAgICBtYXBbS2V5cy5jaGlsZHJlbl0gPSBjaGlsZHJlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50RmluZ2VycHJpbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwW0tleXMucGFyZW50X2ZpbmdlcnByaW50XSA9IHRoaXMucGFyZW50RmluZ2VycHJpbnQucmVhZFVJbnQzMkJFKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwW0tleXMubmFtZV0gPSB0aGlzLm5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBtYXBbS2V5cy5ub3RlXSA9IHRoaXMubm90ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IGxpYl8xLkRhdGFJdGVtKG1hcCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChhcmdzLmlzTWFzdGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNldHVwTWFzdGVyS2V5KGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXR1cERlcml2ZUtleShhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ3J5cHRvSERLZXkgPSBDcnlwdG9IREtleTtcbkNyeXB0b0hES2V5LmZyb21EYXRhSXRlbSA9IChkYXRhSXRlbSkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IGRhdGFJdGVtLmdldERhdGEoKTtcbiAgICBjb25zdCBpc01hc3RlciA9ICEhbWFwW0tleXMuaXNfbWFzdGVyXTtcbiAgICBjb25zdCBpc1ByaXZhdGVLZXkgPSBtYXBbS2V5cy5pc19wcml2YXRlXTtcbiAgICBjb25zdCBrZXkgPSBtYXBbS2V5cy5rZXlfZGF0YV07XG4gICAgY29uc3QgY2hhaW5Db2RlID0gbWFwW0tleXMuY2hhaW5fY29kZV07XG4gICAgY29uc3QgdXNlSW5mbyA9IG1hcFtLZXlzLnVzZV9pbmZvXVxuICAgICAgICA/IENyeXB0b0NvaW5JbmZvXzEuQ3J5cHRvQ29pbkluZm8uZnJvbURhdGFJdGVtKG1hcFtLZXlzLnVzZV9pbmZvXSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb3JpZ2luID0gbWFwW0tleXMub3JpZ2luXVxuICAgICAgICA/IENyeXB0b0tleXBhdGhfMS5DcnlwdG9LZXlwYXRoLmZyb21EYXRhSXRlbShtYXBbS2V5cy5vcmlnaW5dKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG1hcFtLZXlzLmNoaWxkcmVuXVxuICAgICAgICA/IENyeXB0b0tleXBhdGhfMS5DcnlwdG9LZXlwYXRoLmZyb21EYXRhSXRlbShtYXBbS2V5cy5jaGlsZHJlbl0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IF9wYXJlbnRGaW5nZXJwcmludCA9IG1hcFtLZXlzLnBhcmVudF9maW5nZXJwcmludF07XG4gICAgbGV0IHBhcmVudEZpbmdlcnByaW50ID0gdW5kZWZpbmVkO1xuICAgIGlmIChfcGFyZW50RmluZ2VycHJpbnQpIHtcbiAgICAgICAgcGFyZW50RmluZ2VycHJpbnQgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgICAgIHBhcmVudEZpbmdlcnByaW50LndyaXRlVUludDMyQkUoX3BhcmVudEZpbmdlcnByaW50LCAwKTtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IG1hcFtLZXlzLm5hbWVdO1xuICAgIGNvbnN0IG5vdGUgPSBtYXBbS2V5cy5ub3RlXTtcbiAgICByZXR1cm4gbmV3IENyeXB0b0hES2V5KHtcbiAgICAgICAgaXNNYXN0ZXIsXG4gICAgICAgIGlzUHJpdmF0ZUtleSxcbiAgICAgICAga2V5LFxuICAgICAgICBjaGFpbkNvZGUsXG4gICAgICAgIHVzZUluZm8sXG4gICAgICAgIG9yaWdpbixcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHBhcmVudEZpbmdlcnByaW50LFxuICAgICAgICBuYW1lLFxuICAgICAgICBub3RlLFxuICAgIH0pO1xufTtcbkNyeXB0b0hES2V5LmZyb21DQk9SID0gKF9jYm9yUGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IGRhdGFJdGVtID0gKDAsIGxpYl8xLmRlY29kZVRvRGF0YUl0ZW0pKF9jYm9yUGF5bG9hZCk7XG4gICAgcmV0dXJuIENyeXB0b0hES2V5LmZyb21EYXRhSXRlbShkYXRhSXRlbSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3J5cHRvSERLZXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNyeXB0b0tleXBhdGggPSB2b2lkIDA7XG5jb25zdCBsaWJfMSA9IHJlcXVpcmUoXCIuL2xpYlwiKTtcbmNvbnN0IFBhdGhDb21wb25lbnRfMSA9IHJlcXVpcmUoXCIuL1BhdGhDb21wb25lbnRcIik7XG5jb25zdCBSZWdpc3RyeUl0ZW1fMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5SXRlbVwiKTtcbmNvbnN0IFJlZ2lzdHJ5VHlwZV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlUeXBlXCIpO1xudmFyIEtleXM7XG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgICBLZXlzW0tleXNbXCJjb21wb25lbnRzXCJdID0gMV0gPSBcImNvbXBvbmVudHNcIjtcbiAgICBLZXlzW0tleXNbXCJzb3VyY2VfZmluZ2VycHJpbnRcIl0gPSAyXSA9IFwic291cmNlX2ZpbmdlcnByaW50XCI7XG4gICAgS2V5c1tLZXlzW1wiZGVwdGhcIl0gPSAzXSA9IFwiZGVwdGhcIjtcbn0pKEtleXMgfHwgKEtleXMgPSB7fSkpO1xuY2xhc3MgQ3J5cHRvS2V5cGF0aCBleHRlbmRzIFJlZ2lzdHJ5SXRlbV8xLlJlZ2lzdHJ5SXRlbSB7XG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50cyA9IFtdLCBzb3VyY2VGaW5nZXJwcmludCwgZGVwdGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgdGhpcy5zb3VyY2VGaW5nZXJwcmludCA9IHNvdXJjZUZpbmdlcnByaW50O1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgICAgIHRoaXMuZ2V0UmVnaXN0cnlUeXBlID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX0tFWVBBVEg7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0UGF0aCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHMubWFwKChjb21wb25lbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7Y29tcG9uZW50LmlzV2lsZGNhcmQoKSA/ICcqJyA6IGNvbXBvbmVudC5nZXRJbmRleCgpfSR7Y29tcG9uZW50LmlzSGFyZGVuZWQoKSA/IFwiJ1wiIDogJyd9YDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudHMuam9pbignLycpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldENvbXBvbmVudHMgPSAoKSA9PiB0aGlzLmNvbXBvbmVudHM7XG4gICAgICAgIHRoaXMuZ2V0U291cmNlRmluZ2VycHJpbnQgPSAoKSA9PiB0aGlzLnNvdXJjZUZpbmdlcnByaW50O1xuICAgICAgICB0aGlzLmdldERlcHRoID0gKCkgPT4gdGhpcy5kZXB0aDtcbiAgICAgICAgdGhpcy50b0RhdGFJdGVtID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWFwID0ge307XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRzID0gW107XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMuZm9yRWFjaCgoY29tcG9uZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQuaXNXaWxkY2FyZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLnB1c2goW10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudC5nZXRJbmRleCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLnB1c2goY29tcG9uZW50LmlzSGFyZGVuZWQoKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtYXBbS2V5cy5jb21wb25lbnRzXSA9IGNvbXBvbmVudHM7XG4gICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VGaW5nZXJwcmludCkge1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLnNvdXJjZV9maW5nZXJwcmludF0gPSB0aGlzLnNvdXJjZUZpbmdlcnByaW50LnJlYWRVSW50MzJCRSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRlcHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXBbS2V5cy5kZXB0aF0gPSB0aGlzLmRlcHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBsaWJfMS5EYXRhSXRlbShtYXApO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ3J5cHRvS2V5cGF0aCA9IENyeXB0b0tleXBhdGg7XG5DcnlwdG9LZXlwYXRoLmZyb21EYXRhSXRlbSA9IChkYXRhSXRlbSkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IGRhdGFJdGVtLmdldERhdGEoKTtcbiAgICBjb25zdCBwYXRoQ29tcG9uZW50cyA9IFtdO1xuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBtYXBbS2V5cy5jb21wb25lbnRzXTtcbiAgICBpZiAoY29tcG9uZW50cykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzSGFyZGVuZWQgPSBjb21wb25lbnRzW2kgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBjb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHBhdGhDb21wb25lbnRzLnB1c2gobmV3IFBhdGhDb21wb25lbnRfMS5QYXRoQ29tcG9uZW50KHsgaW5kZXg6IHBhdGgsIGhhcmRlbmVkOiBpc0hhcmRlbmVkIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGhDb21wb25lbnRzLnB1c2gobmV3IFBhdGhDb21wb25lbnRfMS5QYXRoQ29tcG9uZW50KHsgaGFyZGVuZWQ6IGlzSGFyZGVuZWQgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IF9zb3VyY2VGaW5nZXJwcmludCA9IG1hcFtLZXlzLnNvdXJjZV9maW5nZXJwcmludF07XG4gICAgbGV0IHNvdXJjZUZpbmdlcnByaW50O1xuICAgIGlmIChfc291cmNlRmluZ2VycHJpbnQpIHtcbiAgICAgICAgc291cmNlRmluZ2VycHJpbnQgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgICAgIHNvdXJjZUZpbmdlcnByaW50LndyaXRlVUludDMyQkUoX3NvdXJjZUZpbmdlcnByaW50LCAwKTtcbiAgICB9XG4gICAgY29uc3QgZGVwdGggPSBtYXBbS2V5cy5kZXB0aF07XG4gICAgcmV0dXJuIG5ldyBDcnlwdG9LZXlwYXRoKHBhdGhDb21wb25lbnRzLCBzb3VyY2VGaW5nZXJwcmludCwgZGVwdGgpO1xufTtcbkNyeXB0b0tleXBhdGguZnJvbUNCT1IgPSAoX2Nib3JQYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgZGF0YUl0ZW0gPSAoMCwgbGliXzEuZGVjb2RlVG9EYXRhSXRlbSkoX2Nib3JQYXlsb2FkKTtcbiAgICByZXR1cm4gQ3J5cHRvS2V5cGF0aC5mcm9tRGF0YUl0ZW0oZGF0YUl0ZW0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNyeXB0b0tleXBhdGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNyeXB0b091dHB1dCA9IHZvaWQgMDtcbmNvbnN0IENyeXB0b0VDS2V5XzEgPSByZXF1aXJlKFwiLi9DcnlwdG9FQ0tleVwiKTtcbmNvbnN0IENyeXB0b0hES2V5XzEgPSByZXF1aXJlKFwiLi9DcnlwdG9IREtleVwiKTtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4vbGliXCIpO1xuY29uc3QgTXVsdGlLZXlfMSA9IHJlcXVpcmUoXCIuL011bHRpS2V5XCIpO1xuY29uc3QgUmVnaXN0cnlJdGVtXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeUl0ZW1cIik7XG5jb25zdCBSZWdpc3RyeVR5cGVfMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5VHlwZVwiKTtcbmNvbnN0IFNjcmlwdEV4cHJlc3Npb25fMSA9IHJlcXVpcmUoXCIuL1NjcmlwdEV4cHJlc3Npb25cIik7XG5jbGFzcyBDcnlwdG9PdXRwdXQgZXh0ZW5kcyBSZWdpc3RyeUl0ZW1fMS5SZWdpc3RyeUl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKHNjcmlwdEV4cHJlc3Npb25zLCBjcnlwdG9LZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zY3JpcHRFeHByZXNzaW9ucyA9IHNjcmlwdEV4cHJlc3Npb25zO1xuICAgICAgICB0aGlzLmNyeXB0b0tleSA9IGNyeXB0b0tleTtcbiAgICAgICAgdGhpcy5nZXRSZWdpc3RyeVR5cGUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fT1VUUFVUO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldENyeXB0b0tleSA9ICgpID0+IHRoaXMuY3J5cHRvS2V5O1xuICAgICAgICB0aGlzLmdldEhES2V5ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3J5cHRvS2V5IGluc3RhbmNlb2YgQ3J5cHRvSERLZXlfMS5DcnlwdG9IREtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyeXB0b0tleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0RUNLZXkgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jcnlwdG9LZXkgaW5zdGFuY2VvZiBDcnlwdG9FQ0tleV8xLkNyeXB0b0VDS2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3J5cHRvS2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRNdWx0aUtleSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNyeXB0b0tleSBpbnN0YW5jZW9mIE11bHRpS2V5XzEuTXVsdGlLZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcnlwdG9LZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFNjcmlwdEV4cHJlc3Npb25zID0gKCkgPT4gdGhpcy5zY3JpcHRFeHByZXNzaW9ucztcbiAgICAgICAgdGhpcy5fdG9PdXRwdXREZXNjcmlwdG9yID0gKHNlSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChzZUluZGV4ID49IHRoaXMuc2NyaXB0RXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3J5cHRvS2V5LmdldE91dHB1dERlc2NyaXB0b3JDb250ZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5zY3JpcHRFeHByZXNzaW9uc1tzZUluZGV4XS5nZXRFeHByZXNzaW9uKCl9KCR7dGhpcy5fdG9PdXRwdXREZXNjcmlwdG9yKHNlSW5kZXggKyAxKX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b1N0cmluZyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90b091dHB1dERlc2NyaXB0b3IoMCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudG9EYXRhSXRlbSA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCBkYXRhSXRlbSA9IHRoaXMuY3J5cHRvS2V5LnRvRGF0YUl0ZW0oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNyeXB0b0tleSBpbnN0YW5jZW9mIENyeXB0b0VDS2V5XzEuQ3J5cHRvRUNLZXkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNyeXB0b0tleSBpbnN0YW5jZW9mIENyeXB0b0hES2V5XzEuQ3J5cHRvSERLZXkpIHtcbiAgICAgICAgICAgICAgICBkYXRhSXRlbS5zZXRUYWcodGhpcy5jcnlwdG9LZXkuZ2V0UmVnaXN0cnlUeXBlKCkuZ2V0VGFnKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2xvbmVkU2UgPSBbLi4udGhpcy5zY3JpcHRFeHByZXNzaW9uc107XG4gICAgICAgICAgICBjbG9uZWRTZS5yZXZlcnNlKCkuZm9yRWFjaCgoc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWdWYWx1ZSA9IHNlLmdldFRhZygpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhSXRlbS5nZXRUYWcoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFJdGVtLnNldFRhZyh0YWdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbSA9IG5ldyBsaWJfMS5EYXRhSXRlbShkYXRhSXRlbSwgdGFnVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFJdGVtO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ3J5cHRvT3V0cHV0ID0gQ3J5cHRvT3V0cHV0O1xuQ3J5cHRvT3V0cHV0LmZyb21EYXRhSXRlbSA9IChkYXRhSXRlbSkgPT4ge1xuICAgIGNvbnN0IHNjcmlwdEV4cHJlc3Npb25zID0gW107XG4gICAgbGV0IF9kYXRhSXRlbSA9IGRhdGFJdGVtO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBfdGFnID0gX2RhdGFJdGVtLmdldFRhZygpO1xuICAgICAgICBjb25zdCBzZSA9IFNjcmlwdEV4cHJlc3Npb25fMS5TY3JpcHRFeHByZXNzaW9uLmZyb21UYWcoX3RhZyk7XG4gICAgICAgIGlmIChzZSkge1xuICAgICAgICAgICAgc2NyaXB0RXhwcmVzc2lvbnMucHVzaChzZSk7XG4gICAgICAgICAgICBpZiAoX2RhdGFJdGVtLmdldERhdGEoKSBpbnN0YW5jZW9mIGxpYl8xLkRhdGFJdGVtKSB7XG4gICAgICAgICAgICAgICAgX2RhdGFJdGVtID0gX2RhdGFJdGVtLmdldERhdGEoKTtcbiAgICAgICAgICAgICAgICBfdGFnID0gX2RhdGFJdGVtLmdldFRhZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzZUxlbmd0aCA9IHNjcmlwdEV4cHJlc3Npb25zLmxlbmd0aDtcbiAgICBjb25zdCBpc011bHRpS2V5ID0gc2VMZW5ndGggPiAwICYmXG4gICAgICAgIChzY3JpcHRFeHByZXNzaW9uc1tzZUxlbmd0aCAtIDFdLmdldEV4cHJlc3Npb24oKSA9PT1cbiAgICAgICAgICAgIFNjcmlwdEV4cHJlc3Npb25fMS5TY3JpcHRFeHByZXNzaW9ucy5NVUxUSVNJRy5nZXRFeHByZXNzaW9uKCkgfHxcbiAgICAgICAgICAgIHNjcmlwdEV4cHJlc3Npb25zW3NlTGVuZ3RoIC0gMV0uZ2V0RXhwcmVzc2lvbigpID09PVxuICAgICAgICAgICAgICAgIFNjcmlwdEV4cHJlc3Npb25fMS5TY3JpcHRFeHByZXNzaW9ucy5TT1JURURfTVVMVElTSUcuZ2V0RXhwcmVzc2lvbigpKTtcbiAgICBpZiAoaXNNdWx0aUtleSkge1xuICAgICAgICBjb25zdCBtdWx0aUtleSA9IE11bHRpS2V5XzEuTXVsdGlLZXkuZnJvbURhdGFJdGVtKF9kYXRhSXRlbSk7XG4gICAgICAgIHJldHVybiBuZXcgQ3J5cHRvT3V0cHV0KHNjcmlwdEV4cHJlc3Npb25zLCBtdWx0aUtleSk7XG4gICAgfVxuICAgIGlmIChfZGF0YUl0ZW0uZ2V0VGFnKCkgPT09IFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX0hES0VZLmdldFRhZygpKSB7XG4gICAgICAgIGNvbnN0IGNyeXB0b0hES2V5ID0gQ3J5cHRvSERLZXlfMS5DcnlwdG9IREtleS5mcm9tRGF0YUl0ZW0oX2RhdGFJdGVtKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDcnlwdG9PdXRwdXQoc2NyaXB0RXhwcmVzc2lvbnMsIGNyeXB0b0hES2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGNyeXB0b0VDS2V5ID0gQ3J5cHRvRUNLZXlfMS5DcnlwdG9FQ0tleS5mcm9tRGF0YUl0ZW0oX2RhdGFJdGVtKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDcnlwdG9PdXRwdXQoc2NyaXB0RXhwcmVzc2lvbnMsIGNyeXB0b0VDS2V5KTtcbiAgICB9XG59O1xuQ3J5cHRvT3V0cHV0LmZyb21DQk9SID0gKF9jYm9yUGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IGRhdGFJdGVtID0gKDAsIGxpYl8xLmRlY29kZVRvRGF0YUl0ZW0pKF9jYm9yUGF5bG9hZCk7XG4gICAgcmV0dXJuIENyeXB0b091dHB1dC5mcm9tRGF0YUl0ZW0oZGF0YUl0ZW0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNyeXB0b091dHB1dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ3J5cHRvUFNCVCA9IHZvaWQgMDtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4vbGliXCIpO1xuY29uc3QgUmVnaXN0cnlJdGVtXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeUl0ZW1cIik7XG5jb25zdCBSZWdpc3RyeVR5cGVfMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5VHlwZVwiKTtcbmNsYXNzIENyeXB0b1BTQlQgZXh0ZW5kcyBSZWdpc3RyeUl0ZW1fMS5SZWdpc3RyeUl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKHBzYnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wc2J0ID0gcHNidDtcbiAgICAgICAgdGhpcy5nZXRSZWdpc3RyeVR5cGUgPSAoKSA9PiBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19QU0JUO1xuICAgICAgICB0aGlzLmdldFBTQlQgPSAoKSA9PiB0aGlzLnBzYnQ7XG4gICAgICAgIHRoaXMudG9EYXRhSXRlbSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbGliXzEuRGF0YUl0ZW0odGhpcy5wc2J0KTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkNyeXB0b1BTQlQgPSBDcnlwdG9QU0JUO1xuQ3J5cHRvUFNCVC5mcm9tRGF0YUl0ZW0gPSAoZGF0YUl0ZW0pID0+IHtcbiAgICBjb25zdCBwc2J0ID0gZGF0YUl0ZW0uZ2V0RGF0YSgpO1xuICAgIGlmICghcHNidCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCNbdXItcmVnaXN0cnldW0NyeXB0b1BTQlRdW2ZuLmZyb21EYXRhSXRlbV06IGRlY29kZWQgW2RhdGFJdGVtXVsjZGF0YV0gaXMgdW5kZWZpbmVkOiAke2RhdGFJdGVtfWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IENyeXB0b1BTQlQocHNidCk7XG59O1xuQ3J5cHRvUFNCVC5mcm9tQ0JPUiA9IChfY2JvclBheWxvYWQpID0+IHtcbiAgICBjb25zdCBkYXRhSXRlbSA9ICgwLCBsaWJfMS5kZWNvZGVUb0RhdGFJdGVtKShfY2JvclBheWxvYWQpO1xuICAgIHJldHVybiBDcnlwdG9QU0JULmZyb21EYXRhSXRlbShkYXRhSXRlbSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3J5cHRvUFNCVC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVVJSZWdpc3RyeURlY29kZXIgPSB2b2lkIDA7XG5jb25zdCBiY191cl8xID0gcmVxdWlyZShcIkBuZ3JhdmVpby9iYy11clwiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLlwiKTtcbmNvbnN0IFJlZ2lzdHJ5VHlwZV8xID0gcmVxdWlyZShcIi4uL1JlZ2lzdHJ5VHlwZVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNsYXNzIFVSUmVnaXN0cnlEZWNvZGVyIGV4dGVuZHMgYmNfdXJfMS5VUkRlY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnJlc3VsdFJlZ2lzdHJ5VHlwZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVyID0gdGhpcy5yZXN1bHRVUigpO1xuICAgICAgICAgICAgc3dpdGNoICh1ci50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkJZVEVTLmdldFR5cGUoKTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fMS5CeXRlcy5mcm9tQ0JPUih1ci5jYm9yKTtcbiAgICAgICAgICAgICAgICBjYXNlIFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX0hES0VZLmdldFR5cGUoKTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fMS5DcnlwdG9IREtleS5mcm9tQ0JPUih1ci5jYm9yKTtcbiAgICAgICAgICAgICAgICBjYXNlIFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX0tFWVBBVEguZ2V0VHlwZSgpOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18xLkNyeXB0b0tleXBhdGguZnJvbUNCT1IodXIuY2Jvcik7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19DT0lOX0lORk8uZ2V0VHlwZSgpOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18xLkNyeXB0b0NvaW5JbmZvLmZyb21DQk9SKHVyLmNib3IpO1xuICAgICAgICAgICAgICAgIGNhc2UgUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fRUNLRVkuZ2V0VHlwZSgpOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18xLkNyeXB0b0VDS2V5LmZyb21DQk9SKHVyLmNib3IpO1xuICAgICAgICAgICAgICAgIGNhc2UgUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fT1VUUFVULmdldFR5cGUoKTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fMS5DcnlwdG9PdXRwdXQuZnJvbUNCT1IodXIuY2Jvcik7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19QU0JULmdldFR5cGUoKTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fMS5DcnlwdG9QU0JULmZyb21DQk9SKHVyLmNib3IpO1xuICAgICAgICAgICAgICAgIGNhc2UgUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fQUNDT1VOVC5nZXRUeXBlKCk6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfXzEuQ3J5cHRvQWNjb3VudC5mcm9tQ0JPUih1ci5jYm9yKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5rbm93blVSVHlwZUVycm9yKGAjW3VyLXJlZ2lzdHJ5XVtEZWNvZGVyXVtmbi5yZXN1bHRSZWdpc3RyeVR5cGVdOiByZWdpc3RyeSB0eXBlICR7dXIudHlwZX0gaXMgbm90IHN1cHBvcnRlZCBub3dgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlVSUmVnaXN0cnlEZWNvZGVyID0gVVJSZWdpc3RyeURlY29kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTXVsdGlLZXkgPSB2b2lkIDA7XG5jb25zdCBDcnlwdG9FQ0tleV8xID0gcmVxdWlyZShcIi4vQ3J5cHRvRUNLZXlcIik7XG5jb25zdCBDcnlwdG9IREtleV8xID0gcmVxdWlyZShcIi4vQ3J5cHRvSERLZXlcIik7XG5jb25zdCBEYXRhSXRlbV8xID0gcmVxdWlyZShcIi4vbGliL0RhdGFJdGVtXCIpO1xuY29uc3QgUmVnaXN0cnlJdGVtXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeUl0ZW1cIik7XG5jb25zdCBSZWdpc3RyeVR5cGVfMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5VHlwZVwiKTtcbnZhciBLZXlzO1xuKGZ1bmN0aW9uIChLZXlzKSB7XG4gICAgS2V5c1tLZXlzW1widGhyZXNob2xkXCJdID0gMV0gPSBcInRocmVzaG9sZFwiO1xuICAgIEtleXNbS2V5c1tcImtleXNcIl0gPSAyXSA9IFwia2V5c1wiO1xufSkoS2V5cyB8fCAoS2V5cyA9IHt9KSk7XG5jbGFzcyBNdWx0aUtleSBleHRlbmRzIFJlZ2lzdHJ5SXRlbV8xLlJlZ2lzdHJ5SXRlbSB7XG4gICAgY29uc3RydWN0b3IodGhyZXNob2xkLCBrZXlzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGhyZXNob2xkID0gdGhyZXNob2xkO1xuICAgICAgICB0aGlzLmtleXMgPSBrZXlzO1xuICAgICAgICB0aGlzLmdldFRocmVzaG9sZCA9ICgpID0+IHRoaXMudGhyZXNob2xkO1xuICAgICAgICB0aGlzLmdldEtleXMgPSAoKSA9PiB0aGlzLmtleXM7XG4gICAgICAgIHRoaXMudG9EYXRhSXRlbSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgICAgICAgICAgbWFwW0tleXMudGhyZXNob2xkXSA9IHRoaXMudGhyZXNob2xkO1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMua2V5cy5tYXAoKGspID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhSXRlbSA9IGsudG9EYXRhSXRlbSgpO1xuICAgICAgICAgICAgICAgIGRhdGFJdGVtLnNldFRhZyhrLmdldFJlZ2lzdHJ5VHlwZSgpLmdldFRhZygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YUl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1hcFtLZXlzLmtleXNdID0ga2V5cztcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0YUl0ZW1fMS5EYXRhSXRlbShtYXApO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE91dHB1dERlc2NyaXB0b3JDb250ZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLmdldFRocmVzaG9sZCgpLFxuICAgICAgICAgICAgICAgIHRoaXMua2V5cy5tYXAoayA9PiBrLmdldE91dHB1dERlc2NyaXB0b3JDb250ZW50KCkpLmpvaW4oJywnKSxcbiAgICAgICAgICAgIF0uam9pbignLCcpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTXVsdGlLZXkgPSBNdWx0aUtleTtcbk11bHRpS2V5LmZyb21EYXRhSXRlbSA9IChkYXRhSXRlbSkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IGRhdGFJdGVtLmdldERhdGEoKTtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSBtYXBbS2V5cy50aHJlc2hvbGRdO1xuICAgIGNvbnN0IF9rZXlzID0gbWFwW0tleXMua2V5c107XG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIF9rZXlzLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgaWYgKGsuZ2V0VGFnKCkgPT09IFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX0hES0VZLmdldFRhZygpKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goQ3J5cHRvSERLZXlfMS5DcnlwdG9IREtleS5mcm9tRGF0YUl0ZW0oaykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGsuZ2V0VGFnKCkgPT09IFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX0VDS0VZLmdldFRhZygpKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goQ3J5cHRvRUNLZXlfMS5DcnlwdG9FQ0tleS5mcm9tRGF0YUl0ZW0oaykpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBNdWx0aUtleSh0aHJlc2hvbGQsIGtleXMpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU11bHRpS2V5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXRoQ29tcG9uZW50ID0gdm9pZCAwO1xuY2xhc3MgUGF0aENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoYXJncykge1xuICAgICAgICB0aGlzLmdldEluZGV4ID0gKCkgPT4gdGhpcy5pbmRleDtcbiAgICAgICAgdGhpcy5pc1dpbGRjYXJkID0gKCkgPT4gdGhpcy53aWxkY2FyZDtcbiAgICAgICAgdGhpcy5pc0hhcmRlbmVkID0gKCkgPT4gdGhpcy5oYXJkZW5lZDtcbiAgICAgICAgdGhpcy5pbmRleCA9IGFyZ3MuaW5kZXg7XG4gICAgICAgIHRoaXMuaGFyZGVuZWQgPSBhcmdzLmhhcmRlbmVkO1xuICAgICAgICBpZiAodGhpcy5pbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLndpbGRjYXJkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndpbGRjYXJkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmRleCAmJiAodGhpcy5pbmRleCAmIFBhdGhDb21wb25lbnQuSEFSREVORURfQklUKSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAjW3VyLXJlZ2lzdHJ5XVtQYXRoQ29tcG9uZW50XVtmbi5jb25zdHJ1Y3Rvcl06IEludmFsaWQgaW5kZXggJHt0aGlzLmluZGV4fSAtIG1vc3Qgc2lnbmlmaWNhbnQgYml0IGNhbm5vdCBiZSBzZXRgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUGF0aENvbXBvbmVudCA9IFBhdGhDb21wb25lbnQ7XG5QYXRoQ29tcG9uZW50LkhBUkRFTkVEX0JJVCA9IDB4ODAwMDAwMDA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYXRoQ29tcG9uZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZWdpc3RyeUl0ZW0gPSB2b2lkIDA7XG5jb25zdCBiY191cl8xID0gcmVxdWlyZShcIkBuZ3JhdmVpby9iYy11clwiKTtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4vbGliXCIpO1xuY2xhc3MgUmVnaXN0cnlJdGVtIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50b0NCT1IgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy50b0RhdGFJdGVtKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgI1t1ci1yZWdpc3RyeV1bUmVnaXN0cnlJdGVtXVtmbi50b0NCT1JdOiByZWdpc3RyeSAke3RoaXMuZ2V0UmVnaXN0cnlUeXBlKCl9J3MgbWV0aG9kIHRvRGF0YUl0ZW0gcmV0dXJucyB1bmRlZmluZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgbGliXzEuZW5jb2RlRGF0YUl0ZW0pKHRoaXMudG9EYXRhSXRlbSgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b1VSID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBiY191cl8xLlVSKHRoaXMudG9DQk9SKCksIHRoaXMuZ2V0UmVnaXN0cnlUeXBlKCkuZ2V0VHlwZSgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b1VSRW5jb2RlciA9IChtYXhGcmFnbWVudExlbmd0aCwgZmlyc3RTZXFOdW0sIG1pbkZyYWdtZW50TGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1ciA9IHRoaXMudG9VUigpO1xuICAgICAgICAgICAgY29uc3QgdXJFbmNvZGVyID0gbmV3IGJjX3VyXzEuVVJFbmNvZGVyKHVyLCBtYXhGcmFnbWVudExlbmd0aCwgZmlyc3RTZXFOdW0sIG1pbkZyYWdtZW50TGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiB1ckVuY29kZXI7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5SZWdpc3RyeUl0ZW0gPSBSZWdpc3RyeUl0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWdpc3RyeUl0ZW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlZ2lzdHJ5VHlwZXMgPSBleHBvcnRzLlJlZ2lzdHJ5VHlwZSA9IHZvaWQgMDtcbmNsYXNzIFJlZ2lzdHJ5VHlwZSB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgdGFnKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLmdldFRhZyA9ICgpID0+IHRoaXMudGFnO1xuICAgICAgICB0aGlzLmdldFR5cGUgPSAoKSA9PiB0aGlzLnR5cGU7XG4gICAgfVxufVxuZXhwb3J0cy5SZWdpc3RyeVR5cGUgPSBSZWdpc3RyeVR5cGU7XG5leHBvcnRzLlJlZ2lzdHJ5VHlwZXMgPSB7XG4gICAgVVVJRDogbmV3IFJlZ2lzdHJ5VHlwZSgndXVpZCcsIDM3KSxcbiAgICBCWVRFUzogbmV3IFJlZ2lzdHJ5VHlwZSgnYnl0ZXMnLCB1bmRlZmluZWQpLFxuICAgIENSWVBUT19IREtFWTogbmV3IFJlZ2lzdHJ5VHlwZSgnY3J5cHRvLWhka2V5JywgMzAzKSxcbiAgICBDUllQVE9fS0VZUEFUSDogbmV3IFJlZ2lzdHJ5VHlwZSgnY3J5cHRvLWtleXBhdGgnLCAzMDQpLFxuICAgIENSWVBUT19DT0lOX0lORk86IG5ldyBSZWdpc3RyeVR5cGUoJ2NyeXB0by1jb2luLWluZm8nLCAzMDUpLFxuICAgIENSWVBUT19FQ0tFWTogbmV3IFJlZ2lzdHJ5VHlwZSgnY3J5cHRvLWVja2V5JywgMzA2KSxcbiAgICBDUllQVE9fT1VUUFVUOiBuZXcgUmVnaXN0cnlUeXBlKCdjcnlwdG8tb3V0cHV0JywgMzA4KSxcbiAgICBDUllQVE9fUFNCVDogbmV3IFJlZ2lzdHJ5VHlwZSgnY3J5cHRvLXBzYnQnLCAzMTApLFxuICAgIENSWVBUT19BQ0NPVU5UOiBuZXcgUmVnaXN0cnlUeXBlKCdjcnlwdG8tYWNjb3VudCcsIDMxMSksXG4gICAgQ1JZUFRPX01VTFRJX0FDQ09VTlRTOiBuZXcgUmVnaXN0cnlUeXBlKFwiY3J5cHRvLW11bHRpLWFjY291bnRzXCIsIDExMDMpLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlZ2lzdHJ5VHlwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2NyaXB0RXhwcmVzc2lvbnMgPSBleHBvcnRzLlNjcmlwdEV4cHJlc3Npb24gPSB2b2lkIDA7XG5jbGFzcyBTY3JpcHRFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWcsIGV4cHJlc3Npb24pIHtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgIHRoaXMuZ2V0VGFnID0gKCkgPT4gdGhpcy50YWc7XG4gICAgICAgIHRoaXMuZ2V0RXhwcmVzc2lvbiA9ICgpID0+IHRoaXMuZXhwcmVzc2lvbjtcbiAgICB9XG59XG5leHBvcnRzLlNjcmlwdEV4cHJlc3Npb24gPSBTY3JpcHRFeHByZXNzaW9uO1xuU2NyaXB0RXhwcmVzc2lvbi5mcm9tVGFnID0gKHRhZykgPT4ge1xuICAgIGNvbnN0IHNlID0gT2JqZWN0LnZhbHVlcyhleHBvcnRzLlNjcmlwdEV4cHJlc3Npb25zKS5maW5kKChzZSkgPT4gc2UuZ2V0VGFnKCkgPT09IHRhZyk7XG4gICAgcmV0dXJuIHNlO1xufTtcbmV4cG9ydHMuU2NyaXB0RXhwcmVzc2lvbnMgPSB7XG4gICAgU0NSSVBUX0hBU0g6IG5ldyBTY3JpcHRFeHByZXNzaW9uKDQwMCwgJ3NoJyksXG4gICAgV0lUTkVTU19TQ1JJUFRfSEFTSDogbmV3IFNjcmlwdEV4cHJlc3Npb24oNDAxLCAnd3NoJyksXG4gICAgUFVCTElDX0tFWTogbmV3IFNjcmlwdEV4cHJlc3Npb24oNDAyLCAncGsnKSxcbiAgICBQVUJMSUNfS0VZX0hBU0g6IG5ldyBTY3JpcHRFeHByZXNzaW9uKDQwMywgJ3BraCcpLFxuICAgIFdJVE5FU1NfUFVCTElDX0tFWV9IQVNIOiBuZXcgU2NyaXB0RXhwcmVzc2lvbig0MDQsICd3cGtoJyksXG4gICAgQ09NQk86IG5ldyBTY3JpcHRFeHByZXNzaW9uKDQwNSwgJ2NvbWJvJyksXG4gICAgTVVMVElTSUc6IG5ldyBTY3JpcHRFeHByZXNzaW9uKDQwNiwgJ211bHRpJyksXG4gICAgU09SVEVEX01VTFRJU0lHOiBuZXcgU2NyaXB0RXhwcmVzc2lvbig0MDcsICdzb3J0ZWRtdWx0aScpLFxuICAgIEFERFJFU1M6IG5ldyBTY3JpcHRFeHByZXNzaW9uKDMwNywgJ2FkZHInKSxcbiAgICBSQVdfU0NSSVBUOiBuZXcgU2NyaXB0RXhwcmVzc2lvbig0MDgsICdyYXcnKSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TY3JpcHRFeHByZXNzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Vbmtub3duVVJUeXBlRXJyb3IgPSB2b2lkIDA7XG5jbGFzcyBVbmtub3duVVJUeXBlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnRzLlVua25vd25VUlR5cGVFcnJvciA9IFVua25vd25VUlR5cGVFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DcnlwdG9NdWx0aUFjY291bnRzID0gdm9pZCAwO1xuY29uc3QgUmVnaXN0cnlUeXBlXzEgPSByZXF1aXJlKFwiLi4vUmVnaXN0cnlUeXBlXCIpO1xuY29uc3QgQ3J5cHRvSERLZXlfMSA9IHJlcXVpcmUoXCIuLi9DcnlwdG9IREtleVwiKTtcbmNvbnN0IFJlZ2lzdHJ5SXRlbV8xID0gcmVxdWlyZShcIi4uL1JlZ2lzdHJ5SXRlbVwiKTtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4uL2xpYlwiKTtcbnZhciBLZXlzO1xuKGZ1bmN0aW9uIChLZXlzKSB7XG4gICAgS2V5c1tLZXlzW1wibWFzdGVyRmluZ2VycHJpbnRcIl0gPSAxXSA9IFwibWFzdGVyRmluZ2VycHJpbnRcIjtcbiAgICBLZXlzW0tleXNbXCJrZXlzXCJdID0gMl0gPSBcImtleXNcIjtcbiAgICBLZXlzW0tleXNbXCJkZXZpY2VcIl0gPSAzXSA9IFwiZGV2aWNlXCI7XG59KShLZXlzIHx8IChLZXlzID0ge30pKTtcbmNsYXNzIENyeXB0b011bHRpQWNjb3VudHMgZXh0ZW5kcyBSZWdpc3RyeUl0ZW1fMS5SZWdpc3RyeUl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKG1hc3RlckZpbmdlcnByaW50LCBrZXlzLCBkZXZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tYXN0ZXJGaW5nZXJwcmludCA9IG1hc3RlckZpbmdlcnByaW50O1xuICAgICAgICB0aGlzLmtleXMgPSBrZXlzO1xuICAgICAgICB0aGlzLmRldmljZSA9IGRldmljZTtcbiAgICAgICAgdGhpcy5nZXRSZWdpc3RyeVR5cGUgPSAoKSA9PiBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19NVUxUSV9BQ0NPVU5UUztcbiAgICAgICAgdGhpcy5nZXRNYXN0ZXJGaW5nZXJwcmludCA9ICgpID0+IHRoaXMubWFzdGVyRmluZ2VycHJpbnQ7XG4gICAgICAgIHRoaXMuZ2V0S2V5cyA9ICgpID0+IHRoaXMua2V5cztcbiAgICAgICAgdGhpcy5nZXREZXZpY2UgPSAoKSA9PiB0aGlzLmRldmljZTtcbiAgICAgICAgdGhpcy50b0RhdGFJdGVtID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWFwID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5tYXN0ZXJGaW5nZXJwcmludCkge1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLm1hc3RlckZpbmdlcnByaW50XSA9IHRoaXMubWFzdGVyRmluZ2VycHJpbnQucmVhZFVJbnQzMkJFKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMua2V5cykge1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLmtleXNdID0gdGhpcy5rZXlzLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhSXRlbSA9IGl0ZW0udG9EYXRhSXRlbSgpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbS5zZXRUYWcoaXRlbS5nZXRSZWdpc3RyeVR5cGUoKS5nZXRUYWcoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhSXRlbTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRldmljZSkge1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLmRldmljZV0gPSB0aGlzLmRldmljZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgbGliXzEuRGF0YUl0ZW0obWFwKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkNyeXB0b011bHRpQWNjb3VudHMgPSBDcnlwdG9NdWx0aUFjY291bnRzO1xuQ3J5cHRvTXVsdGlBY2NvdW50cy5mcm9tRGF0YUl0ZW0gPSAoZGF0YUl0ZW0pID0+IHtcbiAgICBjb25zdCBtYXAgPSBkYXRhSXRlbS5nZXREYXRhKCk7XG4gICAgY29uc3QgbWFzdGVyRmluZ2VycHJpbnQgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgY29uc3QgX21hc3RlckZpbmdlcnByaW50ID0gbWFwW0tleXMubWFzdGVyRmluZ2VycHJpbnRdO1xuICAgIGlmIChfbWFzdGVyRmluZ2VycHJpbnQpIHtcbiAgICAgICAgbWFzdGVyRmluZ2VycHJpbnQud3JpdGVVSW50MzJCRShfbWFzdGVyRmluZ2VycHJpbnQsIDApO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gbWFwW0tleXMua2V5c107XG4gICAgY29uc3QgY3J5cHRvSERLZXlzID0ga2V5cy5tYXAoKGl0ZW0pID0+IENyeXB0b0hES2V5XzEuQ3J5cHRvSERLZXkuZnJvbURhdGFJdGVtKGl0ZW0pKTtcbiAgICBjb25zdCBkZXZpY2UgPSBtYXBbS2V5cy5kZXZpY2VdO1xuICAgIHJldHVybiBuZXcgQ3J5cHRvTXVsdGlBY2NvdW50cyhtYXN0ZXJGaW5nZXJwcmludCwgY3J5cHRvSERLZXlzLCBkZXZpY2UpO1xufTtcbkNyeXB0b011bHRpQWNjb3VudHMuZnJvbUNCT1IgPSAoX2Nib3JQYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgZGF0YUl0ZW0gPSAoMCwgbGliXzEuZGVjb2RlVG9EYXRhSXRlbSkoX2Nib3JQYXlsb2FkKTtcbiAgICByZXR1cm4gQ3J5cHRvTXVsdGlBY2NvdW50cy5mcm9tRGF0YUl0ZW0oZGF0YUl0ZW0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNyeXB0b011bHRpQWNjb3VudHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJ1ZmZlciA9IGV4cG9ydHMuZXh0ZW5kID0gZXhwb3J0cy5QYXRoQ29tcG9uZW50ID0gZXhwb3J0cy5TY3JpcHRFeHByZXNzaW9ucyA9IGV4cG9ydHMuTXVsdGlLZXkgPSBleHBvcnRzLkNyeXB0b1BTQlQgPSBleHBvcnRzLkNyeXB0b091dHB1dCA9IGV4cG9ydHMuQ3J5cHRvRUNLZXkgPSBleHBvcnRzLkNyeXB0b0NvaW5JbmZvTmV0d29yayA9IGV4cG9ydHMuQ3J5cHRvQ29pbkluZm9UeXBlID0gZXhwb3J0cy5DcnlwdG9Db2luSW5mbyA9IGV4cG9ydHMuQ3J5cHRvS2V5cGF0aCA9IGV4cG9ydHMuQ3J5cHRvTXVsdGlBY2NvdW50cyA9IGV4cG9ydHMuQ3J5cHRvSERLZXkgPSBleHBvcnRzLkNyeXB0b0FjY291bnQgPSBleHBvcnRzLkJ5dGVzID0gZXhwb3J0cy5VUlJlZ2lzdHJ5RGVjb2RlciA9IGV4cG9ydHMuRGF0YUl0ZW0gPSB2b2lkIDA7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xucmVxdWlyZShcIi4vcGF0Y2hDQk9SXCIpO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJ1ZmZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVmZmVyXzEuQnVmZmVyOyB9IH0pO1xuY29uc3QgQ3J5cHRvSERLZXlfMSA9IHJlcXVpcmUoXCIuL0NyeXB0b0hES2V5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ3J5cHRvSERLZXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENyeXB0b0hES2V5XzEuQ3J5cHRvSERLZXk7IH0gfSk7XG5jb25zdCBDcnlwdG9LZXlwYXRoXzEgPSByZXF1aXJlKFwiLi9DcnlwdG9LZXlwYXRoXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ3J5cHRvS2V5cGF0aFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ3J5cHRvS2V5cGF0aF8xLkNyeXB0b0tleXBhdGg7IH0gfSk7XG5jb25zdCBDcnlwdG9Db2luSW5mb18xID0gcmVxdWlyZShcIi4vQ3J5cHRvQ29pbkluZm9cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDcnlwdG9Db2luSW5mb1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ3J5cHRvQ29pbkluZm9fMS5DcnlwdG9Db2luSW5mbzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNyeXB0b0NvaW5JbmZvVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ3J5cHRvQ29pbkluZm9fMS5UeXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ3J5cHRvQ29pbkluZm9OZXR3b3JrXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDcnlwdG9Db2luSW5mb18xLk5ldHdvcms7IH0gfSk7XG5jb25zdCBDcnlwdG9FQ0tleV8xID0gcmVxdWlyZShcIi4vQ3J5cHRvRUNLZXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDcnlwdG9FQ0tleVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ3J5cHRvRUNLZXlfMS5DcnlwdG9FQ0tleTsgfSB9KTtcbmNvbnN0IEJ5dGVzXzEgPSByZXF1aXJlKFwiLi9CeXRlc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJ5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBCeXRlc18xLkJ5dGVzOyB9IH0pO1xuY29uc3QgQ3J5cHRvT3V0cHV0XzEgPSByZXF1aXJlKFwiLi9DcnlwdG9PdXRwdXRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDcnlwdG9PdXRwdXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENyeXB0b091dHB1dF8xLkNyeXB0b091dHB1dDsgfSB9KTtcbmNvbnN0IENyeXB0b1BTQlRfMSA9IHJlcXVpcmUoXCIuL0NyeXB0b1BTQlRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDcnlwdG9QU0JUXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDcnlwdG9QU0JUXzEuQ3J5cHRvUFNCVDsgfSB9KTtcbmNvbnN0IENyeXB0b0FjY291bnRfMSA9IHJlcXVpcmUoXCIuL0NyeXB0b0FjY291bnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDcnlwdG9BY2NvdW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDcnlwdG9BY2NvdW50XzEuQ3J5cHRvQWNjb3VudDsgfSB9KTtcbmNvbnN0IERlY29kZXJfMSA9IHJlcXVpcmUoXCIuL0RlY29kZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVUlJlZ2lzdHJ5RGVjb2RlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRGVjb2Rlcl8xLlVSUmVnaXN0cnlEZWNvZGVyOyB9IH0pO1xuY29uc3QgTXVsdGlLZXlfMSA9IHJlcXVpcmUoXCIuL011bHRpS2V5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTXVsdGlLZXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE11bHRpS2V5XzEuTXVsdGlLZXk7IH0gfSk7XG5jb25zdCBTY3JpcHRFeHByZXNzaW9uXzEgPSByZXF1aXJlKFwiLi9TY3JpcHRFeHByZXNzaW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2NyaXB0RXhwcmVzc2lvbnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFNjcmlwdEV4cHJlc3Npb25fMS5TY3JpcHRFeHByZXNzaW9uczsgfSB9KTtcbmNvbnN0IFBhdGhDb21wb25lbnRfMSA9IHJlcXVpcmUoXCIuL1BhdGhDb21wb25lbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXRoQ29tcG9uZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQYXRoQ29tcG9uZW50XzEuUGF0aENvbXBvbmVudDsgfSB9KTtcbmNvbnN0IFJlZ2lzdHJ5SXRlbV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlJdGVtXCIpO1xuY29uc3QgUmVnaXN0cnlUeXBlXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeVR5cGVcIik7XG5jb25zdCBsaWJfMSA9IHJlcXVpcmUoXCIuL2xpYlwiKTtcbnZhciBsaWJfMiA9IHJlcXVpcmUoXCIuL2xpYlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRhdGFJdGVtXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWJfMi5EYXRhSXRlbTsgfSB9KTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IENyeXB0b011bHRpQWNjb3VudHNfMSA9IHJlcXVpcmUoXCIuL2V4dGVuZGVkL0NyeXB0b011bHRpQWNjb3VudHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDcnlwdG9NdWx0aUFjY291bnRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDcnlwdG9NdWx0aUFjY291bnRzXzEuQ3J5cHRvTXVsdGlBY2NvdW50czsgfSB9KTtcbmNvbnN0IFVSbGliID0ge1xuICAgIFVSUmVnaXN0cnlEZWNvZGVyOiBEZWNvZGVyXzEuVVJSZWdpc3RyeURlY29kZXIsXG4gICAgQnl0ZXM6IEJ5dGVzXzEuQnl0ZXMsXG4gICAgQ3J5cHRvQWNjb3VudDogQ3J5cHRvQWNjb3VudF8xLkNyeXB0b0FjY291bnQsXG4gICAgQ3J5cHRvSERLZXk6IENyeXB0b0hES2V5XzEuQ3J5cHRvSERLZXksXG4gICAgQ3J5cHRvTXVsdGlBY2NvdW50czogQ3J5cHRvTXVsdGlBY2NvdW50c18xLkNyeXB0b011bHRpQWNjb3VudHMsXG4gICAgQ3J5cHRvS2V5cGF0aDogQ3J5cHRvS2V5cGF0aF8xLkNyeXB0b0tleXBhdGgsXG4gICAgQ3J5cHRvQ29pbkluZm86IENyeXB0b0NvaW5JbmZvXzEuQ3J5cHRvQ29pbkluZm8sXG4gICAgQ3J5cHRvQ29pbkluZm9UeXBlOiBDcnlwdG9Db2luSW5mb18xLlR5cGUsXG4gICAgQ3J5cHRvQ29pbkluZm9OZXR3b3JrOiBDcnlwdG9Db2luSW5mb18xLk5ldHdvcmssXG4gICAgQ3J5cHRvRUNLZXk6IENyeXB0b0VDS2V5XzEuQ3J5cHRvRUNLZXksXG4gICAgQ3J5cHRvT3V0cHV0OiBDcnlwdG9PdXRwdXRfMS5DcnlwdG9PdXRwdXQsXG4gICAgQ3J5cHRvUFNCVDogQ3J5cHRvUFNCVF8xLkNyeXB0b1BTQlQsXG4gICAgTXVsdGlLZXk6IE11bHRpS2V5XzEuTXVsdGlLZXksXG4gICAgU2NyaXB0RXhwcmVzc2lvbnM6IFNjcmlwdEV4cHJlc3Npb25fMS5TY3JpcHRFeHByZXNzaW9ucyxcbiAgICBQYXRoQ29tcG9uZW50OiBQYXRoQ29tcG9uZW50XzEuUGF0aENvbXBvbmVudCxcbn07XG5jb25zdCBjYm9yID0ge1xuICAgIGFkZFJlYWRlcjogbGliXzEuYWRkUmVhZGVyLFxuICAgIGFkZFNlbWFudGljRGVjb2RlOiBsaWJfMS5hZGRTZW1hbnRpY0RlY29kZSxcbiAgICBhZGRTZW1hbnRpY0VuY29kZTogbGliXzEuYWRkU2VtYW50aWNFbmNvZGUsXG4gICAgYWRkV3JpdGVyOiBsaWJfMS5hZGRXcml0ZXIsXG4gICAgcGF0Y2hUYWdzOiB1dGlsc18xLnBhdGNoVGFncyxcbn07XG5jb25zdCBleHRlbmQgPSB7XG4gICAgUmVnaXN0cnlUeXBlczogUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcyxcbiAgICBSZWdpc3RyeUl0ZW06IFJlZ2lzdHJ5SXRlbV8xLlJlZ2lzdHJ5SXRlbSxcbiAgICBSZWdpc3RyeVR5cGU6IFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZSxcbiAgICBkZWNvZGVUb0RhdGFJdGVtOiBsaWJfMS5kZWNvZGVUb0RhdGFJdGVtLFxuICAgIGVuY29kZURhdGFJdGVtOiBsaWJfMS5lbmNvZGVEYXRhSXRlbSxcbiAgICBjYm9yLFxufTtcbmV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9lcnJvcnNcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9EZWNvZGVyXCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vbGliXCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vQ3J5cHRvQWNjb3VudFwiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL0NyeXB0b1BTQlRcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9DcnlwdG9IREtleVwiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL2V4dGVuZGVkL0NyeXB0b011bHRpQWNjb3VudHNcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9DcnlwdG9PdXRwdXRcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9DcnlwdG9Db2luSW5mb1wiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL0NyeXB0b0VDS2V5XCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vTXVsdGlLZXlcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9DcnlwdG9LZXlwYXRoXCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vcGF0Y2hDQk9SXCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vUGF0aENvbXBvbmVudFwiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL1JlZ2lzdHJ5SXRlbVwiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL1JlZ2lzdHJ5VHlwZVwiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL3R5cGVzXCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vdXRpbHNcIiksIGV4cG9ydHMpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVVJsaWI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGF0YUl0ZW0gPSB2b2lkIDA7XG5jbGFzcyBEYXRhSXRlbSB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgdGFnKSB7XG4gICAgICAgIHRoaXMuc2V0VGFnID0gKHRhZykgPT4ge1xuICAgICAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xlYXJUYWcgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRhZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRUYWcgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50YWc7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0RGF0YSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgIH1cbn1cbmV4cG9ydHMuRGF0YUl0ZW0gPSBEYXRhSXRlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURhdGFJdGVtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsLkNCT1IgPSBmYWN0b3J5KCk7XG4gICAgfVxufSkodGhpcywgZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHsgRGF0YUl0ZW0gfSA9IHJlcXVpcmUoJy4vRGF0YUl0ZW0nKTtcbiAgICB2YXIgQ0JPUiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEJpbmFyeUhleChoZXgpIHtcbiAgICAgICAgICAgIHRoaXMuJGhleCA9IGhleDtcbiAgICAgICAgfVxuICAgICAgICBCaW5hcnlIZXgucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGhleC5sZW5ndGggLyAyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3JtYXQgfHwgZm9ybWF0ID09PSAnaGV4JyB8fCBmb3JtYXQgPT09IDE2KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaGV4O1xuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICd1dGYtOCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuY29kZWQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiRoZXgubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZWQgKz0gJyUnICsgdGhpcy4kaGV4LnN1YnN0cmluZyhpLCBpICsgMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2xhdGluJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5jb2RlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJGhleC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZC5wdXNoKHBhcnNlSW50KHRoaXMuJGhleC5zdWJzdHJpbmcoaSwgaSArIDIpLCAxNikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgZW5jb2RlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pc2VkIGZvcm1hdDogJyArIGZvcm1hdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBCaW5hcnlIZXguZnJvbUxhdGluU3RyaW5nID0gZnVuY3Rpb24gKGxhdGluU3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgaGV4ID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGluU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhaXIgPSBsYXRpblN0cmluZy5jaGFyQ29kZUF0KGkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgICAgICBpZiAocGFpci5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHBhaXIgPSAnMCcgKyBwYWlyO1xuICAgICAgICAgICAgICAgIGhleCArPSBwYWlyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlIZXgoaGV4KTtcbiAgICAgICAgfTtcbiAgICAgICAgQmluYXJ5SGV4LmZyb21VdGY4U3RyaW5nID0gZnVuY3Rpb24gKHV0ZjhTdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBlbmNvZGVkID0gZW5jb2RlVVJJQ29tcG9uZW50KHV0ZjhTdHJpbmcpO1xuICAgICAgICAgICAgdmFyIGhleCA9ICcnO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kZWQuY2hhckF0KGkpID09PSAnJScpIHtcbiAgICAgICAgICAgICAgICAgICAgaGV4ICs9IGVuY29kZWQuc3Vic3RyaW5nKGkgKyAxLCBpICsgMyk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZXhQYWlyID0gZW5jb2RlZC5jaGFyQ29kZUF0KGkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhleFBhaXIubGVuZ3RoIDwgMilcbiAgICAgICAgICAgICAgICAgICAgICAgIGhleFBhaXIgPSAnMCcgKyBoZXhQYWlyO1xuICAgICAgICAgICAgICAgICAgICBoZXggKz0gaGV4UGFpcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUhleChoZXgpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgc2VtYW50aWNFbmNvZGVycyA9IFtdO1xuICAgICAgICB2YXIgc2VtYW50aWNEZWNvZGVycyA9IHt9O1xuICAgICAgICB2YXIgbm90SW1wbGVtZW50ZWQgPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGxhYmVsICsgJyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIFJlYWRlcigpIHsgfVxuICAgICAgICBSZWFkZXIucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgcGVla0J5dGU6IG5vdEltcGxlbWVudGVkKCdwZWVrQnl0ZScpLFxuICAgICAgICAgICAgcmVhZEJ5dGU6IG5vdEltcGxlbWVudGVkKCdyZWFkQnl0ZScpLFxuICAgICAgICAgICAgcmVhZENodW5rOiBub3RJbXBsZW1lbnRlZCgncmVhZENodW5rJyksXG4gICAgICAgICAgICByZWFkRmxvYXQxNjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBoYWxmID0gdGhpcy5yZWFkVWludDE2KCk7XG4gICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50ID0gKGhhbGYgJiAweDdmZmYpID4+IDEwO1xuICAgICAgICAgICAgICAgIHZhciBtYW50aXNzYSA9IGhhbGYgJiAweDNmZjtcbiAgICAgICAgICAgICAgICB2YXIgbmVnYXRpdmUgPSBoYWxmICYgMHg4MDAwO1xuICAgICAgICAgICAgICAgIGlmIChleHBvbmVudCA9PT0gMHgxZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFudGlzc2EgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZWdhdGl2ZSA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBtYWduaXR1ZGUgPSBleHBvbmVudFxuICAgICAgICAgICAgICAgICAgICA/IE1hdGgucG93KDIsIGV4cG9uZW50IC0gMjUpICogKDEwMjQgKyBtYW50aXNzYSlcbiAgICAgICAgICAgICAgICAgICAgOiBNYXRoLnBvdygyLCAtMjQpICogbWFudGlzc2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5lZ2F0aXZlID8gLW1hZ25pdHVkZSA6IG1hZ25pdHVkZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWFkRmxvYXQzMjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbnRWYWx1ZSA9IHRoaXMucmVhZFVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHZhciBleHBvbmVudCA9IChpbnRWYWx1ZSAmIDB4N2ZmZmZmZmYpID4+IDIzO1xuICAgICAgICAgICAgICAgIHZhciBtYW50aXNzYSA9IGludFZhbHVlICYgMHg3ZmZmZmY7XG4gICAgICAgICAgICAgICAgdmFyIG5lZ2F0aXZlID0gaW50VmFsdWUgJiAweDgwMDAwMDAwO1xuICAgICAgICAgICAgICAgIGlmIChleHBvbmVudCA9PT0gMHhmZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFudGlzc2EgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZWdhdGl2ZSA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBtYWduaXR1ZGUgPSBleHBvbmVudFxuICAgICAgICAgICAgICAgICAgICA/IE1hdGgucG93KDIsIGV4cG9uZW50IC0gMjMgLSAxMjcpICogKDgzODg2MDggKyBtYW50aXNzYSlcbiAgICAgICAgICAgICAgICAgICAgOiBNYXRoLnBvdygyLCAtMjMgLSAxMjYpICogbWFudGlzc2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5lZ2F0aXZlID8gLW1hZ25pdHVkZSA6IG1hZ25pdHVkZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWFkRmxvYXQ2NDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbnQxID0gdGhpcy5yZWFkVWludDMyKCksIGludDIgPSB0aGlzLnJlYWRVaW50MzIoKTtcbiAgICAgICAgICAgICAgICB2YXIgZXhwb25lbnQgPSAoaW50MSA+PiAyMCkgJiAweDdmZjtcbiAgICAgICAgICAgICAgICB2YXIgbWFudGlzc2EgPSAoaW50MSAmIDB4ZmZmZmYpICogNDI5NDk2NzI5NiArIGludDI7XG4gICAgICAgICAgICAgICAgdmFyIG5lZ2F0aXZlID0gaW50MSAmIDB4ODAwMDAwMDA7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50ID09PSAweDdmZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFudGlzc2EgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZWdhdGl2ZSA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBtYWduaXR1ZGUgPSBleHBvbmVudFxuICAgICAgICAgICAgICAgICAgICA/IE1hdGgucG93KDIsIGV4cG9uZW50IC0gNTIgLSAxMDIzKSAqICg0NTAzNTk5NjI3MzcwNDk2ICsgbWFudGlzc2EpXG4gICAgICAgICAgICAgICAgICAgIDogTWF0aC5wb3coMiwgLTUyIC0gMTAyMikgKiBtYW50aXNzYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmVnYXRpdmUgPyAtbWFnbml0dWRlIDogbWFnbml0dWRlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlYWRVaW50MTY6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkQnl0ZSgpICogMjU2ICsgdGhpcy5yZWFkQnl0ZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlYWRVaW50MzI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkVWludDE2KCkgKiA2NTUzNiArIHRoaXMucmVhZFVpbnQxNigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlYWRVaW50NjQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkVWludDMyKCkgKiA0Mjk0OTY3Mjk2ICsgdGhpcy5yZWFkVWludDMyKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBXcml0ZXIoKSB7IH1cbiAgICAgICAgV3JpdGVyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgIHdyaXRlQnl0ZTogbm90SW1wbGVtZW50ZWQoJ3dyaXRlQnl0ZScpLFxuICAgICAgICAgICAgcmVzdWx0OiBub3RJbXBsZW1lbnRlZCgncmVzdWx0JyksXG4gICAgICAgICAgICB3cml0ZUZsb2F0MTY6IG5vdEltcGxlbWVudGVkKCd3cml0ZUZsb2F0MTYnKSxcbiAgICAgICAgICAgIHdyaXRlRmxvYXQzMjogbm90SW1wbGVtZW50ZWQoJ3dyaXRlRmxvYXQzMicpLFxuICAgICAgICAgICAgd3JpdGVGbG9hdDY0OiBub3RJbXBsZW1lbnRlZCgnd3JpdGVGbG9hdDY0JyksXG4gICAgICAgICAgICB3cml0ZVVpbnQxNjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGUoKHZhbHVlID4+IDgpICYgMHhmZik7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGUodmFsdWUgJiAweGZmKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3cml0ZVVpbnQzMjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVVpbnQxNigodmFsdWUgPj4gMTYpICYgMHhmZmZmKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVWludDE2KHZhbHVlICYgMHhmZmZmKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3cml0ZVVpbnQ2NDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID49IDkwMDcxOTkyNTQ3NDA5OTIgfHwgdmFsdWUgPD0gLTkwMDcxOTkyNTQ3NDA5OTIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZW5jb2RlIFVpbnQ2NCBvZjogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIG1hZ25pdHVkZSB0byBiaWcgKGZsb2F0aW5nIHBvaW50IGVycm9ycyknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVVpbnQzMihNYXRoLmZsb29yKHZhbHVlIC8gNDI5NDk2NzI5NikpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVVaW50MzIodmFsdWUgJSA0Mjk0OTY3Mjk2KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3cml0ZVN0cmluZzogbm90SW1wbGVtZW50ZWQoJ3dyaXRlU3RyaW5nJyksXG4gICAgICAgICAgICBjYW5Xcml0ZUJpbmFyeTogZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdyaXRlQmluYXJ5OiBub3RJbXBsZW1lbnRlZCgnd3JpdGVDaHVuaycpLFxuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiByZWFkSGVhZGVyUmF3KHJlYWRlcikge1xuICAgICAgICAgICAgdmFyIGZpcnN0Qnl0ZSA9IHJlYWRlci5yZWFkQnl0ZSgpO1xuICAgICAgICAgICAgdmFyIG1ham9yVHlwZSA9IGZpcnN0Qnl0ZSA+PiA1LCB2YWx1ZSA9IGZpcnN0Qnl0ZSAmIDB4MWY7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBtYWpvclR5cGUsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlRnJvbUhlYWRlcihoZWFkZXIsIHJlYWRlcikge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gaGVhZGVyLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMjQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSAyNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZEJ5dGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09IDI1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkVWludDE2KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSAyNikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZFVpbnQzMigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gMjcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRVaW50NjQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09IDMxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3RJbXBsZW1lbnRlZCgnQWRkaXRpb25hbCBpbmZvOiAnICsgdmFsdWUpKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd3JpdGVIZWFkZXJSYXcodHlwZSwgdmFsdWUsIHdyaXRlcikge1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlQnl0ZSgodHlwZSA8PCA1KSB8IHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cml0ZUhlYWRlcih0eXBlLCB2YWx1ZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RCeXRlID0gdHlwZSA8PCA1O1xuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMjQpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVCeXRlKGZpcnN0Qnl0ZSB8IHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIDwgMjU2KSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlQnl0ZShmaXJzdEJ5dGUgfCAyNCk7XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlQnl0ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA8IDY1NTM2KSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlQnl0ZShmaXJzdEJ5dGUgfCAyNSk7XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlVWludDE2KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIDwgNDI5NDk2NzI5Nikge1xuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZUJ5dGUoZmlyc3RCeXRlIHwgMjYpO1xuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZVVpbnQzMih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVCeXRlKGZpcnN0Qnl0ZSB8IDI3KTtcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVVaW50NjQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzdG9wQ29kZSA9IG5ldyBFcnJvcigpO1xuICAgICAgICBmdW5jdGlvbiBkZWNvZGVSZWFkZXIocmVhZGVyKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gcmVhZEhlYWRlclJhdyhyZWFkZXIpO1xuICAgICAgICAgICAgc3dpdGNoIChoZWFkZXIudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlRnJvbUhlYWRlcihoZWFkZXIsIHJlYWRlcik7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTEgLSB2YWx1ZUZyb21IZWFkZXIoaGVhZGVyLCByZWFkZXIpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQ2h1bmsodmFsdWVGcm9tSGVhZGVyKGhlYWRlciwgcmVhZGVyKSk7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gcmVhZGVyLnJlYWRDaHVuayh2YWx1ZUZyb21IZWFkZXIoaGVhZGVyLCByZWFkZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygndXRmLTgnKTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXlMZW5ndGggPSB2YWx1ZUZyb21IZWFkZXIoaGVhZGVyLCByZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnJheUxlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlci50eXBlID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlMZW5ndGggKj0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGRlY29kZVJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGl0ZW0gPSBkZWNvZGVSZWFkZXIocmVhZGVyKSkgIT09IHN0b3BDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlci50eXBlID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqUmVzdWx0ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialJlc3VsdFtyZXN1bHRbaV1dID0gcmVzdWx0W2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmpSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gdmFsdWVGcm9tSGVhZGVyKGhlYWRlciwgcmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlY29kZXIgPSBzZW1hbnRpY0RlY29kZXJzW3RhZ107XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBkZWNvZGVSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZXIgPyBkZWNvZGVyKHJlc3VsdCkgOiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVyLnZhbHVlID09PSAyNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkRmxvYXQxNigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhlYWRlci52YWx1ZSA9PT0gMjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZEZsb2F0MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChoZWFkZXIudmFsdWUgPT09IDI3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRGbG9hdDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZUZyb21IZWFkZXIoaGVhZGVyLCByZWFkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9wQ29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGZpeGVkIHZhbHVlOiAnICsgaGVhZGVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgaGVhZGVyOiAnICsgSlNPTi5zdHJpbmdpZnkoaGVhZGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlbmNvZGVXcml0ZXIoZGF0YSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbWFudGljRW5jb2RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBzZW1hbnRpY0VuY29kZXJzW2ldLmZuKGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlSGVhZGVyKDYsIHNlbWFudGljRW5jb2RlcnNbaV0udGFnLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlV3JpdGVyKHJlcGxhY2VtZW50LCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhLnRvQ0JPUiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnRvQ0JPUigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVIZWFkZXIoNywgMjAsIHdyaXRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVIZWFkZXIoNywgMjEsIHdyaXRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVIZWFkZXIoNywgMjIsIHdyaXRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB3cml0ZUhlYWRlcig3LCAyMywgd3JpdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmZsb29yKGRhdGEpID09PSBkYXRhICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPCA5MDA3MTk5MjU0NzQwOTkyICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPiAtOTAwNzE5OTI1NDc0MDk5Mikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlSGVhZGVyKDEsIC0xIC0gZGF0YSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlSGVhZGVyKDAsIGRhdGEsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlSGVhZGVyUmF3KDcsIDI3LCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVGbG9hdDY0KGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZVN0cmluZyhkYXRhLCBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlSGVhZGVyKDMsIGxlbmd0aCwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHdyaXRlci5jYW5Xcml0ZUJpbmFyeShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZUJpbmFyeShkYXRhLCBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlSGVhZGVyKDIsIGxlbmd0aCwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmIChhcGkuY29uZmlnLnVzZVRvSlNPTiAmJiB0eXBlb2YgZGF0YS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEudG9KU09OKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlSGVhZGVyKDQsIGRhdGEubGVuZ3RoLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVdyaXRlcihkYXRhW2ldLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZUhlYWRlcig1LCBrZXlzLmxlbmd0aCwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBudW1iZXIgPSBwYXJzZUludChrZXlzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihudW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlV3JpdGVyKGtleXNbaV0sIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlV3JpdGVyKGRhdGFba2V5c1tpXV0sIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVXcml0ZXIobnVtYmVyLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVdyaXRlcihkYXRhW2tleXNbaV1dLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDQk9SIGVuY29kaW5nIG5vdCBzdXBwb3J0ZWQ6ICcgKyBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVhZGVyRnVuY3Rpb25zID0gW107XG4gICAgICAgIHZhciB3cml0ZXJGdW5jdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIGFwaSA9IHtcbiAgICAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgICAgIHVzZVRvSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRXcml0ZXI6IGZ1bmN0aW9uIChmb3JtYXQsIHdyaXRlckZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlckZ1bmN0aW9ucy5wdXNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBmKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZXJGdW5jdGlvbihmKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3cml0ZXJGdW5jdGlvbnMucHVzaChmb3JtYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRSZWFkZXI6IGZ1bmN0aW9uIChmb3JtYXQsIHJlYWRlckZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlckZ1bmN0aW9ucy5wdXNoKGZ1bmN0aW9uIChkYXRhLCBmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBmKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXJGdW5jdGlvbihkYXRhLCBmKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXJGdW5jdGlvbnMucHVzaChmb3JtYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uIChkYXRhLCBmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdyaXRlckZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVuYyA9IHdyaXRlckZ1bmN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdyaXRlciA9IGZ1bmMoZm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdyaXRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlV3JpdGVyKGRhdGEsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVyLnJlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgb3V0cHV0IGZvcm1hdDogJyArIGZvcm1hdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5jb2RlRGF0YUl0ZW06IGZ1bmN0aW9uIChkYXRhLCBmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdyaXRlckZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVuYyA9IHdyaXRlckZ1bmN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdyaXRlciA9IGZ1bmMoZm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdyaXRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuZ2V0VGFnKCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVdyaXRlcihkYXRhLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZXIucmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVXcml0ZXIoZGF0YS5nZXREYXRhKCksIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlci5yZXN1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG91dHB1dCBmb3JtYXQ6ICcgKyBmb3JtYXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29kZTogZnVuY3Rpb24gKGRhdGEsIGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVhZGVyRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdW5jID0gcmVhZGVyRnVuY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gZnVuYyhkYXRhLCBmb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBpbnB1dCBmb3JtYXQ6ICcgKyBmb3JtYXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29kZVRvRGF0YUl0ZW06IGZ1bmN0aW9uIChkYXRhLCBmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlYWRlckZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVuYyA9IHJlYWRlckZ1bmN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IGZ1bmMoZGF0YSwgZm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVjb2RlUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRGF0YUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRhSXRlbShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgaW5wdXQgZm9ybWF0OiAnICsgZm9ybWF0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRTZW1hbnRpY0VuY29kZTogZnVuY3Rpb24gKHRhZywgZm4pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhZyAhPT0gJ251bWJlcicgfHwgdGFnICUgMSAhPT0gMCB8fCB0YWcgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGFnIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbWFudGljRW5jb2RlcnMucHVzaCh7IHRhZzogdGFnLCBmbjogZm4gfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkU2VtYW50aWNEZWNvZGU6IGZ1bmN0aW9uICh0YWcsIGZuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YWcgIT09ICdudW1iZXInIHx8IHRhZyAlIDEgIT09IDAgfHwgdGFnIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhZyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZW1hbnRpY0RlY29kZXJzW3RhZ10gPSBmbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlclJlYWRlcihidWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIEJ1ZmZlclJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlYWRlci5wcm90b3R5cGUpO1xuICAgICAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLnBlZWtCeXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMucG9zXTtcbiAgICAgICAgfTtcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkQnl0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLnBvcysrXTtcbiAgICAgICAgfTtcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkVWludDE2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuYnVmZmVyLnJlYWRVSW50MTZCRSh0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkVWludDMyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuYnVmZmVyLnJlYWRVSW50MzJCRSh0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkRmxvYXQzMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmJ1ZmZlci5yZWFkRmxvYXRCRSh0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkRmxvYXQ2NCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmJ1ZmZlci5yZWFkRG91YmxlQkUodGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIEJ1ZmZlclJlYWRlci5wcm90b3R5cGUucmVhZENodW5rID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IEJ1ZmZlci5hbGxvYyhsZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIuY29weShyZXN1bHQsIDAsIHRoaXMucG9zLCAodGhpcy5wb3MgKz0gbGVuZ3RoKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBCdWZmZXJXcml0ZXIoc3RyaW5nRm9ybWF0KSB7XG4gICAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0QnVmZmVyTGVuZ3RoID0gMTYzODQ7XG4gICAgICAgICAgICB0aGlzLmxhdGVzdEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyh0aGlzLmRlZmF1bHRCdWZmZXJMZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQgPSAwO1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc3RyaW5nRm9ybWF0ID0gc3RyaW5nRm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIEJ1ZmZlcldyaXRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdyaXRlci5wcm90b3R5cGUpO1xuICAgICAgICBCdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlQnl0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RCdWZmZXJbdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQrK10gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCA+PSB0aGlzLmxhdGVzdEJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlQnVmZmVycy5wdXNoKHRoaXMubGF0ZXN0QnVmZmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyh0aGlzLmRlZmF1bHRCdWZmZXJMZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCsrO1xuICAgICAgICB9O1xuICAgICAgICBCdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlRmxvYXQzMiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZUZsb2F0QkUodmFsdWUsIDApO1xuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcihidWZmZXIpO1xuICAgICAgICB9O1xuICAgICAgICBCdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlRmxvYXQ2NCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg4KTtcbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZURvdWJsZUJFKHZhbHVlLCAwKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXIoYnVmZmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnVmZmVyV3JpdGVyLnByb3RvdHlwZS53cml0ZVN0cmluZyA9IGZ1bmN0aW9uIChzdHJpbmcsIGxlbmd0aEZ1bmMpIHtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBCdWZmZXIuZnJvbShzdHJpbmcsICd1dGYtOCcpO1xuICAgICAgICAgICAgbGVuZ3RoRnVuYyhidWZmZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXIoYnVmZmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5jYW5Xcml0ZUJpbmFyeSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIEJ1ZmZlcjtcbiAgICAgICAgfTtcbiAgICAgICAgQnVmZmVyV3JpdGVyLnByb3RvdHlwZS53cml0ZUJpbmFyeSA9IGZ1bmN0aW9uIChidWZmZXIsIGxlbmd0aEZ1bmMpIHtcbiAgICAgICAgICAgIGxlbmd0aEZ1bmMoYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgIH07XG4gICAgICAgIEJ1ZmZlcldyaXRlci5wcm90b3R5cGUud3JpdGVCdWZmZXIgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgIGlmICghKGNodW5rIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCdWZmZXJXcml0ZXIgb25seSBhY2NlcHRzIEJ1ZmZlcnMnKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlQnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubGF0ZXN0QnVmZmVyLmxlbmd0aCAtIHRoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0ID49XG4gICAgICAgICAgICAgICAgY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsuY29weSh0aGlzLmxhdGVzdEJ1ZmZlciwgdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQgPj0gdGhpcy5sYXRlc3RCdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVCdWZmZXJzLnB1c2godGhpcy5sYXRlc3RCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyh0aGlzLmRlZmF1bHRCdWZmZXJMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUJ1ZmZlcnMucHVzaCh0aGlzLmxhdGVzdEJ1ZmZlci5zbGljZSgwLCB0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVCdWZmZXJzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0QnVmZmVyID0gQnVmZmVyLmFsbG9jKHRoaXMuZGVmYXVsdEJ1ZmZlckxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgfTtcbiAgICAgICAgQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5yZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gQnVmZmVyLmFsbG9jKHRoaXMuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb21wbGV0ZUJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5jb21wbGV0ZUJ1ZmZlcnNbaV07XG4gICAgICAgICAgICAgICAgYnVmZmVyLmNvcHkocmVzdWx0LCBvZmZzZXQsIDAsIGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RCdWZmZXIuY29weShyZXN1bHQsIG9mZnNldCwgMCwgdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RyaW5nRm9ybWF0KVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcodGhpcy5zdHJpbmdGb3JtYXQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFwaS5hZGRSZWFkZXIoZnVuY3Rpb24gKGRhdGEsIGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJSZWFkZXIoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdoZXgnIHx8IGZvcm1hdCA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGRhdGEsIGZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyUmVhZGVyKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhcGkuYWRkV3JpdGVyKGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZvcm1hdCB8fCBmb3JtYXQgPT09ICdidWZmZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2hleCcgfHwgZm9ybWF0ID09PSAnYmFzZTY0Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcldyaXRlcihmb3JtYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIEhleFJlYWRlcihoZXgpIHtcbiAgICAgICAgICAgIHRoaXMuaGV4ID0gaGV4O1xuICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIEhleFJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlYWRlci5wcm90b3R5cGUpO1xuICAgICAgICBIZXhSZWFkZXIucHJvdG90eXBlLnBlZWtCeXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSB0aGlzLmhleC5zdWJzdHJpbmcodGhpcy5wb3MsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHBhaXIsIDE2KTtcbiAgICAgICAgfTtcbiAgICAgICAgSGV4UmVhZGVyLnByb3RvdHlwZS5yZWFkQnl0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYWlyID0gdGhpcy5oZXguc3Vic3RyaW5nKHRoaXMucG9zLCB0aGlzLnBvcyArIDIpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gMjtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChwYWlyLCAxNik7XG4gICAgICAgIH07XG4gICAgICAgIEhleFJlYWRlci5wcm90b3R5cGUucmVhZENodW5rID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGhleCA9IHRoaXMuaGV4LnN1YnN0cmluZyh0aGlzLnBvcywgdGhpcy5wb3MgKyBsZW5ndGggKiAyKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IGxlbmd0aCAqIDI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oaGV4LCAnaGV4Jyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUhleChoZXgpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBIZXhXcml0ZXIoZmluYWxGb3JtYXQpIHtcbiAgICAgICAgICAgIHRoaXMuJGhleCA9ICcnO1xuICAgICAgICAgICAgdGhpcy5maW5hbEZvcm1hdCA9IGZpbmFsRm9ybWF0IHx8ICdoZXgnO1xuICAgICAgICB9XG4gICAgICAgIEhleFdyaXRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdyaXRlci5wcm90b3R5cGUpO1xuICAgICAgICBIZXhXcml0ZXIucHJvdG90eXBlLndyaXRlQnl0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDI1NSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0J5dGUgdmFsdWUgb3V0IG9mIHJhbmdlOiAnICsgdmFsdWUpO1xuICAgICAgICAgICAgdmFyIGhleCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBoZXggPSAnMCcgKyBoZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRoZXggKz0gaGV4O1xuICAgICAgICB9O1xuICAgICAgICBIZXhXcml0ZXIucHJvdG90eXBlLmNhbldyaXRlQmluYXJ5ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gKGNodW5rIGluc3RhbmNlb2YgQmluYXJ5SGV4IHx8XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgY2h1bmsgaW5zdGFuY2VvZiBCdWZmZXIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgSGV4V3JpdGVyLnByb3RvdHlwZS53cml0ZUJpbmFyeSA9IGZ1bmN0aW9uIChjaHVuaywgbGVuZ3RoRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChjaHVuayBpbnN0YW5jZW9mIEJpbmFyeUhleCkge1xuICAgICAgICAgICAgICAgIGxlbmd0aEZ1bmN0aW9uKGNodW5rLmxlbmd0aCgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRoZXggKz0gY2h1bmsuJGhleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgY2h1bmsgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGhGdW5jdGlvbihjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGhleCArPSBjaHVuay50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIZXhXcml0ZXIgb25seSBhY2NlcHRzIEJpbmFyeUhleCBvciBCdWZmZXJzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEhleFdyaXRlci5wcm90b3R5cGUucmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmluYWxGb3JtYXQgPT09ICdidWZmZXInICYmIHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy4kaGV4LCAnaGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUhleCh0aGlzLiRoZXgpLnRvU3RyaW5nKHRoaXMuZmluYWxGb3JtYXQpO1xuICAgICAgICB9O1xuICAgICAgICBIZXhXcml0ZXIucHJvdG90eXBlLndyaXRlU3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZywgbGVuZ3RoRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBCaW5hcnlIZXguZnJvbVV0ZjhTdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICAgIGxlbmd0aEZ1bmN0aW9uKGJ1ZmZlci5sZW5ndGgoKSk7XG4gICAgICAgICAgICB0aGlzLiRoZXggKz0gYnVmZmVyLiRoZXg7XG4gICAgICAgIH07XG4gICAgICAgIGFwaS5hZGRSZWFkZXIoZnVuY3Rpb24gKGRhdGEsIGZvcm1hdCkge1xuICAgICAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBCaW5hcnlIZXggfHwgZGF0YS4kaGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIZXhSZWFkZXIoZGF0YS4kaGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdoZXgnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIZXhSZWFkZXIoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhcGkuYWRkV3JpdGVyKGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdoZXgnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIZXhXcml0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgfSkoKTtcbiAgICBDQk9SLmFkZFNlbWFudGljRW5jb2RlKDAsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgICAgIC5hZGRTZW1hbnRpY0RlY29kZSgwLCBmdW5jdGlvbiAoaXNvU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShpc29TdHJpbmcpO1xuICAgIH0pXG4gICAgICAgIC5hZGRTZW1hbnRpY0RlY29kZSgxLCBmdW5jdGlvbiAoaXNvU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShpc29TdHJpbmcpO1xuICAgIH0pO1xuICAgIHJldHVybiBDQk9SO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYm9yLXN5bmMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRhdGFJdGVtID0gZXhwb3J0cy5hZGRXcml0ZXIgPSBleHBvcnRzLmFkZFJlYWRlciA9IGV4cG9ydHMuYWRkU2VtYW50aWNFbmNvZGUgPSBleHBvcnRzLmFkZFNlbWFudGljRGVjb2RlID0gZXhwb3J0cy5kZWNvZGVUb0RhdGFJdGVtID0gZXhwb3J0cy5lbmNvZGVEYXRhSXRlbSA9IHZvaWQgMDtcbnZhciBjYm9yX3N5bmNfMSA9IHJlcXVpcmUoXCIuL2Nib3Itc3luY1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZURhdGFJdGVtXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYm9yX3N5bmNfMS5lbmNvZGVEYXRhSXRlbTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZVRvRGF0YUl0ZW1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNib3Jfc3luY18xLmRlY29kZVRvRGF0YUl0ZW07IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhZGRTZW1hbnRpY0RlY29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2Jvcl9zeW5jXzEuYWRkU2VtYW50aWNEZWNvZGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhZGRTZW1hbnRpY0VuY29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2Jvcl9zeW5jXzEuYWRkU2VtYW50aWNFbmNvZGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhZGRSZWFkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNib3Jfc3luY18xLmFkZFJlYWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZFdyaXRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2Jvcl9zeW5jXzEuYWRkV3JpdGVyOyB9IH0pO1xudmFyIERhdGFJdGVtXzEgPSByZXF1aXJlKFwiLi9EYXRhSXRlbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRhdGFJdGVtXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBEYXRhSXRlbV8xLkRhdGFJdGVtOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBSZWdpc3RyeVR5cGVfMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5VHlwZVwiKTtcbmNvbnN0IFNjcmlwdEV4cHJlc3Npb25fMSA9IHJlcXVpcmUoXCIuL1NjcmlwdEV4cHJlc3Npb25cIik7XG5jb25zdCByZWdpc3RyeVRhZ3MgPSBPYmplY3QudmFsdWVzKFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMpXG4gICAgLmZpbHRlcigocikgPT4gISFyLmdldFRhZygpKVxuICAgIC5tYXAoKHIpID0+IHIuZ2V0VGFnKCkpO1xuY29uc3Qgc2NyaXB0RXhwcmVzc2lvblRhZ3MgPSBPYmplY3QudmFsdWVzKFNjcmlwdEV4cHJlc3Npb25fMS5TY3JpcHRFeHByZXNzaW9ucykubWFwKChzZSkgPT4gc2UuZ2V0VGFnKCkpO1xuKDAsIHV0aWxzXzEucGF0Y2hUYWdzKShyZWdpc3RyeVRhZ3MuY29uY2F0KHNjcmlwdEV4cHJlc3Npb25UYWdzKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRjaENCT1IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGF0Y2hUYWdzID0gdm9pZCAwO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi9saWJcIik7XG5jb25zdCBhbHJlYWR5UGF0Y2hlZFRhZyA9IFtdO1xuY29uc3QgcGF0Y2hUYWdzID0gKHRhZ3MpID0+IHtcbiAgICB0YWdzLmZvckVhY2goKHRhZykgPT4ge1xuICAgICAgICBpZiAoYWxyZWFkeVBhdGNoZWRUYWcuZmluZCgoaSkgPT4gaSA9PT0gdGFnKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgKDAsIGxpYl8xLmFkZFNlbWFudGljRW5jb2RlKSh0YWcsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIGxpYl8xLkRhdGFJdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZ2V0VGFnKCkgPT09IHRhZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5nZXREYXRhKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgKDAsIGxpYl8xLmFkZFNlbWFudGljRGVjb2RlKSh0YWcsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGxpYl8xLkRhdGFJdGVtKGRhdGEsIHRhZyk7XG4gICAgICAgIH0pO1xuICAgICAgICBhbHJlYWR5UGF0Y2hlZFRhZy5wdXNoKHRhZyk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy5wYXRjaFRhZ3MgPSBwYXRjaFRhZ3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXRpbHMgPSBleHBvcnRzLmRlY29kZSA9IGV4cG9ydHMuZW5jb2RlID0gdm9pZCAwO1xuLyoqXG4gKiBSTFAgRW5jb2RpbmcgYmFzZWQgb24gaHR0cHM6Ly9ldGgud2lraS9lbi9mdW5kYW1lbnRhbHMvcmxwXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGluIGRhdGEsIGNvbnZlcnRzIGl0IHRvIFVpbnQ4QXJyYXkgaWYgbm90LFxuICogYW5kIGFkZHMgYSBsZW5ndGggZm9yIHJlY3Vyc2lvbi5cbiAqIEBwYXJhbSBpbnB1dCBXaWxsIGJlIGNvbnZlcnRlZCB0byBVaW50OEFycmF5XG4gKiBAcmV0dXJucyBVaW50OEFycmF5IG9mIGVuY29kZWQgZGF0YVxuICoqL1xuZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChlbmNvZGUoaW5wdXRbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWYgPSBjb25jYXRCeXRlcyguLi5vdXRwdXQpO1xuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoZW5jb2RlTGVuZ3RoKGJ1Zi5sZW5ndGgsIDE5MiksIGJ1Zik7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0QnVmID0gdG9CeXRlcyhpbnB1dCk7XG4gICAgaWYgKGlucHV0QnVmLmxlbmd0aCA9PT0gMSAmJiBpbnB1dEJ1ZlswXSA8IDEyOCkge1xuICAgICAgICByZXR1cm4gaW5wdXRCdWY7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXRCeXRlcyhlbmNvZGVMZW5ndGgoaW5wdXRCdWYubGVuZ3RoLCAxMjgpLCBpbnB1dEJ1Zik7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbi8qKlxuICogU2xpY2VzIGEgVWludDhBcnJheSwgdGhyb3dzIGlmIHRoZSBzbGljZSBnb2VzIG91dC1vZi1ib3VuZHMgb2YgdGhlIFVpbnQ4QXJyYXkuXG4gKiBFLmcuIGBzYWZlU2xpY2UoaGV4VG9CeXRlcygnYWEnKSwgMSwgMilgIHdpbGwgdGhyb3cuXG4gKiBAcGFyYW0gaW5wdXRcbiAqIEBwYXJhbSBzdGFydFxuICogQHBhcmFtIGVuZFxuICovXG5mdW5jdGlvbiBzYWZlU2xpY2UoaW5wdXQsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoZW5kID4gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFAgKHNhZmVTbGljZSk6IGVuZCBzbGljZSBvZiBVaW50OEFycmF5IG91dC1vZi1ib3VuZHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpO1xufVxuLyoqXG4gKiBQYXJzZSBpbnRlZ2Vycy4gQ2hlY2sgaWYgdGhlcmUgaXMgbm8gbGVhZGluZyB6ZXJvc1xuICogQHBhcmFtIHYgVGhlIHZhbHVlIHRvIHBhcnNlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZUxlbmd0aCh2KSB7XG4gICAgaWYgKHZbMF0gPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogZXh0cmEgemVyb3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlSGV4Qnl0ZShieXRlc1RvSGV4KHYpKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUxlbmd0aChsZW4sIG9mZnNldCkge1xuICAgIGlmIChsZW4gPCA1Nikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKFtsZW4gKyBvZmZzZXRdKTtcbiAgICB9XG4gICAgY29uc3QgaGV4TGVuZ3RoID0gbnVtYmVyVG9IZXgobGVuKTtcbiAgICBjb25zdCBsTGVuZ3RoID0gaGV4TGVuZ3RoLmxlbmd0aCAvIDI7XG4gICAgY29uc3QgZmlyc3RCeXRlID0gbnVtYmVyVG9IZXgob2Zmc2V0ICsgNTUgKyBsTGVuZ3RoKTtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGhleFRvQnl0ZXMoZmlyc3RCeXRlICsgaGV4TGVuZ3RoKSk7XG59XG5mdW5jdGlvbiBkZWNvZGUoaW5wdXQsIHN0cmVhbSA9IGZhbHNlKSB7XG4gICAgaWYgKCFpbnB1dCB8fCBpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShbXSk7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0Qnl0ZXMgPSB0b0J5dGVzKGlucHV0KTtcbiAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShpbnB1dEJ5dGVzKTtcbiAgICBpZiAoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgIH1cbiAgICBpZiAoZGVjb2RlZC5yZW1haW5kZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IHJlbWFpbmRlciBtdXN0IGJlIHplcm8nKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZWQuZGF0YTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuLyoqIERlY29kZSBhbiBpbnB1dCB3aXRoIFJMUCAqL1xuZnVuY3Rpb24gX2RlY29kZShpbnB1dCkge1xuICAgIGxldCBsZW5ndGgsIGxsZW5ndGgsIGRhdGEsIGlubmVyUmVtYWluZGVyLCBkO1xuICAgIGNvbnN0IGRlY29kZWQgPSBbXTtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBpbnB1dFswXTtcbiAgICBpZiAoZmlyc3RCeXRlIDw9IDB4N2YpIHtcbiAgICAgICAgLy8gYSBzaW5nbGUgYnl0ZSB3aG9zZSB2YWx1ZSBpcyBpbiB0aGUgWzB4MDAsIDB4N2ZdIHJhbmdlLCB0aGF0IGJ5dGUgaXMgaXRzIG93biBSTFAgZW5jb2RpbmcuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBpbnB1dC5zbGljZSgwLCAxKSxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UoMSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGI3KSB7XG4gICAgICAgIC8vIHN0cmluZyBpcyAwLTU1IGJ5dGVzIGxvbmcuIEEgc2luZ2xlIGJ5dGUgd2l0aCB2YWx1ZSAweDgwIHBsdXMgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIGZvbGxvd2VkIGJ5IHRoZSBzdHJpbmdcbiAgICAgICAgLy8gVGhlIHJhbmdlIG9mIHRoZSBmaXJzdCBieXRlIGlzIFsweDgwLCAweGI3XVxuICAgICAgICBsZW5ndGggPSBmaXJzdEJ5dGUgLSAweDdmO1xuICAgICAgICAvLyBzZXQgMHg4MCBudWxsIHRvIDBcbiAgICAgICAgaWYgKGZpcnN0Qnl0ZSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgZGF0YSA9IFVpbnQ4QXJyYXkuZnJvbShbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gc2FmZVNsaWNlKGlucHV0LCAxLCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPT09IDIgJiYgZGF0YVswXSA8IDB4ODApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFAgZW5jb2Rpbmc6IGludmFsaWQgcHJlZml4LCBzaW5nbGUgYnl0ZSA8IDB4ODAgYXJlIG5vdCBwcmVmaXhlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZShsZW5ndGgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhiZikge1xuICAgICAgICAvLyBzdHJpbmcgaXMgZ3JlYXRlciB0aGFuIDU1IGJ5dGVzIGxvbmcuIEEgc2luZ2xlIGJ5dGUgd2l0aCB0aGUgdmFsdWUgKDB4YjcgcGx1cyB0aGUgbGVuZ3RoIG9mIHRoZSBsZW5ndGgpLFxuICAgICAgICAvLyBmb2xsb3dlZCBieSB0aGUgbGVuZ3RoLCBmb2xsb3dlZCBieSB0aGUgc3RyaW5nXG4gICAgICAgIGxsZW5ndGggPSBmaXJzdEJ5dGUgLSAweGI2O1xuICAgICAgICBpZiAoaW5wdXQubGVuZ3RoIC0gMSA8IGxsZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IG5vdCBlbm91Z2ggYnl0ZXMgZm9yIHN0cmluZyBsZW5ndGgnKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggPSBkZWNvZGVMZW5ndGgoc2FmZVNsaWNlKGlucHV0LCAxLCBsbGVuZ3RoKSk7XG4gICAgICAgIGlmIChsZW5ndGggPD0gNTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IGV4cGVjdGVkIHN0cmluZyBsZW5ndGggdG8gYmUgZ3JlYXRlciB0aGFuIDU1Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IHNhZmVTbGljZShpbnB1dCwgbGxlbmd0aCwgbGVuZ3RoICsgbGxlbmd0aCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZShsZW5ndGggKyBsbGVuZ3RoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4ZjcpIHtcbiAgICAgICAgLy8gYSBsaXN0IGJldHdlZW4gMC01NSBieXRlcyBsb25nXG4gICAgICAgIGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4YmY7XG4gICAgICAgIGlubmVyUmVtYWluZGVyID0gc2FmZVNsaWNlKGlucHV0LCAxLCBsZW5ndGgpO1xuICAgICAgICB3aGlsZSAoaW5uZXJSZW1haW5kZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBkID0gX2RlY29kZShpbm5lclJlbWFpbmRlcik7XG4gICAgICAgICAgICBkZWNvZGVkLnB1c2goZC5kYXRhKTtcbiAgICAgICAgICAgIGlubmVyUmVtYWluZGVyID0gZC5yZW1haW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGRlY29kZWQsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKGxlbmd0aCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBhIGxpc3Qgb3ZlciA1NSBieXRlcyBsb25nXG4gICAgICAgIGxsZW5ndGggPSBmaXJzdEJ5dGUgLSAweGY2O1xuICAgICAgICBsZW5ndGggPSBkZWNvZGVMZW5ndGgoc2FmZVNsaWNlKGlucHV0LCAxLCBsbGVuZ3RoKSk7XG4gICAgICAgIGlmIChsZW5ndGggPCA1Nikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogZW5jb2RlZCBsaXN0IHRvbyBzaG9ydCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvdGFsTGVuZ3RoID0gbGxlbmd0aCArIGxlbmd0aDtcbiAgICAgICAgaWYgKHRvdGFsTGVuZ3RoID4gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiB0b3RhbCBsZW5ndGggaXMgbGFyZ2VyIHRoYW4gdGhlIGRhdGEnKTtcbiAgICAgICAgfVxuICAgICAgICBpbm5lclJlbWFpbmRlciA9IHNhZmVTbGljZShpbnB1dCwgbGxlbmd0aCwgdG90YWxMZW5ndGgpO1xuICAgICAgICB3aGlsZSAoaW5uZXJSZW1haW5kZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBkID0gX2RlY29kZShpbm5lclJlbWFpbmRlcik7XG4gICAgICAgICAgICBkZWNvZGVkLnB1c2goZC5kYXRhKTtcbiAgICAgICAgICAgIGlubmVyUmVtYWluZGVyID0gZC5yZW1haW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGRlY29kZWQsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKHRvdGFsTGVuZ3RoKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5jb25zdCBjYWNoZWRIZXhlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoX3YsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuZnVuY3Rpb24gYnl0ZXNUb0hleCh1aW50OGEpIHtcbiAgICAvLyBQcmUtY2FjaGluZyBjaGFycyB3aXRoIGBjYWNoZWRIZXhlc2Agc3BlZWRzIHRoaXMgdXAgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1aW50OGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGNhY2hlZEhleGVzW3VpbnQ4YVtpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5mdW5jdGlvbiBwYXJzZUhleEJ5dGUoaGV4Qnl0ZSkge1xuICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgcmV0dXJuIGJ5dGU7XG59XG4vLyBDYWNoaW5nIHNsb3dzIGl0IGRvd24gMi0zeFxuZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaGV4VG9CeXRlczogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIH1cbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4VG9CeXRlczogcmVjZWl2ZWQgaW52YWxpZCB1bnBhZGRlZCBoZXgnKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgYXJyYXlbaV0gPSBwYXJzZUhleEJ5dGUoaGV4LnNsaWNlKGosIGogKyAyKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8qKiBDb25jYXRlbmF0ZXMgdHdvIFVpbnQ4QXJyYXlzIGludG8gb25lLiAqL1xuZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgaWYgKGFycmF5cy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBhcnJheXNbMF07XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXlzLnJlZHVjZSgoYSwgYXJyKSA9PiBhICsgYXJyLmxlbmd0aCwgMCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhcnIgPSBhcnJheXNbaV07XG4gICAgICAgIHJlc3VsdC5zZXQoYXJyLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHV0Zikge1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodXRmKTtcbn1cbi8qKiBUcmFuc2Zvcm0gYW4gaW50ZWdlciBpbnRvIGl0cyBoZXhhZGVjaW1hbCB2YWx1ZSAqL1xuZnVuY3Rpb24gbnVtYmVyVG9IZXgoaW50ZWdlcikge1xuICAgIGlmIChpbnRlZ2VyIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50ZWdlciBhcyBhcmd1bWVudCwgbXVzdCBiZSB1bnNpZ25lZCEnKTtcbiAgICB9XG4gICAgY29uc3QgaGV4ID0gaW50ZWdlci50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJSAyID8gYDAke2hleH1gIDogaGV4O1xufVxuLyoqIFBhZCBhIHN0cmluZyB0byBiZSBldmVuICovXG5mdW5jdGlvbiBwYWRUb0V2ZW4oYSkge1xuICAgIHJldHVybiBhLmxlbmd0aCAlIDIgPyBgMCR7YX1gIDogYTtcbn1cbi8qKiBDaGVjayBpZiBhIHN0cmluZyBpcyBwcmVmaXhlZCBieSAweCAqL1xuZnVuY3Rpb24gaXNIZXhQcmVmaXhlZChzdHIpIHtcbiAgICByZXR1cm4gc3RyLmxlbmd0aCA+PSAyICYmIHN0clswXSA9PT0gJzAnICYmIHN0clsxXSA9PT0gJ3gnO1xufVxuLyoqIFJlbW92ZXMgMHggZnJvbSBhIGdpdmVuIFN0cmluZyAqL1xuZnVuY3Rpb24gc3RyaXBIZXhQcmVmaXgoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHJldHVybiBpc0hleFByZWZpeGVkKHN0cikgPyBzdHIuc2xpY2UoMikgOiBzdHI7XG59XG4vKiogVHJhbnNmb3JtIGFueXRoaW5nIGludG8gYSBVaW50OEFycmF5ICovXG5mdW5jdGlvbiB0b0J5dGVzKHYpIHtcbiAgICBpZiAodiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGlzSGV4UHJlZml4ZWQodikpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhUb0J5dGVzKHBhZFRvRXZlbihzdHJpcEhleFByZWZpeCh2KSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyh2KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKFtdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyhudW1iZXJUb0hleCh2KSk7XG4gICAgfVxuICAgIGlmICh2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKFtdKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0b0J5dGVzOiByZWNlaXZlZCB1bnN1cHBvcnRlZCB0eXBlICcgKyB0eXBlb2Ygdik7XG59XG5leHBvcnRzLnV0aWxzID0ge1xuICAgIGJ5dGVzVG9IZXgsXG4gICAgY29uY2F0Qnl0ZXMsXG4gICAgaGV4VG9CeXRlcyxcbiAgICB1dGY4VG9CeXRlcyxcbn07XG5jb25zdCBSTFAgPSB7IGVuY29kZSwgZGVjb2RlIH07XG5leHBvcnRzLmRlZmF1bHQgPSBSTFA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcbid1c2Ugc3RyaWN0J1xuXG5pZiAoXCJkZXZlbG9wbWVudFwiID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nLmNqcy5wcm9kdWN0aW9uLm1pbi5qcycpXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcuY2pzLmRldmVsb3BtZW50LmpzJylcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciBiYXNlRXRoS2V5cmluZyA9IHJlcXVpcmUoJ0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcnKTtcbnZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcbnZhciBvYnNTdG9yZSA9IHJlcXVpcmUoJ0BtZXRhbWFzay9vYnMtc3RvcmUnKTtcbnZhciBiY1VyUmVnaXN0cnlFdGggPSByZXF1aXJlKCdAa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS1ldGgnKTtcbnZhciB1dWlkID0gcmVxdWlyZSgndXVpZCcpO1xudmFyIHR4ID0gcmVxdWlyZSgnQGV0aGVyZXVtanMvdHgnKTtcbnZhciBybHAgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgncmxwJykpO1xuXG5jbGFzcyBNZXRhbWFza0ludGVyYWN0aW9uUHJvdmlkZXIgZXh0ZW5kcyBldmVudHMuRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuY2xlYW5TeW5jTGlzdGVuZXJzID0gKCkgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJrZXlzdG9uZS1zeW5jX3N1Y2Nlc3MtaGRrZXlcIik7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhcImtleXN0b25lLXN5bmNfc3VjY2Vzcy1hY2NvdW50XCIpO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJrZXlzdG9uZS1zeW5jX2NhbmNlbFwiKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jbGVhblNpZ25MaXN0ZW5lcnMgPSByZXF1ZXN0SWQgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoYCR7cmVxdWVzdElkfS1zaWduZWRgKTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGAke3JlcXVlc3RJZH0tY2FuY2VsZWRgKTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZWFkQ3J5cHRvSERLZXlPckNyeXB0b0FjY291bnQgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgICBzeW5jOiB7XG4gICAgICAgICAgICByZWFkaW5nOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbihcImtleXN0b25lLXN5bmNfc3VjY2Vzcy1oZGtleVwiLCBjYm9yID0+IHtcbiAgICAgICAgICBjb25zdCBjcnlwdG9IREtleSA9IGJjVXJSZWdpc3RyeUV0aC5DcnlwdG9IREtleS5mcm9tQ0JPUihCdWZmZXIuZnJvbShjYm9yLCBcImhleFwiKSk7XG4gICAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgICAgICAgcmVzb2x2ZShjcnlwdG9IREtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKFwia2V5c3RvbmUtc3luY19zdWNjZXNzLWFjY291bnRcIiwgY2JvciA9PiB7XG4gICAgICAgICAgY29uc3QgY3J5cHRvQWNjb3VudCA9IGJjVXJSZWdpc3RyeUV0aC5DcnlwdG9BY2NvdW50LmZyb21DQk9SKEJ1ZmZlci5mcm9tKGNib3IsIFwiaGV4XCIpKTtcbiAgICAgICAgICB0aGlzLnJlc2V0U3RhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKGNyeXB0b0FjY291bnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbihcImtleXN0b25lLXN5bmNfY2FuY2VsXCIsICgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0U3RhdGUoKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNzeW5jX2NhbmNlbC4gU3luYyBwcm9jZXNzIGNhbmNlbGVkLCBwbGVhc2UgcmV0cnlcIikpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLnN1Ym1pdENyeXB0b0hES2V5ID0gY2JvciA9PiB7XG4gICAgICB0aGlzLmVtaXQoXCJrZXlzdG9uZS1zeW5jX3N1Y2Nlc3MtaGRrZXlcIiwgY2Jvcik7XG4gICAgfTtcblxuICAgIHRoaXMuc3VibWl0Q3J5cHRvQWNjb3VudCA9IGNib3IgPT4ge1xuICAgICAgdGhpcy5lbWl0KFwia2V5c3RvbmUtc3luY19zdWNjZXNzLWFjY291bnRcIiwgY2Jvcik7XG4gICAgfTtcblxuICAgIHRoaXMuY2FuY2VsU3luYyA9ICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdChcImtleXN0b25lLXN5bmNfY2FuY2VsXCIpO1xuICAgIH07XG5cbiAgICB0aGlzLnJlcXVlc3RTaWduYXR1cmUgPSAoc2lnblJlcXVlc3QsIHJlcXVlc3RUaXRsZSwgcmVxdWVzdERlc2NyaXB0aW9uKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB1ciA9IHNpZ25SZXF1ZXN0LnRvVVIoKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkQnVmZmVyID0gc2lnblJlcXVlc3QuZ2V0UmVxdWVzdElkKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHV1aWQuc3RyaW5naWZ5KHJlcXVlc3RJZEJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHNpZ25QYXlsb2FkID0ge1xuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICB0eXBlOiB1ci50eXBlLFxuICAgICAgICAgICAgY2JvcjogdXIuY2Jvci50b1N0cmluZyhcImhleFwiKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGl0bGU6IHJlcXVlc3RUaXRsZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogcmVxdWVzdERlc2NyaXB0aW9uXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgICAgIHNpZ246IHtcbiAgICAgICAgICAgIHJlcXVlc3Q6IHNpZ25QYXlsb2FkXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbmNlKGAke3JlcXVlc3RJZH0tc2lnbmVkYCwgY2JvciA9PiB7XG4gICAgICAgICAgY29uc3QgZXRoU2lnbmF0dXJlID0gYmNVclJlZ2lzdHJ5RXRoLkVUSFNpZ25hdHVyZS5mcm9tQ0JPUihCdWZmZXIuZnJvbShjYm9yLCBcImhleFwiKSk7XG4gICAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgICAgICAgcmVzb2x2ZShldGhTaWduYXR1cmUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbmNlKGAke3JlcXVlc3RJZH0tY2FuY2VsZWRgLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjVHhfY2FuY2VsZWQuIFNpZ25pbmcgY2FuY2VsZWQsIHBsZWFzZSByZXRyeVwiKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuc3VibWl0U2lnbmF0dXJlID0gKHJlcXVlc3RJZCwgY2JvcikgPT4ge1xuICAgICAgdGhpcy5lbWl0KGAke3JlcXVlc3RJZH0tc2lnbmVkYCwgY2Jvcik7XG4gICAgfTtcblxuICAgIHRoaXMuY2FuY2VsUmVxdWVzdFNpZ25hdHVyZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHNpZ25QYXlsb2FkID0gdGhpcy5tZW1TdG9yZS5nZXRTdGF0ZSgpLnNpZ24ucmVxdWVzdDtcblxuICAgICAgaWYgKHNpZ25QYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgfSA9IHNpZ25QYXlsb2FkO1xuICAgICAgICB0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgICBzaWduOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWl0KGAke3JlcXVlc3RJZH0tY2FuY2VsZWRgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5yZXNldCA9ICgpID0+IHtcbiAgICAgIHRoaXMuY2xlYW5TeW5jTGlzdGVuZXJzKCk7XG4gICAgICBjb25zdCBzaWduUGF5bG9hZCA9IHRoaXMubWVtU3RvcmUuZ2V0U3RhdGUoKS5zaWduLnJlcXVlc3Q7XG5cbiAgICAgIGlmIChzaWduUGF5bG9hZCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgIH0gPSBzaWduUGF5bG9hZDtcbiAgICAgICAgdGhpcy5jbGVhblNpZ25MaXN0ZW5lcnMocmVxdWVzdElkKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgfTtcblxuICAgIHRoaXMucmVzZXRTdGF0ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgICBzeW5jOiB7XG4gICAgICAgICAgcmVhZGluZzogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbjoge31cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoTWV0YW1hc2tJbnRlcmFjdGlvblByb3ZpZGVyLmluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gTWV0YW1hc2tJbnRlcmFjdGlvblByb3ZpZGVyLmluc3RhbmNlO1xuICAgIH1cblxuICAgIHRoaXMubWVtU3RvcmUgPSBuZXcgb2JzU3RvcmUuT2JzZXJ2YWJsZVN0b3JlKHtcbiAgICAgIHN5bmM6IHtcbiAgICAgICAgcmVhZGluZzogZmFsc2VcbiAgICAgIH0sXG4gICAgICBzaWduOiB7fSxcbiAgICAgIF92ZXJzaW9uOiAxXG4gICAgfSk7XG4gICAgTWV0YW1hc2tJbnRlcmFjdGlvblByb3ZpZGVyLmluc3RhbmNlID0gdGhpcztcbiAgfVxuXG59XG5cbmNsYXNzIE1ldGFNYXNrS2V5cmluZyBleHRlbmRzIGJhc2VFdGhLZXlyaW5nLkJhc2VLZXlyaW5nIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgdGhpcy5nZXRJbnRlcmFjdGlvbiA9ICgpID0+IHtcbiAgICAgIHJldHVybiBuZXcgTWV0YW1hc2tJbnRlcmFjdGlvblByb3ZpZGVyKCk7XG4gICAgfTtcblxuICAgIHRoaXMucmVzZXRTdG9yZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5yZXNldCgpO1xuICAgIH07XG5cbiAgICB0aGlzLmdldE1lbVN0b3JlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5tZW1TdG9yZTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZW1vdmVBY2NvdW50ID0gYWRkcmVzcyA9PiB7XG4gICAgICBpZiAoIXRoaXMuYWNjb3VudHMubWFwKGEgPT4gYS50b0xvd2VyQ2FzZSgpKS5pbmNsdWRlcyhhZGRyZXNzLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWRkcmVzcyAke2FkZHJlc3N9IG5vdCBmb3VuZCBpbiB0aGlzIGtleXJpbmdgKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hY2NvdW50cyA9IHRoaXMuYWNjb3VudHMuZmlsdGVyKGEgPT4gYS50b0xvd2VyQ2FzZSgpICE9PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgIH07XG5cbiAgICB0aGlzLmZvcmdldERldmljZSA9ICgpID0+IHtcbiAgICAgIC8vY29tbW9uIHByb3BzXG4gICAgICB0aGlzLnBhZ2UgPSAwO1xuICAgICAgdGhpcy5wZXJQYWdlID0gNTtcbiAgICAgIHRoaXMuYWNjb3VudHMgPSBbXTtcbiAgICAgIHRoaXMuY3VycmVudEFjY291bnQgPSAwO1xuICAgICAgdGhpcy5uYW1lID0gXCJRUiBIYXJkd2FyZVwiO1xuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlOyAvL2hkIHByb3BzO1xuXG4gICAgICB0aGlzLnhmcCA9IFwiXCI7XG4gICAgICB0aGlzLnhwdWIgPSBcIlwiO1xuICAgICAgdGhpcy5oZFBhdGggPSBcIlwiO1xuICAgICAgdGhpcy5pbmRleGVzID0ge307XG4gICAgICB0aGlzLmhkayA9IHVuZGVmaW5lZDsgLy9wdWJrZXkgcHJvcHM7XG5cbiAgICAgIHRoaXMucGF0aHMgPSB7fTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdWJtaXRDcnlwdG9IREtleSA9IHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5zdWJtaXRDcnlwdG9IREtleTtcbiAgICB0aGlzLnN1Ym1pdENyeXB0b0FjY291bnQgPSB0aGlzLmdldEludGVyYWN0aW9uKCkuc3VibWl0Q3J5cHRvQWNjb3VudDtcbiAgICB0aGlzLnN1Ym1pdFNpZ25hdHVyZSA9IHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5zdWJtaXRTaWduYXR1cmU7XG4gICAgdGhpcy5jYW5jZWxTeW5jID0gdGhpcy5nZXRJbnRlcmFjdGlvbigpLmNhbmNlbFN5bmM7XG4gICAgdGhpcy5jYW5jZWxTaWduUmVxdWVzdCA9IHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5jYW5jZWxSZXF1ZXN0U2lnbmF0dXJlO1xuXG4gICAgaWYgKE1ldGFNYXNrS2V5cmluZy5pbnN0YW5jZSkge1xuICAgICAgTWV0YU1hc2tLZXlyaW5nLmluc3RhbmNlLmRlc2VyaWFsaXplKG9wdHMpO1xuICAgICAgcmV0dXJuIE1ldGFNYXNrS2V5cmluZy5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICBNZXRhTWFza0tleXJpbmcuaW5zdGFuY2UgPSB0aGlzO1xuICB9XG5cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKGFkZHJlc3MsIHR4JDEpIHtcbiAgICBjb25zdCBkYXRhVHlwZSA9IHR4JDEudHlwZSA9PT0gMCA/IGJjVXJSZWdpc3RyeUV0aC5EYXRhVHlwZS50cmFuc2FjdGlvbiA6IGJjVXJSZWdpc3RyeUV0aC5EYXRhVHlwZS50eXBlZFRyYW5zYWN0aW9uO1xuICAgIGxldCBtZXNzYWdlVG9TaWduO1xuXG4gICAgaWYgKHR4JDEudHlwZSA9PT0gMCkge1xuICAgICAgbWVzc2FnZVRvU2lnbiA9IHJscC5lbmNvZGUodHgkMS5nZXRNZXNzYWdlVG9TaWduKGZhbHNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2VUb1NpZ24gPSB0eCQxLmdldE1lc3NhZ2VUb1NpZ24oZmFsc2UpO1xuICAgIH1cblxuICAgIGNvbnN0IGhkUGF0aCA9IGF3YWl0IHRoaXMuX3BhdGhGcm9tQWRkcmVzcyhhZGRyZXNzKTtcbiAgICBjb25zdCBjaGFpbklkID0gdHgkMS5jb21tb24uY2hhaW5JZCgpO1xuICAgIGNvbnN0IHJlcXVlc3RJZCA9IHV1aWQudjQoKTtcbiAgICBjb25zdCBldGhTaWduUmVxdWVzdCA9IGJjVXJSZWdpc3RyeUV0aC5FdGhTaWduUmVxdWVzdC5jb25zdHJ1Y3RFVEhSZXF1ZXN0KG1lc3NhZ2VUb1NpZ24sIGRhdGFUeXBlLCBoZFBhdGgsIHRoaXMueGZwLCByZXF1ZXN0SWQsIGNoYWluSWQsIGFkZHJlc3MpO1xuICAgIGNvbnN0IHtcbiAgICAgIHIsXG4gICAgICBzLFxuICAgICAgdlxuICAgIH0gPSBhd2FpdCB0aGlzLnJlcXVlc3RTaWduYXR1cmUocmVxdWVzdElkLCBldGhTaWduUmVxdWVzdCwgXCJTY2FuIHdpdGggeW91ciBLZXlzdG9uZVwiLCAnQWZ0ZXIgeW91ciBLZXlzdG9uZSBoYXMgc2lnbmVkIHRoZSB0cmFuc2FjdGlvbiwgY2xpY2sgb24gXCJTY2FuIEtleXN0b25lXCIgdG8gcmVjZWl2ZSB0aGUgc2lnbmF0dXJlJyk7XG4gICAgY29uc3QgdHhKc29uID0gdHgkMS50b0pTT04oKTtcbiAgICB0eEpzb24udiA9IHY7XG4gICAgdHhKc29uLnMgPSBzO1xuICAgIHR4SnNvbi5yID0gcjtcbiAgICB0eEpzb24udHlwZSA9IHR4JDEudHlwZTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHR4LlRyYW5zYWN0aW9uRmFjdG9yeS5mcm9tVHhEYXRhKHR4SnNvbiwge1xuICAgICAgY29tbW9uOiB0eCQxLmNvbW1vblxuICAgIH0pO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgfVxuXG59XG5NZXRhTWFza0tleXJpbmcudHlwZSA9IGJhc2VFdGhLZXlyaW5nLkJhc2VLZXlyaW5nLnR5cGU7XG5cbmV4cG9ydHMuTWV0YU1hc2tLZXlyaW5nID0gTWV0YU1hc2tLZXlyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcuY2pzLmRldmVsb3BtZW50LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGUsdD1yZXF1aXJlKFwiQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZ1wiKSxzPXJlcXVpcmUoXCJldmVudHNcIiksbj1yZXF1aXJlKFwiQG1ldGFtYXNrL29icy1zdG9yZVwiKSxpPXJlcXVpcmUoXCJAa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS1ldGhcIikscj1yZXF1aXJlKFwidXVpZFwiKSxjPXJlcXVpcmUoXCJAZXRoZXJldW1qcy90eFwiKSxvPShlPXJlcXVpcmUoXCJybHBcIikpJiZcIm9iamVjdFwiPT10eXBlb2YgZSYmXCJkZWZhdWx0XCJpbiBlP2UuZGVmYXVsdDplO2NsYXNzIGEgZXh0ZW5kcyBzLkV2ZW50RW1pdHRlcntjb25zdHJ1Y3Rvcigpe2lmKHN1cGVyKCksdGhpcy5jbGVhblN5bmNMaXN0ZW5lcnM9KCk9Pnt0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhcImtleXN0b25lLXN5bmNfc3VjY2Vzcy1oZGtleVwiKSx0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhcImtleXN0b25lLXN5bmNfc3VjY2Vzcy1hY2NvdW50XCIpLHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKFwia2V5c3RvbmUtc3luY19jYW5jZWxcIil9LHRoaXMuY2xlYW5TaWduTGlzdGVuZXJzPWU9Pnt0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhlK1wiLXNpZ25lZFwiKSx0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhlK1wiLWNhbmNlbGVkXCIpfSx0aGlzLnJlYWRDcnlwdG9IREtleU9yQ3J5cHRvQWNjb3VudD0oKT0+bmV3IFByb21pc2UoKGUsdCk9Pnt0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHtzeW5jOntyZWFkaW5nOiEwfX0pLHRoaXMub24oXCJrZXlzdG9uZS1zeW5jX3N1Y2Nlc3MtaGRrZXlcIix0PT57Y29uc3Qgcz1pLkNyeXB0b0hES2V5LmZyb21DQk9SKEJ1ZmZlci5mcm9tKHQsXCJoZXhcIikpO3RoaXMucmVzZXRTdGF0ZSgpLGUocyl9KSx0aGlzLm9uKFwia2V5c3RvbmUtc3luY19zdWNjZXNzLWFjY291bnRcIix0PT57Y29uc3Qgcz1pLkNyeXB0b0FjY291bnQuZnJvbUNCT1IoQnVmZmVyLmZyb20odCxcImhleFwiKSk7dGhpcy5yZXNldFN0YXRlKCksZShzKX0pLHRoaXMub24oXCJrZXlzdG9uZS1zeW5jX2NhbmNlbFwiLCgpPT57dGhpcy5yZXNldFN0YXRlKCksdChuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI3N5bmNfY2FuY2VsLiBTeW5jIHByb2Nlc3MgY2FuY2VsZWQsIHBsZWFzZSByZXRyeVwiKSl9KX0pLHRoaXMuc3VibWl0Q3J5cHRvSERLZXk9ZT0+e3RoaXMuZW1pdChcImtleXN0b25lLXN5bmNfc3VjY2Vzcy1oZGtleVwiLGUpfSx0aGlzLnN1Ym1pdENyeXB0b0FjY291bnQ9ZT0+e3RoaXMuZW1pdChcImtleXN0b25lLXN5bmNfc3VjY2Vzcy1hY2NvdW50XCIsZSl9LHRoaXMuY2FuY2VsU3luYz0oKT0+e3RoaXMuZW1pdChcImtleXN0b25lLXN5bmNfY2FuY2VsXCIpfSx0aGlzLnJlcXVlc3RTaWduYXR1cmU9KGUsdCxzKT0+bmV3IFByb21pc2UoKG4sYyk9Pntjb25zdCBvPWUudG9VUigpLGE9ZS5nZXRSZXF1ZXN0SWQoKSxoPXIuc3RyaW5naWZ5KGEpLHU9e3JlcXVlc3RJZDpoLHBheWxvYWQ6e3R5cGU6by50eXBlLGNib3I6by5jYm9yLnRvU3RyaW5nKFwiaGV4XCIpfSx0aXRsZTp0LGRlc2NyaXB0aW9uOnN9O3RoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe3NpZ246e3JlcXVlc3Q6dX19KSx0aGlzLm9uY2UoaCtcIi1zaWduZWRcIixlPT57Y29uc3QgdD1pLkVUSFNpZ25hdHVyZS5mcm9tQ0JPUihCdWZmZXIuZnJvbShlLFwiaGV4XCIpKTt0aGlzLnJlc2V0U3RhdGUoKSxuKHQpfSksdGhpcy5vbmNlKGgrXCItY2FuY2VsZWRcIiwoKT0+e3RoaXMucmVzZXRTdGF0ZSgpLGMobmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNUeF9jYW5jZWxlZC4gU2lnbmluZyBjYW5jZWxlZCwgcGxlYXNlIHJldHJ5XCIpKX0pfSksdGhpcy5zdWJtaXRTaWduYXR1cmU9KGUsdCk9Pnt0aGlzLmVtaXQoZStcIi1zaWduZWRcIix0KX0sdGhpcy5jYW5jZWxSZXF1ZXN0U2lnbmF0dXJlPSgpPT57Y29uc3QgZT10aGlzLm1lbVN0b3JlLmdldFN0YXRlKCkuc2lnbi5yZXF1ZXN0O2lmKGUpe2NvbnN0e3JlcXVlc3RJZDp0fT1lO3RoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe3NpZ246e319KSx0aGlzLmVtaXQodCtcIi1jYW5jZWxlZFwiKX19LHRoaXMucmVzZXQ9KCk9Pnt0aGlzLmNsZWFuU3luY0xpc3RlbmVycygpO2NvbnN0IGU9dGhpcy5tZW1TdG9yZS5nZXRTdGF0ZSgpLnNpZ24ucmVxdWVzdDtpZihlKXtjb25zdHtyZXF1ZXN0SWQ6dH09ZTt0aGlzLmNsZWFuU2lnbkxpc3RlbmVycyh0KX10aGlzLnJlc2V0U3RhdGUoKX0sdGhpcy5yZXNldFN0YXRlPSgpPT57dGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7c3luYzp7cmVhZGluZzohMX0sc2lnbjp7fX0pfSxhLmluc3RhbmNlKXJldHVybiBhLmluc3RhbmNlO3RoaXMubWVtU3RvcmU9bmV3IG4uT2JzZXJ2YWJsZVN0b3JlKHtzeW5jOntyZWFkaW5nOiExfSxzaWduOnt9LF92ZXJzaW9uOjF9KSxhLmluc3RhbmNlPXRoaXN9fWNsYXNzIGggZXh0ZW5kcyB0LkJhc2VLZXlyaW5ne2NvbnN0cnVjdG9yKGUpe2lmKHN1cGVyKGUpLHRoaXMuZ2V0SW50ZXJhY3Rpb249KCk9Pm5ldyBhLHRoaXMucmVzZXRTdG9yZT0oKT0+e3RoaXMuZ2V0SW50ZXJhY3Rpb24oKS5yZXNldCgpfSx0aGlzLmdldE1lbVN0b3JlPSgpPT50aGlzLmdldEludGVyYWN0aW9uKCkubWVtU3RvcmUsdGhpcy5yZW1vdmVBY2NvdW50PWU9PntpZighdGhpcy5hY2NvdW50cy5tYXAoZT0+ZS50b0xvd2VyQ2FzZSgpKS5pbmNsdWRlcyhlLnRvTG93ZXJDYXNlKCkpKXRocm93IG5ldyBFcnJvcihgQWRkcmVzcyAke2V9IG5vdCBmb3VuZCBpbiB0aGlzIGtleXJpbmdgKTt0aGlzLmFjY291bnRzPXRoaXMuYWNjb3VudHMuZmlsdGVyKHQ9PnQudG9Mb3dlckNhc2UoKSE9PWUudG9Mb3dlckNhc2UoKSl9LHRoaXMuZm9yZ2V0RGV2aWNlPSgpPT57dGhpcy5wYWdlPTAsdGhpcy5wZXJQYWdlPTUsdGhpcy5hY2NvdW50cz1bXSx0aGlzLmN1cnJlbnRBY2NvdW50PTAsdGhpcy5uYW1lPVwiUVIgSGFyZHdhcmVcIix0aGlzLmluaXRpYWxpemVkPSExLHRoaXMueGZwPVwiXCIsdGhpcy54cHViPVwiXCIsdGhpcy5oZFBhdGg9XCJcIix0aGlzLmluZGV4ZXM9e30sdGhpcy5oZGs9dm9pZCAwLHRoaXMucGF0aHM9e319LHRoaXMuc3VibWl0Q3J5cHRvSERLZXk9dGhpcy5nZXRJbnRlcmFjdGlvbigpLnN1Ym1pdENyeXB0b0hES2V5LHRoaXMuc3VibWl0Q3J5cHRvQWNjb3VudD10aGlzLmdldEludGVyYWN0aW9uKCkuc3VibWl0Q3J5cHRvQWNjb3VudCx0aGlzLnN1Ym1pdFNpZ25hdHVyZT10aGlzLmdldEludGVyYWN0aW9uKCkuc3VibWl0U2lnbmF0dXJlLHRoaXMuY2FuY2VsU3luYz10aGlzLmdldEludGVyYWN0aW9uKCkuY2FuY2VsU3luYyx0aGlzLmNhbmNlbFNpZ25SZXF1ZXN0PXRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5jYW5jZWxSZXF1ZXN0U2lnbmF0dXJlLGguaW5zdGFuY2UpcmV0dXJuIGguaW5zdGFuY2UuZGVzZXJpYWxpemUoZSksaC5pbnN0YW5jZTtoLmluc3RhbmNlPXRoaXN9YXN5bmMgc2lnblRyYW5zYWN0aW9uKGUsdCl7Y29uc3Qgcz0wPT09dC50eXBlP2kuRGF0YVR5cGUudHJhbnNhY3Rpb246aS5EYXRhVHlwZS50eXBlZFRyYW5zYWN0aW9uO2xldCBuO249MD09PXQudHlwZT9vLmVuY29kZSh0LmdldE1lc3NhZ2VUb1NpZ24oITEpKTp0LmdldE1lc3NhZ2VUb1NpZ24oITEpO2NvbnN0IGE9YXdhaXQgdGhpcy5fcGF0aEZyb21BZGRyZXNzKGUpLGg9dC5jb21tb24uY2hhaW5JZCgpLHU9ci52NCgpLHk9aS5FdGhTaWduUmVxdWVzdC5jb25zdHJ1Y3RFVEhSZXF1ZXN0KG4scyxhLHRoaXMueGZwLHUsaCxlKSx7cjptLHM6Zyx2OmR9PWF3YWl0IHRoaXMucmVxdWVzdFNpZ25hdHVyZSh1LHksXCJTY2FuIHdpdGggeW91ciBLZXlzdG9uZVwiLCdBZnRlciB5b3VyIEtleXN0b25lIGhhcyBzaWduZWQgdGhlIHRyYW5zYWN0aW9uLCBjbGljayBvbiBcIlNjYW4gS2V5c3RvbmVcIiB0byByZWNlaXZlIHRoZSBzaWduYXR1cmUnKSxTPXQudG9KU09OKCk7cmV0dXJuIFMudj1kLFMucz1nLFMucj1tLFMudHlwZT10LnR5cGUsYy5UcmFuc2FjdGlvbkZhY3RvcnkuZnJvbVR4RGF0YShTLHtjb21tb246dC5jb21tb259KX19aC50eXBlPXQuQmFzZUtleXJpbmcudHlwZSxleHBvcnRzLk1ldGFNYXNrS2V5cmluZz1oO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcuY2pzLnByb2R1Y3Rpb24ubWluLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIGJjVXJSZWdpc3RyeSA9IHJlcXVpcmUoJ0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5Jyk7XG52YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQnKTtcbnZhciBIREtleSA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdoZGtleScpKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnQGV0aGVyZXVtanMvdXRpbCcpO1xuXG5jb25zdCBFeHRlbmRlZFJlZ2lzdHJ5VHlwZXMgPSB7XG4gIEVUSF9TSUdOX1JFUVVFU1Q6IC8qI19fUFVSRV9fKi9uZXcgYmNVclJlZ2lzdHJ5LlJlZ2lzdHJ5VHlwZShcImV0aC1zaWduLXJlcXVlc3RcIiwgNDAxKSxcbiAgRVRIX1NJR05BVFVSRTogLyojX19QVVJFX18qL25ldyBiY1VyUmVnaXN0cnkuUmVnaXN0cnlUeXBlKFwiZXRoLXNpZ25hdHVyZVwiLCA0MDIpLFxuICBFVEhfTkZUX0lURU06IC8qI19fUFVSRV9fKi9uZXcgYmNVclJlZ2lzdHJ5LlJlZ2lzdHJ5VHlwZShcImV0aC1uZnQtaXRlbVwiLCA0MDMpXG59O1xuXG5jb25zdCB7XG4gIGRlY29kZVRvRGF0YUl0ZW0sXG4gIFJlZ2lzdHJ5VHlwZXNcbn0gPSBiY1VyUmVnaXN0cnkuZXh0ZW5kO1xudmFyIEtleXM7XG5cbihmdW5jdGlvbiAoS2V5cykge1xuICBLZXlzW0tleXNbXCJyZXF1ZXN0SWRcIl0gPSAxXSA9IFwicmVxdWVzdElkXCI7XG4gIEtleXNbS2V5c1tcInNpZ25EYXRhXCJdID0gMl0gPSBcInNpZ25EYXRhXCI7XG4gIEtleXNbS2V5c1tcImRhdGFUeXBlXCJdID0gM10gPSBcImRhdGFUeXBlXCI7XG4gIEtleXNbS2V5c1tcImNoYWluSWRcIl0gPSA0XSA9IFwiY2hhaW5JZFwiO1xuICBLZXlzW0tleXNbXCJkZXJpdmF0aW9uUGF0aFwiXSA9IDVdID0gXCJkZXJpdmF0aW9uUGF0aFwiO1xuICBLZXlzW0tleXNbXCJhZGRyZXNzXCJdID0gNl0gPSBcImFkZHJlc3NcIjtcbiAgS2V5c1tLZXlzW1wib3JpZ2luXCJdID0gN10gPSBcIm9yaWdpblwiO1xufSkoS2V5cyB8fCAoS2V5cyA9IHt9KSk7XG5cbihmdW5jdGlvbiAoRGF0YVR5cGUpIHtcbiAgRGF0YVR5cGVbRGF0YVR5cGVbXCJ0cmFuc2FjdGlvblwiXSA9IDFdID0gXCJ0cmFuc2FjdGlvblwiO1xuICBEYXRhVHlwZVtEYXRhVHlwZVtcInR5cGVkRGF0YVwiXSA9IDJdID0gXCJ0eXBlZERhdGFcIjtcbiAgRGF0YVR5cGVbRGF0YVR5cGVbXCJwZXJzb25hbE1lc3NhZ2VcIl0gPSAzXSA9IFwicGVyc29uYWxNZXNzYWdlXCI7XG4gIERhdGFUeXBlW0RhdGFUeXBlW1widHlwZWRUcmFuc2FjdGlvblwiXSA9IDRdID0gXCJ0eXBlZFRyYW5zYWN0aW9uXCI7XG59KShleHBvcnRzLkRhdGFUeXBlIHx8IChleHBvcnRzLkRhdGFUeXBlID0ge30pKTtcblxuY2xhc3MgRXRoU2lnblJlcXVlc3QgZXh0ZW5kcyBiY1VyUmVnaXN0cnkuUmVnaXN0cnlJdGVtIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IEV4dGVuZGVkUmVnaXN0cnlUeXBlcy5FVEhfU0lHTl9SRVFVRVNUO1xuXG4gICAgdGhpcy5nZXRSZXF1ZXN0SWQgPSAoKSA9PiB0aGlzLnJlcXVlc3RJZDtcblxuICAgIHRoaXMuZ2V0U2lnbkRhdGEgPSAoKSA9PiB0aGlzLnNpZ25EYXRhO1xuXG4gICAgdGhpcy5nZXREYXRhVHlwZSA9ICgpID0+IHRoaXMuZGF0YVR5cGU7XG5cbiAgICB0aGlzLmdldENoYWluSWQgPSAoKSA9PiB0aGlzLmNoYWluSWQ7XG5cbiAgICB0aGlzLmdldERlcml2YXRpb25QYXRoID0gKCkgPT4gdGhpcy5kZXJpdmF0aW9uUGF0aC5nZXRQYXRoKCk7XG5cbiAgICB0aGlzLmdldFNvdXJjZUZpbmdlcnByaW50ID0gKCkgPT4gdGhpcy5kZXJpdmF0aW9uUGF0aC5nZXRTb3VyY2VGaW5nZXJwcmludCgpO1xuXG4gICAgdGhpcy5nZXRTaWduUmVxdWVzdEFkZHJlc3MgPSAoKSA9PiB0aGlzLmFkZHJlc3M7XG5cbiAgICB0aGlzLmdldE9yaWdpbiA9ICgpID0+IHRoaXMub3JpZ2luO1xuXG4gICAgdGhpcy50b0RhdGFJdGVtID0gKCkgPT4ge1xuICAgICAgY29uc3QgbWFwID0ge307XG5cbiAgICAgIGlmICh0aGlzLnJlcXVlc3RJZCkge1xuICAgICAgICBtYXBbS2V5cy5yZXF1ZXN0SWRdID0gbmV3IGJjVXJSZWdpc3RyeS5EYXRhSXRlbSh0aGlzLnJlcXVlc3RJZCwgUmVnaXN0cnlUeXBlcy5VVUlELmdldFRhZygpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYWRkcmVzcykge1xuICAgICAgICBtYXBbS2V5cy5hZGRyZXNzXSA9IHRoaXMuYWRkcmVzcztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2hhaW5JZCkge1xuICAgICAgICBtYXBbS2V5cy5jaGFpbklkXSA9IHRoaXMuY2hhaW5JZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3JpZ2luKSB7XG4gICAgICAgIG1hcFtLZXlzLm9yaWdpbl0gPSB0aGlzLm9yaWdpbjtcbiAgICAgIH1cblxuICAgICAgbWFwW0tleXMuc2lnbkRhdGFdID0gdGhpcy5zaWduRGF0YTtcbiAgICAgIG1hcFtLZXlzLmRhdGFUeXBlXSA9IHRoaXMuZGF0YVR5cGU7XG4gICAgICBjb25zdCBrZXlQYXRoID0gdGhpcy5kZXJpdmF0aW9uUGF0aC50b0RhdGFJdGVtKCk7XG4gICAgICBrZXlQYXRoLnNldFRhZyh0aGlzLmRlcml2YXRpb25QYXRoLmdldFJlZ2lzdHJ5VHlwZSgpLmdldFRhZygpKTtcbiAgICAgIG1hcFtLZXlzLmRlcml2YXRpb25QYXRoXSA9IGtleVBhdGg7XG4gICAgICByZXR1cm4gbmV3IGJjVXJSZWdpc3RyeS5EYXRhSXRlbShtYXApO1xuICAgIH07XG5cbiAgICB0aGlzLnJlcXVlc3RJZCA9IGFyZ3MucmVxdWVzdElkO1xuICAgIHRoaXMuc2lnbkRhdGEgPSBhcmdzLnNpZ25EYXRhO1xuICAgIHRoaXMuZGF0YVR5cGUgPSBhcmdzLmRhdGFUeXBlO1xuICAgIHRoaXMuY2hhaW5JZCA9IGFyZ3MuY2hhaW5JZDtcbiAgICB0aGlzLmRlcml2YXRpb25QYXRoID0gYXJncy5kZXJpdmF0aW9uUGF0aDtcbiAgICB0aGlzLmFkZHJlc3MgPSBhcmdzLmFkZHJlc3M7XG4gICAgdGhpcy5vcmlnaW4gPSBhcmdzLm9yaWdpbjtcbiAgfVxuXG4gIHN0YXRpYyBjb25zdHJ1Y3RFVEhSZXF1ZXN0KHNpZ25EYXRhLCBzaWduRGF0YVR5cGUsIGhkUGF0aCwgeGZwLCB1dWlkU3RyaW5nLCBjaGFpbklkLCBhZGRyZXNzLCBvcmlnaW4pIHtcbiAgICBjb25zdCBwYXRocyA9IGhkUGF0aC5yZXBsYWNlKC9bbXxNXVxcLy8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICBjb25zdCBoZHBhdGhPYmplY3QgPSBuZXcgYmNVclJlZ2lzdHJ5LkNyeXB0b0tleXBhdGgocGF0aHMubWFwKHBhdGggPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChwYXRoLnJlcGxhY2UoXCInXCIsIFwiXCIpKTtcbiAgICAgIGxldCBpc0hhcmRlbmVkID0gZmFsc2U7XG5cbiAgICAgIGlmIChwYXRoLmVuZHNXaXRoKFwiJ1wiKSkge1xuICAgICAgICBpc0hhcmRlbmVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBiY1VyUmVnaXN0cnkuUGF0aENvbXBvbmVudCh7XG4gICAgICAgIGluZGV4LFxuICAgICAgICBoYXJkZW5lZDogaXNIYXJkZW5lZFxuICAgICAgfSk7XG4gICAgfSksIEJ1ZmZlci5mcm9tKHhmcCwgXCJoZXhcIikpO1xuICAgIHJldHVybiBuZXcgRXRoU2lnblJlcXVlc3Qoe1xuICAgICAgcmVxdWVzdElkOiB1dWlkU3RyaW5nID8gQnVmZmVyLmZyb20odXVpZC5wYXJzZSh1dWlkU3RyaW5nKSkgOiB1bmRlZmluZWQsXG4gICAgICBzaWduRGF0YSxcbiAgICAgIGRhdGFUeXBlOiBzaWduRGF0YVR5cGUsXG4gICAgICBkZXJpdmF0aW9uUGF0aDogaGRwYXRoT2JqZWN0LFxuICAgICAgY2hhaW5JZCxcbiAgICAgIGFkZHJlc3M6IGFkZHJlc3MgPyBCdWZmZXIuZnJvbShhZGRyZXNzLnJlcGxhY2UoXCIweFwiLCBcIlwiKSwgXCJoZXhcIikgOiB1bmRlZmluZWQsXG4gICAgICBvcmlnaW46IG9yaWdpbiB8fCB1bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuXG59XG5cbkV0aFNpZ25SZXF1ZXN0LmZyb21EYXRhSXRlbSA9IGRhdGFJdGVtID0+IHtcbiAgY29uc3QgbWFwID0gZGF0YUl0ZW0uZ2V0RGF0YSgpO1xuICBjb25zdCBzaWduRGF0YSA9IG1hcFtLZXlzLnNpZ25EYXRhXTtcbiAgY29uc3QgZGF0YVR5cGUgPSBtYXBbS2V5cy5kYXRhVHlwZV07XG4gIGNvbnN0IGRlcml2YXRpb25QYXRoID0gYmNVclJlZ2lzdHJ5LkNyeXB0b0tleXBhdGguZnJvbURhdGFJdGVtKG1hcFtLZXlzLmRlcml2YXRpb25QYXRoXSk7XG4gIGNvbnN0IGNoYWluSWQgPSBtYXBbS2V5cy5jaGFpbklkXSA/IG1hcFtLZXlzLmNoYWluSWRdIDogdW5kZWZpbmVkO1xuICBjb25zdCBhZGRyZXNzID0gbWFwW0tleXMuYWRkcmVzc10gPyBtYXBbS2V5cy5hZGRyZXNzXSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgcmVxdWVzdElkID0gbWFwW0tleXMucmVxdWVzdElkXSA/IG1hcFtLZXlzLnJlcXVlc3RJZF0uZ2V0RGF0YSgpIDogdW5kZWZpbmVkO1xuICBjb25zdCBvcmlnaW4gPSBtYXBbS2V5cy5vcmlnaW5dID8gbWFwW0tleXMub3JpZ2luXSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG5ldyBFdGhTaWduUmVxdWVzdCh7XG4gICAgcmVxdWVzdElkLFxuICAgIHNpZ25EYXRhLFxuICAgIGRhdGFUeXBlLFxuICAgIGNoYWluSWQsXG4gICAgZGVyaXZhdGlvblBhdGgsXG4gICAgYWRkcmVzcyxcbiAgICBvcmlnaW5cbiAgfSk7XG59O1xuXG5FdGhTaWduUmVxdWVzdC5mcm9tQ0JPUiA9IF9jYm9yUGF5bG9hZCA9PiB7XG4gIGNvbnN0IGRhdGFJdGVtID0gZGVjb2RlVG9EYXRhSXRlbShfY2JvclBheWxvYWQpO1xuICByZXR1cm4gRXRoU2lnblJlcXVlc3QuZnJvbURhdGFJdGVtKGRhdGFJdGVtKTtcbn07XG5cbmNvbnN0IHtcbiAgUmVnaXN0cnlUeXBlczogUmVnaXN0cnlUeXBlcyQxLFxuICBkZWNvZGVUb0RhdGFJdGVtOiBkZWNvZGVUb0RhdGFJdGVtJDFcbn0gPSBiY1VyUmVnaXN0cnkuZXh0ZW5kO1xudmFyIEtleXMkMTtcblxuKGZ1bmN0aW9uIChLZXlzKSB7XG4gIEtleXNbS2V5c1tcInJlcXVlc3RJZFwiXSA9IDFdID0gXCJyZXF1ZXN0SWRcIjtcbiAgS2V5c1tLZXlzW1wic2lnbmF0dXJlXCJdID0gMl0gPSBcInNpZ25hdHVyZVwiO1xuICBLZXlzW0tleXNbXCJvcmlnaW5cIl0gPSAzXSA9IFwib3JpZ2luXCI7XG59KShLZXlzJDEgfHwgKEtleXMkMSA9IHt9KSk7XG5cbmNsYXNzIEVUSFNpZ25hdHVyZSBleHRlbmRzIGJjVXJSZWdpc3RyeS5SZWdpc3RyeUl0ZW0ge1xuICBjb25zdHJ1Y3RvcihzaWduYXR1cmUsIHJlcXVlc3RJZCwgb3JpZ2luKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuZ2V0UmVnaXN0cnlUeXBlID0gKCkgPT4gRXh0ZW5kZWRSZWdpc3RyeVR5cGVzLkVUSF9TSUdOQVRVUkU7XG5cbiAgICB0aGlzLmdldFJlcXVlc3RJZCA9ICgpID0+IHRoaXMucmVxdWVzdElkO1xuXG4gICAgdGhpcy5nZXRTaWduYXR1cmUgPSAoKSA9PiB0aGlzLnNpZ25hdHVyZTtcblxuICAgIHRoaXMuZ2V0T3JpZ2luID0gKCkgPT4gdGhpcy5vcmlnaW47XG5cbiAgICB0aGlzLnRvRGF0YUl0ZW0gPSAoKSA9PiB7XG4gICAgICBjb25zdCBtYXAgPSB7fTtcblxuICAgICAgaWYgKHRoaXMucmVxdWVzdElkKSB7XG4gICAgICAgIG1hcFtLZXlzJDEucmVxdWVzdElkXSA9IG5ldyBiY1VyUmVnaXN0cnkuRGF0YUl0ZW0odGhpcy5yZXF1ZXN0SWQsIFJlZ2lzdHJ5VHlwZXMkMS5VVUlELmdldFRhZygpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3JpZ2luKSBtYXBbS2V5cyQxLm9yaWdpbl0gPSB0aGlzLm9yaWdpbjtcbiAgICAgIG1hcFtLZXlzJDEuc2lnbmF0dXJlXSA9IHRoaXMuc2lnbmF0dXJlO1xuICAgICAgcmV0dXJuIG5ldyBiY1VyUmVnaXN0cnkuRGF0YUl0ZW0obWFwKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gICAgdGhpcy5yZXF1ZXN0SWQgPSByZXF1ZXN0SWQ7XG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW47XG4gIH1cblxufVxuXG5FVEhTaWduYXR1cmUuZnJvbURhdGFJdGVtID0gZGF0YUl0ZW0gPT4ge1xuICBjb25zdCBtYXAgPSBkYXRhSXRlbS5nZXREYXRhKCk7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IG1hcFtLZXlzJDEuc2lnbmF0dXJlXTtcbiAgY29uc3QgcmVxdWVzdElkID0gbWFwW0tleXMkMS5yZXF1ZXN0SWRdID8gbWFwW0tleXMkMS5yZXF1ZXN0SWRdLmdldERhdGEoKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG5ldyBFVEhTaWduYXR1cmUoc2lnbmF0dXJlLCByZXF1ZXN0SWQsIG1hcFtLZXlzJDEub3JpZ2luXSk7XG59O1xuXG5FVEhTaWduYXR1cmUuZnJvbUNCT1IgPSBfY2JvclBheWxvYWQgPT4ge1xuICBjb25zdCBkYXRhSXRlbSA9IGRlY29kZVRvRGF0YUl0ZW0kMShfY2JvclBheWxvYWQpO1xuICByZXR1cm4gRVRIU2lnbmF0dXJlLmZyb21EYXRhSXRlbShkYXRhSXRlbSk7XG59O1xuXG5jb25zdCB7XG4gIGRlY29kZVRvRGF0YUl0ZW06IGRlY29kZVRvRGF0YUl0ZW0kMlxufSA9IGJjVXJSZWdpc3RyeS5leHRlbmQ7XG52YXIgS2V5cyQyO1xuXG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgS2V5c1tLZXlzW1wiY2hhaW5JZFwiXSA9IDFdID0gXCJjaGFpbklkXCI7XG4gIEtleXNbS2V5c1tcImNvbnRyYWN0QWRkcmVzc1wiXSA9IDJdID0gXCJjb250cmFjdEFkZHJlc3NcIjtcbiAgS2V5c1tLZXlzW1wiY29udHJhY3ROYW1lXCJdID0gM10gPSBcImNvbnRyYWN0TmFtZVwiO1xuICBLZXlzW0tleXNbXCJuYW1lXCJdID0gNF0gPSBcIm5hbWVcIjtcbiAgS2V5c1tLZXlzW1wibWVkaWFEYXRhXCJdID0gNV0gPSBcIm1lZGlhRGF0YVwiO1xufSkoS2V5cyQyIHx8IChLZXlzJDIgPSB7fSkpO1xuXG5jbGFzcyBFVEhORlRJdGVtIGV4dGVuZHMgYmNVclJlZ2lzdHJ5LlJlZ2lzdHJ5SXRlbSB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5nZXRSZWdpc3RyeVR5cGUgPSAoKSA9PiBFeHRlbmRlZFJlZ2lzdHJ5VHlwZXMuRVRIX05GVF9JVEVNO1xuXG4gICAgdGhpcy5nZXRDaGFpbklkID0gKCkgPT4gdGhpcy5jaGFpbklkO1xuXG4gICAgdGhpcy5nZXROYW1lID0gKCkgPT4gdGhpcy5uYW1lO1xuXG4gICAgdGhpcy5nZXRtZWRpYURhdGEgPSAoKSA9PiB0aGlzLm1lZGlhRGF0YTtcblxuICAgIHRoaXMuZ2V0Q29udHJhY3RBZGRyZXNzID0gKCkgPT4gdGhpcy5jb250cmFjdEFkZHJlc3M7XG5cbiAgICB0aGlzLmdldENvbnRyYWN0TmFtZSA9ICgpID0+IHRoaXMuY29udHJhY3ROYW1lO1xuXG4gICAgdGhpcy50b0RhdGFJdGVtID0gKCkgPT4ge1xuICAgICAgY29uc3QgbWFwID0ge307XG4gICAgICBtYXBbS2V5cyQyLmNoYWluSWRdID0gdGhpcy5jaGFpbklkO1xuICAgICAgbWFwW0tleXMkMi5uYW1lXSA9IHRoaXMubmFtZTtcbiAgICAgIG1hcFtLZXlzJDIuY29udHJhY3RBZGRyZXNzXSA9IHRoaXMuY29udHJhY3RBZGRyZXNzO1xuICAgICAgbWFwW0tleXMkMi5jb250cmFjdE5hbWVdID0gdGhpcy5jb250cmFjdE5hbWU7XG4gICAgICBtYXBbS2V5cyQyLm1lZGlhRGF0YV0gPSB0aGlzLm1lZGlhRGF0YTtcbiAgICAgIHJldHVybiBuZXcgYmNVclJlZ2lzdHJ5LkRhdGFJdGVtKG1hcCk7XG4gICAgfTtcblxuICAgIHRoaXMuY2hhaW5JZCA9IGFyZ3MuY2hhaW5JZDtcbiAgICB0aGlzLm5hbWUgPSBhcmdzLm5hbWU7XG4gICAgdGhpcy5jb250cmFjdEFkZHJlc3MgPSBhcmdzLmNvbnRyYWN0QWRkcmVzcztcbiAgICB0aGlzLmNvbnRyYWN0TmFtZSA9IGFyZ3MuY29udHJhY3ROYW1lO1xuICAgIHRoaXMubWVkaWFEYXRhID0gYXJncy5tZWRpYURhdGE7IC8vIHJlbW92ZSB0aGUgZGF0YSBwZXJmaXggZm9yIGFuZHJvaWQgdXNhZ2VcbiAgfVxuXG4gIHN0YXRpYyBjb25zdHJ1Y3RFVEhORlRJdGVtKGNoYWluSWQsIGNvbnRyYWN0QWRkcmVzcywgY29udHJhY3ROYW1lLCBuYW1lLCBtZWRpYURhdGEpIHtcbiAgICByZXR1cm4gbmV3IEVUSE5GVEl0ZW0oe1xuICAgICAgY2hhaW5JZCxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGNvbnRyYWN0TmFtZSxcbiAgICAgIG1lZGlhRGF0YSxcbiAgICAgIG5hbWVcbiAgICB9KTtcbiAgfVxuXG59XG5cbkVUSE5GVEl0ZW0uZnJvbURhdGFJdGVtID0gZGF0YUl0ZW0gPT4ge1xuICBjb25zdCBtYXAgPSBkYXRhSXRlbS5nZXREYXRhKCk7XG4gIGNvbnN0IGNoYWluSWQgPSBtYXBbS2V5cyQyLmNoYWluSWRdO1xuICBjb25zdCBuYW1lID0gbWFwW0tleXMkMi5uYW1lXTtcbiAgY29uc3QgbWVkaWFEYXRhID0gbWFwW0tleXMkMi5tZWRpYURhdGFdO1xuICBjb25zdCBjb250cmFjdEFkZHJlc3MgPSBtYXBbS2V5cyQyLmNvbnRyYWN0QWRkcmVzc107XG4gIGNvbnN0IGNvbnRyYWN0TmFtZSA9IG1hcFtLZXlzJDIuY29udHJhY3ROYW1lXTtcbiAgcmV0dXJuIG5ldyBFVEhORlRJdGVtKHtcbiAgICBjaGFpbklkLFxuICAgIG5hbWUsXG4gICAgY29udHJhY3RBZGRyZXNzLFxuICAgIGNvbnRyYWN0TmFtZSxcbiAgICBtZWRpYURhdGFcbiAgfSk7XG59O1xuXG5FVEhORlRJdGVtLmZyb21DQk9SID0gX2Nib3JQYXlsb2FkID0+IHtcbiAgY29uc3QgZGF0YUl0ZW0gPSBkZWNvZGVUb0RhdGFJdGVtJDIoX2Nib3JQYXlsb2FkKTtcbiAgcmV0dXJuIEVUSE5GVEl0ZW0uZnJvbURhdGFJdGVtKGRhdGFJdGVtKTtcbn07XG5cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGdlbmVyYXRlQWRkcmVzc0Zyb21YcHViID0gKHhwdWIsIGRlcml2ZVBhdGgpID0+IHtcbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBub2RlID0gSERLZXkuZnJvbUV4dGVuZGVkS2V5KHhwdWIpO1xuICBjb25zdCBwdWJsaWNLZXkgPSBub2RlLmRlcml2ZShkZXJpdmVQYXRoKTtcbiAgY29uc3QgYWRkcmVzcyA9IFwiMHhcIiArIHV0aWwucHVibGljVG9BZGRyZXNzKHB1YmxpY0tleS5wdWJsaWNLZXksIHRydWUpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICByZXR1cm4gdXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbn07XG5jb25zdCBmaW5kSERQYXRoRnJvbUFkZHJlc3MgPSAoYWRkcmVzcywgeHB1YiwgbnVtYmVyTGltaXQsIHJvb3RQYXRoKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyTGltaXQ7IGkrKykge1xuICAgIGNvbnN0IHBhdGggPSBgTS8wLyR7aX1gO1xuXG4gICAgY29uc3QgX2FkZHJlc3MgPSBnZW5lcmF0ZUFkZHJlc3NGcm9tWHB1Yih4cHViLCBwYXRoKTtcblxuICAgIGlmIChhZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT0gX2FkZHJlc3MudG9Mb3dlckNhc2UoKSkge1xuICAgICAgcmV0dXJuIGAke3Jvb3RQYXRofS8wLyR7aX1gO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuYmNVclJlZ2lzdHJ5LnBhdGNoVGFncyhPYmplY3QudmFsdWVzKEV4dGVuZGVkUmVnaXN0cnlUeXBlcykuZmlsdGVyKHJ0ID0+ICEhcnQuZ2V0VGFnKCkpLm1hcChydCA9PiBydC5nZXRUYWcoKSkpO1xuXG5PYmplY3Qua2V5cyhiY1VyUmVnaXN0cnkpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgaWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGJjVXJSZWdpc3RyeVtrXTtcbiAgICB9XG4gIH0pO1xufSk7XG5leHBvcnRzLkVUSE5GVEl0ZW0gPSBFVEhORlRJdGVtO1xuZXhwb3J0cy5FVEhTaWduYXR1cmUgPSBFVEhTaWduYXR1cmU7XG5leHBvcnRzLkV0aFNpZ25SZXF1ZXN0ID0gRXRoU2lnblJlcXVlc3Q7XG5leHBvcnRzLmZpbmRIRFBhdGhGcm9tQWRkcmVzcyA9IGZpbmRIRFBhdGhGcm9tQWRkcmVzcztcbmV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzRnJvbVhwdWIgPSBnZW5lcmF0ZUFkZHJlc3NGcm9tWHB1Yjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJjLXVyLXJlZ2lzdHJ5LWV0aC5janMuZGV2ZWxvcG1lbnQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdCxlPXJlcXVpcmUoXCJAa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeVwiKSxhPXJlcXVpcmUoXCJ1dWlkXCIpLHM9KHQ9cmVxdWlyZShcImhka2V5XCIpKSYmXCJvYmplY3RcIj09dHlwZW9mIHQmJlwiZGVmYXVsdFwiaW4gdD90LmRlZmF1bHQ6dCxpPXJlcXVpcmUoXCJAZXRoZXJldW1qcy91dGlsXCIpO2NvbnN0IHI9e0VUSF9TSUdOX1JFUVVFU1Q6bmV3IGUuUmVnaXN0cnlUeXBlKFwiZXRoLXNpZ24tcmVxdWVzdFwiLDQwMSksRVRIX1NJR05BVFVSRTpuZXcgZS5SZWdpc3RyeVR5cGUoXCJldGgtc2lnbmF0dXJlXCIsNDAyKSxFVEhfTkZUX0lURU06bmV3IGUuUmVnaXN0cnlUeXBlKFwiZXRoLW5mdC1pdGVtXCIsNDAzKX0se2RlY29kZVRvRGF0YUl0ZW06bixSZWdpc3RyeVR5cGVzOmR9PWUuZXh0ZW5kO3ZhciBvLGg7IWZ1bmN0aW9uKHQpe3RbdC5yZXF1ZXN0SWQ9MV09XCJyZXF1ZXN0SWRcIix0W3Quc2lnbkRhdGE9Ml09XCJzaWduRGF0YVwiLHRbdC5kYXRhVHlwZT0zXT1cImRhdGFUeXBlXCIsdFt0LmNoYWluSWQ9NF09XCJjaGFpbklkXCIsdFt0LmRlcml2YXRpb25QYXRoPTVdPVwiZGVyaXZhdGlvblBhdGhcIix0W3QuYWRkcmVzcz02XT1cImFkZHJlc3NcIix0W3Qub3JpZ2luPTddPVwib3JpZ2luXCJ9KG98fChvPXt9KSksKGg9ZXhwb3J0cy5EYXRhVHlwZXx8KGV4cG9ydHMuRGF0YVR5cGU9e30pKVtoLnRyYW5zYWN0aW9uPTFdPVwidHJhbnNhY3Rpb25cIixoW2gudHlwZWREYXRhPTJdPVwidHlwZWREYXRhXCIsaFtoLnBlcnNvbmFsTWVzc2FnZT0zXT1cInBlcnNvbmFsTWVzc2FnZVwiLGhbaC50eXBlZFRyYW5zYWN0aW9uPTRdPVwidHlwZWRUcmFuc2FjdGlvblwiO2NsYXNzIGMgZXh0ZW5kcyBlLlJlZ2lzdHJ5SXRlbXtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuZ2V0UmVnaXN0cnlUeXBlPSgpPT5yLkVUSF9TSUdOX1JFUVVFU1QsdGhpcy5nZXRSZXF1ZXN0SWQ9KCk9PnRoaXMucmVxdWVzdElkLHRoaXMuZ2V0U2lnbkRhdGE9KCk9PnRoaXMuc2lnbkRhdGEsdGhpcy5nZXREYXRhVHlwZT0oKT0+dGhpcy5kYXRhVHlwZSx0aGlzLmdldENoYWluSWQ9KCk9PnRoaXMuY2hhaW5JZCx0aGlzLmdldERlcml2YXRpb25QYXRoPSgpPT50aGlzLmRlcml2YXRpb25QYXRoLmdldFBhdGgoKSx0aGlzLmdldFNvdXJjZUZpbmdlcnByaW50PSgpPT50aGlzLmRlcml2YXRpb25QYXRoLmdldFNvdXJjZUZpbmdlcnByaW50KCksdGhpcy5nZXRTaWduUmVxdWVzdEFkZHJlc3M9KCk9PnRoaXMuYWRkcmVzcyx0aGlzLmdldE9yaWdpbj0oKT0+dGhpcy5vcmlnaW4sdGhpcy50b0RhdGFJdGVtPSgpPT57Y29uc3QgdD17fTt0aGlzLnJlcXVlc3RJZCYmKHRbby5yZXF1ZXN0SWRdPW5ldyBlLkRhdGFJdGVtKHRoaXMucmVxdWVzdElkLGQuVVVJRC5nZXRUYWcoKSkpLHRoaXMuYWRkcmVzcyYmKHRbby5hZGRyZXNzXT10aGlzLmFkZHJlc3MpLHRoaXMuY2hhaW5JZCYmKHRbby5jaGFpbklkXT10aGlzLmNoYWluSWQpLHRoaXMub3JpZ2luJiYodFtvLm9yaWdpbl09dGhpcy5vcmlnaW4pLHRbby5zaWduRGF0YV09dGhpcy5zaWduRGF0YSx0W28uZGF0YVR5cGVdPXRoaXMuZGF0YVR5cGU7Y29uc3QgYT10aGlzLmRlcml2YXRpb25QYXRoLnRvRGF0YUl0ZW0oKTtyZXR1cm4gYS5zZXRUYWcodGhpcy5kZXJpdmF0aW9uUGF0aC5nZXRSZWdpc3RyeVR5cGUoKS5nZXRUYWcoKSksdFtvLmRlcml2YXRpb25QYXRoXT1hLG5ldyBlLkRhdGFJdGVtKHQpfSx0aGlzLnJlcXVlc3RJZD10LnJlcXVlc3RJZCx0aGlzLnNpZ25EYXRhPXQuc2lnbkRhdGEsdGhpcy5kYXRhVHlwZT10LmRhdGFUeXBlLHRoaXMuY2hhaW5JZD10LmNoYWluSWQsdGhpcy5kZXJpdmF0aW9uUGF0aD10LmRlcml2YXRpb25QYXRoLHRoaXMuYWRkcmVzcz10LmFkZHJlc3MsdGhpcy5vcmlnaW49dC5vcmlnaW59c3RhdGljIGNvbnN0cnVjdEVUSFJlcXVlc3QodCxzLGkscixuLGQsbyxoKXtjb25zdCBnPWkucmVwbGFjZSgvW218TV1cXC8vLFwiXCIpLnNwbGl0KFwiL1wiKSx1PW5ldyBlLkNyeXB0b0tleXBhdGgoZy5tYXAodD0+e2NvbnN0IGE9cGFyc2VJbnQodC5yZXBsYWNlKFwiJ1wiLFwiXCIpKTtsZXQgcz0hMTtyZXR1cm4gdC5lbmRzV2l0aChcIidcIikmJihzPSEwKSxuZXcgZS5QYXRoQ29tcG9uZW50KHtpbmRleDphLGhhcmRlbmVkOnN9KX0pLEJ1ZmZlci5mcm9tKHIsXCJoZXhcIikpO3JldHVybiBuZXcgYyh7cmVxdWVzdElkOm4/QnVmZmVyLmZyb20oYS5wYXJzZShuKSk6dm9pZCAwLHNpZ25EYXRhOnQsZGF0YVR5cGU6cyxkZXJpdmF0aW9uUGF0aDp1LGNoYWluSWQ6ZCxhZGRyZXNzOm8/QnVmZmVyLmZyb20oby5yZXBsYWNlKFwiMHhcIixcIlwiKSxcImhleFwiKTp2b2lkIDAsb3JpZ2luOmh8fHZvaWQgMH0pfX1jLmZyb21EYXRhSXRlbT10PT57Y29uc3QgYT10LmdldERhdGEoKSxzPWFbby5zaWduRGF0YV0saT1hW28uZGF0YVR5cGVdLHI9ZS5DcnlwdG9LZXlwYXRoLmZyb21EYXRhSXRlbShhW28uZGVyaXZhdGlvblBhdGhdKSxuPWFbby5jaGFpbklkXT9hW28uY2hhaW5JZF06dm9pZCAwLGQ9YVtvLmFkZHJlc3NdP2Fbby5hZGRyZXNzXTp2b2lkIDAsaD1hW28ucmVxdWVzdElkXT9hW28ucmVxdWVzdElkXS5nZXREYXRhKCk6dm9pZCAwO3JldHVybiBuZXcgYyh7cmVxdWVzdElkOmgsc2lnbkRhdGE6cyxkYXRhVHlwZTppLGNoYWluSWQ6bixkZXJpdmF0aW9uUGF0aDpyLGFkZHJlc3M6ZCxvcmlnaW46YVtvLm9yaWdpbl0/YVtvLm9yaWdpbl06dm9pZCAwfSl9LGMuZnJvbUNCT1I9dD0+e2NvbnN0IGU9bih0KTtyZXR1cm4gYy5mcm9tRGF0YUl0ZW0oZSl9O2NvbnN0e1JlZ2lzdHJ5VHlwZXM6ZyxkZWNvZGVUb0RhdGFJdGVtOnV9PWUuZXh0ZW5kO3ZhciBtOyFmdW5jdGlvbih0KXt0W3QucmVxdWVzdElkPTFdPVwicmVxdWVzdElkXCIsdFt0LnNpZ25hdHVyZT0yXT1cInNpZ25hdHVyZVwiLHRbdC5vcmlnaW49M109XCJvcmlnaW5cIn0obXx8KG09e30pKTtjbGFzcyBJIGV4dGVuZHMgZS5SZWdpc3RyeUl0ZW17Y29uc3RydWN0b3IodCxhLHMpe3N1cGVyKCksdGhpcy5nZXRSZWdpc3RyeVR5cGU9KCk9PnIuRVRIX1NJR05BVFVSRSx0aGlzLmdldFJlcXVlc3RJZD0oKT0+dGhpcy5yZXF1ZXN0SWQsdGhpcy5nZXRTaWduYXR1cmU9KCk9PnRoaXMuc2lnbmF0dXJlLHRoaXMuZ2V0T3JpZ2luPSgpPT50aGlzLm9yaWdpbix0aGlzLnRvRGF0YUl0ZW09KCk9Pntjb25zdCB0PXt9O3JldHVybiB0aGlzLnJlcXVlc3RJZCYmKHRbbS5yZXF1ZXN0SWRdPW5ldyBlLkRhdGFJdGVtKHRoaXMucmVxdWVzdElkLGcuVVVJRC5nZXRUYWcoKSkpLHRoaXMub3JpZ2luJiYodFttLm9yaWdpbl09dGhpcy5vcmlnaW4pLHRbbS5zaWduYXR1cmVdPXRoaXMuc2lnbmF0dXJlLG5ldyBlLkRhdGFJdGVtKHQpfSx0aGlzLnNpZ25hdHVyZT10LHRoaXMucmVxdWVzdElkPWEsdGhpcy5vcmlnaW49c319SS5mcm9tRGF0YUl0ZW09dD0+e2NvbnN0IGU9dC5nZXREYXRhKCksYT1lW20uc2lnbmF0dXJlXSxzPWVbbS5yZXF1ZXN0SWRdP2VbbS5yZXF1ZXN0SWRdLmdldERhdGEoKTp2b2lkIDA7cmV0dXJuIG5ldyBJKGEscyxlW20ub3JpZ2luXSl9LEkuZnJvbUNCT1I9dD0+e2NvbnN0IGU9dSh0KTtyZXR1cm4gSS5mcm9tRGF0YUl0ZW0oZSl9O2NvbnN0e2RlY29kZVRvRGF0YUl0ZW06cH09ZS5leHRlbmQ7dmFyIEQ7IWZ1bmN0aW9uKHQpe3RbdC5jaGFpbklkPTFdPVwiY2hhaW5JZFwiLHRbdC5jb250cmFjdEFkZHJlc3M9Ml09XCJjb250cmFjdEFkZHJlc3NcIix0W3QuY29udHJhY3ROYW1lPTNdPVwiY29udHJhY3ROYW1lXCIsdFt0Lm5hbWU9NF09XCJuYW1lXCIsdFt0Lm1lZGlhRGF0YT01XT1cIm1lZGlhRGF0YVwifShEfHwoRD17fSkpO2NsYXNzIFQgZXh0ZW5kcyBlLlJlZ2lzdHJ5SXRlbXtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuZ2V0UmVnaXN0cnlUeXBlPSgpPT5yLkVUSF9ORlRfSVRFTSx0aGlzLmdldENoYWluSWQ9KCk9PnRoaXMuY2hhaW5JZCx0aGlzLmdldE5hbWU9KCk9PnRoaXMubmFtZSx0aGlzLmdldG1lZGlhRGF0YT0oKT0+dGhpcy5tZWRpYURhdGEsdGhpcy5nZXRDb250cmFjdEFkZHJlc3M9KCk9PnRoaXMuY29udHJhY3RBZGRyZXNzLHRoaXMuZ2V0Q29udHJhY3ROYW1lPSgpPT50aGlzLmNvbnRyYWN0TmFtZSx0aGlzLnRvRGF0YUl0ZW09KCk9Pntjb25zdCB0PXt9O3JldHVybiB0W0QuY2hhaW5JZF09dGhpcy5jaGFpbklkLHRbRC5uYW1lXT10aGlzLm5hbWUsdFtELmNvbnRyYWN0QWRkcmVzc109dGhpcy5jb250cmFjdEFkZHJlc3MsdFtELmNvbnRyYWN0TmFtZV09dGhpcy5jb250cmFjdE5hbWUsdFtELm1lZGlhRGF0YV09dGhpcy5tZWRpYURhdGEsbmV3IGUuRGF0YUl0ZW0odCl9LHRoaXMuY2hhaW5JZD10LmNoYWluSWQsdGhpcy5uYW1lPXQubmFtZSx0aGlzLmNvbnRyYWN0QWRkcmVzcz10LmNvbnRyYWN0QWRkcmVzcyx0aGlzLmNvbnRyYWN0TmFtZT10LmNvbnRyYWN0TmFtZSx0aGlzLm1lZGlhRGF0YT10Lm1lZGlhRGF0YX1zdGF0aWMgY29uc3RydWN0RVRITkZUSXRlbSh0LGUsYSxzLGkpe3JldHVybiBuZXcgVCh7Y2hhaW5JZDp0LGNvbnRyYWN0QWRkcmVzczplLGNvbnRyYWN0TmFtZTphLG1lZGlhRGF0YTppLG5hbWU6c30pfX1ULmZyb21EYXRhSXRlbT10PT57Y29uc3QgZT10LmdldERhdGEoKTtyZXR1cm4gbmV3IFQoe2NoYWluSWQ6ZVtELmNoYWluSWRdLG5hbWU6ZVtELm5hbWVdLGNvbnRyYWN0QWRkcmVzczplW0QuY29udHJhY3RBZGRyZXNzXSxjb250cmFjdE5hbWU6ZVtELmNvbnRyYWN0TmFtZV0sbWVkaWFEYXRhOmVbRC5tZWRpYURhdGFdfSl9LFQuZnJvbUNCT1I9dD0+e2NvbnN0IGU9cCh0KTtyZXR1cm4gVC5mcm9tRGF0YUl0ZW0oZSl9O2NvbnN0IHk9KHQsZSk9Pntjb25zdCBhPXMuZnJvbUV4dGVuZGVkS2V5KHQpLmRlcml2ZShlKSxyPVwiMHhcIitpLnB1YmxpY1RvQWRkcmVzcyhhLnB1YmxpY0tleSwhMCkudG9TdHJpbmcoXCJoZXhcIik7cmV0dXJuIGkudG9DaGVja3N1bUFkZHJlc3Mocil9O2UucGF0Y2hUYWdzKE9iamVjdC52YWx1ZXMocikuZmlsdGVyKHQ9PiEhdC5nZXRUYWcoKSkubWFwKHQ9PnQuZ2V0VGFnKCkpKSxPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChmdW5jdGlvbih0KXtcImRlZmF1bHRcIiE9PXQmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLHQse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGVbdF19fSl9KSksZXhwb3J0cy5FVEhORlRJdGVtPVQsZXhwb3J0cy5FVEhTaWduYXR1cmU9SSxleHBvcnRzLkV0aFNpZ25SZXF1ZXN0PWMsZXhwb3J0cy5maW5kSERQYXRoRnJvbUFkZHJlc3M9KHQsZSxhLHMpPT57Zm9yKGxldCBpPTA7aTxhO2krKyl7Y29uc3QgYT15KGUsXCJNLzAvXCIraSk7aWYodC50b0xvd2VyQ2FzZSgpPT1hLnRvTG93ZXJDYXNlKCkpcmV0dXJuYCR7c30vMC8ke2l9YH1yZXR1cm4gbnVsbH0sZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3NGcm9tWHB1Yj15O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmMtdXItcmVnaXN0cnktZXRoLmNqcy5wcm9kdWN0aW9uLm1pbi5qcy5tYXBcbiIsIlxuJ3VzZSBzdHJpY3QnXG5cbmlmIChcImRldmVsb3BtZW50XCIgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYmMtdXItcmVnaXN0cnktZXRoLmNqcy5wcm9kdWN0aW9uLm1pbi5qcycpXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYmMtdXItcmVnaXN0cnktZXRoLmNqcy5kZXZlbG9wbWVudC5qcycpXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnl0ZXMgPSB2b2lkIDA7XG5jb25zdCBsaWJfMSA9IHJlcXVpcmUoXCIuL2xpYlwiKTtcbmNvbnN0IFJlZ2lzdHJ5SXRlbV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlJdGVtXCIpO1xuY29uc3QgUmVnaXN0cnlUeXBlXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeVR5cGVcIik7XG5jbGFzcyBCeXRlcyBleHRlbmRzIFJlZ2lzdHJ5SXRlbV8xLlJlZ2lzdHJ5SXRlbSB7XG4gICAgY29uc3RydWN0b3IoYnl0ZXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ieXRlcyA9IGJ5dGVzO1xuICAgICAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkJZVEVTO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldERhdGEgPSAoKSA9PiB0aGlzLmJ5dGVzO1xuICAgICAgICB0aGlzLnRvRGF0YUl0ZW0gPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGxpYl8xLkRhdGFJdGVtKHRoaXMuYnl0ZXMpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQnl0ZXMgPSBCeXRlcztcbkJ5dGVzLmZyb21EYXRhSXRlbSA9IChkYXRhSXRlbSkgPT4ge1xuICAgIGNvbnN0IGJ5dGVzID0gZGF0YUl0ZW0uZ2V0RGF0YSgpO1xuICAgIGlmICghYnl0ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAjW3VyLXJlZ2lzdHJ5XVtCeXRlc11bZm4uZnJvbURhdGFJdGVtXTogZGVjb2RlZCBbZGF0YUl0ZW1dWyNkYXRhXSBpcyB1bmRlZmluZWQ6ICR7ZGF0YUl0ZW19YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQnl0ZXMoYnl0ZXMpO1xufTtcbkJ5dGVzLmZyb21DQk9SID0gKF9jYm9yUGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IGRhdGFJdGVtID0gKDAsIGxpYl8xLmRlY29kZVRvRGF0YUl0ZW0pKF9jYm9yUGF5bG9hZCk7XG4gICAgcmV0dXJuIEJ5dGVzLmZyb21EYXRhSXRlbShkYXRhSXRlbSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qnl0ZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNyeXB0b0FjY291bnQgPSB2b2lkIDA7XG5jb25zdCBfMSA9IHJlcXVpcmUoXCIuXCIpO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi9saWJcIik7XG5jb25zdCBSZWdpc3RyeUl0ZW1fMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5SXRlbVwiKTtcbmNvbnN0IFJlZ2lzdHJ5VHlwZV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlUeXBlXCIpO1xudmFyIEtleXM7XG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgICBLZXlzW0tleXNbXCJtYXN0ZXJGaW5nZXJwcmludFwiXSA9IDFdID0gXCJtYXN0ZXJGaW5nZXJwcmludFwiO1xuICAgIEtleXNbS2V5c1tcIm91dHB1dERlc2NyaXB0b3JzXCJdID0gMl0gPSBcIm91dHB1dERlc2NyaXB0b3JzXCI7XG59KShLZXlzIHx8IChLZXlzID0ge30pKTtcbmNsYXNzIENyeXB0b0FjY291bnQgZXh0ZW5kcyBSZWdpc3RyeUl0ZW1fMS5SZWdpc3RyeUl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKG1hc3RlckZpbmdlcnByaW50LCBvdXRwdXREZXNjcmlwdG9ycykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1hc3RlckZpbmdlcnByaW50ID0gbWFzdGVyRmluZ2VycHJpbnQ7XG4gICAgICAgIHRoaXMub3V0cHV0RGVzY3JpcHRvcnMgPSBvdXRwdXREZXNjcmlwdG9ycztcbiAgICAgICAgdGhpcy5nZXRSZWdpc3RyeVR5cGUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fQUNDT1VOVDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRNYXN0ZXJGaW5nZXJwcmludCA9ICgpID0+IHRoaXMubWFzdGVyRmluZ2VycHJpbnQ7XG4gICAgICAgIHRoaXMuZ2V0T3V0cHV0RGVzY3JpcHRvcnMgPSAoKSA9PiB0aGlzLm91dHB1dERlc2NyaXB0b3JzO1xuICAgICAgICB0aGlzLnRvRGF0YUl0ZW0gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hc3RlckZpbmdlcnByaW50KSB7XG4gICAgICAgICAgICAgICAgbWFwW0tleXMubWFzdGVyRmluZ2VycHJpbnRdID0gdGhpcy5tYXN0ZXJGaW5nZXJwcmludC5yZWFkVUludDMyQkUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXREZXNjcmlwdG9ycykge1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLm91dHB1dERlc2NyaXB0b3JzXSA9IHRoaXMub3V0cHV0RGVzY3JpcHRvcnMubWFwKChpdGVtKSA9PiBpdGVtLnRvRGF0YUl0ZW0oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IGxpYl8xLkRhdGFJdGVtKG1hcCk7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5DcnlwdG9BY2NvdW50ID0gQ3J5cHRvQWNjb3VudDtcbkNyeXB0b0FjY291bnQuZnJvbURhdGFJdGVtID0gKGRhdGFJdGVtKSA9PiB7XG4gICAgY29uc3QgbWFwID0gZGF0YUl0ZW0uZ2V0RGF0YSgpO1xuICAgIGNvbnN0IG1hc3RlckZpbmdlcnByaW50ID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIGNvbnN0IF9tYXN0ZXJGaW5nZXJwcmludCA9IG1hcFtLZXlzLm1hc3RlckZpbmdlcnByaW50XTtcbiAgICBpZiAoX21hc3RlckZpbmdlcnByaW50KSB7XG4gICAgICAgIG1hc3RlckZpbmdlcnByaW50LndyaXRlVUludDMyQkUoX21hc3RlckZpbmdlcnByaW50LCAwKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0RGVzY3JpcHRvcnMgPSBtYXBbS2V5cy5vdXRwdXREZXNjcmlwdG9yc107XG4gICAgY29uc3QgY3J5cHRvT3V0cHV0cyA9IG91dHB1dERlc2NyaXB0b3JzLm1hcCgoaXRlbSkgPT4gXzEuQ3J5cHRvT3V0cHV0LmZyb21EYXRhSXRlbShpdGVtKSk7XG4gICAgcmV0dXJuIG5ldyBDcnlwdG9BY2NvdW50KG1hc3RlckZpbmdlcnByaW50LCBjcnlwdG9PdXRwdXRzKTtcbn07XG5DcnlwdG9BY2NvdW50LmZyb21DQk9SID0gKF9jYm9yUGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IGRhdGFJdGVtID0gKDAsIGxpYl8xLmRlY29kZVRvRGF0YUl0ZW0pKF9jYm9yUGF5bG9hZCk7XG4gICAgcmV0dXJuIENyeXB0b0FjY291bnQuZnJvbURhdGFJdGVtKGRhdGFJdGVtKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DcnlwdG9BY2NvdW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DcnlwdG9Db2luSW5mbyA9IGV4cG9ydHMuTmV0d29yayA9IGV4cG9ydHMuVHlwZSA9IHZvaWQgMDtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4vbGliXCIpO1xuY29uc3QgUmVnaXN0cnlJdGVtXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeUl0ZW1cIik7XG5jb25zdCBSZWdpc3RyeVR5cGVfMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5VHlwZVwiKTtcbnZhciBLZXlzO1xuKGZ1bmN0aW9uIChLZXlzKSB7XG4gICAgS2V5c1tcInR5cGVcIl0gPSBcIjFcIjtcbiAgICBLZXlzW1wibmV0d29ya1wiXSA9IFwiMlwiO1xufSkoS2V5cyB8fCAoS2V5cyA9IHt9KSk7XG52YXIgVHlwZTtcbihmdW5jdGlvbiAoVHlwZSkge1xuICAgIFR5cGVbVHlwZVtcImJpdGNvaW5cIl0gPSAwXSA9IFwiYml0Y29pblwiO1xufSkoVHlwZSA9IGV4cG9ydHMuVHlwZSB8fCAoZXhwb3J0cy5UeXBlID0ge30pKTtcbnZhciBOZXR3b3JrO1xuKGZ1bmN0aW9uIChOZXR3b3JrKSB7XG4gICAgTmV0d29ya1tOZXR3b3JrW1wibWFpbm5ldFwiXSA9IDBdID0gXCJtYWlubmV0XCI7XG4gICAgTmV0d29ya1tOZXR3b3JrW1widGVzdG5ldFwiXSA9IDFdID0gXCJ0ZXN0bmV0XCI7XG59KShOZXR3b3JrID0gZXhwb3J0cy5OZXR3b3JrIHx8IChleHBvcnRzLk5ldHdvcmsgPSB7fSkpO1xuY2xhc3MgQ3J5cHRvQ29pbkluZm8gZXh0ZW5kcyBSZWdpc3RyeUl0ZW1fMS5SZWdpc3RyeUl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIG5ldHdvcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5uZXR3b3JrID0gbmV0d29yaztcbiAgICAgICAgdGhpcy5nZXRSZWdpc3RyeVR5cGUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fQ09JTl9JTkZPO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFR5cGUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlIHx8IFR5cGUuYml0Y29pbjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXROZXR3b3JrID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV0d29yayB8fCBOZXR3b3JrLm1haW5uZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudG9EYXRhSXRlbSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLnR5cGVdID0gdGhpcy50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubmV0d29yaykge1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLm5ldHdvcmtdID0gdGhpcy5uZXR3b3JrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBsaWJfMS5EYXRhSXRlbShtYXApO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ3J5cHRvQ29pbkluZm8gPSBDcnlwdG9Db2luSW5mbztcbkNyeXB0b0NvaW5JbmZvLmZyb21EYXRhSXRlbSA9IChkYXRhSXRlbSkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IGRhdGFJdGVtLmdldERhdGEoKTtcbiAgICBjb25zdCB0eXBlID0gbWFwW0tleXMudHlwZV07XG4gICAgY29uc3QgbmV0d29yayA9IG1hcFtLZXlzLm5ldHdvcmtdO1xuICAgIHJldHVybiBuZXcgQ3J5cHRvQ29pbkluZm8odHlwZSwgbmV0d29yayk7XG59O1xuQ3J5cHRvQ29pbkluZm8uZnJvbUNCT1IgPSAoX2Nib3JQYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgZGF0YUl0ZW0gPSAoMCwgbGliXzEuZGVjb2RlVG9EYXRhSXRlbSkoX2Nib3JQYXlsb2FkKTtcbiAgICByZXR1cm4gQ3J5cHRvQ29pbkluZm8uZnJvbURhdGFJdGVtKGRhdGFJdGVtKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DcnlwdG9Db2luSW5mby5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ3J5cHRvRUNLZXkgPSB2b2lkIDA7XG5jb25zdCBsaWJfMSA9IHJlcXVpcmUoXCIuL2xpYlwiKTtcbmNvbnN0IFJlZ2lzdHJ5SXRlbV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlJdGVtXCIpO1xuY29uc3QgUmVnaXN0cnlUeXBlXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeVR5cGVcIik7XG52YXIgS2V5cztcbihmdW5jdGlvbiAoS2V5cykge1xuICAgIEtleXNbS2V5c1tcImN1cnZlXCJdID0gMV0gPSBcImN1cnZlXCI7XG4gICAgS2V5c1tLZXlzW1wicHJpdmF0ZVwiXSA9IDJdID0gXCJwcml2YXRlXCI7XG4gICAgS2V5c1tLZXlzW1wiZGF0YVwiXSA9IDNdID0gXCJkYXRhXCI7XG59KShLZXlzIHx8IChLZXlzID0ge30pKTtcbmNsYXNzIENyeXB0b0VDS2V5IGV4dGVuZHMgUmVnaXN0cnlJdGVtXzEuUmVnaXN0cnlJdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaXNFQ0tleSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldEN1cnZlID0gKCkgPT4gdGhpcy5jdXJ2ZSB8fCAwO1xuICAgICAgICB0aGlzLmlzUHJpdmF0ZUtleSA9ICgpID0+IHRoaXMucHJpdmF0ZUtleSB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5nZXREYXRhID0gKCkgPT4gdGhpcy5kYXRhO1xuICAgICAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19FQ0tFWTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b0RhdGFJdGVtID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWFwID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJ2ZSkge1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLmN1cnZlXSA9IHRoaXMuY3VydmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wcml2YXRlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXBbS2V5cy5wcml2YXRlXSA9IHRoaXMucHJpdmF0ZUtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcFtLZXlzLmRhdGFdID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBsaWJfMS5EYXRhSXRlbShtYXApO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE91dHB1dERlc2NyaXB0b3JDb250ZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGF0YSA9IGFyZ3MuZGF0YTtcbiAgICAgICAgdGhpcy5jdXJ2ZSA9IGFyZ3MuY3VydmU7XG4gICAgICAgIHRoaXMucHJpdmF0ZUtleSA9IGFyZ3MucHJpdmF0ZUtleSB8fCB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5DcnlwdG9FQ0tleSA9IENyeXB0b0VDS2V5O1xuQ3J5cHRvRUNLZXkuZnJvbURhdGFJdGVtID0gKGRhdGFJdGVtKSA9PiB7XG4gICAgY29uc3QgbWFwID0gZGF0YUl0ZW0uZ2V0RGF0YSgpO1xuICAgIGNvbnN0IGN1cnZlID0gbWFwW0tleXMuY3VydmVdO1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBtYXBbS2V5cy5wcml2YXRlXTtcbiAgICBjb25zdCBkYXRhID0gbWFwW0tleXMuZGF0YV07XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgI1t1ci1yZWdpc3RyeV1bQ3J5cHRvRUNLZXldW2ZuLmZyb21EYXRhSXRlbV06IGRlY29kZWQgW2RhdGFJdGVtXVsjZGF0YS5kYXRhXSBpcyB1bmRlZmluZWQ6ICR7ZGF0YUl0ZW19YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ3J5cHRvRUNLZXkoeyBkYXRhLCBjdXJ2ZSwgcHJpdmF0ZUtleSB9KTtcbn07XG5DcnlwdG9FQ0tleS5mcm9tQ0JPUiA9IChfY2JvclBheWxvYWQpID0+IHtcbiAgICBjb25zdCBkYXRhSXRlbSA9ICgwLCBsaWJfMS5kZWNvZGVUb0RhdGFJdGVtKShfY2JvclBheWxvYWQpO1xuICAgIHJldHVybiBDcnlwdG9FQ0tleS5mcm9tRGF0YUl0ZW0oZGF0YUl0ZW0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNyeXB0b0VDS2V5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DcnlwdG9IREtleSA9IHZvaWQgMDtcbmNvbnN0IGJzNThjaGVja18xID0gcmVxdWlyZShcImJzNThjaGVja1wiKTtcbmNvbnN0IENyeXB0b0NvaW5JbmZvXzEgPSByZXF1aXJlKFwiLi9DcnlwdG9Db2luSW5mb1wiKTtcbmNvbnN0IENyeXB0b0tleXBhdGhfMSA9IHJlcXVpcmUoXCIuL0NyeXB0b0tleXBhdGhcIik7XG5jb25zdCBsaWJfMSA9IHJlcXVpcmUoXCIuL2xpYlwiKTtcbmNvbnN0IFJlZ2lzdHJ5SXRlbV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlJdGVtXCIpO1xuY29uc3QgUmVnaXN0cnlUeXBlXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeVR5cGVcIik7XG52YXIgS2V5cztcbihmdW5jdGlvbiAoS2V5cykge1xuICAgIEtleXNbS2V5c1tcImlzX21hc3RlclwiXSA9IDFdID0gXCJpc19tYXN0ZXJcIjtcbiAgICBLZXlzW0tleXNbXCJpc19wcml2YXRlXCJdID0gMl0gPSBcImlzX3ByaXZhdGVcIjtcbiAgICBLZXlzW0tleXNbXCJrZXlfZGF0YVwiXSA9IDNdID0gXCJrZXlfZGF0YVwiO1xuICAgIEtleXNbS2V5c1tcImNoYWluX2NvZGVcIl0gPSA0XSA9IFwiY2hhaW5fY29kZVwiO1xuICAgIEtleXNbS2V5c1tcInVzZV9pbmZvXCJdID0gNV0gPSBcInVzZV9pbmZvXCI7XG4gICAgS2V5c1tLZXlzW1wib3JpZ2luXCJdID0gNl0gPSBcIm9yaWdpblwiO1xuICAgIEtleXNbS2V5c1tcImNoaWxkcmVuXCJdID0gN10gPSBcImNoaWxkcmVuXCI7XG4gICAgS2V5c1tLZXlzW1wicGFyZW50X2ZpbmdlcnByaW50XCJdID0gOF0gPSBcInBhcmVudF9maW5nZXJwcmludFwiO1xuICAgIEtleXNbS2V5c1tcIm5hbWVcIl0gPSA5XSA9IFwibmFtZVwiO1xuICAgIEtleXNbS2V5c1tcIm5vdGVcIl0gPSAxMF0gPSBcIm5vdGVcIjtcbn0pKEtleXMgfHwgKEtleXMgPSB7fSkpO1xuY2xhc3MgQ3J5cHRvSERLZXkgZXh0ZW5kcyBSZWdpc3RyeUl0ZW1fMS5SZWdpc3RyeUl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pc0VDS2V5ID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldEtleSA9ICgpID0+IHRoaXMua2V5O1xuICAgICAgICB0aGlzLmdldENoYWluQ29kZSA9ICgpID0+IHRoaXMuY2hhaW5Db2RlO1xuICAgICAgICB0aGlzLmlzTWFzdGVyID0gKCkgPT4gdGhpcy5tYXN0ZXI7XG4gICAgICAgIHRoaXMuaXNQcml2YXRlS2V5ID0gKCkgPT4gISF0aGlzLnByaXZhdGVLZXk7XG4gICAgICAgIHRoaXMuZ2V0VXNlSW5mbyA9ICgpID0+IHRoaXMudXNlSW5mbztcbiAgICAgICAgdGhpcy5nZXRPcmlnaW4gPSAoKSA9PiB0aGlzLm9yaWdpbjtcbiAgICAgICAgdGhpcy5nZXRDaGlsZHJlbiA9ICgpID0+IHRoaXMuY2hpbGRyZW47XG4gICAgICAgIHRoaXMuZ2V0UGFyZW50RmluZ2VycHJpbnQgPSAoKSA9PiB0aGlzLnBhcmVudEZpbmdlcnByaW50O1xuICAgICAgICB0aGlzLmdldE5hbWUgPSAoKSA9PiB0aGlzLm5hbWU7XG4gICAgICAgIHRoaXMuZ2V0Tm90ZSA9ICgpID0+IHRoaXMubm90ZTtcbiAgICAgICAgdGhpcy5nZXRCaXAzMktleSA9ICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgbGV0IHZlcnNpb247XG4gICAgICAgICAgICBsZXQgZGVwdGg7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgbGV0IHBhcmVudEZpbmdlcnByaW50ID0gQnVmZmVyLmFsbG9jKDQpLmZpbGwoMCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc01hc3RlcigpKSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbiA9IEJ1ZmZlci5mcm9tKCcwNDg4QURFNCcsICdoZXgnKTtcbiAgICAgICAgICAgICAgICBkZXB0aCA9IDA7XG4gICAgICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVwdGggPSAoKF9hID0gdGhpcy5nZXRPcmlnaW4oKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldENvbXBvbmVudHMoKS5sZW5ndGgpIHx8ICgoX2IgPSB0aGlzLmdldE9yaWdpbigpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0RGVwdGgoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aHMgPSAoX2MgPSB0aGlzLmdldE9yaWdpbigpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZ2V0Q29tcG9uZW50cygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RQYXRoID0gcGF0aHNbcGF0aHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gbGFzdFBhdGguaXNIYXJkZW5lZCgpID8gbGFzdFBhdGguZ2V0SW5kZXgoKSArIDB4ODAwMDAwMDAgOiBsYXN0UGF0aC5nZXRJbmRleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRQYXJlbnRGaW5nZXJwcmludCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRGaW5nZXJwcmludCA9IHRoaXMuZ2V0UGFyZW50RmluZ2VycHJpbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ByaXZhdGVLZXkoKSkge1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uID0gQnVmZmVyLmZyb20oJzA0ODhBREU0JywgJ2hleCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbiA9IEJ1ZmZlci5mcm9tKCcwNDg4QjIxRScsICdoZXgnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXB0aEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxKTtcbiAgICAgICAgICAgIGRlcHRoQnVmZmVyLndyaXRlVUludDgoZGVwdGgsIDApO1xuICAgICAgICAgICAgY29uc3QgaW5kZXhCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgICAgICAgICBpbmRleEJ1ZmZlci53cml0ZVVJbnQzMkJFKGluZGV4LCAwKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluQ29kZSA9IHRoaXMuZ2V0Q2hhaW5Db2RlKCk7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleSgpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBiczU4Y2hlY2tfMS5lbmNvZGUpKEJ1ZmZlci5jb25jYXQoW3ZlcnNpb24sIGRlcHRoQnVmZmVyLCBwYXJlbnRGaW5nZXJwcmludCwgaW5kZXhCdWZmZXIsIGNoYWluQ29kZSwga2V5XSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19IREtFWTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRPdXRwdXREZXNjcmlwdG9yQ29udGVudCA9ICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLmdldE9yaWdpbigpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLmdldE9yaWdpbigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U291cmNlRmluZ2VycHJpbnQoKSkgJiYgKChfYiA9IHRoaXMuZ2V0T3JpZ2luKCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXRQYXRoKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBgJHsoX2QgPSAoX2MgPSB0aGlzLmdldE9yaWdpbigpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZ2V0U291cmNlRmluZ2VycHJpbnQoKSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnRvU3RyaW5nKCdoZXgnKX0vJHsoX2UgPSB0aGlzLmdldE9yaWdpbigpKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuZ2V0UGF0aCgpfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuZ2V0QmlwMzJLZXkoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldENoaWxkcmVuKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKF9mID0gdGhpcy5nZXRDaGlsZHJlbigpKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuZ2V0UGF0aCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBgLyR7KF9nID0gdGhpcy5nZXRDaGlsZHJlbigpKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuZ2V0UGF0aCgpfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXR1cE1hc3RlcktleSA9IChhcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1hc3RlciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmtleSA9IGFyZ3Mua2V5O1xuICAgICAgICAgICAgdGhpcy5jaGFpbkNvZGUgPSBhcmdzLmNoYWluQ29kZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXR1cERlcml2ZUtleSA9IChhcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1hc3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wcml2YXRlS2V5ID0gYXJncy5pc1ByaXZhdGVLZXk7XG4gICAgICAgICAgICB0aGlzLmtleSA9IGFyZ3Mua2V5O1xuICAgICAgICAgICAgdGhpcy5jaGFpbkNvZGUgPSBhcmdzLmNoYWluQ29kZTtcbiAgICAgICAgICAgIHRoaXMudXNlSW5mbyA9IGFyZ3MudXNlSW5mbztcbiAgICAgICAgICAgIHRoaXMub3JpZ2luID0gYXJncy5vcmlnaW47XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gYXJncy5jaGlsZHJlbjtcbiAgICAgICAgICAgIHRoaXMucGFyZW50RmluZ2VycHJpbnQgPSBhcmdzLnBhcmVudEZpbmdlcnByaW50O1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gYXJncy5uYW1lO1xuICAgICAgICAgICAgdGhpcy5ub3RlID0gYXJncy5ub3RlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRvRGF0YUl0ZW0gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hc3Rlcikge1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLmlzX21hc3Rlcl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLmtleV9kYXRhXSA9IHRoaXMua2V5O1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLmNoYWluX2NvZGVdID0gdGhpcy5jaGFpbkNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcml2YXRlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwW0tleXMuaXNfcHJpdmF0ZV0gPSB0aGlzLnByaXZhdGVLZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcFtLZXlzLmtleV9kYXRhXSA9IHRoaXMua2V5O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYWluQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICBtYXBbS2V5cy5jaGFpbl9jb2RlXSA9IHRoaXMuY2hhaW5Db2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy51c2VJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZUluZm8gPSB0aGlzLnVzZUluZm8udG9EYXRhSXRlbSgpO1xuICAgICAgICAgICAgICAgICAgICB1c2VJbmZvLnNldFRhZyh0aGlzLnVzZUluZm8uZ2V0UmVnaXN0cnlUeXBlKCkuZ2V0VGFnKCkpO1xuICAgICAgICAgICAgICAgICAgICBtYXBbS2V5cy51c2VfaW5mb10gPSB1c2VJbmZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luID0gdGhpcy5vcmlnaW4udG9EYXRhSXRlbSgpO1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW4uc2V0VGFnKHRoaXMub3JpZ2luLmdldFJlZ2lzdHJ5VHlwZSgpLmdldFRhZygpKTtcbiAgICAgICAgICAgICAgICAgICAgbWFwW0tleXMub3JpZ2luXSA9IG9yaWdpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnRvRGF0YUl0ZW0oKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uc2V0VGFnKHRoaXMuY2hpbGRyZW4uZ2V0UmVnaXN0cnlUeXBlKCkuZ2V0VGFnKCkpO1xuICAgICAgICAgICAgICAgICAgICBtYXBbS2V5cy5jaGlsZHJlbl0gPSBjaGlsZHJlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50RmluZ2VycHJpbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwW0tleXMucGFyZW50X2ZpbmdlcnByaW50XSA9IHRoaXMucGFyZW50RmluZ2VycHJpbnQucmVhZFVJbnQzMkJFKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwW0tleXMubmFtZV0gPSB0aGlzLm5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBtYXBbS2V5cy5ub3RlXSA9IHRoaXMubm90ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IGxpYl8xLkRhdGFJdGVtKG1hcCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChhcmdzLmlzTWFzdGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNldHVwTWFzdGVyS2V5KGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXR1cERlcml2ZUtleShhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ3J5cHRvSERLZXkgPSBDcnlwdG9IREtleTtcbkNyeXB0b0hES2V5LmZyb21EYXRhSXRlbSA9IChkYXRhSXRlbSkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IGRhdGFJdGVtLmdldERhdGEoKTtcbiAgICBjb25zdCBpc01hc3RlciA9ICEhbWFwW0tleXMuaXNfbWFzdGVyXTtcbiAgICBjb25zdCBpc1ByaXZhdGVLZXkgPSBtYXBbS2V5cy5pc19wcml2YXRlXTtcbiAgICBjb25zdCBrZXkgPSBtYXBbS2V5cy5rZXlfZGF0YV07XG4gICAgY29uc3QgY2hhaW5Db2RlID0gbWFwW0tleXMuY2hhaW5fY29kZV07XG4gICAgY29uc3QgdXNlSW5mbyA9IG1hcFtLZXlzLnVzZV9pbmZvXVxuICAgICAgICA/IENyeXB0b0NvaW5JbmZvXzEuQ3J5cHRvQ29pbkluZm8uZnJvbURhdGFJdGVtKG1hcFtLZXlzLnVzZV9pbmZvXSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb3JpZ2luID0gbWFwW0tleXMub3JpZ2luXVxuICAgICAgICA/IENyeXB0b0tleXBhdGhfMS5DcnlwdG9LZXlwYXRoLmZyb21EYXRhSXRlbShtYXBbS2V5cy5vcmlnaW5dKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG1hcFtLZXlzLmNoaWxkcmVuXVxuICAgICAgICA/IENyeXB0b0tleXBhdGhfMS5DcnlwdG9LZXlwYXRoLmZyb21EYXRhSXRlbShtYXBbS2V5cy5jaGlsZHJlbl0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IF9wYXJlbnRGaW5nZXJwcmludCA9IG1hcFtLZXlzLnBhcmVudF9maW5nZXJwcmludF07XG4gICAgbGV0IHBhcmVudEZpbmdlcnByaW50ID0gdW5kZWZpbmVkO1xuICAgIGlmIChfcGFyZW50RmluZ2VycHJpbnQpIHtcbiAgICAgICAgcGFyZW50RmluZ2VycHJpbnQgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgICAgIHBhcmVudEZpbmdlcnByaW50LndyaXRlVUludDMyQkUoX3BhcmVudEZpbmdlcnByaW50LCAwKTtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IG1hcFtLZXlzLm5hbWVdO1xuICAgIGNvbnN0IG5vdGUgPSBtYXBbS2V5cy5ub3RlXTtcbiAgICByZXR1cm4gbmV3IENyeXB0b0hES2V5KHtcbiAgICAgICAgaXNNYXN0ZXIsXG4gICAgICAgIGlzUHJpdmF0ZUtleSxcbiAgICAgICAga2V5LFxuICAgICAgICBjaGFpbkNvZGUsXG4gICAgICAgIHVzZUluZm8sXG4gICAgICAgIG9yaWdpbixcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHBhcmVudEZpbmdlcnByaW50LFxuICAgICAgICBuYW1lLFxuICAgICAgICBub3RlLFxuICAgIH0pO1xufTtcbkNyeXB0b0hES2V5LmZyb21DQk9SID0gKF9jYm9yUGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IGRhdGFJdGVtID0gKDAsIGxpYl8xLmRlY29kZVRvRGF0YUl0ZW0pKF9jYm9yUGF5bG9hZCk7XG4gICAgcmV0dXJuIENyeXB0b0hES2V5LmZyb21EYXRhSXRlbShkYXRhSXRlbSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3J5cHRvSERLZXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNyeXB0b0tleXBhdGggPSB2b2lkIDA7XG5jb25zdCBsaWJfMSA9IHJlcXVpcmUoXCIuL2xpYlwiKTtcbmNvbnN0IFBhdGhDb21wb25lbnRfMSA9IHJlcXVpcmUoXCIuL1BhdGhDb21wb25lbnRcIik7XG5jb25zdCBSZWdpc3RyeUl0ZW1fMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5SXRlbVwiKTtcbmNvbnN0IFJlZ2lzdHJ5VHlwZV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlUeXBlXCIpO1xudmFyIEtleXM7XG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgICBLZXlzW0tleXNbXCJjb21wb25lbnRzXCJdID0gMV0gPSBcImNvbXBvbmVudHNcIjtcbiAgICBLZXlzW0tleXNbXCJzb3VyY2VfZmluZ2VycHJpbnRcIl0gPSAyXSA9IFwic291cmNlX2ZpbmdlcnByaW50XCI7XG4gICAgS2V5c1tLZXlzW1wiZGVwdGhcIl0gPSAzXSA9IFwiZGVwdGhcIjtcbn0pKEtleXMgfHwgKEtleXMgPSB7fSkpO1xuY2xhc3MgQ3J5cHRvS2V5cGF0aCBleHRlbmRzIFJlZ2lzdHJ5SXRlbV8xLlJlZ2lzdHJ5SXRlbSB7XG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50cyA9IFtdLCBzb3VyY2VGaW5nZXJwcmludCwgZGVwdGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgdGhpcy5zb3VyY2VGaW5nZXJwcmludCA9IHNvdXJjZUZpbmdlcnByaW50O1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgICAgIHRoaXMuZ2V0UmVnaXN0cnlUeXBlID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX0tFWVBBVEg7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0UGF0aCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHMubWFwKChjb21wb25lbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7Y29tcG9uZW50LmlzV2lsZGNhcmQoKSA/ICcqJyA6IGNvbXBvbmVudC5nZXRJbmRleCgpfSR7Y29tcG9uZW50LmlzSGFyZGVuZWQoKSA/IFwiJ1wiIDogJyd9YDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudHMuam9pbignLycpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldENvbXBvbmVudHMgPSAoKSA9PiB0aGlzLmNvbXBvbmVudHM7XG4gICAgICAgIHRoaXMuZ2V0U291cmNlRmluZ2VycHJpbnQgPSAoKSA9PiB0aGlzLnNvdXJjZUZpbmdlcnByaW50O1xuICAgICAgICB0aGlzLmdldERlcHRoID0gKCkgPT4gdGhpcy5kZXB0aDtcbiAgICAgICAgdGhpcy50b0RhdGFJdGVtID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWFwID0ge307XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRzID0gW107XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMuZm9yRWFjaCgoY29tcG9uZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQuaXNXaWxkY2FyZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLnB1c2goW10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudC5nZXRJbmRleCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLnB1c2goY29tcG9uZW50LmlzSGFyZGVuZWQoKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtYXBbS2V5cy5jb21wb25lbnRzXSA9IGNvbXBvbmVudHM7XG4gICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VGaW5nZXJwcmludCkge1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLnNvdXJjZV9maW5nZXJwcmludF0gPSB0aGlzLnNvdXJjZUZpbmdlcnByaW50LnJlYWRVSW50MzJCRSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRlcHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXBbS2V5cy5kZXB0aF0gPSB0aGlzLmRlcHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBsaWJfMS5EYXRhSXRlbShtYXApO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ3J5cHRvS2V5cGF0aCA9IENyeXB0b0tleXBhdGg7XG5DcnlwdG9LZXlwYXRoLmZyb21EYXRhSXRlbSA9IChkYXRhSXRlbSkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IGRhdGFJdGVtLmdldERhdGEoKTtcbiAgICBjb25zdCBwYXRoQ29tcG9uZW50cyA9IFtdO1xuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBtYXBbS2V5cy5jb21wb25lbnRzXTtcbiAgICBpZiAoY29tcG9uZW50cykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzSGFyZGVuZWQgPSBjb21wb25lbnRzW2kgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBjb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHBhdGhDb21wb25lbnRzLnB1c2gobmV3IFBhdGhDb21wb25lbnRfMS5QYXRoQ29tcG9uZW50KHsgaW5kZXg6IHBhdGgsIGhhcmRlbmVkOiBpc0hhcmRlbmVkIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGhDb21wb25lbnRzLnB1c2gobmV3IFBhdGhDb21wb25lbnRfMS5QYXRoQ29tcG9uZW50KHsgaGFyZGVuZWQ6IGlzSGFyZGVuZWQgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IF9zb3VyY2VGaW5nZXJwcmludCA9IG1hcFtLZXlzLnNvdXJjZV9maW5nZXJwcmludF07XG4gICAgbGV0IHNvdXJjZUZpbmdlcnByaW50O1xuICAgIGlmIChfc291cmNlRmluZ2VycHJpbnQpIHtcbiAgICAgICAgc291cmNlRmluZ2VycHJpbnQgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgICAgIHNvdXJjZUZpbmdlcnByaW50LndyaXRlVUludDMyQkUoX3NvdXJjZUZpbmdlcnByaW50LCAwKTtcbiAgICB9XG4gICAgY29uc3QgZGVwdGggPSBtYXBbS2V5cy5kZXB0aF07XG4gICAgcmV0dXJuIG5ldyBDcnlwdG9LZXlwYXRoKHBhdGhDb21wb25lbnRzLCBzb3VyY2VGaW5nZXJwcmludCwgZGVwdGgpO1xufTtcbkNyeXB0b0tleXBhdGguZnJvbUNCT1IgPSAoX2Nib3JQYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgZGF0YUl0ZW0gPSAoMCwgbGliXzEuZGVjb2RlVG9EYXRhSXRlbSkoX2Nib3JQYXlsb2FkKTtcbiAgICByZXR1cm4gQ3J5cHRvS2V5cGF0aC5mcm9tRGF0YUl0ZW0oZGF0YUl0ZW0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNyeXB0b0tleXBhdGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNyeXB0b091dHB1dCA9IHZvaWQgMDtcbmNvbnN0IENyeXB0b0VDS2V5XzEgPSByZXF1aXJlKFwiLi9DcnlwdG9FQ0tleVwiKTtcbmNvbnN0IENyeXB0b0hES2V5XzEgPSByZXF1aXJlKFwiLi9DcnlwdG9IREtleVwiKTtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4vbGliXCIpO1xuY29uc3QgTXVsdGlLZXlfMSA9IHJlcXVpcmUoXCIuL011bHRpS2V5XCIpO1xuY29uc3QgUmVnaXN0cnlJdGVtXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeUl0ZW1cIik7XG5jb25zdCBSZWdpc3RyeVR5cGVfMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5VHlwZVwiKTtcbmNvbnN0IFNjcmlwdEV4cHJlc3Npb25fMSA9IHJlcXVpcmUoXCIuL1NjcmlwdEV4cHJlc3Npb25cIik7XG5jbGFzcyBDcnlwdG9PdXRwdXQgZXh0ZW5kcyBSZWdpc3RyeUl0ZW1fMS5SZWdpc3RyeUl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKHNjcmlwdEV4cHJlc3Npb25zLCBjcnlwdG9LZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zY3JpcHRFeHByZXNzaW9ucyA9IHNjcmlwdEV4cHJlc3Npb25zO1xuICAgICAgICB0aGlzLmNyeXB0b0tleSA9IGNyeXB0b0tleTtcbiAgICAgICAgdGhpcy5nZXRSZWdpc3RyeVR5cGUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fT1VUUFVUO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldENyeXB0b0tleSA9ICgpID0+IHRoaXMuY3J5cHRvS2V5O1xuICAgICAgICB0aGlzLmdldEhES2V5ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3J5cHRvS2V5IGluc3RhbmNlb2YgQ3J5cHRvSERLZXlfMS5DcnlwdG9IREtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyeXB0b0tleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0RUNLZXkgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jcnlwdG9LZXkgaW5zdGFuY2VvZiBDcnlwdG9FQ0tleV8xLkNyeXB0b0VDS2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3J5cHRvS2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRNdWx0aUtleSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNyeXB0b0tleSBpbnN0YW5jZW9mIE11bHRpS2V5XzEuTXVsdGlLZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcnlwdG9LZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFNjcmlwdEV4cHJlc3Npb25zID0gKCkgPT4gdGhpcy5zY3JpcHRFeHByZXNzaW9ucztcbiAgICAgICAgdGhpcy5fdG9PdXRwdXREZXNjcmlwdG9yID0gKHNlSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChzZUluZGV4ID49IHRoaXMuc2NyaXB0RXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3J5cHRvS2V5LmdldE91dHB1dERlc2NyaXB0b3JDb250ZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5zY3JpcHRFeHByZXNzaW9uc1tzZUluZGV4XS5nZXRFeHByZXNzaW9uKCl9KCR7dGhpcy5fdG9PdXRwdXREZXNjcmlwdG9yKHNlSW5kZXggKyAxKX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b1N0cmluZyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90b091dHB1dERlc2NyaXB0b3IoMCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudG9EYXRhSXRlbSA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCBkYXRhSXRlbSA9IHRoaXMuY3J5cHRvS2V5LnRvRGF0YUl0ZW0oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNyeXB0b0tleSBpbnN0YW5jZW9mIENyeXB0b0VDS2V5XzEuQ3J5cHRvRUNLZXkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNyeXB0b0tleSBpbnN0YW5jZW9mIENyeXB0b0hES2V5XzEuQ3J5cHRvSERLZXkpIHtcbiAgICAgICAgICAgICAgICBkYXRhSXRlbS5zZXRUYWcodGhpcy5jcnlwdG9LZXkuZ2V0UmVnaXN0cnlUeXBlKCkuZ2V0VGFnKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2xvbmVkU2UgPSBbLi4udGhpcy5zY3JpcHRFeHByZXNzaW9uc107XG4gICAgICAgICAgICBjbG9uZWRTZS5yZXZlcnNlKCkuZm9yRWFjaCgoc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWdWYWx1ZSA9IHNlLmdldFRhZygpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhSXRlbS5nZXRUYWcoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFJdGVtLnNldFRhZyh0YWdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbSA9IG5ldyBsaWJfMS5EYXRhSXRlbShkYXRhSXRlbSwgdGFnVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFJdGVtO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ3J5cHRvT3V0cHV0ID0gQ3J5cHRvT3V0cHV0O1xuQ3J5cHRvT3V0cHV0LmZyb21EYXRhSXRlbSA9IChkYXRhSXRlbSkgPT4ge1xuICAgIGNvbnN0IHNjcmlwdEV4cHJlc3Npb25zID0gW107XG4gICAgbGV0IF9kYXRhSXRlbSA9IGRhdGFJdGVtO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBfdGFnID0gX2RhdGFJdGVtLmdldFRhZygpO1xuICAgICAgICBjb25zdCBzZSA9IFNjcmlwdEV4cHJlc3Npb25fMS5TY3JpcHRFeHByZXNzaW9uLmZyb21UYWcoX3RhZyk7XG4gICAgICAgIGlmIChzZSkge1xuICAgICAgICAgICAgc2NyaXB0RXhwcmVzc2lvbnMucHVzaChzZSk7XG4gICAgICAgICAgICBpZiAoX2RhdGFJdGVtLmdldERhdGEoKSBpbnN0YW5jZW9mIGxpYl8xLkRhdGFJdGVtKSB7XG4gICAgICAgICAgICAgICAgX2RhdGFJdGVtID0gX2RhdGFJdGVtLmdldERhdGEoKTtcbiAgICAgICAgICAgICAgICBfdGFnID0gX2RhdGFJdGVtLmdldFRhZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzZUxlbmd0aCA9IHNjcmlwdEV4cHJlc3Npb25zLmxlbmd0aDtcbiAgICBjb25zdCBpc011bHRpS2V5ID0gc2VMZW5ndGggPiAwICYmXG4gICAgICAgIChzY3JpcHRFeHByZXNzaW9uc1tzZUxlbmd0aCAtIDFdLmdldEV4cHJlc3Npb24oKSA9PT1cbiAgICAgICAgICAgIFNjcmlwdEV4cHJlc3Npb25fMS5TY3JpcHRFeHByZXNzaW9ucy5NVUxUSVNJRy5nZXRFeHByZXNzaW9uKCkgfHxcbiAgICAgICAgICAgIHNjcmlwdEV4cHJlc3Npb25zW3NlTGVuZ3RoIC0gMV0uZ2V0RXhwcmVzc2lvbigpID09PVxuICAgICAgICAgICAgICAgIFNjcmlwdEV4cHJlc3Npb25fMS5TY3JpcHRFeHByZXNzaW9ucy5TT1JURURfTVVMVElTSUcuZ2V0RXhwcmVzc2lvbigpKTtcbiAgICBpZiAoaXNNdWx0aUtleSkge1xuICAgICAgICBjb25zdCBtdWx0aUtleSA9IE11bHRpS2V5XzEuTXVsdGlLZXkuZnJvbURhdGFJdGVtKF9kYXRhSXRlbSk7XG4gICAgICAgIHJldHVybiBuZXcgQ3J5cHRvT3V0cHV0KHNjcmlwdEV4cHJlc3Npb25zLCBtdWx0aUtleSk7XG4gICAgfVxuICAgIGlmIChfZGF0YUl0ZW0uZ2V0VGFnKCkgPT09IFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX0hES0VZLmdldFRhZygpKSB7XG4gICAgICAgIGNvbnN0IGNyeXB0b0hES2V5ID0gQ3J5cHRvSERLZXlfMS5DcnlwdG9IREtleS5mcm9tRGF0YUl0ZW0oX2RhdGFJdGVtKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDcnlwdG9PdXRwdXQoc2NyaXB0RXhwcmVzc2lvbnMsIGNyeXB0b0hES2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGNyeXB0b0VDS2V5ID0gQ3J5cHRvRUNLZXlfMS5DcnlwdG9FQ0tleS5mcm9tRGF0YUl0ZW0oX2RhdGFJdGVtKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDcnlwdG9PdXRwdXQoc2NyaXB0RXhwcmVzc2lvbnMsIGNyeXB0b0VDS2V5KTtcbiAgICB9XG59O1xuQ3J5cHRvT3V0cHV0LmZyb21DQk9SID0gKF9jYm9yUGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IGRhdGFJdGVtID0gKDAsIGxpYl8xLmRlY29kZVRvRGF0YUl0ZW0pKF9jYm9yUGF5bG9hZCk7XG4gICAgcmV0dXJuIENyeXB0b091dHB1dC5mcm9tRGF0YUl0ZW0oZGF0YUl0ZW0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNyeXB0b091dHB1dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ3J5cHRvUFNCVCA9IHZvaWQgMDtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4vbGliXCIpO1xuY29uc3QgUmVnaXN0cnlJdGVtXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeUl0ZW1cIik7XG5jb25zdCBSZWdpc3RyeVR5cGVfMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5VHlwZVwiKTtcbmNsYXNzIENyeXB0b1BTQlQgZXh0ZW5kcyBSZWdpc3RyeUl0ZW1fMS5SZWdpc3RyeUl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKHBzYnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wc2J0ID0gcHNidDtcbiAgICAgICAgdGhpcy5nZXRSZWdpc3RyeVR5cGUgPSAoKSA9PiBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19QU0JUO1xuICAgICAgICB0aGlzLmdldFBTQlQgPSAoKSA9PiB0aGlzLnBzYnQ7XG4gICAgICAgIHRoaXMudG9EYXRhSXRlbSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbGliXzEuRGF0YUl0ZW0odGhpcy5wc2J0KTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkNyeXB0b1BTQlQgPSBDcnlwdG9QU0JUO1xuQ3J5cHRvUFNCVC5mcm9tRGF0YUl0ZW0gPSAoZGF0YUl0ZW0pID0+IHtcbiAgICBjb25zdCBwc2J0ID0gZGF0YUl0ZW0uZ2V0RGF0YSgpO1xuICAgIGlmICghcHNidCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCNbdXItcmVnaXN0cnldW0NyeXB0b1BTQlRdW2ZuLmZyb21EYXRhSXRlbV06IGRlY29kZWQgW2RhdGFJdGVtXVsjZGF0YV0gaXMgdW5kZWZpbmVkOiAke2RhdGFJdGVtfWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IENyeXB0b1BTQlQocHNidCk7XG59O1xuQ3J5cHRvUFNCVC5mcm9tQ0JPUiA9IChfY2JvclBheWxvYWQpID0+IHtcbiAgICBjb25zdCBkYXRhSXRlbSA9ICgwLCBsaWJfMS5kZWNvZGVUb0RhdGFJdGVtKShfY2JvclBheWxvYWQpO1xuICAgIHJldHVybiBDcnlwdG9QU0JULmZyb21EYXRhSXRlbShkYXRhSXRlbSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3J5cHRvUFNCVC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVVJSZWdpc3RyeURlY29kZXIgPSB2b2lkIDA7XG5jb25zdCBiY191cl8xID0gcmVxdWlyZShcIkBuZ3JhdmVpby9iYy11clwiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLlwiKTtcbmNvbnN0IFJlZ2lzdHJ5VHlwZV8xID0gcmVxdWlyZShcIi4uL1JlZ2lzdHJ5VHlwZVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNsYXNzIFVSUmVnaXN0cnlEZWNvZGVyIGV4dGVuZHMgYmNfdXJfMS5VUkRlY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnJlc3VsdFJlZ2lzdHJ5VHlwZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVyID0gdGhpcy5yZXN1bHRVUigpO1xuICAgICAgICAgICAgc3dpdGNoICh1ci50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkJZVEVTLmdldFR5cGUoKTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fMS5CeXRlcy5mcm9tQ0JPUih1ci5jYm9yKTtcbiAgICAgICAgICAgICAgICBjYXNlIFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX0hES0VZLmdldFR5cGUoKTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fMS5DcnlwdG9IREtleS5mcm9tQ0JPUih1ci5jYm9yKTtcbiAgICAgICAgICAgICAgICBjYXNlIFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX0tFWVBBVEguZ2V0VHlwZSgpOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18xLkNyeXB0b0tleXBhdGguZnJvbUNCT1IodXIuY2Jvcik7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19DT0lOX0lORk8uZ2V0VHlwZSgpOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18xLkNyeXB0b0NvaW5JbmZvLmZyb21DQk9SKHVyLmNib3IpO1xuICAgICAgICAgICAgICAgIGNhc2UgUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fRUNLRVkuZ2V0VHlwZSgpOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18xLkNyeXB0b0VDS2V5LmZyb21DQk9SKHVyLmNib3IpO1xuICAgICAgICAgICAgICAgIGNhc2UgUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fT1VUUFVULmdldFR5cGUoKTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fMS5DcnlwdG9PdXRwdXQuZnJvbUNCT1IodXIuY2Jvcik7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19QU0JULmdldFR5cGUoKTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fMS5DcnlwdG9QU0JULmZyb21DQk9SKHVyLmNib3IpO1xuICAgICAgICAgICAgICAgIGNhc2UgUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcy5DUllQVE9fQUNDT1VOVC5nZXRUeXBlKCk6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfXzEuQ3J5cHRvQWNjb3VudC5mcm9tQ0JPUih1ci5jYm9yKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5rbm93blVSVHlwZUVycm9yKGAjW3VyLXJlZ2lzdHJ5XVtEZWNvZGVyXVtmbi5yZXN1bHRSZWdpc3RyeVR5cGVdOiByZWdpc3RyeSB0eXBlICR7dXIudHlwZX0gaXMgbm90IHN1cHBvcnRlZCBub3dgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlVSUmVnaXN0cnlEZWNvZGVyID0gVVJSZWdpc3RyeURlY29kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTXVsdGlLZXkgPSB2b2lkIDA7XG5jb25zdCBDcnlwdG9FQ0tleV8xID0gcmVxdWlyZShcIi4vQ3J5cHRvRUNLZXlcIik7XG5jb25zdCBDcnlwdG9IREtleV8xID0gcmVxdWlyZShcIi4vQ3J5cHRvSERLZXlcIik7XG5jb25zdCBEYXRhSXRlbV8xID0gcmVxdWlyZShcIi4vbGliL0RhdGFJdGVtXCIpO1xuY29uc3QgUmVnaXN0cnlJdGVtXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeUl0ZW1cIik7XG5jb25zdCBSZWdpc3RyeVR5cGVfMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5VHlwZVwiKTtcbnZhciBLZXlzO1xuKGZ1bmN0aW9uIChLZXlzKSB7XG4gICAgS2V5c1tLZXlzW1widGhyZXNob2xkXCJdID0gMV0gPSBcInRocmVzaG9sZFwiO1xuICAgIEtleXNbS2V5c1tcImtleXNcIl0gPSAyXSA9IFwia2V5c1wiO1xufSkoS2V5cyB8fCAoS2V5cyA9IHt9KSk7XG5jbGFzcyBNdWx0aUtleSBleHRlbmRzIFJlZ2lzdHJ5SXRlbV8xLlJlZ2lzdHJ5SXRlbSB7XG4gICAgY29uc3RydWN0b3IodGhyZXNob2xkLCBrZXlzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGhyZXNob2xkID0gdGhyZXNob2xkO1xuICAgICAgICB0aGlzLmtleXMgPSBrZXlzO1xuICAgICAgICB0aGlzLmdldFRocmVzaG9sZCA9ICgpID0+IHRoaXMudGhyZXNob2xkO1xuICAgICAgICB0aGlzLmdldEtleXMgPSAoKSA9PiB0aGlzLmtleXM7XG4gICAgICAgIHRoaXMudG9EYXRhSXRlbSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgICAgICAgICAgbWFwW0tleXMudGhyZXNob2xkXSA9IHRoaXMudGhyZXNob2xkO1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMua2V5cy5tYXAoKGspID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhSXRlbSA9IGsudG9EYXRhSXRlbSgpO1xuICAgICAgICAgICAgICAgIGRhdGFJdGVtLnNldFRhZyhrLmdldFJlZ2lzdHJ5VHlwZSgpLmdldFRhZygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YUl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1hcFtLZXlzLmtleXNdID0ga2V5cztcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0YUl0ZW1fMS5EYXRhSXRlbShtYXApO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE91dHB1dERlc2NyaXB0b3JDb250ZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLmdldFRocmVzaG9sZCgpLFxuICAgICAgICAgICAgICAgIHRoaXMua2V5cy5tYXAoayA9PiBrLmdldE91dHB1dERlc2NyaXB0b3JDb250ZW50KCkpLmpvaW4oJywnKSxcbiAgICAgICAgICAgIF0uam9pbignLCcpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTXVsdGlLZXkgPSBNdWx0aUtleTtcbk11bHRpS2V5LmZyb21EYXRhSXRlbSA9IChkYXRhSXRlbSkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IGRhdGFJdGVtLmdldERhdGEoKTtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSBtYXBbS2V5cy50aHJlc2hvbGRdO1xuICAgIGNvbnN0IF9rZXlzID0gbWFwW0tleXMua2V5c107XG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIF9rZXlzLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgaWYgKGsuZ2V0VGFnKCkgPT09IFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX0hES0VZLmdldFRhZygpKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goQ3J5cHRvSERLZXlfMS5DcnlwdG9IREtleS5mcm9tRGF0YUl0ZW0oaykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGsuZ2V0VGFnKCkgPT09IFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX0VDS0VZLmdldFRhZygpKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goQ3J5cHRvRUNLZXlfMS5DcnlwdG9FQ0tleS5mcm9tRGF0YUl0ZW0oaykpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBNdWx0aUtleSh0aHJlc2hvbGQsIGtleXMpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU11bHRpS2V5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXRoQ29tcG9uZW50ID0gdm9pZCAwO1xuY2xhc3MgUGF0aENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoYXJncykge1xuICAgICAgICB0aGlzLmdldEluZGV4ID0gKCkgPT4gdGhpcy5pbmRleDtcbiAgICAgICAgdGhpcy5pc1dpbGRjYXJkID0gKCkgPT4gdGhpcy53aWxkY2FyZDtcbiAgICAgICAgdGhpcy5pc0hhcmRlbmVkID0gKCkgPT4gdGhpcy5oYXJkZW5lZDtcbiAgICAgICAgdGhpcy5pbmRleCA9IGFyZ3MuaW5kZXg7XG4gICAgICAgIHRoaXMuaGFyZGVuZWQgPSBhcmdzLmhhcmRlbmVkO1xuICAgICAgICBpZiAodGhpcy5pbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLndpbGRjYXJkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndpbGRjYXJkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmRleCAmJiAodGhpcy5pbmRleCAmIFBhdGhDb21wb25lbnQuSEFSREVORURfQklUKSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAjW3VyLXJlZ2lzdHJ5XVtQYXRoQ29tcG9uZW50XVtmbi5jb25zdHJ1Y3Rvcl06IEludmFsaWQgaW5kZXggJHt0aGlzLmluZGV4fSAtIG1vc3Qgc2lnbmlmaWNhbnQgYml0IGNhbm5vdCBiZSBzZXRgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUGF0aENvbXBvbmVudCA9IFBhdGhDb21wb25lbnQ7XG5QYXRoQ29tcG9uZW50LkhBUkRFTkVEX0JJVCA9IDB4ODAwMDAwMDA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYXRoQ29tcG9uZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZWdpc3RyeUl0ZW0gPSB2b2lkIDA7XG5jb25zdCBiY191cl8xID0gcmVxdWlyZShcIkBuZ3JhdmVpby9iYy11clwiKTtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4vbGliXCIpO1xuY2xhc3MgUmVnaXN0cnlJdGVtIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50b0NCT1IgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy50b0RhdGFJdGVtKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgI1t1ci1yZWdpc3RyeV1bUmVnaXN0cnlJdGVtXVtmbi50b0NCT1JdOiByZWdpc3RyeSAke3RoaXMuZ2V0UmVnaXN0cnlUeXBlKCl9J3MgbWV0aG9kIHRvRGF0YUl0ZW0gcmV0dXJucyB1bmRlZmluZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgbGliXzEuZW5jb2RlRGF0YUl0ZW0pKHRoaXMudG9EYXRhSXRlbSgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b1VSID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBiY191cl8xLlVSKHRoaXMudG9DQk9SKCksIHRoaXMuZ2V0UmVnaXN0cnlUeXBlKCkuZ2V0VHlwZSgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b1VSRW5jb2RlciA9IChtYXhGcmFnbWVudExlbmd0aCwgZmlyc3RTZXFOdW0sIG1pbkZyYWdtZW50TGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1ciA9IHRoaXMudG9VUigpO1xuICAgICAgICAgICAgY29uc3QgdXJFbmNvZGVyID0gbmV3IGJjX3VyXzEuVVJFbmNvZGVyKHVyLCBtYXhGcmFnbWVudExlbmd0aCwgZmlyc3RTZXFOdW0sIG1pbkZyYWdtZW50TGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiB1ckVuY29kZXI7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5SZWdpc3RyeUl0ZW0gPSBSZWdpc3RyeUl0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWdpc3RyeUl0ZW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlZ2lzdHJ5VHlwZXMgPSBleHBvcnRzLlJlZ2lzdHJ5VHlwZSA9IHZvaWQgMDtcbmNsYXNzIFJlZ2lzdHJ5VHlwZSB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgdGFnKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLmdldFRhZyA9ICgpID0+IHRoaXMudGFnO1xuICAgICAgICB0aGlzLmdldFR5cGUgPSAoKSA9PiB0aGlzLnR5cGU7XG4gICAgfVxufVxuZXhwb3J0cy5SZWdpc3RyeVR5cGUgPSBSZWdpc3RyeVR5cGU7XG5leHBvcnRzLlJlZ2lzdHJ5VHlwZXMgPSB7XG4gICAgVVVJRDogbmV3IFJlZ2lzdHJ5VHlwZSgndXVpZCcsIDM3KSxcbiAgICBCWVRFUzogbmV3IFJlZ2lzdHJ5VHlwZSgnYnl0ZXMnLCB1bmRlZmluZWQpLFxuICAgIENSWVBUT19IREtFWTogbmV3IFJlZ2lzdHJ5VHlwZSgnY3J5cHRvLWhka2V5JywgMzAzKSxcbiAgICBDUllQVE9fS0VZUEFUSDogbmV3IFJlZ2lzdHJ5VHlwZSgnY3J5cHRvLWtleXBhdGgnLCAzMDQpLFxuICAgIENSWVBUT19DT0lOX0lORk86IG5ldyBSZWdpc3RyeVR5cGUoJ2NyeXB0by1jb2luLWluZm8nLCAzMDUpLFxuICAgIENSWVBUT19FQ0tFWTogbmV3IFJlZ2lzdHJ5VHlwZSgnY3J5cHRvLWVja2V5JywgMzA2KSxcbiAgICBDUllQVE9fT1VUUFVUOiBuZXcgUmVnaXN0cnlUeXBlKCdjcnlwdG8tb3V0cHV0JywgMzA4KSxcbiAgICBDUllQVE9fUFNCVDogbmV3IFJlZ2lzdHJ5VHlwZSgnY3J5cHRvLXBzYnQnLCAzMTApLFxuICAgIENSWVBUT19BQ0NPVU5UOiBuZXcgUmVnaXN0cnlUeXBlKCdjcnlwdG8tYWNjb3VudCcsIDMxMSksXG4gICAgQ1JZUFRPX01VTFRJX0FDQ09VTlRTOiBuZXcgUmVnaXN0cnlUeXBlKFwiY3J5cHRvLW11bHRpLWFjY291bnRzXCIsIDExMDMpLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlZ2lzdHJ5VHlwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2NyaXB0RXhwcmVzc2lvbnMgPSBleHBvcnRzLlNjcmlwdEV4cHJlc3Npb24gPSB2b2lkIDA7XG5jbGFzcyBTY3JpcHRFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWcsIGV4cHJlc3Npb24pIHtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgIHRoaXMuZ2V0VGFnID0gKCkgPT4gdGhpcy50YWc7XG4gICAgICAgIHRoaXMuZ2V0RXhwcmVzc2lvbiA9ICgpID0+IHRoaXMuZXhwcmVzc2lvbjtcbiAgICB9XG59XG5leHBvcnRzLlNjcmlwdEV4cHJlc3Npb24gPSBTY3JpcHRFeHByZXNzaW9uO1xuU2NyaXB0RXhwcmVzc2lvbi5mcm9tVGFnID0gKHRhZykgPT4ge1xuICAgIGNvbnN0IHNlID0gT2JqZWN0LnZhbHVlcyhleHBvcnRzLlNjcmlwdEV4cHJlc3Npb25zKS5maW5kKChzZSkgPT4gc2UuZ2V0VGFnKCkgPT09IHRhZyk7XG4gICAgcmV0dXJuIHNlO1xufTtcbmV4cG9ydHMuU2NyaXB0RXhwcmVzc2lvbnMgPSB7XG4gICAgU0NSSVBUX0hBU0g6IG5ldyBTY3JpcHRFeHByZXNzaW9uKDQwMCwgJ3NoJyksXG4gICAgV0lUTkVTU19TQ1JJUFRfSEFTSDogbmV3IFNjcmlwdEV4cHJlc3Npb24oNDAxLCAnd3NoJyksXG4gICAgUFVCTElDX0tFWTogbmV3IFNjcmlwdEV4cHJlc3Npb24oNDAyLCAncGsnKSxcbiAgICBQVUJMSUNfS0VZX0hBU0g6IG5ldyBTY3JpcHRFeHByZXNzaW9uKDQwMywgJ3BraCcpLFxuICAgIFdJVE5FU1NfUFVCTElDX0tFWV9IQVNIOiBuZXcgU2NyaXB0RXhwcmVzc2lvbig0MDQsICd3cGtoJyksXG4gICAgQ09NQk86IG5ldyBTY3JpcHRFeHByZXNzaW9uKDQwNSwgJ2NvbWJvJyksXG4gICAgTVVMVElTSUc6IG5ldyBTY3JpcHRFeHByZXNzaW9uKDQwNiwgJ211bHRpJyksXG4gICAgU09SVEVEX01VTFRJU0lHOiBuZXcgU2NyaXB0RXhwcmVzc2lvbig0MDcsICdzb3J0ZWRtdWx0aScpLFxuICAgIEFERFJFU1M6IG5ldyBTY3JpcHRFeHByZXNzaW9uKDMwNywgJ2FkZHInKSxcbiAgICBSQVdfU0NSSVBUOiBuZXcgU2NyaXB0RXhwcmVzc2lvbig0MDgsICdyYXcnKSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TY3JpcHRFeHByZXNzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Vbmtub3duVVJUeXBlRXJyb3IgPSB2b2lkIDA7XG5jbGFzcyBVbmtub3duVVJUeXBlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnRzLlVua25vd25VUlR5cGVFcnJvciA9IFVua25vd25VUlR5cGVFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DcnlwdG9NdWx0aUFjY291bnRzID0gdm9pZCAwO1xuY29uc3QgUmVnaXN0cnlUeXBlXzEgPSByZXF1aXJlKFwiLi4vUmVnaXN0cnlUeXBlXCIpO1xuY29uc3QgQ3J5cHRvSERLZXlfMSA9IHJlcXVpcmUoXCIuLi9DcnlwdG9IREtleVwiKTtcbmNvbnN0IFJlZ2lzdHJ5SXRlbV8xID0gcmVxdWlyZShcIi4uL1JlZ2lzdHJ5SXRlbVwiKTtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4uL2xpYlwiKTtcbnZhciBLZXlzO1xuKGZ1bmN0aW9uIChLZXlzKSB7XG4gICAgS2V5c1tLZXlzW1wibWFzdGVyRmluZ2VycHJpbnRcIl0gPSAxXSA9IFwibWFzdGVyRmluZ2VycHJpbnRcIjtcbiAgICBLZXlzW0tleXNbXCJrZXlzXCJdID0gMl0gPSBcImtleXNcIjtcbiAgICBLZXlzW0tleXNbXCJkZXZpY2VcIl0gPSAzXSA9IFwiZGV2aWNlXCI7XG59KShLZXlzIHx8IChLZXlzID0ge30pKTtcbmNsYXNzIENyeXB0b011bHRpQWNjb3VudHMgZXh0ZW5kcyBSZWdpc3RyeUl0ZW1fMS5SZWdpc3RyeUl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKG1hc3RlckZpbmdlcnByaW50LCBrZXlzLCBkZXZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tYXN0ZXJGaW5nZXJwcmludCA9IG1hc3RlckZpbmdlcnByaW50O1xuICAgICAgICB0aGlzLmtleXMgPSBrZXlzO1xuICAgICAgICB0aGlzLmRldmljZSA9IGRldmljZTtcbiAgICAgICAgdGhpcy5nZXRSZWdpc3RyeVR5cGUgPSAoKSA9PiBSZWdpc3RyeVR5cGVfMS5SZWdpc3RyeVR5cGVzLkNSWVBUT19NVUxUSV9BQ0NPVU5UUztcbiAgICAgICAgdGhpcy5nZXRNYXN0ZXJGaW5nZXJwcmludCA9ICgpID0+IHRoaXMubWFzdGVyRmluZ2VycHJpbnQ7XG4gICAgICAgIHRoaXMuZ2V0S2V5cyA9ICgpID0+IHRoaXMua2V5cztcbiAgICAgICAgdGhpcy5nZXREZXZpY2UgPSAoKSA9PiB0aGlzLmRldmljZTtcbiAgICAgICAgdGhpcy50b0RhdGFJdGVtID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWFwID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5tYXN0ZXJGaW5nZXJwcmludCkge1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLm1hc3RlckZpbmdlcnByaW50XSA9IHRoaXMubWFzdGVyRmluZ2VycHJpbnQucmVhZFVJbnQzMkJFKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMua2V5cykge1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLmtleXNdID0gdGhpcy5rZXlzLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhSXRlbSA9IGl0ZW0udG9EYXRhSXRlbSgpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbS5zZXRUYWcoaXRlbS5nZXRSZWdpc3RyeVR5cGUoKS5nZXRUYWcoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhSXRlbTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRldmljZSkge1xuICAgICAgICAgICAgICAgIG1hcFtLZXlzLmRldmljZV0gPSB0aGlzLmRldmljZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgbGliXzEuRGF0YUl0ZW0obWFwKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkNyeXB0b011bHRpQWNjb3VudHMgPSBDcnlwdG9NdWx0aUFjY291bnRzO1xuQ3J5cHRvTXVsdGlBY2NvdW50cy5mcm9tRGF0YUl0ZW0gPSAoZGF0YUl0ZW0pID0+IHtcbiAgICBjb25zdCBtYXAgPSBkYXRhSXRlbS5nZXREYXRhKCk7XG4gICAgY29uc3QgbWFzdGVyRmluZ2VycHJpbnQgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgY29uc3QgX21hc3RlckZpbmdlcnByaW50ID0gbWFwW0tleXMubWFzdGVyRmluZ2VycHJpbnRdO1xuICAgIGlmIChfbWFzdGVyRmluZ2VycHJpbnQpIHtcbiAgICAgICAgbWFzdGVyRmluZ2VycHJpbnQud3JpdGVVSW50MzJCRShfbWFzdGVyRmluZ2VycHJpbnQsIDApO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gbWFwW0tleXMua2V5c107XG4gICAgY29uc3QgY3J5cHRvSERLZXlzID0ga2V5cy5tYXAoKGl0ZW0pID0+IENyeXB0b0hES2V5XzEuQ3J5cHRvSERLZXkuZnJvbURhdGFJdGVtKGl0ZW0pKTtcbiAgICBjb25zdCBkZXZpY2UgPSBtYXBbS2V5cy5kZXZpY2VdO1xuICAgIHJldHVybiBuZXcgQ3J5cHRvTXVsdGlBY2NvdW50cyhtYXN0ZXJGaW5nZXJwcmludCwgY3J5cHRvSERLZXlzLCBkZXZpY2UpO1xufTtcbkNyeXB0b011bHRpQWNjb3VudHMuZnJvbUNCT1IgPSAoX2Nib3JQYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgZGF0YUl0ZW0gPSAoMCwgbGliXzEuZGVjb2RlVG9EYXRhSXRlbSkoX2Nib3JQYXlsb2FkKTtcbiAgICByZXR1cm4gQ3J5cHRvTXVsdGlBY2NvdW50cy5mcm9tRGF0YUl0ZW0oZGF0YUl0ZW0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNyeXB0b011bHRpQWNjb3VudHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJ1ZmZlciA9IGV4cG9ydHMuZXh0ZW5kID0gZXhwb3J0cy5QYXRoQ29tcG9uZW50ID0gZXhwb3J0cy5TY3JpcHRFeHByZXNzaW9ucyA9IGV4cG9ydHMuTXVsdGlLZXkgPSBleHBvcnRzLkNyeXB0b1BTQlQgPSBleHBvcnRzLkNyeXB0b091dHB1dCA9IGV4cG9ydHMuQ3J5cHRvRUNLZXkgPSBleHBvcnRzLkNyeXB0b0NvaW5JbmZvTmV0d29yayA9IGV4cG9ydHMuQ3J5cHRvQ29pbkluZm9UeXBlID0gZXhwb3J0cy5DcnlwdG9Db2luSW5mbyA9IGV4cG9ydHMuQ3J5cHRvS2V5cGF0aCA9IGV4cG9ydHMuQ3J5cHRvTXVsdGlBY2NvdW50cyA9IGV4cG9ydHMuQ3J5cHRvSERLZXkgPSBleHBvcnRzLkNyeXB0b0FjY291bnQgPSBleHBvcnRzLkJ5dGVzID0gZXhwb3J0cy5VUlJlZ2lzdHJ5RGVjb2RlciA9IGV4cG9ydHMuRGF0YUl0ZW0gPSB2b2lkIDA7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xucmVxdWlyZShcIi4vcGF0Y2hDQk9SXCIpO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJ1ZmZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVmZmVyXzEuQnVmZmVyOyB9IH0pO1xuY29uc3QgQ3J5cHRvSERLZXlfMSA9IHJlcXVpcmUoXCIuL0NyeXB0b0hES2V5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ3J5cHRvSERLZXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENyeXB0b0hES2V5XzEuQ3J5cHRvSERLZXk7IH0gfSk7XG5jb25zdCBDcnlwdG9LZXlwYXRoXzEgPSByZXF1aXJlKFwiLi9DcnlwdG9LZXlwYXRoXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ3J5cHRvS2V5cGF0aFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ3J5cHRvS2V5cGF0aF8xLkNyeXB0b0tleXBhdGg7IH0gfSk7XG5jb25zdCBDcnlwdG9Db2luSW5mb18xID0gcmVxdWlyZShcIi4vQ3J5cHRvQ29pbkluZm9cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDcnlwdG9Db2luSW5mb1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ3J5cHRvQ29pbkluZm9fMS5DcnlwdG9Db2luSW5mbzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNyeXB0b0NvaW5JbmZvVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ3J5cHRvQ29pbkluZm9fMS5UeXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ3J5cHRvQ29pbkluZm9OZXR3b3JrXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDcnlwdG9Db2luSW5mb18xLk5ldHdvcms7IH0gfSk7XG5jb25zdCBDcnlwdG9FQ0tleV8xID0gcmVxdWlyZShcIi4vQ3J5cHRvRUNLZXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDcnlwdG9FQ0tleVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ3J5cHRvRUNLZXlfMS5DcnlwdG9FQ0tleTsgfSB9KTtcbmNvbnN0IEJ5dGVzXzEgPSByZXF1aXJlKFwiLi9CeXRlc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJ5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBCeXRlc18xLkJ5dGVzOyB9IH0pO1xuY29uc3QgQ3J5cHRvT3V0cHV0XzEgPSByZXF1aXJlKFwiLi9DcnlwdG9PdXRwdXRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDcnlwdG9PdXRwdXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENyeXB0b091dHB1dF8xLkNyeXB0b091dHB1dDsgfSB9KTtcbmNvbnN0IENyeXB0b1BTQlRfMSA9IHJlcXVpcmUoXCIuL0NyeXB0b1BTQlRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDcnlwdG9QU0JUXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDcnlwdG9QU0JUXzEuQ3J5cHRvUFNCVDsgfSB9KTtcbmNvbnN0IENyeXB0b0FjY291bnRfMSA9IHJlcXVpcmUoXCIuL0NyeXB0b0FjY291bnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDcnlwdG9BY2NvdW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDcnlwdG9BY2NvdW50XzEuQ3J5cHRvQWNjb3VudDsgfSB9KTtcbmNvbnN0IERlY29kZXJfMSA9IHJlcXVpcmUoXCIuL0RlY29kZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVUlJlZ2lzdHJ5RGVjb2RlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRGVjb2Rlcl8xLlVSUmVnaXN0cnlEZWNvZGVyOyB9IH0pO1xuY29uc3QgTXVsdGlLZXlfMSA9IHJlcXVpcmUoXCIuL011bHRpS2V5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTXVsdGlLZXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE11bHRpS2V5XzEuTXVsdGlLZXk7IH0gfSk7XG5jb25zdCBTY3JpcHRFeHByZXNzaW9uXzEgPSByZXF1aXJlKFwiLi9TY3JpcHRFeHByZXNzaW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2NyaXB0RXhwcmVzc2lvbnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFNjcmlwdEV4cHJlc3Npb25fMS5TY3JpcHRFeHByZXNzaW9uczsgfSB9KTtcbmNvbnN0IFBhdGhDb21wb25lbnRfMSA9IHJlcXVpcmUoXCIuL1BhdGhDb21wb25lbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXRoQ29tcG9uZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQYXRoQ29tcG9uZW50XzEuUGF0aENvbXBvbmVudDsgfSB9KTtcbmNvbnN0IFJlZ2lzdHJ5SXRlbV8xID0gcmVxdWlyZShcIi4vUmVnaXN0cnlJdGVtXCIpO1xuY29uc3QgUmVnaXN0cnlUeXBlXzEgPSByZXF1aXJlKFwiLi9SZWdpc3RyeVR5cGVcIik7XG5jb25zdCBsaWJfMSA9IHJlcXVpcmUoXCIuL2xpYlwiKTtcbnZhciBsaWJfMiA9IHJlcXVpcmUoXCIuL2xpYlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRhdGFJdGVtXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWJfMi5EYXRhSXRlbTsgfSB9KTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IENyeXB0b011bHRpQWNjb3VudHNfMSA9IHJlcXVpcmUoXCIuL2V4dGVuZGVkL0NyeXB0b011bHRpQWNjb3VudHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDcnlwdG9NdWx0aUFjY291bnRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDcnlwdG9NdWx0aUFjY291bnRzXzEuQ3J5cHRvTXVsdGlBY2NvdW50czsgfSB9KTtcbmNvbnN0IFVSbGliID0ge1xuICAgIFVSUmVnaXN0cnlEZWNvZGVyOiBEZWNvZGVyXzEuVVJSZWdpc3RyeURlY29kZXIsXG4gICAgQnl0ZXM6IEJ5dGVzXzEuQnl0ZXMsXG4gICAgQ3J5cHRvQWNjb3VudDogQ3J5cHRvQWNjb3VudF8xLkNyeXB0b0FjY291bnQsXG4gICAgQ3J5cHRvSERLZXk6IENyeXB0b0hES2V5XzEuQ3J5cHRvSERLZXksXG4gICAgQ3J5cHRvTXVsdGlBY2NvdW50czogQ3J5cHRvTXVsdGlBY2NvdW50c18xLkNyeXB0b011bHRpQWNjb3VudHMsXG4gICAgQ3J5cHRvS2V5cGF0aDogQ3J5cHRvS2V5cGF0aF8xLkNyeXB0b0tleXBhdGgsXG4gICAgQ3J5cHRvQ29pbkluZm86IENyeXB0b0NvaW5JbmZvXzEuQ3J5cHRvQ29pbkluZm8sXG4gICAgQ3J5cHRvQ29pbkluZm9UeXBlOiBDcnlwdG9Db2luSW5mb18xLlR5cGUsXG4gICAgQ3J5cHRvQ29pbkluZm9OZXR3b3JrOiBDcnlwdG9Db2luSW5mb18xLk5ldHdvcmssXG4gICAgQ3J5cHRvRUNLZXk6IENyeXB0b0VDS2V5XzEuQ3J5cHRvRUNLZXksXG4gICAgQ3J5cHRvT3V0cHV0OiBDcnlwdG9PdXRwdXRfMS5DcnlwdG9PdXRwdXQsXG4gICAgQ3J5cHRvUFNCVDogQ3J5cHRvUFNCVF8xLkNyeXB0b1BTQlQsXG4gICAgTXVsdGlLZXk6IE11bHRpS2V5XzEuTXVsdGlLZXksXG4gICAgU2NyaXB0RXhwcmVzc2lvbnM6IFNjcmlwdEV4cHJlc3Npb25fMS5TY3JpcHRFeHByZXNzaW9ucyxcbiAgICBQYXRoQ29tcG9uZW50OiBQYXRoQ29tcG9uZW50XzEuUGF0aENvbXBvbmVudCxcbn07XG5jb25zdCBjYm9yID0ge1xuICAgIGFkZFJlYWRlcjogbGliXzEuYWRkUmVhZGVyLFxuICAgIGFkZFNlbWFudGljRGVjb2RlOiBsaWJfMS5hZGRTZW1hbnRpY0RlY29kZSxcbiAgICBhZGRTZW1hbnRpY0VuY29kZTogbGliXzEuYWRkU2VtYW50aWNFbmNvZGUsXG4gICAgYWRkV3JpdGVyOiBsaWJfMS5hZGRXcml0ZXIsXG4gICAgcGF0Y2hUYWdzOiB1dGlsc18xLnBhdGNoVGFncyxcbn07XG5jb25zdCBleHRlbmQgPSB7XG4gICAgUmVnaXN0cnlUeXBlczogUmVnaXN0cnlUeXBlXzEuUmVnaXN0cnlUeXBlcyxcbiAgICBSZWdpc3RyeUl0ZW06IFJlZ2lzdHJ5SXRlbV8xLlJlZ2lzdHJ5SXRlbSxcbiAgICBSZWdpc3RyeVR5cGU6IFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZSxcbiAgICBkZWNvZGVUb0RhdGFJdGVtOiBsaWJfMS5kZWNvZGVUb0RhdGFJdGVtLFxuICAgIGVuY29kZURhdGFJdGVtOiBsaWJfMS5lbmNvZGVEYXRhSXRlbSxcbiAgICBjYm9yLFxufTtcbmV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9lcnJvcnNcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9EZWNvZGVyXCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vbGliXCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vQ3J5cHRvQWNjb3VudFwiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL0NyeXB0b1BTQlRcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9DcnlwdG9IREtleVwiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL2V4dGVuZGVkL0NyeXB0b011bHRpQWNjb3VudHNcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9DcnlwdG9PdXRwdXRcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9DcnlwdG9Db2luSW5mb1wiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL0NyeXB0b0VDS2V5XCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vTXVsdGlLZXlcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9DcnlwdG9LZXlwYXRoXCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vcGF0Y2hDQk9SXCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vUGF0aENvbXBvbmVudFwiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL1JlZ2lzdHJ5SXRlbVwiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL1JlZ2lzdHJ5VHlwZVwiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL3R5cGVzXCIpLCBleHBvcnRzKTtcbigwLCB0c2xpYl8xLl9fZXhwb3J0U3RhcikocmVxdWlyZShcIi4vdXRpbHNcIiksIGV4cG9ydHMpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVVJsaWI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGF0YUl0ZW0gPSB2b2lkIDA7XG5jbGFzcyBEYXRhSXRlbSB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgdGFnKSB7XG4gICAgICAgIHRoaXMuc2V0VGFnID0gKHRhZykgPT4ge1xuICAgICAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xlYXJUYWcgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRhZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRUYWcgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50YWc7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0RGF0YSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgIH1cbn1cbmV4cG9ydHMuRGF0YUl0ZW0gPSBEYXRhSXRlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURhdGFJdGVtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsLkNCT1IgPSBmYWN0b3J5KCk7XG4gICAgfVxufSkodGhpcywgZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHsgRGF0YUl0ZW0gfSA9IHJlcXVpcmUoJy4vRGF0YUl0ZW0nKTtcbiAgICB2YXIgQ0JPUiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEJpbmFyeUhleChoZXgpIHtcbiAgICAgICAgICAgIHRoaXMuJGhleCA9IGhleDtcbiAgICAgICAgfVxuICAgICAgICBCaW5hcnlIZXgucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGhleC5sZW5ndGggLyAyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3JtYXQgfHwgZm9ybWF0ID09PSAnaGV4JyB8fCBmb3JtYXQgPT09IDE2KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaGV4O1xuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICd1dGYtOCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuY29kZWQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiRoZXgubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZWQgKz0gJyUnICsgdGhpcy4kaGV4LnN1YnN0cmluZyhpLCBpICsgMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2xhdGluJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5jb2RlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJGhleC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZC5wdXNoKHBhcnNlSW50KHRoaXMuJGhleC5zdWJzdHJpbmcoaSwgaSArIDIpLCAxNikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgZW5jb2RlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pc2VkIGZvcm1hdDogJyArIGZvcm1hdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBCaW5hcnlIZXguZnJvbUxhdGluU3RyaW5nID0gZnVuY3Rpb24gKGxhdGluU3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgaGV4ID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGluU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhaXIgPSBsYXRpblN0cmluZy5jaGFyQ29kZUF0KGkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgICAgICBpZiAocGFpci5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHBhaXIgPSAnMCcgKyBwYWlyO1xuICAgICAgICAgICAgICAgIGhleCArPSBwYWlyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlIZXgoaGV4KTtcbiAgICAgICAgfTtcbiAgICAgICAgQmluYXJ5SGV4LmZyb21VdGY4U3RyaW5nID0gZnVuY3Rpb24gKHV0ZjhTdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBlbmNvZGVkID0gZW5jb2RlVVJJQ29tcG9uZW50KHV0ZjhTdHJpbmcpO1xuICAgICAgICAgICAgdmFyIGhleCA9ICcnO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kZWQuY2hhckF0KGkpID09PSAnJScpIHtcbiAgICAgICAgICAgICAgICAgICAgaGV4ICs9IGVuY29kZWQuc3Vic3RyaW5nKGkgKyAxLCBpICsgMyk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZXhQYWlyID0gZW5jb2RlZC5jaGFyQ29kZUF0KGkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhleFBhaXIubGVuZ3RoIDwgMilcbiAgICAgICAgICAgICAgICAgICAgICAgIGhleFBhaXIgPSAnMCcgKyBoZXhQYWlyO1xuICAgICAgICAgICAgICAgICAgICBoZXggKz0gaGV4UGFpcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUhleChoZXgpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgc2VtYW50aWNFbmNvZGVycyA9IFtdO1xuICAgICAgICB2YXIgc2VtYW50aWNEZWNvZGVycyA9IHt9O1xuICAgICAgICB2YXIgbm90SW1wbGVtZW50ZWQgPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGxhYmVsICsgJyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIFJlYWRlcigpIHsgfVxuICAgICAgICBSZWFkZXIucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgcGVla0J5dGU6IG5vdEltcGxlbWVudGVkKCdwZWVrQnl0ZScpLFxuICAgICAgICAgICAgcmVhZEJ5dGU6IG5vdEltcGxlbWVudGVkKCdyZWFkQnl0ZScpLFxuICAgICAgICAgICAgcmVhZENodW5rOiBub3RJbXBsZW1lbnRlZCgncmVhZENodW5rJyksXG4gICAgICAgICAgICByZWFkRmxvYXQxNjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBoYWxmID0gdGhpcy5yZWFkVWludDE2KCk7XG4gICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50ID0gKGhhbGYgJiAweDdmZmYpID4+IDEwO1xuICAgICAgICAgICAgICAgIHZhciBtYW50aXNzYSA9IGhhbGYgJiAweDNmZjtcbiAgICAgICAgICAgICAgICB2YXIgbmVnYXRpdmUgPSBoYWxmICYgMHg4MDAwO1xuICAgICAgICAgICAgICAgIGlmIChleHBvbmVudCA9PT0gMHgxZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFudGlzc2EgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZWdhdGl2ZSA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBtYWduaXR1ZGUgPSBleHBvbmVudFxuICAgICAgICAgICAgICAgICAgICA/IE1hdGgucG93KDIsIGV4cG9uZW50IC0gMjUpICogKDEwMjQgKyBtYW50aXNzYSlcbiAgICAgICAgICAgICAgICAgICAgOiBNYXRoLnBvdygyLCAtMjQpICogbWFudGlzc2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5lZ2F0aXZlID8gLW1hZ25pdHVkZSA6IG1hZ25pdHVkZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWFkRmxvYXQzMjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbnRWYWx1ZSA9IHRoaXMucmVhZFVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHZhciBleHBvbmVudCA9IChpbnRWYWx1ZSAmIDB4N2ZmZmZmZmYpID4+IDIzO1xuICAgICAgICAgICAgICAgIHZhciBtYW50aXNzYSA9IGludFZhbHVlICYgMHg3ZmZmZmY7XG4gICAgICAgICAgICAgICAgdmFyIG5lZ2F0aXZlID0gaW50VmFsdWUgJiAweDgwMDAwMDAwO1xuICAgICAgICAgICAgICAgIGlmIChleHBvbmVudCA9PT0gMHhmZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFudGlzc2EgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZWdhdGl2ZSA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBtYWduaXR1ZGUgPSBleHBvbmVudFxuICAgICAgICAgICAgICAgICAgICA/IE1hdGgucG93KDIsIGV4cG9uZW50IC0gMjMgLSAxMjcpICogKDgzODg2MDggKyBtYW50aXNzYSlcbiAgICAgICAgICAgICAgICAgICAgOiBNYXRoLnBvdygyLCAtMjMgLSAxMjYpICogbWFudGlzc2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5lZ2F0aXZlID8gLW1hZ25pdHVkZSA6IG1hZ25pdHVkZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWFkRmxvYXQ2NDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbnQxID0gdGhpcy5yZWFkVWludDMyKCksIGludDIgPSB0aGlzLnJlYWRVaW50MzIoKTtcbiAgICAgICAgICAgICAgICB2YXIgZXhwb25lbnQgPSAoaW50MSA+PiAyMCkgJiAweDdmZjtcbiAgICAgICAgICAgICAgICB2YXIgbWFudGlzc2EgPSAoaW50MSAmIDB4ZmZmZmYpICogNDI5NDk2NzI5NiArIGludDI7XG4gICAgICAgICAgICAgICAgdmFyIG5lZ2F0aXZlID0gaW50MSAmIDB4ODAwMDAwMDA7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50ID09PSAweDdmZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFudGlzc2EgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZWdhdGl2ZSA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBtYWduaXR1ZGUgPSBleHBvbmVudFxuICAgICAgICAgICAgICAgICAgICA/IE1hdGgucG93KDIsIGV4cG9uZW50IC0gNTIgLSAxMDIzKSAqICg0NTAzNTk5NjI3MzcwNDk2ICsgbWFudGlzc2EpXG4gICAgICAgICAgICAgICAgICAgIDogTWF0aC5wb3coMiwgLTUyIC0gMTAyMikgKiBtYW50aXNzYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmVnYXRpdmUgPyAtbWFnbml0dWRlIDogbWFnbml0dWRlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlYWRVaW50MTY6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkQnl0ZSgpICogMjU2ICsgdGhpcy5yZWFkQnl0ZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlYWRVaW50MzI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkVWludDE2KCkgKiA2NTUzNiArIHRoaXMucmVhZFVpbnQxNigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlYWRVaW50NjQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkVWludDMyKCkgKiA0Mjk0OTY3Mjk2ICsgdGhpcy5yZWFkVWludDMyKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBXcml0ZXIoKSB7IH1cbiAgICAgICAgV3JpdGVyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgIHdyaXRlQnl0ZTogbm90SW1wbGVtZW50ZWQoJ3dyaXRlQnl0ZScpLFxuICAgICAgICAgICAgcmVzdWx0OiBub3RJbXBsZW1lbnRlZCgncmVzdWx0JyksXG4gICAgICAgICAgICB3cml0ZUZsb2F0MTY6IG5vdEltcGxlbWVudGVkKCd3cml0ZUZsb2F0MTYnKSxcbiAgICAgICAgICAgIHdyaXRlRmxvYXQzMjogbm90SW1wbGVtZW50ZWQoJ3dyaXRlRmxvYXQzMicpLFxuICAgICAgICAgICAgd3JpdGVGbG9hdDY0OiBub3RJbXBsZW1lbnRlZCgnd3JpdGVGbG9hdDY0JyksXG4gICAgICAgICAgICB3cml0ZVVpbnQxNjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGUoKHZhbHVlID4+IDgpICYgMHhmZik7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGUodmFsdWUgJiAweGZmKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3cml0ZVVpbnQzMjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVVpbnQxNigodmFsdWUgPj4gMTYpICYgMHhmZmZmKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVWludDE2KHZhbHVlICYgMHhmZmZmKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3cml0ZVVpbnQ2NDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID49IDkwMDcxOTkyNTQ3NDA5OTIgfHwgdmFsdWUgPD0gLTkwMDcxOTkyNTQ3NDA5OTIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZW5jb2RlIFVpbnQ2NCBvZjogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIG1hZ25pdHVkZSB0byBiaWcgKGZsb2F0aW5nIHBvaW50IGVycm9ycyknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVVpbnQzMihNYXRoLmZsb29yKHZhbHVlIC8gNDI5NDk2NzI5NikpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVVaW50MzIodmFsdWUgJSA0Mjk0OTY3Mjk2KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3cml0ZVN0cmluZzogbm90SW1wbGVtZW50ZWQoJ3dyaXRlU3RyaW5nJyksXG4gICAgICAgICAgICBjYW5Xcml0ZUJpbmFyeTogZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdyaXRlQmluYXJ5OiBub3RJbXBsZW1lbnRlZCgnd3JpdGVDaHVuaycpLFxuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiByZWFkSGVhZGVyUmF3KHJlYWRlcikge1xuICAgICAgICAgICAgdmFyIGZpcnN0Qnl0ZSA9IHJlYWRlci5yZWFkQnl0ZSgpO1xuICAgICAgICAgICAgdmFyIG1ham9yVHlwZSA9IGZpcnN0Qnl0ZSA+PiA1LCB2YWx1ZSA9IGZpcnN0Qnl0ZSAmIDB4MWY7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBtYWpvclR5cGUsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlRnJvbUhlYWRlcihoZWFkZXIsIHJlYWRlcikge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gaGVhZGVyLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMjQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSAyNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZEJ5dGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09IDI1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkVWludDE2KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSAyNikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZFVpbnQzMigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gMjcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRVaW50NjQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09IDMxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3RJbXBsZW1lbnRlZCgnQWRkaXRpb25hbCBpbmZvOiAnICsgdmFsdWUpKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd3JpdGVIZWFkZXJSYXcodHlwZSwgdmFsdWUsIHdyaXRlcikge1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlQnl0ZSgodHlwZSA8PCA1KSB8IHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cml0ZUhlYWRlcih0eXBlLCB2YWx1ZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RCeXRlID0gdHlwZSA8PCA1O1xuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMjQpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVCeXRlKGZpcnN0Qnl0ZSB8IHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIDwgMjU2KSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlQnl0ZShmaXJzdEJ5dGUgfCAyNCk7XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlQnl0ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA8IDY1NTM2KSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlQnl0ZShmaXJzdEJ5dGUgfCAyNSk7XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlVWludDE2KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIDwgNDI5NDk2NzI5Nikge1xuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZUJ5dGUoZmlyc3RCeXRlIHwgMjYpO1xuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZVVpbnQzMih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVCeXRlKGZpcnN0Qnl0ZSB8IDI3KTtcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVVaW50NjQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzdG9wQ29kZSA9IG5ldyBFcnJvcigpO1xuICAgICAgICBmdW5jdGlvbiBkZWNvZGVSZWFkZXIocmVhZGVyKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gcmVhZEhlYWRlclJhdyhyZWFkZXIpO1xuICAgICAgICAgICAgc3dpdGNoIChoZWFkZXIudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlRnJvbUhlYWRlcihoZWFkZXIsIHJlYWRlcik7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTEgLSB2YWx1ZUZyb21IZWFkZXIoaGVhZGVyLCByZWFkZXIpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQ2h1bmsodmFsdWVGcm9tSGVhZGVyKGhlYWRlciwgcmVhZGVyKSk7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gcmVhZGVyLnJlYWRDaHVuayh2YWx1ZUZyb21IZWFkZXIoaGVhZGVyLCByZWFkZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygndXRmLTgnKTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXlMZW5ndGggPSB2YWx1ZUZyb21IZWFkZXIoaGVhZGVyLCByZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnJheUxlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlci50eXBlID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlMZW5ndGggKj0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGRlY29kZVJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGl0ZW0gPSBkZWNvZGVSZWFkZXIocmVhZGVyKSkgIT09IHN0b3BDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlci50eXBlID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqUmVzdWx0ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialJlc3VsdFtyZXN1bHRbaV1dID0gcmVzdWx0W2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmpSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gdmFsdWVGcm9tSGVhZGVyKGhlYWRlciwgcmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlY29kZXIgPSBzZW1hbnRpY0RlY29kZXJzW3RhZ107XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBkZWNvZGVSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZXIgPyBkZWNvZGVyKHJlc3VsdCkgOiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVyLnZhbHVlID09PSAyNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkRmxvYXQxNigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhlYWRlci52YWx1ZSA9PT0gMjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZEZsb2F0MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChoZWFkZXIudmFsdWUgPT09IDI3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRGbG9hdDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZUZyb21IZWFkZXIoaGVhZGVyLCByZWFkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9wQ29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGZpeGVkIHZhbHVlOiAnICsgaGVhZGVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgaGVhZGVyOiAnICsgSlNPTi5zdHJpbmdpZnkoaGVhZGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlbmNvZGVXcml0ZXIoZGF0YSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbWFudGljRW5jb2RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBzZW1hbnRpY0VuY29kZXJzW2ldLmZuKGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlSGVhZGVyKDYsIHNlbWFudGljRW5jb2RlcnNbaV0udGFnLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlV3JpdGVyKHJlcGxhY2VtZW50LCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhLnRvQ0JPUiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnRvQ0JPUigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVIZWFkZXIoNywgMjAsIHdyaXRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVIZWFkZXIoNywgMjEsIHdyaXRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVIZWFkZXIoNywgMjIsIHdyaXRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB3cml0ZUhlYWRlcig3LCAyMywgd3JpdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmZsb29yKGRhdGEpID09PSBkYXRhICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPCA5MDA3MTk5MjU0NzQwOTkyICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPiAtOTAwNzE5OTI1NDc0MDk5Mikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlSGVhZGVyKDEsIC0xIC0gZGF0YSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlSGVhZGVyKDAsIGRhdGEsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlSGVhZGVyUmF3KDcsIDI3LCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVGbG9hdDY0KGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZVN0cmluZyhkYXRhLCBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlSGVhZGVyKDMsIGxlbmd0aCwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHdyaXRlci5jYW5Xcml0ZUJpbmFyeShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZUJpbmFyeShkYXRhLCBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlSGVhZGVyKDIsIGxlbmd0aCwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmIChhcGkuY29uZmlnLnVzZVRvSlNPTiAmJiB0eXBlb2YgZGF0YS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEudG9KU09OKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlSGVhZGVyKDQsIGRhdGEubGVuZ3RoLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVdyaXRlcihkYXRhW2ldLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZUhlYWRlcig1LCBrZXlzLmxlbmd0aCwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBudW1iZXIgPSBwYXJzZUludChrZXlzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihudW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlV3JpdGVyKGtleXNbaV0sIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlV3JpdGVyKGRhdGFba2V5c1tpXV0sIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVXcml0ZXIobnVtYmVyLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVdyaXRlcihkYXRhW2tleXNbaV1dLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDQk9SIGVuY29kaW5nIG5vdCBzdXBwb3J0ZWQ6ICcgKyBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVhZGVyRnVuY3Rpb25zID0gW107XG4gICAgICAgIHZhciB3cml0ZXJGdW5jdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIGFwaSA9IHtcbiAgICAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgICAgIHVzZVRvSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRXcml0ZXI6IGZ1bmN0aW9uIChmb3JtYXQsIHdyaXRlckZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlckZ1bmN0aW9ucy5wdXNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBmKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZXJGdW5jdGlvbihmKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3cml0ZXJGdW5jdGlvbnMucHVzaChmb3JtYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRSZWFkZXI6IGZ1bmN0aW9uIChmb3JtYXQsIHJlYWRlckZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlckZ1bmN0aW9ucy5wdXNoKGZ1bmN0aW9uIChkYXRhLCBmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBmKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXJGdW5jdGlvbihkYXRhLCBmKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXJGdW5jdGlvbnMucHVzaChmb3JtYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uIChkYXRhLCBmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdyaXRlckZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVuYyA9IHdyaXRlckZ1bmN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdyaXRlciA9IGZ1bmMoZm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdyaXRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlV3JpdGVyKGRhdGEsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVyLnJlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgb3V0cHV0IGZvcm1hdDogJyArIGZvcm1hdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5jb2RlRGF0YUl0ZW06IGZ1bmN0aW9uIChkYXRhLCBmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdyaXRlckZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVuYyA9IHdyaXRlckZ1bmN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdyaXRlciA9IGZ1bmMoZm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdyaXRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuZ2V0VGFnKCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVdyaXRlcihkYXRhLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZXIucmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVXcml0ZXIoZGF0YS5nZXREYXRhKCksIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlci5yZXN1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG91dHB1dCBmb3JtYXQ6ICcgKyBmb3JtYXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29kZTogZnVuY3Rpb24gKGRhdGEsIGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVhZGVyRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdW5jID0gcmVhZGVyRnVuY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gZnVuYyhkYXRhLCBmb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBpbnB1dCBmb3JtYXQ6ICcgKyBmb3JtYXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29kZVRvRGF0YUl0ZW06IGZ1bmN0aW9uIChkYXRhLCBmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlYWRlckZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVuYyA9IHJlYWRlckZ1bmN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IGZ1bmMoZGF0YSwgZm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVjb2RlUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRGF0YUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRhSXRlbShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgaW5wdXQgZm9ybWF0OiAnICsgZm9ybWF0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRTZW1hbnRpY0VuY29kZTogZnVuY3Rpb24gKHRhZywgZm4pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhZyAhPT0gJ251bWJlcicgfHwgdGFnICUgMSAhPT0gMCB8fCB0YWcgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGFnIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbWFudGljRW5jb2RlcnMucHVzaCh7IHRhZzogdGFnLCBmbjogZm4gfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkU2VtYW50aWNEZWNvZGU6IGZ1bmN0aW9uICh0YWcsIGZuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YWcgIT09ICdudW1iZXInIHx8IHRhZyAlIDEgIT09IDAgfHwgdGFnIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhZyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZW1hbnRpY0RlY29kZXJzW3RhZ10gPSBmbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlclJlYWRlcihidWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIEJ1ZmZlclJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlYWRlci5wcm90b3R5cGUpO1xuICAgICAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLnBlZWtCeXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMucG9zXTtcbiAgICAgICAgfTtcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkQnl0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLnBvcysrXTtcbiAgICAgICAgfTtcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkVWludDE2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuYnVmZmVyLnJlYWRVSW50MTZCRSh0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkVWludDMyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuYnVmZmVyLnJlYWRVSW50MzJCRSh0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkRmxvYXQzMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmJ1ZmZlci5yZWFkRmxvYXRCRSh0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkRmxvYXQ2NCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmJ1ZmZlci5yZWFkRG91YmxlQkUodGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIEJ1ZmZlclJlYWRlci5wcm90b3R5cGUucmVhZENodW5rID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IEJ1ZmZlci5hbGxvYyhsZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIuY29weShyZXN1bHQsIDAsIHRoaXMucG9zLCAodGhpcy5wb3MgKz0gbGVuZ3RoKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBCdWZmZXJXcml0ZXIoc3RyaW5nRm9ybWF0KSB7XG4gICAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0QnVmZmVyTGVuZ3RoID0gMTYzODQ7XG4gICAgICAgICAgICB0aGlzLmxhdGVzdEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyh0aGlzLmRlZmF1bHRCdWZmZXJMZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQgPSAwO1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc3RyaW5nRm9ybWF0ID0gc3RyaW5nRm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIEJ1ZmZlcldyaXRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdyaXRlci5wcm90b3R5cGUpO1xuICAgICAgICBCdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlQnl0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RCdWZmZXJbdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQrK10gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCA+PSB0aGlzLmxhdGVzdEJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlQnVmZmVycy5wdXNoKHRoaXMubGF0ZXN0QnVmZmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyh0aGlzLmRlZmF1bHRCdWZmZXJMZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCsrO1xuICAgICAgICB9O1xuICAgICAgICBCdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlRmxvYXQzMiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZUZsb2F0QkUodmFsdWUsIDApO1xuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcihidWZmZXIpO1xuICAgICAgICB9O1xuICAgICAgICBCdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlRmxvYXQ2NCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg4KTtcbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZURvdWJsZUJFKHZhbHVlLCAwKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXIoYnVmZmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnVmZmVyV3JpdGVyLnByb3RvdHlwZS53cml0ZVN0cmluZyA9IGZ1bmN0aW9uIChzdHJpbmcsIGxlbmd0aEZ1bmMpIHtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBCdWZmZXIuZnJvbShzdHJpbmcsICd1dGYtOCcpO1xuICAgICAgICAgICAgbGVuZ3RoRnVuYyhidWZmZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXIoYnVmZmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5jYW5Xcml0ZUJpbmFyeSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIEJ1ZmZlcjtcbiAgICAgICAgfTtcbiAgICAgICAgQnVmZmVyV3JpdGVyLnByb3RvdHlwZS53cml0ZUJpbmFyeSA9IGZ1bmN0aW9uIChidWZmZXIsIGxlbmd0aEZ1bmMpIHtcbiAgICAgICAgICAgIGxlbmd0aEZ1bmMoYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgIH07XG4gICAgICAgIEJ1ZmZlcldyaXRlci5wcm90b3R5cGUud3JpdGVCdWZmZXIgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgIGlmICghKGNodW5rIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCdWZmZXJXcml0ZXIgb25seSBhY2NlcHRzIEJ1ZmZlcnMnKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlQnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubGF0ZXN0QnVmZmVyLmxlbmd0aCAtIHRoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0ID49XG4gICAgICAgICAgICAgICAgY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsuY29weSh0aGlzLmxhdGVzdEJ1ZmZlciwgdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQgPj0gdGhpcy5sYXRlc3RCdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVCdWZmZXJzLnB1c2godGhpcy5sYXRlc3RCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyh0aGlzLmRlZmF1bHRCdWZmZXJMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUJ1ZmZlcnMucHVzaCh0aGlzLmxhdGVzdEJ1ZmZlci5zbGljZSgwLCB0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVCdWZmZXJzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0QnVmZmVyID0gQnVmZmVyLmFsbG9jKHRoaXMuZGVmYXVsdEJ1ZmZlckxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgfTtcbiAgICAgICAgQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5yZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gQnVmZmVyLmFsbG9jKHRoaXMuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb21wbGV0ZUJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5jb21wbGV0ZUJ1ZmZlcnNbaV07XG4gICAgICAgICAgICAgICAgYnVmZmVyLmNvcHkocmVzdWx0LCBvZmZzZXQsIDAsIGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RCdWZmZXIuY29weShyZXN1bHQsIG9mZnNldCwgMCwgdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RyaW5nRm9ybWF0KVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcodGhpcy5zdHJpbmdGb3JtYXQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFwaS5hZGRSZWFkZXIoZnVuY3Rpb24gKGRhdGEsIGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJSZWFkZXIoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdoZXgnIHx8IGZvcm1hdCA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGRhdGEsIGZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyUmVhZGVyKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhcGkuYWRkV3JpdGVyKGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZvcm1hdCB8fCBmb3JtYXQgPT09ICdidWZmZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2hleCcgfHwgZm9ybWF0ID09PSAnYmFzZTY0Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcldyaXRlcihmb3JtYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIEhleFJlYWRlcihoZXgpIHtcbiAgICAgICAgICAgIHRoaXMuaGV4ID0gaGV4O1xuICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIEhleFJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlYWRlci5wcm90b3R5cGUpO1xuICAgICAgICBIZXhSZWFkZXIucHJvdG90eXBlLnBlZWtCeXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSB0aGlzLmhleC5zdWJzdHJpbmcodGhpcy5wb3MsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHBhaXIsIDE2KTtcbiAgICAgICAgfTtcbiAgICAgICAgSGV4UmVhZGVyLnByb3RvdHlwZS5yZWFkQnl0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYWlyID0gdGhpcy5oZXguc3Vic3RyaW5nKHRoaXMucG9zLCB0aGlzLnBvcyArIDIpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gMjtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChwYWlyLCAxNik7XG4gICAgICAgIH07XG4gICAgICAgIEhleFJlYWRlci5wcm90b3R5cGUucmVhZENodW5rID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGhleCA9IHRoaXMuaGV4LnN1YnN0cmluZyh0aGlzLnBvcywgdGhpcy5wb3MgKyBsZW5ndGggKiAyKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IGxlbmd0aCAqIDI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oaGV4LCAnaGV4Jyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUhleChoZXgpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBIZXhXcml0ZXIoZmluYWxGb3JtYXQpIHtcbiAgICAgICAgICAgIHRoaXMuJGhleCA9ICcnO1xuICAgICAgICAgICAgdGhpcy5maW5hbEZvcm1hdCA9IGZpbmFsRm9ybWF0IHx8ICdoZXgnO1xuICAgICAgICB9XG4gICAgICAgIEhleFdyaXRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdyaXRlci5wcm90b3R5cGUpO1xuICAgICAgICBIZXhXcml0ZXIucHJvdG90eXBlLndyaXRlQnl0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDI1NSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0J5dGUgdmFsdWUgb3V0IG9mIHJhbmdlOiAnICsgdmFsdWUpO1xuICAgICAgICAgICAgdmFyIGhleCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBoZXggPSAnMCcgKyBoZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRoZXggKz0gaGV4O1xuICAgICAgICB9O1xuICAgICAgICBIZXhXcml0ZXIucHJvdG90eXBlLmNhbldyaXRlQmluYXJ5ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gKGNodW5rIGluc3RhbmNlb2YgQmluYXJ5SGV4IHx8XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgY2h1bmsgaW5zdGFuY2VvZiBCdWZmZXIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgSGV4V3JpdGVyLnByb3RvdHlwZS53cml0ZUJpbmFyeSA9IGZ1bmN0aW9uIChjaHVuaywgbGVuZ3RoRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChjaHVuayBpbnN0YW5jZW9mIEJpbmFyeUhleCkge1xuICAgICAgICAgICAgICAgIGxlbmd0aEZ1bmN0aW9uKGNodW5rLmxlbmd0aCgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRoZXggKz0gY2h1bmsuJGhleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgY2h1bmsgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGhGdW5jdGlvbihjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGhleCArPSBjaHVuay50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIZXhXcml0ZXIgb25seSBhY2NlcHRzIEJpbmFyeUhleCBvciBCdWZmZXJzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEhleFdyaXRlci5wcm90b3R5cGUucmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmluYWxGb3JtYXQgPT09ICdidWZmZXInICYmIHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy4kaGV4LCAnaGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUhleCh0aGlzLiRoZXgpLnRvU3RyaW5nKHRoaXMuZmluYWxGb3JtYXQpO1xuICAgICAgICB9O1xuICAgICAgICBIZXhXcml0ZXIucHJvdG90eXBlLndyaXRlU3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZywgbGVuZ3RoRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBCaW5hcnlIZXguZnJvbVV0ZjhTdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICAgIGxlbmd0aEZ1bmN0aW9uKGJ1ZmZlci5sZW5ndGgoKSk7XG4gICAgICAgICAgICB0aGlzLiRoZXggKz0gYnVmZmVyLiRoZXg7XG4gICAgICAgIH07XG4gICAgICAgIGFwaS5hZGRSZWFkZXIoZnVuY3Rpb24gKGRhdGEsIGZvcm1hdCkge1xuICAgICAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBCaW5hcnlIZXggfHwgZGF0YS4kaGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIZXhSZWFkZXIoZGF0YS4kaGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdoZXgnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIZXhSZWFkZXIoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhcGkuYWRkV3JpdGVyKGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdoZXgnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIZXhXcml0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgfSkoKTtcbiAgICBDQk9SLmFkZFNlbWFudGljRW5jb2RlKDAsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgICAgIC5hZGRTZW1hbnRpY0RlY29kZSgwLCBmdW5jdGlvbiAoaXNvU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShpc29TdHJpbmcpO1xuICAgIH0pXG4gICAgICAgIC5hZGRTZW1hbnRpY0RlY29kZSgxLCBmdW5jdGlvbiAoaXNvU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShpc29TdHJpbmcpO1xuICAgIH0pO1xuICAgIHJldHVybiBDQk9SO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYm9yLXN5bmMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRhdGFJdGVtID0gZXhwb3J0cy5hZGRXcml0ZXIgPSBleHBvcnRzLmFkZFJlYWRlciA9IGV4cG9ydHMuYWRkU2VtYW50aWNFbmNvZGUgPSBleHBvcnRzLmFkZFNlbWFudGljRGVjb2RlID0gZXhwb3J0cy5kZWNvZGVUb0RhdGFJdGVtID0gZXhwb3J0cy5lbmNvZGVEYXRhSXRlbSA9IHZvaWQgMDtcbnZhciBjYm9yX3N5bmNfMSA9IHJlcXVpcmUoXCIuL2Nib3Itc3luY1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZURhdGFJdGVtXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYm9yX3N5bmNfMS5lbmNvZGVEYXRhSXRlbTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZVRvRGF0YUl0ZW1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNib3Jfc3luY18xLmRlY29kZVRvRGF0YUl0ZW07IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhZGRTZW1hbnRpY0RlY29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2Jvcl9zeW5jXzEuYWRkU2VtYW50aWNEZWNvZGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhZGRTZW1hbnRpY0VuY29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2Jvcl9zeW5jXzEuYWRkU2VtYW50aWNFbmNvZGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhZGRSZWFkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNib3Jfc3luY18xLmFkZFJlYWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZFdyaXRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2Jvcl9zeW5jXzEuYWRkV3JpdGVyOyB9IH0pO1xudmFyIERhdGFJdGVtXzEgPSByZXF1aXJlKFwiLi9EYXRhSXRlbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRhdGFJdGVtXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBEYXRhSXRlbV8xLkRhdGFJdGVtOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBSZWdpc3RyeVR5cGVfMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdHJ5VHlwZVwiKTtcbmNvbnN0IFNjcmlwdEV4cHJlc3Npb25fMSA9IHJlcXVpcmUoXCIuL1NjcmlwdEV4cHJlc3Npb25cIik7XG5jb25zdCByZWdpc3RyeVRhZ3MgPSBPYmplY3QudmFsdWVzKFJlZ2lzdHJ5VHlwZV8xLlJlZ2lzdHJ5VHlwZXMpXG4gICAgLmZpbHRlcigocikgPT4gISFyLmdldFRhZygpKVxuICAgIC5tYXAoKHIpID0+IHIuZ2V0VGFnKCkpO1xuY29uc3Qgc2NyaXB0RXhwcmVzc2lvblRhZ3MgPSBPYmplY3QudmFsdWVzKFNjcmlwdEV4cHJlc3Npb25fMS5TY3JpcHRFeHByZXNzaW9ucykubWFwKChzZSkgPT4gc2UuZ2V0VGFnKCkpO1xuKDAsIHV0aWxzXzEucGF0Y2hUYWdzKShyZWdpc3RyeVRhZ3MuY29uY2F0KHNjcmlwdEV4cHJlc3Npb25UYWdzKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRjaENCT1IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGF0Y2hUYWdzID0gdm9pZCAwO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi9saWJcIik7XG5jb25zdCBhbHJlYWR5UGF0Y2hlZFRhZyA9IFtdO1xuY29uc3QgcGF0Y2hUYWdzID0gKHRhZ3MpID0+IHtcbiAgICB0YWdzLmZvckVhY2goKHRhZykgPT4ge1xuICAgICAgICBpZiAoYWxyZWFkeVBhdGNoZWRUYWcuZmluZCgoaSkgPT4gaSA9PT0gdGFnKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgKDAsIGxpYl8xLmFkZFNlbWFudGljRW5jb2RlKSh0YWcsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIGxpYl8xLkRhdGFJdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZ2V0VGFnKCkgPT09IHRhZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5nZXREYXRhKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgKDAsIGxpYl8xLmFkZFNlbWFudGljRGVjb2RlKSh0YWcsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGxpYl8xLkRhdGFJdGVtKGRhdGEsIHRhZyk7XG4gICAgICAgIH0pO1xuICAgICAgICBhbHJlYWR5UGF0Y2hlZFRhZy5wdXNoKHRhZyk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy5wYXRjaFRhZ3MgPSBwYXRjaFRhZ3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tcG9zZWRTdG9yZSA9IHZvaWQgMDtcbmNvbnN0IE9ic2VydmFibGVTdG9yZV8xID0gcmVxdWlyZShcIi4vT2JzZXJ2YWJsZVN0b3JlXCIpO1xuY2xhc3MgQ29tcG9zZWRTdG9yZSBleHRlbmRzIE9ic2VydmFibGVTdG9yZV8xLk9ic2VydmFibGVTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4pIHtcbiAgICAgICAgLy8gVHlwZWNhc3Q6IFByZXNlcnZlIGV4aXN0aW5nIGJlaGF2aW9yXG4gICAgICAgIHN1cGVyKHt9KTtcbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIGNoaWxkcmVuXG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gY2hpbGRyZW4gfHwge307XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2NoaWxkcmVuKS5mb3JFYWNoKChjaGlsZEtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltjaGlsZEtleV07XG4gICAgICAgICAgICB0aGlzLl9hZGRDaGlsZChjaGlsZEtleSwgY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoaWxkKGNoaWxkS2V5LCBjaGlsZCkge1xuICAgICAgICBjb25zdCB1cGRhdGVGcm9tQ2hpbGQgPSAoY2hpbGRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBzdGF0ZVtjaGlsZEtleV0gPSBjaGlsZFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5wdXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNoaWxkLnN1YnNjcmliZSh1cGRhdGVGcm9tQ2hpbGQpO1xuICAgICAgICB1cGRhdGVGcm9tQ2hpbGQoY2hpbGQuZ2V0U3RhdGUoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db21wb3NlZFN0b3JlID0gQ29tcG9zZWRTdG9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbXBvc2VkU3RvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1lcmdlZFN0b3JlID0gdm9pZCAwO1xuY29uc3QgT2JzZXJ2YWJsZVN0b3JlXzEgPSByZXF1aXJlKFwiLi9PYnNlcnZhYmxlU3RvcmVcIik7XG5jbGFzcyBNZXJnZWRTdG9yZSBleHRlbmRzIE9ic2VydmFibGVTdG9yZV8xLk9ic2VydmFibGVTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4gPSBbXSkge1xuICAgICAgICAvLyBUeXBlY2FzdDogUHJlc2VydmUgZXhpc3RpbmcgYmVoYXZpb3JcbiAgICAgICAgc3VwZXIoe30pO1xuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gY2hpbGRyZW5cbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHRoaXMuX2FkZENoaWxkKGNoaWxkKSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVdob2xlU3RhdGUoKTtcbiAgICB9XG4gICAgX2FkZENoaWxkKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLnN1YnNjcmliZSgoKSA9PiB0aGlzLl91cGRhdGVXaG9sZVN0YXRlKCkpO1xuICAgIH1cbiAgICBfdXBkYXRlV2hvbGVTdGF0ZSgpIHtcbiAgICAgICAgY29uc3QgY2hpbGRTdGF0ZXMgPSB0aGlzLl9jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC5nZXRTdGF0ZSgpKTtcbiAgICAgICAgLy8gYXBwbHkgc2hhbGxvdyBtZXJnZSBvdmVyIHN0YXRlc1xuICAgICAgICBjb25zdCBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIC4uLmNoaWxkU3RhdGVzKTtcbiAgICAgICAgdGhpcy5wdXRTdGF0ZShzdGF0ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5NZXJnZWRTdG9yZSA9IE1lcmdlZFN0b3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVyZ2VkU3RvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9ic2VydmFibGVTdG9yZSA9IHZvaWQgMDtcbmNvbnN0IHNhZmVfZXZlbnRfZW1pdHRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAbWV0YW1hc2svc2FmZS1ldmVudC1lbWl0dGVyXCIpKTtcbmNsYXNzIE9ic2VydmFibGVTdG9yZSBleHRlbmRzIHNhZmVfZXZlbnRfZW1pdHRlcl8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKGluaXRTdGF0ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoaW5pdFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IGluaXRTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFR5cGVjYXN0L2RlZmF1bHQgc3RhdGU6IFByZXNlcnZlIGV4aXN0aW5nIGJlaGF2aW9yXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHdyYXBwZXIgYXJvdW5kIGludGVybmFsIGdldFN0YXRlXG4gICAgZ2V0U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTdGF0ZSgpO1xuICAgIH1cbiAgICAvLyB3cmFwcGVyIGFyb3VuZCBpbnRlcm5hbCBwdXRTdGF0ZVxuICAgIHB1dFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuX3B1dFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCBuZXdTdGF0ZSk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKHBhcnRpYWxTdGF0ZSkge1xuICAgICAgICAvLyBpZiBub24tbnVsbCBvYmplY3QsIG1lcmdlXG4gICAgICAgIGlmIChwYXJ0aWFsU3RhdGUgJiYgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5wdXRTdGF0ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwgcGFydGlhbFN0YXRlKSk7XG4gICAgICAgICAgICAvLyBpZiBub3Qgb2JqZWN0LCB1c2UgbmV3IHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnB1dFN0YXRlKHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc3Vic2NyaWJlIHRvIGNoYW5nZXNcbiAgICBzdWJzY3JpYmUoaGFuZGxlcikge1xuICAgICAgICB0aGlzLm9uKCd1cGRhdGUnLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLy8gdW5zdWJzY3JpYmUgdG8gY2hhbmdlc1xuICAgIHVuc3Vic2NyaWJlKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigndXBkYXRlJywgaGFuZGxlcik7XG4gICAgfVxuICAgIC8vXG4gICAgLy8gcHJpdmF0ZVxuICAgIC8vXG4gICAgLy8gcmVhZCBmcm9tIHBlcnNpc3RlbmNlXG4gICAgX2dldFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuICAgIC8vIHdyaXRlIHRvIHBlcnNpc3RlbmNlXG4gICAgX3B1dFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gbmV3U3RhdGU7XG4gICAgfVxufVxuZXhwb3J0cy5PYnNlcnZhYmxlU3RvcmUgPSBPYnNlcnZhYmxlU3RvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZhYmxlU3RvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN0b3JlQXNTdHJlYW0gPSB2b2lkIDA7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jbGFzcyBPYnNlcnZhYmxlU3RvcmVTdHJlYW0gZXh0ZW5kcyBzdHJlYW1fMS5EdXBsZXgge1xuICAgIGNvbnN0cnVjdG9yKG9ic1N0b3JlKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIC8vIHBhc3MgdmFsdWVzLCBub3Qgc2VyaWFsaXphdGlvbnNcbiAgICAgICAgICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBkb250IGJ1ZmZlciBvdXRnb2luZyB1cGRhdGVzXG4gICAgICAgIHRoaXMucmVzdW1lKCk7XG4gICAgICAgIC8vIHNhdmUgaGFuZGxlciBzbyB3ZSBjYW4gdW5zdWJzY3JpYmUgbGF0ZXJcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gKHN0YXRlKSA9PiB0aGlzLnB1c2goc3RhdGUpO1xuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gb2JzU3RvcmUgY2hhbmdlc1xuICAgICAgICB0aGlzLm9ic1N0b3JlID0gb2JzU3RvcmU7XG4gICAgICAgIHRoaXMub2JzU3RvcmUuc3Vic2NyaWJlKHRoaXMuaGFuZGxlcik7XG4gICAgfVxuICAgIC8vIGVtaXQgY3VycmVudCBzdGF0ZSBvbiBuZXcgZGVzdGluYXRpb25cbiAgICBwaXBlKGRlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIucGlwZShkZXN0LCBvcHRpb25zKTtcbiAgICAgICAgZGVzdC53cml0ZSh0aGlzLm9ic1N0b3JlLmdldFN0YXRlKCkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyB3cml0ZSBmcm9tIGluY29taW5nIHN0cmVhbSB0byBzdGF0ZVxuICAgIF93cml0ZShjaHVuaywgX2VuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm9ic1N0b3JlLnB1dFN0YXRlKGNodW5rKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgLy8gbm9vcCAtIG91dGdvaW5nIHN0cmVhbSBpcyBhc2tpbmcgdXMgaWYgd2UgaGF2ZSBkYXRhIHdlIGFyZW50IGdpdmluZyBpdFxuICAgIF9yZWFkKF9zaXplKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gZXZlbnQgZW1pdHRlclxuICAgIF9kZXN0cm95KGVyciwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vYnNTdG9yZS51bnN1YnNjcmliZSh0aGlzLmhhbmRsZXIpO1xuICAgICAgICBzdXBlci5fZGVzdHJveShlcnIsIGNhbGxiYWNrKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdG9yZUFzU3RyZWFtKG9ic1N0b3JlKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlU3RvcmVTdHJlYW0ob2JzU3RvcmUpO1xufVxuZXhwb3J0cy5zdG9yZUFzU3RyZWFtID0gc3RvcmVBc1N0cmVhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzU3RyZWFtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNTdHJlYW1cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0NvbXBvc2VkU3RvcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL01lcmdlZFN0b3JlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9PYnNlcnZhYmxlU3RvcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RyYW5zZm9ybVwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3RvcmVUcmFuc2Zvcm1TdHJlYW0gPSB2b2lkIDA7XG5jb25zdCB0aHJvdWdoMl8xID0gcmVxdWlyZShcInRocm91Z2gyXCIpO1xuZnVuY3Rpb24gc3RvcmVUcmFuc2Zvcm1TdHJlYW0oc3luY1RyYW5zZm9ybUZuKSB7XG4gICAgcmV0dXJuIHRocm91Z2gyXzEub2JqKChzdGF0ZSwgX2VuY29kaW5nLCBjYikgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBzeW5jVHJhbnNmb3JtRm4oc3RhdGUpO1xuICAgICAgICAgICAgY2IobnVsbCwgbmV3U3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5zdG9yZVRyYW5zZm9ybVN0cmVhbSA9IHN0b3JlVHJhbnNmb3JtU3RyZWFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNmb3JtLmpzLm1hcCIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5UcmFuc2Zvcm1cbiAgLCBpbmhlcml0cyAgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcbiAgLCB4dGVuZCAgICAgPSByZXF1aXJlKCd4dGVuZCcpXG5cbmZ1bmN0aW9uIERlc3Ryb3lhYmxlVHJhbnNmb3JtKG9wdHMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0cylcbiAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2Vcbn1cblxuaW5oZXJpdHMoRGVzdHJveWFibGVUcmFuc2Zvcm0sIFRyYW5zZm9ybSlcblxuRGVzdHJveWFibGVUcmFuc2Zvcm0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWVcbiAgXG4gIHZhciBzZWxmID0gdGhpc1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIGlmIChlcnIpXG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgIHNlbGYuZW1pdCgnY2xvc2UnKVxuICB9KVxufVxuXG4vLyBhIG5vb3AgX3RyYW5zZm9ybSBmdW5jdGlvblxuZnVuY3Rpb24gbm9vcCAoY2h1bmssIGVuYywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sobnVsbCwgY2h1bmspXG59XG5cblxuLy8gY3JlYXRlIGEgbmV3IGV4cG9ydCBmdW5jdGlvbiwgdXNlZCBieSBib3RoIHRoZSBtYWluIGV4cG9ydCBhbmRcbi8vIHRoZSAuY3RvciBleHBvcnQsIGNvbnRhaW5zIGNvbW1vbiBsb2dpYyBmb3IgZGVhbGluZyB3aXRoIGFyZ3VtZW50c1xuZnVuY3Rpb24gdGhyb3VnaDIgKGNvbnN0cnVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmx1c2ggICAgID0gdHJhbnNmb3JtXG4gICAgICB0cmFuc2Zvcm0gPSBvcHRpb25zXG4gICAgICBvcHRpb25zICAgPSB7fVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHJhbnNmb3JtICE9ICdmdW5jdGlvbicpXG4gICAgICB0cmFuc2Zvcm0gPSBub29wXG5cbiAgICBpZiAodHlwZW9mIGZsdXNoICE9ICdmdW5jdGlvbicpXG4gICAgICBmbHVzaCA9IG51bGxcblxuICAgIHJldHVybiBjb25zdHJ1Y3Qob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaClcbiAgfVxufVxuXG5cbi8vIG1haW4gZXhwb3J0LCBqdXN0IG1ha2UgbWUgYSB0cmFuc2Zvcm0gc3RyZWFtIVxubW9kdWxlLmV4cG9ydHMgPSB0aHJvdWdoMihmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICB2YXIgdDIgPSBuZXcgRGVzdHJveWFibGVUcmFuc2Zvcm0ob3B0aW9ucylcblxuICB0Mi5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIHQyLl9mbHVzaCA9IGZsdXNoXG5cbiAgcmV0dXJuIHQyXG59KVxuXG5cbi8vIG1ha2UgbWUgYSByZXVzYWJsZSBwcm90b3R5cGUgdGhhdCBJIGNhbiBgbmV3YCwgb3IgaW1wbGljaXRseSBgbmV3YFxuLy8gd2l0aCBhIGNvbnN0cnVjdG9yIGNhbGxcbm1vZHVsZS5leHBvcnRzLmN0b3IgPSB0aHJvdWdoMihmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICBmdW5jdGlvbiBUaHJvdWdoMiAob3ZlcnJpZGUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGhyb3VnaDIpKVxuICAgICAgcmV0dXJuIG5ldyBUaHJvdWdoMihvdmVycmlkZSlcblxuICAgIHRoaXMub3B0aW9ucyA9IHh0ZW5kKG9wdGlvbnMsIG92ZXJyaWRlKVxuXG4gICAgRGVzdHJveWFibGVUcmFuc2Zvcm0uY2FsbCh0aGlzLCB0aGlzLm9wdGlvbnMpXG4gIH1cblxuICBpbmhlcml0cyhUaHJvdWdoMiwgRGVzdHJveWFibGVUcmFuc2Zvcm0pXG5cbiAgVGhyb3VnaDIucHJvdG90eXBlLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cblxuICBpZiAoZmx1c2gpXG4gICAgVGhyb3VnaDIucHJvdG90eXBlLl9mbHVzaCA9IGZsdXNoXG5cbiAgcmV0dXJuIFRocm91Z2gyXG59KVxuXG5cbm1vZHVsZS5leHBvcnRzLm9iaiA9IHRocm91Z2gyKGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gIHZhciB0MiA9IG5ldyBEZXN0cm95YWJsZVRyYW5zZm9ybSh4dGVuZCh7IG9iamVjdE1vZGU6IHRydWUsIGhpZ2hXYXRlck1hcms6IDE2IH0sIG9wdGlvbnMpKVxuXG4gIHQyLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cblxuICBpZiAoZmx1c2gpXG4gICAgdDIuX2ZsdXNoID0gZmx1c2hcblxuICByZXR1cm4gdDJcbn0pXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWRkcmVzc0Jvb2tDb250cm9sbGVyID0gZXhwb3J0cy5BZGRyZXNzVHlwZSA9IHZvaWQgMDtcbmNvbnN0IGNvbnRyb2xsZXJfdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svY29udHJvbGxlci11dGlsc1wiKTtcbmNvbnN0IGJhc2VfY29udHJvbGxlcl8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9iYXNlLWNvbnRyb2xsZXJcIik7XG52YXIgQWRkcmVzc1R5cGU7XG4oZnVuY3Rpb24gKEFkZHJlc3NUeXBlKSB7XG4gICAgQWRkcmVzc1R5cGVbXCJleHRlcm5hbGx5T3duZWRBY2NvdW50c1wiXSA9IFwiRVhURVJOQUxMWV9PV05FRF9BQ0NPVU5UU1wiO1xuICAgIEFkZHJlc3NUeXBlW1wiY29udHJhY3RBY2NvdW50c1wiXSA9IFwiQ09OVFJBQ1RfQUNDT1VOVFNcIjtcbiAgICBBZGRyZXNzVHlwZVtcIm5vbkFjY291bnRzXCJdID0gXCJOT05fQUNDT1VOVFNcIjtcbn0pKEFkZHJlc3NUeXBlID0gZXhwb3J0cy5BZGRyZXNzVHlwZSB8fCAoZXhwb3J0cy5BZGRyZXNzVHlwZSA9IHt9KSk7XG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCBtYW5hZ2VzIGEgbGlzdCBvZiByZWNpcGllbnQgYWRkcmVzc2VzIGFzc29jaWF0ZWQgd2l0aCBuaWNrbmFtZXMuXG4gKi9cbmNsYXNzIEFkZHJlc3NCb29rQ29udHJvbGxlciBleHRlbmRzIGJhc2VfY29udHJvbGxlcl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIEFkZHJlc3NCb29rQ29udHJvbGxlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyLlxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdBZGRyZXNzQm9va0NvbnRyb2xsZXInO1xuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHsgYWRkcmVzc0Jvb2s6IHt9IH07XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGNvbnRyYWN0IGVudHJpZXMuXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKHsgYWRkcmVzc0Jvb2s6IHt9IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBjb250cmFjdCBlbnRyeSBieSBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYWluSWQgLSBDaGFpbiBpZCBpZGVudGlmaWVzIHRoZSBjdXJyZW50IGNoYWluLlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gUmVjaXBpZW50IGFkZHJlc3MgdG8gZGVsZXRlLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGVudHJ5IHdhcyBkZWxldGVkLlxuICAgICAqL1xuICAgIGRlbGV0ZShjaGFpbklkLCBhZGRyZXNzKSB7XG4gICAgICAgIGFkZHJlc3MgPSAoMCwgY29udHJvbGxlcl91dGlsc18xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKShhZGRyZXNzKTtcbiAgICAgICAgaWYgKCEoMCwgY29udHJvbGxlcl91dGlsc18xLmlzVmFsaWRIZXhBZGRyZXNzKShhZGRyZXNzKSB8fFxuICAgICAgICAgICAgIXRoaXMuc3RhdGUuYWRkcmVzc0Jvb2tbY2hhaW5JZF0gfHxcbiAgICAgICAgICAgICF0aGlzLnN0YXRlLmFkZHJlc3NCb29rW2NoYWluSWRdW2FkZHJlc3NdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzc0Jvb2sgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlLmFkZHJlc3NCb29rKTtcbiAgICAgICAgZGVsZXRlIGFkZHJlc3NCb29rW2NoYWluSWRdW2FkZHJlc3NdO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoYWRkcmVzc0Jvb2tbY2hhaW5JZF0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIGFkZHJlc3NCb29rW2NoYWluSWRdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKHsgYWRkcmVzc0Jvb2sgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgb3IgdXBkYXRlIGEgY29udGFjdCBlbnRyeSBieSBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBSZWNpcGllbnQgYWRkcmVzcyB0byBhZGQgb3IgdXBkYXRlLlxuICAgICAqIEBwYXJhbSBuYW1lIC0gTmlja25hbWUgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSBjaGFpbklkIC0gQ2hhaW4gaWQgaWRlbnRpZmllcyB0aGUgY3VycmVudCBjaGFpbi5cbiAgICAgKiBAcGFyYW0gbWVtbyAtIFVzZXIncyBub3RlIGFib3V0IGFkZHJlc3MuXG4gICAgICogQHBhcmFtIGFkZHJlc3NUeXBlIC0gQ29udGFjdCdzIGFkZHJlc3MgdHlwZS5cbiAgICAgKiBAcmV0dXJucyBCb29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGFkZHJlc3Mgd2FzIHN1Y2Nlc3NmdWxseSBzZXQuXG4gICAgICovXG4gICAgc2V0KGFkZHJlc3MsIG5hbWUsIGNoYWluSWQgPSAnMScsIG1lbW8gPSAnJywgYWRkcmVzc1R5cGUpIHtcbiAgICAgICAgYWRkcmVzcyA9ICgwLCBjb250cm9sbGVyX3V0aWxzXzEudG9DaGVja3N1bUhleEFkZHJlc3MpKGFkZHJlc3MpO1xuICAgICAgICBpZiAoISgwLCBjb250cm9sbGVyX3V0aWxzXzEuaXNWYWxpZEhleEFkZHJlc3MpKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW50cnkgPSB7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgIGlzRW5zOiBmYWxzZSxcbiAgICAgICAgICAgIG1lbW8sXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgYWRkcmVzc1R5cGUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVuc05hbWUgPSAoMCwgY29udHJvbGxlcl91dGlsc18xLm5vcm1hbGl6ZUVuc05hbWUpKG5hbWUpO1xuICAgICAgICBpZiAoZW5zTmFtZSkge1xuICAgICAgICAgICAgZW50cnkubmFtZSA9IGVuc05hbWU7XG4gICAgICAgICAgICBlbnRyeS5pc0VucyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgYWRkcmVzc0Jvb2s6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdGF0ZS5hZGRyZXNzQm9vayksIHsgW2NoYWluSWRdOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhdGUuYWRkcmVzc0Jvb2tbY2hhaW5JZF0pLCB7IFthZGRyZXNzXTogZW50cnkgfSkgfSksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLkFkZHJlc3NCb29rQ29udHJvbGxlciA9IEFkZHJlc3NCb29rQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IEFkZHJlc3NCb29rQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFkZHJlc3NCb29rQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0FkZHJlc3NCb29rQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9Bbm5vdW5jZW1lbnRDb250cm9sbGVyX2luc3RhbmNlcywgX0Fubm91bmNlbWVudENvbnRyb2xsZXJfYWRkQW5ub3VuY2VtZW50cztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQW5ub3VuY2VtZW50Q29udHJvbGxlciA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfY29udHJvbGxlcl8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9iYXNlLWNvbnRyb2xsZXJcIik7XG5jb25zdCBjb250cm9sbGVyTmFtZSA9ICdBbm5vdW5jZW1lbnRDb250cm9sbGVyJztcbmNvbnN0IGRlZmF1bHRTdGF0ZSA9IHtcbiAgICBhbm5vdW5jZW1lbnRzOiB7fSxcbn07XG5jb25zdCBtZXRhZGF0YSA9IHtcbiAgICBhbm5vdW5jZW1lbnRzOiB7XG4gICAgICAgIHBlcnNpc3Q6IHRydWUsXG4gICAgICAgIGFub255bW91czogdHJ1ZSxcbiAgICB9LFxufTtcbi8qKlxuICogQ29udHJvbGxlciBmb3IgbWFuYWdpbmcgaW4tYXBwIGFubm91bmNlbWVudHMuXG4gKi9cbmNsYXNzIEFubm91bmNlbWVudENvbnRyb2xsZXIgZXh0ZW5kcyBiYXNlX2NvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlclYyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgQW5ub3VuY2VtZW50Q29udHJvbGxlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byB0aGlzIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSBhcmdzLm1lc3NlbmdlciAtIE1lc3NlbmdlciB1c2VkIHRvIGNvbW11bmljYXRlIHdpdGggQmFzZVYyIGNvbnRyb2xsZXIuXG4gICAgICogQHBhcmFtIGFyZ3Muc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICogQHBhcmFtIGFyZ3MuYWxsQW5ub3VuY2VtZW50cyAtIEFubm91bmNlbWVudHMgdG8gYmUgcGFzc2VkIHRocm91Z2ggdG8gI2FkZEFubm91bmNlbWVudHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IG1lc3Nlbmdlciwgc3RhdGUsIGFsbEFubm91bmNlbWVudHMsIH0pIHtcbiAgICAgICAgY29uc3QgbWVyZ2VkU3RhdGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRTdGF0ZSksIHN0YXRlKTtcbiAgICAgICAgc3VwZXIoeyBtZXNzZW5nZXIsIG1ldGFkYXRhLCBuYW1lOiBjb250cm9sbGVyTmFtZSwgc3RhdGU6IG1lcmdlZFN0YXRlIH0pO1xuICAgICAgICBfQW5ub3VuY2VtZW50Q29udHJvbGxlcl9pbnN0YW5jZXMuYWRkKHRoaXMpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bbm5vdW5jZW1lbnRDb250cm9sbGVyX2luc3RhbmNlcywgXCJtXCIsIF9Bbm5vdW5jZW1lbnRDb250cm9sbGVyX2FkZEFubm91bmNlbWVudHMpLmNhbGwodGhpcywgYWxsQW5ub3VuY2VtZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHN0YXR1cyBvZiB0aGUgc3RhdHVzIG9mIHRoZSBzcGVjaWZpZWQgYW5ub3VuY2VtZW50c1xuICAgICAqIG9uY2UgaXQgaXMgcmVhZCBieSB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2aWV3ZWRJZHMgLSBUaGUgYW5ub3VuY2VtZW50IElEcyB0byBtYXJrIGFzIHZpZXdlZC5cbiAgICAgKi9cbiAgICB1cGRhdGVWaWV3ZWQodmlld2VkSWRzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCh7IGFubm91bmNlbWVudHMgfSkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpZCBvZiBPYmplY3Qua2V5cyh2aWV3ZWRJZHMpLm1hcChOdW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgYW5ub3VuY2VtZW50c1tpZF0uaXNTaG93biA9IHZpZXdlZElkc1tpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQW5ub3VuY2VtZW50Q29udHJvbGxlciA9IEFubm91bmNlbWVudENvbnRyb2xsZXI7XG5fQW5ub3VuY2VtZW50Q29udHJvbGxlcl9pbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpLCBfQW5ub3VuY2VtZW50Q29udHJvbGxlcl9hZGRBbm5vdW5jZW1lbnRzID0gZnVuY3Rpb24gX0Fubm91bmNlbWVudENvbnRyb2xsZXJfYWRkQW5ub3VuY2VtZW50cyhhbGxBbm5vdW5jZW1lbnRzKSB7XG4gICAgdGhpcy51cGRhdGUoKHN0YXRlKSA9PiB7XG4gICAgICAgIE9iamVjdC52YWx1ZXMoYWxsQW5ub3VuY2VtZW50cykuZm9yRWFjaCgoYW5ub3VuY2VtZW50KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBzdGF0ZS5hbm5vdW5jZW1lbnRzW2Fubm91bmNlbWVudC5pZF0gPSAoX2EgPSBzdGF0ZS5hbm5vdW5jZW1lbnRzW2Fubm91bmNlbWVudC5pZF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYW5ub3VuY2VtZW50KSwgeyBpc1Nob3duOiBmYWxzZSB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QW5ub3VuY2VtZW50Q29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0Fubm91bmNlbWVudENvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFwcHJvdmFsQ29udHJvbGxlciA9IHZvaWQgMDtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG5jb25zdCBuYW5vaWRfMSA9IHJlcXVpcmUoXCJuYW5vaWRcIik7XG5jb25zdCBiYXNlX2NvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svYmFzZS1jb250cm9sbGVyXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCBjb250cm9sbGVyTmFtZSA9ICdBcHByb3ZhbENvbnRyb2xsZXInO1xuY29uc3Qgc3RhdGVNZXRhZGF0YSA9IHtcbiAgICBwZW5kaW5nQXBwcm92YWxzOiB7IHBlcnNpc3Q6IGZhbHNlLCBhbm9ueW1vdXM6IHRydWUgfSxcbiAgICBwZW5kaW5nQXBwcm92YWxDb3VudDogeyBwZXJzaXN0OiBmYWxzZSwgYW5vbnltb3VzOiBmYWxzZSB9LFxufTtcbmNvbnN0IGdldEFscmVhZHlQZW5kaW5nTWVzc2FnZSA9IChvcmlnaW4sIHR5cGUpID0+IGBSZXF1ZXN0IG9mIHR5cGUgJyR7dHlwZX0nIGFscmVhZHkgcGVuZGluZyBmb3Igb3JpZ2luICR7b3JpZ2lufS4gUGxlYXNlIHdhaXQuYDtcbmNvbnN0IGdldERlZmF1bHRTdGF0ZSA9ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwZW5kaW5nQXBwcm92YWxzOiB7fSxcbiAgICAgICAgcGVuZGluZ0FwcHJvdmFsQ291bnQ6IDAsXG4gICAgfTtcbn07XG4vKipcbiAqIENvbnRyb2xsZXIgZm9yIG1hbmFnaW5nIHJlcXVlc3RzIHRoYXQgcmVxdWlyZSB1c2VyIGFwcHJvdmFsLlxuICpcbiAqIEVuYWJsZXMgbGltaXRpbmcgdGhlIG51bWJlciBvZiBwZW5kaW5nIHJlcXVlc3RzIGJ5IG9yaWdpbiBhbmQgdHlwZSwgY291bnRpbmdcbiAqIHBlbmRpbmcgcmVxdWVzdHMsIGFuZCBtb3JlLlxuICpcbiAqIEFkZGluZyBhIHJlcXVlc3QgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBvciByZWplY3RzIHdoZW4gdGhlIHJlcXVlc3RcbiAqIGlzIGFwcHJvdmVkIG9yIGRlbmllZCwgcmVzcGVjdGl2ZWx5LlxuICovXG5jbGFzcyBBcHByb3ZhbENvbnRyb2xsZXIgZXh0ZW5kcyBiYXNlX2NvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlclYyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYW4gQXBwcm92YWwgY29udHJvbGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGNvbnRyb2xsZXIgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zaG93QXBwcm92YWxSZXF1ZXN0IC0gRnVuY3Rpb24gZm9yIG9wZW5pbmcgdGhlIFVJIHN1Y2ggdGhhdFxuICAgICAqIHRoZSByZXF1ZXN0IGNhbiBiZSBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubWVzc2VuZ2VyIC0gVGhlIHJlc3RyaWN0ZWQgY29udHJvbGxlciBtZXNzZW5nZXIgZm9yIHRoZSBBcHByb3ZhbCBjb250cm9sbGVyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnN0YXRlIC0gVGhlIGluaXRpYWwgY29udHJvbGxlciBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50eXBlc0V4Y2x1ZGVkRnJvbVJhdGVMaW1pdGluZyAtIEFycmF5IG9mIGFwcm92YWwgdHlwZXMgd2hpY2ggYWxsb3cgbXVsdGlwbGUgcGVuZGluZyBhcHByb3ZhbCByZXF1ZXN0cyBmcm9tIHRoZSBzYW1lIG9yaWdpbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IG1lc3Nlbmdlciwgc2hvd0FwcHJvdmFsUmVxdWVzdCwgc3RhdGUgPSB7fSwgdHlwZXNFeGNsdWRlZEZyb21SYXRlTGltaXRpbmcgPSBbXSwgfSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBuYW1lOiBjb250cm9sbGVyTmFtZSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBzdGF0ZU1ldGFkYXRhLFxuICAgICAgICAgICAgbWVzc2VuZ2VyLFxuICAgICAgICAgICAgc3RhdGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZ2V0RGVmYXVsdFN0YXRlKCkpLCBzdGF0ZSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9hcHByb3ZhbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX29yaWdpbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3Nob3dBcHByb3ZhbFJlcXVlc3QgPSBzaG93QXBwcm92YWxSZXF1ZXN0O1xuICAgICAgICB0aGlzLl90eXBlc0V4Y2x1ZGVkRnJvbVJhdGVMaW1pdGluZyA9IHR5cGVzRXhjbHVkZWRGcm9tUmF0ZUxpbWl0aW5nO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXJzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGhlbHBlciBmb3IgcmVnaXN0ZXJpbmcgdGhpcyBjb250cm9sbGVyJ3MgbWVzc2FnaW5nIHN5c3RlbVxuICAgICAqIGFjdGlvbnMuXG4gICAgICovXG4gICAgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcnMoKSB7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06Y2xlYXJSZXF1ZXN0c2AsIHRoaXMuY2xlYXIuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06YWRkUmVxdWVzdGAsIChvcHRzLCBzaG91bGRTaG93UmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNob3VsZFNob3dSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkQW5kU2hvd0FwcHJvdmFsUmVxdWVzdChvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvcHRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06aGFzUmVxdWVzdGAsIHRoaXMuaGFzLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYCR7Y29udHJvbGxlck5hbWV9OmFjY2VwdFJlcXVlc3RgLCB0aGlzLmFjY2VwdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTpyZWplY3RSZXF1ZXN0YCwgdGhpcy5yZWplY3QuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06dXBkYXRlUmVxdWVzdFN0YXRlYCwgdGhpcy51cGRhdGVSZXF1ZXN0U3RhdGUuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gYXBwcm92YWwgcmVxdWVzdCBwZXIgdGhlIGdpdmVuIGFyZ3VtZW50cywgY2FsbHMgdGhlIHNob3cgYXBwcm92YWxcbiAgICAgKiByZXF1ZXN0IGZ1bmN0aW9uLCBhbmQgcmV0dXJucyB0aGUgYXNzb2NpYXRlZCBhcHByb3ZhbCBwcm9taXNlLlxuICAgICAqXG4gICAgICogVGhlcmUgY2FuIG9ubHkgYmUgb25lIGFwcHJvdmFsIHBlciBvcmlnaW4gYW5kIHR5cGUuIEFuIGVycm9yIGlzIHRocm93biBpZlxuICAgICAqIGF0dGVtcHRpbmcgdG8gYWRkIGFuIGludmFsaWQgb3IgZHVwbGljYXRlIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgYmFnLlxuICAgICAqIEBwYXJhbSBvcHRzLmlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LiBBIHJhbmRvbSBpZCB3aWxsIGJlXG4gICAgICogZ2VuZXJhdGVkIGlmIG5vbmUgaXMgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIG9wdHMub3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gb3B0cy50eXBlIC0gVGhlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBvcHRzLnJlcXVlc3REYXRhIC0gQWRkaXRpb25hbCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVxdWVzdCxcbiAgICAgKiBAcGFyYW0gb3B0cy5yZXF1ZXN0U3RhdGUgLSBBZGRpdGlvbmFsIHN0YXRlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVxdWVzdCxcbiAgICAgKiBpZiBhbnkuXG4gICAgICogQHJldHVybnMgVGhlIGFwcHJvdmFsIHByb21pc2UuXG4gICAgICovXG4gICAgYWRkQW5kU2hvd0FwcHJvdmFsUmVxdWVzdChvcHRzKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLl9hZGQob3B0cy5vcmlnaW4sIG9wdHMudHlwZSwgb3B0cy5pZCwgb3B0cy5yZXF1ZXN0RGF0YSwgb3B0cy5yZXF1ZXN0U3RhdGUpO1xuICAgICAgICB0aGlzLl9zaG93QXBwcm92YWxSZXF1ZXN0KCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGFwcHJvdmFsIHJlcXVlc3QgcGVyIHRoZSBnaXZlbiBhcmd1bWVudHMgYW5kIHJldHVybnMgdGhlIGFwcHJvdmFsXG4gICAgICogcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBhcHByb3ZhbCBwZXIgb3JpZ2luIGFuZCB0eXBlLiBBbiBlcnJvciBpcyB0aHJvd24gaWZcbiAgICAgKiBhdHRlbXB0aW5nIHRvIGFkZCBhbiBpbnZhbGlkIG9yIGR1cGxpY2F0ZSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25zIGJhZy5cbiAgICAgKiBAcGFyYW0gb3B0cy5pZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC4gQSByYW5kb20gaWQgd2lsbCBiZVxuICAgICAqIGdlbmVyYXRlZCBpZiBub25lIGlzIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSBvcHRzLm9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIG9wdHMudHlwZSAtIFRoZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gb3B0cy5yZXF1ZXN0RGF0YSAtIEFkZGl0aW9uYWwgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIHJlcXVlc3QsXG4gICAgICogaWYgYW55LlxuICAgICAqIEByZXR1cm5zIFRoZSBhcHByb3ZhbCBwcm9taXNlLlxuICAgICAqL1xuICAgIGFkZChvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGQob3B0cy5vcmlnaW4sIG9wdHMudHlwZSwgb3B0cy5pZCwgb3B0cy5yZXF1ZXN0RGF0YSwgb3B0cy5yZXF1ZXN0U3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmZvIGZvciB0aGUgYXBwcm92YWwgcmVxdWVzdCB3aXRoIHRoZSBnaXZlbiBpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgYXBwcm92YWwgcmVxdWVzdCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgaWQuXG4gICAgICovXG4gICAgZ2V0KGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnBlbmRpbmdBcHByb3ZhbHNbaWRdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgcGVuZGluZyBhcHByb3ZhbHMsIGJ5IG9yaWdpbiBhbmQvb3IgdHlwZS5cbiAgICAgKlxuICAgICAqIElmIG9ubHkgYG9yaWdpbmAgaXMgc3BlY2lmaWVkLCBhbGwgYXBwcm92YWxzIGZvciB0aGF0IG9yaWdpbiB3aWxsIGJlXG4gICAgICogY291bnRlZCwgcmVnYXJkbGVzcyBvZiB0eXBlLlxuICAgICAqIElmIG9ubHkgYHR5cGVgIGlzIHNwZWNpZmllZCwgYWxsIGFwcHJvdmFscyBmb3IgdGhhdCB0eXBlIHdpbGwgYmUgY291bnRlZCxcbiAgICAgKiByZWdhcmRsZXNzIG9mIG9yaWdpbi5cbiAgICAgKiBJZiBib3RoIGBvcmlnaW5gIGFuZCBgdHlwZWAgYXJlIHNwZWNpZmllZCwgMCBvciAxIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIFRoZSBhcHByb3ZhbCBjb3VudCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRzLm9yaWdpbiAtIEFuIGFwcHJvdmFsIG9yaWdpbi5cbiAgICAgKiBAcGFyYW0gb3B0cy50eXBlIC0gVGhlIHR5cGUgb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgYXBwcm92YWwgcmVxdWVzdCBjb3VudCBmb3IgdGhlIGdpdmVuIG9yaWdpbiBhbmQvb3JcbiAgICAgKiB0eXBlLlxuICAgICAqL1xuICAgIGdldEFwcHJvdmFsQ291bnQob3B0cyA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFvcHRzLm9yaWdpbiAmJiAhb3B0cy50eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3BlY2lmeSBvcmlnaW4sIHR5cGUsIG9yIGJvdGguJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvcmlnaW4sIHR5cGU6IF90eXBlIH0gPSBvcHRzO1xuICAgICAgICBpZiAob3JpZ2luICYmIF90eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuX29yaWdpbnMuZ2V0KG9yaWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoX3R5cGUpKSB8fCAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKCh0aGlzLl9vcmlnaW5zLmdldChvcmlnaW4pIHx8IG5ldyBNYXAoKSkudmFsdWVzKCkpLnJlZHVjZSgodG90YWwsIHZhbHVlKSA9PiB0b3RhbCArIHZhbHVlLCAwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IFwidHlwZVwiIHdhcyBzcGVjaWZpZWRcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBhcHByb3ZhbCBvZiBPYmplY3QudmFsdWVzKHRoaXMuc3RhdGUucGVuZGluZ0FwcHJvdmFscykpIHtcbiAgICAgICAgICAgIGlmIChhcHByb3ZhbC50eXBlID09PSBfdHlwZSkge1xuICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRvdGFsIGNvdW50IG9mIGFsbCBwZW5kaW5nIGFwcHJvdmFsIHJlcXVlc3RzIGZvciBhbGwgb3JpZ2lucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSB0b3RhbCBwZW5kaW5nIGFwcHJvdmFsIHJlcXVlc3QgY291bnQuXG4gICAgICovXG4gICAgZ2V0VG90YWxBcHByb3ZhbENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5wZW5kaW5nQXBwcm92YWxDb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZXJlJ3MgYSBwZW5kaW5nIGFwcHJvdmFsIHJlcXVlc3QgcGVyIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxuICAgICAqIEF0IGxlYXN0IG9uZSBwYXJhbWV0ZXIgbXVzdCBiZSBzcGVjaWZpZWQuIEFuIGVycm9yIHdpbGwgYmUgdGhyb3duIGlmIHRoZVxuICAgICAqIHBhcmFtZXRlcnMgYXJlIGludmFsaWQuXG4gICAgICpcbiAgICAgKiBJZiBgaWRgIGlzIHNwZWNpZmllZCwgYWxsIG90aGVyIHBhcmFtZXRlcnMgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqIElmIGBpZGAgaXMgbm90IHNwZWNpZmllZCwgdGhlIG1ldGhvZCB3aWxsIGNoZWNrIGZvciByZXF1ZXN0cyB0aGF0IG1hdGNoXG4gICAgICogYWxsIG9mIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyBiYWcuXG4gICAgICogQHBhcmFtIG9wdHMuaWQgLSBUaGUgSUQgdG8gY2hlY2sgZm9yLlxuICAgICAqIEBwYXJhbSBvcHRzLm9yaWdpbiAtIFRoZSBvcmlnaW4gdG8gY2hlY2sgZm9yLlxuICAgICAqIEBwYXJhbSBvcHRzLnR5cGUgLSBUaGUgdHlwZSB0byBjaGVjayBmb3IuXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIGEgbWF0Y2hpbmcgYXBwcm92YWwgaXMgZm91bmQsIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBoYXMob3B0cyA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBpZCwgb3JpZ2luLCB0eXBlOiBfdHlwZSB9ID0gb3B0cztcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWF5IG5vdCBzcGVjaWZ5IG5vbi1zdHJpbmcgaWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBwcm92YWxzLmhhcyhpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90eXBlICYmIHR5cGVvZiBfdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWF5IG5vdCBzcGVjaWZ5IG5vbi1zdHJpbmcgdHlwZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01heSBub3Qgc3BlY2lmeSBub24tc3RyaW5nIG9yaWdpbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIG9yaWdpbiBhbmQgdHlwZSBwYWlyIGlmIHR5cGUgYWxzbyBzcGVjaWZpZWRcbiAgICAgICAgICAgIGlmIChfdHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKChfYSA9IHRoaXMuX29yaWdpbnMuZ2V0KG9yaWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoX3R5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5zLmhhcyhvcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdHlwZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBhcHByb3ZhbCBvZiBPYmplY3QudmFsdWVzKHRoaXMuc3RhdGUucGVuZGluZ0FwcHJvdmFscykpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXBwcm92YWwudHlwZSA9PT0gX3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzcGVjaWZ5IGEgdmFsaWQgY29tYmluYXRpb24gb2YgaWQsIG9yaWdpbiwgYW5kIHR5cGUuJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSBwcm9taXNlIG9mIHRoZSBhcHByb3ZhbCB3aXRoIHRoZSBnaXZlbiBpZCwgYW5kIGRlbGV0ZXMgdGhlXG4gICAgICogYXBwcm92YWwuIFRocm93cyBhbiBlcnJvciBpZiBubyBzdWNoIGFwcHJvdmFsIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcmVzb2x2ZSB0aGUgYXBwcm92YWwgcHJvbWlzZSB3aXRoLlxuICAgICAqL1xuICAgIGFjY2VwdChpZCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGVsZXRlQXBwcm92YWxBbmRHZXRDYWxsYmFja3MoaWQpLnJlc29sdmUodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWplY3RzIHRoZSBwcm9taXNlIG9mIHRoZSBhcHByb3ZhbCB3aXRoIHRoZSBnaXZlbiBpZCwgYW5kIGRlbGV0ZXMgdGhlXG4gICAgICogYXBwcm92YWwuIFRocm93cyBhbiBlcnJvciBpZiBubyBzdWNoIGFwcHJvdmFsIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gcmVqZWN0IHRoZSBhcHByb3ZhbCBwcm9taXNlIHdpdGguXG4gICAgICovXG4gICAgcmVqZWN0KGlkLCBlcnJvcikge1xuICAgICAgICB0aGlzLl9kZWxldGVBcHByb3ZhbEFuZEdldENhbGxiYWNrcyhpZCkucmVqZWN0KGVycm9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVqZWN0cyBhbmQgZGVsZXRlcyBhbGwgYXBwcm92YWwgcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVqZWN0aW9uRXJyb3IgLSBUaGUgRXRoZXJldW1ScGNFcnJvciB0byByZWplY3QgdGhlIGFwcHJvdmFsXG4gICAgICogcmVxdWVzdHMgd2l0aC5cbiAgICAgKi9cbiAgICBjbGVhcihyZWplY3Rpb25FcnJvcikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIHRoaXMuX2FwcHJvdmFscy5rZXlzKCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0KGlkLCByZWplY3Rpb25FcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3JpZ2lucy5jbGVhcigpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgoKSA9PiBnZXREZWZhdWx0U3RhdGUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHJlcXVlc3Qgc3RhdGUgb2YgdGhlIGFwcHJvdmFsIHdpdGggdGhlIGdpdmVuIGlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25zIGJhZy5cbiAgICAgKiBAcGFyYW0gb3B0cy5pZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gb3B0cy5yZXF1ZXN0U3RhdGUgLSBBZGRpdGlvbmFsIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSByZXF1ZXN0XG4gICAgICovXG4gICAgdXBkYXRlUmVxdWVzdFN0YXRlKG9wdHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLnBlbmRpbmdBcHByb3ZhbHNbb3B0cy5pZF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5BcHByb3ZhbFJlcXVlc3ROb3RGb3VuZEVycm9yKG9wdHMuaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKChkcmFmdFN0YXRlKSA9PiB7XG4gICAgICAgICAgICAvLyBUeXBlY2FzdDogdHMoMjU4OSlcbiAgICAgICAgICAgIGRyYWZ0U3RhdGUucGVuZGluZ0FwcHJvdmFsc1tvcHRzLmlkXS5yZXF1ZXN0U3RhdGUgPVxuICAgICAgICAgICAgICAgIG9wdHMucmVxdWVzdFN0YXRlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50YXRpb24gb2YgYWRkIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdERhdGEgLSBUaGUgcmVxdWVzdCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdFN0YXRlIC0gVGhlIHJlcXVlc3Qgc3RhdGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBhcHByb3ZhbCBwcm9taXNlLlxuICAgICAqL1xuICAgIF9hZGQob3JpZ2luLCB0eXBlLCBpZCA9ICgwLCBuYW5vaWRfMS5uYW5vaWQpKCksIHJlcXVlc3REYXRhLCByZXF1ZXN0U3RhdGUpIHtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVBZGRQYXJhbXMoaWQsIG9yaWdpbiwgdHlwZSwgcmVxdWVzdERhdGEsIHJlcXVlc3RTdGF0ZSk7XG4gICAgICAgIGlmICghdGhpcy5fdHlwZXNFeGNsdWRlZEZyb21SYXRlTGltaXRpbmcuaW5jbHVkZXModHlwZSkgJiZcbiAgICAgICAgICAgIHRoaXMuaGFzKHsgb3JpZ2luLCB0eXBlIH0pKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMucmVzb3VyY2VVbmF2YWlsYWJsZShnZXRBbHJlYWR5UGVuZGluZ01lc3NhZ2Uob3JpZ2luLCB0eXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIHBlbmRpbmcgYXBwcm92YWxcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2FwcHJvdmFscy5zZXQoaWQsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgICAgICAgdGhpcy5fYWRkUGVuZGluZ0FwcHJvdmFsT3JpZ2luKG9yaWdpbiwgdHlwZSk7XG4gICAgICAgICAgICB0aGlzLl9hZGRUb1N0b3JlKGlkLCBvcmlnaW4sIHR5cGUsIHJlcXVlc3REYXRhLCByZXF1ZXN0U3RhdGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHBhcmFtZXRlcnMgdG8gdGhlIGFkZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHJlcXVlc3REYXRhIC0gVGhlIHJlcXVlc3QgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHJlcXVlc3RTdGF0ZSAtIFRoZSByZXF1ZXN0IHN0YXRlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBfdmFsaWRhdGVBZGRQYXJhbXMoaWQsIG9yaWdpbiwgdHlwZSwgcmVxdWVzdERhdGEsIHJlcXVlc3RTdGF0ZSkge1xuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgaWYgKCFpZCB8fCB0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnTXVzdCBzcGVjaWZ5IG5vbi1lbXB0eSBzdHJpbmcgaWQuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9hcHByb3ZhbHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gYEFwcHJvdmFsIHJlcXVlc3Qgd2l0aCBpZCAnJHtpZH0nIGFscmVhZHkgZXhpc3RzLmA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW9yaWdpbiB8fCB0eXBlb2Ygb3JpZ2luICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gJ011c3Qgc3BlY2lmeSBub24tZW1wdHkgc3RyaW5nIG9yaWdpbi4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0eXBlIHx8IHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gJ011c3Qgc3BlY2lmeSBub24tZW1wdHkgc3RyaW5nIHR5cGUuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXF1ZXN0RGF0YSAmJlxuICAgICAgICAgICAgKHR5cGVvZiByZXF1ZXN0RGF0YSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShyZXF1ZXN0RGF0YSkpKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnUmVxdWVzdCBkYXRhIG11c3QgYmUgYSBwbGFpbiBvYmplY3QgaWYgc3BlY2lmaWVkLic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVxdWVzdFN0YXRlICYmXG4gICAgICAgICAgICAodHlwZW9mIHJlcXVlc3RTdGF0ZSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShyZXF1ZXN0U3RhdGUpKSkge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gJ1JlcXVlc3Qgc3RhdGUgbXVzdCBiZSBhIHBsYWluIG9iamVjdCBpZiBzcGVjaWZpZWQuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGVudHJ5IHRvIF9vcmlnaW5zLlxuICAgICAqIFBlcmZvcm1zIG5vIHZhbGlkYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBfYWRkUGVuZGluZ0FwcHJvdmFsT3JpZ2luKG9yaWdpbiwgdHlwZSkge1xuICAgICAgICBsZXQgb3JpZ2luTWFwID0gdGhpcy5fb3JpZ2lucy5nZXQob3JpZ2luKTtcbiAgICAgICAgaWYgKCFvcmlnaW5NYXApIHtcbiAgICAgICAgICAgIG9yaWdpbk1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbnMuc2V0KG9yaWdpbiwgb3JpZ2luTWFwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBvcmlnaW5NYXAuZ2V0KHR5cGUpIHx8IDA7XG4gICAgICAgIG9yaWdpbk1hcC5zZXQodHlwZSwgY3VycmVudFZhbHVlICsgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZW50cnkgdG8gdGhlIHN0b3JlLlxuICAgICAqIFBlcmZvcm1zIG5vIHZhbGlkYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHJlcXVlc3REYXRhIC0gVGhlIHJlcXVlc3QgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHJlcXVlc3RTdGF0ZSAtIFRoZSByZXF1ZXN0IHN0YXRlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBfYWRkVG9TdG9yZShpZCwgb3JpZ2luLCB0eXBlLCByZXF1ZXN0RGF0YSwgcmVxdWVzdFN0YXRlKSB7XG4gICAgICAgIGNvbnN0IGFwcHJvdmFsID0ge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHJlcXVlc3REYXRhOiByZXF1ZXN0RGF0YSB8fCBudWxsLFxuICAgICAgICAgICAgcmVxdWVzdFN0YXRlOiByZXF1ZXN0U3RhdGUgfHwgbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGUoKGRyYWZ0U3RhdGUpID0+IHtcbiAgICAgICAgICAgIC8vIFR5cGVjYXN0OiB0cygyNTg5KVxuICAgICAgICAgICAgZHJhZnRTdGF0ZS5wZW5kaW5nQXBwcm92YWxzW2lkXSA9IGFwcHJvdmFsO1xuICAgICAgICAgICAgZHJhZnRTdGF0ZS5wZW5kaW5nQXBwcm92YWxDb3VudCA9IE9iamVjdC5rZXlzKGRyYWZ0U3RhdGUucGVuZGluZ0FwcHJvdmFscykubGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgYXBwcm92YWwgd2l0aCB0aGUgZ2l2ZW4gaWQuIFRoZSBhcHByb3ZhbCBwcm9taXNlIG11c3QgYmVcbiAgICAgKiByZXNvbHZlZCBvciByZWplY3QgYmVmb3JlIHRoaXMgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgKiBEZWxldGlvbiBpcyBhbiBpbnRlcm5hbCBvcGVyYXRpb24gYmVjYXVzZSBhcHByb3ZhbCBzdGF0ZSBpcyBzb2xlbHlcbiAgICAgKiBtYW5hZ2VkIGJ5IHRoaXMgY29udHJvbGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdCB0byBiZSBkZWxldGVkLlxuICAgICAqL1xuICAgIF9kZWxldGUoaWQpIHtcbiAgICAgICAgdGhpcy5fYXBwcm92YWxzLmRlbGV0ZShpZCk7XG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIG9ubHkgY2FsbGVkIGFmdGVyIHZlcmlmeWluZyB0aGF0IHRoZSBhcHByb3ZhbCB3aXRoIHRoZVxuICAgICAgICAvLyBzcGVjaWZpZWQgaWQgZXhpc3RzLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBjb25zdCB7IG9yaWdpbiwgdHlwZSB9ID0gdGhpcy5zdGF0ZS5wZW5kaW5nQXBwcm92YWxzW2lkXTtcbiAgICAgICAgY29uc3Qgb3JpZ2luTWFwID0gdGhpcy5fb3JpZ2lucy5nZXQob3JpZ2luKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luVG90YWxDb3VudCA9IHRoaXMuZ2V0QXBwcm92YWxDb3VudCh7IG9yaWdpbiB9KTtcbiAgICAgICAgY29uc3Qgb3JpZ2luVHlwZUNvdW50ID0gb3JpZ2luTWFwLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKG9yaWdpblRvdGFsQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbnMuZGVsZXRlKG9yaWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcmlnaW5NYXAuc2V0KHR5cGUsIG9yaWdpblR5cGVDb3VudCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKChkcmFmdFN0YXRlKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgZHJhZnRTdGF0ZS5wZW5kaW5nQXBwcm92YWxzW2lkXTtcbiAgICAgICAgICAgIGRyYWZ0U3RhdGUucGVuZGluZ0FwcHJvdmFsQ291bnQgPSBPYmplY3Qua2V5cyhkcmFmdFN0YXRlLnBlbmRpbmdBcHByb3ZhbHMpLmxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFwcHJvdmFsIGNhbGxiYWNrcyBmb3IgdGhlIGdpdmVuIGlkLCBkZWxldGVzIHRoZSBlbnRyeSwgYW5kIHRoZW5cbiAgICAgKiByZXR1cm5zIHRoZSBjYWxsYmFja3MgZm9yIHByb21pc2UgcmVzb2x1dGlvbi5cbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgbm8gYXBwcm92YWwgaXMgZm91bmQgZm9yIHRoZSBnaXZlbiBpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcHJvbWlzZSBjYWxsYmFja3MgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqL1xuICAgIF9kZWxldGVBcHByb3ZhbEFuZEdldENhbGxiYWNrcyhpZCkge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLl9hcHByb3ZhbHMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5BcHByb3ZhbFJlcXVlc3ROb3RGb3VuZEVycm9yKGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kZWxldGUoaWQpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2tzO1xuICAgIH1cbn1cbmV4cG9ydHMuQXBwcm92YWxDb250cm9sbGVyID0gQXBwcm92YWxDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXBwcm92YWxDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXBwcm92YWxDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BcHByb3ZhbFJlcXVlc3ROb3RGb3VuZEVycm9yID0gdm9pZCAwO1xuY2xhc3MgQXBwcm92YWxSZXF1ZXN0Tm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihpZCkge1xuICAgICAgICBzdXBlcihgQXBwcm92YWwgcmVxdWVzdCB3aXRoIGlkICcke2lkfScgbm90IGZvdW5kLmApO1xuICAgIH1cbn1cbmV4cG9ydHMuQXBwcm92YWxSZXF1ZXN0Tm90Rm91bmRFcnJvciA9IEFwcHJvdmFsUmVxdWVzdE5vdEZvdW5kRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9BcHByb3ZhbENvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Vycm9yc1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJsZXQgeyB1cmxBbHBoYWJldCB9ID0gcmVxdWlyZSgnLi91cmwtYWxwaGFiZXQvaW5kZXguY2pzJylcbmxldCByYW5kb20gPSBieXRlcyA9PiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzKSlcbmxldCBjdXN0b21SYW5kb20gPSAoYWxwaGFiZXQsIGRlZmF1bHRTaXplLCBnZXRSYW5kb20pID0+IHtcbiAgbGV0IG1hc2sgPSAoMiA8PCAoTWF0aC5sb2coYWxwaGFiZXQubGVuZ3RoIC0gMSkgLyBNYXRoLkxOMikpIC0gMVxuICBsZXQgc3RlcCA9IC1+KCgxLjYgKiBtYXNrICogZGVmYXVsdFNpemUpIC8gYWxwaGFiZXQubGVuZ3RoKVxuICByZXR1cm4gKHNpemUgPSBkZWZhdWx0U2l6ZSkgPT4ge1xuICAgIGxldCBpZCA9ICcnXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGxldCBieXRlcyA9IGdldFJhbmRvbShzdGVwKVxuICAgICAgbGV0IGogPSBzdGVwXG4gICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgIGlkICs9IGFscGhhYmV0W2J5dGVzW2pdICYgbWFza10gfHwgJydcbiAgICAgICAgaWYgKGlkLmxlbmd0aCA9PT0gc2l6ZSkgcmV0dXJuIGlkXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5sZXQgY3VzdG9tQWxwaGFiZXQgPSAoYWxwaGFiZXQsIHNpemUgPSAyMSkgPT5cbiAgY3VzdG9tUmFuZG9tKGFscGhhYmV0LCBzaXplLCByYW5kb20pXG5sZXQgbmFub2lkID0gKHNpemUgPSAyMSkgPT5cbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShzaXplKSkucmVkdWNlKChpZCwgYnl0ZSkgPT4ge1xuICAgIGJ5dGUgJj0gNjNcbiAgICBpZiAoYnl0ZSA8IDM2KSB7XG4gICAgICBpZCArPSBieXRlLnRvU3RyaW5nKDM2KVxuICAgIH0gZWxzZSBpZiAoYnl0ZSA8IDYyKSB7XG4gICAgICBpZCArPSAoYnl0ZSAtIDI2KS50b1N0cmluZygzNikudG9VcHBlckNhc2UoKVxuICAgIH0gZWxzZSBpZiAoYnl0ZSA+IDYyKSB7XG4gICAgICBpZCArPSAnLSdcbiAgICB9IGVsc2Uge1xuICAgICAgaWQgKz0gJ18nXG4gICAgfVxuICAgIHJldHVybiBpZFxuICB9LCAnJylcbm1vZHVsZS5leHBvcnRzID0geyBuYW5vaWQsIGN1c3RvbUFscGhhYmV0LCBjdXN0b21SYW5kb20sIHVybEFscGhhYmV0LCByYW5kb20gfVxuIiwibGV0IHVybEFscGhhYmV0ID1cbiAgJ3VzZWFuZG9tLTI2VDE5ODM0MFBYNzVweEpBQ0tWRVJZTUlOREJVU0hXT0xGX0dRWmJmZ2hqa2xxdnd5enJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IHsgdXJsQWxwaGFiZXQgfVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdlbmVyYXRlU2FsdCA9IGV4cG9ydHMuc2VyaWFsaXplQnVmZmVyRm9yU3RvcmFnZSA9IGV4cG9ydHMuc2VyaWFsaXplQnVmZmVyRnJvbVN0b3JhZ2UgPSBleHBvcnRzLmtleUZyb21QYXNzd29yZCA9IGV4cG9ydHMuZXhwb3J0S2V5ID0gZXhwb3J0cy5pbXBvcnRLZXkgPSBleHBvcnRzLmRlY3J5cHRXaXRoS2V5ID0gZXhwb3J0cy5kZWNyeXB0V2l0aERldGFpbCA9IGV4cG9ydHMuZGVjcnlwdCA9IGV4cG9ydHMuZW5jcnlwdFdpdGhLZXkgPSBleHBvcnRzLmVuY3J5cHRXaXRoRGV0YWlsID0gZXhwb3J0cy5lbmNyeXB0ID0gdm9pZCAwO1xuY29uc3QgRVhQT1JUX0ZPUk1BVCA9ICdqd2snO1xuY29uc3QgREVSSVZFRF9LRVlfRk9STUFUID0gJ0FFUy1HQ00nO1xuY29uc3QgU1RSSU5HX0VOQ09ESU5HID0gJ3V0Zi04Jztcbi8qKlxuICogRW5jcnlwdHMgYSBkYXRhIG9iamVjdCB0aGF0IGNhbiBiZSBhbnkgc2VyaWFsaXphYmxlIHZhbHVlIHVzaW5nXG4gKiBhIHByb3ZpZGVkIHBhc3N3b3JkLlxuICpcbiAqIEBwYXJhbSBwYXNzd29yZCAtIFRoZSBwYXNzd29yZCB0byB1c2UgZm9yIGVuY3J5cHRpb24uXG4gKiBAcGFyYW0gZGF0YU9iaiAtIFRoZSBkYXRhIHRvIGVuY3J5cHQuXG4gKiBAcGFyYW0ga2V5IC0gVGhlIENyeXB0b0tleSB0byBlbmNyeXB0IHdpdGguXG4gKiBAcGFyYW0gc2FsdCAtIFRoZSBzYWx0IHRvIHVzZSB0byBlbmNyeXB0LlxuICogQHJldHVybnMgVGhlIGVuY3J5cHRlZCB2YXVsdC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdChwYXNzd29yZCwgZGF0YU9iaiwga2V5LCBzYWx0ID0gZ2VuZXJhdGVTYWx0KCkpIHtcbiAgICBjb25zdCBjcnlwdG9LZXkgPSBrZXkgfHwgKGF3YWl0IGtleUZyb21QYXNzd29yZChwYXNzd29yZCwgc2FsdCkpO1xuICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCBlbmNyeXB0V2l0aEtleShjcnlwdG9LZXksIGRhdGFPYmopO1xuICAgIHBheWxvYWQuc2FsdCA9IHNhbHQ7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xufVxuZXhwb3J0cy5lbmNyeXB0ID0gZW5jcnlwdDtcbi8qKlxuICogRW5jcnlwdHMgYSBkYXRhIG9iamVjdCB0aGF0IGNhbiBiZSBhbnkgc2VyaWFsaXphYmxlIHZhbHVlIHVzaW5nXG4gKiBhIHByb3ZpZGVkIHBhc3N3b3JkLlxuICpcbiAqIEBwYXJhbSBwYXNzd29yZCAtIEEgcGFzc3dvcmQgdG8gdXNlIGZvciBlbmNyeXB0aW9uLlxuICogQHBhcmFtIGRhdGFPYmogLSBUaGUgZGF0YSB0byBlbmNyeXB0LlxuICogQHBhcmFtIHNhbHQgLSBUaGUgc2FsdCB1c2VkIHRvIGVuY3J5cHQuXG4gKiBAcmV0dXJucyBUaGUgdmF1bHQgYW5kIGV4cG9ydGVkIGtleSBzdHJpbmcuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHRXaXRoRGV0YWlsKHBhc3N3b3JkLCBkYXRhT2JqLCBzYWx0ID0gZ2VuZXJhdGVTYWx0KCkpIHtcbiAgICBjb25zdCBrZXkgPSBhd2FpdCBrZXlGcm9tUGFzc3dvcmQocGFzc3dvcmQsIHNhbHQsIHRydWUpO1xuICAgIGNvbnN0IGV4cG9ydGVkS2V5U3RyaW5nID0gYXdhaXQgZXhwb3J0S2V5KGtleSk7XG4gICAgY29uc3QgdmF1bHQgPSBhd2FpdCBlbmNyeXB0KHBhc3N3b3JkLCBkYXRhT2JqLCBrZXksIHNhbHQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHZhdWx0LFxuICAgICAgICBleHBvcnRlZEtleVN0cmluZyxcbiAgICB9O1xufVxuZXhwb3J0cy5lbmNyeXB0V2l0aERldGFpbCA9IGVuY3J5cHRXaXRoRGV0YWlsO1xuLyoqXG4gKiBFbmNyeXB0cyB0aGUgcHJvdmlkZWQgc2VyaWFsaXphYmxlIGphdmFzY3JpcHQgb2JqZWN0IHVzaW5nIHRoZVxuICogcHJvdmlkZWQgQ3J5cHRvS2V5IGFuZCByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjeXBoZXIgdGV4dCBhbmRcbiAqIHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgdXNlZC5cbiAqXG4gKiBAcGFyYW0ga2V5IC0gVGhlIENyeXB0b0tleSB0byBlbmNyeXB0IHdpdGguXG4gKiBAcGFyYW0gZGF0YU9iaiAtIEEgc2VyaWFsaXphYmxlIEphdmFTY3JpcHQgb2JqZWN0IHRvIGVuY3J5cHQuXG4gKiBAcmV0dXJucyBUaGUgZW5jcnlwdGVkIGRhdGEuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHRXaXRoS2V5KGtleSwgZGF0YU9iaikge1xuICAgIGNvbnN0IGRhdGEgPSBKU09OLnN0cmluZ2lmeShkYXRhT2JqKTtcbiAgICBjb25zdCBkYXRhQnVmZmVyID0gQnVmZmVyLmZyb20oZGF0YSwgU1RSSU5HX0VOQ09ESU5HKTtcbiAgICBjb25zdCB2ZWN0b3IgPSBnbG9iYWwuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgxNikpO1xuICAgIGNvbnN0IGJ1ZiA9IGF3YWl0IGdsb2JhbC5jcnlwdG8uc3VidGxlLmVuY3J5cHQoe1xuICAgICAgICBuYW1lOiBERVJJVkVEX0tFWV9GT1JNQVQsXG4gICAgICAgIGl2OiB2ZWN0b3IsXG4gICAgfSwga2V5LCBkYXRhQnVmZmVyKTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgIGNvbnN0IHZlY3RvclN0ciA9IEJ1ZmZlci5mcm9tKHZlY3RvcikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIGNvbnN0IHZhdWx0U3RyID0gQnVmZmVyLmZyb20oYnVmZmVyKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogdmF1bHRTdHIsXG4gICAgICAgIGl2OiB2ZWN0b3JTdHIsXG4gICAgfTtcbn1cbmV4cG9ydHMuZW5jcnlwdFdpdGhLZXkgPSBlbmNyeXB0V2l0aEtleTtcbi8qKlxuICogR2l2ZW4gYSBwYXNzd29yZCBhbmQgYSBjeXBoZXIgdGV4dCwgZGVjcnlwdHMgdGhlIHRleHQgYW5kIHJldHVybnNcbiAqIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKlxuICogQHBhcmFtIHBhc3N3b3JkIC0gVGhlIHBhc3N3b3JkIHRvIGRlY3J5cHQgd2l0aC5cbiAqIEBwYXJhbSB0ZXh0IC0gVGhlIGN5cGhlciB0ZXh0IHRvIGRlY3J5cHQuXG4gKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB0byBkZWNyeXB0IHdpdGguXG4gKiBAcmV0dXJucyBUaGUgZGVjcnlwdGVkIGRhdGEuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHQocGFzc3dvcmQsIHRleHQsIGtleSkge1xuICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKHRleHQpO1xuICAgIGNvbnN0IHsgc2FsdCB9ID0gcGF5bG9hZDtcbiAgICBjb25zdCBjcnlwdG9LZXkgPSBrZXkgfHwgKGF3YWl0IGtleUZyb21QYXNzd29yZChwYXNzd29yZCwgc2FsdCkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRlY3J5cHRXaXRoS2V5KGNyeXB0b0tleSwgcGF5bG9hZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZGVjcnlwdCA9IGRlY3J5cHQ7XG4vKipcbiAqIEdpdmVuIGEgcGFzc3dvcmQgYW5kIGEgY3lwaGVyIHRleHQsIGRlY3J5cHRzIHRoZSB0ZXh0IGFuZCByZXR1cm5zXG4gKiB0aGUgcmVzdWx0aW5nIHZhbHVlLCBrZXlTdHJpbmcsIGFuZCBzYWx0LlxuICpcbiAqIEBwYXJhbSBwYXNzd29yZCAtIFRoZSBwYXNzd29yZCB0byBkZWNyeXB0IHdpdGguXG4gKiBAcGFyYW0gdGV4dCAtIFRoZSBlbmNyeXB0ZWQgdmF1bHQgdG8gZGVjcnlwdC5cbiAqIEByZXR1cm5zIFRoZSBkZWNyeXB0ZWQgdmF1bHQgYWxvbmcgd2l0aCB0aGUgc2FsdCBhbmQgZXhwb3J0ZWQga2V5LlxuICovXG5hc3luYyBmdW5jdGlvbiBkZWNyeXB0V2l0aERldGFpbChwYXNzd29yZCwgdGV4dCkge1xuICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKHRleHQpO1xuICAgIGNvbnN0IHsgc2FsdCB9ID0gcGF5bG9hZDtcbiAgICBjb25zdCBrZXkgPSBhd2FpdCBrZXlGcm9tUGFzc3dvcmQocGFzc3dvcmQsIHNhbHQsIHRydWUpO1xuICAgIGNvbnN0IGV4cG9ydGVkS2V5U3RyaW5nID0gYXdhaXQgZXhwb3J0S2V5KGtleSk7XG4gICAgY29uc3QgdmF1bHQgPSBhd2FpdCBkZWNyeXB0KHBhc3N3b3JkLCB0ZXh0LCBrZXkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGV4cG9ydGVkS2V5U3RyaW5nLFxuICAgICAgICB2YXVsdCxcbiAgICAgICAgc2FsdCxcbiAgICB9O1xufVxuZXhwb3J0cy5kZWNyeXB0V2l0aERldGFpbCA9IGRlY3J5cHRXaXRoRGV0YWlsO1xuLyoqXG4gKiBHaXZlbiBhIENyeXB0b0tleSBhbmQgYW4gRW5jcnlwdGlvblJlc3VsdCBvYmplY3QgY29udGFpbmluZyB0aGUgaW5pdGlhbGl6YXRpb25cbiAqIHZlY3RvciAoaXYpIGFuZCBkYXRhIHRvIGRlY3J5cHQsIHJldHVybiB0aGUgcmVzdWx0aW5nIGRlY3J5cHRlZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ga2V5IC0gVGhlIENyeXB0b0tleSB0byBkZWNyeXB0IHdpdGguXG4gKiBAcGFyYW0gcGF5bG9hZCAtIFRoZSBwYXlsb2FkIHRvIGRlY3J5cHQsIHJldHVybmVkIGZyb20gYW4gZW5jcnlwdGlvbiBtZXRob2QuXG4gKiBAcmV0dXJucyBUaGUgZGVjcnlwdGVkIGRhdGEuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHRXaXRoS2V5KGtleSwgcGF5bG9hZCkge1xuICAgIGNvbnN0IGVuY3J5cHRlZERhdGEgPSBCdWZmZXIuZnJvbShwYXlsb2FkLmRhdGEsICdiYXNlNjQnKTtcbiAgICBjb25zdCB2ZWN0b3IgPSBCdWZmZXIuZnJvbShwYXlsb2FkLml2LCAnYmFzZTY0Jyk7XG4gICAgbGV0IGRlY3J5cHRlZE9iajtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRlY3J5cHQoeyBuYW1lOiBERVJJVkVEX0tFWV9GT1JNQVQsIGl2OiB2ZWN0b3IgfSwga2V5LCBlbmNyeXB0ZWREYXRhKTtcbiAgICAgICAgY29uc3QgZGVjcnlwdGVkRGF0YSA9IG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG4gICAgICAgIGNvbnN0IGRlY3J5cHRlZFN0ciA9IEJ1ZmZlci5mcm9tKGRlY3J5cHRlZERhdGEpLnRvU3RyaW5nKFNUUklOR19FTkNPRElORyk7XG4gICAgICAgIGRlY3J5cHRlZE9iaiA9IEpTT04ucGFyc2UoZGVjcnlwdGVkU3RyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgcGFzc3dvcmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY3J5cHRlZE9iajtcbn1cbmV4cG9ydHMuZGVjcnlwdFdpdGhLZXkgPSBkZWNyeXB0V2l0aEtleTtcbi8qKlxuICogUmVjZWl2ZXMgYW4gZXhwb3J0ZWQgQ3J5cHRvS2V5IHN0cmluZyBhbmQgY3JlYXRlcyBhIGtleS5cbiAqXG4gKiBAcGFyYW0ga2V5U3RyaW5nIC0gVGhlIGtleSBzdHJpbmcgdG8gaW1wb3J0LlxuICogQHJldHVybnMgQSBDcnlwdG9LZXkuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGltcG9ydEtleShrZXlTdHJpbmcpIHtcbiAgICBjb25zdCBrZXkgPSBhd2FpdCB3aW5kb3cuY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoRVhQT1JUX0ZPUk1BVCwgSlNPTi5wYXJzZShrZXlTdHJpbmcpLCBERVJJVkVEX0tFWV9GT1JNQVQsIHRydWUsIFsnZW5jcnlwdCcsICdkZWNyeXB0J10pO1xuICAgIHJldHVybiBrZXk7XG59XG5leHBvcnRzLmltcG9ydEtleSA9IGltcG9ydEtleTtcbi8qKlxuICogUmVjZWl2ZXMgYW4gZXhwb3J0ZWQgQ3J5cHRvS2V5IHN0cmluZywgY3JlYXRlcyBhIGtleSxcbiAqIGFuZCBkZWNyeXB0cyBjaXBoZXIgdGV4dCB3aXRoIHRoZSByZWNvbnN0cnVjdGVkIGtleS5cbiAqXG4gKiBAcGFyYW0ga2V5IC0gVGhlIENyeXB0b0tleSB0byBleHBvcnQuXG4gKiBAcmV0dXJucyBBIGtleSBzdHJpbmcuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV4cG9ydEtleShrZXkpIHtcbiAgICBjb25zdCBleHBvcnRlZEtleSA9IGF3YWl0IHdpbmRvdy5jcnlwdG8uc3VidGxlLmV4cG9ydEtleShFWFBPUlRfRk9STUFULCBrZXkpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShleHBvcnRlZEtleSk7XG59XG5leHBvcnRzLmV4cG9ydEtleSA9IGV4cG9ydEtleTtcbi8qKlxuICogR2VuZXJhdGUgYSBDcnlwdG9LZXkgZnJvbSBhIHBhc3N3b3JkIGFuZCByYW5kb20gc2FsdC5cbiAqXG4gKiBAcGFyYW0gcGFzc3dvcmQgLSBUaGUgcGFzc3dvcmQgdG8gdXNlIHRvIGdlbmVyYXRlIGtleS5cbiAqIEBwYXJhbSBzYWx0IC0gVGhlIHNhbHQgc3RyaW5nIHRvIHVzZSBpbiBrZXkgZGVyaXZhdGlvbi5cbiAqIEBwYXJhbSBleHBvcnRhYmxlIC0gU2hvdWxkIHRoZSBkZXJpdmVkIGtleSBiZSBleHBvcnRhYmxlLlxuICogQHJldHVybnMgQSBDcnlwdG9LZXkgZm9yIGVuY3J5cHRpb24gYW5kIGRlY3J5cHRpb24uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGtleUZyb21QYXNzd29yZChwYXNzd29yZCwgc2FsdCwgZXhwb3J0YWJsZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgcGFzc0J1ZmZlciA9IEJ1ZmZlci5mcm9tKHBhc3N3b3JkLCBTVFJJTkdfRU5DT0RJTkcpO1xuICAgIGNvbnN0IHNhbHRCdWZmZXIgPSBCdWZmZXIuZnJvbShzYWx0LCAnYmFzZTY0Jyk7XG4gICAgY29uc3Qga2V5ID0gYXdhaXQgZ2xvYmFsLmNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCBwYXNzQnVmZmVyLCB7IG5hbWU6ICdQQktERjInIH0sIGZhbHNlLCBbJ2Rlcml2ZUJpdHMnLCAnZGVyaXZlS2V5J10pO1xuICAgIGNvbnN0IGRlcml2ZWRLZXkgPSBhd2FpdCBnbG9iYWwuY3J5cHRvLnN1YnRsZS5kZXJpdmVLZXkoe1xuICAgICAgICBuYW1lOiAnUEJLREYyJyxcbiAgICAgICAgc2FsdDogc2FsdEJ1ZmZlcixcbiAgICAgICAgaXRlcmF0aW9uczogMTAwMDAsXG4gICAgICAgIGhhc2g6ICdTSEEtMjU2JyxcbiAgICB9LCBrZXksIHsgbmFtZTogREVSSVZFRF9LRVlfRk9STUFULCBsZW5ndGg6IDI1NiB9LCBleHBvcnRhYmxlLCBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKTtcbiAgICByZXR1cm4gZGVyaXZlZEtleTtcbn1cbmV4cG9ydHMua2V5RnJvbVBhc3N3b3JkID0ga2V5RnJvbVBhc3N3b3JkO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgaW50byBhIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gc3RyIC0gSGV4IGVuY29kZWQgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHN0cmluZyBlY29kZWQgYXMgYSBieXRlIGFycmF5LlxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVCdWZmZXJGcm9tU3RvcmFnZShzdHIpIHtcbiAgICBjb25zdCBzdHJpcFN0ciA9IHN0ci5zbGljZSgwLCAyKSA9PT0gJzB4JyA/IHN0ci5zbGljZSgyKSA6IHN0cjtcbiAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShzdHJpcFN0ci5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmlwU3RyLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IHNlZyA9IHN0cmlwU3RyLnN1YnN0cihpLCAyKTtcbiAgICAgICAgYnVmW2kgLyAyXSA9IHBhcnNlSW50KHNlZywgMTYpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xufVxuZXhwb3J0cy5zZXJpYWxpemVCdWZmZXJGcm9tU3RvcmFnZSA9IHNlcmlhbGl6ZUJ1ZmZlckZyb21TdG9yYWdlO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciBpbnRvIGEgaGV4IHN0cmluZyByZWFkeSBmb3Igc3RvcmFnZS5cbiAqXG4gKiBAcGFyYW0gYnVmZmVyIC0gQnVmZmVyIHRvIHNlcmlhbGl6ZS5cbiAqIEByZXR1cm5zIEEgaGV4IGVuY29kZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVCdWZmZXJGb3JTdG9yYWdlKGJ1ZmZlcikge1xuICAgIGxldCByZXN1bHQgPSAnMHgnO1xuICAgIGJ1ZmZlci5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICByZXN1bHQgKz0gdW5wcmVmaXhlZEhleCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuc2VyaWFsaXplQnVmZmVyRm9yU3RvcmFnZSA9IHNlcmlhbGl6ZUJ1ZmZlckZvclN0b3JhZ2U7XG4vKipcbiAqIENvbnZlcnRzIGEgbnVtYmVyIGludG8gaGV4IHZhbHVlLCBhbmQgZW5zdXJlcyBwcm9wZXIgbGVhZGluZyAwXG4gKiBmb3Igc2luZ2xlIGNoYXJhY3RlcnMgc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0gbnVtIC0gVGhlIG51bWJlciB0byBjb252ZXJ0IHRvIHN0cmluZy5cbiAqIEByZXR1cm5zIEFuIHVucHJlZml4ZWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdW5wcmVmaXhlZEhleChudW0pIHtcbiAgICBsZXQgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAoaGV4Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgaGV4ID0gYDAke2hleH1gO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gc3RyaW5nIGZvciB1c2UgYXMgYSBzYWx0IGluIENyeXB0b0tleSBnZW5lcmF0aW9uLlxuICpcbiAqIEBwYXJhbSBieXRlQ291bnQgLSBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICogQHJldHVybnMgQSByYW5kb21seSBnZW5lcmF0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVNhbHQoYnl0ZUNvdW50ID0gMzIpIHtcbiAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUNvdW50KTtcbiAgICBnbG9iYWwuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh2aWV3KTtcbiAgICAvLyBVaW50OEFycmF5IGlzIGEgZml4ZWQgbGVuZ3RoIGFycmF5IGFuZCB0aHVzIGRvZXMgbm90IGhhdmUgbWV0aG9kcyBsaWtlIHBvcCwgZXRjXG4gICAgLy8gc28gVHlwZVNjcmlwdCBjb21wbGFpbnMgYWJvdXQgY2FzdGluZyBpdCB0byBhbiBhcnJheS4gQXJyYXkuZnJvbSgpIHdvcmtzIGhlcmUgZm9yXG4gICAgLy8gZ2V0dGluZyB0aGUgcHJvcGVyIHR5cGUsIGJ1dCBpdCByZXN1bHRzIGluIGEgZnVuY3Rpb25hbCBkaWZmZXJlbmNlLiBJbiBvcmRlciB0b1xuICAgIC8vIGNhc3QsIHlvdSBoYXZlIHRvIGZpcnN0IGNhc3QgdmlldyB0byB1bmtub3duIHRoZW4gY2FzdCB0aGUgdW5rbm93biB2YWx1ZSB0byBudW1iZXJbXVxuICAgIC8vIFR5cGVTY3JpcHQgZnR3OiBkb3VibGUgb3B0IGluIHRvIHdyaXRlIHBvdGVudGlhbGx5IHR5cGUtbWlzbWF0Y2hlZCBjb2RlLlxuICAgIGNvbnN0IGI2NGVuY29kZWQgPSBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdmlldykpO1xuICAgIHJldHVybiBiNjRlbmNvZGVkO1xufVxuZXhwb3J0cy5nZW5lcmF0ZVNhbHQgPSBnZW5lcmF0ZVNhbHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJjb25zdCB7IEhES2V5IH0gPSByZXF1aXJlKCdldGhlcmV1bS1jcnlwdG9ncmFwaHkvaGRrZXknKTtcbmNvbnN0IHsga2VjY2FrMjU2IH0gPSByZXF1aXJlKCdldGhlcmV1bS1jcnlwdG9ncmFwaHkva2VjY2FrJyk7XG5jb25zdCB7IGJ5dGVzVG9IZXggfSA9IHJlcXVpcmUoJ2V0aGVyZXVtLWNyeXB0b2dyYXBoeS91dGlscycpO1xuY29uc3Qge1xuICBzdHJpcEhleFByZWZpeCxcbiAgcHJpdmF0ZVRvUHVibGljLFxuICBwdWJsaWNUb0FkZHJlc3MsXG4gIGVjc2lnbixcbiAgYXJyVG9CdWZBcnIsXG4gIGJ1ZmZlclRvSGV4LFxufSA9IHJlcXVpcmUoJ0BldGhlcmV1bWpzL3V0aWwnKTtcbmNvbnN0IGJpcDM5ID0gcmVxdWlyZSgnQG1ldGFtYXNrL3NjdXJlLWJpcDM5Jyk7XG5jb25zdCB7IHdvcmRsaXN0IH0gPSByZXF1aXJlKCdAbWV0YW1hc2svc2N1cmUtYmlwMzkvZGlzdC93b3JkbGlzdHMvZW5nbGlzaCcpO1xuY29uc3Qge1xuICBjb25jYXRTaWcsXG4gIGRlY3J5cHQsXG4gIGdldEVuY3J5cHRpb25QdWJsaWNLZXksXG4gIG5vcm1hbGl6ZSxcbiAgcGVyc29uYWxTaWduLFxuICBzaWduVHlwZWREYXRhLFxuICBTaWduVHlwZWREYXRhVmVyc2lvbixcbn0gPSByZXF1aXJlKCdAbWV0YW1hc2svZXRoLXNpZy11dGlsJyk7XG5cbi8vIE9wdGlvbnM6XG5jb25zdCBoZFBhdGhTdHJpbmcgPSBgbS80NCcvNjAnLzAnLzBgO1xuY29uc3QgdHlwZSA9ICdIRCBLZXkgVHJlZSc7XG5cbmNsYXNzIEhkS2V5cmluZyB7XG4gIC8qIFBVQkxJQyBNRVRIT0RTICovXG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5fd2FsbGV0cyA9IFtdO1xuICAgIHRoaXMuZGVzZXJpYWxpemUob3B0cyk7XG4gIH1cblxuICBnZW5lcmF0ZVJhbmRvbU1uZW1vbmljKCkge1xuICAgIHRoaXMuX2luaXRGcm9tTW5lbW9uaWMoYmlwMzkuZ2VuZXJhdGVNbmVtb25pYyh3b3JkbGlzdCkpO1xuICB9XG5cbiAgX3VpbnQ4QXJyYXlUb1N0cmluZyhtbmVtb25pYykge1xuICAgIGNvbnN0IHJlY292ZXJlZEluZGljZXMgPSBBcnJheS5mcm9tKFxuICAgICAgbmV3IFVpbnQxNkFycmF5KG5ldyBVaW50OEFycmF5KG1uZW1vbmljKS5idWZmZXIpLFxuICAgICk7XG4gICAgcmV0dXJuIHJlY292ZXJlZEluZGljZXMubWFwKChpKSA9PiB3b3JkbGlzdFtpXSkuam9pbignICcpO1xuICB9XG5cbiAgX3N0cmluZ1RvVWludDhBcnJheShtbmVtb25pYykge1xuICAgIGNvbnN0IGluZGljZXMgPSBtbmVtb25pYy5zcGxpdCgnICcpLm1hcCgod29yZCkgPT4gd29yZGxpc3QuaW5kZXhPZih3b3JkKSk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBVaW50MTZBcnJheShpbmRpY2VzKS5idWZmZXIpO1xuICB9XG5cbiAgX21uZW1vbmljVG9VaW50OEFycmF5KG1uZW1vbmljKSB7XG4gICAgbGV0IG1uZW1vbmljRGF0YSA9IG1uZW1vbmljO1xuICAgIC8vIHdoZW4gZW5jcnlwdGVkL2RlY3J5cHRlZCwgYnVmZmVycyBnZXQgY2FzdCBpbnRvIGpzIG9iamVjdCB3aXRoIGEgcHJvcGVydHkgdHlwZSBzZXQgdG8gYnVmZmVyXG4gICAgaWYgKG1uZW1vbmljICYmIG1uZW1vbmljLnR5cGUgJiYgbW5lbW9uaWMudHlwZSA9PT0gJ0J1ZmZlcicpIHtcbiAgICAgIG1uZW1vbmljRGF0YSA9IG1uZW1vbmljLmRhdGE7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgLy8gdGhpcyBibG9jayBpcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCB2YXVsdHMgdGhhdCB3ZXJlIHByZXZpb3VzbHkgc3RvcmVkIGFzIGJ1ZmZlcnMsIG51bWJlciBhcnJheXMgb3IgcGxhaW4gdGV4dCBzdHJpbmdzXG4gICAgICB0eXBlb2YgbW5lbW9uaWNEYXRhID09PSAnc3RyaW5nJyB8fFxuICAgICAgQnVmZmVyLmlzQnVmZmVyKG1uZW1vbmljRGF0YSkgfHxcbiAgICAgIEFycmF5LmlzQXJyYXkobW5lbW9uaWNEYXRhKVxuICAgICkge1xuICAgICAgbGV0IG1uZW1vbmljQXNTdHJpbmcgPSBtbmVtb25pY0RhdGE7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShtbmVtb25pY0RhdGEpKSB7XG4gICAgICAgIG1uZW1vbmljQXNTdHJpbmcgPSBCdWZmZXIuZnJvbShtbmVtb25pY0RhdGEpLnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihtbmVtb25pY0RhdGEpKSB7XG4gICAgICAgIG1uZW1vbmljQXNTdHJpbmcgPSBtbmVtb25pY0RhdGEudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9zdHJpbmdUb1VpbnQ4QXJyYXkobW5lbW9uaWNBc1N0cmluZyk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIG1uZW1vbmljRGF0YSBpbnN0YW5jZW9mIE9iamVjdCAmJlxuICAgICAgIShtbmVtb25pY0RhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICkge1xuICAgICAgLy8gd2hlbiBlbmNyeXB0ZWQvZGVjcnlwdGVkIHRoZSBVaW50OEFycmF5IGJlY29tZXMgYSBqcyBvYmplY3Qgd2UgbmVlZCB0byBjYXN0IGJhY2sgdG8gYSBVaW50OEFycmF5XG4gICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKE9iamVjdC52YWx1ZXMobW5lbW9uaWNEYXRhKSk7XG4gICAgfVxuICAgIHJldHVybiBtbmVtb25pY0RhdGE7XG4gIH1cblxuICBzZXJpYWxpemUoKSB7XG4gICAgY29uc3QgbW5lbW9uaWNBc1N0cmluZyA9IHRoaXMuX3VpbnQ4QXJyYXlUb1N0cmluZyh0aGlzLm1uZW1vbmljKTtcbiAgICBjb25zdCB1aW50OEFycmF5TW5lbW9uaWMgPSBuZXcgVGV4dEVuY29kZXIoJ3V0Zi04JykuZW5jb2RlKFxuICAgICAgbW5lbW9uaWNBc1N0cmluZyxcbiAgICApO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBtbmVtb25pYzogQXJyYXkuZnJvbSh1aW50OEFycmF5TW5lbW9uaWMpLFxuICAgICAgbnVtYmVyT2ZBY2NvdW50czogdGhpcy5fd2FsbGV0cy5sZW5ndGgsXG4gICAgICBoZFBhdGg6IHRoaXMuaGRQYXRoLFxuICAgIH0pO1xuICB9XG5cbiAgZGVzZXJpYWxpemUob3B0cyA9IHt9KSB7XG4gICAgaWYgKG9wdHMubnVtYmVyT2ZBY2NvdW50cyAmJiAhb3B0cy5tbmVtb25pYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnRXRoLUhkLUtleXJpbmc6IERlc2VyaWFsaXplIG1ldGhvZCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggYW4gb3B0cyB2YWx1ZSBmb3IgbnVtYmVyT2ZBY2NvdW50cyBhbmQgbm8gbWVubW9uaWMnLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdFdGgtSGQtS2V5cmluZzogU2VjcmV0IHJlY292ZXJ5IHBocmFzZSBhbHJlYWR5IHByb3ZpZGVkJyxcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5fd2FsbGV0cyA9IFtdO1xuICAgIHRoaXMubW5lbW9uaWMgPSBudWxsO1xuICAgIHRoaXMucm9vdCA9IG51bGw7XG4gICAgdGhpcy5oZFBhdGggPSBvcHRzLmhkUGF0aCB8fCBoZFBhdGhTdHJpbmc7XG5cbiAgICBpZiAob3B0cy5tbmVtb25pYykge1xuICAgICAgdGhpcy5faW5pdEZyb21NbmVtb25pYyhvcHRzLm1uZW1vbmljKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5udW1iZXJPZkFjY291bnRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGRBY2NvdW50cyhvcHRzLm51bWJlck9mQWNjb3VudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICB9XG5cbiAgYWRkQWNjb3VudHMobnVtYmVyT2ZBY2NvdW50cyA9IDEpIHtcbiAgICBpZiAoIXRoaXMucm9vdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdGgtSGQtS2V5cmluZzogTm8gc2VjcmV0IHJlY292ZXJ5IHBocmFzZSBwcm92aWRlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IG9sZExlbiA9IHRoaXMuX3dhbGxldHMubGVuZ3RoO1xuICAgIGNvbnN0IG5ld1dhbGxldHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gb2xkTGVuOyBpIDwgbnVtYmVyT2ZBY2NvdW50cyArIG9sZExlbjsgaSsrKSB7XG4gICAgICBjb25zdCB3YWxsZXQgPSB0aGlzLnJvb3QuZGVyaXZlQ2hpbGQoaSk7XG4gICAgICBuZXdXYWxsZXRzLnB1c2god2FsbGV0KTtcbiAgICAgIHRoaXMuX3dhbGxldHMucHVzaCh3YWxsZXQpO1xuICAgIH1cbiAgICBjb25zdCBoZXhXYWxsZXRzID0gbmV3V2FsbGV0cy5tYXAoKHcpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9hZGRyZXNzZnJvbVB1YmxpY0tleSh3LnB1YmxpY0tleSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShoZXhXYWxsZXRzKTtcbiAgfVxuXG4gIGdldEFjY291bnRzKCkge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXRzLm1hcCgodykgPT4gdGhpcy5fYWRkcmVzc2Zyb21QdWJsaWNLZXkody5wdWJsaWNLZXkpKTtcbiAgfVxuXG4gIC8qIEJBU0UgS0VZUklORyBNRVRIT0RTICovXG5cbiAgLy8gcmV0dXJucyBhbiBhZGRyZXNzIHNwZWNpZmljIHRvIGFuIGFwcFxuICBhc3luYyBnZXRBcHBLZXlBZGRyZXNzKGFkZHJlc3MsIG9yaWdpbikge1xuICAgIGlmICghb3JpZ2luIHx8IHR5cGVvZiBvcmlnaW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCdvcmlnaW4nIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nYCk7XG4gICAgfVxuICAgIGNvbnN0IHdhbGxldCA9IHRoaXMuX2dldFdhbGxldEZvckFjY291bnQoYWRkcmVzcywge1xuICAgICAgd2l0aEFwcEtleU9yaWdpbjogb3JpZ2luLFxuICAgIH0pO1xuICAgIGNvbnN0IGFwcEtleUFkZHJlc3MgPSBub3JtYWxpemUoXG4gICAgICBwdWJsaWNUb0FkZHJlc3Mod2FsbGV0LnB1YmxpY0tleSkudG9TdHJpbmcoJ2hleCcpLFxuICAgICk7XG5cbiAgICByZXR1cm4gYXBwS2V5QWRkcmVzcztcbiAgfVxuXG4gIC8vIGV4cG9ydEFjY291bnQgc2hvdWxkIHJldHVybiBhIGhleC1lbmNvZGVkIHByaXZhdGUga2V5OlxuICBhc3luYyBleHBvcnRBY2NvdW50KGFkZHJlc3MsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHdhbGxldCA9IHRoaXMuX2dldFdhbGxldEZvckFjY291bnQoYWRkcmVzcywgb3B0cyk7XG4gICAgcmV0dXJuIGJ5dGVzVG9IZXgod2FsbGV0LnByaXZhdGVLZXkpO1xuICB9XG5cbiAgLy8gdHggaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIGV0aGVyZXVtanMtdHJhbnNhY3Rpb24gY2xhc3MuXG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihhZGRyZXNzLCB0eCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgcHJpdktleSA9IHRoaXMuX2dldFByaXZhdGVLZXlGb3IoYWRkcmVzcywgb3B0cyk7XG4gICAgY29uc3Qgc2lnbmVkVHggPSB0eC5zaWduKHByaXZLZXkpO1xuICAgIC8vIE5ld2VyIHZlcnNpb25zIG9mIEV0aGVyZXVtanMtdHggYXJlIGltbXV0YWJsZSBhbmQgcmV0dXJuIGEgbmV3IHR4IG9iamVjdFxuICAgIHJldHVybiBzaWduZWRUeCA9PT0gdW5kZWZpbmVkID8gdHggOiBzaWduZWRUeDtcbiAgfVxuXG4gIC8vIEZvciBldGhfc2lnbiwgd2UgbmVlZCB0byBzaWduIGFyYml0cmFyeSBkYXRhOlxuICBhc3luYyBzaWduTWVzc2FnZShhZGRyZXNzLCBkYXRhLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBtZXNzYWdlID0gc3RyaXBIZXhQcmVmaXgoZGF0YSk7XG4gICAgY29uc3QgcHJpdktleSA9IHRoaXMuX2dldFByaXZhdGVLZXlGb3IoYWRkcmVzcywgb3B0cyk7XG4gICAgY29uc3QgbXNnU2lnID0gZWNzaWduKEJ1ZmZlci5mcm9tKG1lc3NhZ2UsICdoZXgnKSwgcHJpdktleSk7XG4gICAgY29uc3QgcmF3TXNnU2lnID0gY29uY2F0U2lnKG1zZ1NpZy52LCBtc2dTaWcuciwgbXNnU2lnLnMpO1xuICAgIHJldHVybiByYXdNc2dTaWc7XG4gIH1cblxuICAvLyBGb3IgcGVyc29uYWxfc2lnbiwgd2UgbmVlZCB0byBwcmVmaXggdGhlIG1lc3NhZ2U6XG4gIGFzeW5jIHNpZ25QZXJzb25hbE1lc3NhZ2UoYWRkcmVzcywgbXNnSGV4LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBwcml2S2V5ID0gdGhpcy5fZ2V0UHJpdmF0ZUtleUZvcihhZGRyZXNzLCBvcHRzKTtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gQnVmZmVyLmZyb20ocHJpdktleSwgJ2hleCcpO1xuICAgIGNvbnN0IHNpZyA9IHBlcnNvbmFsU2lnbih7IHByaXZhdGVLZXksIGRhdGE6IG1zZ0hleCB9KTtcbiAgICByZXR1cm4gc2lnO1xuICB9XG5cbiAgLy8gRm9yIGV0aF9kZWNyeXB0TWVzc2FnZTpcbiAgYXN5bmMgZGVjcnlwdE1lc3NhZ2Uod2l0aEFjY291bnQsIGVuY3J5cHRlZERhdGEpIHtcbiAgICBjb25zdCB3YWxsZXQgPSB0aGlzLl9nZXRXYWxsZXRGb3JBY2NvdW50KHdpdGhBY2NvdW50KTtcbiAgICBjb25zdCB7IHByaXZhdGVLZXk6IHByaXZhdGVLZXlBc1VpbnQ4QXJyYXkgfSA9IHdhbGxldDtcbiAgICBjb25zdCBwcml2YXRlS2V5QXNIZXggPSBCdWZmZXIuZnJvbShwcml2YXRlS2V5QXNVaW50OEFycmF5KS50b1N0cmluZygnaGV4Jyk7XG4gICAgY29uc3Qgc2lnID0gZGVjcnlwdCh7IHByaXZhdGVLZXk6IHByaXZhdGVLZXlBc0hleCwgZW5jcnlwdGVkRGF0YSB9KTtcbiAgICByZXR1cm4gc2lnO1xuICB9XG5cbiAgLy8gcGVyc29uYWxfc2lnblR5cGVkRGF0YSwgc2lnbnMgZGF0YSBhbG9uZyB3aXRoIHRoZSBzY2hlbWFcbiAgYXN5bmMgc2lnblR5cGVkRGF0YShcbiAgICB3aXRoQWNjb3VudCxcbiAgICB0eXBlZERhdGEsXG4gICAgb3B0cyA9IHsgdmVyc2lvbjogU2lnblR5cGVkRGF0YVZlcnNpb24uVjEgfSxcbiAgKSB7XG4gICAgLy8gVHJlYXQgaW52YWxpZCB2ZXJzaW9ucyBhcyBcIlYxXCJcbiAgICBjb25zdCB2ZXJzaW9uID0gT2JqZWN0LmtleXMoU2lnblR5cGVkRGF0YVZlcnNpb24pLmluY2x1ZGVzKG9wdHMudmVyc2lvbilcbiAgICAgID8gb3B0cy52ZXJzaW9uXG4gICAgICA6IFNpZ25UeXBlZERhdGFWZXJzaW9uLlYxO1xuXG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IHRoaXMuX2dldFByaXZhdGVLZXlGb3Iod2l0aEFjY291bnQsIG9wdHMpO1xuICAgIHJldHVybiBzaWduVHlwZWREYXRhKHsgcHJpdmF0ZUtleSwgZGF0YTogdHlwZWREYXRhLCB2ZXJzaW9uIH0pO1xuICB9XG5cbiAgcmVtb3ZlQWNjb3VudChhY2NvdW50KSB7XG4gICAgY29uc3QgYWRkcmVzcyA9IG5vcm1hbGl6ZShhY2NvdW50KTtcbiAgICBpZiAoXG4gICAgICAhdGhpcy5fd2FsbGV0c1xuICAgICAgICAubWFwKCh7IHB1YmxpY0tleSB9KSA9PiB0aGlzLl9hZGRyZXNzZnJvbVB1YmxpY0tleShwdWJsaWNLZXkpKVxuICAgICAgICAuaW5jbHVkZXMoYWRkcmVzcylcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQWRkcmVzcyAke2FkZHJlc3N9IG5vdCBmb3VuZCBpbiB0aGlzIGtleXJpbmdgKTtcbiAgICB9XG5cbiAgICB0aGlzLl93YWxsZXRzID0gdGhpcy5fd2FsbGV0cy5maWx0ZXIoXG4gICAgICAoeyBwdWJsaWNLZXkgfSkgPT4gdGhpcy5fYWRkcmVzc2Zyb21QdWJsaWNLZXkocHVibGljS2V5KSAhPT0gYWRkcmVzcyxcbiAgICApO1xuICB9XG5cbiAgLy8gZ2V0IHB1YmxpYyBrZXkgZm9yIG5hY2xcbiAgYXN5bmMgZ2V0RW5jcnlwdGlvblB1YmxpY0tleSh3aXRoQWNjb3VudCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgcHJpdktleSA9IHRoaXMuX2dldFByaXZhdGVLZXlGb3Iod2l0aEFjY291bnQsIG9wdHMpO1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGdldEVuY3J5cHRpb25QdWJsaWNLZXkocHJpdktleSk7XG4gICAgcmV0dXJuIHB1YmxpY0tleTtcbiAgfVxuXG4gIF9nZXRQcml2YXRlS2V5Rm9yKGFkZHJlc3MsIG9wdHMgPSB7fSkge1xuICAgIGlmICghYWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNwZWNpZnkgYWRkcmVzcy4nKTtcbiAgICB9XG4gICAgY29uc3Qgd2FsbGV0ID0gdGhpcy5fZ2V0V2FsbGV0Rm9yQWNjb3VudChhZGRyZXNzLCBvcHRzKTtcbiAgICByZXR1cm4gd2FsbGV0LnByaXZhdGVLZXk7XG4gIH1cblxuICBfZ2V0V2FsbGV0Rm9yQWNjb3VudChhY2NvdW50LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBhZGRyZXNzID0gbm9ybWFsaXplKGFjY291bnQpO1xuICAgIGxldCB3YWxsZXQgPSB0aGlzLl93YWxsZXRzLmZpbmQoKHsgcHVibGljS2V5IH0pID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9hZGRyZXNzZnJvbVB1YmxpY0tleShwdWJsaWNLZXkpID09PSBhZGRyZXNzO1xuICAgIH0pO1xuICAgIGlmICghd2FsbGV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hEIEtleXJpbmcgLSBVbmFibGUgdG8gZmluZCBtYXRjaGluZyBhZGRyZXNzLicpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLndpdGhBcHBLZXlPcmlnaW4pIHtcbiAgICAgIGNvbnN0IHsgcHJpdmF0ZUtleSB9ID0gd2FsbGV0O1xuICAgICAgY29uc3QgYXBwS2V5T3JpZ2luQnVmZmVyID0gQnVmZmVyLmZyb20ob3B0cy53aXRoQXBwS2V5T3JpZ2luLCAndXRmOCcpO1xuICAgICAgY29uc3QgYXBwS2V5QnVmZmVyID0gQnVmZmVyLmNvbmNhdChbcHJpdmF0ZUtleSwgYXBwS2V5T3JpZ2luQnVmZmVyXSk7XG4gICAgICBjb25zdCBhcHBLZXlQcml2YXRlS2V5ID0gYXJyVG9CdWZBcnIoa2VjY2FrMjU2KGFwcEtleUJ1ZmZlciwgMjU2KSk7XG4gICAgICBjb25zdCBhcHBLZXlQdWJsaWNLZXkgPSBwcml2YXRlVG9QdWJsaWMoYXBwS2V5UHJpdmF0ZUtleSk7XG4gICAgICB3YWxsZXQgPSB7IHByaXZhdGVLZXk6IGFwcEtleVByaXZhdGVLZXksIHB1YmxpY0tleTogYXBwS2V5UHVibGljS2V5IH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHdhbGxldDtcbiAgfVxuXG4gIC8qIFBSSVZBVEUgLyBVVElMSVRZIE1FVEhPRFMgKi9cblxuICAvKipcbiAgICogU2V0cyBhcHByb3ByaWF0ZSBwcm9wZXJ0aWVzIGZvciB0aGUga2V5cmluZyBiYXNlZCBvbiB0aGUgZ2l2ZW5cbiAgICogQklQMzktY29tcGxpYW50IG1uZW1vbmljLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheTxudW1iZXI+fEJ1ZmZlcn0gbW5lbW9uaWMgLSBBIHNlZWQgcGhyYXNlIHJlcHJlc2VudGVkXG4gICAqIGFzIGEgc3RyaW5nLCBhbiBhcnJheSBvZiBVVEYtOCBieXRlcywgb3IgYSBCdWZmZXIuIE1uZW1vbmljIGlucHV0XG4gICAqIHBhc3NlZCBhcyB0eXBlIGJ1ZmZlciBvciBhcnJheSBvZiBVVEYtOCBieXRlcyBtdXN0IGJlIE5GS0Qgbm9ybWFsaXplZC5cbiAgICovXG4gIF9pbml0RnJvbU1uZW1vbmljKG1uZW1vbmljKSB7XG4gICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnRXRoLUhkLUtleXJpbmc6IFNlY3JldCByZWNvdmVyeSBwaHJhc2UgYWxyZWFkeSBwcm92aWRlZCcsXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMubW5lbW9uaWMgPSB0aGlzLl9tbmVtb25pY1RvVWludDhBcnJheShtbmVtb25pYyk7XG5cbiAgICAvLyB2YWxpZGF0ZSBiZWZvcmUgaW5pdGlhbGl6aW5nXG4gICAgY29uc3QgaXNWYWxpZCA9IGJpcDM5LnZhbGlkYXRlTW5lbW9uaWModGhpcy5tbmVtb25pYywgd29yZGxpc3QpO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnRXRoLUhkLUtleXJpbmc6IEludmFsaWQgc2VjcmV0IHJlY292ZXJ5IHBocmFzZSBwcm92aWRlZCcsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXN5bmNcbiAgICBjb25zdCBzZWVkID0gYmlwMzkubW5lbW9uaWNUb1NlZWRTeW5jKHRoaXMubW5lbW9uaWMsIHdvcmRsaXN0KTtcbiAgICB0aGlzLmhkV2FsbGV0ID0gSERLZXkuZnJvbU1hc3RlclNlZWQoc2VlZCk7XG4gICAgdGhpcy5yb290ID0gdGhpcy5oZFdhbGxldC5kZXJpdmUodGhpcy5oZFBhdGgpO1xuICB9XG5cbiAgLy8gc21hbGwgaGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgcHVibGljS2V5IGluIFVpbnQ4QXJyYXkgZm9ybSB0byBhIHB1YmxpY0FkZHJlc3MgYXMgYSBoZXhcbiAgX2FkZHJlc3Nmcm9tUHVibGljS2V5KHB1YmxpY0tleSkge1xuICAgIHJldHVybiBidWZmZXJUb0hleChcbiAgICAgIHB1YmxpY1RvQWRkcmVzcyhCdWZmZXIuZnJvbShwdWJsaWNLZXkpLCB0cnVlKSxcbiAgICApLnRvTG93ZXJDYXNlKCk7XG4gIH1cbn1cblxuSGRLZXlyaW5nLnR5cGUgPSB0eXBlO1xubW9kdWxlLmV4cG9ydHMgPSBIZEtleXJpbmc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlSW5mdXJhTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG5jb25zdCBub2RlX2ZldGNoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm5vZGUtZmV0Y2hcIikpO1xuY29uc3QgZmV0Y2hfY29uZmlnX2Zyb21fcmVxXzEgPSByZXF1aXJlKFwiLi9mZXRjaC1jb25maWctZnJvbS1yZXFcIik7XG5jb25zdCBsb2dnaW5nX3V0aWxzXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nLXV0aWxzXCIpO1xuY29uc3QgbG9nID0gKDAsIGxvZ2dpbmdfdXRpbHNfMS5jcmVhdGVNb2R1bGVMb2dnZXIpKGxvZ2dpbmdfdXRpbHNfMS5wcm9qZWN0TG9nZ2VyLCAnY3JlYXRlLWluZnVyYS1taWRkbGV3YXJlJyk7XG5jb25zdCBSRVRSSUFCTEVfRVJST1JTID0gW1xuICAgIC8vIGlnbm9yZSBzZXJ2ZXIgb3ZlcmxvYWQgZXJyb3JzXG4gICAgJ0dhdGV3YXkgdGltZW91dCcsXG4gICAgJ0VUSU1FRE9VVCcsXG4gICAgJ0VDT05OUkVTRVQnLFxuICAgIC8vIGlnbm9yZSBzZXJ2ZXIgc2VudCBodG1sIGVycm9yIHBhZ2VzXG4gICAgLy8gb3IgdHJ1bmNhdGVkIGpzb24gcmVzcG9uc2VzXG4gICAgJ1N5bnRheEVycm9yJyxcbl07XG4vKipcbiAqIEJ1aWxkcyBbYGpzb24tcnBjLWVuZ2luZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9qc29uLXJwYy1lbmdpbmUpLWNvbXBhdGlibGUgbWlkZGxld2FyZSBkZXNpZ25lZFxuICogZm9yIGludGVyZmFjaW5nIHdpdGggSW5mdXJhJ3MgSlNPTi1SUEMgZW5kcG9pbnRzLlxuICpcbiAqIEBwYXJhbSBvcHRzIC0gVGhlIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0cy5uZXR3b3JrIC0gQSBuZXR3b3JrIHRoYXQgSW5mdXJhIHN1cHBvcnRzOyBwbHVncyBpbnRvXG4gKiBgaHR0cHM6Ly8ke25ldHdvcmt9LmluZnVyYS5pb2AgKGRlZmF1bHQ6ICdtYWlubmV0JykuXG4gKiBAcGFyYW0gb3B0cy5tYXhBdHRlbXB0cyAtIFRoZSBudW1iZXIgb2YgdGltZXMgYSByZXF1ZXN0IHRvIEluZnVyYSBzaG91bGQgYmVcbiAqIHJldHJpZWQgaW4gdGhlIGNhc2Ugb2YgZmFpbHVyZSAoZGVmYXVsdDogNSkuXG4gKiBAcGFyYW0gb3B0cy5zb3VyY2UgLSBBIGRlc2NyaXB0b3IgZm9yIHRoZSBlbnRpdHkgbWFraW5nIHRoZSByZXF1ZXN0OyB0cmFja2VkXG4gKiBieSBJbmZ1cmEgZm9yIGFuYWx5dGljcyBwdXJwb3Nlcy5cbiAqIEBwYXJhbSBvcHRzLnByb2plY3RJZCAtIFRoZSBJbmZ1cmEgcHJvamVjdCBpZC5cbiAqIEBwYXJhbSBvcHRzLmhlYWRlcnMgLSBFeHRyYSBoZWFkZXJzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIG1ha2UgdGhlIHJlcXVlc3QuXG4gKiBAcmV0dXJucyBUaGUgYGpzb24tcnBjLWVuZ2luZWAtY29tcGF0aWJsZSBtaWRkbGV3YXJlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJbmZ1cmFNaWRkbGV3YXJlKHsgbmV0d29yayA9ICdtYWlubmV0JywgbWF4QXR0ZW1wdHMgPSA1LCBzb3VyY2UsIHByb2plY3RJZCwgaGVhZGVycyA9IHt9LCB9KSB7XG4gICAgLy8gdmFsaWRhdGUgb3B0aW9uc1xuICAgIGlmICghcHJvamVjdElkIHx8IHR5cGVvZiBwcm9qZWN0SWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZSBmb3IgJ3Byb2plY3RJZCc6IFwiJHtwcm9qZWN0SWR9XCJgKTtcbiAgICB9XG4gICAgaWYgKCFoZWFkZXJzIHx8IHR5cGVvZiBoZWFkZXJzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsdWUgZm9yICdoZWFkZXJzJzogXCIke2hlYWRlcnN9XCJgKTtcbiAgICB9XG4gICAgaWYgKCFtYXhBdHRlbXB0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsdWUgZm9yICdtYXhBdHRlbXB0cyc6IFwiJHttYXhBdHRlbXB0c31cIiAoJHt0eXBlb2YgbWF4QXR0ZW1wdHN9KWApO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSkoYXN5bmMgKHJlcSwgcmVzKSA9PiB7XG4gICAgICAgIC8vIHJldHJ5IE1BWF9BVFRFTVBUUyB0aW1lcywgaWYgZXJyb3IgbWF0Y2hlcyBmaWx0ZXJcbiAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDE7IGF0dGVtcHQgPD0gbWF4QXR0ZW1wdHM7IGF0dGVtcHQrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBhdHRlbXB0IHJlcXVlc3RcbiAgICAgICAgICAgICAgICBsb2coJ0F0dGVtcHRpbmcgcmVxdWVzdCB0byBJbmZ1cmEuIG5ldHdvcmsgPSAlbywgcHJvamVjdElkID0gJXMsIGhlYWRlcnMgPSAlbywgcmVxID0gJW8nLCBuZXR3b3JrLCBwcm9qZWN0SWQsIGhlYWRlcnMsIHJlcSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcGVyZm9ybUZldGNoKG5ldHdvcmssIHByb2plY3RJZCwgaGVhZGVycywgcmVxLCByZXMsIHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bFxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIGFuIGVycm9yIHdhcyBjYXVnaHQgd2hpbGUgcGVyZm9ybWluZyB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgICAgIC8vIGlmIG5vdCByZXRyaWFibGUsIHJlc29sdmUgd2l0aCB0aGUgZW5jb3VudGVyZWQgZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAoIWlzUmV0cmlhYmxlRXJyb3IoZXJyKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhYm9ydCB3aXRoIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGxvZygnTm9uLXJldHJpYWJsZSByZXF1ZXN0IGVycm9yIGVuY291bnRlcmVkLiByZXEgPSAlbywgcmVzID0gJW8sIGVycm9yID0gJW8nLCByZXEsIHJlcywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiBubyBtb3JlIGF0dGVtcHRzIHJlbWFpbmluZywgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICBjb25zdCByZW1haW5pbmdBdHRlbXB0cyA9IG1heEF0dGVtcHRzIC0gYXR0ZW1wdDtcbiAgICAgICAgICAgICAgICBpZiAoIXJlbWFpbmluZ0F0dGVtcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZygnUmV0cmlhYmxlIHJlcXVlc3QgZXJyb3IgZW5jb3VudGVyZWQsIGJ1dCBleGNlZWRlZCBtYXggYXR0ZW1wdHMuIHJlcSA9ICVvLCByZXMgPSAlbywgZXJyb3IgPSAlbycsIHJlcSwgcmVzLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSBgSW5mdXJhUHJvdmlkZXIgLSBjYW5ub3QgY29tcGxldGUgcmVxdWVzdC4gQWxsIHJldHJpZXMgZXhoYXVzdGVkLlxcbk9yaWdpbmFsIEVycm9yOlxcbiR7ZXJyLnRvU3RyaW5nKCl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0cmllc0V4aGF1c3RlZEVyciA9IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyByZXRyaWVzRXhoYXVzdGVkRXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIGlnbm9yZSBlcnJvciBhbmQgcmV0cnkgYWdhaW4gYWZ0ZXIgdGltZW91dFxuICAgICAgICAgICAgICAgIGxvZygnUmV0cmlhYmxlIHJlcXVlc3QgZXJyb3IgZW5jb3VudGVyZWQuIHJlcSA9ICVvLCByZXMgPSAlbywgZXJyb3IgPSAlbycsIHJlcSwgcmVzLCBlcnIpO1xuICAgICAgICAgICAgICAgIGxvZygnV2FpdGluZyAxIHNlY29uZCB0byB0cnkgYWdhaW4uLi4nKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aW1lb3V0KDEwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJlcXVlc3Qgd2FzIGhhbmRsZWQgY29ycmVjdGx5LCBlbmRcbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlSW5mdXJhTWlkZGxld2FyZSA9IGNyZWF0ZUluZnVyYU1pZGRsZXdhcmU7XG4vKipcbiAqIE1ha2VzIGEgcmVxdWVzdCB0byBJbmZ1cmEsIHVwZGF0aW5nIHRoZSBnaXZlbiByZXNwb25zZSBvYmplY3QgaWYgdGhlIHJlc3BvbnNlXG4gKiBoYXMgYSBcInN1Y2Nlc3NmdWxcIiBzdGF0dXMgY29kZSBvciB0aHJvd2luZyBhbiBlcnJvciBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIG5ldHdvcmsgLSBBIG5ldHdvcmsgdGhhdCBJbmZ1cmEgc3VwcG9ydHM7IHBsdWdzIGludG9cbiAqIGBodHRwczovLyR7bmV0d29ya30uaW5mdXJhLmlvYC5cbiAqIEBwYXJhbSBwcm9qZWN0SWQgLSBUaGUgSW5mdXJhIHByb2plY3QgaWQuXG4gKiBAcGFyYW0gZXh0cmFIZWFkZXJzIC0gRXh0cmEgaGVhZGVycyB0aGF0IHdpbGwgYmUgdXNlZCB0byBtYWtlIHRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHJlcSAtIFRoZSBvcmlnaW5hbCByZXF1ZXN0IG9iamVjdCBvYnRhaW5lZCB2aWEgdGhlIG1pZGRsZXdhcmUgc3RhY2suXG4gKiBAcGFyYW0gcmVzIC0gVGhlIG9yaWdpbmFsIHJlc3BvbnNlIG9iamVjdCBvYnRhaW5lZCB2aWEgdGhlIG1pZGRsZXdhcmUgc3RhY2suXG4gKiBAcGFyYW0gc291cmNlIC0gQSBkZXNjcmlwdG9yIGZvciB0aGUgZW50aXR5IG1ha2luZyB0aGUgcmVxdWVzdDtcbiAqIHRyYWNrZWQgYnkgSW5mdXJhIGZvciBhbmFseXRpY3MgcHVycG9zZXMuXG4gKiBAdGhyb3dzIGFuIGVycm9yIHdpdGggYSBkZXRhaWxlZCBtZXNzYWdlIGlmIHRoZSBIVFRQIHN0YXR1cyBjb2RlIGlzIGFueXdoZXJlXG4gKiBvdXRzaWRlIDJ4eCwgYW5kIGVzcGVjaWFsbHkgaWYgaXQgaXMgNDA1LCA0MjksIDUwMywgb3IgNTA0LlxuICovXG5hc3luYyBmdW5jdGlvbiBwZXJmb3JtRmV0Y2gobmV0d29yaywgcHJvamVjdElkLCBleHRyYUhlYWRlcnMsIHJlcSwgcmVzLCBzb3VyY2UpIHtcbiAgICBjb25zdCB7IGZldGNoVXJsLCBmZXRjaFBhcmFtcyB9ID0gKDAsIGZldGNoX2NvbmZpZ19mcm9tX3JlcV8xLmZldGNoQ29uZmlnRnJvbVJlcSkoe1xuICAgICAgICBuZXR3b3JrLFxuICAgICAgICBwcm9qZWN0SWQsXG4gICAgICAgIGV4dHJhSGVhZGVycyxcbiAgICAgICAgcmVxLFxuICAgICAgICBzb3VyY2UsXG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCAoMCwgbm9kZV9mZXRjaF8xLmRlZmF1bHQpKGZldGNoVXJsLCBmZXRjaFBhcmFtcyk7XG4gICAgY29uc3QgcmF3RGF0YSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAvLyBoYW5kbGUgZXJyb3JzXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBzd2l0Y2ggKHJlc3BvbnNlLnN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSA0MDU6XG4gICAgICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdEZvdW5kKCk7XG4gICAgICAgICAgICBjYXNlIDQyOTpcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVSYXRlbGltaXRFcnJvcigpO1xuICAgICAgICAgICAgY2FzZSA1MDM6XG4gICAgICAgICAgICBjYXNlIDUwNDpcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVUaW1lb3V0RXJyb3IoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW50ZXJuYWxFcnJvcihyYXdEYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIG5vd1xuICAgIGlmIChyZXEubWV0aG9kID09PSAnZXRoX2dldEJsb2NrQnlOdW1iZXInICYmIHJhd0RhdGEgPT09ICdOb3QgRm91bmQnKSB7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHBhcnNlIEpTT05cbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShyYXdEYXRhKTtcbiAgICAvLyBmaW5hbGx5IHJldHVybiByZXN1bHRcbiAgICByZXMucmVzdWx0ID0gZGF0YS5yZXN1bHQ7XG4gICAgcmVzLmVycm9yID0gZGF0YS5lcnJvcjtcbn1cbi8qKlxuICogQnVpbGRzIGEgSlNPTi1SUEMgMi4wIGludGVybmFsIGVycm9yIG9iamVjdCBkZXNjcmliaW5nIGEgcmF0ZS1saW1pdGluZ1xuICogZXJyb3IuXG4gKlxuICogQHJldHVybnMgVGhlIGVycm9yIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmF0ZWxpbWl0RXJyb3IoKSB7XG4gICAgY29uc3QgbXNnID0gYFJlcXVlc3QgaXMgYmVpbmcgcmF0ZSBsaW1pdGVkLmA7XG4gICAgcmV0dXJuIGNyZWF0ZUludGVybmFsRXJyb3IobXNnKTtcbn1cbi8qKlxuICogQnVpbGRzIGEgSlNPTi1SUEMgMi4wIGludGVybmFsIGVycm9yIG9iamVjdCBkZXNjcmliaW5nIGEgdGltZW91dCBlcnJvci5cbiAqXG4gKiBAcmV0dXJucyBUaGUgZXJyb3Igb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVUaW1lb3V0RXJyb3IoKSB7XG4gICAgbGV0IG1zZyA9IGBHYXRld2F5IHRpbWVvdXQuIFRoZSByZXF1ZXN0IHRvb2sgdG9vIGxvbmcgdG8gcHJvY2Vzcy4gYDtcbiAgICBtc2cgKz0gYFRoaXMgY2FuIGhhcHBlbiB3aGVuIHF1ZXJ5aW5nIGxvZ3Mgb3ZlciB0b28gd2lkZSBhIGJsb2NrIHJhbmdlLmA7XG4gICAgcmV0dXJuIGNyZWF0ZUludGVybmFsRXJyb3IobXNnKTtcbn1cbi8qKlxuICogQnVpbGRzIGEgSlNPTi1SUEMgMi4wIGludGVybmFsIGVycm9yIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gbXNnIC0gVGhlIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyBUaGUgZXJyb3Igb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnRlcm5hbEVycm9yKG1zZykge1xuICAgIHJldHVybiBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW50ZXJuYWwobXNnKTtcbn1cbi8qKlxuICogVXBvbiBtYWtpbmcgYSByZXF1ZXN0LCB3ZSBtYXkgZ2V0IGFuIGVycm9yIHRoYXQgaXMgdGVtcG9yYXJ5IGFuZFxuICogaW50ZXJtaXR0ZW50LiBJbiB0aGVzZSBjYXNlcyB3ZSBjYW4gYXR0ZW1wdCB0aGUgcmVxdWVzdCBhZ2FpbiB3aXRoIHRoZVxuICogYXNzdW1wdGlvbiB0aGF0IHRoZSBlcnJvciBpcyB1bmxpa2VseSB0byBvY2N1ciBhZ2Fpbi4gSGVyZSB3ZSBkZXRlcm1pbmUgaWYgd2VcbiAqIGhhdmUgcmVjZWl2ZWQgc3VjaCBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0gZXJyIC0gVGhlIGVycm9yIG9iamVjdC5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHJlcXVlc3QgdGhhdCBwcm9kdWNlZCB0aGUgZXJyb3IgY2FuIGJlIHJldHJpZWQuXG4gKi9cbmZ1bmN0aW9uIGlzUmV0cmlhYmxlRXJyb3IoZXJyKSB7XG4gICAgY29uc3QgZXJyTWVzc2FnZSA9IGVyci50b1N0cmluZygpO1xuICAgIHJldHVybiBSRVRSSUFCTEVfRVJST1JTLnNvbWUoKHBocmFzZSkgPT4gZXJyTWVzc2FnZS5pbmNsdWRlcyhwaHJhc2UpKTtcbn1cbi8qKlxuICogQSB1dGlsaXR5IGZ1bmN0aW9uIHRoYXQgcHJvbWlzaWZpZXMgYHNldFRpbWVvdXRgLlxuICpcbiAqIEBwYXJhbSBsZW5ndGggLSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0LlxuICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgdGhlIGdpdmVuIHRpbWUgaGFzIGVsYXBzZWQuXG4gKi9cbmZ1bmN0aW9uIHRpbWVvdXQobGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgbGVuZ3RoKTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZS1pbmZ1cmEtbWlkZGxld2FyZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBldGhfanNvbl9ycGNfbWlkZGxld2FyZV8xID0gcmVxdWlyZShcImV0aC1qc29uLXJwYy1taWRkbGV3YXJlXCIpO1xuY29uc3QgY3JlYXRlX2luZnVyYV9taWRkbGV3YXJlXzEgPSByZXF1aXJlKFwiLi9jcmVhdGUtaW5mdXJhLW1pZGRsZXdhcmVcIik7XG4vKipcbiAqIENyZWF0ZXMgYSBwcm92aWRlciAoYXMgZGVmaW5lZCBpblxuICogW2BldGgtanNvbi1ycGMtbWlkZGxld2FyZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZSlcbiAqIHdoaWNoIGlzIHByZWxvYWRlZCB3aXRoIG1pZGRsZXdhcmUgc3BlY2lhbGl6ZWQgZm9yIGludGVyZmFjaW5nIHdpdGggSW5mdXJhXG4gKiBKU09OLVJQQyBlbmRwb2ludHMuXG4gKlxuICogQHBhcmFtIG9wdHMgLSBPcHRpb25zIHRvIHtAbGluayBjcmVhdGVJbmZ1cmFNaWRkbGV3YXJlfS5cbiAqIEByZXR1cm5zIFRoZSBwcm92aWRlciBhcyByZXR1cm5lZCBieSBgcHJvdmlkZXJGcm9tRW5naW5lYCAoYSBwYXJ0IG9mXG4gKiBbYGV0aC1qc29uLXJwYy1taWRkbGV3YXJlYF0oaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlKSkuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb3ZpZGVyKG9wdHMpIHtcbiAgICBjb25zdCBlbmdpbmUgPSBuZXcganNvbl9ycGNfZW5naW5lXzEuSnNvblJwY0VuZ2luZSgpO1xuICAgIGVuZ2luZS5wdXNoKCgwLCBjcmVhdGVfaW5mdXJhX21pZGRsZXdhcmVfMS5jcmVhdGVJbmZ1cmFNaWRkbGV3YXJlKShvcHRzKSk7XG4gICAgcmV0dXJuICgwLCBldGhfanNvbl9ycGNfbWlkZGxld2FyZV8xLnByb3ZpZGVyRnJvbUVuZ2luZSkoZW5naW5lKTtcbn1cbmV4cG9ydHMuY3JlYXRlUHJvdmlkZXIgPSBjcmVhdGVQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZS1wcm92aWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZmV0Y2hDb25maWdGcm9tUmVxID0gdm9pZCAwO1xuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBhcmd1bWVudHMgdG8gZmVlZCBpbnRvIGBmZXRjaGAgaW4gb3JkZXIgdG8gbWFrZSBhIHJlcXVlc3QgdG9cbiAqIEluZnVyYS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMubmV0d29yayAtIEEgbmV0d29yayB0aGF0IEluZnVyYSBzdXBwb3J0czsgcGx1Z3MgaW50b1xuICogYGh0dHBzOi8vJHtuZXR3b3JrfS5pbmZ1cmEuaW9gLlxuICogQHBhcmFtIG9wdGlvbnMucHJvamVjdElkIC0gVGhlIEluZnVyYSBwcm9qZWN0IGlkLlxuICogQHBhcmFtIG9wdGlvbnMuZXh0cmFIZWFkZXJzIC0gRXh0cmEgaGVhZGVycyB0aGF0IHdpbGwgYmUgdXNlZCB0byBtYWtlIHRoZVxuICogcmVxdWVzdC5cbiAqIEBwYXJhbSBvcHRpb25zLnJlcSAtIFRoZSBvcmlnaW5hbCByZXF1ZXN0IG9iamVjdCBvYnRhaW5lZCB2aWEgdGhlXG4gKiBtaWRkbGV3YXJlIHN0YWNrLlxuICogQHBhcmFtIG9wdGlvbnMuc291cmNlIC0gQSBkZXNjcmlwdG9yIGZvciB0aGUgZW50aXR5IG1ha2luZyB0aGUgcmVxdWVzdDtcbiAqIHRyYWNrZWQgYnkgSW5mdXJhIGZvciBhbmFseXRpY3MgcHVycG9zZXMuXG4gKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgVVJMIGFuZCBhIGJhZyBvZiBvcHRpb25zLCBib3RoIG9mIHdoaWNoXG4gKiB3aWxsIGJlIHBhc3NlZCB0byBgZmV0Y2hgLlxuICovXG5mdW5jdGlvbiBmZXRjaENvbmZpZ0Zyb21SZXEoeyBuZXR3b3JrLCBwcm9qZWN0SWQsIGV4dHJhSGVhZGVycyA9IHt9LCByZXEsIHNvdXJjZSwgfSkge1xuICAgIGNvbnN0IHJlcXVlc3RPcmlnaW4gPSByZXEub3JpZ2luIHx8ICdpbnRlcm5hbCc7XG4gICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIGV4dHJhSGVhZGVycywge1xuICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICB9KTtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGhlYWRlcnNbJ0luZnVyYS1Tb3VyY2UnXSA9IGAke3NvdXJjZX0vJHtyZXF1ZXN0T3JpZ2lufWA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGZldGNoVXJsOiBgaHR0cHM6Ly8ke25ldHdvcmt9LmluZnVyYS5pby92My8ke3Byb2plY3RJZH1gLFxuICAgICAgICBmZXRjaFBhcmFtczoge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplUmVxKHJlcSkpLFxuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnRzLmZldGNoQ29uZmlnRnJvbVJlcSA9IGZldGNoQ29uZmlnRnJvbVJlcTtcbi8qKlxuICogU3RyaXBzIG91dCBleHRyYSBrZXlzIGZyb20gYSByZXF1ZXN0IG9iamVjdCB0aGF0IGNvdWxkIGJlIHJlamVjdGVkIGJ5IHN0cmljdFxuICogbm9kZXMgbGlrZSBwYXJpdHkuXG4gKlxuICogQHBhcmFtIHJlcSAtIFRoZSBvcmlnaW5hbCByZXF1ZXN0IG9iamVjdCBvYnRhaW5lZCB2aWEgdGhlIG1pZGRsZXdhcmUgc3RhY2suXG4gKiBAcmV0dXJucyBBbiBvYmplY3QgdGhhdCBkZXNjcmliZXMgYSBKU09OLVJQQyByZXF1ZXN0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVSZXEocmVxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IHJlcS5pZCxcbiAgICAgICAganNvbnJwYzogcmVxLmpzb25ycGMsXG4gICAgICAgIG1ldGhvZDogcmVxLm1ldGhvZCxcbiAgICAgICAgcGFyYW1zOiByZXEucGFyYW1zLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC1jb25maWctZnJvbS1yZXEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jcmVhdGUtaW5mdXJhLW1pZGRsZXdhcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2ZldGNoLWNvbmZpZy1mcm9tLXJlcVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY3JlYXRlLXByb3ZpZGVyXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVNb2R1bGVMb2dnZXIgPSBleHBvcnRzLnByb2plY3RMb2dnZXIgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZU1vZHVsZUxvZ2dlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5jcmVhdGVNb2R1bGVMb2dnZXI7IH0gfSk7XG5leHBvcnRzLnByb2plY3RMb2dnZXIgPSAoMCwgdXRpbHNfMS5jcmVhdGVQcm9qZWN0TG9nZ2VyKSgnZXRoLWpzb24tcnBjLWluZnVyYScpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2luZy11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzZXJ0RXhoYXVzdGl2ZSA9IGV4cG9ydHMuYXNzZXJ0U3RydWN0ID0gZXhwb3J0cy5hc3NlcnQgPSBleHBvcnRzLkFzc2VydGlvbkVycm9yID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbi8qKlxuICogVHlwZSBndWFyZCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gZXJyb3Igb2JqZWN0IHdpdGggYVxuICogYG1lc3NhZ2VgIHByb3BlcnR5LCBzdWNoIGFzIGFuIGluc3RhbmNlIG9mIEVycm9yLlxuICpcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBUcnVlIG9yIGZhbHNlLCBkZXBlbmRpbmcgb24gdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNFcnJvcldpdGhNZXNzYWdlKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ21lc3NhZ2UnIGluIGVycm9yO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgY29uc3RydWN0b3IsIGkuZS4sIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgY2FsbGVkIHdpdGhcbiAqIHRoZSBgbmV3YCBrZXl3b3JkLlxuICpcbiAqIEBwYXJhbSBmbiAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBjb25zdHJ1Y3Rvciwgb3IgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzQ29uc3RydWN0YWJsZShmbikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gQm9vbGVhbih0eXBlb2YgKChfYiA9IChfYSA9IGZuID09PSBudWxsIHx8IGZuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmbi5wcm90b3R5cGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25zdHJ1Y3RvcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5hbWUpID09PSAnc3RyaW5nJyk7XG59XG4vKipcbiAqIEdldCB0aGUgZXJyb3IgbWVzc2FnZSBmcm9tIGFuIHVua25vd24gZXJyb3Igb2JqZWN0LiBJZiB0aGUgZXJyb3Igb2JqZWN0IGhhc1xuICogYSBgbWVzc2FnZWAgcHJvcGVydHksIHRoYXQgcHJvcGVydHkgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSwgdGhlIHN0cmluZ2lmaWVkXG4gKiBlcnJvciBvYmplY3QgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIG9iamVjdCB0byBnZXQgdGhlIG1lc3NhZ2UgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBlcnJvciBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gaXNFcnJvcldpdGhNZXNzYWdlKGVycm9yKSA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgIC8vIElmIHRoZSBlcnJvciBlbmRzIHdpdGggYSBwZXJpb2QsIHJlbW92ZSBpdCwgYXMgd2UnbGwgYWRkIG91ciBvd24gcGVyaW9kLlxuICAgIGlmIChtZXNzYWdlLmVuZHNXaXRoKCcuJykpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2Uuc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbn1cbi8qKlxuICogSW5pdGlhbGlzZSBhbiB7QGxpbmsgQXNzZXJ0aW9uRXJyb3JDb25zdHJ1Y3Rvcn0gZXJyb3IuXG4gKlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB1c2UuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHJldHVybnMgVGhlIGVycm9yIG9iamVjdC5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZnVuY3Rpb24gZ2V0RXJyb3IoRXJyb3JXcmFwcGVyLCBtZXNzYWdlKSB7XG4gICAgaWYgKGlzQ29uc3RydWN0YWJsZShFcnJvcldyYXBwZXIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3JXcmFwcGVyKHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gRXJyb3JXcmFwcGVyKHtcbiAgICAgICAgbWVzc2FnZSxcbiAgICB9KTtcbn1cbi8qKlxuICogVGhlIGRlZmF1bHQgZXJyb3IgY2xhc3MgdGhhdCBpcyB0aHJvd24gaWYgYW4gYXNzZXJ0aW9uIGZhaWxzLlxuICovXG5jbGFzcyBBc3NlcnRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMubWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9ICdFUlJfQVNTRVJUSU9OJztcbiAgICB9XG59XG5leHBvcnRzLkFzc2VydGlvbkVycm9yID0gQXNzZXJ0aW9uRXJyb3I7XG4vKipcbiAqIFNhbWUgYXMgTm9kZS5qcyBhc3NlcnQuXG4gKiBJZiB0aGUgdmFsdWUgaXMgZmFsc3ksIHRocm93cyBhbiBlcnJvciwgZG9lcyBub3RoaW5nIG90aGVyd2lzZS5cbiAqXG4gKiBAdGhyb3dzIHtAbGluayBBc3NlcnRpb25FcnJvcn0gSWYgdmFsdWUgaXMgZmFsc3kuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdGVzdCB0aGF0IHNob3VsZCBiZSB0cnV0aHkgdG8gcGFzcy5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gTWVzc2FnZSB0byBiZSBwYXNzZWQgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfSBvciBhblxuICoge0BsaW5rIEVycm9yfSBpbnN0YW5jZSB0byB0aHJvdy5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uIElmIGEgY3VzdG9tIGVycm9yIGNsYXNzIGlzIHByb3ZpZGVkIGZvclxuICogdGhlIGBtZXNzYWdlYCBhcmd1bWVudCwgdGhpcyBhcmd1bWVudCBpcyBpZ25vcmVkLlxuICovXG5mdW5jdGlvbiBhc3NlcnQodmFsdWUsIG1lc3NhZ2UgPSAnQXNzZXJ0aW9uIGZhaWxlZC4nLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlciA9IEFzc2VydGlvbkVycm9yKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGdldEVycm9yKEVycm9yV3JhcHBlciwgbWVzc2FnZSk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG4vKipcbiAqIEFzc2VydCBhIHZhbHVlIGFnYWluc3QgYSBTdXBlcnN0cnVjdCBzdHJ1Y3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gdmFsaWRhdGUgYWdhaW5zdC5cbiAqIEBwYXJhbSBlcnJvclByZWZpeCAtIEEgcHJlZml4IHRvIGFkZCB0byB0aGUgZXJyb3IgbWVzc2FnZS4gRGVmYXVsdHMgdG9cbiAqIFwiQXNzZXJ0aW9uIGZhaWxlZFwiLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0U3RydWN0KHZhbHVlLCBzdHJ1Y3QsIGVycm9yUHJlZml4ID0gJ0Fzc2VydGlvbiBmYWlsZWQnLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlciA9IEFzc2VydGlvbkVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgKDAsIHN1cGVyc3RydWN0XzEuYXNzZXJ0KSh2YWx1ZSwgc3RydWN0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IGdldEVycm9yKEVycm9yV3JhcHBlciwgYCR7ZXJyb3JQcmVmaXh9OiAke2dldEVycm9yTWVzc2FnZShlcnJvcil9LmApO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0U3RydWN0ID0gYXNzZXJ0U3RydWN0O1xuLyoqXG4gKiBVc2UgaW4gdGhlIGRlZmF1bHQgY2FzZSBvZiBhIHN3aXRjaCB0aGF0IHlvdSB3YW50IHRvIGJlIGZ1bGx5IGV4aGF1c3RpdmUuXG4gKiBVc2luZyB0aGlzIGZ1bmN0aW9uIGZvcmNlcyB0aGUgY29tcGlsZXIgdG8gZW5mb3JjZSBleGhhdXN0aXZpdHkgZHVyaW5nXG4gKiBjb21waWxlLXRpbWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogY29uc3QgbnVtYmVyID0gMTtcbiAqIHN3aXRjaCAobnVtYmVyKSB7XG4gKiAgIGNhc2UgMDpcbiAqICAgICAuLi5cbiAqICAgY2FzZSAxOlxuICogICAgIC4uLlxuICogICBkZWZhdWx0OlxuICogICAgIGFzc2VydEV4aGF1c3RpdmUoc25hcFByZWZpeCk7XG4gKiB9XG4gKiBgYGBcbiAqIEBwYXJhbSBfb2JqZWN0IC0gVGhlIG9iamVjdCBvbiB3aGljaCB0aGUgc3dpdGNoIGlzIGJlaW5nIG9wZXJhdGVkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRFeGhhdXN0aXZlKF9vYmplY3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnJhbmNoIHJlYWNoZWQuIFNob3VsZCBiZSBkZXRlY3RlZCBkdXJpbmcgY29tcGlsYXRpb24uJyk7XG59XG5leHBvcnRzLmFzc2VydEV4aGF1c3RpdmUgPSBhc3NlcnRFeGhhdXN0aXZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXJ0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5iYXNlNjQgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgcHJvdmlkZWQgc3RyaW5nLWJhc2VkIHN0cnVjdCBpcyB2YWxpZCBiYXNlNjQuXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJpbmcgYmFzZWQgc3RydWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBvcHRpb25zIHRvIHNwZWNpYWxpemUgYmFzZTY0IHZhbGlkYXRpb24uIFNlZSB7QGxpbmsgQmFzZTY0T3B0aW9uc30gZG9jdW1lbnRhdGlvbi5cbiAqIEByZXR1cm5zIEEgc3VwZXJzdHJ1Y3QgdmFsaWRhdGluZyBiYXNlNjQuXG4gKi9cbmNvbnN0IGJhc2U2NCA9IChzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgcGFkZGluZ1JlcXVpcmVkID0gKF9hID0gb3B0aW9ucy5wYWRkaW5nUmVxdWlyZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgIGNvbnN0IGNoYXJhY3RlclNldCA9IChfYiA9IG9wdGlvbnMuY2hhcmFjdGVyU2V0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnYmFzZTY0JztcbiAgICBsZXQgbGV0dGVycztcbiAgICBpZiAoY2hhcmFjdGVyU2V0ID09PSAnYmFzZTY0Jykge1xuICAgICAgICBsZXR0ZXJzID0gU3RyaW5nLnJhdyBgW0EtWmEtejAtOStcXC9dYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGNoYXJhY3RlclNldCA9PT0gJ2Jhc2U2NHVybCcpO1xuICAgICAgICBsZXR0ZXJzID0gU3RyaW5nLnJhdyBgWy1fQS1aYS16MC05XWA7XG4gICAgfVxuICAgIGxldCByZTtcbiAgICBpZiAocGFkZGluZ1JlcXVpcmVkKSB7XG4gICAgICAgIHJlID0gbmV3IFJlZ0V4cChgXig/OiR7bGV0dGVyc317NH0pKig/OiR7bGV0dGVyc317M309fCR7bGV0dGVyc317Mn09PSk/JGAsICd1Jyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZSA9IG5ldyBSZWdFeHAoYF4oPzoke2xldHRlcnN9ezR9KSooPzoke2xldHRlcnN9ezIsM318JHtsZXR0ZXJzfXszfT18JHtsZXR0ZXJzfXsyfT09KT8kYCwgJ3UnKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLnBhdHRlcm4pKHN0cnVjdCwgcmUpO1xufTtcbmV4cG9ydHMuYmFzZTY0ID0gYmFzZTY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTY0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVEYXRhVmlldyA9IGV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBleHBvcnRzLnZhbHVlVG9CeXRlcyA9IGV4cG9ydHMuc3RyaW5nVG9CeXRlcyA9IGV4cG9ydHMubnVtYmVyVG9CeXRlcyA9IGV4cG9ydHMuc2lnbmVkQmlnSW50VG9CeXRlcyA9IGV4cG9ydHMuYmlnSW50VG9CeXRlcyA9IGV4cG9ydHMuaGV4VG9CeXRlcyA9IGV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGV4cG9ydHMuYnl0ZXNUb051bWJlciA9IGV4cG9ydHMuYnl0ZXNUb1NpZ25lZEJpZ0ludCA9IGV4cG9ydHMuYnl0ZXNUb0JpZ0ludCA9IGV4cG9ydHMuYnl0ZXNUb0hleCA9IGV4cG9ydHMuYXNzZXJ0SXNCeXRlcyA9IGV4cG9ydHMuaXNCeXRlcyA9IHZvaWQgMDtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuY29uc3QgaGV4XzEgPSByZXF1aXJlKFwiLi9oZXhcIik7XG4vLyAnMCcuY2hhckNvZGVBdCgwKSA9PT0gNDhcbmNvbnN0IEhFWF9NSU5JTVVNX05VTUJFUl9DSEFSQUNURVIgPSA0ODtcbi8vICc5Jy5jaGFyQ29kZUF0KDApID09PSA1N1xuY29uc3QgSEVYX01BWElNVU1fTlVNQkVSX0NIQVJBQ1RFUiA9IDU4O1xuY29uc3QgSEVYX0NIQVJBQ1RFUl9PRkZTRVQgPSA4Nztcbi8qKlxuICogTWVtb2l6ZWQgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGFycmF5IHRvIGJlIHVzZWQgYXMgYSBsb29rdXAgdGFibGUgZm9yXG4gKiBjb252ZXJ0aW5nIGJ5dGVzIHRvIGhleGFkZWNpbWFsIHZhbHVlcy5cbiAqXG4gKiBUaGUgYXJyYXkgaXMgY3JlYXRlZCBsYXppbHkgYW5kIHRoZW4gY2FjaGVkIGZvciBmdXR1cmUgdXNlLiBUaGUgYmVuZWZpdCBvZlxuICogdGhpcyBhcHByb2FjaCBpcyB0aGF0IHRoZSBwZXJmb3JtYW5jZSBvZiBjb252ZXJ0aW5nIGJ5dGVzIHRvIGhleCBpcyBtdWNoXG4gKiBiZXR0ZXIgdGhhbiBpZiB3ZSB3ZXJlIHRvIGNhbGwgYHRvU3RyaW5nKDE2KWAgb24gZWFjaCBieXRlLlxuICpcbiAqIFRoZSBkb3duc2lkZSBpcyB0aGF0IHRoZSBhcnJheSBpcyBjcmVhdGVkIG9uY2UgYW5kIHRoZW4gbmV2ZXIgZ2FyYmFnZVxuICogY29sbGVjdGVkLiBUaGlzIGlzIG5vdCBhIHByb2JsZW0gaW4gcHJhY3RpY2UgYmVjYXVzZSB0aGUgYXJyYXkgaXMgb25seSAyNTZcbiAqIGVsZW1lbnRzIGxvbmcuXG4gKlxuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGxvb2t1cCB0YWJsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXNCdWlsZGVyKCkge1xuICAgIC8vIFRvIGF2b2lkIGlzc3VlcyB3aXRoIHRyZWUgc2hha2luZywgd2UgbmVlZCB0byB1c2UgYSBmdW5jdGlvbiB0byByZXR1cm4gdGhlXG4gICAgLy8gYXJyYXkuIFRoaXMgaXMgYmVjYXVzZSB0aGUgYXJyYXkgaXMgb25seSB1c2VkIGluIHRoZSBgYnl0ZXNUb0hleGAgZnVuY3Rpb25cbiAgICAvLyBhbmQgaWYgd2Ugd2VyZSB0byB1c2UgYSBnbG9iYWwgdmFyaWFibGUsIHRoZSBhcnJheSBtaWdodCBiZSByZW1vdmVkIGJ5IHRoZVxuICAgIC8vIHRyZWUgc2hha2VyLlxuICAgIGNvbnN0IGxvb2t1cFRhYmxlID0gW107XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKGxvb2t1cFRhYmxlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGxvb2t1cFRhYmxlLnB1c2goaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvb2t1cFRhYmxlO1xuICAgIH07XG59XG4vKipcbiAqIEZ1bmN0aW9uIGltcGxlbWVudGF0aW9uIG9mIHRoZSB7QGxpbmsgZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXNCdWlsZGVyfVxuICogZnVuY3Rpb24uXG4gKi9cbmNvbnN0IGdldFByZWNvbXB1dGVkSGV4VmFsdWVzID0gZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXNCdWlsZGVyKCk7XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBgVWludDhBcnJheWAuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGlzQnl0ZXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xufVxuZXhwb3J0cy5pc0J5dGVzID0gaXNCeXRlcztcbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzQnl0ZXModmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShpc0J5dGVzKHZhbHVlKSwgJ1ZhbHVlIG11c3QgYmUgYSBVaW50OEFycmF5LicpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0J5dGVzID0gYXNzZXJ0SXNCeXRlcztcbi8qKlxuICogQ29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnMHgnO1xuICAgIH1cbiAgICBjb25zdCBsb29rdXBUYWJsZSA9IGdldFByZWNvbXB1dGVkSGV4VmFsdWVzKCk7XG4gICAgY29uc3QgaGV4YWRlY2ltYWwgPSBuZXcgQXJyYXkoYnl0ZXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGhleGFkZWNpbWFsW2ldID0gbG9va3VwVGFibGVbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGhleF8xLmFkZDB4KShoZXhhZGVjaW1hbC5qb2luKCcnKSk7XG59XG5leHBvcnRzLmJ5dGVzVG9IZXggPSBieXRlc1RvSGV4O1xuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgYGJpZ2ludGAuXG4gKlxuICogVG8gY29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBudW1iZXJgIGluc3RlYWQsIHVzZSB7QGxpbmsgYnl0ZXNUb051bWJlcn0uXG4gKiBUbyBjb252ZXJ0IGEgdHdvJ3MgY29tcGxlbWVudCBlbmNvZGVkIGBVaW50OEFycmF5YCB0byBhIGBiaWdpbnRgLCB1c2VcbiAqIHtAbGluayBieXRlc1RvU2lnbmVkQmlnSW50fS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIGBiaWdpbnRgLlxuICogQHJldHVybnMgVGhlIGBiaWdpbnRgLlxuICovXG5mdW5jdGlvbiBieXRlc1RvQmlnSW50KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgY29uc3QgaGV4YWRlY2ltYWwgPSBieXRlc1RvSGV4KGJ5dGVzKTtcbiAgICByZXR1cm4gQmlnSW50KGhleGFkZWNpbWFsKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb0JpZ0ludCA9IGJ5dGVzVG9CaWdJbnQ7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBzaWduZWQgYGJpZ2ludGAuIFRoaXMgYXNzdW1lcyB0aGF0IHRoZSBieXRlcyBhcmVcbiAqIGVuY29kZWQgaW4gdHdvJ3MgY29tcGxlbWVudC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGFuIHVuc2lnbmVkIGBiaWdpbnRgIGluc3RlYWQsIHVzZVxuICoge0BsaW5rIGJ5dGVzVG9CaWdJbnR9LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHdvJTI3c19jb21wbGVtZW50XG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIHNpZ25lZCBgYmlnaW50YC5cbiAqIEByZXR1cm5zIFRoZSBzaWduZWQgYGJpZ2ludGAuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9TaWduZWRCaWdJbnQoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICBsZXQgdmFsdWUgPSBCaWdJbnQoMCk7XG4gICAgZm9yIChjb25zdCBieXRlIG9mIGJ5dGVzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIHZhbHVlID0gKHZhbHVlIDw8IEJpZ0ludCg4KSkgKyBCaWdJbnQoYnl0ZSk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQuYXNJbnROKGJ5dGVzLmxlbmd0aCAqIDgsIHZhbHVlKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb1NpZ25lZEJpZ0ludCA9IGJ5dGVzVG9TaWduZWRCaWdJbnQ7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBgbnVtYmVyYC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgYGJpZ2ludGAgaW5zdGVhZCwgdXNlIHtAbGluayBieXRlc1RvQmlnSW50fS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIG51bWJlci5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIuXG4gKiBAdGhyb3dzIElmIHRoZSByZXN1bHRpbmcgbnVtYmVyIGlzIG5vdCBhIHNhZmUgaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb051bWJlcihieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIGNvbnN0IGJpZ2ludCA9IGJ5dGVzVG9CaWdJbnQoYnl0ZXMpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGJpZ2ludCA8PSBCaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpLCAnTnVtYmVyIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBieXRlc1RvQmlnSW50YCBpbnN0ZWFkLicpO1xuICAgIHJldHVybiBOdW1iZXIoYmlnaW50KTtcbn1cbmV4cG9ydHMuYnl0ZXNUb051bWJlciA9IGJ5dGVzVG9OdW1iZXI7XG4vKipcbiAqIENvbnZlcnQgYSBVVEYtOCBlbmNvZGVkIGBVaW50OEFycmF5YCB0byBhIGBzdHJpbmdgLlxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjb252ZXJ0IHRvIGEgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xufVxuZXhwb3J0cy5ieXRlc1RvU3RyaW5nID0gYnl0ZXNUb1N0cmluZztcbi8qKlxuICogQ29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIGBVaW50OEFycmF5YC4gVGhlIHN0cmluZyBjYW4gb3B0aW9uYWxseSBiZVxuICogcHJlZml4ZWQgd2l0aCBgMHhgLiBJdCBhY2NlcHRzIGV2ZW4gYW5kIG9kZCBsZW5ndGggc3RyaW5ncy5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgXCIweFwiLCBhbiBlbXB0eSBgVWludDhBcnJheWAgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gaGV4VG9CeXRlcyh2YWx1ZSkge1xuICAgIHZhciBfYTtcbiAgICAvLyBcIjB4XCIgaXMgb2Z0ZW4gdXNlZCBhcyBlbXB0eSBieXRlIGFycmF5LlxuICAgIGlmICgoKF9hID0gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLnRvTG93ZXJDYXNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh2YWx1ZSkpID09PSAnMHgnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICAoMCwgaGV4XzEuYXNzZXJ0SXNIZXhTdHJpbmcpKHZhbHVlKTtcbiAgICAvLyBSZW1vdmUgdGhlIGAweGAgcHJlZml4IGlmIGl0IGV4aXN0cywgYW5kIHBhZCB0aGUgc3RyaW5nIHRvIGhhdmUgYW4gZXZlblxuICAgIC8vIG51bWJlciBvZiBjaGFyYWN0ZXJzLlxuICAgIGNvbnN0IHN0cmlwcGVkVmFsdWUgPSAoMCwgaGV4XzEucmVtb3ZlMHgpKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZSA9IHN0cmlwcGVkVmFsdWUubGVuZ3RoICUgMiA9PT0gMCA/IHN0cmlwcGVkVmFsdWUgOiBgMCR7c3RyaXBwZWRWYWx1ZX1gO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobm9ybWFsaXplZFZhbHVlLmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gV2hpbGUgdGhpcyBpcyBub3QgdGhlIHByZXR0aWVzdCB3YXkgdG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhXG4gICAgICAgIC8vIGBVaW50OEFycmF5YCwgaXQgaXMgYSBsb3QgZmFzdGVyIHRoYW4gdXNpbmcgYHBhcnNlSW50YCB0byBjb252ZXJ0IGVhY2hcbiAgICAgICAgLy8gY2hhcmFjdGVyLlxuICAgICAgICBjb25zdCBjMSA9IG5vcm1hbGl6ZWRWYWx1ZS5jaGFyQ29kZUF0KGkgKiAyKTtcbiAgICAgICAgY29uc3QgYzIgPSBub3JtYWxpemVkVmFsdWUuY2hhckNvZGVBdChpICogMiArIDEpO1xuICAgICAgICBjb25zdCBuMSA9IGMxIC1cbiAgICAgICAgICAgIChjMSA8IEhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA/IEhFWF9NSU5JTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA6IEhFWF9DSEFSQUNURVJfT0ZGU0VUKTtcbiAgICAgICAgY29uc3QgbjIgPSBjMiAtXG4gICAgICAgICAgICAoYzIgPCBIRVhfTUFYSU1VTV9OVU1CRVJfQ0hBUkFDVEVSXG4gICAgICAgICAgICAgICAgPyBIRVhfTUlOSU1VTV9OVU1CRVJfQ0hBUkFDVEVSXG4gICAgICAgICAgICAgICAgOiBIRVhfQ0hBUkFDVEVSX09GRlNFVCk7XG4gICAgICAgIGJ5dGVzW2ldID0gbjEgKiAxNiArIG4yO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYGJpZ2ludGAgdG8gYSBgVWludDhBcnJheWAuXG4gKlxuICogVGhpcyBhc3N1bWVzIHRoYXQgdGhlIGBiaWdpbnRgIGlzIGFuIHVuc2lnbmVkIGludGVnZXIuIFRvIGNvbnZlcnQgYSBzaWduZWRcbiAqIGBiaWdpbnRgIGluc3RlYWQsIHVzZSB7QGxpbmsgc2lnbmVkQmlnSW50VG9CeXRlc30uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGJpZ2ludCB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmlnSW50VG9CeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcsICdWYWx1ZSBtdXN0IGJlIGEgYmlnaW50LicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IEJpZ0ludCgwKSwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgYmlnaW50LicpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXhUb0J5dGVzKGhleGFkZWNpbWFsKTtcbn1cbmV4cG9ydHMuYmlnSW50VG9CeXRlcyA9IGJpZ0ludFRvQnl0ZXM7XG4vKipcbiAqIENoZWNrIGlmIGEgYGJpZ2ludGAgZml0cyBpbiBhIGNlcnRhaW4gbnVtYmVyIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBgYmlnaW50YCB0byBjaGVjay5cbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBudW1iZXIgb2YgYnl0ZXMuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBgYmlnaW50YCBmaXRzIGluIHRoZSBudW1iZXIgb2YgYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIGJpZ0ludEZpdHModmFsdWUsIGJ5dGVzKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYnl0ZXMgPiAwKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gICAgY29uc3QgbWFzayA9IHZhbHVlID4+IEJpZ0ludCgzMSk7XG4gICAgcmV0dXJuICEoKCh+dmFsdWUgJiBtYXNrKSArICh2YWx1ZSAmIH5tYXNrKSkgPj4gQmlnSW50KGJ5dGVzICogOCArIH4wKSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1iaXR3aXNlICovXG59XG4vKipcbiAqIENvbnZlcnQgYSBzaWduZWQgYGJpZ2ludGAgdG8gYSBgVWludDhBcnJheWAuIFRoaXMgdXNlcyB0d28ncyBjb21wbGVtZW50XG4gKiBlbmNvZGluZyB0byByZXByZXNlbnQgbmVnYXRpdmUgbnVtYmVycy5cbiAqXG4gKiBUbyBjb252ZXJ0IGFuIHVuc2lnbmVkIGBiaWdpbnRgIHRvIGEgYFVpbnQ4QXJyYXlgIGluc3RlYWQsIHVzZVxuICoge0BsaW5rIGJpZ0ludFRvQnl0ZXN9LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHdvJTI3c19jb21wbGVtZW50XG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcGFyYW0gYnl0ZUxlbmd0aCAtIFRoZSBsZW5ndGggb2YgdGhlIHJlc3VsdGluZyBgVWludDhBcnJheWAuIElmIHRoZSBudW1iZXJcbiAqIGlzIGxhcmdlciB0aGFuIHRoZSBtYXhpbXVtIHZhbHVlIHRoYXQgY2FuIGJlIHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiBsZW5ndGgsXG4gKiBhbiBlcnJvciBpcyB0aHJvd24uXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBzaWduZWRCaWdJbnRUb0J5dGVzKHZhbHVlLCBieXRlTGVuZ3RoKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JywgJ1ZhbHVlIG11c3QgYmUgYSBiaWdpbnQuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIGJ5dGVMZW5ndGggPT09ICdudW1iZXInLCAnQnl0ZSBsZW5ndGggbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShieXRlTGVuZ3RoID4gMCwgJ0J5dGUgbGVuZ3RoIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYmlnSW50Rml0cyh2YWx1ZSwgYnl0ZUxlbmd0aCksICdCeXRlIGxlbmd0aCBpcyB0b28gc21hbGwgdG8gcmVwcmVzZW50IHRoZSBnaXZlbiB2YWx1ZS4nKTtcbiAgICAvLyBFU0xpbnQgZG9lc24ndCBsaWtlIG11dGF0aW5nIGZ1bmN0aW9uIHBhcmFtZXRlcnMsIHNvIHRvIGF2b2lkIGhhdmluZyB0b1xuICAgIC8vIGRpc2FibGUgdGhlIHJ1bGUsIHdlIGNyZWF0ZSBhIG5ldyB2YXJpYWJsZS5cbiAgICBsZXQgbnVtYmVyVmFsdWUgPSB2YWx1ZTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBOdW1iZXIoQmlnSW50LmFzVWludE4oOCwgbnVtYmVyVmFsdWUpKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgbnVtYmVyVmFsdWUgPj49IEJpZ0ludCg4KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzLnJldmVyc2UoKTtcbn1cbmV4cG9ydHMuc2lnbmVkQmlnSW50VG9CeXRlcyA9IHNpZ25lZEJpZ0ludFRvQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgbnVtYmVyYCB0byBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICogQHRocm93cyBJZiB0aGUgbnVtYmVyIGlzIG5vdCBhIHNhZmUgaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gbnVtYmVyVG9CeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdWYWx1ZSBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IDAsICdWYWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSksICdWYWx1ZSBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgYmlnSW50VG9CeXRlc2AgaW5zdGVhZC4nKTtcbiAgICBjb25zdCBoZXhhZGVjaW1hbCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhoZXhhZGVjaW1hbCk7XG59XG5leHBvcnRzLm51bWJlclRvQnl0ZXMgPSBudW1iZXJUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYHN0cmluZ2AgdG8gYSBVVEYtOCBlbmNvZGVkIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJywgJ1ZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG59XG5leHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBzdHJpbmdUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYnl0ZS1saWtlIHZhbHVlIHRvIGEgYFVpbnQ4QXJyYXlgLiBUaGUgdmFsdWUgY2FuIGJlIGEgYFVpbnQ4QXJyYXlgLFxuICogYSBgYmlnaW50YCwgYSBgbnVtYmVyYCwgb3IgYSBgc3RyaW5nYC5cbiAqXG4gKiBUaGlzIHdpbGwgYXR0ZW1wdCB0byBndWVzcyB0aGUgdHlwZSBvZiB0aGUgdmFsdWUgYmFzZWQgb24gaXRzIHR5cGUgYW5kXG4gKiBjb250ZW50cy4gRm9yIG1vcmUgY29udHJvbCBvdmVyIHRoZSBjb252ZXJzaW9uLCB1c2UgdGhlIG1vcmUgc3BlY2lmaWNcbiAqIGNvbnZlcnNpb24gZnVuY3Rpb25zLCBzdWNoIGFzIHtAbGluayBoZXhUb0J5dGVzfSBvciB7QGxpbmsgc3RyaW5nVG9CeXRlc30uXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIGEgYHN0cmluZ2AsIGFuZCBpdCBpcyBwcmVmaXhlZCB3aXRoIGAweGAsIGl0IHdpbGwgYmVcbiAqIGludGVycHJldGVkIGFzIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBPdGhlcndpc2UsIGl0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgYVxuICogVVRGLTggc3RyaW5nLiBUbyBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGJ5dGVzIHdpdGhvdXQgaW50ZXJwcmV0aW5nXG4gKiBpdCBhcyBhIFVURi04IHN0cmluZywgdXNlIHtAbGluayBoZXhUb0J5dGVzfSBpbnN0ZWFkLlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyBhIGBiaWdpbnRgLCBpdCBpcyBhc3N1bWVkIHRvIGJlIHVuc2lnbmVkLiBUbyBjb252ZXJ0IGEgc2lnbmVkXG4gKiBgYmlnaW50YCB0byBieXRlcywgdXNlIHtAbGluayBzaWduZWRCaWdJbnRUb0J5dGVzfSBpbnN0ZWFkLlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YCwgaXQgd2lsbCBiZSByZXR1cm5lZCBhcy1pcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIHZhbHVlVG9CeXRlcyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHJldHVybiBiaWdJbnRUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlclRvQnl0ZXModmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGlzQnl0ZXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdmFsdWUgdHlwZTogXCIke3R5cGVvZiB2YWx1ZX1cIi5gKTtcbn1cbmV4cG9ydHMudmFsdWVUb0J5dGVzID0gdmFsdWVUb0J5dGVzO1xuLyoqXG4gKiBDb25jYXRlbmF0ZSBtdWx0aXBsZSBieXRlLWxpa2UgdmFsdWVzIGludG8gYSBzaW5nbGUgYFVpbnQ4QXJyYXlgLiBUaGUgdmFsdWVzXG4gKiBjYW4gYmUgYFVpbnQ4QXJyYXlgLCBgYmlnaW50YCwgYG51bWJlcmAsIG9yIGBzdHJpbmdgLiBUaGlzIHVzZXNcbiAqIHtAbGluayB2YWx1ZVRvQnl0ZXN9IHVuZGVyIHRoZSBob29kIHRvIGNvbnZlcnQgZWFjaCB2YWx1ZSB0byBieXRlcy4gUmVmZXIgdG9cbiAqIHRoZSBkb2N1bWVudGF0aW9uIG9mIHRoYXQgZnVuY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gKiBAcmV0dXJucyBUaGUgY29uY2F0ZW5hdGVkIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29uY2F0Qnl0ZXModmFsdWVzKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlcyA9IG5ldyBBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICBsZXQgYnl0ZUxlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZVRvQnl0ZXModmFsdWVzW2ldKTtcbiAgICAgICAgbm9ybWFsaXplZFZhbHVlc1tpXSA9IHZhbHVlO1xuICAgICAgICBieXRlTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShieXRlTGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IG5vcm1hbGl6ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gV2hpbGUgd2UgY291bGQgc2ltcGx5IHNwcmVhZCB0aGUgdmFsdWVzIGludG8gYW4gYXJyYXkgYW5kIHVzZVxuICAgICAgICAvLyBgVWludDhBcnJheS5mcm9tYCwgdGhhdCBpcyBhIGxvdCBzbG93ZXIgdGhhbiB1c2luZyBgVWludDhBcnJheS5zZXRgLlxuICAgICAgICBieXRlcy5zZXQobm9ybWFsaXplZFZhbHVlc1tpXSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IG5vcm1hbGl6ZWRWYWx1ZXNbaV0ubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnRzLmNvbmNhdEJ5dGVzID0gY29uY2F0Qnl0ZXM7XG4vKipcbiAqIENyZWF0ZSBhIHtAbGluayBEYXRhVmlld30gZnJvbSBhIHtAbGluayBVaW50OEFycmF5fS4gVGhpcyBpcyBhIGNvbnZlbmllbmNlXG4gKiBmdW5jdGlvbiB0aGF0IGF2b2lkcyBoYXZpbmcgdG8gY3JlYXRlIGEge0BsaW5rIERhdGFWaWV3fSBtYW51YWxseSwgd2hpY2hcbiAqIHJlcXVpcmVzIHBhc3NpbmcgdGhlIGBieXRlT2Zmc2V0YCBhbmQgYGJ5dGVMZW5ndGhgIHBhcmFtZXRlcnMgZXZlcnkgdGltZS5cbiAqXG4gKiBOb3QgcGFzc2luZyB0aGUgYGJ5dGVPZmZzZXRgIGFuZCBgYnl0ZUxlbmd0aGAgcGFyYW1ldGVycyBjYW4gcmVzdWx0IGluXG4gKiB1bmV4cGVjdGVkIGJlaGF2aW9yIHdoZW4gdGhlIHtAbGluayBVaW50OEFycmF5fSBpcyBhIHZpZXcgb2YgYSBsYXJnZXJcbiAqIHtAbGluayBBcnJheUJ1ZmZlcn0sIGUuZy4sIHdoZW4gdXNpbmcge0BsaW5rIFVpbnQ4QXJyYXkuc3ViYXJyYXl9LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYWxzbyBzdXBwb3J0cyBOb2RlLmpzIHtAbGluayBCdWZmZXJ9cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShbMSwgMiwgM10pO1xuICpcbiAqIC8vIFRoaXMgaXMgZXF1aXZhbGVudCB0bzpcbiAqIC8vIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gKiBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZURhdGFWaWV3KGJ5dGVzKTtcbiAqIGBgYFxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNyZWF0ZSB0aGUge0BsaW5rIERhdGFWaWV3fSBmcm9tLlxuICogQHJldHVybnMgVGhlIHtAbGluayBEYXRhVmlld30uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURhdGFWaWV3KGJ5dGVzKSB7XG4gICAgLy8gVG8gbWFpbnRhaW4gY29tcGF0aWJpbGl0eSB3aXRoIE5vZGUuanMsIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIGJ5dGVzIGFyZVxuICAgIC8vIGEgQnVmZmVyLiBJZiBzbywgd2UgbmVlZCB0byBzbGljZSB0aGUgYnVmZmVyIHRvIGdldCB0aGUgdW5kZXJseWluZ1xuICAgIC8vIEFycmF5QnVmZmVyLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgYnl0ZXMgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gYnl0ZXMuYnVmZmVyLnNsaWNlKGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVPZmZzZXQgKyBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aCk7XG59XG5leHBvcnRzLmNyZWF0ZURhdGFWaWV3ID0gY3JlYXRlRGF0YVZpZXc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hlY2tzdW1TdHJ1Y3QgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYmFzZTY0XzEgPSByZXF1aXJlKFwiLi9iYXNlNjRcIik7XG5leHBvcnRzLkNoZWNrc3VtU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEuc2l6ZSkoKDAsIGJhc2U2NF8xLmJhc2U2NCkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCB7IHBhZGRpbmdSZXF1aXJlZDogdHJ1ZSB9KSwgNDQsIDQ0KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrc3VtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVIZXggPSBleHBvcnRzLmNyZWF0ZUJ5dGVzID0gZXhwb3J0cy5jcmVhdGVCaWdJbnQgPSBleHBvcnRzLmNyZWF0ZU51bWJlciA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbmNvbnN0IGhleF8xID0gcmVxdWlyZShcIi4vaGV4XCIpO1xuY29uc3QgTnVtYmVyTGlrZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbKDAsIHN1cGVyc3RydWN0XzEubnVtYmVyKSgpLCAoMCwgc3VwZXJzdHJ1Y3RfMS5iaWdpbnQpKCksICgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgaGV4XzEuU3RyaWN0SGV4U3RydWN0XSk7XG5jb25zdCBOdW1iZXJDb2VyY2VyID0gKDAsIHN1cGVyc3RydWN0XzEuY29lcmNlKSgoMCwgc3VwZXJzdHJ1Y3RfMS5udW1iZXIpKCksIE51bWJlckxpa2VTdHJ1Y3QsIE51bWJlcik7XG5jb25zdCBCaWdJbnRDb2VyY2VyID0gKDAsIHN1cGVyc3RydWN0XzEuY29lcmNlKSgoMCwgc3VwZXJzdHJ1Y3RfMS5iaWdpbnQpKCksIE51bWJlckxpa2VTdHJ1Y3QsIEJpZ0ludCk7XG5jb25zdCBCeXRlc0xpa2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoW2hleF8xLlN0cmljdEhleFN0cnVjdCwgKDAsIHN1cGVyc3RydWN0XzEuaW5zdGFuY2UpKFVpbnQ4QXJyYXkpXSk7XG5jb25zdCBCeXRlc0NvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKCgwLCBzdXBlcnN0cnVjdF8xLmluc3RhbmNlKShVaW50OEFycmF5KSwgKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFtoZXhfMS5TdHJpY3RIZXhTdHJ1Y3RdKSwgYnl0ZXNfMS5oZXhUb0J5dGVzKTtcbmNvbnN0IEhleENvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKGhleF8xLlN0cmljdEhleFN0cnVjdCwgKDAsIHN1cGVyc3RydWN0XzEuaW5zdGFuY2UpKFVpbnQ4QXJyYXkpLCBieXRlc18xLmJ5dGVzVG9IZXgpO1xuLyoqXG4gKiBDcmVhdGUgYSBudW1iZXIgZnJvbSBhIG51bWJlci1saWtlIHZhbHVlLlxuICpcbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgbnVtYmVyLCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgYGJpZ2ludGAsIGl0IGlzIGNvbnZlcnRlZCB0byBhIG51bWJlci5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLCBpdCBpcyBpbnRlcnByZXRlZCBhcyBhIGRlY2ltYWwgbnVtYmVyLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpc1xuICogaW50ZXJwcmV0ZWQgYXMgYSBoZXhhZGVjaW1hbCBudW1iZXIuXG4gKlxuICogVGhpcyB2YWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaXMgYSBudW1iZXItbGlrZSB2YWx1ZSwgYW5kIHRoYXQgdGhlIHJlc3VsdGluZ1xuICogbnVtYmVyIGlzIG5vdCBgTmFOYCBvciBgSW5maW5pdHlgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCB2YWx1ZSA9IGNyZWF0ZU51bWJlcignMHgwMTAyMDMnKTtcbiAqIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gNjYwNTFcbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlTnVtYmVyKDEyM24pO1xuICogY29uc29sZS5sb2cob3RoZXJWYWx1ZSk7IC8vIDEyM1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY3JlYXRlIHRoZSBudW1iZXIgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIG51bWJlci5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIG51bWJlci1saWtlIHZhbHVlLCBvciBpZiB0aGUgcmVzdWx0aW5nIG51bWJlclxuICogaXMgYE5hTmAgb3IgYEluZmluaXR5YC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTnVtYmVyKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKSh2YWx1ZSwgTnVtYmVyQ29lcmNlcik7XG4gICAgICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc0Zpbml0ZShyZXN1bHQpLCBgRXhwZWN0ZWQgYSBudW1iZXItbGlrZSB2YWx1ZSwgZ290IFwiJHt2YWx1ZX1cIi5gKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBudW1iZXItbGlrZSB2YWx1ZSwgZ290IFwiJHt2YWx1ZX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZU51bWJlciA9IGNyZWF0ZU51bWJlcjtcbi8qKlxuICogQ3JlYXRlIGEgYGJpZ2ludGAgZnJvbSBhIG51bWJlci1saWtlIHZhbHVlLlxuICpcbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgbnVtYmVyLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBgYmlnaW50YC5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgYGJpZ2ludGAsIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGl0IGlzIGludGVycHJldGVkIGFzIGEgZGVjaW1hbCBudW1iZXIgYW5kXG4gKiBjb252ZXJ0ZWQgdG8gYSBgYmlnaW50YC5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgaGV4IHN0cmluZyAoaS5lLiwgaXQgc3RhcnRzIHdpdGggXCIweFwiKSwgaXQgaXNcbiAqIGludGVycHJldGVkIGFzIGEgaGV4YWRlY2ltYWwgbnVtYmVyIGFuZCBjb252ZXJ0ZWQgdG8gYSBgYmlnaW50YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgdmFsdWUgPSBjcmVhdGVCaWdJbnQoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vIDE2OTA5MDYwblxuICpcbiAqIGNvbnN0IG90aGVyVmFsdWUgPSBjcmVhdGVCaWdJbnQoMTIzKTtcbiAqIGNvbnNvbGUubG9nKG90aGVyVmFsdWUpOyAvLyAxMjNuXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjcmVhdGUgdGhlIGJpZ2ludCBmcm9tLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgYmlnaW50LlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJpZ0ludCh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFRoZSBgQmlnSW50YCBjb25zdHJ1Y3RvciB0aHJvd3MgaWYgdGhlIHZhbHVlIGlzIG5vdCBhIG51bWJlci1saWtlIHZhbHVlLlxuICAgICAgICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIHZhbGlkYXRlIHRoZSB2YWx1ZSBtYW51YWxseS5cbiAgICAgICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmNyZWF0ZSkodmFsdWUsIEJpZ0ludENvZXJjZXIpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2Ygc3VwZXJzdHJ1Y3RfMS5TdHJ1Y3RFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG51bWJlci1saWtlIHZhbHVlLCBnb3QgXCIke1N0cmluZyhlcnJvci52YWx1ZSl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVCaWdJbnQgPSBjcmVhdGVCaWdJbnQ7XG4vKipcbiAqIENyZWF0ZSBhIGJ5dGUgYXJyYXkgZnJvbSBhIGJ5dGVzLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBieXRlIGFycmF5LCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgaGV4IHN0cmluZyAoaS5lLiwgaXQgc3RhcnRzIHdpdGggXCIweFwiKSwgaXQgaXMgaW50ZXJwcmV0ZWRcbiAqIGFzIGEgaGV4YWRlY2ltYWwgbnVtYmVyIGFuZCBjb252ZXJ0ZWQgdG8gYSBieXRlIGFycmF5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCB2YWx1ZSA9IGNyZWF0ZUJ5dGVzKCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2codmFsdWUpOyAvLyBVaW50OEFycmF5IFsgMSwgMiwgMyBdXG4gKlxuICogY29uc3Qgb3RoZXJWYWx1ZSA9IGNyZWF0ZUJ5dGVzKCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2cob3RoZXJWYWx1ZSk7IC8vIFVpbnQ4QXJyYXkgWyAxLCAyLCAzIF1cbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgYnl0ZSBhcnJheSBmcm9tLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgYnl0ZSBhcnJheS5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIGJ5dGVzLWxpa2UgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ5dGVzKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJzB4Jykge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmNyZWF0ZSkodmFsdWUsIEJ5dGVzQ29lcmNlcik7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBzdXBlcnN0cnVjdF8xLlN0cnVjdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgYnl0ZXMtbGlrZSB2YWx1ZSwgZ290IFwiJHtTdHJpbmcoZXJyb3IudmFsdWUpfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlQnl0ZXMgPSBjcmVhdGVCeXRlcztcbi8qKlxuICogQ3JlYXRlIGEgaGV4YWRlY2ltYWwgc3RyaW5nIGZyb20gYSBieXRlcy1saWtlIHZhbHVlLlxuICpcbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgaGV4IHN0cmluZyAoaS5lLiwgaXQgc3RhcnRzIHdpdGggXCIweFwiKSwgaXQgaXMgcmV0dXJuZWRcbiAqIGFzLWlzLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBgVWludDhBcnJheWAsIGl0IGlzIGNvbnZlcnRlZCB0byBhIGhleCBzdHJpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlSGV4KG5ldyBVaW50OEFycmF5KFsxLCAyLCAzXSkpO1xuICogY29uc29sZS5sb2codmFsdWUpOyAvLyAnMHgwMTAyMDMnXG4gKlxuICogY29uc3Qgb3RoZXJWYWx1ZSA9IGNyZWF0ZUhleCgnMHgwMTAyMDMnKTtcbiAqIGNvbnNvbGUubG9nKG90aGVyVmFsdWUpOyAvLyAnMHgwMTAyMDMnXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjcmVhdGUgdGhlIGhleCBzdHJpbmcgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGhleCBzdHJpbmcuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBieXRlcy1saWtlIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVIZXgodmFsdWUpIHtcbiAgICBpZiAoKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICcweCcpKSB7XG4gICAgICAgIHJldHVybiAnMHgnO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKSh2YWx1ZSwgSGV4Q29lcmNlcik7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBzdXBlcnN0cnVjdF8xLlN0cnVjdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgYnl0ZXMtbGlrZSB2YWx1ZSwgZ290IFwiJHtTdHJpbmcoZXJyb3IudmFsdWUpfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlSGV4ID0gY3JlYXRlSGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29lcmNlcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0Zyb3plbk1hcF9tYXAsIF9Gcm96ZW5TZXRfc2V0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Gcm96ZW5TZXQgPSBleHBvcnRzLkZyb3plbk1hcCA9IHZvaWQgMDtcbi8qKlxuICogQSB7QGxpbmsgUmVhZG9ubHlNYXB9IHRoYXQgY2Fubm90IGJlIG1vZGlmaWVkIGFmdGVyIGluc3RhbnRpYXRpb24uXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gdXNlcyBhbiBpbm5lciBtYXAgaGlkZGVuIHZpYSBhIHByaXZhdGUgZmllbGQsIGFuZCB0aGVcbiAqIGltbXV0YWJpbGl0eSBndWFyYW50ZWUgcmVsaWVzIG9uIGl0IGJlaW5nIGltcG9zc2libGUgdG8gZ2V0IGEgcmVmZXJlbmNlXG4gKiB0byB0aGlzIG1hcC5cbiAqL1xuY2xhc3MgRnJvemVuTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihlbnRyaWVzKSB7XG4gICAgICAgIF9Gcm96ZW5NYXBfbWFwLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBuZXcgTWFwKGVudHJpZXMpLCBcImZcIik7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLnNpemU7XG4gICAgfVxuICAgIFsoX0Zyb3plbk1hcF9tYXAgPSBuZXcgV2Vha01hcCgpLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuZW50cmllcygpO1xuICAgIH1cbiAgICBmb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSB0byB3cmFwIHRoZSBzcGVjaWZpZWQgY2FsbGJhY2sgaW4gb3JkZXIgdG8gcHJldmVudCBpdCBmcm9tXG4gICAgICAgIC8vIHJlY2VpdmluZyBhIHJlZmVyZW5jZSB0byB0aGUgaW5uZXIgbWFwLlxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLmZvckVhY2goKHZhbHVlLCBrZXksIF9tYXApID0+IGNhbGxiYWNrZm4uY2FsbCh0aGlzQXJnLCB2YWx1ZSwga2V5LCB0aGlzKSk7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5nZXQoa2V5KTtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLmhhcyhrZXkpO1xuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLmtleXMoKTtcbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLnZhbHVlcygpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBGcm96ZW5NYXAoJHt0aGlzLnNpemV9KSB7JHt0aGlzLnNpemUgPiAwXG4gICAgICAgICAgICA/IGAgJHtbLi4udGhpcy5lbnRyaWVzKCldXG4gICAgICAgICAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgJHtTdHJpbmcoa2V5KX0gPT4gJHtTdHJpbmcodmFsdWUpfWApXG4gICAgICAgICAgICAgICAgLmpvaW4oJywgJyl9IGBcbiAgICAgICAgICAgIDogJyd9fWA7XG4gICAgfVxufVxuZXhwb3J0cy5Gcm96ZW5NYXAgPSBGcm96ZW5NYXA7XG4vKipcbiAqIEEge0BsaW5rIFJlYWRvbmx5U2V0fSB0aGF0IGNhbm5vdCBiZSBtb2RpZmllZCBhZnRlciBpbnN0YW50aWF0aW9uLlxuICogVGhlIGltcGxlbWVudGF0aW9uIHVzZXMgYW4gaW5uZXIgc2V0IGhpZGRlbiB2aWEgYSBwcml2YXRlIGZpZWxkLCBhbmQgdGhlXG4gKiBpbW11dGFiaWxpdHkgZ3VhcmFudGVlIHJlbGllcyBvbiBpdCBiZWluZyBpbXBvc3NpYmxlIHRvIGdldCBhIHJlZmVyZW5jZVxuICogdG8gdGhpcyBzZXQuXG4gKi9cbmNsYXNzIEZyb3plblNldCB7XG4gICAgY29uc3RydWN0b3IodmFsdWVzKSB7XG4gICAgICAgIF9Gcm96ZW5TZXRfc2V0LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBuZXcgU2V0KHZhbHVlcyksIFwiZlwiKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikuc2l6ZTtcbiAgICB9XG4gICAgWyhfRnJvemVuU2V0X3NldCA9IG5ldyBXZWFrTWFwKCksIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5lbnRyaWVzKCk7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICAvLyBXZSBoYXZlIHRvIHdyYXAgdGhlIHNwZWNpZmllZCBjYWxsYmFjayBpbiBvcmRlciB0byBwcmV2ZW50IGl0IGZyb21cbiAgICAgICAgLy8gcmVjZWl2aW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBpbm5lciBzZXQuXG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikuZm9yRWFjaCgodmFsdWUsIHZhbHVlMiwgX3NldCkgPT4gY2FsbGJhY2tmbi5jYWxsKHRoaXNBcmcsIHZhbHVlLCB2YWx1ZTIsIHRoaXMpKTtcbiAgICB9XG4gICAgaGFzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikuaGFzKHZhbHVlKTtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5rZXlzKCk7XG4gICAgfVxuICAgIHZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS52YWx1ZXMoKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgRnJvemVuU2V0KCR7dGhpcy5zaXplfSkgeyR7dGhpcy5zaXplID4gMFxuICAgICAgICAgICAgPyBgICR7Wy4uLnRoaXMudmFsdWVzKCldLm1hcCgobWVtYmVyKSA9PiBTdHJpbmcobWVtYmVyKSkuam9pbignLCAnKX0gYFxuICAgICAgICAgICAgOiAnJ319YDtcbiAgICB9XG59XG5leHBvcnRzLkZyb3plblNldCA9IEZyb3plblNldDtcbk9iamVjdC5mcmVlemUoRnJvemVuTWFwKTtcbk9iamVjdC5mcmVlemUoRnJvemVuTWFwLnByb3RvdHlwZSk7XG5PYmplY3QuZnJlZXplKEZyb3plblNldCk7XG5PYmplY3QuZnJlZXplKEZyb3plblNldC5wcm90b3R5cGUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sbGVjdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlbW92ZTB4ID0gZXhwb3J0cy5hZGQweCA9IGV4cG9ydHMuYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmcgPSBleHBvcnRzLmFzc2VydElzSGV4U3RyaW5nID0gZXhwb3J0cy5pc1N0cmljdEhleFN0cmluZyA9IGV4cG9ydHMuaXNIZXhTdHJpbmcgPSBleHBvcnRzLlN0cmljdEhleFN0cnVjdCA9IGV4cG9ydHMuSGV4U3RydWN0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuZXhwb3J0cy5IZXhTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5wYXR0ZXJuKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIC9eKD86MHgpP1swLTlhLWZdKyQvaXUpO1xuZXhwb3J0cy5TdHJpY3RIZXhTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5wYXR0ZXJuKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIC9eMHhbMC05YS1mXSskL2l1KTtcbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBoZXggc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkhleFN0cnVjdCk7XG59XG5leHBvcnRzLmlzSGV4U3RyaW5nID0gaXNIZXhTdHJpbmc7XG4vKipcbiAqIFN0cmljdGx5IGNoZWNrIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgaGV4IHN0cmluZy4gQSB2YWxpZCBoZXggc3RyaW5nIG11c3RcbiAqIHN0YXJ0IHdpdGggdGhlIFwiMHhcIi1wcmVmaXguXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdEhleFN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuU3RyaWN0SGV4U3RydWN0KTtcbn1cbmV4cG9ydHMuaXNTdHJpY3RIZXhTdHJpbmcgPSBpc1N0cmljdEhleFN0cmluZztcbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNIZXhTdHJpbmcodmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShpc0hleFN0cmluZyh2YWx1ZSksICdWYWx1ZSBtdXN0IGJlIGEgaGV4YWRlY2ltYWwgc3RyaW5nLicpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0hleFN0cmluZyA9IGFzc2VydElzSGV4U3RyaW5nO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgaGV4IHN0cmluZy4gQSB2YWxpZCBoZXggc3RyaW5nIG11c3Qgc3RhcnQgd2l0aFxuICogdGhlIFwiMHhcIi1wcmVmaXguXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmcodmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShpc1N0cmljdEhleFN0cmluZyh2YWx1ZSksICdWYWx1ZSBtdXN0IGJlIGEgaGV4YWRlY2ltYWwgc3RyaW5nLCBzdGFydGluZyB3aXRoIFwiMHhcIi4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmcgPSBhc3NlcnRJc1N0cmljdEhleFN0cmluZztcbi8qKlxuICogQWRkIHRoZSBgMHhgLXByZWZpeCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy4gSWYgdGhlIHN0cmluZyBhbHJlYWR5IGhhcyB0aGVcbiAqIHByZWZpeCwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKlxuICogQHBhcmFtIGhleGFkZWNpbWFsIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBhZGQgdGhlIHByZWZpeCB0by5cbiAqIEByZXR1cm5zIFRoZSBwcmVmaXhlZCBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGFkZDB4KGhleGFkZWNpbWFsKSB7XG4gICAgaWYgKGhleGFkZWNpbWFsLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgcmV0dXJuIGhleGFkZWNpbWFsO1xuICAgIH1cbiAgICBpZiAoaGV4YWRlY2ltYWwuc3RhcnRzV2l0aCgnMFgnKSkge1xuICAgICAgICByZXR1cm4gYDB4JHtoZXhhZGVjaW1hbC5zdWJzdHJpbmcoMil9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAweCR7aGV4YWRlY2ltYWx9YDtcbn1cbmV4cG9ydHMuYWRkMHggPSBhZGQweDtcbi8qKlxuICogUmVtb3ZlIHRoZSBgMHhgLXByZWZpeCBmcm9tIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBJZiB0aGUgc3RyaW5nIGRvZXNuJ3QgaGF2ZVxuICogdGhlIHByZWZpeCwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKlxuICogQHBhcmFtIGhleGFkZWNpbWFsIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byByZW1vdmUgdGhlIHByZWZpeCBmcm9tLlxuICogQHJldHVybnMgVGhlIHVuLXByZWZpeGVkIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlMHgoaGV4YWRlY2ltYWwpIHtcbiAgICBpZiAoaGV4YWRlY2ltYWwuc3RhcnRzV2l0aCgnMHgnKSB8fCBoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcwWCcpKSB7XG4gICAgICAgIHJldHVybiBoZXhhZGVjaW1hbC5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiBoZXhhZGVjaW1hbDtcbn1cbmV4cG9ydHMucmVtb3ZlMHggPSByZW1vdmUweDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc2VydFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZTY0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ieXRlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2hlY2tzdW1cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvZXJjZXJzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2xsZWN0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaGV4XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9qc29uXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9sb2dnaW5nXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9taXNjXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9udW1iZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL29wYXF1ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdGltZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmVyc2lvbnNcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlSnNvbkFuZEdldFNpemUgPSBleHBvcnRzLmdldEpzb25ScGNJZFZhbGlkYXRvciA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjRXJyb3IgPSBleHBvcnRzLmlzSnNvblJwY0Vycm9yID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNGYWlsdXJlID0gZXhwb3J0cy5pc0pzb25ScGNGYWlsdXJlID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNTdWNjZXNzID0gZXhwb3J0cy5pc0pzb25ScGNTdWNjZXNzID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNSZXNwb25zZSA9IGV4cG9ydHMuaXNKc29uUnBjUmVzcG9uc2UgPSBleHBvcnRzLmFzc2VydElzUGVuZGluZ0pzb25ScGNSZXNwb25zZSA9IGV4cG9ydHMuaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlID0gZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNGYWlsdXJlU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCA9IGV4cG9ydHMuUGVuZGluZ0pzb25ScGNSZXNwb25zZVN0cnVjdCA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjUmVxdWVzdCA9IGV4cG9ydHMuaXNKc29uUnBjUmVxdWVzdCA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjTm90aWZpY2F0aW9uID0gZXhwb3J0cy5pc0pzb25ScGNOb3RpZmljYXRpb24gPSBleHBvcnRzLkpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjUGFyYW1zU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QgPSBleHBvcnRzLmpzb25ycGMyID0gZXhwb3J0cy5pc1ZhbGlkSnNvbiA9IGV4cG9ydHMuSnNvblN0cnVjdCA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbmNvbnN0IG1pc2NfMSA9IHJlcXVpcmUoXCIuL21pc2NcIik7XG5leHBvcnRzLkpzb25TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5kZWZpbmUpKCdKc29uJywgKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgW2lzVmFsaWRdID0gdmFsaWRhdGVKc29uQW5kR2V0U2l6ZSh2YWx1ZSwgdHJ1ZSk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgIHJldHVybiAnRXhwZWN0ZWQgYSB2YWxpZCBKU09OLXNlcmlhbGl6YWJsZSB2YWx1ZSc7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29ufSB2YWx1ZSwgaS5lLiwgYSB2YWx1ZSB0aGF0IGlzXG4gKiBzZXJpYWxpemFibGUgdG8gSlNPTi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29ufSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEpzb24odmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1ZhbGlkSnNvbiA9IGlzVmFsaWRKc29uO1xuLyoqXG4gKiBUaGUgc3RyaW5nICcyLjAnLlxuICovXG5leHBvcnRzLmpzb25ycGMyID0gJzIuMCc7XG5leHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEubGl0ZXJhbCkoZXhwb3J0cy5qc29ucnBjMik7XG5leHBvcnRzLkpzb25ScGNJZFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm51bGxhYmxlKSgoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoWygwLCBzdXBlcnN0cnVjdF8xLm51bWJlcikoKSwgKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpXSkpO1xuZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vYmplY3QpKHtcbiAgICBjb2RlOiAoMCwgc3VwZXJzdHJ1Y3RfMS5pbnRlZ2VyKSgpLFxuICAgIG1lc3NhZ2U6ICgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSxcbiAgICBkYXRhOiAoMCwgc3VwZXJzdHJ1Y3RfMS5vcHRpb25hbCkoZXhwb3J0cy5Kc29uU3RydWN0KSxcbiAgICBzdGFjazogKDAsIHN1cGVyc3RydWN0XzEub3B0aW9uYWwpKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSksXG59KTtcbmV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKSgoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoWygwLCBzdXBlcnN0cnVjdF8xLnJlY29yZCkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCBleHBvcnRzLkpzb25TdHJ1Y3QpLCAoMCwgc3VwZXJzdHJ1Y3RfMS5hcnJheSkoZXhwb3J0cy5Kc29uU3RydWN0KV0pKTtcbmV4cG9ydHMuSnNvblJwY1JlcXVlc3RTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vYmplY3QpKHtcbiAgICBpZDogZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QsXG4gICAganNvbnJwYzogZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgICBtZXRob2Q6ICgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSxcbiAgICBwYXJhbXM6IGV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub21pdCkoZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCwgWydpZCddKTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufVxuICogb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNOb3RpZmljYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNOb3RpZmljYXRpb24gPSBpc0pzb25ScGNOb3RpZmljYXRpb247XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbih2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyBub3RpZmljYXRpb24nLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb24gPSBhc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb247XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXF1ZXN0fSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1JlcXVlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjUmVxdWVzdCA9IGlzSnNvblJwY1JlcXVlc3Q7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBKU09OLVJQQyByZXF1ZXN0IG9yIG5vdGlmaWNhdGlvbiB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1JlcXVlc3R9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjUmVxdWVzdCh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgcmVxdWVzdCcsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1JlcXVlc3QgPSBhc3NlcnRJc0pzb25ScGNSZXF1ZXN0O1xuZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KSh7XG4gICAgaWQ6IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgcmVzdWx0OiAoMCwgc3VwZXJzdHJ1Y3RfMS5vcHRpb25hbCkoKDAsIHN1cGVyc3RydWN0XzEudW5rbm93bikoKSksXG4gICAgZXJyb3I6ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKShleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCksXG59KTtcbmV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vYmplY3QpKHtcbiAgICBpZDogZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QsXG4gICAganNvbnJwYzogZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgICByZXN1bHQ6IGV4cG9ydHMuSnNvblN0cnVjdCxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9iamVjdCkoe1xuICAgIGlkOiBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCxcbiAgICBqc29ucnBjOiBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIGVycm9yOiBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoW1xuICAgIGV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QsXG4gICAgZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCxcbl0pO1xuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIHdoZXRoZXIgc3BlY2lmaWVkIEpTT04tUlBDIHJlc3BvbnNlIGlzIGFcbiAqIHtAbGluayBQZW5kaW5nSnNvblJwY1Jlc3BvbnNlfS5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgSlNPTi1SUEMgcmVzcG9uc2UgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgSlNPTi1SUEMgcmVzcG9uc2UgaXMgcGVuZGluZy5cbiAqL1xuZnVuY3Rpb24gaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKShyZXNwb25zZSwgZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlID0gaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgUGVuZGluZ0pzb25ScGNSZXNwb25zZX0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBKU09OLVJQQyByZXNwb25zZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgUGVuZGluZ0pzb25ScGNSZXNwb25zZX1cbiAqIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHJlc3BvbnNlLCBleHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QsICdJbnZhbGlkIHBlbmRpbmcgSlNPTi1SUEMgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBhc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHtAbGluayBKc29uUnBjUmVzcG9uc2V9LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBvYmplY3QgaXMgYSBKc29uUnBjUmVzcG9uc2UuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKShyZXNwb25zZSwgZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNSZXNwb25zZSA9IGlzSnNvblJwY1Jlc3BvbnNlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1Jlc3BvbnNlfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVzcG9uc2V9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY1Jlc3BvbnNlU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1Jlc3BvbnNlID0gYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNTdWNjZXNzfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1N1Y2Nlc3ModmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjU3VjY2VzcyA9IGlzSnNvblJwY1N1Y2Nlc3M7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1N1Y2Nlc3N9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjU3VjY2Vzcyh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgc3VjY2VzcyByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1N1Y2Nlc3MgPSBhc3NlcnRJc0pzb25ScGNTdWNjZXNzO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRmFpbHVyZX0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNGYWlsdXJlKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY0ZhaWx1cmUgPSBpc0pzb25ScGNGYWlsdXJlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNGYWlsdXJlfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY0ZhaWx1cmUodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIGZhaWx1cmUgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNGYWlsdXJlID0gYXNzZXJ0SXNKc29uUnBjRmFpbHVyZTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNFcnJvcih2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjRXJyb3IgPSBpc0pzb25ScGNFcnJvcjtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0Vycm9yfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY0Vycm9yKHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgZXJyb3InLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNFcnJvciA9IGFzc2VydElzSnNvblJwY0Vycm9yO1xuLyoqXG4gKiBHZXRzIGEgZnVuY3Rpb24gZm9yIHZhbGlkYXRpbmcgSlNPTi1SUEMgcmVxdWVzdCAvIHJlc3BvbnNlIGBpZGAgdmFsdWVzLlxuICpcbiAqIEJ5IG1hbmlwdWxhdGluZyB0aGUgb3B0aW9ucyBvZiB0aGlzIGZhY3RvcnksIHlvdSBjYW4gY29udHJvbCB0aGUgYmVoYXZpb3JcbiAqIG9mIHRoZSByZXN1bHRpbmcgdmFsaWRhdG9yIGZvciBzb21lIGVkZ2UgY2FzZXMuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2UgZS5nLlxuICogYG51bGxgIHNob3VsZCBzb21ldGltZXMgYnV0IG5vdCBhbHdheXMgYmUgcGVybWl0dGVkLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgZW1wdHkgc3RyaW5nIChgJydgKSBpcyBhbHdheXMgcGVybWl0dGVkIGJ5IHRoZSBKU09OLVJQQ1xuICogc3BlY2lmaWNhdGlvbiwgYnV0IHRoYXQga2luZCBvZiBzdWNrcyBhbmQgeW91IG1heSB3YW50IHRvIGZvcmJpZCBpdCBpbiBzb21lXG4gKiBpbnN0YW5jZXMgYW55d2F5LlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB0aGVcbiAqIFtKU09OLVJQQyBTcGVjaWZpY2F0aW9uXShodHRwczovL3d3dy5qc29ucnBjLm9yZy9zcGVjaWZpY2F0aW9uKS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIG9wdGlvbnMucGVybWl0RW1wdHlTdHJpbmcgLSBXaGV0aGVyIHRoZSBlbXB0eSBzdHJpbmcgKGkuZS4gYCcnYClcbiAqIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgdmFsaWQgSUQuIERlZmF1bHQ6IGB0cnVlYFxuICogQHBhcmFtIG9wdGlvbnMucGVybWl0RnJhY3Rpb25zIC0gV2hldGhlciBmcmFjdGlvbmFsIG51bWJlcnMgKGUuZy4gYDEuMmApXG4gKiBzaG91bGQgYmUgdHJlYXRlZCBhcyB2YWxpZCBJRHMuIERlZmF1bHQ6IGBmYWxzZWBcbiAqIEBwYXJhbSBvcHRpb25zLnBlcm1pdE51bGwgLSBXaGV0aGVyIGBudWxsYCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHZhbGlkIElELlxuICogRGVmYXVsdDogYHRydWVgXG4gKiBAcmV0dXJucyBUaGUgSlNPTi1SUEMgSUQgdmFsaWRhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRKc29uUnBjSWRWYWxpZGF0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcGVybWl0RW1wdHlTdHJpbmcsIHBlcm1pdEZyYWN0aW9ucywgcGVybWl0TnVsbCB9ID0gT2JqZWN0LmFzc2lnbih7IHBlcm1pdEVtcHR5U3RyaW5nOiB0cnVlLCBwZXJtaXRGcmFjdGlvbnM6IGZhbHNlLCBwZXJtaXROdWxsOiB0cnVlIH0sIG9wdGlvbnMpO1xuICAgIC8qKlxuICAgICAqIFR5cGUgZ3VhcmQgZm9yIHtAbGluayBKc29uUnBjSWR9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIEpTT04tUlBDIElEIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIElEIGlzIHZhbGlkIHBlciB0aGUgb3B0aW9ucyBnaXZlbiB0byB0aGVcbiAgICAgKiBmYWN0b3J5LlxuICAgICAqL1xuICAgIGNvbnN0IGlzVmFsaWRKc29uUnBjSWQgPSAoaWQpID0+IHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKHR5cGVvZiBpZCA9PT0gJ251bWJlcicgJiYgKHBlcm1pdEZyYWN0aW9ucyB8fCBOdW1iZXIuaXNJbnRlZ2VyKGlkKSkpIHx8XG4gICAgICAgICAgICAodHlwZW9mIGlkID09PSAnc3RyaW5nJyAmJiAocGVybWl0RW1wdHlTdHJpbmcgfHwgaWQubGVuZ3RoID4gMCkpIHx8XG4gICAgICAgICAgICAocGVybWl0TnVsbCAmJiBpZCA9PT0gbnVsbCkpO1xuICAgIH07XG4gICAgcmV0dXJuIGlzVmFsaWRKc29uUnBjSWQ7XG59XG5leHBvcnRzLmdldEpzb25ScGNJZFZhbGlkYXRvciA9IGdldEpzb25ScGNJZFZhbGlkYXRvcjtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSB2YWx1ZSBpcyBKU09OIHNlcmlhbGl6YWJsZSBhbmQgY291bnRzIHRoZSB0b3RhbCBudW1iZXJcbiAqIG9mIGJ5dGVzIG5lZWRlZCB0byBzdG9yZSB0aGUgc2VyaWFsaXplZCB2ZXJzaW9uIG9mIHRoZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ganNPYmplY3QgLSBQb3RlbnRpYWwgSlNPTiBzZXJpYWxpemFibGUgb2JqZWN0LlxuICogQHBhcmFtIHNraXBTaXppbmdQcm9jZXNzIC0gU2tpcCBKU09OIHNpemUgY2FsY3VsYXRpb24gKGRlZmF1bHQ6IGZhbHNlKS5cbiAqIEByZXR1cm5zIFR1cGxlIFtpc1ZhbGlkLCBwbGFpblRleHRTaXplSW5CeXRlc10gY29udGFpbmluZyBhIGJvb2xlYW4gdGhhdCBzaWduYWxzIHdoZXRoZXJcbiAqIHRoZSB2YWx1ZSB3YXMgc2VyaWFsaXphYmxlIGFuZCBhIG51bWJlciBvZiBieXRlcyB0aGF0IGl0IHdpbGwgdXNlIHdoZW4gc2VyaWFsaXplZCB0byBKU09OLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUpzb25BbmRHZXRTaXplKGpzT2JqZWN0LCBza2lwU2l6aW5nUHJvY2VzcyA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc2Vlbk9iamVjdHMgPSBuZXcgU2V0KCk7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYSB2YWx1ZSBpcyBKU09OIHNlcmlhbGl6YWJsZSBhbmQgY291bnRzIHRoZSB0b3RhbCBudW1iZXJcbiAgICAgKiBvZiBieXRlcyBuZWVkZWQgdG8gc3RvcmUgdGhlIHNlcmlhbGl6ZWQgdmVyc2lvbiBvZiB0aGUgdmFsdWUuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhlIGVuY29kaW5nIG9mIHRoZSBKU09OIGlzIGRvbmUgaW4gVVRGLTguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBQb3RlbnRpYWwgSlNPTiBzZXJpYWxpemFibGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHNraXBTaXppbmcgLSBTa2lwIEpTT04gc2l6ZSBjYWxjdWxhdGlvbiAoZGVmYXVsdDogZmFsc2UpLlxuICAgICAqIEByZXR1cm5zIFR1cGxlIFtpc1ZhbGlkLCBwbGFpblRleHRTaXplSW5CeXRlc10gY29udGFpbmluZyBhIGJvb2xlYW4gdGhhdCBzaWduYWxzIHdoZXRoZXJcbiAgICAgKiB0aGUgdmFsdWUgd2FzIHNlcmlhbGl6YWJsZSBhbmQgYSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBpdCB3aWxsIHVzZSB3aGVuIHNlcmlhbGl6ZWQgdG8gSlNPTi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRKc29uU2VyaWFsaXphYmxlSW5mbyh2YWx1ZSwgc2tpcFNpemluZykge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtmYWxzZSwgMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFJldHVybiBhbHJlYWR5IHNwZWNpZmllZCBjb25zdGFudCBzaXplIGZvciBudWxsIChzcGVjaWFsIG9iamVjdClcbiAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgc2tpcFNpemluZyA/IDAgOiBtaXNjXzEuSnNvblNpemUuTnVsbF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgYW5kIGNhbGN1bGF0ZSBzaXplcyBmb3IgYmFzaWMgKGFuZCBzb21lIHNwZWNpYWwpIHR5cGVzXG4gICAgICAgIGNvbnN0IHR5cGVPZlZhbHVlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVPZlZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtmYWxzZSwgMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlT2ZWYWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBza2lwU2l6aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKDAsIG1pc2NfMS5jYWxjdWxhdGVTdHJpbmdTaXplKSh2YWx1ZSkgKyBtaXNjXzEuSnNvblNpemUuUXVvdGUgKiAyLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlT2ZWYWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgICAgICAgICAgICAgIGlmIChza2lwU2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgICAgICAgICByZXR1cm4gW3RydWUsIHZhbHVlID09IHRydWUgPyBtaXNjXzEuSnNvblNpemUuVHJ1ZSA6IG1pc2NfMS5Kc29uU2l6ZS5GYWxzZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlT2ZWYWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcFNpemluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3RydWUsIDBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW3RydWUsICgwLCBtaXNjXzEuY2FsY3VsYXRlTnVtYmVyU2l6ZSkodmFsdWUpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChza2lwU2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IEludmFsaWQgZGF0ZXMgd2lsbCBzZXJpYWxpemUgdG8gbnVsbFxuICAgICAgICAgICAgICAgICAgICBpc05hTih2YWx1ZS5nZXREYXRlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG1pc2NfMS5Kc29uU2l6ZS5OdWxsXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG1pc2NfMS5Kc29uU2l6ZS5EYXRlICsgbWlzY18xLkpzb25TaXplLlF1b3RlICogMixcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gW2ZhbHNlLCAwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBvYmplY3QgaXMgbm90IHBsYWluIGFuZCBjYW5ub3QgYmUgc2VyaWFsaXplZCBwcm9wZXJseSxcbiAgICAgICAgLy8gc3RvcCBoZXJlIGFuZCByZXR1cm4gZmFsc2UgZm9yIHNlcmlhbGl6YXRpb25cbiAgICAgICAgaWYgKCEoMCwgbWlzY18xLmlzUGxhaW5PYmplY3QpKHZhbHVlKSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIDBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIENpcmN1bGFyIG9iamVjdCBkZXRlY3Rpb24gKGhhbmRsaW5nKVxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc2FtZSBvYmplY3QgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgaWYgKHNlZW5PYmplY3RzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIDBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBuZXcgb2JqZWN0IHRvIHRoZSBzZWVuIG9iamVjdHMgc2V0XG4gICAgICAgIC8vIE9ubHkgdGhlIHBsYWluIG9iamVjdHMgc2hvdWxkIGJlIGFkZGVkIChQcmltaXRpdmUgdHlwZXMgYXJlIHNraXBwZWQpXG4gICAgICAgIHNlZW5PYmplY3RzLmFkZCh2YWx1ZSk7XG4gICAgICAgIC8vIENvbnRpbnVlIG9iamVjdCBkZWNvbXBvc2l0aW9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLnJlZHVjZSgoc3VtLCBba2V5LCBuZXN0ZWRWYWx1ZV0sIGlkeCwgYXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHByb2Nlc3MgbmV4dCBuZXN0ZWQgb2JqZWN0IG9yIHByaW1pdGl2ZSB0eXBlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICAgICAgICAgICAgICAgICAgbGV0IFt2YWxpZCwgc2l6ZV0gPSBnZXRKc29uU2VyaWFsaXphYmxlSW5mbyhuZXN0ZWRWYWx1ZSwgc2tpcFNpemluZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlNPTiB2YWxpZGF0aW9uIGRpZCBub3QgcGFzcy4gVmFsaWRhdGlvbiBwcm9jZXNzIHN0b3BwZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2lyY3VsYXIgb2JqZWN0IGRldGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBPbmNlIGEgY2hpbGQgbm9kZSBpcyB2aXNpdGVkIGFuZCBwcm9jZXNzZWQgcmVtb3ZlIGl0IGZyb20gdGhlIHNldC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHByZXZlbnQgZmFsc2UgcG9zaXRpdmVzIHdpdGggdGhlIHNhbWUgYWRqYWNlbnQgb2JqZWN0cy5cbiAgICAgICAgICAgICAgICAgICAgc2Vlbk9iamVjdHMuZGVsZXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNraXBTaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE9iamVjdHMgd2lsbCBoYXZlIGJlIHNlcmlhbGl6ZWQgd2l0aCBcImtleVwiOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlcmVmb3JlIHdlIGluY2x1ZGUgdGhlIGtleSBpbiB0aGUgY2FsY3VsYXRpb24gaGVyZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlTaXplID0gQXJyYXkuaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBrZXkubGVuZ3RoICsgbWlzY18xLkpzb25TaXplLkNvbW1hICsgbWlzY18xLkpzb25TaXplLkNvbG9uICogMjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VwYXJhdG9yID0gaWR4IDwgYXJyLmxlbmd0aCAtIDEgPyBtaXNjXzEuSnNvblNpemUuQ29tbWEgOiAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VtICsga2V5U2l6ZSArIHNpemUgKyBzZXBhcmF0b3I7XG4gICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgLy8gU3RhcnRzIGF0IDIgYmVjYXVzZSB0aGUgc2VyaWFsaXplZCBKU09OIHN0cmluZyBkYXRhIChwbGFpbiB0ZXh0KVxuICAgICAgICAgICAgICAgIC8vIHdpbGwgbWluaW1hbGx5IGNvbnRhaW4ge30vW11cbiAgICAgICAgICAgICAgICBza2lwU2l6aW5nID8gMCA6IG1pc2NfMS5Kc29uU2l6ZS5XcmFwcGVyICogMiksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gW2ZhbHNlLCAwXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2V0SnNvblNlcmlhbGl6YWJsZUluZm8oanNPYmplY3QsIHNraXBTaXppbmdQcm9jZXNzKTtcbn1cbmV4cG9ydHMudmFsaWRhdGVKc29uQW5kR2V0U2l6ZSA9IHZhbGlkYXRlSnNvbkFuZEdldFNpemU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVNb2R1bGVMb2dnZXIgPSBleHBvcnRzLmNyZWF0ZVByb2plY3RMb2dnZXIgPSB2b2lkIDA7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBnbG9iYWxMb2dnZXIgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnbWV0YW1hc2snKTtcbi8qKlxuICogQ3JlYXRlcyBhIGxvZ2dlciB2aWEgdGhlIGBkZWJ1Z2AgbGlicmFyeSB3aG9zZSBsb2cgbWVzc2FnZXMgd2lsbCBiZSB0YWdnZWRcbiAqIHVzaW5nIHRoZSBuYW1lIG9mIHlvdXIgcHJvamVjdC4gQnkgZGVmYXVsdCwgc3VjaCBtZXNzYWdlcyB3aWxsIGJlXG4gKiBzdXBwcmVzc2VkLCBidXQgeW91IGNhbiByZXZlYWwgdGhlbSBieSBzZXR0aW5nIHRoZSBgREVCVUdgIGVudmlyb25tZW50XG4gKiB2YXJpYWJsZSB0byBgbWV0YW1hc2s6PHByb2plY3ROYW1lPmAuIFlvdSBjYW4gYWxzbyBzZXQgdGhpcyB2YXJpYWJsZSB0b1xuICogYG1ldGFtYXNrOipgIGlmIHlvdSB3YW50IHRvIHNlZSBsb2cgbWVzc2FnZXMgZnJvbSBhbGwgTWV0YU1hc2sgcHJvamVjdHMgdGhhdFxuICogYXJlIGFsc28gdXNpbmcgdGhpcyBmdW5jdGlvbiB0byBjcmVhdGUgdGhlaXIgbG9nZ2Vycy5cbiAqXG4gKiBAcGFyYW0gcHJvamVjdE5hbWUgLSBUaGUgbmFtZSBvZiB5b3VyIHByb2plY3QuIFRoaXMgc2hvdWxkIGJlIHRoZSBuYW1lIG9mXG4gKiB5b3VyIE5QTSBwYWNrYWdlIGlmIHlvdSdyZSBkZXZlbG9waW5nIG9uZS5cbiAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIGBkZWJ1Z2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb2plY3RMb2dnZXIocHJvamVjdE5hbWUpIHtcbiAgICByZXR1cm4gZ2xvYmFsTG9nZ2VyLmV4dGVuZChwcm9qZWN0TmFtZSk7XG59XG5leHBvcnRzLmNyZWF0ZVByb2plY3RMb2dnZXIgPSBjcmVhdGVQcm9qZWN0TG9nZ2VyO1xuLyoqXG4gKiBDcmVhdGVzIGEgbG9nZ2VyIHZpYSB0aGUgYGRlYnVnYCBsaWJyYXJ5IHdoaWNoIGlzIGRlcml2ZWQgZnJvbSB0aGUgbG9nZ2VyIGZvclxuICogdGhlIHdob2xlIHByb2plY3Qgd2hvc2UgbG9nIG1lc3NhZ2VzIHdpbGwgYmUgdGFnZ2VkIHVzaW5nIHRoZSBuYW1lIG9mIHlvdXJcbiAqIG1vZHVsZS4gQnkgZGVmYXVsdCwgc3VjaCBtZXNzYWdlcyB3aWxsIGJlIHN1cHByZXNzZWQsIGJ1dCB5b3UgY2FuIHJldmVhbCB0aGVtXG4gKiBieSBzZXR0aW5nIHRoZSBgREVCVUdgIGVudmlyb25tZW50IHZhcmlhYmxlIHRvXG4gKiBgbWV0YW1hc2s6PHByb2plY3ROYW1lPjo8bW9kdWxlTmFtZT5gLiBZb3UgY2FuIGFsc28gc2V0IHRoaXMgdmFyaWFibGUgdG9cbiAqIGBtZXRhbWFzazo8cHJvamVjdE5hbWU+OipgIGlmIHlvdSB3YW50IHRvIHNlZSBsb2cgbWVzc2FnZXMgZnJvbSB0aGUgcHJvamVjdCxcbiAqIG9yIGBtZXRhbWFzazoqYCBpZiB5b3Ugd2FudCB0byBzZWUgbG9nIG1lc3NhZ2VzIGZyb20gYWxsIE1ldGFNYXNrIHByb2plY3RzLlxuICpcbiAqIEBwYXJhbSBwcm9qZWN0TG9nZ2VyIC0gVGhlIGxvZ2dlciBjcmVhdGVkIHZpYSB7QGxpbmsgY3JlYXRlUHJvamVjdExvZ2dlcn0uXG4gKiBAcGFyYW0gbW9kdWxlTmFtZSAtIFRoZSBuYW1lIG9mIHlvdXIgbW9kdWxlLiBZb3UgY291bGQgdXNlIHRoZSBuYW1lIG9mIHRoZVxuICogZmlsZSB3aGVyZSB5b3UncmUgdXNpbmcgdGhpcyBsb2dnZXIgb3Igc29tZSBvdGhlciBuYW1lLlxuICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgYGRlYnVnYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9kdWxlTG9nZ2VyKHByb2plY3RMb2dnZXIsIG1vZHVsZU5hbWUpIHtcbiAgICByZXR1cm4gcHJvamVjdExvZ2dlci5leHRlbmQobW9kdWxlTmFtZSk7XG59XG5leHBvcnRzLmNyZWF0ZU1vZHVsZUxvZ2dlciA9IGNyZWF0ZU1vZHVsZUxvZ2dlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dpbmcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vL1xuLy8gVHlwZXNcbi8vXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhbGN1bGF0ZU51bWJlclNpemUgPSBleHBvcnRzLmNhbGN1bGF0ZVN0cmluZ1NpemUgPSBleHBvcnRzLmlzQVNDSUkgPSBleHBvcnRzLmlzUGxhaW5PYmplY3QgPSBleHBvcnRzLkVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCA9IGV4cG9ydHMuSnNvblNpemUgPSBleHBvcnRzLmhhc1Byb3BlcnR5ID0gZXhwb3J0cy5pc09iamVjdCA9IGV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBleHBvcnRzLmlzTm9uRW1wdHlBcnJheSA9IHZvaWQgMDtcbi8vXG4vLyBUeXBlIEd1YXJkc1xuLy9cbi8qKlxuICogQSB7QGxpbmsgTm9uRW1wdHlBcnJheX0gdHlwZSBndWFyZC5cbiAqXG4gKiBAdGVtcGxhdGUgRWxlbWVudCAtIFRoZSBub24tZW1wdHkgYXJyYXkgbWVtYmVyIHR5cGUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIG5vbi1lbXB0eSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gaXNOb25FbXB0eUFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA+IDA7XG59XG5leHBvcnRzLmlzTm9uRW1wdHlBcnJheSA9IGlzTm9uRW1wdHlBcnJheTtcbi8qKlxuICogVHlwZSBndWFyZCBmb3IgXCJudWxsaXNobmVzc1wiLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuLyoqXG4gKiBBIHR5cGUgZ3VhcmQgZm9yIHtAbGluayBSdW50aW1lT2JqZWN0fS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgdmFsdWUgaGFzIGEgcnVudGltZSB0eXBlIG9mIGBvYmplY3RgIGFuZCBpc1xuICogbmVpdGhlciBgbnVsbGAgbm9yIGFuIGBBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odmFsdWUpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuLy9cbi8vIE90aGVyIHV0aWxpdHkgZnVuY3Rpb25zXG4vL1xuLyoqXG4gKiBBIHR5cGUgZ3VhcmQgZm9yIGVuc3VyaW5nIGFuIG9iamVjdCBoYXMgYSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0VG9DaGVjayAtIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBwcm9wZXJ0eSBuYW1lIHRvIGNoZWNrIGZvci5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHNwZWNpZmllZCBvYmplY3QgaGFzIGFuIG93biBwcm9wZXJ0eSB3aXRoIHRoZSBzcGVjaWZpZWRcbiAqIG5hbWUsIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBpdCBpcyBlbnVtZXJhYmxlIG9yIG5vdC5cbiAqL1xuY29uc3QgaGFzUHJvcGVydHkgPSAob2JqZWN0VG9DaGVjaywgbmFtZSkgPT4gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0VG9DaGVjaywgbmFtZSk7XG5leHBvcnRzLmhhc1Byb3BlcnR5ID0gaGFzUHJvcGVydHk7XG4vKipcbiAqIFByZWRlZmluZWQgc2l6ZXMgKGluIEJ5dGVzKSBvZiBzcGVjaWZpYyBwYXJ0cyBvZiBKU09OIHN0cnVjdHVyZS5cbiAqL1xudmFyIEpzb25TaXplO1xuKGZ1bmN0aW9uIChKc29uU2l6ZSkge1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiTnVsbFwiXSA9IDRdID0gXCJOdWxsXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJDb21tYVwiXSA9IDFdID0gXCJDb21tYVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiV3JhcHBlclwiXSA9IDFdID0gXCJXcmFwcGVyXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJUcnVlXCJdID0gNF0gPSBcIlRydWVcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIkZhbHNlXCJdID0gNV0gPSBcIkZhbHNlXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJRdW90ZVwiXSA9IDFdID0gXCJRdW90ZVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiQ29sb25cIl0gPSAxXSA9IFwiQ29sb25cIjtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiRGF0ZVwiXSA9IDI0XSA9IFwiRGF0ZVwiO1xufSkoSnNvblNpemUgPSBleHBvcnRzLkpzb25TaXplIHx8IChleHBvcnRzLkpzb25TaXplID0ge30pKTtcbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHdpdGggcGF0dGVybiBtYXRjaGluZyBmb3IgKHNwZWNpYWwpIGVzY2FwZWQgY2hhcmFjdGVycy5cbiAqL1xuZXhwb3J0cy5FU0NBUEVfQ0hBUkFDVEVSU19SRUdFWFAgPSAvXCJ8XFxcXHxcXG58XFxyfFxcdC9ndTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgVHJ1ZSBpZiBhbiBvYmplY3QgaXMgdGhlIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0LFxuICogZmFsc2UgaWYgdGhlIG9iamVjdCBpcyBub3QgcGxhaW4gKGUuZy4gZnVuY3Rpb24pLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBsZXQgcHJvdG8gPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gcHJvdG87XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuLyoqXG4gKiBDaGVjayBpZiBjaGFyYWN0ZXIgaXMgQVNDSUkuXG4gKlxuICogQHBhcmFtIGNoYXJhY3RlciAtIENoYXJhY3Rlci5cbiAqIEByZXR1cm5zIFRydWUgaWYgYSBjaGFyYWN0ZXIgY29kZSBpcyBBU0NJSSwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBpc0FTQ0lJKGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIuY2hhckNvZGVBdCgwKSA8PSAxMjc7XG59XG5leHBvcnRzLmlzQVNDSUkgPSBpc0FTQ0lJO1xuLyoqXG4gKiBDYWxjdWxhdGUgc3RyaW5nIHNpemUuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gU3RyaW5nIHZhbHVlIHRvIGNhbGN1bGF0ZSBzaXplLlxuICogQHJldHVybnMgTnVtYmVyIG9mIGJ5dGVzIHVzZWQgdG8gc3RvcmUgd2hvbGUgc3RyaW5nIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVTdHJpbmdTaXplKHZhbHVlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHNpemUgPSB2YWx1ZS5zcGxpdCgnJykucmVkdWNlKCh0b3RhbCwgY2hhcmFjdGVyKSA9PiB7XG4gICAgICAgIGlmIChpc0FTQ0lJKGNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgIHJldHVybiB0b3RhbCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsICsgMjtcbiAgICB9LCAwKTtcbiAgICAvLyBBbHNvIGRldGVjdCBjaGFyYWN0ZXJzIHRoYXQgbmVlZCBiYWNrc2xhc2ggZXNjYXBlXG4gICAgcmV0dXJuIHNpemUgKyAoKF9hID0gdmFsdWUubWF0Y2goZXhwb3J0cy5FU0NBUEVfQ0hBUkFDVEVSU19SRUdFWFApKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSkubGVuZ3RoO1xufVxuZXhwb3J0cy5jYWxjdWxhdGVTdHJpbmdTaXplID0gY2FsY3VsYXRlU3RyaW5nU2l6ZTtcbi8qKlxuICogQ2FsY3VsYXRlIHNpemUgb2YgYSBudW1iZXIgb2Z0ZXIgSlNPTiBzZXJpYWxpemF0aW9uLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIE51bWJlciB2YWx1ZSB0byBjYWxjdWxhdGUgc2l6ZS5cbiAqIEByZXR1cm5zIE51bWJlciBvZiBieXRlcyB1c2VkIHRvIHN0b3JlIHdob2xlIG51bWJlciBpbiBKU09OLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVOdW1iZXJTaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCkubGVuZ3RoO1xufVxuZXhwb3J0cy5jYWxjdWxhdGVOdW1iZXJTaXplID0gY2FsY3VsYXRlTnVtYmVyU2l6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pc2MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhleFRvQmlnSW50ID0gZXhwb3J0cy5oZXhUb051bWJlciA9IGV4cG9ydHMuYmlnSW50VG9IZXggPSBleHBvcnRzLm51bWJlclRvSGV4ID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG5jb25zdCBoZXhfMSA9IHJlcXVpcmUoXCIuL2hleFwiKTtcbi8qKlxuICogQ29udmVydCBhIG51bWJlciB0byBhIGhleGFkZWNpbWFsIHN0cmluZy4gVGhpcyB2ZXJpZmllcyB0aGF0IHRoZSBudW1iZXIgaXMgYVxuICogbm9uLW5lZ2F0aXZlIHNhZmUgaW50ZWdlci5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgYGJpZ2ludGAgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcgaW5zdGVhZCwgdXNlXG4gKiB7QGxpbmsgYmlnSW50VG9IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBudW1iZXJUb0hleCgwKTsgLy8gJzB4MCdcbiAqIG51bWJlclRvSGV4KDEpOyAvLyAnMHgxJ1xuICogbnVtYmVyVG9IZXgoMTYpOyAvLyAnMHgxMCdcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIG51bWJlciB0byBjb252ZXJ0IHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIGhleGFkZWNpbWFsIHN0cmluZywgd2l0aCB0aGUgXCIweFwiLXByZWZpeC5cbiAqIEB0aHJvd3MgSWYgdGhlIG51bWJlciBpcyBub3QgYSBub24tbmVnYXRpdmUgc2FmZSBpbnRlZ2VyLlxuICovXG5jb25zdCBudW1iZXJUb0hleCA9ICh2YWx1ZSkgPT4ge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdWYWx1ZSBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IDAsICdWYWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSksICdWYWx1ZSBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgYmlnSW50VG9IZXhgIGluc3RlYWQuJyk7XG4gICAgcmV0dXJuICgwLCBoZXhfMS5hZGQweCkodmFsdWUudG9TdHJpbmcoMTYpKTtcbn07XG5leHBvcnRzLm51bWJlclRvSGV4ID0gbnVtYmVyVG9IZXg7XG4vKipcbiAqIENvbnZlcnQgYSBgYmlnaW50YCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy4gVGhpcyB2ZXJpZmllcyB0aGF0IHRoZSBgYmlnaW50YFxuICogaXMgYSBub24tbmVnYXRpdmUgaW50ZWdlci5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgbnVtYmVyIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nIGluc3RlYWQsIHVzZSB7QGxpbmsgbnVtYmVyVG9IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBiaWdJbnRUb0hleCgwbik7IC8vICcweDAnXG4gKiBiaWdJbnRUb0hleCgxbik7IC8vICcweDEnXG4gKiBiaWdJbnRUb0hleCgxNm4pOyAvLyAnMHgxMCdcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGBiaWdpbnRgIHRvIGNvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nLCB3aXRoIHRoZSBcIjB4XCItcHJlZml4LlxuICogQHRocm93cyBJZiB0aGUgYGJpZ2ludGAgaXMgbm90IGEgbm9uLW5lZ2F0aXZlIGludGVnZXIuXG4gKi9cbmNvbnN0IGJpZ0ludFRvSGV4ID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JywgJ1ZhbHVlIG11c3QgYmUgYSBiaWdpbnQuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodmFsdWUgPj0gMCwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgYmlnaW50LicpO1xuICAgIHJldHVybiAoMCwgaGV4XzEuYWRkMHgpKHZhbHVlLnRvU3RyaW5nKDE2KSk7XG59O1xuZXhwb3J0cy5iaWdJbnRUb0hleCA9IGJpZ0ludFRvSGV4O1xuLyoqXG4gKiBDb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgbnVtYmVyLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIHN0cmluZyBpcyBhXG4gKiB2YWxpZCBoZXggc3RyaW5nLCBhbmQgdGhhdCB0aGUgcmVzdWx0aW5nIG51bWJlciBpcyBhIHNhZmUgaW50ZWdlci4gQm90aFxuICogXCIweFwiLXByZWZpeGVkIGFuZCB1bnByZWZpeGVkIHN0cmluZ3MgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgYGJpZ2ludGAgaW5zdGVhZCwgdXNlXG4gKiB7QGxpbmsgaGV4VG9CaWdJbnR9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBoZXhUb051bWJlcignMHgwJyk7IC8vIDBcbiAqIGhleFRvTnVtYmVyKCcweDEnKTsgLy8gMVxuICogaGV4VG9OdW1iZXIoJzB4MTAnKTsgLy8gMTZcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0IHRvIGEgbnVtYmVyLlxuICogQHJldHVybnMgVGhlIG51bWJlci5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGhleGFkZWNpbWFsIHN0cmluZywgb3IgaWYgdGhlIHJlc3VsdGluZ1xuICogbnVtYmVyIGlzIG5vdCBhIHNhZmUgaW50ZWdlci5cbiAqL1xuY29uc3QgaGV4VG9OdW1iZXIgPSAodmFsdWUpID0+IHtcbiAgICAoMCwgaGV4XzEuYXNzZXJ0SXNIZXhTdHJpbmcpKHZhbHVlKTtcbiAgICAvLyBgcGFyc2VJbnRgIGFjY2VwdHMgdmFsdWVzIHdpdGhvdXQgdGhlIFwiMHhcIi1wcmVmaXgsIHdoZXJlYXMgYE51bWJlcmAgZG9lc1xuICAgIC8vIG5vdC4gVXNpbmcgdGhpcyBpcyBzbGlnaHRseSBmYXN0ZXIgdGhhbiBgTnVtYmVyKGFkZDB4KHZhbHVlKSlgLlxuICAgIGNvbnN0IG51bWJlclZhbHVlID0gcGFyc2VJbnQodmFsdWUsIDE2KTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShOdW1iZXIuaXNTYWZlSW50ZWdlcihudW1iZXJWYWx1ZSksICdWYWx1ZSBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgaGV4VG9CaWdJbnRgIGluc3RlYWQuJyk7XG4gICAgcmV0dXJuIG51bWJlclZhbHVlO1xufTtcbmV4cG9ydHMuaGV4VG9OdW1iZXIgPSBoZXhUb051bWJlcjtcbi8qKlxuICogQ29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIGBiaWdpbnRgLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIHN0cmluZyBpc1xuICogYSB2YWxpZCBoZXggc3RyaW5nLiBCb3RoIFwiMHhcIi1wcmVmaXhlZCBhbmQgdW5wcmVmaXhlZCBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQuXG4gKlxuICogVG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIG51bWJlciBpbnN0ZWFkLCB1c2Uge0BsaW5rIGhleFRvTnVtYmVyfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaGV4VG9CaWdJbnQoJzB4MCcpOyAvLyAwblxuICogaGV4VG9CaWdJbnQoJzB4MScpOyAvLyAxblxuICogaGV4VG9CaWdJbnQoJzB4MTAnKTsgLy8gMTZuXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydCB0byBhIGBiaWdpbnRgLlxuICogQHJldHVybnMgVGhlIGBiaWdpbnRgLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5jb25zdCBoZXhUb0JpZ0ludCA9ICh2YWx1ZSkgPT4ge1xuICAgICgwLCBoZXhfMS5hc3NlcnRJc0hleFN0cmluZykodmFsdWUpO1xuICAgIC8vIFRoZSBgQmlnSW50YCBjb25zdHJ1Y3RvciByZXF1aXJlcyB0aGUgXCIweFwiLXByZWZpeCB0byBwYXJzZSBhIGhleCBzdHJpbmcuXG4gICAgcmV0dXJuIEJpZ0ludCgoMCwgaGV4XzEuYWRkMHgpKHZhbHVlKSk7XG59O1xuZXhwb3J0cy5oZXhUb0JpZ0ludCA9IGhleFRvQmlnSW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3BhcXVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50aW1lU2luY2UgPSBleHBvcnRzLmluTWlsbGlzZWNvbmRzID0gZXhwb3J0cy5EdXJhdGlvbiA9IHZvaWQgMDtcbi8qKlxuICogQ29tbW9uIGR1cmF0aW9uIGNvbnN0YW50cywgaW4gbWlsbGlzZWNvbmRzLlxuICovXG52YXIgRHVyYXRpb247XG4oZnVuY3Rpb24gKER1cmF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQSBtaWxsaXNlY29uZC5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIk1pbGxpc2Vjb25kXCJdID0gMV0gPSBcIk1pbGxpc2Vjb25kXCI7XG4gICAgLyoqXG4gICAgICogQSBzZWNvbmQsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIlNlY29uZFwiXSA9IDEwMDBdID0gXCJTZWNvbmRcIjtcbiAgICAvKipcbiAgICAgKiBBIG1pbnV0ZSwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiTWludXRlXCJdID0gNjAwMDBdID0gXCJNaW51dGVcIjtcbiAgICAvKipcbiAgICAgKiBBbiBob3VyLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJIb3VyXCJdID0gMzYwMDAwMF0gPSBcIkhvdXJcIjtcbiAgICAvKipcbiAgICAgKiBBIGRheSwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiRGF5XCJdID0gODY0MDAwMDBdID0gXCJEYXlcIjtcbiAgICAvKipcbiAgICAgKiBBIHdlZWssIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIldlZWtcIl0gPSA2MDQ4MDAwMDBdID0gXCJXZWVrXCI7XG4gICAgLyoqXG4gICAgICogQSB5ZWFyLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJZZWFyXCJdID0gMzE1MzYwMDAwMDBdID0gXCJZZWFyXCI7XG59KShEdXJhdGlvbiA9IGV4cG9ydHMuRHVyYXRpb24gfHwgKGV4cG9ydHMuRHVyYXRpb24gPSB7fSkpO1xuY29uc3QgaXNOb25OZWdhdGl2ZUludGVnZXIgPSAobnVtYmVyKSA9PiBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcikgJiYgbnVtYmVyID49IDA7XG5jb25zdCBhc3NlcnRJc05vbk5lZ2F0aXZlSW50ZWdlciA9IChudW1iZXIsIG5hbWUpID0+IHtcbiAgICBpZiAoIWlzTm9uTmVnYXRpdmVJbnRlZ2VyKG51bWJlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7bmFtZX1cIiBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIuIFJlY2VpdmVkOiBcIiR7bnVtYmVyfVwiLmApO1xuICAgIH1cbn07XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIG1pbGxpc2Vjb25kIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHVuaXRzIG9mIHRpbWUuXG4gKlxuICogQHBhcmFtIGNvdW50IC0gVGhlIG51bWJlciBvZiB1bml0cyBvZiB0aW1lLlxuICogQHBhcmFtIGR1cmF0aW9uIC0gVGhlIHVuaXQgb2YgdGltZSB0byBjb3VudC5cbiAqIEByZXR1cm5zIFRoZSBjb3VudCBtdWx0aXBsaWVkIGJ5IHRoZSBzcGVjaWZpZWQgZHVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGluTWlsbGlzZWNvbmRzKGNvdW50LCBkdXJhdGlvbikge1xuICAgIGFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyKGNvdW50LCAnY291bnQnKTtcbiAgICByZXR1cm4gY291bnQgKiBkdXJhdGlvbjtcbn1cbmV4cG9ydHMuaW5NaWxsaXNlY29uZHMgPSBpbk1pbGxpc2Vjb25kcztcbi8qKlxuICogR2V0cyB0aGUgbWlsbGlzZWNvbmRzIHNpbmNlIGEgcGFydGljdWxhciBVbml4IGVwb2NoIHRpbWVzdGFtcC5cbiAqXG4gKiBAcGFyYW0gdGltZXN0YW1wIC0gQSBVbml4IG1pbGxpc2Vjb25kIHRpbWVzdGFtcC5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGVsYXBzZWQgc2luY2UgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXAuXG4gKi9cbmZ1bmN0aW9uIHRpbWVTaW5jZSh0aW1lc3RhbXApIHtcbiAgICBhc3NlcnRJc05vbk5lZ2F0aXZlSW50ZWdlcih0aW1lc3RhbXAsICd0aW1lc3RhbXAnKTtcbiAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHRpbWVzdGFtcDtcbn1cbmV4cG9ydHMudGltZVNpbmNlID0gdGltZVNpbmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2F0aXNmaWVzVmVyc2lvblJhbmdlID0gZXhwb3J0cy5ndFJhbmdlID0gZXhwb3J0cy5ndFZlcnNpb24gPSBleHBvcnRzLmFzc2VydElzU2VtVmVyUmFuZ2UgPSBleHBvcnRzLmFzc2VydElzU2VtVmVyVmVyc2lvbiA9IGV4cG9ydHMuaXNWYWxpZFNlbVZlclJhbmdlID0gZXhwb3J0cy5pc1ZhbGlkU2VtVmVyVmVyc2lvbiA9IGV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0ID0gZXhwb3J0cy5WZXJzaW9uU3RydWN0ID0gdm9pZCAwO1xuY29uc3Qgc2VtdmVyXzEgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuLyoqXG4gKiBBIHN0cnVjdCBmb3IgdmFsaWRhdGluZyBhIHZlcnNpb24gc3RyaW5nLlxuICovXG5leHBvcnRzLlZlcnNpb25TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5yZWZpbmUpKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgJ1ZlcnNpb24nLCAodmFsdWUpID0+IHtcbiAgICBpZiAoKDAsIHNlbXZlcl8xLnZhbGlkKSh2YWx1ZSkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCBTZW1WZXIgdmVyc2lvbiwgZ290IFwiJHt2YWx1ZX1cImA7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufSk7XG5leHBvcnRzLlZlcnNpb25SYW5nZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnJlZmluZSkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAnVmVyc2lvbiByYW5nZScsICh2YWx1ZSkgPT4ge1xuICAgIGlmICgoMCwgc2VtdmVyXzEudmFsaWRSYW5nZSkodmFsdWUpID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBgRXhwZWN0ZWQgU2VtVmVyIHJhbmdlLCBnb3QgXCIke3ZhbHVlfVwiYDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBTZW1WZXIgdmVyc2lvbiBpcyB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbiAtIEEgcG90ZW50aWFsIHZlcnNpb24uXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZlcnNpb24gaXMgdmFsaWQsIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFNlbVZlclZlcnNpb24odmVyc2lvbikge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmVyc2lvbiwgZXhwb3J0cy5WZXJzaW9uU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNWYWxpZFNlbVZlclZlcnNpb24gPSBpc1ZhbGlkU2VtVmVyVmVyc2lvbjtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBTZW1WZXIgdmVyc2lvbiByYW5nZSBpcyB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvblJhbmdlIC0gQSBwb3RlbnRpYWwgdmVyc2lvbiByYW5nZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVyc2lvbiByYW5nZSBpcyB2YWxpZCwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU2VtVmVyUmFuZ2UodmVyc2lvblJhbmdlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2ZXJzaW9uUmFuZ2UsIGV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNWYWxpZFNlbVZlclJhbmdlID0gaXNWYWxpZFNlbVZlclJhbmdlO1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIGNvbmNyZXRlIFNlbVZlciB2ZXJzaW9uLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gQSBwb3RlbnRpYWwgU2VtVmVyIGNvbmNyZXRlIHZlcnNpb24uXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzU2VtVmVyVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmVyc2lvbiwgZXhwb3J0cy5WZXJzaW9uU3RydWN0KTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNTZW1WZXJWZXJzaW9uID0gYXNzZXJ0SXNTZW1WZXJWZXJzaW9uO1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIFNlbVZlciByYW5nZS5cbiAqXG4gKiBAcGFyYW0gcmFuZ2UgLSBBIHBvdGVudGlhbCBTZW1WZXIgcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzU2VtVmVyUmFuZ2UocmFuZ2UpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KShyYW5nZSwgZXhwb3J0cy5WZXJzaW9uUmFuZ2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1NlbVZlclJhbmdlID0gYXNzZXJ0SXNTZW1WZXJSYW5nZTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBTZW1WZXIgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYW5vdGhlci5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbjEgLSBUaGUgbGVmdC1oYW5kIHZlcnNpb24uXG4gKiBAcGFyYW0gdmVyc2lvbjIgLSBUaGUgcmlnaHQtaGFuZCB2ZXJzaW9uLlxuICogQHJldHVybnMgYHZlcnNpb24xID4gdmVyc2lvbjJgLlxuICovXG5mdW5jdGlvbiBndFZlcnNpb24odmVyc2lvbjEsIHZlcnNpb24yKSB7XG4gICAgcmV0dXJuICgwLCBzZW12ZXJfMS5ndCkodmVyc2lvbjEsIHZlcnNpb24yKTtcbn1cbmV4cG9ydHMuZ3RWZXJzaW9uID0gZ3RWZXJzaW9uO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbGwgcG9zc2liaWxpdGllcyBpbiBhIHJhbmdlLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gQSBTZW12VmVyIHZlcnNpb24uXG4gKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIGB2ZXJzaW9uID4gcmFuZ2VgLlxuICovXG5mdW5jdGlvbiBndFJhbmdlKHZlcnNpb24sIHJhbmdlKSB7XG4gICAgcmV0dXJuICgwLCBzZW12ZXJfMS5ndHIpKHZlcnNpb24sIHJhbmdlKTtcbn1cbmV4cG9ydHMuZ3RSYW5nZSA9IGd0UmFuZ2U7XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIHNhdGlzZmllcyBhIFNlbVZlciByYW5nZS5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbiAtIFRoZSBTZW1WZXIgdmVyc2lvbiB0byBjaGVjay5cbiAqIEBwYXJhbSB2ZXJzaW9uUmFuZ2UgLSBUaGUgU2VtVmVyIHZlcnNpb24gcmFuZ2UgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZlcnNpb24gc2F0aXNmaWVkIHRoZSB2ZXJzaW9uIHJhbmdlLlxuICovXG5mdW5jdGlvbiBzYXRpc2ZpZXNWZXJzaW9uUmFuZ2UodmVyc2lvbiwgdmVyc2lvblJhbmdlKSB7XG4gICAgcmV0dXJuICgwLCBzZW12ZXJfMS5zYXRpc2ZpZXMpKHZlcnNpb24sIHZlcnNpb25SYW5nZSwge1xuICAgICAgICBpbmNsdWRlUHJlcmVsZWFzZTogdHJ1ZSxcbiAgICB9KTtcbn1cbmV4cG9ydHMuc2F0aXNmaWVzVmVyc2lvblJhbmdlID0gc2F0aXNmaWVzVmVyc2lvblJhbmdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUJsb2NrQ2FjaGVNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgbG9nZ2luZ191dGlsc18xID0gcmVxdWlyZShcIi4vbG9nZ2luZy11dGlsc1wiKTtcbmNvbnN0IGNhY2hlXzEgPSByZXF1aXJlKFwiLi91dGlscy9jYWNoZVwiKTtcbmNvbnN0IGxvZyA9IGxvZ2dpbmdfdXRpbHNfMS5jcmVhdGVNb2R1bGVMb2dnZXIobG9nZ2luZ191dGlsc18xLnByb2plY3RMb2dnZXIsICdibG9jay1jYWNoZScpO1xuLy8gYDxuaWw+YCBjb21lcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMTY5MjVcbmNvbnN0IGVtcHR5VmFsdWVzID0gW3VuZGVmaW5lZCwgbnVsbCwgJ1xcdTAwM2NuaWxcXHUwMDNlJ107XG4vL1xuLy8gQ2FjaGUgU3RyYXRlZ2llc1xuLy9cbmNsYXNzIEJsb2NrQ2FjaGVTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICB9XG4gICAgZ2V0QmxvY2tDYWNoZUZvclBheWxvYWQoX3BheWxvYWQsIGJsb2NrTnVtYmVySGV4KSB7XG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KGJsb2NrTnVtYmVySGV4LCAxNik7XG4gICAgICAgIGxldCBibG9ja0NhY2hlID0gdGhpcy5jYWNoZVtibG9ja051bWJlcl07XG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgY2FjaGUgaWYgbmVjZXNhcnlcbiAgICAgICAgaWYgKCFibG9ja0NhY2hlKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdDYWNoZSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jYWNoZVtibG9ja051bWJlcl0gPSBuZXdDYWNoZTtcbiAgICAgICAgICAgIGJsb2NrQ2FjaGUgPSBuZXdDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxvY2tDYWNoZTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0KHBheWxvYWQsIHJlcXVlc3RlZEJsb2NrTnVtYmVyKSB7XG4gICAgICAgIC8vIGxvb2t1cCBibG9jayBjYWNoZVxuICAgICAgICBjb25zdCBibG9ja0NhY2hlID0gdGhpcy5nZXRCbG9ja0NhY2hlRm9yUGF5bG9hZChwYXlsb2FkLCByZXF1ZXN0ZWRCbG9ja051bWJlcik7XG4gICAgICAgIC8vIGxvb2t1cCBwYXlsb2FkIGluIGJsb2NrIGNhY2hlXG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBjYWNoZV8xLmNhY2hlSWRlbnRpZmllckZvclBheWxvYWQocGF5bG9hZCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBpZGVudGlmaWVyID8gYmxvY2tDYWNoZVtpZGVudGlmaWVyXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXN5bmMgc2V0KHBheWxvYWQsIHJlcXVlc3RlZEJsb2NrTnVtYmVyLCByZXN1bHQpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgY2FuIGNhY2hlZCB0aGlzIHJlc3VsdFxuICAgICAgICBjb25zdCBjYW5DYWNoZVJlc3VsdCA9IHRoaXMuY2FuQ2FjaGVSZXN1bHQocGF5bG9hZCwgcmVzdWx0KTtcbiAgICAgICAgaWYgKCFjYW5DYWNoZVJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCB0aGUgdmFsdWUgaW4gdGhlIGNhY2hlXG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBjYWNoZV8xLmNhY2hlSWRlbnRpZmllckZvclBheWxvYWQocGF5bG9hZCwgdHJ1ZSk7XG4gICAgICAgIGlmICghaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrQ2FjaGUgPSB0aGlzLmdldEJsb2NrQ2FjaGVGb3JQYXlsb2FkKHBheWxvYWQsIHJlcXVlc3RlZEJsb2NrTnVtYmVyKTtcbiAgICAgICAgYmxvY2tDYWNoZVtpZGVudGlmaWVyXSA9IHJlc3VsdDtcbiAgICB9XG4gICAgY2FuQ2FjaGVSZXF1ZXN0KHBheWxvYWQpIHtcbiAgICAgICAgLy8gY2hlY2sgcmVxdWVzdCBtZXRob2RcbiAgICAgICAgaWYgKCFjYWNoZV8xLmNhbkNhY2hlKHBheWxvYWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgYmxvY2tUYWdcbiAgICAgICAgY29uc3QgYmxvY2tUYWcgPSBjYWNoZV8xLmJsb2NrVGFnRm9yUGF5bG9hZChwYXlsb2FkKTtcbiAgICAgICAgaWYgKGJsb2NrVGFnID09PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYW4gYmUgY2FjaGVkXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYW5DYWNoZVJlc3VsdChwYXlsb2FkLCByZXN1bHQpIHtcbiAgICAgICAgLy8gbmV2ZXIgY2FjaGUgZW1wdHkgdmFsdWVzIChlLmcuIHVuZGVmaW5lZClcbiAgICAgICAgaWYgKGVtcHR5VmFsdWVzLmluY2x1ZGVzKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiB0cmFuc2FjdGlvbnMgaGF2ZSBibG9jayByZWZlcmVuY2UgYmVmb3JlIGNhY2hpbmdcbiAgICAgICAgaWYgKHBheWxvYWQubWV0aG9kICYmXG4gICAgICAgICAgICBbJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCcsICdldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0J10uaW5jbHVkZXMocGF5bG9hZC5tZXRob2QpKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCB8fFxuICAgICAgICAgICAgICAgICFyZXN1bHQuYmxvY2tIYXNoIHx8XG4gICAgICAgICAgICAgICAgcmVzdWx0LmJsb2NrSGFzaCA9PT1cbiAgICAgICAgICAgICAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRydWVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIHJlbW92ZXMgYWxsIGJsb2NrIGNhY2hlcyB3aXRoIGJsb2NrIG51bWJlciBsb3dlciB0aGFuIGBvbGRCbG9ja0hleGBcbiAgICBjbGVhckJlZm9yZShvbGRCbG9ja0hleCkge1xuICAgICAgICBjb25zdCBvbGRCbG9ja051bWJlciA9IE51bWJlci5wYXJzZUludChvbGRCbG9ja0hleCwgMTYpO1xuICAgICAgICAvLyBjbGVhciBvbGQgY2FjaGVzXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuY2FjaGUpXG4gICAgICAgICAgICAubWFwKE51bWJlcilcbiAgICAgICAgICAgIC5maWx0ZXIoKG51bSkgPT4gbnVtIDwgb2xkQmxvY2tOdW1iZXIpXG4gICAgICAgICAgICAuZm9yRWFjaCgobnVtKSA9PiBkZWxldGUgdGhpcy5jYWNoZVtudW1dKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVCbG9ja0NhY2hlTWlkZGxld2FyZSh7IGJsb2NrVHJhY2tlciwgfSA9IHt9KSB7XG4gICAgLy8gdmFsaWRhdGUgb3B0aW9uc1xuICAgIGlmICghYmxvY2tUcmFja2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3JlYXRlQmxvY2tDYWNoZU1pZGRsZXdhcmUgLSBObyBQb2xsaW5nQmxvY2tUcmFja2VyIHNwZWNpZmllZCcpO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgY2FjaGluZyBzdHJhdGVnaWVzXG4gICAgY29uc3QgYmxvY2tDYWNoZSA9IG5ldyBCbG9ja0NhY2hlU3RyYXRlZ3koKTtcbiAgICBjb25zdCBzdHJhdGVnaWVzID0ge1xuICAgICAgICBwZXJtYTogYmxvY2tDYWNoZSxcbiAgICAgICAgYmxvY2s6IGJsb2NrQ2FjaGUsXG4gICAgICAgIGZvcms6IGJsb2NrQ2FjaGUsXG4gICAgfTtcbiAgICByZXR1cm4ganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgICAgICAvLyBhbGxvdyBjYWNoIHRvIGJlIHNraXBwZWQgaWYgc28gc3BlY2lmaWVkXG4gICAgICAgIGlmIChyZXEuc2tpcENhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIHR5cGUgYW5kIG1hdGNoaW5nIHN0cmF0ZWd5XG4gICAgICAgIGNvbnN0IHR5cGUgPSBjYWNoZV8xLmNhY2hlVHlwZUZvclBheWxvYWQocmVxKTtcbiAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBzdHJhdGVnaWVzW3R5cGVdO1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHN0cmF0ZWd5IGluIHBsYWNlLCBwYXNzIGl0IGRvd24gdGhlIGNoYWluLlxuICAgICAgICBpZiAoIXN0cmF0ZWd5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBzdHJhdGVneSBjYW4ndCBjYWNoZSB0aGlzIHJlcXVlc3QsIGlnbm9yZSBpdC5cbiAgICAgICAgaWYgKCFzdHJhdGVneS5jYW5DYWNoZVJlcXVlc3QocmVxKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgYmxvY2sgcmVmZXJlbmNlIChudW1iZXIgb3Iga2V5d29yZClcbiAgICAgICAgbGV0IGJsb2NrVGFnID0gY2FjaGVfMS5ibG9ja1RhZ0ZvclBheWxvYWQocmVxKTtcbiAgICAgICAgaWYgKCFibG9ja1RhZykge1xuICAgICAgICAgICAgYmxvY2tUYWcgPSAnbGF0ZXN0JztcbiAgICAgICAgfVxuICAgICAgICBsb2coJ2Jsb2NrVGFnID0gJW8sIHJlcSA9ICVvJywgYmxvY2tUYWcsIHJlcSk7XG4gICAgICAgIC8vIGdldCBleGFjdCBibG9jayBudW1iZXJcbiAgICAgICAgbGV0IHJlcXVlc3RlZEJsb2NrTnVtYmVyO1xuICAgICAgICBpZiAoYmxvY2tUYWcgPT09ICdlYXJsaWVzdCcpIHtcbiAgICAgICAgICAgIC8vIHRoaXMganVzdCBleGlzdHMgZm9yIHN5bW1ldHJ5IHdpdGggXCJsYXRlc3RcIlxuICAgICAgICAgICAgcmVxdWVzdGVkQmxvY2tOdW1iZXIgPSAnMHgwMCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmxvY2tUYWcgPT09ICdsYXRlc3QnKSB7XG4gICAgICAgICAgICAvLyBmZXRjaCBsYXRlc3QgYmxvY2sgbnVtYmVyXG4gICAgICAgICAgICBsb2coJ0ZldGNoaW5nIGxhdGVzdCBibG9jayBudW1iZXIgdG8gZGV0ZXJtaW5lIGNhY2hlIGtleScpO1xuICAgICAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2tOdW1iZXIgPSBhd2FpdCBibG9ja1RyYWNrZXIuZ2V0TGF0ZXN0QmxvY2soKTtcbiAgICAgICAgICAgIC8vIGNsZWFyIGFsbCBjYWNoZSBiZWZvcmUgbGF0ZXN0IGJsb2NrXG4gICAgICAgICAgICBsb2coJ0NsZWFyaW5nIHZhbHVlcyBzdG9yZWQgdW5kZXIgYmxvY2sgbnVtYmVycyBiZWZvcmUgJW8nLCBsYXRlc3RCbG9ja051bWJlcik7XG4gICAgICAgICAgICBibG9ja0NhY2hlLmNsZWFyQmVmb3JlKGxhdGVzdEJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIHJlcXVlc3RlZEJsb2NrTnVtYmVyID0gbGF0ZXN0QmxvY2tOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGEgaGV4IG51bWJlclxuICAgICAgICAgICAgcmVxdWVzdGVkQmxvY2tOdW1iZXIgPSBibG9ja1RhZztcbiAgICAgICAgfVxuICAgICAgICAvLyBlbmQgb24gYSBoaXQsIGNvbnRpbnVlIG9uIGEgbWlzc1xuICAgICAgICBjb25zdCBjYWNoZVJlc3VsdCA9IGF3YWl0IHN0cmF0ZWd5LmdldChyZXEsIHJlcXVlc3RlZEJsb2NrTnVtYmVyKTtcbiAgICAgICAgaWYgKGNhY2hlUmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGNhY2hlIG1pc3NcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIG90aGVyIG1pZGRsZXdhcmUgdG8gaGFuZGxlIHJlcXVlc3RcbiAgICAgICAgICAgIGxvZygnTm8gY2FjaGUgc3RvcmVkIHVuZGVyIGJsb2NrIG51bWJlciAlbywgY2FycnlpbmcgcmVxdWVzdCBmb3J3YXJkJywgcmVxdWVzdGVkQmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvY2FsbGJhY2stcmV0dXJuXG4gICAgICAgICAgICBhd2FpdCBuZXh0KCk7XG4gICAgICAgICAgICAvLyBhZGQgcmVzdWx0IHRvIGNhY2hlXG4gICAgICAgICAgICAvLyBpdCdzIHNhZmUgdG8gY2FzdCByZXMucmVzdWx0IGFzIEJsb2NrLCBkdWUgdG8gcnVudGltZSB0eXBlIGNoZWNrc1xuICAgICAgICAgICAgLy8gcGVyZm9ybWVkIHdoZW4gc3RyYXRlZ3kuc2V0IGlzIGNhbGxlZFxuICAgICAgICAgICAgbG9nKCdQb3B1bGF0aW5nIGNhY2hlIHdpdGgnLCByZXMpO1xuICAgICAgICAgICAgYXdhaXQgc3RyYXRlZ3kuc2V0KHJlcSwgcmVxdWVzdGVkQmxvY2tOdW1iZXIsIHJlcy5yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZmlsbCBpbiByZXN1bHQgZnJvbSBjYWNoZVxuICAgICAgICAgICAgbG9nKCdDYWNoZSBoaXQsIHJldXNpbmcgY2FjaGUgcmVzdWx0IHN0b3JlZCB1bmRlciBibG9jayBudW1iZXIgJW8nLCByZXF1ZXN0ZWRCbG9ja051bWJlcik7XG4gICAgICAgICAgICByZXMucmVzdWx0ID0gY2FjaGVSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlQmxvY2tDYWNoZU1pZGRsZXdhcmUgPSBjcmVhdGVCbG9ja0NhY2hlTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsb2NrLWNhY2hlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVCbG9ja1JlZlJld3JpdGVNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgY2FjaGVfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NhY2hlXCIpO1xuZnVuY3Rpb24gY3JlYXRlQmxvY2tSZWZSZXdyaXRlTWlkZGxld2FyZSh7IGJsb2NrVHJhY2tlciwgfSA9IHt9KSB7XG4gICAgaWYgKCFibG9ja1RyYWNrZXIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0Jsb2NrUmVmUmV3cml0ZU1pZGRsZXdhcmUgLSBtYW5kYXRvcnkgXCJibG9ja1RyYWNrZXJcIiBvcHRpb24gaXMgbWlzc2luZy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCBfcmVzLCBuZXh0KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgYmxvY2tSZWZJbmRleCA9IGNhY2hlXzEuYmxvY2tUYWdQYXJhbUluZGV4KHJlcSk7XG4gICAgICAgIC8vIHNraXAgaWYgbWV0aG9kIGRvZXMgbm90IGluY2x1ZGUgYmxvY2tSZWZcbiAgICAgICAgaWYgKGJsb2NrUmVmSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBza2lwIGlmIG5vdCBcImxhdGVzdFwiXG4gICAgICAgIGxldCBibG9ja1JlZiA9IChfYSA9IHJlcS5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtibG9ja1JlZkluZGV4XTtcbiAgICAgICAgLy8gb21pdHRlZCBibG9ja1JlZiBpbXBsaWVzIFwibGF0ZXN0XCJcbiAgICAgICAgaWYgKGJsb2NrUmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJsb2NrUmVmID0gJ2xhdGVzdCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrUmVmICE9PSAnbGF0ZXN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXdyaXRlIGJsb2NrUmVmIHRvIGJsb2NrLXRyYWNrZXIncyBibG9jayBudW1iZXJcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2tOdW1iZXIgPSBhd2FpdCBibG9ja1RyYWNrZXIuZ2V0TGF0ZXN0QmxvY2soKTtcbiAgICAgICAgaWYgKHJlcS5wYXJhbXMpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF0b21pYy11cGRhdGVzXG4gICAgICAgICAgICByZXEucGFyYW1zW2Jsb2NrUmVmSW5kZXhdID0gbGF0ZXN0QmxvY2tOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlQmxvY2tSZWZSZXdyaXRlTWlkZGxld2FyZSA9IGNyZWF0ZUJsb2NrUmVmUmV3cml0ZU1pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibG9jay1yZWYtcmV3cml0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlQmxvY2tSZWZNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgY2xvbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY2xvbmVcIikpO1xuY29uc3QgcGlmeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwaWZ5XCIpKTtcbmNvbnN0IGxvZ2dpbmdfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmctdXRpbHNcIik7XG5jb25zdCBjYWNoZV8xID0gcmVxdWlyZShcIi4vdXRpbHMvY2FjaGVcIik7XG5jb25zdCBsb2cgPSBsb2dnaW5nX3V0aWxzXzEuY3JlYXRlTW9kdWxlTG9nZ2VyKGxvZ2dpbmdfdXRpbHNfMS5wcm9qZWN0TG9nZ2VyLCAnYmxvY2stcmVmJyk7XG5mdW5jdGlvbiBjcmVhdGVCbG9ja1JlZk1pZGRsZXdhcmUoeyBwcm92aWRlciwgYmxvY2tUcmFja2VyLCB9ID0ge30pIHtcbiAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdCbG9ja1JlZk1pZGRsZXdhcmUgLSBtYW5kYXRvcnkgXCJwcm92aWRlclwiIG9wdGlvbiBpcyBtaXNzaW5nLicpO1xuICAgIH1cbiAgICBpZiAoIWJsb2NrVHJhY2tlcikge1xuICAgICAgICB0aHJvdyBFcnJvcignQmxvY2tSZWZNaWRkbGV3YXJlIC0gbWFuZGF0b3J5IFwiYmxvY2tUcmFja2VyXCIgb3B0aW9uIGlzIG1pc3NpbmcuJyk7XG4gICAgfVxuICAgIHJldHVybiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmMgKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGJsb2NrUmVmSW5kZXggPSBjYWNoZV8xLmJsb2NrVGFnUGFyYW1JbmRleChyZXEpO1xuICAgICAgICAvLyBza2lwIGlmIG1ldGhvZCBkb2VzIG5vdCBpbmNsdWRlIGJsb2NrUmVmXG4gICAgICAgIGlmIChibG9ja1JlZkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvY2tSZWYgPSAoX2IgPSAoX2EgPSByZXEucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbYmxvY2tSZWZJbmRleF0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdsYXRlc3QnO1xuICAgICAgICAvLyBza2lwIGlmIG5vdCBcImxhdGVzdFwiXG4gICAgICAgIGlmIChibG9ja1JlZiAhPT0gJ2xhdGVzdCcpIHtcbiAgICAgICAgICAgIGxvZygnYmxvY2tSZWYgaXMgbm90IFwibGF0ZXN0XCIsIGNhcnJ5aW5nIHJlcXVlc3QgZm9yd2FyZCcpO1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb29rdXAgbGF0ZXN0IGJsb2NrXG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NrTnVtYmVyID0gYXdhaXQgYmxvY2tUcmFja2VyLmdldExhdGVzdEJsb2NrKCk7XG4gICAgICAgIGxvZyhgYmxvY2tSZWYgaXMgXCJsYXRlc3RcIiwgc2V0dGluZyBwYXJhbSAke2Jsb2NrUmVmSW5kZXh9IHRvIGxhdGVzdCBibG9jayAke2xhdGVzdEJsb2NrTnVtYmVyfWApO1xuICAgICAgICAvLyBjcmVhdGUgY2hpbGQgcmVxdWVzdCB3aXRoIHNwZWNpZmljIGJsb2NrLXJlZlxuICAgICAgICBjb25zdCBjaGlsZFJlcXVlc3QgPSBjbG9uZV8xLmRlZmF1bHQocmVxKTtcbiAgICAgICAgaWYgKGNoaWxkUmVxdWVzdC5wYXJhbXMpIHtcbiAgICAgICAgICAgIGNoaWxkUmVxdWVzdC5wYXJhbXNbYmxvY2tSZWZJbmRleF0gPSBsYXRlc3RCbG9ja051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBwZXJmb3JtIGNoaWxkIHJlcXVlc3RcbiAgICAgICAgbG9nKCdQZXJmb3JtaW5nIGFub3RoZXIgcmVxdWVzdCAlbycsIGNoaWxkUmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IGNoaWxkUmVzID0gYXdhaXQgcGlmeV8xLmRlZmF1bHQocHJvdmlkZXIuc2VuZEFzeW5jKS5jYWxsKHByb3ZpZGVyLCBjaGlsZFJlcXVlc3QpO1xuICAgICAgICAvLyBjb3B5IGNoaWxkIHJlc3BvbnNlIG9udG8gb3JpZ2luYWwgcmVzcG9uc2VcbiAgICAgICAgcmVzLnJlc3VsdCA9IGNoaWxkUmVzLnJlc3VsdDtcbiAgICAgICAgcmVzLmVycm9yID0gY2hpbGRSZXMuZXJyb3I7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUJsb2NrUmVmTWlkZGxld2FyZSA9IGNyZWF0ZUJsb2NrUmVmTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsb2NrLXJlZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlQmxvY2tUcmFja2VySW5zcGVjdG9yTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IGxvZ2dpbmdfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmctdXRpbHNcIik7XG5jb25zdCBsb2cgPSBsb2dnaW5nX3V0aWxzXzEuY3JlYXRlTW9kdWxlTG9nZ2VyKGxvZ2dpbmdfdXRpbHNfMS5wcm9qZWN0TG9nZ2VyLCAnYmxvY2stdHJhY2tlci1pbnNwZWN0b3InKTtcbmNvbnN0IGZ1dHVyZUJsb2NrUmVmUmVxdWVzdHMgPSBbXG4gICAgJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCcsXG4gICAgJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnLFxuXTtcbi8vIGluc3BlY3QgaWYgcmVzcG9uc2UgY29udGFpbnMgYSBibG9jayByZWYgaGlnaGVyIHRoYW4gb3VyIGxhdGVzdCBibG9ja1xuZnVuY3Rpb24gY3JlYXRlQmxvY2tUcmFja2VySW5zcGVjdG9yTWlkZGxld2FyZSh7IGJsb2NrVHJhY2tlciwgfSkge1xuICAgIHJldHVybiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmMgKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFmdXR1cmVCbG9ja1JlZlJlcXVlc3RzLmluY2x1ZGVzKHJlcS5tZXRob2QpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL2NhbGxiYWNrLXJldHVyblxuICAgICAgICBhd2FpdCBuZXh0KCk7XG4gICAgICAgIC8vIGFib3J0IGlmIG5vIHJlc3VsdCBvciBubyBibG9jayBudW1iZXJcbiAgICAgICAgaWYgKCEoKF9hID0gcmVzLnJlc3VsdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJsb2NrTnVtYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsb2coJ3Jlcy5yZXN1bHQuYmxvY2tOdW1iZXIgZXhpc3RzLCBwcm9jZWVkaW5nLiByZXMgPSAlbycsIHJlcyk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzLnJlc3VsdC5ibG9ja051bWJlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIGlmIG51bWJlciBpcyBoaWdoZXIsIHN1Z2dlc3QgYmxvY2stdHJhY2tlciBjaGVjayBmb3IgYSBuZXcgYmxvY2tcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KHJlcy5yZXN1bHQuYmxvY2tOdW1iZXIsIDE2KTtcbiAgICAgICAgICAgIC8vIFR5cGVjYXN0OiBJZiBnZXRDdXJyZW50QmxvY2sgcmV0dXJucyBudWxsLCBjdXJyZW50QmxvY2tOdW1iZXIgd2lsbCBiZSBOYU4sIHdoaWNoIGlzIGZpbmUuXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50QmxvY2tOdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQoYmxvY2tUcmFja2VyLmdldEN1cnJlbnRCbG9jaygpLCAxNik7XG4gICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPiBjdXJyZW50QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBsb2coJ2Jsb2NrTnVtYmVyIGZyb20gcmVzcG9uc2UgaXMgZ3JlYXRlciB0aGFuIGN1cnJlbnQgYmxvY2sgbnVtYmVyLCByZWZyZXNoaW5nIGN1cnJlbnQgYmxvY2sgbnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgYmxvY2tUcmFja2VyLmNoZWNrRm9yTGF0ZXN0QmxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVCbG9ja1RyYWNrZXJJbnNwZWN0b3JNaWRkbGV3YXJlID0gY3JlYXRlQmxvY2tUcmFja2VySW5zcGVjdG9yTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsb2NrLXRyYWNrZXItaW5zcGVjdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVGZXRjaENvbmZpZ0Zyb21SZXEgPSBleHBvcnRzLmNyZWF0ZUZldGNoTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLEB0eXBlc2NyaXB0LWVzbGludC9uby1zaGFkb3cgKi9cbmNvbnN0IGZldGNoID0gZ2xvYmFsLmZldGNoIHx8IHJlcXVpcmUoJ25vZGUtZmV0Y2gnKTtcbmNvbnN0IGJ0b2EgPSBnbG9iYWwuYnRvYSB8fCByZXF1aXJlKCdidG9hJyk7XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvdyAqL1xuY29uc3QgUkVUUklBQkxFX0VSUk9SUyA9IFtcbiAgICAvLyBpZ25vcmUgc2VydmVyIG92ZXJsb2FkIGVycm9yc1xuICAgICdHYXRld2F5IHRpbWVvdXQnLFxuICAgICdFVElNRURPVVQnLFxuICAgIC8vIGlnbm9yZSBzZXJ2ZXIgc2VudCBodG1sIGVycm9yIHBhZ2VzXG4gICAgLy8gb3IgdHJ1bmNhdGVkIGpzb24gcmVzcG9uc2VzXG4gICAgJ2ZhaWxlZCB0byBwYXJzZSByZXNwb25zZSBib2R5JyxcbiAgICAvLyBpZ25vcmUgZXJyb3JzIHdoZXJlIGh0dHAgcmVxIGZhaWxlZCB0byBlc3RhYmxpc2hcbiAgICAnRmFpbGVkIHRvIGZldGNoJyxcbl07XG5mdW5jdGlvbiBjcmVhdGVGZXRjaE1pZGRsZXdhcmUoeyBycGNVcmwsIG9yaWdpbkh0dHBIZWFkZXJLZXksIH0pIHtcbiAgICByZXR1cm4ganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXEsIHJlcywgX25leHQpID0+IHtcbiAgICAgICAgY29uc3QgeyBmZXRjaFVybCwgZmV0Y2hQYXJhbXMgfSA9IGNyZWF0ZUZldGNoQ29uZmlnRnJvbVJlcSh7XG4gICAgICAgICAgICByZXEsXG4gICAgICAgICAgICBycGNVcmwsXG4gICAgICAgICAgICBvcmlnaW5IdHRwSGVhZGVyS2V5LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gYXR0ZW1wdCByZXF1ZXN0IG11bHRpcGxlIHRpbWVzXG4gICAgICAgIGNvbnN0IG1heEF0dGVtcHRzID0gNTtcbiAgICAgICAgY29uc3QgcmV0cnlJbnRlcnZhbCA9IDEwMDA7XG4gICAgICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgbWF4QXR0ZW1wdHM7IGF0dGVtcHQrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmZXRjaFJlcyA9IGF3YWl0IGZldGNoKGZldGNoVXJsLCBmZXRjaFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGh0dHAgZXJycm9yc1xuICAgICAgICAgICAgICAgIGNoZWNrRm9ySHR0cEVycm9ycyhmZXRjaFJlcyk7XG4gICAgICAgICAgICAgICAgLy8gcGFyc2UgcmVzcG9uc2UgYm9keVxuICAgICAgICAgICAgICAgIGNvbnN0IHJhd0JvZHkgPSBhd2FpdCBmZXRjaFJlcy50ZXh0KCk7XG4gICAgICAgICAgICAgICAgbGV0IGZldGNoQm9keTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmZXRjaEJvZHkgPSBKU09OLnBhcnNlKHJhd0JvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZldGNoTWlkZGxld2FyZSAtIGZhaWxlZCB0byBwYXJzZSByZXNwb25zZSBib2R5OiBcIiR7cmF3Qm9keX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJzZVJlc3BvbnNlKGZldGNoUmVzLCBmZXRjaEJvZHkpO1xuICAgICAgICAgICAgICAgIC8vIHNldCByZXN1bHQgYW5kIGV4aXQgcmV0cnkgbG9vcFxuICAgICAgICAgICAgICAgIHJlcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9IGVyci50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmV0cmlhYmxlID0gUkVUUklBQkxFX0VSUk9SUy5zb21lKChwaHJhc2UpID0+IGVyck1zZy5pbmNsdWRlcyhwaHJhc2UpKTtcbiAgICAgICAgICAgICAgICAvLyByZS10aHJvdyBlcnJvciBpZiBub3QgcmV0cmlhYmxlXG4gICAgICAgICAgICAgICAgaWYgKCFpc1JldHJpYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVsYXkgYmVmb3JlIHJldHJ5aW5nXG4gICAgICAgICAgICBhd2FpdCB0aW1lb3V0KHJldHJ5SW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUZldGNoTWlkZGxld2FyZSA9IGNyZWF0ZUZldGNoTWlkZGxld2FyZTtcbmZ1bmN0aW9uIGNoZWNrRm9ySHR0cEVycm9ycyhmZXRjaFJlcykge1xuICAgIC8vIGNoZWNrIGZvciBlcnJvcnNcbiAgICBzd2l0Y2ggKGZldGNoUmVzLnN0YXR1cykge1xuICAgICAgICBjYXNlIDQwNTpcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RGb3VuZCgpO1xuICAgICAgICBjYXNlIDQxODpcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZVJhdGVsaW1pdEVycm9yKCk7XG4gICAgICAgIGNhc2UgNTAzOlxuICAgICAgICBjYXNlIDUwNDpcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZVRpbWVvdXRFcnJvcigpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VSZXNwb25zZShmZXRjaFJlcywgYm9keSkge1xuICAgIC8vIGNoZWNrIGZvciBlcnJvciBjb2RlXG4gICAgaWYgKGZldGNoUmVzLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbCh7XG4gICAgICAgICAgICBtZXNzYWdlOiBgTm9uLTIwMCBzdGF0dXMgY29kZTogJyR7ZmV0Y2hSZXMuc3RhdHVzfSdgLFxuICAgICAgICAgICAgZGF0YTogYm9keSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBycGMgZXJyb3JcbiAgICBpZiAoYm9keS5lcnJvcikge1xuICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoe1xuICAgICAgICAgICAgZGF0YTogYm9keS5lcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHJldHVybiBzdWNjZXNzZnVsIHJlc3VsdFxuICAgIHJldHVybiBib2R5LnJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZldGNoQ29uZmlnRnJvbVJlcSh7IHJlcSwgcnBjVXJsLCBvcmlnaW5IdHRwSGVhZGVyS2V5LCB9KSB7XG4gICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTChycGNVcmwpO1xuICAgIGNvbnN0IGZldGNoVXJsID0gbm9ybWFsaXplVXJsRnJvbVBhcnNlZChwYXJzZWRVcmwpO1xuICAgIC8vIHByZXBhcmUgcGF5bG9hZFxuICAgIC8vIGNvcHkgb25seSBjYW5vbmljYWwganNvbiBycGMgcHJvcGVydGllc1xuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIGlkOiByZXEuaWQsXG4gICAgICAgIGpzb25ycGM6IHJlcS5qc29ucnBjLFxuICAgICAgICBtZXRob2Q6IHJlcS5tZXRob2QsXG4gICAgICAgIHBhcmFtczogcmVxLnBhcmFtcyxcbiAgICB9O1xuICAgIC8vIGV4dHJhY3QgJ29yaWdpbicgcGFyYW1ldGVyIGZyb20gcmVxdWVzdFxuICAgIGNvbnN0IG9yaWdpbkRvbWFpbiA9IHJlcS5vcmlnaW47XG4gICAgLy8gc2VyaWFsaXplIHJlcXVlc3QgYm9keVxuICAgIGNvbnN0IHNlcmlhbGl6ZWRQYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gICAgLy8gY29uZmlndXJlIGZldGNoIHBhcmFtc1xuICAgIGNvbnN0IGZldGNoUGFyYW1zID0ge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBzZXJpYWxpemVkUGF5bG9hZCxcbiAgICB9O1xuICAgIC8vIGVuY29kZWQgYXV0aCBkZXRhaWxzIGFzIGhlYWRlciAobm90IGFsbG93ZWQgaW4gZmV0Y2ggdXJsKVxuICAgIGlmIChwYXJzZWRVcmwudXNlcm5hbWUgJiYgcGFyc2VkVXJsLnBhc3N3b3JkKSB7XG4gICAgICAgIGNvbnN0IGF1dGhTdHJpbmcgPSBgJHtwYXJzZWRVcmwudXNlcm5hbWV9OiR7cGFyc2VkVXJsLnBhc3N3b3JkfWA7XG4gICAgICAgIGNvbnN0IGVuY29kZWRBdXRoID0gYnRvYShhdXRoU3RyaW5nKTtcbiAgICAgICAgZmV0Y2hQYXJhbXMuaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJhc2ljICR7ZW5jb2RlZEF1dGh9YDtcbiAgICB9XG4gICAgLy8gb3B0aW9uYWw6IGFkZCByZXF1ZXN0IG9yaWdpbiBhcyBoZWFkZXJcbiAgICBpZiAob3JpZ2luSHR0cEhlYWRlcktleSAmJiBvcmlnaW5Eb21haW4pIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuaGVhZGVyc1tvcmlnaW5IdHRwSGVhZGVyS2V5XSA9IG9yaWdpbkRvbWFpbjtcbiAgICB9XG4gICAgcmV0dXJuIHsgZmV0Y2hVcmwsIGZldGNoUGFyYW1zIH07XG59XG5leHBvcnRzLmNyZWF0ZUZldGNoQ29uZmlnRnJvbVJlcSA9IGNyZWF0ZUZldGNoQ29uZmlnRnJvbVJlcTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVVybEZyb21QYXJzZWQocGFyc2VkVXJsKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIHJlc3VsdCArPSBwYXJzZWRVcmwucHJvdG9jb2w7XG4gICAgcmVzdWx0ICs9IGAvLyR7cGFyc2VkVXJsLmhvc3RuYW1lfWA7XG4gICAgaWYgKHBhcnNlZFVybC5wb3J0KSB7XG4gICAgICAgIHJlc3VsdCArPSBgOiR7cGFyc2VkVXJsLnBvcnR9YDtcbiAgICB9XG4gICAgcmVzdWx0ICs9IGAke3BhcnNlZFVybC5wYXRobmFtZX1gO1xuICAgIHJlc3VsdCArPSBgJHtwYXJzZWRVcmwuc2VhcmNofWA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJhdGVsaW1pdEVycm9yKCkge1xuICAgIHJldHVybiBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoeyBtZXNzYWdlOiBgUmVxdWVzdCBpcyBiZWluZyByYXRlIGxpbWl0ZWQuYCB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRpbWVvdXRFcnJvcigpIHtcbiAgICBsZXQgbXNnID0gYEdhdGV3YXkgdGltZW91dC4gVGhlIHJlcXVlc3QgdG9vayB0b28gbG9uZyB0byBwcm9jZXNzLiBgO1xuICAgIG1zZyArPSBgVGhpcyBjYW4gaGFwcGVuIHdoZW4gcXVlcnlpbmcgbG9ncyBvdmVyIHRvbyB3aWRlIGEgYmxvY2sgcmFuZ2UuYDtcbiAgICByZXR1cm4gZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludGVybmFsKHsgbWVzc2FnZTogbXNnIH0pO1xufVxuZnVuY3Rpb24gdGltZW91dChkdXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ibG9jay1jYWNoZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmxvY2stcmVmLXJld3JpdGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jsb2NrLXJlZlwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmxvY2stdHJhY2tlci1pbnNwZWN0b3JcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2ZldGNoXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9pbmZsaWdodC1jYWNoZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcHJvdmlkZXJBc01pZGRsZXdhcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Byb3ZpZGVyRnJvbUVuZ2luZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcHJvdmlkZXJGcm9tTWlkZGxld2FyZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcmV0cnlPbkVtcHR5XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi93YWxsZXRcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUluZmxpZ2h0Q2FjaGVNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QgY2xvbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY2xvbmVcIikpO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgbG9nZ2luZ191dGlsc18xID0gcmVxdWlyZShcIi4vbG9nZ2luZy11dGlsc1wiKTtcbmNvbnN0IGNhY2hlXzEgPSByZXF1aXJlKFwiLi91dGlscy9jYWNoZVwiKTtcbmNvbnN0IGxvZyA9IGxvZ2dpbmdfdXRpbHNfMS5jcmVhdGVNb2R1bGVMb2dnZXIobG9nZ2luZ191dGlsc18xLnByb2plY3RMb2dnZXIsICdpbmZsaWdodC1jYWNoZScpO1xuZnVuY3Rpb24gY3JlYXRlSW5mbGlnaHRDYWNoZU1pZGRsZXdhcmUoKSB7XG4gICAgY29uc3QgaW5mbGlnaHRSZXF1ZXN0cyA9IHt9O1xuICAgIHJldHVybiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmMgKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgICAgIC8vIGFsbG93IGNhY2ggdG8gYmUgc2tpcHBlZCBpZiBzbyBzcGVjaWZpZWRcbiAgICAgICAgaWYgKHJlcS5za2lwQ2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0IGNhY2hlSWQsIGlmIGNhY2hlYWJsZVxuICAgICAgICBjb25zdCBjYWNoZUlkID0gY2FjaGVfMS5jYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkKHJlcSk7XG4gICAgICAgIC8vIGlmIG5vdCBjYWNoZWFibGUsIHNraXBcbiAgICAgICAgaWYgKCFjYWNoZUlkKSB7XG4gICAgICAgICAgICBsb2coJ1JlcXVlc3QgaXMgbm90IGNhY2hlYWJsZSwgcHJvY2VlZGluZy4gcmVxID0gJW8nLCByZXEpO1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBmb3IgbWF0Y2hpbmcgcmVxdWVzdHNcbiAgICAgICAgbGV0IGFjdGl2ZVJlcXVlc3RIYW5kbGVycyA9IGluZmxpZ2h0UmVxdWVzdHNbY2FjaGVJZF07XG4gICAgICAgIC8vIGlmIGZvdW5kLCB3YWl0IGZvciB0aGUgYWN0aXZlIHJlcXVlc3QgdG8gYmUgaGFuZGxlZFxuICAgICAgICBpZiAoYWN0aXZlUmVxdWVzdEhhbmRsZXJzKSB7XG4gICAgICAgICAgICAvLyBzZXR1cCB0aGUgcmVzcG9uc2UgbGlzdGVuZXIgYW5kIHdhaXQgZm9yIGl0IHRvIGJlIGNhbGxlZFxuICAgICAgICAgICAgLy8gaXQgd2lsbCBoYW5kbGUgY29weWluZyB0aGUgcmVzdWx0IGFuZCByZXF1ZXN0IGZpZWxkc1xuICAgICAgICAgICAgbG9nKCdSdW5uaW5nICVpIGhhbmRsZXIocykgZm9yIHJlcXVlc3QgJW8nLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMubGVuZ3RoLCByZXEpO1xuICAgICAgICAgICAgYXdhaXQgY3JlYXRlQWN0aXZlUmVxdWVzdEhhbmRsZXIocmVzLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXR1cCByZXNwb25zZSBoYW5kbGVyIGFycmF5IGZvciBzdWJzZXF1ZW50IHJlcXVlc3RzXG4gICAgICAgIGFjdGl2ZVJlcXVlc3RIYW5kbGVycyA9IFtdO1xuICAgICAgICBpbmZsaWdodFJlcXVlc3RzW2NhY2hlSWRdID0gYWN0aXZlUmVxdWVzdEhhbmRsZXJzO1xuICAgICAgICAvLyBhbGxvdyByZXF1ZXN0IHRvIGJlIGhhbmRsZWQgbm9ybWFsbHlcbiAgICAgICAgbG9nKCdDYXJyeWluZyBvcmlnaW5hbCByZXF1ZXN0IGZvcndhcmQgJW8nLCByZXEpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9jYWxsYmFjay1yZXR1cm5cbiAgICAgICAgYXdhaXQgbmV4dCgpO1xuICAgICAgICAvLyBjbGVhciBpbmZsaWdodCByZXF1ZXN0c1xuICAgICAgICBkZWxldGUgaW5mbGlnaHRSZXF1ZXN0c1tjYWNoZUlkXTtcbiAgICAgICAgLy8gc2NoZWR1bGUgYWN0aXZlUmVxdWVzdEhhbmRsZXJzIHRvIGJlIGhhbmRsZWRcbiAgICAgICAgbG9nKCdSdW5uaW5nICVpIGNvbGxlY3RlZCBoYW5kbGVyKHMpIGZvciByZXF1ZXN0ICVvJywgYWN0aXZlUmVxdWVzdEhhbmRsZXJzLmxlbmd0aCwgcmVxKTtcbiAgICAgICAgaGFuZGxlQWN0aXZlUmVxdWVzdChyZXMsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycyk7XG4gICAgICAgIC8vIGNvbXBsZXRlXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gY3JlYXRlQWN0aXZlUmVxdWVzdEhhbmRsZXIocmVzLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlLCBwcm9taXNlIH0gPSBkZWZlcnJlZFByb21pc2UoKTtcbiAgICAgICAgYWN0aXZlUmVxdWVzdEhhbmRsZXJzLnB1c2goKGhhbmRsZWRSZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGFwcGVuZCBhIGNvcHkgb2YgdGhlIHJlc3VsdCBhbmQgZXJyb3IgdG8gdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICByZXMucmVzdWx0ID0gY2xvbmVfMS5kZWZhdWx0KGhhbmRsZWRSZXMucmVzdWx0KTtcbiAgICAgICAgICAgIHJlcy5lcnJvciA9IGNsb25lXzEuZGVmYXVsdChoYW5kbGVkUmVzLmVycm9yKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVBY3RpdmVSZXF1ZXN0KHJlcywgYWN0aXZlUmVxdWVzdEhhbmRsZXJzKSB7XG4gICAgICAgIC8vIHVzZSBzZXRUaW1lb3V0IHNvIHdlIGNhbiByZXNvbHZlIG91ciBvcmlnaW5hbCByZXF1ZXN0IGZpcnN0XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgYWN0aXZlUmVxdWVzdEhhbmRsZXJzLmZvckVhY2goKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKHJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2F0Y2ggZXJyb3Igc28gYWxsIHJlcXVlc3RzIGFyZSBoYW5kbGVkIGNvcnJlY3RseVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlSW5mbGlnaHRDYWNoZU1pZGRsZXdhcmUgPSBjcmVhdGVJbmZsaWdodENhY2hlTWlkZGxld2FyZTtcbmZ1bmN0aW9uIGRlZmVycmVkUHJvbWlzZSgpIHtcbiAgICBsZXQgcmVzb2x2ZTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKF9yZXNvbHZlKSA9PiB7XG4gICAgICAgIHJlc29sdmUgPSBfcmVzb2x2ZTtcbiAgICB9KTtcbiAgICByZXR1cm4geyByZXNvbHZlLCBwcm9taXNlIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZsaWdodC1jYWNoZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlTW9kdWxlTG9nZ2VyID0gZXhwb3J0cy5wcm9qZWN0TG9nZ2VyID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVNb2R1bGVMb2dnZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuY3JlYXRlTW9kdWxlTG9nZ2VyOyB9IH0pO1xuZXhwb3J0cy5wcm9qZWN0TG9nZ2VyID0gdXRpbHNfMS5jcmVhdGVQcm9qZWN0TG9nZ2VyKCdldGgtanNvbi1ycGMtbWlkZGxld2FyZScpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2luZy11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXRoZXJzUHJvdmlkZXJBc01pZGRsZXdhcmUgPSBleHBvcnRzLnByb3ZpZGVyQXNNaWRkbGV3YXJlID0gdm9pZCAwO1xuZnVuY3Rpb24gcHJvdmlkZXJBc01pZGRsZXdhcmUocHJvdmlkZXIpIHtcbiAgICByZXR1cm4gKHJlcSwgcmVzLCBfbmV4dCwgZW5kKSA9PiB7XG4gICAgICAgIC8vIHNlbmQgcmVxdWVzdCB0byBwcm92aWRlclxuICAgICAgICBwcm92aWRlci5zZW5kQXN5bmMocmVxLCAoZXJyLCBwcm92aWRlclJlcykgPT4ge1xuICAgICAgICAgICAgLy8gZm9yd2FyZCBhbnkgZXJyb3JcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmQoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvcHkgcHJvdmlkZXIgcmVzcG9uc2Ugb250byBvcmlnaW5hbCByZXNwb25zZVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXMsIHByb3ZpZGVyUmVzKTtcbiAgICAgICAgICAgIHJldHVybiBlbmQoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmV4cG9ydHMucHJvdmlkZXJBc01pZGRsZXdhcmUgPSBwcm92aWRlckFzTWlkZGxld2FyZTtcbmZ1bmN0aW9uIGV0aGVyc1Byb3ZpZGVyQXNNaWRkbGV3YXJlKHByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIChyZXEsIHJlcywgX25leHQsIGVuZCkgPT4ge1xuICAgICAgICAvLyBzZW5kIHJlcXVlc3QgdG8gcHJvdmlkZXJcbiAgICAgICAgcHJvdmlkZXIuc2VuZChyZXEsIChlcnIsIHByb3ZpZGVyUmVzKSA9PiB7XG4gICAgICAgICAgICAvLyBmb3J3YXJkIGFueSBlcnJvclxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmQoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvcHkgcHJvdmlkZXIgcmVzcG9uc2Ugb250byBvcmlnaW5hbCByZXNwb25zZVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXMsIHByb3ZpZGVyUmVzKTtcbiAgICAgICAgICAgIHJldHVybiBlbmQoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuZXRoZXJzUHJvdmlkZXJBc01pZGRsZXdhcmUgPSBldGhlcnNQcm92aWRlckFzTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyQXNNaWRkbGV3YXJlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wcm92aWRlckZyb21FbmdpbmUgPSB2b2lkIDA7XG5jb25zdCBzYWZlX2V2ZW50X2VtaXR0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQG1ldGFtYXNrL3NhZmUtZXZlbnQtZW1pdHRlclwiKSk7XG5mdW5jdGlvbiBwcm92aWRlckZyb21FbmdpbmUoZW5naW5lKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgc2FmZV9ldmVudF9lbWl0dGVyXzEuZGVmYXVsdCgpO1xuICAgIC8vIGhhbmRsZSBib3RoIHJwYyBzZW5kIG1ldGhvZHNcbiAgICBwcm92aWRlci5zZW5kQXN5bmMgPSAocmVxLCBjYikgPT4ge1xuICAgICAgICBlbmdpbmUuaGFuZGxlKHJlcSwgY2IpO1xuICAgIH07XG4gICAgcHJvdmlkZXIuc2VuZCA9IChyZXEsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGNhbGxiYWNrIHRvIFwic2VuZFwiIG1ldGhvZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbmdpbmUuaGFuZGxlKHJlcSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgLy8gZm9yd2FyZCBub3RpZmljYXRpb25zXG4gICAgaWYgKGVuZ2luZS5vbikge1xuICAgICAgICBlbmdpbmUub24oJ25vdGlmaWNhdGlvbicsIChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KCdkYXRhJywgbnVsbCwgbWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdmlkZXI7XG59XG5leHBvcnRzLnByb3ZpZGVyRnJvbUVuZ2luZSA9IHByb3ZpZGVyRnJvbUVuZ2luZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyRnJvbUVuZ2luZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucHJvdmlkZXJGcm9tTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IHByb3ZpZGVyRnJvbUVuZ2luZV8xID0gcmVxdWlyZShcIi4vcHJvdmlkZXJGcm9tRW5naW5lXCIpO1xuZnVuY3Rpb24gcHJvdmlkZXJGcm9tTWlkZGxld2FyZShtaWRkbGV3YXJlKSB7XG4gICAgY29uc3QgZW5naW5lID0gbmV3IGpzb25fcnBjX2VuZ2luZV8xLkpzb25ScGNFbmdpbmUoKTtcbiAgICBlbmdpbmUucHVzaChtaWRkbGV3YXJlKTtcbiAgICBjb25zdCBwcm92aWRlciA9IHByb3ZpZGVyRnJvbUVuZ2luZV8xLnByb3ZpZGVyRnJvbUVuZ2luZShlbmdpbmUpO1xuICAgIHJldHVybiBwcm92aWRlcjtcbn1cbmV4cG9ydHMucHJvdmlkZXJGcm9tTWlkZGxld2FyZSA9IHByb3ZpZGVyRnJvbU1pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlckZyb21NaWRkbGV3YXJlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVSZXRyeU9uRW1wdHlNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QgY2xvbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY2xvbmVcIikpO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgcGlmeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwaWZ5XCIpKTtcbmNvbnN0IGxvZ2dpbmdfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmctdXRpbHNcIik7XG5jb25zdCBjYWNoZV8xID0gcmVxdWlyZShcIi4vdXRpbHMvY2FjaGVcIik7XG4vL1xuLy8gUmV0cnlPbkVtcHR5TWlkZGxld2FyZSB3aWxsIHJldHJ5IGFueSByZXF1ZXN0IHdpdGggYW4gZW1wdHkgcmVzcG9uc2UgdGhhdCBoYXNcbi8vIGEgbnVtYmVyZWQgYmxvY2sgcmVmZXJlbmNlIGF0IG9yIGxvd2VyIHRoYW4gdGhlIGJsb2NrVHJhY2tlcidzIGxhdGVzdCBibG9jay5cbi8vIEl0cyB1c2VmdWwgZm9yIGRlYWxpbmcgd2l0aCBsb2FkLWJhbGFuY2VkIGV0aGVyZXVtIEpTT04gUlBDXG4vLyBub2RlcyB0aGF0IGFyZSBub3QgYWx3YXlzIGluIHN5bmMgd2l0aCBlYWNoIG90aGVyLlxuLy9cbmNvbnN0IGxvZyA9IGxvZ2dpbmdfdXRpbHNfMS5jcmVhdGVNb2R1bGVMb2dnZXIobG9nZ2luZ191dGlsc18xLnByb2plY3RMb2dnZXIsICdyZXRyeS1vbi1lbXB0eScpO1xuLy8gZW1wdHkgdmFsdWVzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGEgcmVxdWVzdCBzaG91bGQgYmUgcmV0cmllZFxuLy8gYDxuaWw+YCBjb21lcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMTY5MjVcbmNvbnN0IGVtcHR5VmFsdWVzID0gW1xuICAgIHVuZGVmaW5lZCxcbiAgICBudWxsLFxuICAgICdcXHUwMDNjbmlsXFx1MDAzZScsXG5dO1xuZnVuY3Rpb24gY3JlYXRlUmV0cnlPbkVtcHR5TWlkZGxld2FyZSh7IHByb3ZpZGVyLCBibG9ja1RyYWNrZXIsIH0gPSB7fSkge1xuICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1JldHJ5T25FbXB0eU1pZGRsZXdhcmUgLSBtYW5kYXRvcnkgXCJwcm92aWRlclwiIG9wdGlvbiBpcyBtaXNzaW5nLicpO1xuICAgIH1cbiAgICBpZiAoIWJsb2NrVHJhY2tlcikge1xuICAgICAgICB0aHJvdyBFcnJvcignUmV0cnlPbkVtcHR5TWlkZGxld2FyZSAtIG1hbmRhdG9yeSBcImJsb2NrVHJhY2tlclwiIG9wdGlvbiBpcyBtaXNzaW5nLicpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGJsb2NrUmVmSW5kZXggPSBjYWNoZV8xLmJsb2NrVGFnUGFyYW1JbmRleChyZXEpO1xuICAgICAgICAvLyBza2lwIGlmIG1ldGhvZCBkb2VzIG5vdCBpbmNsdWRlIGJsb2NrUmVmXG4gICAgICAgIGlmIChibG9ja1JlZkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2tpcCBpZiBub3QgZXhhY3QgYmxvY2sgcmVmZXJlbmNlc1xuICAgICAgICBsZXQgYmxvY2tSZWYgPSAoX2EgPSByZXEucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbYmxvY2tSZWZJbmRleF07XG4gICAgICAgIC8vIG9taXR0ZWQgYmxvY2tSZWYgaW1wbGllcyBcImxhdGVzdFwiXG4gICAgICAgIGlmIChibG9ja1JlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBibG9ja1JlZiA9ICdsYXRlc3QnO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNraXAgaWYgbm9uLW51bWJlciBibG9jayByZWZlcmVuY2VcbiAgICAgICAgaWYgKFsnbGF0ZXN0JywgJ3BlbmRpbmcnXS5pbmNsdWRlcyhibG9ja1JlZikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2tpcCBpZiBibG9jayByZWZlcm5jZSBpcyBub3QgYSB2YWxpZCBudW1iZXJcbiAgICAgICAgY29uc3QgYmxvY2tSZWZOdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQoYmxvY2tSZWYuc2xpY2UoMiksIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihibG9ja1JlZk51bWJlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9va3VwIGxhdGVzdCBibG9ja1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja051bWJlckhleCA9IGF3YWl0IGJsb2NrVHJhY2tlci5nZXRMYXRlc3RCbG9jaygpO1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja051bWJlciA9IE51bWJlci5wYXJzZUludChsYXRlc3RCbG9ja051bWJlckhleC5zbGljZSgyKSwgMTYpO1xuICAgICAgICAvLyBza2lwIGlmIHJlcXVlc3QgYmxvY2sgbnVtYmVyIGlzIGhpZ2hlciB0aGFuIGN1cnJlbnRcbiAgICAgICAgaWYgKGJsb2NrUmVmTnVtYmVyID4gbGF0ZXN0QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgIGxvZygnUmVxdWVzdGVkIGJsb2NrIG51bWJlciAlbyBpcyBoaWdoZXIgdGhhbiBsYXRlc3QgYmxvY2sgbnVtYmVyICVvLCBmYWxsaW5nIHRocm91Z2ggdG8gb3JpZ2luYWwgcmVxdWVzdCcsIGJsb2NrUmVmTnVtYmVyLCBsYXRlc3RCbG9ja051bWJlcik7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGxvZygnUmVxdWVzdGVkIGJsb2NrIG51bWJlciAlbyBpcyBub3QgaGlnaGVyIHRoYW4gbGF0ZXN0IGJsb2NrIG51bWJlciAlbywgdHJ5aW5nIHJlcXVlc3QgdW50aWwgbm9uLWVtcHR5IHJlc3BvbnNlIGlzIHJlY2VpdmVkJywgYmxvY2tSZWZOdW1iZXIsIGxhdGVzdEJsb2NrTnVtYmVyKTtcbiAgICAgICAgLy8gY3JlYXRlIGNoaWxkIHJlcXVlc3Qgd2l0aCBzcGVjaWZpYyBibG9jay1yZWZcbiAgICAgICAgY29uc3QgY2hpbGRSZXF1ZXN0ID0gY2xvbmVfMS5kZWZhdWx0KHJlcSk7XG4gICAgICAgIC8vIGF0dGVtcHQgY2hpbGQgcmVxdWVzdCB1bnRpbCBub24tZW1wdHkgcmVzcG9uc2UgaXMgcmVjZWl2ZWRcbiAgICAgICAgY29uc3QgY2hpbGRSZXNwb25zZSA9IGF3YWl0IHJldHJ5KDEwLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsb2coJ1BlcmZvcm1pbmcgcmVxdWVzdCAlbycsIGNoaWxkUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBhdHRlbXB0UmVzcG9uc2UgPSBhd2FpdCBwaWZ5XzEuZGVmYXVsdChwcm92aWRlci5zZW5kQXN5bmMpLmNhbGwocHJvdmlkZXIsIGNoaWxkUmVxdWVzdCk7XG4gICAgICAgICAgICBsb2coJ1Jlc3BvbnNlIGlzICVvJywgYXR0ZW1wdFJlc3BvbnNlKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXN1bHRcbiAgICAgICAgICAgIGlmIChlbXB0eVZhbHVlcy5pbmNsdWRlcyhhdHRlbXB0UmVzcG9uc2UucmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmV0cnlPbkVtcHR5TWlkZGxld2FyZSAtIGVtcHR5IHJlc3BvbnNlIFwiJHtKU09OLnN0cmluZ2lmeShhdHRlbXB0UmVzcG9uc2UpfVwiIGZvciByZXF1ZXN0IFwiJHtKU09OLnN0cmluZ2lmeShjaGlsZFJlcXVlc3QpfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXR0ZW1wdFJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICAgICAgbG9nKCdDb3B5aW5nIHJlc3VsdCAlbyBhbmQgZXJyb3IgJW8nLCBjaGlsZFJlc3BvbnNlLnJlc3VsdCwgY2hpbGRSZXNwb25zZS5lcnJvcik7XG4gICAgICAgIC8vIGNvcHkgY2hpbGQgcmVzcG9uc2Ugb250byBvcmlnaW5hbCByZXNwb25zZVxuICAgICAgICByZXMucmVzdWx0ID0gY2hpbGRSZXNwb25zZS5yZXN1bHQ7XG4gICAgICAgIHJlcy5lcnJvciA9IGNoaWxkUmVzcG9uc2UuZXJyb3I7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZVJldHJ5T25FbXB0eU1pZGRsZXdhcmUgPSBjcmVhdGVSZXRyeU9uRW1wdHlNaWRkbGV3YXJlO1xuYXN5bmMgZnVuY3Rpb24gcmV0cnkobWF4UmV0cmllcywgYXN5bmNGbikge1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBtYXhSZXRyaWVzOyBpbmRleCsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgYXN5bmNGbigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZygnKGNhbGwgJWkpIFJlcXVlc3QgZmFpbGVkLCB3YWl0aW5nIDFzIHRvIHJldHJ5IGFnYWluLi4uJywgaW5kZXggKyAxKTtcbiAgICAgICAgICAgIGF3YWl0IHRpbWVvdXQoMTAwMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9nKCdSZXRyaWVzIGV4aGF1c3RlZCcpO1xuICAgIHRocm93IG5ldyBFcnJvcignUmV0cnlPbkVtcHR5TWlkZGxld2FyZSAtIHJldHJpZXMgZXhoYXVzdGVkJyk7XG59XG5mdW5jdGlvbiB0aW1lb3V0KGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXRyeU9uRW1wdHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhY2hlVHlwZUZvclBheWxvYWQgPSBleHBvcnRzLmJsb2NrVGFnUGFyYW1JbmRleCA9IGV4cG9ydHMucGFyYW1zV2l0aG91dEJsb2NrVGFnID0gZXhwb3J0cy5ibG9ja1RhZ0ZvclBheWxvYWQgPSBleHBvcnRzLmNhbkNhY2hlID0gZXhwb3J0cy5jYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkID0gdm9pZCAwO1xuY29uc3QganNvbl9zdGFibGVfc3RyaW5naWZ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzb24tc3RhYmxlLXN0cmluZ2lmeVwiKSk7XG5mdW5jdGlvbiBjYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkKHBheWxvYWQsIHNraXBCbG9ja1JlZikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzaW1wbGVQYXJhbXMgPSBza2lwQmxvY2tSZWZcbiAgICAgICAgPyBwYXJhbXNXaXRob3V0QmxvY2tUYWcocGF5bG9hZClcbiAgICAgICAgOiAoX2EgPSBwYXlsb2FkLnBhcmFtcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgaWYgKGNhbkNhY2hlKHBheWxvYWQpKSB7XG4gICAgICAgIHJldHVybiBgJHtwYXlsb2FkLm1ldGhvZH06JHtqc29uX3N0YWJsZV9zdHJpbmdpZnlfMS5kZWZhdWx0KHNpbXBsZVBhcmFtcyl9YDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLmNhY2hlSWRlbnRpZmllckZvclBheWxvYWQgPSBjYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkO1xuZnVuY3Rpb24gY2FuQ2FjaGUocGF5bG9hZCkge1xuICAgIHJldHVybiBjYWNoZVR5cGVGb3JQYXlsb2FkKHBheWxvYWQpICE9PSAnbmV2ZXInO1xufVxuZXhwb3J0cy5jYW5DYWNoZSA9IGNhbkNhY2hlO1xuZnVuY3Rpb24gYmxvY2tUYWdGb3JQYXlsb2FkKHBheWxvYWQpIHtcbiAgICBpZiAoIXBheWxvYWQucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gYmxvY2tUYWdQYXJhbUluZGV4KHBheWxvYWQpO1xuICAgIC8vIEJsb2NrIHRhZyBwYXJhbSBub3QgcGFzc2VkLlxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkIHx8IGluZGV4ID49IHBheWxvYWQucGFyYW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gcGF5bG9hZC5wYXJhbXNbaW5kZXhdO1xufVxuZXhwb3J0cy5ibG9ja1RhZ0ZvclBheWxvYWQgPSBibG9ja1RhZ0ZvclBheWxvYWQ7XG5mdW5jdGlvbiBwYXJhbXNXaXRob3V0QmxvY2tUYWcocGF5bG9hZCkge1xuICAgIGlmICghcGF5bG9hZC5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IGJsb2NrVGFnUGFyYW1JbmRleChwYXlsb2FkKTtcbiAgICAvLyBCbG9jayB0YWcgcGFyYW0gbm90IHBhc3NlZC5cbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCB8fCBpbmRleCA+PSBwYXlsb2FkLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQucGFyYW1zO1xuICAgIH1cbiAgICAvLyBldGhfZ2V0QmxvY2tCeU51bWJlciBoYXMgdGhlIGJsb2NrIHRhZyBmaXJzdCwgdGhlbiB0aGUgb3B0aW9uYWwgaW5jbHVkZVR4PyBwYXJhbVxuICAgIGlmIChwYXlsb2FkLm1ldGhvZCA9PT0gJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJykge1xuICAgICAgICByZXR1cm4gcGF5bG9hZC5wYXJhbXMuc2xpY2UoMSk7XG4gICAgfVxuICAgIHJldHVybiBwYXlsb2FkLnBhcmFtcy5zbGljZSgwLCBpbmRleCk7XG59XG5leHBvcnRzLnBhcmFtc1dpdGhvdXRCbG9ja1RhZyA9IHBhcmFtc1dpdGhvdXRCbG9ja1RhZztcbmZ1bmN0aW9uIGJsb2NrVGFnUGFyYW1JbmRleChwYXlsb2FkKSB7XG4gICAgc3dpdGNoIChwYXlsb2FkLm1ldGhvZCkge1xuICAgICAgICAvLyBibG9ja1RhZyBpcyBhdCBpbmRleCAyXG4gICAgICAgIGNhc2UgJ2V0aF9nZXRTdG9yYWdlQXQnOlxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIC8vIGJsb2NrVGFnIGlzIGF0IGluZGV4IDFcbiAgICAgICAgY2FzZSAnZXRoX2dldEJhbGFuY2UnOlxuICAgICAgICBjYXNlICdldGhfZ2V0Q29kZSc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50JzpcbiAgICAgICAgY2FzZSAnZXRoX2NhbGwnOlxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIC8vIGJsb2NrVGFnIGlzIGF0IGluZGV4IDBcbiAgICAgICAgY2FzZSAnZXRoX2dldEJsb2NrQnlOdW1iZXInOlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIGJsb2NrVGFnXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuYmxvY2tUYWdQYXJhbUluZGV4ID0gYmxvY2tUYWdQYXJhbUluZGV4O1xuZnVuY3Rpb24gY2FjaGVUeXBlRm9yUGF5bG9hZChwYXlsb2FkKSB7XG4gICAgc3dpdGNoIChwYXlsb2FkLm1ldGhvZCkge1xuICAgICAgICAvLyBjYWNoZSBwZXJtYW5lbnRseVxuICAgICAgICBjYXNlICd3ZWIzX2NsaWVudFZlcnNpb24nOlxuICAgICAgICBjYXNlICd3ZWIzX3NoYTMnOlxuICAgICAgICBjYXNlICdldGhfcHJvdG9jb2xWZXJzaW9uJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudEJ5SGFzaCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRVbmNsZUNvdW50QnlCbG9ja0hhc2gnOlxuICAgICAgICBjYXNlICdldGhfZ2V0Q29kZSc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCbG9ja0J5SGFzaCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tIYXNoQW5kSW5kZXgnOlxuICAgICAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFVuY2xlQnlCbG9ja0hhc2hBbmRJbmRleCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRDb21waWxlcnMnOlxuICAgICAgICBjYXNlICdldGhfY29tcGlsZUxMTCc6XG4gICAgICAgIGNhc2UgJ2V0aF9jb21waWxlU29saWRpdHknOlxuICAgICAgICBjYXNlICdldGhfY29tcGlsZVNlcnBlbnQnOlxuICAgICAgICBjYXNlICdzaGhfdmVyc2lvbic6XG4gICAgICAgIGNhc2UgJ3Rlc3RfcGVybWFDYWNoZSc6XG4gICAgICAgICAgICByZXR1cm4gJ3Blcm1hJztcbiAgICAgICAgLy8gY2FjaGUgdW50aWwgZm9ya1xuICAgICAgICBjYXNlICdldGhfZ2V0QmxvY2tCeU51bWJlcic6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRCeU51bWJlcic6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRVbmNsZUNvdW50QnlCbG9ja051bWJlcic6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tOdW1iZXJBbmRJbmRleCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRVbmNsZUJ5QmxvY2tOdW1iZXJBbmRJbmRleCc6XG4gICAgICAgIGNhc2UgJ3Rlc3RfZm9ya0NhY2hlJzpcbiAgICAgICAgICAgIHJldHVybiAnZm9yayc7XG4gICAgICAgIC8vIGNhY2hlIGZvciBibG9ja1xuICAgICAgICBjYXNlICdldGhfZ2FzUHJpY2UnOlxuICAgICAgICBjYXNlICdldGhfYmxvY2tOdW1iZXInOlxuICAgICAgICBjYXNlICdldGhfZ2V0QmFsYW5jZSc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRTdG9yYWdlQXQnOlxuICAgICAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCc6XG4gICAgICAgIGNhc2UgJ2V0aF9jYWxsJzpcbiAgICAgICAgY2FzZSAnZXRoX2VzdGltYXRlR2FzJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldEZpbHRlckxvZ3MnOlxuICAgICAgICBjYXNlICdldGhfZ2V0TG9ncyc6XG4gICAgICAgIGNhc2UgJ3Rlc3RfYmxvY2tDYWNoZSc6XG4gICAgICAgICAgICByZXR1cm4gJ2Jsb2NrJztcbiAgICAgICAgLy8gbmV2ZXIgY2FjaGVcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnbmV2ZXInO1xuICAgIH1cbn1cbmV4cG9ydHMuY2FjaGVUeXBlRm9yUGF5bG9hZCA9IGNhY2hlVHlwZUZvclBheWxvYWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWNoZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVXYWxsZXRNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3Qgc2lnVXRpbCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiQG1ldGFtYXNrL2V0aC1zaWctdXRpbFwiKSk7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2FsbGV0TWlkZGxld2FyZSh7IGdldEFjY291bnRzLCBwcm9jZXNzRGVjcnlwdE1lc3NhZ2UsIHByb2Nlc3NFbmNyeXB0aW9uUHVibGljS2V5LCBwcm9jZXNzRXRoU2lnbk1lc3NhZ2UsIHByb2Nlc3NQZXJzb25hbE1lc3NhZ2UsIHByb2Nlc3NUcmFuc2FjdGlvbiwgcHJvY2Vzc1NpZ25UcmFuc2FjdGlvbiwgcHJvY2Vzc1R5cGVkTWVzc2FnZSwgcHJvY2Vzc1R5cGVkTWVzc2FnZVYzLCBwcm9jZXNzVHlwZWRNZXNzYWdlVjQsIH0pIHtcbiAgICBpZiAoIWdldEFjY291bnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0cy5nZXRBY2NvdW50cyBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlU2NhZmZvbGRNaWRkbGV3YXJlKHtcbiAgICAgICAgLy8gYWNjb3VudCBsb29rdXBzXG4gICAgICAgIGV0aF9hY2NvdW50czoganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGxvb2t1cEFjY291bnRzKSxcbiAgICAgICAgZXRoX2NvaW5iYXNlOiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUobG9va3VwRGVmYXVsdEFjY291bnQpLFxuICAgICAgICAvLyB0eCBzaWduYXR1cmVzXG4gICAgICAgIGV0aF9zZW5kVHJhbnNhY3Rpb246IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShzZW5kVHJhbnNhY3Rpb24pLFxuICAgICAgICBldGhfc2lnblRyYW5zYWN0aW9uOiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoc2lnblRyYW5zYWN0aW9uKSxcbiAgICAgICAgLy8gbWVzc2FnZSBzaWduYXR1cmVzXG4gICAgICAgIGV0aF9zaWduOiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoZXRoU2lnbiksXG4gICAgICAgIGV0aF9zaWduVHlwZWREYXRhOiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoc2lnblR5cGVkRGF0YSksXG4gICAgICAgIGV0aF9zaWduVHlwZWREYXRhX3YzOiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoc2lnblR5cGVkRGF0YVYzKSxcbiAgICAgICAgZXRoX3NpZ25UeXBlZERhdGFfdjQ6IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShzaWduVHlwZWREYXRhVjQpLFxuICAgICAgICBwZXJzb25hbF9zaWduOiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUocGVyc29uYWxTaWduKSxcbiAgICAgICAgZXRoX2dldEVuY3J5cHRpb25QdWJsaWNLZXk6IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShlbmNyeXB0aW9uUHVibGljS2V5KSxcbiAgICAgICAgZXRoX2RlY3J5cHQ6IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShkZWNyeXB0TWVzc2FnZSksXG4gICAgICAgIHBlcnNvbmFsX2VjUmVjb3ZlcjoganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKHBlcnNvbmFsUmVjb3ZlciksXG4gICAgfSk7XG4gICAgLy9cbiAgICAvLyBhY2NvdW50IGxvb2t1cHNcbiAgICAvL1xuICAgIGFzeW5jIGZ1bmN0aW9uIGxvb2t1cEFjY291bnRzKHJlcSwgcmVzKSB7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBnZXRBY2NvdW50cyhyZXEpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBsb29rdXBEZWZhdWx0QWNjb3VudChyZXEsIHJlcykge1xuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGdldEFjY291bnRzKHJlcSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhY2NvdW50c1swXSB8fCBudWxsO1xuICAgIH1cbiAgICAvL1xuICAgIC8vIHRyYW5zYWN0aW9uIHNpZ25hdHVyZXNcbiAgICAvL1xuICAgIGFzeW5jIGZ1bmN0aW9uIHNlbmRUcmFuc2FjdGlvbihyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR4UGFyYW1zID0gcmVxLnBhcmFtc1swXSB8fCB7fTtcbiAgICAgICAgdHhQYXJhbXMuZnJvbSA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHR4UGFyYW1zLmZyb20sIHJlcSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzVHJhbnNhY3Rpb24odHhQYXJhbXMsIHJlcSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNpZ25UcmFuc2FjdGlvbihyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NTaWduVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eFBhcmFtcyA9IHJlcS5wYXJhbXNbMF0gfHwge307XG4gICAgICAgIHR4UGFyYW1zLmZyb20gPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcih0eFBhcmFtcy5mcm9tLCByZXEpO1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc1NpZ25UcmFuc2FjdGlvbih0eFBhcmFtcywgcmVxKTtcbiAgICB9XG4gICAgLy9cbiAgICAvLyBtZXNzYWdlIHNpZ25hdHVyZXNcbiAgICAvL1xuICAgIGFzeW5jIGZ1bmN0aW9uIGV0aFNpZ24ocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzRXRoU2lnbk1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIocmVxLnBhcmFtc1swXSwgcmVxKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlcS5wYXJhbXNbMV07XG4gICAgICAgIGNvbnN0IGV4dHJhUGFyYW1zID0gcmVxLnBhcmFtc1syXSB8fCB7fTtcbiAgICAgICAgY29uc3QgbXNnUGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBleHRyYVBhcmFtcyksIHsgZnJvbTogYWRkcmVzcywgZGF0YTogbWVzc2FnZSB9KTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NFdGhTaWduTWVzc2FnZShtc2dQYXJhbXMsIHJlcSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNpZ25UeXBlZERhdGEocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzVHlwZWRNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlcS5wYXJhbXNbMF07XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihyZXEucGFyYW1zWzFdLCByZXEpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gJ1YxJztcbiAgICAgICAgY29uc3QgZXh0cmFQYXJhbXMgPSByZXEucGFyYW1zWzJdIHx8IHt9O1xuICAgICAgICBjb25zdCBtc2dQYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4dHJhUGFyYW1zKSwgeyBmcm9tOiBhZGRyZXNzLCBkYXRhOiBtZXNzYWdlIH0pO1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc1R5cGVkTWVzc2FnZShtc2dQYXJhbXMsIHJlcSwgdmVyc2lvbik7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNpZ25UeXBlZERhdGFWMyhyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NUeXBlZE1lc3NhZ2VWMykge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihyZXEucGFyYW1zWzBdLCByZXEpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gcmVxLnBhcmFtc1sxXTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9ICdWMyc7XG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtcyA9IHtcbiAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2UsXG4gICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgfTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NUeXBlZE1lc3NhZ2VWMyhtc2dQYXJhbXMsIHJlcSwgdmVyc2lvbik7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNpZ25UeXBlZERhdGFWNChyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NUeXBlZE1lc3NhZ2VWNCkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihyZXEucGFyYW1zWzBdLCByZXEpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gcmVxLnBhcmFtc1sxXTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9ICdWNCc7XG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtcyA9IHtcbiAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2UsXG4gICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgfTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NUeXBlZE1lc3NhZ2VWNChtc2dQYXJhbXMsIHJlcSwgdmVyc2lvbik7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHBlcnNvbmFsU2lnbihyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NQZXJzb25hbE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcm9jZXNzIG5vcm1hbGx5XG4gICAgICAgIGNvbnN0IGZpcnN0UGFyYW0gPSByZXEucGFyYW1zWzBdO1xuICAgICAgICBjb25zdCBzZWNvbmRQYXJhbSA9IHJlcS5wYXJhbXNbMV07XG4gICAgICAgIC8vIG5vbi1zdGFuZGFyZCBcImV4dHJhUGFyYW1zXCIgdG8gYmUgYXBwZW5kZWQgdG8gb3VyIFwibXNnUGFyYW1zXCIgb2JqXG4gICAgICAgIGNvbnN0IGV4dHJhUGFyYW1zID0gcmVxLnBhcmFtc1syXSB8fCB7fTtcbiAgICAgICAgLy8gV2UgaW5pdGlhbGx5IGluY29ycmVjdGx5IG9yZGVyZWQgdGhlc2UgcGFyYW1ldGVycy5cbiAgICAgICAgLy8gVG8gZ3JhY2VmdWxseSByZXNwZWN0IHVzZXJzIHdobyBhZG9wdGVkIHRoaXMgQVBJIGVhcmx5LFxuICAgICAgICAvLyB3ZSBhcmUgY3VycmVudGx5IGdyYWNlZnVsbHkgcmVjb3ZlcmluZyBmcm9tIHRoZSB3cm9uZyBwYXJhbSBvcmRlclxuICAgICAgICAvLyB3aGVuIGl0IGlzIGNsZWFybHkgaWRlbnRpZmlhYmxlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGF0IG1lYW5zIHdoZW4gdGhlIGZpcnN0IHBhcmFtIGlzIGRlZmluaXRlbHkgYW4gYWRkcmVzcyxcbiAgICAgICAgLy8gYW5kIHRoZSBzZWNvbmQgcGFyYW0gaXMgZGVmaW5pdGVseSBub3QsIGJ1dCBpcyBoZXguXG4gICAgICAgIGxldCBhZGRyZXNzLCBtZXNzYWdlO1xuICAgICAgICBpZiAocmVzZW1ibGVzQWRkcmVzcyhmaXJzdFBhcmFtKSAmJiAhcmVzZW1ibGVzQWRkcmVzcyhzZWNvbmRQYXJhbSkpIHtcbiAgICAgICAgICAgIGxldCB3YXJuaW5nID0gYFRoZSBldGhfcGVyc29uYWxTaWduIG1ldGhvZCByZXF1aXJlcyBwYXJhbXMgb3JkZXJlZCBgO1xuICAgICAgICAgICAgd2FybmluZyArPSBgW21lc3NhZ2UsIGFkZHJlc3NdLiBUaGlzIHdhcyBwcmV2aW91c2x5IGhhbmRsZWQgaW5jb3JyZWN0bHksIGA7XG4gICAgICAgICAgICB3YXJuaW5nICs9IGBhbmQgaGFzIGJlZW4gY29ycmVjdGVkIGF1dG9tYXRpY2FsbHkuIGA7XG4gICAgICAgICAgICB3YXJuaW5nICs9IGBQbGVhc2Ugc3dpdGNoIHRoaXMgcGFyYW0gb3JkZXIgZm9yIHNtb290aCBiZWhhdmlvciBpbiB0aGUgZnV0dXJlLmA7XG4gICAgICAgICAgICByZXMud2FybmluZyA9IHdhcm5pbmc7XG4gICAgICAgICAgICBhZGRyZXNzID0gZmlyc3RQYXJhbTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBzZWNvbmRQYXJhbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBmaXJzdFBhcmFtO1xuICAgICAgICAgICAgYWRkcmVzcyA9IHNlY29uZFBhcmFtO1xuICAgICAgICB9XG4gICAgICAgIGFkZHJlc3MgPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihhZGRyZXNzLCByZXEpO1xuICAgICAgICBjb25zdCBtc2dQYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4dHJhUGFyYW1zKSwgeyBmcm9tOiBhZGRyZXNzLCBkYXRhOiBtZXNzYWdlIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hdG9taWMtdXBkYXRlc1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc1BlcnNvbmFsTWVzc2FnZShtc2dQYXJhbXMsIHJlcSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHBlcnNvbmFsUmVjb3ZlcihyZXEsIHJlcykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gcmVxLnBhcmFtc1swXTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gcmVxLnBhcmFtc1sxXTtcbiAgICAgICAgY29uc3Qgc2lnbmVyQWRkcmVzcyA9IHNpZ1V0aWwucmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlKHtcbiAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2UsXG4gICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXMucmVzdWx0ID0gc2lnbmVyQWRkcmVzcztcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZW5jcnlwdGlvblB1YmxpY0tleShyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NFbmNyeXB0aW9uUHVibGljS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHJlcS5wYXJhbXNbMF0sIHJlcSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzRW5jcnlwdGlvblB1YmxpY0tleShhZGRyZXNzLCByZXEpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBkZWNyeXB0TWVzc2FnZShyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NEZWNyeXB0TWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSByZXEucGFyYW1zWzBdO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIocmVxLnBhcmFtc1sxXSwgcmVxKTtcbiAgICAgICAgY29uc3QgZXh0cmFQYXJhbXMgPSByZXEucGFyYW1zWzJdIHx8IHt9O1xuICAgICAgICBjb25zdCBtc2dQYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4dHJhUGFyYW1zKSwgeyBmcm9tOiBhZGRyZXNzLCBkYXRhOiBjaXBoZXJ0ZXh0IH0pO1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc0RlY3J5cHRNZXNzYWdlKG1zZ1BhcmFtcywgcmVxKTtcbiAgICB9XG4gICAgLy9cbiAgICAvLyB1dGlsaXR5XG4gICAgLy9cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIGtleWhvbGRlciBhZGRyZXNzLCBhbmQgcmV0dXJucyBhIG5vcm1hbGl6ZWQgKGkuZS4gbG93ZXJjYXNlKVxuICAgICAqIGNvcHkgb2YgaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBhZGRyZXNzIHRvIHZhbGlkYXRlIGFuZCBub3JtYWxpemUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlcSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBub3JtYWxpemVkIGFkZHJlc3MsIGlmIHZhbGlkLiBPdGhlcndpc2UsIHRocm93c1xuICAgICAqIGFuIGVycm9yXG4gICAgICovXG4gICAgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIoYWRkcmVzcywgcmVxKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYWRkcmVzcyA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIGFkZHJlc3MubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgcmVzZW1ibGVzQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgICAgICAgLy8gZW5zdXJlIGFkZHJlc3MgaXMgaW5jbHVkZWQgaW4gcHJvdmlkZWQgYWNjb3VudHMuIGBzdXBwcmVzc1VuYXV0aG9yaXplZDogZmFsc2VgIGlzIHBhc3NlZCB0byBgZ2V0QWNjb3VudHNgXG4gICAgICAgICAgICAvLyBzbyB0aGF0IGFuIFwidW5hdXRob3JpemVkXCIgZXJyb3IgaXMgdGhyb3duIGlmIHRoZSByZXF1ZXN0ZXIgZG9lcyBub3QgaGF2ZSB0aGUgYGV0aF9hY2NvdW50c2BcbiAgICAgICAgICAgIC8vIHBlcm1pc3Npb24uXG4gICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGdldEFjY291bnRzKHJlcSwge1xuICAgICAgICAgICAgICAgIHN1cHByZXNzVW5hdXRob3JpemVkOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEFjY291bnRzID0gYWNjb3VudHMubWFwKChfYWRkcmVzcykgPT4gX2FkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkQWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkQWNjb3VudHMuaW5jbHVkZXMobm9ybWFsaXplZEFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRBZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucHJvdmlkZXIudW5hdXRob3JpemVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICAgICAgbWVzc2FnZTogYEludmFsaWQgcGFyYW1ldGVyczogbXVzdCBwcm92aWRlIGFuIEV0aGVyZXVtIGFkZHJlc3MuYCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVXYWxsZXRNaWRkbGV3YXJlID0gY3JlYXRlV2FsbGV0TWlkZGxld2FyZTtcbmZ1bmN0aW9uIHJlc2VtYmxlc0FkZHJlc3Moc3RyKSB7XG4gICAgLy8gaGV4IHByZWZpeCAyICsgMjAgYnl0ZXNcbiAgICByZXR1cm4gc3RyLmxlbmd0aCA9PT0gMiArIDIwICogMjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhbGxldC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHByb2Nlc3NGbiA9IChmbiwgb3B0cykgPT4gZnVuY3Rpb24gKCkge1xuXHRjb25zdCBQID0gb3B0cy5wcm9taXNlTW9kdWxlO1xuXHRjb25zdCBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0YXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcblx0fVxuXG5cdHJldHVybiBuZXcgUCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0aWYgKG9wdHMuZXJyb3JGaXJzdCkge1xuXHRcdFx0YXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuXHRcdFx0XHRpZiAob3B0cy5tdWx0aUFyZ3MpIHtcblx0XHRcdFx0XHRjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzLnVuc2hpZnQoZXJyKTtcblx0XHRcdFx0XHRcdHJlamVjdChyZXN1bHRzKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoZXJyKSB7XG5cdFx0XHRcdFx0cmVqZWN0KGVycik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXJncy5wdXNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHRcdFx0aWYgKG9wdHMubXVsdGlBcmdzKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0cmVzdWx0c1tpXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Zm4uYXBwbHkodGhpcywgYXJncyk7XG5cdH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAob2JqLCBvcHRzKSA9PiB7XG5cdG9wdHMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRleGNsdWRlOiBbLy4rKFN5bmN8U3RyZWFtKSQvXSxcblx0XHRlcnJvckZpcnN0OiB0cnVlLFxuXHRcdHByb21pc2VNb2R1bGU6IFByb21pc2Vcblx0fSwgb3B0cyk7XG5cblx0Y29uc3QgZmlsdGVyID0ga2V5ID0+IHtcblx0XHRjb25zdCBtYXRjaCA9IHBhdHRlcm4gPT4gdHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnID8ga2V5ID09PSBwYXR0ZXJuIDogcGF0dGVybi50ZXN0KGtleSk7XG5cdFx0cmV0dXJuIG9wdHMuaW5jbHVkZSA/IG9wdHMuaW5jbHVkZS5zb21lKG1hdGNoKSA6ICFvcHRzLmV4Y2x1ZGUuc29tZShtYXRjaCk7XG5cdH07XG5cblx0bGV0IHJldDtcblx0aWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAob3B0cy5leGNsdWRlTWFpbikge1xuXHRcdFx0XHRyZXR1cm4gb2JqLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcm9jZXNzRm4ob2JqLCBvcHRzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSk7XG5cdH1cblxuXHRmb3IgKGNvbnN0IGtleSBpbiBvYmopIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBndWFyZC1mb3ItaW5cblx0XHRjb25zdCB4ID0gb2JqW2tleV07XG5cdFx0cmV0W2tleV0gPSB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyAmJiBmaWx0ZXIoa2V5KSA/IHByb2Nlc3NGbih4LCBvcHRzKSA6IHg7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVCbG9ja0NhY2hlTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IGxvZ2dpbmdfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmctdXRpbHNcIik7XG5jb25zdCBjYWNoZV8xID0gcmVxdWlyZShcIi4vdXRpbHMvY2FjaGVcIik7XG5jb25zdCBsb2cgPSBsb2dnaW5nX3V0aWxzXzEuY3JlYXRlTW9kdWxlTG9nZ2VyKGxvZ2dpbmdfdXRpbHNfMS5wcm9qZWN0TG9nZ2VyLCAnYmxvY2stY2FjaGUnKTtcbi8vIGA8bmlsPmAgY29tZXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzE2OTI1XG5jb25zdCBlbXB0eVZhbHVlcyA9IFt1bmRlZmluZWQsIG51bGwsICdcXHUwMDNjbmlsXFx1MDAzZSddO1xuLy9cbi8vIENhY2hlIFN0cmF0ZWdpZXNcbi8vXG5jbGFzcyBCbG9ja0NhY2hlU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgfVxuICAgIGdldEJsb2NrQ2FjaGUoYmxvY2tOdW1iZXJIZXgpIHtcbiAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQoYmxvY2tOdW1iZXJIZXgsIDE2KTtcbiAgICAgICAgbGV0IGJsb2NrQ2FjaGUgPSB0aGlzLmNhY2hlW2Jsb2NrTnVtYmVyXTtcbiAgICAgICAgLy8gY3JlYXRlIG5ldyBjYWNoZSBpZiBuZWNlc2FyeVxuICAgICAgICBpZiAoIWJsb2NrQ2FjaGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NhY2hlID0ge307XG4gICAgICAgICAgICB0aGlzLmNhY2hlW2Jsb2NrTnVtYmVyXSA9IG5ld0NhY2hlO1xuICAgICAgICAgICAgYmxvY2tDYWNoZSA9IG5ld0NhY2hlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9ja0NhY2hlO1xuICAgIH1cbiAgICBhc3luYyBnZXQocmVxdWVzdCwgcmVxdWVzdGVkQmxvY2tOdW1iZXIpIHtcbiAgICAgICAgLy8gbG9va3VwIGJsb2NrIGNhY2hlXG4gICAgICAgIGNvbnN0IGJsb2NrQ2FjaGUgPSB0aGlzLmdldEJsb2NrQ2FjaGUocmVxdWVzdGVkQmxvY2tOdW1iZXIpO1xuICAgICAgICAvLyBsb29rdXAgcGF5bG9hZCBpbiBibG9jayBjYWNoZVxuICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gY2FjaGVfMS5jYWNoZUlkZW50aWZpZXJGb3JSZXF1ZXN0KHJlcXVlc3QsIHRydWUpO1xuICAgICAgICByZXR1cm4gaWRlbnRpZmllciA/IGJsb2NrQ2FjaGVbaWRlbnRpZmllcl0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGFzeW5jIHNldChyZXF1ZXN0LCByZXF1ZXN0ZWRCbG9ja051bWJlciwgcmVzdWx0KSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIGNhbiBjYWNoZWQgdGhpcyByZXN1bHRcbiAgICAgICAgY29uc3QgY2FuQ2FjaGVSZXN1bHQgPSB0aGlzLmNhbkNhY2hlUmVzdWx0KHJlcXVlc3QsIHJlc3VsdCk7XG4gICAgICAgIGlmICghY2FuQ2FjaGVSZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgdGhlIHZhbHVlIGluIHRoZSBjYWNoZVxuICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gY2FjaGVfMS5jYWNoZUlkZW50aWZpZXJGb3JSZXF1ZXN0KHJlcXVlc3QsIHRydWUpO1xuICAgICAgICBpZiAoIWlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9ja0NhY2hlID0gdGhpcy5nZXRCbG9ja0NhY2hlKHJlcXVlc3RlZEJsb2NrTnVtYmVyKTtcbiAgICAgICAgYmxvY2tDYWNoZVtpZGVudGlmaWVyXSA9IHJlc3VsdDtcbiAgICB9XG4gICAgY2FuQ2FjaGVSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgICAgLy8gY2hlY2sgcmVxdWVzdCBtZXRob2RcbiAgICAgICAgaWYgKCFjYWNoZV8xLmNhbkNhY2hlKHJlcXVlc3QubWV0aG9kKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGJsb2NrVGFnXG4gICAgICAgIGNvbnN0IGJsb2NrVGFnID0gY2FjaGVfMS5ibG9ja1RhZ0ZvclJlcXVlc3QocmVxdWVzdCk7XG4gICAgICAgIGlmIChibG9ja1RhZyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FuIGJlIGNhY2hlZFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2FuQ2FjaGVSZXN1bHQocmVxdWVzdCwgcmVzdWx0KSB7XG4gICAgICAgIC8vIG5ldmVyIGNhY2hlIGVtcHR5IHZhbHVlcyAoZS5nLiB1bmRlZmluZWQpXG4gICAgICAgIGlmIChlbXB0eVZhbHVlcy5pbmNsdWRlcyhyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgdHJhbnNhY3Rpb25zIGhhdmUgYmxvY2sgcmVmZXJlbmNlIGJlZm9yZSBjYWNoaW5nXG4gICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAmJlxuICAgICAgICAgICAgWydldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2gnLCAnZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdCddLmluY2x1ZGVzKHJlcXVlc3QubWV0aG9kKSkge1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQgfHxcbiAgICAgICAgICAgICAgICAhcmVzdWx0LmJsb2NrSGFzaCB8fFxuICAgICAgICAgICAgICAgIHJlc3VsdC5ibG9ja0hhc2ggPT09XG4gICAgICAgICAgICAgICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSB0cnVlXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyByZW1vdmVzIGFsbCBibG9jayBjYWNoZXMgd2l0aCBibG9jayBudW1iZXIgbG93ZXIgdGhhbiBgb2xkQmxvY2tIZXhgXG4gICAgY2xlYXJCZWZvcmUob2xkQmxvY2tIZXgpIHtcbiAgICAgICAgY29uc3Qgb2xkQmxvY2tOdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQob2xkQmxvY2tIZXgsIDE2KTtcbiAgICAgICAgLy8gY2xlYXIgb2xkIGNhY2hlc1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmNhY2hlKVxuICAgICAgICAgICAgLm1hcChOdW1iZXIpXG4gICAgICAgICAgICAuZmlsdGVyKChudW0pID0+IG51bSA8IG9sZEJsb2NrTnVtYmVyKVxuICAgICAgICAgICAgLmZvckVhY2goKG51bSkgPT4gZGVsZXRlIHRoaXMuY2FjaGVbbnVtXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQmxvY2tDYWNoZU1pZGRsZXdhcmUoeyBibG9ja1RyYWNrZXIsIH0gPSB7fSkge1xuICAgIC8vIHZhbGlkYXRlIG9wdGlvbnNcbiAgICBpZiAoIWJsb2NrVHJhY2tlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZUJsb2NrQ2FjaGVNaWRkbGV3YXJlIC0gTm8gUG9sbGluZ0Jsb2NrVHJhY2tlciBzcGVjaWZpZWQnKTtcbiAgICB9XG4gICAgLy8gY3JlYXRlIGNhY2hpbmcgc3RyYXRlZ2llc1xuICAgIGNvbnN0IGJsb2NrQ2FjaGUgPSBuZXcgQmxvY2tDYWNoZVN0cmF0ZWd5KCk7XG4gICAgY29uc3Qgc3RyYXRlZ2llcyA9IHtcbiAgICAgICAgW2NhY2hlXzEuQ2FjaGVTdHJhdGVneS5QZXJtYW5lbnRdOiBibG9ja0NhY2hlLFxuICAgICAgICBbY2FjaGVfMS5DYWNoZVN0cmF0ZWd5LkJsb2NrXTogYmxvY2tDYWNoZSxcbiAgICAgICAgW2NhY2hlXzEuQ2FjaGVTdHJhdGVneS5Gb3JrXTogYmxvY2tDYWNoZSxcbiAgICAgICAgW2NhY2hlXzEuQ2FjaGVTdHJhdGVneS5OZXZlcl06IHVuZGVmaW5lZCxcbiAgICB9O1xuICAgIHJldHVybiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmMgKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgICAgIC8vIGFsbG93IGNhY2ggdG8gYmUgc2tpcHBlZCBpZiBzbyBzcGVjaWZpZWRcbiAgICAgICAgaWYgKHJlcS5za2lwQ2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgdHlwZSBhbmQgbWF0Y2hpbmcgc3RyYXRlZ3lcbiAgICAgICAgY29uc3QgdHlwZSA9IGNhY2hlXzEuY2FjaGVUeXBlRm9yTWV0aG9kKHJlcS5tZXRob2QpO1xuICAgICAgICBjb25zdCBzdHJhdGVneSA9IHN0cmF0ZWdpZXNbdHlwZV07XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gc3RyYXRlZ3kgaW4gcGxhY2UsIHBhc3MgaXQgZG93biB0aGUgY2hhaW4uXG4gICAgICAgIGlmICghc3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHN0cmF0ZWd5IGNhbid0IGNhY2hlIHRoaXMgcmVxdWVzdCwgaWdub3JlIGl0LlxuICAgICAgICBpZiAoIXN0cmF0ZWd5LmNhbkNhY2hlUmVxdWVzdChyZXEpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBibG9jayByZWZlcmVuY2UgKG51bWJlciBvciBrZXl3b3JkKVxuICAgICAgICBjb25zdCByZXF1ZXN0QmxvY2tUYWcgPSBjYWNoZV8xLmJsb2NrVGFnRm9yUmVxdWVzdChyZXEpO1xuICAgICAgICBjb25zdCBibG9ja1RhZyA9IHJlcXVlc3RCbG9ja1RhZyAmJiB0eXBlb2YgcmVxdWVzdEJsb2NrVGFnID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyByZXF1ZXN0QmxvY2tUYWdcbiAgICAgICAgICAgIDogJ2xhdGVzdCc7XG4gICAgICAgIGxvZygnYmxvY2tUYWcgPSAlbywgcmVxID0gJW8nLCBibG9ja1RhZywgcmVxKTtcbiAgICAgICAgLy8gZ2V0IGV4YWN0IGJsb2NrIG51bWJlclxuICAgICAgICBsZXQgcmVxdWVzdGVkQmxvY2tOdW1iZXI7XG4gICAgICAgIGlmIChibG9ja1RhZyA9PT0gJ2VhcmxpZXN0Jykge1xuICAgICAgICAgICAgLy8gdGhpcyBqdXN0IGV4aXN0cyBmb3Igc3ltbWV0cnkgd2l0aCBcImxhdGVzdFwiXG4gICAgICAgICAgICByZXF1ZXN0ZWRCbG9ja051bWJlciA9ICcweDAwJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChibG9ja1RhZyA9PT0gJ2xhdGVzdCcpIHtcbiAgICAgICAgICAgIC8vIGZldGNoIGxhdGVzdCBibG9jayBudW1iZXJcbiAgICAgICAgICAgIGxvZygnRmV0Y2hpbmcgbGF0ZXN0IGJsb2NrIG51bWJlciB0byBkZXRlcm1pbmUgY2FjaGUga2V5Jyk7XG4gICAgICAgICAgICBjb25zdCBsYXRlc3RCbG9ja051bWJlciA9IGF3YWl0IGJsb2NrVHJhY2tlci5nZXRMYXRlc3RCbG9jaygpO1xuICAgICAgICAgICAgLy8gY2xlYXIgYWxsIGNhY2hlIGJlZm9yZSBsYXRlc3QgYmxvY2tcbiAgICAgICAgICAgIGxvZygnQ2xlYXJpbmcgdmFsdWVzIHN0b3JlZCB1bmRlciBibG9jayBudW1iZXJzIGJlZm9yZSAlbycsIGxhdGVzdEJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIGJsb2NrQ2FjaGUuY2xlYXJCZWZvcmUobGF0ZXN0QmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgcmVxdWVzdGVkQmxvY2tOdW1iZXIgPSBsYXRlc3RCbG9ja051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBoZXggbnVtYmVyXG4gICAgICAgICAgICByZXF1ZXN0ZWRCbG9ja051bWJlciA9IGJsb2NrVGFnO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuZCBvbiBhIGhpdCwgY29udGludWUgb24gYSBtaXNzXG4gICAgICAgIGNvbnN0IGNhY2hlUmVzdWx0ID0gYXdhaXQgc3RyYXRlZ3kuZ2V0KHJlcSwgcmVxdWVzdGVkQmxvY2tOdW1iZXIpO1xuICAgICAgICBpZiAoY2FjaGVSZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gY2FjaGUgbWlzc1xuICAgICAgICAgICAgLy8gd2FpdCBmb3Igb3RoZXIgbWlkZGxld2FyZSB0byBoYW5kbGUgcmVxdWVzdFxuICAgICAgICAgICAgbG9nKCdObyBjYWNoZSBzdG9yZWQgdW5kZXIgYmxvY2sgbnVtYmVyICVvLCBjYXJyeWluZyByZXF1ZXN0IGZvcndhcmQnLCByZXF1ZXN0ZWRCbG9ja051bWJlcik7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9jYWxsYmFjay1yZXR1cm5cbiAgICAgICAgICAgIGF3YWl0IG5leHQoKTtcbiAgICAgICAgICAgIC8vIGFkZCByZXN1bHQgdG8gY2FjaGVcbiAgICAgICAgICAgIC8vIGl0J3Mgc2FmZSB0byBjYXN0IHJlcy5yZXN1bHQgYXMgQmxvY2ssIGR1ZSB0byBydW50aW1lIHR5cGUgY2hlY2tzXG4gICAgICAgICAgICAvLyBwZXJmb3JtZWQgd2hlbiBzdHJhdGVneS5zZXQgaXMgY2FsbGVkXG4gICAgICAgICAgICBsb2coJ1BvcHVsYXRpbmcgY2FjaGUgd2l0aCcsIHJlcyk7XG4gICAgICAgICAgICBhd2FpdCBzdHJhdGVneS5zZXQocmVxLCByZXF1ZXN0ZWRCbG9ja051bWJlciwgcmVzLnJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBmaWxsIGluIHJlc3VsdCBmcm9tIGNhY2hlXG4gICAgICAgICAgICBsb2coJ0NhY2hlIGhpdCwgcmV1c2luZyBjYWNoZSByZXN1bHQgc3RvcmVkIHVuZGVyIGJsb2NrIG51bWJlciAlbycsIHJlcXVlc3RlZEJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIHJlcy5yZXN1bHQgPSBjYWNoZVJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVCbG9ja0NhY2hlTWlkZGxld2FyZSA9IGNyZWF0ZUJsb2NrQ2FjaGVNaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvY2stY2FjaGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUJsb2NrUmVmUmV3cml0ZU1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBjYWNoZV8xID0gcmVxdWlyZShcIi4vdXRpbHMvY2FjaGVcIik7XG5mdW5jdGlvbiBjcmVhdGVCbG9ja1JlZlJld3JpdGVNaWRkbGV3YXJlKHsgYmxvY2tUcmFja2VyLCB9ID0ge30pIHtcbiAgICBpZiAoIWJsb2NrVHJhY2tlcikge1xuICAgICAgICB0aHJvdyBFcnJvcignQmxvY2tSZWZSZXdyaXRlTWlkZGxld2FyZSAtIG1hbmRhdG9yeSBcImJsb2NrVHJhY2tlclwiIG9wdGlvbiBpcyBtaXNzaW5nLicpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXEsIF9yZXMsIG5leHQpID0+IHtcbiAgICAgICAgY29uc3QgYmxvY2tSZWZJbmRleCA9IGNhY2hlXzEuYmxvY2tUYWdQYXJhbUluZGV4KHJlcS5tZXRob2QpO1xuICAgICAgICAvLyBza2lwIGlmIG1ldGhvZCBkb2VzIG5vdCBpbmNsdWRlIGJsb2NrUmVmXG4gICAgICAgIGlmIChibG9ja1JlZkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2tpcCBpZiBub3QgXCJsYXRlc3RcIlxuICAgICAgICBsZXQgYmxvY2tSZWYgPSBBcnJheS5pc0FycmF5KHJlcS5wYXJhbXMpXG4gICAgICAgICAgICA/IHJlcS5wYXJhbXNbYmxvY2tSZWZJbmRleF1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBvbWl0dGVkIGJsb2NrUmVmIGltcGxpZXMgXCJsYXRlc3RcIlxuICAgICAgICBpZiAoYmxvY2tSZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYmxvY2tSZWYgPSAnbGF0ZXN0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2tSZWYgIT09ICdsYXRlc3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJld3JpdGUgYmxvY2tSZWYgdG8gYmxvY2stdHJhY2tlcidzIGJsb2NrIG51bWJlclxuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja051bWJlciA9IGF3YWl0IGJsb2NrVHJhY2tlci5nZXRMYXRlc3RCbG9jaygpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXEucGFyYW1zKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXRvbWljLXVwZGF0ZXNcbiAgICAgICAgICAgIHJlcS5wYXJhbXNbYmxvY2tSZWZJbmRleF0gPSBsYXRlc3RCbG9ja051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVCbG9ja1JlZlJld3JpdGVNaWRkbGV3YXJlID0gY3JlYXRlQmxvY2tSZWZSZXdyaXRlTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsb2NrLXJlZi1yZXdyaXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVCbG9ja1JlZk1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBjbG9uZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjbG9uZVwiKSk7XG5jb25zdCBwaWZ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInBpZnlcIikpO1xuY29uc3QgbG9nZ2luZ191dGlsc18xID0gcmVxdWlyZShcIi4vbG9nZ2luZy11dGlsc1wiKTtcbmNvbnN0IGNhY2hlXzEgPSByZXF1aXJlKFwiLi91dGlscy9jYWNoZVwiKTtcbmNvbnN0IGxvZyA9IGxvZ2dpbmdfdXRpbHNfMS5jcmVhdGVNb2R1bGVMb2dnZXIobG9nZ2luZ191dGlsc18xLnByb2plY3RMb2dnZXIsICdibG9jay1yZWYnKTtcbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrUmVmTWlkZGxld2FyZSh7IHByb3ZpZGVyLCBibG9ja1RyYWNrZXIsIH0gPSB7fSkge1xuICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0Jsb2NrUmVmTWlkZGxld2FyZSAtIG1hbmRhdG9yeSBcInByb3ZpZGVyXCIgb3B0aW9uIGlzIG1pc3NpbmcuJyk7XG4gICAgfVxuICAgIGlmICghYmxvY2tUcmFja2VyKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdCbG9ja1JlZk1pZGRsZXdhcmUgLSBtYW5kYXRvcnkgXCJibG9ja1RyYWNrZXJcIiBvcHRpb24gaXMgbWlzc2luZy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBibG9ja1JlZkluZGV4ID0gY2FjaGVfMS5ibG9ja1RhZ1BhcmFtSW5kZXgocmVxLm1ldGhvZCk7XG4gICAgICAgIC8vIHNraXAgaWYgbWV0aG9kIGRvZXMgbm90IGluY2x1ZGUgYmxvY2tSZWZcbiAgICAgICAgaWYgKGJsb2NrUmVmSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9ja1JlZiA9IEFycmF5LmlzQXJyYXkocmVxLnBhcmFtcylcbiAgICAgICAgICAgID8gKF9hID0gcmVxLnBhcmFtc1tibG9ja1JlZkluZGV4XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2xhdGVzdCdcbiAgICAgICAgICAgIDogJ2xhdGVzdCc7XG4gICAgICAgIC8vIHNraXAgaWYgbm90IFwibGF0ZXN0XCJcbiAgICAgICAgaWYgKGJsb2NrUmVmICE9PSAnbGF0ZXN0Jykge1xuICAgICAgICAgICAgbG9nKCdibG9ja1JlZiBpcyBub3QgXCJsYXRlc3RcIiwgY2FycnlpbmcgcmVxdWVzdCBmb3J3YXJkJyk7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb2t1cCBsYXRlc3QgYmxvY2tcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2tOdW1iZXIgPSBhd2FpdCBibG9ja1RyYWNrZXIuZ2V0TGF0ZXN0QmxvY2soKTtcbiAgICAgICAgbG9nKGBibG9ja1JlZiBpcyBcImxhdGVzdFwiLCBzZXR0aW5nIHBhcmFtICR7YmxvY2tSZWZJbmRleH0gdG8gbGF0ZXN0IGJsb2NrICR7bGF0ZXN0QmxvY2tOdW1iZXJ9YCk7XG4gICAgICAgIC8vIGNyZWF0ZSBjaGlsZCByZXF1ZXN0IHdpdGggc3BlY2lmaWMgYmxvY2stcmVmXG4gICAgICAgIGNvbnN0IGNoaWxkUmVxdWVzdCA9IGNsb25lXzEuZGVmYXVsdChyZXEpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZFJlcXVlc3QucGFyYW1zKSkge1xuICAgICAgICAgICAgY2hpbGRSZXF1ZXN0LnBhcmFtc1tibG9ja1JlZkluZGV4XSA9IGxhdGVzdEJsb2NrTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBlcmZvcm0gY2hpbGQgcmVxdWVzdFxuICAgICAgICBsb2coJ1BlcmZvcm1pbmcgYW5vdGhlciByZXF1ZXN0ICVvJywgY2hpbGRSZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgY2hpbGRSZXMgPSBhd2FpdCBwaWZ5XzEuZGVmYXVsdChwcm92aWRlci5zZW5kQXN5bmMpLmNhbGwocHJvdmlkZXIsIGNoaWxkUmVxdWVzdCk7XG4gICAgICAgIC8vIGNvcHkgY2hpbGQgcmVzcG9uc2Ugb250byBvcmlnaW5hbCByZXNwb25zZVxuICAgICAgICByZXMucmVzdWx0ID0gY2hpbGRSZXMucmVzdWx0O1xuICAgICAgICByZXMuZXJyb3IgPSBjaGlsZFJlcy5lcnJvcjtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlQmxvY2tSZWZNaWRkbGV3YXJlID0gY3JlYXRlQmxvY2tSZWZNaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvY2stcmVmLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVCbG9ja1RyYWNrZXJJbnNwZWN0b3JNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgbG9nZ2luZ191dGlsc18xID0gcmVxdWlyZShcIi4vbG9nZ2luZy11dGlsc1wiKTtcbmNvbnN0IGxvZyA9IGxvZ2dpbmdfdXRpbHNfMS5jcmVhdGVNb2R1bGVMb2dnZXIobG9nZ2luZ191dGlsc18xLnByb2plY3RMb2dnZXIsICdibG9jay10cmFja2VyLWluc3BlY3RvcicpO1xuY29uc3QgZnV0dXJlQmxvY2tSZWZSZXF1ZXN0cyA9IFtcbiAgICAnZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJyxcbiAgICAnZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdCcsXG5dO1xuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBoYXMgdGhlIGdpdmVuIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBvYmplY3RUb0NoZWNrIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEBwYXJhbSBwcm9wZXJ0eSAtIFRoZSBwcm9wZXJ0eSB0byBsb29rIGZvci5cbiAqIEByZXR1cm5zIC0gV2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGhhc1Byb3BlcnR5KG9iamVjdFRvQ2hlY2ssIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdFRvQ2hlY2ssIHByb3BlcnR5KTtcbn1cbmZ1bmN0aW9uIGdldFJlc3VsdEJsb2NrTnVtYmVyKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlc3BvbnNlO1xuICAgIGlmICghcmVzdWx0IHx8XG4gICAgICAgIHR5cGVvZiByZXN1bHQgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICFoYXNQcm9wZXJ0eShyZXN1bHQsICdibG9ja051bWJlcicpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzdWx0LmJsb2NrTnVtYmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmJsb2NrTnVtYmVyO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLy8gaW5zcGVjdCBpZiByZXNwb25zZSBjb250YWlucyBhIGJsb2NrIHJlZiBoaWdoZXIgdGhhbiBvdXIgbGF0ZXN0IGJsb2NrXG5mdW5jdGlvbiBjcmVhdGVCbG9ja1RyYWNrZXJJbnNwZWN0b3JNaWRkbGV3YXJlKHsgYmxvY2tUcmFja2VyLCB9KSB7XG4gICAgcmV0dXJuIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAgICAgaWYgKCFmdXR1cmVCbG9ja1JlZlJlcXVlc3RzLmluY2x1ZGVzKHJlcS5tZXRob2QpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL2NhbGxiYWNrLXJldHVyblxuICAgICAgICBhd2FpdCBuZXh0KCk7XG4gICAgICAgIC8vIGFib3J0IGlmIG5vIHJlc3VsdCBvciBubyBibG9jayBudW1iZXJcbiAgICAgICAgY29uc3QgcmVzcG9uc2VCbG9ja051bWJlciA9IGdldFJlc3VsdEJsb2NrTnVtYmVyKHJlcyk7XG4gICAgICAgIGlmICghcmVzcG9uc2VCbG9ja051bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsb2coJ3Jlcy5yZXN1bHQuYmxvY2tOdW1iZXIgZXhpc3RzLCBwcm9jZWVkaW5nLiByZXMgPSAlbycsIHJlcyk7XG4gICAgICAgIC8vIGlmIG51bWJlciBpcyBoaWdoZXIsIHN1Z2dlc3QgYmxvY2stdHJhY2tlciBjaGVjayBmb3IgYSBuZXcgYmxvY2tcbiAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQocmVzcG9uc2VCbG9ja051bWJlciwgMTYpO1xuICAgICAgICAvLyBUeXBlY2FzdDogSWYgZ2V0Q3VycmVudEJsb2NrIHJldHVybnMgbnVsbCwgY3VycmVudEJsb2NrTnVtYmVyIHdpbGwgYmUgTmFOLCB3aGljaCBpcyBmaW5lLlxuICAgICAgICBjb25zdCBjdXJyZW50QmxvY2tOdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQoYmxvY2tUcmFja2VyLmdldEN1cnJlbnRCbG9jaygpLCAxNik7XG4gICAgICAgIGlmIChibG9ja051bWJlciA+IGN1cnJlbnRCbG9ja051bWJlcikge1xuICAgICAgICAgICAgbG9nKCdibG9ja051bWJlciBmcm9tIHJlc3BvbnNlIGlzIGdyZWF0ZXIgdGhhbiBjdXJyZW50IGJsb2NrIG51bWJlciwgcmVmcmVzaGluZyBjdXJyZW50IGJsb2NrIG51bWJlcicpO1xuICAgICAgICAgICAgYXdhaXQgYmxvY2tUcmFja2VyLmNoZWNrRm9yTGF0ZXN0QmxvY2soKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVCbG9ja1RyYWNrZXJJbnNwZWN0b3JNaWRkbGV3YXJlID0gY3JlYXRlQmxvY2tUcmFja2VySW5zcGVjdG9yTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsb2NrLXRyYWNrZXItaW5zcGVjdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVGZXRjaENvbmZpZ0Zyb21SZXEgPSBleHBvcnRzLmNyZWF0ZUZldGNoTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG5jb25zdCB0aW1lb3V0XzEgPSByZXF1aXJlKFwiLi91dGlscy90aW1lb3V0XCIpO1xuY29uc3QgUkVUUklBQkxFX0VSUk9SUyA9IFtcbiAgICAvLyBpZ25vcmUgc2VydmVyIG92ZXJsb2FkIGVycm9yc1xuICAgICdHYXRld2F5IHRpbWVvdXQnLFxuICAgICdFVElNRURPVVQnLFxuICAgIC8vIGlnbm9yZSBzZXJ2ZXIgc2VudCBodG1sIGVycm9yIHBhZ2VzXG4gICAgLy8gb3IgdHJ1bmNhdGVkIGpzb24gcmVzcG9uc2VzXG4gICAgJ2ZhaWxlZCB0byBwYXJzZSByZXNwb25zZSBib2R5JyxcbiAgICAvLyBpZ25vcmUgZXJyb3JzIHdoZXJlIGh0dHAgcmVxIGZhaWxlZCB0byBlc3RhYmxpc2hcbiAgICAnRmFpbGVkIHRvIGZldGNoJyxcbl07XG4vKipcbiAqIENyZWF0ZSBtaWRkbGV3YXJlIGZvciBzZW5kaW5nIGEgSlNPTi1SUEMgcmVxdWVzdCB0byB0aGUgZ2l2ZW4gUlBDIFVSTC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnNcbiAqIEBwYXJhbSBvcHRpb25zLmJ0b2EgLSBHZW5lcmF0ZXMgYSBiYXNlNjQtZW5jb2RlZCBzdHJpbmcgZnJvbSBhIGJpbmFyeSBzdHJpbmcuXG4gKiBAcGFyYW0gb3B0aW9ucy5mZXRjaCAtIFRoZSBgZmV0Y2hgIGZ1bmN0aW9uOyBleHBlY3RlZCB0byBiZSBlcXVpdmFsZW50IHRvIGB3aW5kb3cuZmV0Y2hgLlxuICogQHBhcmFtIG9wdGlvbnMucnBjVXJsIC0gVGhlIFVSTCB0byBzZW5kIHRoZSByZXF1ZXN0IHRvLlxuICogQHBhcmFtIG9wdGlvbnMub3JpZ2luSHR0cEhlYWRlcktleSAtIElmIHByb3ZpZGVyLCB0aGUgb3JpZ2luIGZpZWxkIGZvciBlYWNoIEpTT04tUlBDIHJlcXVlc3RcbiAqIHdpbGwgYmUgYXR0YWNoZWQgdG8gZWFjaCBvdXRnb2luZyBmZXRjaCByZXF1ZXN0IHVuZGVyIHRoaXMgaGVhZGVyLlxuICogQHJldHVybnMgVGhlIGZldGNoIG1pZGRsZXdhcmUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZldGNoTWlkZGxld2FyZSh7IFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1zaGFkb3dcbmJ0b2EsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1zaGFkb3dcbmZldGNoLCBycGNVcmwsIG9yaWdpbkh0dHBIZWFkZXJLZXksIH0pIHtcbiAgICByZXR1cm4ganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXEsIHJlcywgX25leHQpID0+IHtcbiAgICAgICAgY29uc3QgeyBmZXRjaFVybCwgZmV0Y2hQYXJhbXMgfSA9IGNyZWF0ZUZldGNoQ29uZmlnRnJvbVJlcSh7XG4gICAgICAgICAgICBidG9hLFxuICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgcnBjVXJsLFxuICAgICAgICAgICAgb3JpZ2luSHR0cEhlYWRlcktleSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGF0dGVtcHQgcmVxdWVzdCBtdWx0aXBsZSB0aW1lc1xuICAgICAgICBjb25zdCBtYXhBdHRlbXB0cyA9IDU7XG4gICAgICAgIGNvbnN0IHJldHJ5SW50ZXJ2YWwgPSAxMDAwO1xuICAgICAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IG1heEF0dGVtcHRzOyBhdHRlbXB0KyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmV0Y2hSZXMgPSBhd2FpdCBmZXRjaChmZXRjaFVybCwgZmV0Y2hQYXJhbXMpO1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBodHRwIGVycnJvcnNcbiAgICAgICAgICAgICAgICBjaGVja0Zvckh0dHBFcnJvcnMoZmV0Y2hSZXMpO1xuICAgICAgICAgICAgICAgIC8vIHBhcnNlIHJlc3BvbnNlIGJvZHlcbiAgICAgICAgICAgICAgICBjb25zdCByYXdCb2R5ID0gYXdhaXQgZmV0Y2hSZXMudGV4dCgpO1xuICAgICAgICAgICAgICAgIGxldCBmZXRjaEJvZHk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hCb2R5ID0gSlNPTi5wYXJzZShyYXdCb2R5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGZXRjaE1pZGRsZXdhcmUgLSBmYWlsZWQgdG8gcGFyc2UgcmVzcG9uc2UgYm9keTogXCIke3Jhd0JvZHl9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VSZXNwb25zZShmZXRjaFJlcywgZmV0Y2hCb2R5KTtcbiAgICAgICAgICAgICAgICAvLyBzZXQgcmVzdWx0IGFuZCBleGl0IHJldHJ5IGxvb3BcbiAgICAgICAgICAgICAgICByZXMucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSBlcnIudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JldHJpYWJsZSA9IFJFVFJJQUJMRV9FUlJPUlMuc29tZSgocGhyYXNlKSA9PiBlcnJNc2cuaW5jbHVkZXMocGhyYXNlKSk7XG4gICAgICAgICAgICAgICAgLy8gcmUtdGhyb3cgZXJyb3IgaWYgbm90IHJldHJpYWJsZVxuICAgICAgICAgICAgICAgIGlmICghaXNSZXRyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRlbGF5IGJlZm9yZSByZXRyeWluZ1xuICAgICAgICAgICAgYXdhaXQgdGltZW91dF8xLnRpbWVvdXQocmV0cnlJbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlRmV0Y2hNaWRkbGV3YXJlID0gY3JlYXRlRmV0Y2hNaWRkbGV3YXJlO1xuZnVuY3Rpb24gY2hlY2tGb3JIdHRwRXJyb3JzKGZldGNoUmVzKSB7XG4gICAgLy8gY2hlY2sgZm9yIGVycm9yc1xuICAgIHN3aXRjaCAoZmV0Y2hSZXMuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgNDA1OlxuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdEZvdW5kKCk7XG4gICAgICAgIGNhc2UgNDE4OlxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlUmF0ZWxpbWl0RXJyb3IoKTtcbiAgICAgICAgY2FzZSA1MDM6XG4gICAgICAgIGNhc2UgNTA0OlxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlVGltZW91dEVycm9yKCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZVJlc3BvbnNlKGZldGNoUmVzLCBib2R5KSB7XG4gICAgLy8gY2hlY2sgZm9yIGVycm9yIGNvZGVcbiAgICBpZiAoZmV0Y2hSZXMuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludGVybmFsKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBOb24tMjAwIHN0YXR1cyBjb2RlOiAnJHtmZXRjaFJlcy5zdGF0dXN9J2AsXG4gICAgICAgICAgICBkYXRhOiBib2R5LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZm9yIHJwYyBlcnJvclxuICAgIGlmIChib2R5LmVycm9yKSB7XG4gICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbCh7XG4gICAgICAgICAgICBkYXRhOiBib2R5LmVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIHN1Y2Nlc3NmdWwgcmVzdWx0XG4gICAgcmV0dXJuIGJvZHkucmVzdWx0O1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBgZmV0Y2hgIGNvbmZpZ3VyYXRpb24gZm9yIHNlbmRpbmcgdGhlIGdpdmVuIHJlcXVlc3QgdG8gYW4gUlBDIEFQSS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnNcbiAqIEBwYXJhbSBvcHRpb25zLmJ0b2EgLSBHZW5lcmF0ZXMgYSBiYXNlNjQtZW5jb2RlZCBzdHJpbmcgZnJvbSBhIGJpbmFyeSBzdHJpbmcuXG4gKiBAcGFyYW0gb3B0aW9ucy5ycGNVcmwgLSBUaGUgVVJMIHRvIHNlbmQgdGhlIHJlcXVlc3QgdG8uXG4gKiBAcGFyYW0gb3B0aW9ucy5vcmlnaW5IdHRwSGVhZGVyS2V5IC0gSWYgcHJvdmlkZXIsIHRoZSBvcmlnaW4gZmllbGQgZm9yIGVhY2ggSlNPTi1SUEMgcmVxdWVzdFxuICogd2lsbCBiZSBhdHRhY2hlZCB0byBlYWNoIG91dGdvaW5nIGZldGNoIHJlcXVlc3QgdW5kZXIgdGhpcyBoZWFkZXIuXG4gKiBAcmV0dXJucyBUaGUgZmV0Y2ggbWlkZGxld2FyZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxKHsgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuYnRvYSwgcmVxLCBycGNVcmwsIG9yaWdpbkh0dHBIZWFkZXJLZXksIH0pIHtcbiAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHJwY1VybCk7XG4gICAgY29uc3QgZmV0Y2hVcmwgPSBub3JtYWxpemVVcmxGcm9tUGFyc2VkKHBhcnNlZFVybCk7XG4gICAgLy8gcHJlcGFyZSBwYXlsb2FkXG4gICAgLy8gY29weSBvbmx5IGNhbm9uaWNhbCBqc29uIHJwYyBwcm9wZXJ0aWVzXG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgaWQ6IHJlcS5pZCxcbiAgICAgICAganNvbnJwYzogcmVxLmpzb25ycGMsXG4gICAgICAgIG1ldGhvZDogcmVxLm1ldGhvZCxcbiAgICAgICAgcGFyYW1zOiByZXEucGFyYW1zLFxuICAgIH07XG4gICAgLy8gZXh0cmFjdCAnb3JpZ2luJyBwYXJhbWV0ZXIgZnJvbSByZXF1ZXN0XG4gICAgY29uc3Qgb3JpZ2luRG9tYWluID0gcmVxLm9yaWdpbjtcbiAgICAvLyBzZXJpYWxpemUgcmVxdWVzdCBib2R5XG4gICAgY29uc3Qgc2VyaWFsaXplZFBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgICAvLyBjb25maWd1cmUgZmV0Y2ggcGFyYW1zXG4gICAgY29uc3QgZmV0Y2hQYXJhbXMgPSB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IHNlcmlhbGl6ZWRQYXlsb2FkLFxuICAgIH07XG4gICAgLy8gZW5jb2RlZCBhdXRoIGRldGFpbHMgYXMgaGVhZGVyIChub3QgYWxsb3dlZCBpbiBmZXRjaCB1cmwpXG4gICAgaWYgKHBhcnNlZFVybC51c2VybmFtZSAmJiBwYXJzZWRVcmwucGFzc3dvcmQpIHtcbiAgICAgICAgY29uc3QgYXV0aFN0cmluZyA9IGAke3BhcnNlZFVybC51c2VybmFtZX06JHtwYXJzZWRVcmwucGFzc3dvcmR9YDtcbiAgICAgICAgY29uc3QgZW5jb2RlZEF1dGggPSBidG9hKGF1dGhTdHJpbmcpO1xuICAgICAgICBmZXRjaFBhcmFtcy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmFzaWMgJHtlbmNvZGVkQXV0aH1gO1xuICAgIH1cbiAgICAvLyBvcHRpb25hbDogYWRkIHJlcXVlc3Qgb3JpZ2luIGFzIGhlYWRlclxuICAgIGlmIChvcmlnaW5IdHRwSGVhZGVyS2V5ICYmIG9yaWdpbkRvbWFpbikge1xuICAgICAgICBmZXRjaFBhcmFtcy5oZWFkZXJzW29yaWdpbkh0dHBIZWFkZXJLZXldID0gb3JpZ2luRG9tYWluO1xuICAgIH1cbiAgICByZXR1cm4geyBmZXRjaFVybCwgZmV0Y2hQYXJhbXMgfTtcbn1cbmV4cG9ydHMuY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxID0gY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxO1xuZnVuY3Rpb24gbm9ybWFsaXplVXJsRnJvbVBhcnNlZChwYXJzZWRVcmwpIHtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgcmVzdWx0ICs9IHBhcnNlZFVybC5wcm90b2NvbDtcbiAgICByZXN1bHQgKz0gYC8vJHtwYXJzZWRVcmwuaG9zdG5hbWV9YDtcbiAgICBpZiAocGFyc2VkVXJsLnBvcnQpIHtcbiAgICAgICAgcmVzdWx0ICs9IGA6JHtwYXJzZWRVcmwucG9ydH1gO1xuICAgIH1cbiAgICByZXN1bHQgKz0gYCR7cGFyc2VkVXJsLnBhdGhuYW1lfWA7XG4gICAgcmVzdWx0ICs9IGAke3BhcnNlZFVybC5zZWFyY2h9YDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlUmF0ZWxpbWl0RXJyb3IoKSB7XG4gICAgcmV0dXJuIGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbCh7IG1lc3NhZ2U6IGBSZXF1ZXN0IGlzIGJlaW5nIHJhdGUgbGltaXRlZC5gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlVGltZW91dEVycm9yKCkge1xuICAgIGxldCBtc2cgPSBgR2F0ZXdheSB0aW1lb3V0LiBUaGUgcmVxdWVzdCB0b29rIHRvbyBsb25nIHRvIHByb2Nlc3MuIGA7XG4gICAgbXNnICs9IGBUaGlzIGNhbiBoYXBwZW4gd2hlbiBxdWVyeWluZyBsb2dzIG92ZXIgdG9vIHdpZGUgYSBibG9jayByYW5nZS5gO1xuICAgIHJldHVybiBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoeyBtZXNzYWdlOiBtc2cgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jsb2NrLWNhY2hlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ibG9jay1yZWYtcmV3cml0ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmxvY2stcmVmXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ibG9jay10cmFja2VyLWluc3BlY3RvclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZmV0Y2hcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2luZmxpZ2h0LWNhY2hlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcm92aWRlckFzTWlkZGxld2FyZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcmV0cnlPbkVtcHR5XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi93YWxsZXRcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUluZmxpZ2h0Q2FjaGVNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QgY2xvbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY2xvbmVcIikpO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgbG9nZ2luZ191dGlsc18xID0gcmVxdWlyZShcIi4vbG9nZ2luZy11dGlsc1wiKTtcbmNvbnN0IGNhY2hlXzEgPSByZXF1aXJlKFwiLi91dGlscy9jYWNoZVwiKTtcbmNvbnN0IGxvZyA9IGxvZ2dpbmdfdXRpbHNfMS5jcmVhdGVNb2R1bGVMb2dnZXIobG9nZ2luZ191dGlsc18xLnByb2plY3RMb2dnZXIsICdpbmZsaWdodC1jYWNoZScpO1xuZnVuY3Rpb24gY3JlYXRlSW5mbGlnaHRDYWNoZU1pZGRsZXdhcmUoKSB7XG4gICAgY29uc3QgaW5mbGlnaHRSZXF1ZXN0cyA9IHt9O1xuICAgIHJldHVybiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmMgKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgICAgIC8vIGFsbG93IGNhY2ggdG8gYmUgc2tpcHBlZCBpZiBzbyBzcGVjaWZpZWRcbiAgICAgICAgaWYgKHJlcS5za2lwQ2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0IGNhY2hlSWQsIGlmIGNhY2hlYWJsZVxuICAgICAgICBjb25zdCBjYWNoZUlkID0gY2FjaGVfMS5jYWNoZUlkZW50aWZpZXJGb3JSZXF1ZXN0KHJlcSk7XG4gICAgICAgIC8vIGlmIG5vdCBjYWNoZWFibGUsIHNraXBcbiAgICAgICAgaWYgKCFjYWNoZUlkKSB7XG4gICAgICAgICAgICBsb2coJ1JlcXVlc3QgaXMgbm90IGNhY2hlYWJsZSwgcHJvY2VlZGluZy4gcmVxID0gJW8nLCByZXEpO1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBmb3IgbWF0Y2hpbmcgcmVxdWVzdHNcbiAgICAgICAgbGV0IGFjdGl2ZVJlcXVlc3RIYW5kbGVycyA9IGluZmxpZ2h0UmVxdWVzdHNbY2FjaGVJZF07XG4gICAgICAgIC8vIGlmIGZvdW5kLCB3YWl0IGZvciB0aGUgYWN0aXZlIHJlcXVlc3QgdG8gYmUgaGFuZGxlZFxuICAgICAgICBpZiAoYWN0aXZlUmVxdWVzdEhhbmRsZXJzKSB7XG4gICAgICAgICAgICAvLyBzZXR1cCB0aGUgcmVzcG9uc2UgbGlzdGVuZXIgYW5kIHdhaXQgZm9yIGl0IHRvIGJlIGNhbGxlZFxuICAgICAgICAgICAgLy8gaXQgd2lsbCBoYW5kbGUgY29weWluZyB0aGUgcmVzdWx0IGFuZCByZXF1ZXN0IGZpZWxkc1xuICAgICAgICAgICAgbG9nKCdSdW5uaW5nICVpIGhhbmRsZXIocykgZm9yIHJlcXVlc3QgJW8nLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMubGVuZ3RoLCByZXEpO1xuICAgICAgICAgICAgYXdhaXQgY3JlYXRlQWN0aXZlUmVxdWVzdEhhbmRsZXIocmVzLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXR1cCByZXNwb25zZSBoYW5kbGVyIGFycmF5IGZvciBzdWJzZXF1ZW50IHJlcXVlc3RzXG4gICAgICAgIGFjdGl2ZVJlcXVlc3RIYW5kbGVycyA9IFtdO1xuICAgICAgICBpbmZsaWdodFJlcXVlc3RzW2NhY2hlSWRdID0gYWN0aXZlUmVxdWVzdEhhbmRsZXJzO1xuICAgICAgICAvLyBhbGxvdyByZXF1ZXN0IHRvIGJlIGhhbmRsZWQgbm9ybWFsbHlcbiAgICAgICAgbG9nKCdDYXJyeWluZyBvcmlnaW5hbCByZXF1ZXN0IGZvcndhcmQgJW8nLCByZXEpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9jYWxsYmFjay1yZXR1cm5cbiAgICAgICAgYXdhaXQgbmV4dCgpO1xuICAgICAgICAvLyBjbGVhciBpbmZsaWdodCByZXF1ZXN0c1xuICAgICAgICBkZWxldGUgaW5mbGlnaHRSZXF1ZXN0c1tjYWNoZUlkXTtcbiAgICAgICAgLy8gc2NoZWR1bGUgYWN0aXZlUmVxdWVzdEhhbmRsZXJzIHRvIGJlIGhhbmRsZWRcbiAgICAgICAgbG9nKCdSdW5uaW5nICVpIGNvbGxlY3RlZCBoYW5kbGVyKHMpIGZvciByZXF1ZXN0ICVvJywgYWN0aXZlUmVxdWVzdEhhbmRsZXJzLmxlbmd0aCwgcmVxKTtcbiAgICAgICAgaGFuZGxlQWN0aXZlUmVxdWVzdChyZXMsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycyk7XG4gICAgICAgIC8vIGNvbXBsZXRlXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gY3JlYXRlQWN0aXZlUmVxdWVzdEhhbmRsZXIocmVzLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlLCBwcm9taXNlIH0gPSBkZWZlcnJlZFByb21pc2UoKTtcbiAgICAgICAgYWN0aXZlUmVxdWVzdEhhbmRsZXJzLnB1c2goKGhhbmRsZWRSZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGFwcGVuZCBhIGNvcHkgb2YgdGhlIHJlc3VsdCBhbmQgZXJyb3IgdG8gdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICByZXMucmVzdWx0ID0gY2xvbmVfMS5kZWZhdWx0KGhhbmRsZWRSZXMucmVzdWx0KTtcbiAgICAgICAgICAgIHJlcy5lcnJvciA9IGNsb25lXzEuZGVmYXVsdChoYW5kbGVkUmVzLmVycm9yKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVBY3RpdmVSZXF1ZXN0KHJlcywgYWN0aXZlUmVxdWVzdEhhbmRsZXJzKSB7XG4gICAgICAgIC8vIHVzZSBzZXRUaW1lb3V0IHNvIHdlIGNhbiByZXNvbHZlIG91ciBvcmlnaW5hbCByZXF1ZXN0IGZpcnN0XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgYWN0aXZlUmVxdWVzdEhhbmRsZXJzLmZvckVhY2goKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKHJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2F0Y2ggZXJyb3Igc28gYWxsIHJlcXVlc3RzIGFyZSBoYW5kbGVkIGNvcnJlY3RseVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlSW5mbGlnaHRDYWNoZU1pZGRsZXdhcmUgPSBjcmVhdGVJbmZsaWdodENhY2hlTWlkZGxld2FyZTtcbmZ1bmN0aW9uIGRlZmVycmVkUHJvbWlzZSgpIHtcbiAgICBsZXQgcmVzb2x2ZTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKF9yZXNvbHZlKSA9PiB7XG4gICAgICAgIHJlc29sdmUgPSBfcmVzb2x2ZTtcbiAgICB9KTtcbiAgICByZXR1cm4geyByZXNvbHZlLCBwcm9taXNlIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZsaWdodC1jYWNoZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlTW9kdWxlTG9nZ2VyID0gZXhwb3J0cy5wcm9qZWN0TG9nZ2VyID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVNb2R1bGVMb2dnZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuY3JlYXRlTW9kdWxlTG9nZ2VyOyB9IH0pO1xuZXhwb3J0cy5wcm9qZWN0TG9nZ2VyID0gdXRpbHNfMS5jcmVhdGVQcm9qZWN0TG9nZ2VyKCdldGgtanNvbi1ycGMtbWlkZGxld2FyZScpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2luZy11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXRoZXJzUHJvdmlkZXJBc01pZGRsZXdhcmUgPSBleHBvcnRzLnByb3ZpZGVyQXNNaWRkbGV3YXJlID0gdm9pZCAwO1xuZnVuY3Rpb24gcHJvdmlkZXJBc01pZGRsZXdhcmUocHJvdmlkZXIpIHtcbiAgICByZXR1cm4gKHJlcSwgcmVzLCBfbmV4dCwgZW5kKSA9PiB7XG4gICAgICAgIC8vIHNlbmQgcmVxdWVzdCB0byBwcm92aWRlclxuICAgICAgICBwcm92aWRlci5zZW5kQXN5bmMocmVxLCAoZXJyLCBwcm92aWRlclJlcykgPT4ge1xuICAgICAgICAgICAgLy8gZm9yd2FyZCBhbnkgZXJyb3JcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmQoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvcHkgcHJvdmlkZXIgcmVzcG9uc2Ugb250byBvcmlnaW5hbCByZXNwb25zZVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXMsIHByb3ZpZGVyUmVzKTtcbiAgICAgICAgICAgIHJldHVybiBlbmQoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmV4cG9ydHMucHJvdmlkZXJBc01pZGRsZXdhcmUgPSBwcm92aWRlckFzTWlkZGxld2FyZTtcbmZ1bmN0aW9uIGV0aGVyc1Byb3ZpZGVyQXNNaWRkbGV3YXJlKHByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIChyZXEsIHJlcywgX25leHQsIGVuZCkgPT4ge1xuICAgICAgICAvLyBzZW5kIHJlcXVlc3QgdG8gcHJvdmlkZXJcbiAgICAgICAgcHJvdmlkZXIuc2VuZChyZXEsIChlcnIsIHByb3ZpZGVyUmVzKSA9PiB7XG4gICAgICAgICAgICAvLyBmb3J3YXJkIGFueSBlcnJvclxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIGNhc3Qgd2hlbiBuZXh0IG1ham9yIGBqc29uLXJwYy1lbmdpbmVgIHJlbGVhc2UgaXMgb3V0XG4gICAgICAgICAgICAgICAgLy8gVGhlIG5leHQgcmVsZWFzZSBjaGFuZ2VzIGhvdyBlcnJvcnMgYXJlIHByb3BvZ2F0ZWQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29weSBwcm92aWRlciByZXNwb25zZSBvbnRvIG9yaWdpbmFsIHJlc3BvbnNlXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlcywgcHJvdmlkZXJSZXMpO1xuICAgICAgICAgICAgcmV0dXJuIGVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZXhwb3J0cy5ldGhlcnNQcm92aWRlckFzTWlkZGxld2FyZSA9IGV0aGVyc1Byb3ZpZGVyQXNNaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXJBc01pZGRsZXdhcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZVJldHJ5T25FbXB0eU1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBjbG9uZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjbG9uZVwiKSk7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBwaWZ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInBpZnlcIikpO1xuY29uc3QgbG9nZ2luZ191dGlsc18xID0gcmVxdWlyZShcIi4vbG9nZ2luZy11dGlsc1wiKTtcbmNvbnN0IGNhY2hlXzEgPSByZXF1aXJlKFwiLi91dGlscy9jYWNoZVwiKTtcbmNvbnN0IHRpbWVvdXRfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL3RpbWVvdXRcIik7XG4vL1xuLy8gUmV0cnlPbkVtcHR5TWlkZGxld2FyZSB3aWxsIHJldHJ5IGFueSByZXF1ZXN0IHdpdGggYW4gZW1wdHkgcmVzcG9uc2UgdGhhdCBoYXNcbi8vIGEgbnVtYmVyZWQgYmxvY2sgcmVmZXJlbmNlIGF0IG9yIGxvd2VyIHRoYW4gdGhlIGJsb2NrVHJhY2tlcidzIGxhdGVzdCBibG9jay5cbi8vIEl0cyB1c2VmdWwgZm9yIGRlYWxpbmcgd2l0aCBsb2FkLWJhbGFuY2VkIGV0aGVyZXVtIEpTT04gUlBDXG4vLyBub2RlcyB0aGF0IGFyZSBub3QgYWx3YXlzIGluIHN5bmMgd2l0aCBlYWNoIG90aGVyLlxuLy9cbmNvbnN0IGxvZyA9IGxvZ2dpbmdfdXRpbHNfMS5jcmVhdGVNb2R1bGVMb2dnZXIobG9nZ2luZ191dGlsc18xLnByb2plY3RMb2dnZXIsICdyZXRyeS1vbi1lbXB0eScpO1xuLy8gZW1wdHkgdmFsdWVzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGEgcmVxdWVzdCBzaG91bGQgYmUgcmV0cmllZFxuLy8gYDxuaWw+YCBjb21lcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMTY5MjVcbmNvbnN0IGVtcHR5VmFsdWVzID0gW1xuICAgIHVuZGVmaW5lZCxcbiAgICBudWxsLFxuICAgICdcXHUwMDNjbmlsXFx1MDAzZScsXG5dO1xuZnVuY3Rpb24gY3JlYXRlUmV0cnlPbkVtcHR5TWlkZGxld2FyZSh7IHByb3ZpZGVyLCBibG9ja1RyYWNrZXIsIH0gPSB7fSkge1xuICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1JldHJ5T25FbXB0eU1pZGRsZXdhcmUgLSBtYW5kYXRvcnkgXCJwcm92aWRlclwiIG9wdGlvbiBpcyBtaXNzaW5nLicpO1xuICAgIH1cbiAgICBpZiAoIWJsb2NrVHJhY2tlcikge1xuICAgICAgICB0aHJvdyBFcnJvcignUmV0cnlPbkVtcHR5TWlkZGxld2FyZSAtIG1hbmRhdG9yeSBcImJsb2NrVHJhY2tlclwiIG9wdGlvbiBpcyBtaXNzaW5nLicpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgICAgICBjb25zdCBibG9ja1JlZkluZGV4ID0gY2FjaGVfMS5ibG9ja1RhZ1BhcmFtSW5kZXgocmVxLm1ldGhvZCk7XG4gICAgICAgIC8vIHNraXAgaWYgbWV0aG9kIGRvZXMgbm90IGluY2x1ZGUgYmxvY2tSZWZcbiAgICAgICAgaWYgKGJsb2NrUmVmSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBza2lwIGlmIG5vdCBleGFjdCBibG9jayByZWZlcmVuY2VzXG4gICAgICAgIGxldCBibG9ja1JlZiA9IEFycmF5LmlzQXJyYXkocmVxLnBhcmFtcylcbiAgICAgICAgICAgID8gcmVxLnBhcmFtc1tibG9ja1JlZkluZGV4XVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIG9taXR0ZWQgYmxvY2tSZWYgaW1wbGllcyBcImxhdGVzdFwiXG4gICAgICAgIGlmIChibG9ja1JlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBibG9ja1JlZiA9ICdsYXRlc3QnO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNraXAgaWYgbm9uLW51bWJlciBibG9jayByZWZlcmVuY2VcbiAgICAgICAgaWYgKFsnbGF0ZXN0JywgJ3BlbmRpbmcnXS5pbmNsdWRlcyhibG9ja1JlZikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2tpcCBpZiBibG9jayByZWZlcm5jZSBpcyBub3QgYSB2YWxpZCBudW1iZXJcbiAgICAgICAgY29uc3QgYmxvY2tSZWZOdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQoYmxvY2tSZWYuc2xpY2UoMiksIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihibG9ja1JlZk51bWJlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9va3VwIGxhdGVzdCBibG9ja1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja051bWJlckhleCA9IGF3YWl0IGJsb2NrVHJhY2tlci5nZXRMYXRlc3RCbG9jaygpO1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja051bWJlciA9IE51bWJlci5wYXJzZUludChsYXRlc3RCbG9ja051bWJlckhleC5zbGljZSgyKSwgMTYpO1xuICAgICAgICAvLyBza2lwIGlmIHJlcXVlc3QgYmxvY2sgbnVtYmVyIGlzIGhpZ2hlciB0aGFuIGN1cnJlbnRcbiAgICAgICAgaWYgKGJsb2NrUmVmTnVtYmVyID4gbGF0ZXN0QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgIGxvZygnUmVxdWVzdGVkIGJsb2NrIG51bWJlciAlbyBpcyBoaWdoZXIgdGhhbiBsYXRlc3QgYmxvY2sgbnVtYmVyICVvLCBmYWxsaW5nIHRocm91Z2ggdG8gb3JpZ2luYWwgcmVxdWVzdCcsIGJsb2NrUmVmTnVtYmVyLCBsYXRlc3RCbG9ja051bWJlcik7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGxvZygnUmVxdWVzdGVkIGJsb2NrIG51bWJlciAlbyBpcyBub3QgaGlnaGVyIHRoYW4gbGF0ZXN0IGJsb2NrIG51bWJlciAlbywgdHJ5aW5nIHJlcXVlc3QgdW50aWwgbm9uLWVtcHR5IHJlc3BvbnNlIGlzIHJlY2VpdmVkJywgYmxvY2tSZWZOdW1iZXIsIGxhdGVzdEJsb2NrTnVtYmVyKTtcbiAgICAgICAgLy8gY3JlYXRlIGNoaWxkIHJlcXVlc3Qgd2l0aCBzcGVjaWZpYyBibG9jay1yZWZcbiAgICAgICAgY29uc3QgY2hpbGRSZXF1ZXN0ID0gY2xvbmVfMS5kZWZhdWx0KHJlcSk7XG4gICAgICAgIC8vIGF0dGVtcHQgY2hpbGQgcmVxdWVzdCB1bnRpbCBub24tZW1wdHkgcmVzcG9uc2UgaXMgcmVjZWl2ZWRcbiAgICAgICAgY29uc3QgY2hpbGRSZXNwb25zZSA9IGF3YWl0IHJldHJ5KDEwLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsb2coJ1BlcmZvcm1pbmcgcmVxdWVzdCAlbycsIGNoaWxkUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBhdHRlbXB0UmVzcG9uc2UgPSBhd2FpdCBwaWZ5XzEuZGVmYXVsdChwcm92aWRlci5zZW5kQXN5bmMpLmNhbGwocHJvdmlkZXIsIGNoaWxkUmVxdWVzdCk7XG4gICAgICAgICAgICBsb2coJ1Jlc3BvbnNlIGlzICVvJywgYXR0ZW1wdFJlc3BvbnNlKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXN1bHRcbiAgICAgICAgICAgIGlmIChlbXB0eVZhbHVlcy5pbmNsdWRlcyhhdHRlbXB0UmVzcG9uc2UucmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmV0cnlPbkVtcHR5TWlkZGxld2FyZSAtIGVtcHR5IHJlc3BvbnNlIFwiJHtKU09OLnN0cmluZ2lmeShhdHRlbXB0UmVzcG9uc2UpfVwiIGZvciByZXF1ZXN0IFwiJHtKU09OLnN0cmluZ2lmeShjaGlsZFJlcXVlc3QpfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXR0ZW1wdFJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICAgICAgbG9nKCdDb3B5aW5nIHJlc3VsdCAlbyBhbmQgZXJyb3IgJW8nLCBjaGlsZFJlc3BvbnNlLnJlc3VsdCwgY2hpbGRSZXNwb25zZS5lcnJvcik7XG4gICAgICAgIC8vIGNvcHkgY2hpbGQgcmVzcG9uc2Ugb250byBvcmlnaW5hbCByZXNwb25zZVxuICAgICAgICByZXMucmVzdWx0ID0gY2hpbGRSZXNwb25zZS5yZXN1bHQ7XG4gICAgICAgIHJlcy5lcnJvciA9IGNoaWxkUmVzcG9uc2UuZXJyb3I7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZVJldHJ5T25FbXB0eU1pZGRsZXdhcmUgPSBjcmVhdGVSZXRyeU9uRW1wdHlNaWRkbGV3YXJlO1xuYXN5bmMgZnVuY3Rpb24gcmV0cnkobWF4UmV0cmllcywgYXN5bmNGbikge1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBtYXhSZXRyaWVzOyBpbmRleCsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgYXN5bmNGbigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZygnKGNhbGwgJWkpIFJlcXVlc3QgZmFpbGVkLCB3YWl0aW5nIDFzIHRvIHJldHJ5IGFnYWluLi4uJywgaW5kZXggKyAxKTtcbiAgICAgICAgICAgIGF3YWl0IHRpbWVvdXRfMS50aW1lb3V0KDEwMDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvZygnUmV0cmllcyBleGhhdXN0ZWQnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JldHJ5T25FbXB0eU1pZGRsZXdhcmUgLSByZXRyaWVzIGV4aGF1c3RlZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV0cnlPbkVtcHR5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYWNoZVR5cGVGb3JNZXRob2QgPSBleHBvcnRzLmJsb2NrVGFnUGFyYW1JbmRleCA9IGV4cG9ydHMuYmxvY2tUYWdGb3JSZXF1ZXN0ID0gZXhwb3J0cy5jYW5DYWNoZSA9IGV4cG9ydHMuY2FjaGVJZGVudGlmaWVyRm9yUmVxdWVzdCA9IGV4cG9ydHMuQ2FjaGVTdHJhdGVneSA9IHZvaWQgMDtcbmNvbnN0IHNhZmVfc3RhYmxlX3N0cmluZ2lmeV8xID0gcmVxdWlyZShcInNhZmUtc3RhYmxlLXN0cmluZ2lmeVwiKTtcbmNvbnN0IHN0cmluZ2lmeSA9IHNhZmVfc3RhYmxlX3N0cmluZ2lmeV8xLmNvbmZpZ3VyZSh7IGJpZ2ludDogZmFsc2UsIGNpcmN1bGFyVmFsdWU6IEVycm9yIH0pO1xuLyoqXG4gKiBUaGUgY2FjaGUgc3RyYXRlZ3kgdG8gdXNlIGZvciBhIGdpdmVuIG1ldGhvZC5cbiAqL1xudmFyIENhY2hlU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKENhY2hlU3RyYXRlZ3kpIHtcbiAgICAvKipcbiAgICAgKiBDYWNoZSBwZXItYmxvY2suXG4gICAgICovXG4gICAgQ2FjaGVTdHJhdGVneVtcIkJsb2NrXCJdID0gXCJibG9ja1wiO1xuICAgIC8qKlxuICAgICAqIENhY2hlIHVudGlsIGEgY2hhaW4gcmVvcmdhbml6YXRpb24gb2NjdXJzLlxuICAgICAqL1xuICAgIENhY2hlU3RyYXRlZ3lbXCJGb3JrXCJdID0gXCJmb3JrXCI7XG4gICAgLyoqXG4gICAgICogTmV2ZXIgY2FjaGUuXG4gICAgICovXG4gICAgQ2FjaGVTdHJhdGVneVtcIk5ldmVyXCJdID0gXCJuZXZlclwiO1xuICAgIC8qKlxuICAgICAqIFBlcm1hbmVudGx5IGNhY2hlLlxuICAgICAqL1xuICAgIENhY2hlU3RyYXRlZ3lbXCJQZXJtYW5lbnRcIl0gPSBcInBlcm1hXCI7XG59KShDYWNoZVN0cmF0ZWd5ID0gZXhwb3J0cy5DYWNoZVN0cmF0ZWd5IHx8IChleHBvcnRzLkNhY2hlU3RyYXRlZ3kgPSB7fSkpO1xuLypcbiAqIFJldHVybiBhIGNhY2hlIGlkZW50aWZpZXIgZm9yIHRoZSBnaXZlbiByZXF1ZXN0LlxuICpcbiAqIFRoaXMgaWRlbnRpZmllciBzaG91bGQgaW5jbHVkZSBhbnkgcmVxdWVzdCBkZXRhaWxzIHRoYXQgbWlnaHQgaW1wYWN0IHRoZVxuICogcmVzcG9uc2UsIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiB0aGUgYmxvY2sgcGFyYW1ldGVyIGlmIHRoZSBgc2tpcEJsb2NrUmVmYFxuICogb3B0aW9uIGlzIHNldCxcbiAqXG4gKiBJZiB0aGUgcmVxdWVzdCBjYW5ub3QgYmUgY2FjaGVkLCB0aGlzIHdpbGwgcmV0dXJuIGBudWxsYC5cbiAqXG4gKiBAcGFyYW0gcmVxdWVzdCAtIFRoZSBKU09OLVJQQyByZXF1ZXN0LlxuICogQHBhcmFtIHNraXBCbG9ja1JlZiAtIFNraXAgdGhlIGJsb2NrIHBhcmFtZXRlciB3aGVuIGdlbmVyYXRpbmcgdGhlIGNhY2hlXG4gKiBpZGVudGlmaWVyLlxuICogQHJldHVybnMgVGhlIGNhY2hlIGlkZW50aWZpZXIgZm9yIHRoaXMgcmVxdWVzdCwgb3IgYG51bGxgIGlmIGl0IGNhbid0IGJlXG4gKiBjYWNoZWQuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSWRlbnRpZmllckZvclJlcXVlc3QocmVxdWVzdCwgc2tpcEJsb2NrUmVmKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHNpbXBsZVBhcmFtcyA9IHNraXBCbG9ja1JlZlxuICAgICAgICA/IHBhcmFtc1dpdGhvdXRCbG9ja1RhZyhyZXF1ZXN0KVxuICAgICAgICA6IChfYSA9IHJlcXVlc3QucGFyYW1zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICBpZiAoY2FuQ2FjaGUocmVxdWVzdC5tZXRob2QpKSB7XG4gICAgICAgIHJldHVybiBgJHtyZXF1ZXN0Lm1ldGhvZH06JHtzdHJpbmdpZnkoc2ltcGxlUGFyYW1zKX1gO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuY2FjaGVJZGVudGlmaWVyRm9yUmVxdWVzdCA9IGNhY2hlSWRlbnRpZmllckZvclJlcXVlc3Q7XG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbWV0aG9kIGNhbiBiZSBjYWNoZWQgb3Igbm90LlxuICpcbiAqIEBwYXJhbSBtZXRob2QgLSBUaGUgbWV0aG9kIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgbWV0aG9kIGNhbiBiZSBjYWNoZWQuXG4gKi9cbmZ1bmN0aW9uIGNhbkNhY2hlKG1ldGhvZCkge1xuICAgIHJldHVybiBjYWNoZVR5cGVGb3JNZXRob2QobWV0aG9kKSAhPT0gQ2FjaGVTdHJhdGVneS5OZXZlcjtcbn1cbmV4cG9ydHMuY2FuQ2FjaGUgPSBjYW5DYWNoZTtcbi8qKlxuICogUmV0dXJuIHRoZSBibG9jayBwYXJhbWV0ZXIgZm9yIHRoZSBnaXZlbiByZXF1ZXN0LCBpZiBpdCBoYXMgb25lLlxuICpcbiAqIEBwYXJhbSByZXF1ZXN0IC0gVGhlIEpTT04tUlBDIHJlcXVlc3QuXG4gKiBAcmV0dXJucyBUaGUgYmxvY2sgcGFyYW1ldGVyIGluIHRoZSBnaXZlbiByZXF1ZXN0LCBvciBgdW5kZWZpbmVkYCBpZiBub25lIHdhcyBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gYmxvY2tUYWdGb3JSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICBpZiAoIXJlcXVlc3QucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gYmxvY2tUYWdQYXJhbUluZGV4KHJlcXVlc3QubWV0aG9kKTtcbiAgICAvLyBCbG9jayB0YWcgcGFyYW0gbm90IHBhc3NlZC5cbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAhQXJyYXkuaXNBcnJheShyZXF1ZXN0LnBhcmFtcykgfHxcbiAgICAgICAgaW5kZXggPj0gcmVxdWVzdC5wYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiByZXF1ZXN0LnBhcmFtc1tpbmRleF07XG59XG5leHBvcnRzLmJsb2NrVGFnRm9yUmVxdWVzdCA9IGJsb2NrVGFnRm9yUmVxdWVzdDtcbi8qKlxuICogUmV0dXJuIHRoZSByZXF1ZXN0IHBhcmFtZXRlcnMgd2l0aG91dCB0aGUgYmxvY2sgcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSByZXF1ZXN0IC0gVGhlIEpTT04tUlBDIHJlcXVlc3QuXG4gKiBAcmV0dXJucyBUaGUgcmVxdWVzdCBwYXJhbWV0ZXJzIHdpdGggdGhlIGJsb2NrIHBhcmFtZXRlciByZW1vdmVkLCBpZiBvbmUgd2FzIGZvdW5kLlxuICovXG5mdW5jdGlvbiBwYXJhbXNXaXRob3V0QmxvY2tUYWcocmVxdWVzdCkge1xuICAgIGlmICghcmVxdWVzdC5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IGJsb2NrVGFnUGFyYW1JbmRleChyZXF1ZXN0Lm1ldGhvZCk7XG4gICAgLy8gQmxvY2sgdGFnIHBhcmFtIG5vdCBwYXNzZWQuXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgIUFycmF5LmlzQXJyYXkocmVxdWVzdC5wYXJhbXMpIHx8XG4gICAgICAgIGluZGV4ID49IHJlcXVlc3QucGFyYW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVxdWVzdC5wYXJhbXM7XG4gICAgfVxuICAgIC8vIGV0aF9nZXRCbG9ja0J5TnVtYmVyIGhhcyB0aGUgYmxvY2sgdGFnIGZpcnN0LCB0aGVuIHRoZSBvcHRpb25hbCBpbmNsdWRlVHg/IHBhcmFtXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSAnZXRoX2dldEJsb2NrQnlOdW1iZXInKSB7XG4gICAgICAgIHJldHVybiByZXF1ZXN0LnBhcmFtcy5zbGljZSgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcXVlc3QucGFyYW1zLnNsaWNlKDAsIGluZGV4KTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGJsb2NrIHBhcmFtZXRlciBmb3IgdGhlIGdpdmVuIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0gbWV0aG9kIC0gQSBKU09OLVJQQyBtZXRob2QuXG4gKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIGJsb2NrIHBhcmFtZXRlciBmb3IgdGhhdCBtZXRob2QsIG9yIGB1bmRlZmluZWRgIGlmXG4gKiB0aGVyZSBpcyBubyBrbm93biBibG9jayBwYXJhbWV0ZXIuXG4gKi9cbmZ1bmN0aW9uIGJsb2NrVGFnUGFyYW1JbmRleChtZXRob2QpIHtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAvLyBibG9ja1RhZyBpcyBhdCBpbmRleCAyXG4gICAgICAgIGNhc2UgJ2V0aF9nZXRTdG9yYWdlQXQnOlxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIC8vIGJsb2NrVGFnIGlzIGF0IGluZGV4IDFcbiAgICAgICAgY2FzZSAnZXRoX2dldEJhbGFuY2UnOlxuICAgICAgICBjYXNlICdldGhfZ2V0Q29kZSc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50JzpcbiAgICAgICAgY2FzZSAnZXRoX2NhbGwnOlxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIC8vIGJsb2NrVGFnIGlzIGF0IGluZGV4IDBcbiAgICAgICAgY2FzZSAnZXRoX2dldEJsb2NrQnlOdW1iZXInOlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIGJsb2NrVGFnXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuYmxvY2tUYWdQYXJhbUluZGV4ID0gYmxvY2tUYWdQYXJhbUluZGV4O1xuLyoqXG4gKiBSZXR1cm4gdGhlIGNhY2hlIHR5cGUgdXNlZCBmb3IgdGhlIGdpdmVuIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0gbWV0aG9kIC0gQSBKU09OLVJQQyBtZXRob2QuXG4gKiBAcmV0dXJucyBUaGUgY2FjaGUgdHlwZSB0byB1c2UgZm9yIHRoYXQgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBjYWNoZVR5cGVGb3JNZXRob2QobWV0aG9kKSB7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgLy8gY2FjaGUgcGVybWFuZW50bHlcbiAgICAgICAgY2FzZSAnd2ViM19jbGllbnRWZXJzaW9uJzpcbiAgICAgICAgY2FzZSAnd2ViM19zaGEzJzpcbiAgICAgICAgY2FzZSAnZXRoX3Byb3RvY29sVmVyc2lvbic6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRCeUhhc2gnOlxuICAgICAgICBjYXNlICdldGhfZ2V0VW5jbGVDb3VudEJ5QmxvY2tIYXNoJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldENvZGUnOlxuICAgICAgICBjYXNlICdldGhfZ2V0QmxvY2tCeUhhc2gnOlxuICAgICAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2gnOlxuICAgICAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSGFzaEFuZEluZGV4JzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRVbmNsZUJ5QmxvY2tIYXNoQW5kSW5kZXgnOlxuICAgICAgICBjYXNlICdldGhfZ2V0Q29tcGlsZXJzJzpcbiAgICAgICAgY2FzZSAnZXRoX2NvbXBpbGVMTEwnOlxuICAgICAgICBjYXNlICdldGhfY29tcGlsZVNvbGlkaXR5JzpcbiAgICAgICAgY2FzZSAnZXRoX2NvbXBpbGVTZXJwZW50JzpcbiAgICAgICAgY2FzZSAnc2hoX3ZlcnNpb24nOlxuICAgICAgICBjYXNlICd0ZXN0X3Blcm1hQ2FjaGUnOlxuICAgICAgICAgICAgcmV0dXJuIENhY2hlU3RyYXRlZ3kuUGVybWFuZW50O1xuICAgICAgICAvLyBjYWNoZSB1bnRpbCBmb3JrXG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudEJ5TnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrTnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja051bWJlckFuZEluZGV4JzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFVuY2xlQnlCbG9ja051bWJlckFuZEluZGV4JzpcbiAgICAgICAgY2FzZSAndGVzdF9mb3JrQ2FjaGUnOlxuICAgICAgICAgICAgcmV0dXJuIENhY2hlU3RyYXRlZ3kuRm9yaztcbiAgICAgICAgLy8gY2FjaGUgZm9yIGJsb2NrXG4gICAgICAgIGNhc2UgJ2V0aF9nYXNQcmljZSc6XG4gICAgICAgIGNhc2UgJ2V0aF9ibG9ja051bWJlcic6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCYWxhbmNlJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFN0b3JhZ2VBdCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50JzpcbiAgICAgICAgY2FzZSAnZXRoX2NhbGwnOlxuICAgICAgICBjYXNlICdldGhfZXN0aW1hdGVHYXMnOlxuICAgICAgICBjYXNlICdldGhfZ2V0RmlsdGVyTG9ncyc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRMb2dzJzpcbiAgICAgICAgY2FzZSAndGVzdF9ibG9ja0NhY2hlJzpcbiAgICAgICAgICAgIHJldHVybiBDYWNoZVN0cmF0ZWd5LkJsb2NrO1xuICAgICAgICAvLyBuZXZlciBjYWNoZVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIENhY2hlU3RyYXRlZ3kuTmV2ZXI7XG4gICAgfVxufVxuZXhwb3J0cy5jYWNoZVR5cGVGb3JNZXRob2QgPSBjYWNoZVR5cGVGb3JNZXRob2Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWNoZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudGltZW91dCA9IHZvaWQgMDtcbi8qKlxuICogV2FpdCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIGR1cmF0aW9uIC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdC5cbiAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIHRoZSBzcGVjaWZpZWQgYW1vdW50IG9mIHRpbWUuXG4gKi9cbmZ1bmN0aW9uIHRpbWVvdXQoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pKTtcbn1cbmV4cG9ydHMudGltZW91dCA9IHRpbWVvdXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lb3V0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZVdhbGxldE1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBzaWdVdGlsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJAbWV0YW1hc2svZXRoLXNpZy11dGlsXCIpKTtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG5mdW5jdGlvbiBjcmVhdGVXYWxsZXRNaWRkbGV3YXJlKHsgZ2V0QWNjb3VudHMsIHByb2Nlc3NEZWNyeXB0TWVzc2FnZSwgcHJvY2Vzc0VuY3J5cHRpb25QdWJsaWNLZXksIHByb2Nlc3NFdGhTaWduTWVzc2FnZSwgcHJvY2Vzc1BlcnNvbmFsTWVzc2FnZSwgcHJvY2Vzc1RyYW5zYWN0aW9uLCBwcm9jZXNzU2lnblRyYW5zYWN0aW9uLCBwcm9jZXNzVHlwZWRNZXNzYWdlLCBwcm9jZXNzVHlwZWRNZXNzYWdlVjMsIHByb2Nlc3NUeXBlZE1lc3NhZ2VWNCwgfSkge1xuICAgIGlmICghZ2V0QWNjb3VudHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRzLmdldEFjY291bnRzIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIHJldHVybiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUoe1xuICAgICAgICAvLyBhY2NvdW50IGxvb2t1cHNcbiAgICAgICAgZXRoX2FjY291bnRzOiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUobG9va3VwQWNjb3VudHMpLFxuICAgICAgICBldGhfY29pbmJhc2U6IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShsb29rdXBEZWZhdWx0QWNjb3VudCksXG4gICAgICAgIC8vIHR4IHNpZ25hdHVyZXNcbiAgICAgICAgZXRoX3NlbmRUcmFuc2FjdGlvbjoganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKHNlbmRUcmFuc2FjdGlvbiksXG4gICAgICAgIGV0aF9zaWduVHJhbnNhY3Rpb246IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShzaWduVHJhbnNhY3Rpb24pLFxuICAgICAgICAvLyBtZXNzYWdlIHNpZ25hdHVyZXNcbiAgICAgICAgZXRoX3NpZ246IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShldGhTaWduKSxcbiAgICAgICAgZXRoX3NpZ25UeXBlZERhdGE6IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShzaWduVHlwZWREYXRhKSxcbiAgICAgICAgZXRoX3NpZ25UeXBlZERhdGFfdjM6IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShzaWduVHlwZWREYXRhVjMpLFxuICAgICAgICBldGhfc2lnblR5cGVkRGF0YV92NDoganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKHNpZ25UeXBlZERhdGFWNCksXG4gICAgICAgIHBlcnNvbmFsX3NpZ246IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShwZXJzb25hbFNpZ24pLFxuICAgICAgICBldGhfZ2V0RW5jcnlwdGlvblB1YmxpY0tleToganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGVuY3J5cHRpb25QdWJsaWNLZXkpLFxuICAgICAgICBldGhfZGVjcnlwdDoganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGRlY3J5cHRNZXNzYWdlKSxcbiAgICAgICAgcGVyc29uYWxfZWNSZWNvdmVyOiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUocGVyc29uYWxSZWNvdmVyKSxcbiAgICB9KTtcbiAgICAvL1xuICAgIC8vIGFjY291bnQgbG9va3Vwc1xuICAgIC8vXG4gICAgYXN5bmMgZnVuY3Rpb24gbG9va3VwQWNjb3VudHMocmVxLCByZXMpIHtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IGdldEFjY291bnRzKHJlcSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGxvb2t1cERlZmF1bHRBY2NvdW50KHJlcSwgcmVzKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgZ2V0QWNjb3VudHMocmVxKTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGFjY291bnRzWzBdIHx8IG51bGw7XG4gICAgfVxuICAgIC8vXG4gICAgLy8gdHJhbnNhY3Rpb24gc2lnbmF0dXJlc1xuICAgIC8vXG4gICAgYXN5bmMgZnVuY3Rpb24gc2VuZFRyYW5zYWN0aW9uKHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc1RyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHhQYXJhbXMgPSByZXEucGFyYW1zWzBdIHx8IHt9O1xuICAgICAgICB0eFBhcmFtcy5mcm9tID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIodHhQYXJhbXMuZnJvbSwgcmVxKTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NUcmFuc2FjdGlvbih0eFBhcmFtcywgcmVxKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2lnblRyYW5zYWN0aW9uKHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc1NpZ25UcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR4UGFyYW1zID0gcmVxLnBhcmFtc1swXSB8fCB7fTtcbiAgICAgICAgdHhQYXJhbXMuZnJvbSA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHR4UGFyYW1zLmZyb20sIHJlcSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzU2lnblRyYW5zYWN0aW9uKHR4UGFyYW1zLCByZXEpO1xuICAgIH1cbiAgICAvL1xuICAgIC8vIG1lc3NhZ2Ugc2lnbmF0dXJlc1xuICAgIC8vXG4gICAgYXN5bmMgZnVuY3Rpb24gZXRoU2lnbihyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NFdGhTaWduTWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihyZXEucGFyYW1zWzBdLCByZXEpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gcmVxLnBhcmFtc1sxXTtcbiAgICAgICAgY29uc3QgZXh0cmFQYXJhbXMgPSByZXEucGFyYW1zWzJdIHx8IHt9O1xuICAgICAgICBjb25zdCBtc2dQYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4dHJhUGFyYW1zKSwgeyBmcm9tOiBhZGRyZXNzLCBkYXRhOiBtZXNzYWdlIH0pO1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc0V0aFNpZ25NZXNzYWdlKG1zZ1BhcmFtcywgcmVxKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2lnblR5cGVkRGF0YShyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NUeXBlZE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlID0gcmVxLnBhcmFtc1swXTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHJlcS5wYXJhbXNbMV0sIHJlcSk7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSAnVjEnO1xuICAgICAgICBjb25zdCBleHRyYVBhcmFtcyA9IHJlcS5wYXJhbXNbMl0gfHwge307XG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFQYXJhbXMpLCB7IGZyb206IGFkZHJlc3MsIGRhdGE6IG1lc3NhZ2UgfSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzVHlwZWRNZXNzYWdlKG1zZ1BhcmFtcywgcmVxLCB2ZXJzaW9uKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2lnblR5cGVkRGF0YVYzKHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc1R5cGVkTWVzc2FnZVYzKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHJlcS5wYXJhbXNbMF0sIHJlcSk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXEucGFyYW1zWzFdO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gJ1YzJztcbiAgICAgICAgY29uc3QgbXNnUGFyYW1zID0ge1xuICAgICAgICAgICAgZGF0YTogbWVzc2FnZSxcbiAgICAgICAgICAgIGZyb206IGFkZHJlc3MsXG4gICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICB9O1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc1R5cGVkTWVzc2FnZVYzKG1zZ1BhcmFtcywgcmVxLCB2ZXJzaW9uKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2lnblR5cGVkRGF0YVY0KHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc1R5cGVkTWVzc2FnZVY0KSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHJlcS5wYXJhbXNbMF0sIHJlcSk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXEucGFyYW1zWzFdO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gJ1Y0JztcbiAgICAgICAgY29uc3QgbXNnUGFyYW1zID0ge1xuICAgICAgICAgICAgZGF0YTogbWVzc2FnZSxcbiAgICAgICAgICAgIGZyb206IGFkZHJlc3MsXG4gICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICB9O1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc1R5cGVkTWVzc2FnZVY0KG1zZ1BhcmFtcywgcmVxLCB2ZXJzaW9uKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gcGVyc29uYWxTaWduKHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc1BlcnNvbmFsTWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByb2Nlc3Mgbm9ybWFsbHlcbiAgICAgICAgY29uc3QgZmlyc3RQYXJhbSA9IHJlcS5wYXJhbXNbMF07XG4gICAgICAgIGNvbnN0IHNlY29uZFBhcmFtID0gcmVxLnBhcmFtc1sxXTtcbiAgICAgICAgLy8gbm9uLXN0YW5kYXJkIFwiZXh0cmFQYXJhbXNcIiB0byBiZSBhcHBlbmRlZCB0byBvdXIgXCJtc2dQYXJhbXNcIiBvYmpcbiAgICAgICAgY29uc3QgZXh0cmFQYXJhbXMgPSByZXEucGFyYW1zWzJdIHx8IHt9O1xuICAgICAgICAvLyBXZSBpbml0aWFsbHkgaW5jb3JyZWN0bHkgb3JkZXJlZCB0aGVzZSBwYXJhbWV0ZXJzLlxuICAgICAgICAvLyBUbyBncmFjZWZ1bGx5IHJlc3BlY3QgdXNlcnMgd2hvIGFkb3B0ZWQgdGhpcyBBUEkgZWFybHksXG4gICAgICAgIC8vIHdlIGFyZSBjdXJyZW50bHkgZ3JhY2VmdWxseSByZWNvdmVyaW5nIGZyb20gdGhlIHdyb25nIHBhcmFtIG9yZGVyXG4gICAgICAgIC8vIHdoZW4gaXQgaXMgY2xlYXJseSBpZGVudGlmaWFibGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoYXQgbWVhbnMgd2hlbiB0aGUgZmlyc3QgcGFyYW0gaXMgZGVmaW5pdGVseSBhbiBhZGRyZXNzLFxuICAgICAgICAvLyBhbmQgdGhlIHNlY29uZCBwYXJhbSBpcyBkZWZpbml0ZWx5IG5vdCwgYnV0IGlzIGhleC5cbiAgICAgICAgbGV0IGFkZHJlc3MsIG1lc3NhZ2U7XG4gICAgICAgIGlmIChyZXNlbWJsZXNBZGRyZXNzKGZpcnN0UGFyYW0pICYmICFyZXNlbWJsZXNBZGRyZXNzKHNlY29uZFBhcmFtKSkge1xuICAgICAgICAgICAgbGV0IHdhcm5pbmcgPSBgVGhlIGV0aF9wZXJzb25hbFNpZ24gbWV0aG9kIHJlcXVpcmVzIHBhcmFtcyBvcmRlcmVkIGA7XG4gICAgICAgICAgICB3YXJuaW5nICs9IGBbbWVzc2FnZSwgYWRkcmVzc10uIFRoaXMgd2FzIHByZXZpb3VzbHkgaGFuZGxlZCBpbmNvcnJlY3RseSwgYDtcbiAgICAgICAgICAgIHdhcm5pbmcgKz0gYGFuZCBoYXMgYmVlbiBjb3JyZWN0ZWQgYXV0b21hdGljYWxseS4gYDtcbiAgICAgICAgICAgIHdhcm5pbmcgKz0gYFBsZWFzZSBzd2l0Y2ggdGhpcyBwYXJhbSBvcmRlciBmb3Igc21vb3RoIGJlaGF2aW9yIGluIHRoZSBmdXR1cmUuYDtcbiAgICAgICAgICAgIHJlcy53YXJuaW5nID0gd2FybmluZztcbiAgICAgICAgICAgIGFkZHJlc3MgPSBmaXJzdFBhcmFtO1xuICAgICAgICAgICAgbWVzc2FnZSA9IHNlY29uZFBhcmFtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGZpcnN0UGFyYW07XG4gICAgICAgICAgICBhZGRyZXNzID0gc2Vjb25kUGFyYW07XG4gICAgICAgIH1cbiAgICAgICAgYWRkcmVzcyA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKGFkZHJlc3MsIHJlcSk7XG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFQYXJhbXMpLCB7IGZyb206IGFkZHJlc3MsIGRhdGE6IG1lc3NhZ2UgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF0b21pYy11cGRhdGVzXG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzUGVyc29uYWxNZXNzYWdlKG1zZ1BhcmFtcywgcmVxKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gcGVyc29uYWxSZWNvdmVyKHJlcSwgcmVzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXEucGFyYW1zWzBdO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSByZXEucGFyYW1zWzFdO1xuICAgICAgICBjb25zdCBzaWduZXJBZGRyZXNzID0gc2lnVXRpbC5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmUoe1xuICAgICAgICAgICAgZGF0YTogbWVzc2FnZSxcbiAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBzaWduZXJBZGRyZXNzO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBlbmNyeXB0aW9uUHVibGljS2V5KHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc0VuY3J5cHRpb25QdWJsaWNLZXkpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIocmVxLnBhcmFtc1swXSwgcmVxKTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NFbmNyeXB0aW9uUHVibGljS2V5KGFkZHJlc3MsIHJlcSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGRlY3J5cHRNZXNzYWdlKHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc0RlY3J5cHRNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IHJlcS5wYXJhbXNbMF07XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihyZXEucGFyYW1zWzFdLCByZXEpO1xuICAgICAgICBjb25zdCBleHRyYVBhcmFtcyA9IHJlcS5wYXJhbXNbMl0gfHwge307XG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFQYXJhbXMpLCB7IGZyb206IGFkZHJlc3MsIGRhdGE6IGNpcGhlcnRleHQgfSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzRGVjcnlwdE1lc3NhZ2UobXNnUGFyYW1zLCByZXEpO1xuICAgIH1cbiAgICAvL1xuICAgIC8vIHV0aWxpdHlcbiAgICAvL1xuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUga2V5aG9sZGVyIGFkZHJlc3MsIGFuZCByZXR1cm5zIGEgbm9ybWFsaXplZCAoaS5lLiBsb3dlcmNhc2UpXG4gICAgICogY29weSBvZiBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gdmFsaWRhdGUgYW5kIG5vcm1hbGl6ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVxIC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIG5vcm1hbGl6ZWQgYWRkcmVzcywgaWYgdmFsaWQuIE90aGVyd2lzZSwgdGhyb3dzXG4gICAgICogYW4gZXJyb3JcbiAgICAgKi9cbiAgICBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihhZGRyZXNzLCByZXEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhZGRyZXNzID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgYWRkcmVzcy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICByZXNlbWJsZXNBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCBhbiBcInVuYXV0aG9yaXplZFwiIGVycm9yIGlzIHRocm93biBpZiB0aGUgcmVxdWVzdGVyIGRvZXMgbm90IGhhdmUgdGhlIGBldGhfYWNjb3VudHNgXG4gICAgICAgICAgICAvLyBwZXJtaXNzaW9uLlxuICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBnZXRBY2NvdW50cyhyZXEpO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEFjY291bnRzID0gYWNjb3VudHMubWFwKChfYWRkcmVzcykgPT4gX2FkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkQWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkQWNjb3VudHMuaW5jbHVkZXMobm9ybWFsaXplZEFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRBZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucHJvdmlkZXIudW5hdXRob3JpemVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICAgICAgbWVzc2FnZTogYEludmFsaWQgcGFyYW1ldGVyczogbXVzdCBwcm92aWRlIGFuIEV0aGVyZXVtIGFkZHJlc3MuYCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVXYWxsZXRNaWRkbGV3YXJlID0gY3JlYXRlV2FsbGV0TWlkZGxld2FyZTtcbmZ1bmN0aW9uIHJlc2VtYmxlc0FkZHJlc3Moc3RyKSB7XG4gICAgLy8gaGV4IHByZWZpeCAyICsgMjAgYnl0ZXNcbiAgICByZXR1cm4gc3RyLmxlbmd0aCA9PT0gMiArIDIwICogMjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhbGxldC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzZXJ0RXhoYXVzdGl2ZSA9IGV4cG9ydHMuYXNzZXJ0U3RydWN0ID0gZXhwb3J0cy5hc3NlcnQgPSBleHBvcnRzLkFzc2VydGlvbkVycm9yID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbi8qKlxuICogVHlwZSBndWFyZCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gZXJyb3Igb2JqZWN0IHdpdGggYVxuICogYG1lc3NhZ2VgIHByb3BlcnR5LCBzdWNoIGFzIGFuIGluc3RhbmNlIG9mIEVycm9yLlxuICpcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBUcnVlIG9yIGZhbHNlLCBkZXBlbmRpbmcgb24gdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNFcnJvcldpdGhNZXNzYWdlKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ21lc3NhZ2UnIGluIGVycm9yO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgY29uc3RydWN0b3IsIGkuZS4sIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgY2FsbGVkIHdpdGhcbiAqIHRoZSBgbmV3YCBrZXl3b3JkLlxuICpcbiAqIEBwYXJhbSBmbiAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBjb25zdHJ1Y3Rvciwgb3IgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzQ29uc3RydWN0YWJsZShmbikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gQm9vbGVhbih0eXBlb2YgKChfYiA9IChfYSA9IGZuID09PSBudWxsIHx8IGZuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmbi5wcm90b3R5cGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25zdHJ1Y3RvcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5hbWUpID09PSAnc3RyaW5nJyk7XG59XG4vKipcbiAqIEdldCB0aGUgZXJyb3IgbWVzc2FnZSBmcm9tIGFuIHVua25vd24gZXJyb3Igb2JqZWN0LiBJZiB0aGUgZXJyb3Igb2JqZWN0IGhhc1xuICogYSBgbWVzc2FnZWAgcHJvcGVydHksIHRoYXQgcHJvcGVydHkgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSwgdGhlIHN0cmluZ2lmaWVkXG4gKiBlcnJvciBvYmplY3QgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIG9iamVjdCB0byBnZXQgdGhlIG1lc3NhZ2UgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBlcnJvciBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gaXNFcnJvcldpdGhNZXNzYWdlKGVycm9yKSA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgIC8vIElmIHRoZSBlcnJvciBlbmRzIHdpdGggYSBwZXJpb2QsIHJlbW92ZSBpdCwgYXMgd2UnbGwgYWRkIG91ciBvd24gcGVyaW9kLlxuICAgIGlmIChtZXNzYWdlLmVuZHNXaXRoKCcuJykpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2Uuc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbn1cbi8qKlxuICogSW5pdGlhbGlzZSBhbiB7QGxpbmsgQXNzZXJ0aW9uRXJyb3JDb25zdHJ1Y3Rvcn0gZXJyb3IuXG4gKlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB1c2UuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHJldHVybnMgVGhlIGVycm9yIG9iamVjdC5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZnVuY3Rpb24gZ2V0RXJyb3IoRXJyb3JXcmFwcGVyLCBtZXNzYWdlKSB7XG4gICAgaWYgKGlzQ29uc3RydWN0YWJsZShFcnJvcldyYXBwZXIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3JXcmFwcGVyKHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gRXJyb3JXcmFwcGVyKHtcbiAgICAgICAgbWVzc2FnZSxcbiAgICB9KTtcbn1cbi8qKlxuICogVGhlIGRlZmF1bHQgZXJyb3IgY2xhc3MgdGhhdCBpcyB0aHJvd24gaWYgYW4gYXNzZXJ0aW9uIGZhaWxzLlxuICovXG5jbGFzcyBBc3NlcnRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMubWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9ICdFUlJfQVNTRVJUSU9OJztcbiAgICB9XG59XG5leHBvcnRzLkFzc2VydGlvbkVycm9yID0gQXNzZXJ0aW9uRXJyb3I7XG4vKipcbiAqIFNhbWUgYXMgTm9kZS5qcyBhc3NlcnQuXG4gKiBJZiB0aGUgdmFsdWUgaXMgZmFsc3ksIHRocm93cyBhbiBlcnJvciwgZG9lcyBub3RoaW5nIG90aGVyd2lzZS5cbiAqXG4gKiBAdGhyb3dzIHtAbGluayBBc3NlcnRpb25FcnJvcn0gSWYgdmFsdWUgaXMgZmFsc3kuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdGVzdCB0aGF0IHNob3VsZCBiZSB0cnV0aHkgdG8gcGFzcy5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gTWVzc2FnZSB0byBiZSBwYXNzZWQgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfSBvciBhblxuICoge0BsaW5rIEVycm9yfSBpbnN0YW5jZSB0byB0aHJvdy5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uIElmIGEgY3VzdG9tIGVycm9yIGNsYXNzIGlzIHByb3ZpZGVkIGZvclxuICogdGhlIGBtZXNzYWdlYCBhcmd1bWVudCwgdGhpcyBhcmd1bWVudCBpcyBpZ25vcmVkLlxuICovXG5mdW5jdGlvbiBhc3NlcnQodmFsdWUsIG1lc3NhZ2UgPSAnQXNzZXJ0aW9uIGZhaWxlZC4nLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlciA9IEFzc2VydGlvbkVycm9yKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGdldEVycm9yKEVycm9yV3JhcHBlciwgbWVzc2FnZSk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG4vKipcbiAqIEFzc2VydCBhIHZhbHVlIGFnYWluc3QgYSBTdXBlcnN0cnVjdCBzdHJ1Y3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gdmFsaWRhdGUgYWdhaW5zdC5cbiAqIEBwYXJhbSBlcnJvclByZWZpeCAtIEEgcHJlZml4IHRvIGFkZCB0byB0aGUgZXJyb3IgbWVzc2FnZS4gRGVmYXVsdHMgdG9cbiAqIFwiQXNzZXJ0aW9uIGZhaWxlZFwiLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0U3RydWN0KHZhbHVlLCBzdHJ1Y3QsIGVycm9yUHJlZml4ID0gJ0Fzc2VydGlvbiBmYWlsZWQnLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlciA9IEFzc2VydGlvbkVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgKDAsIHN1cGVyc3RydWN0XzEuYXNzZXJ0KSh2YWx1ZSwgc3RydWN0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IGdldEVycm9yKEVycm9yV3JhcHBlciwgYCR7ZXJyb3JQcmVmaXh9OiAke2dldEVycm9yTWVzc2FnZShlcnJvcil9LmApO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0U3RydWN0ID0gYXNzZXJ0U3RydWN0O1xuLyoqXG4gKiBVc2UgaW4gdGhlIGRlZmF1bHQgY2FzZSBvZiBhIHN3aXRjaCB0aGF0IHlvdSB3YW50IHRvIGJlIGZ1bGx5IGV4aGF1c3RpdmUuXG4gKiBVc2luZyB0aGlzIGZ1bmN0aW9uIGZvcmNlcyB0aGUgY29tcGlsZXIgdG8gZW5mb3JjZSBleGhhdXN0aXZpdHkgZHVyaW5nXG4gKiBjb21waWxlLXRpbWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogY29uc3QgbnVtYmVyID0gMTtcbiAqIHN3aXRjaCAobnVtYmVyKSB7XG4gKiAgIGNhc2UgMDpcbiAqICAgICAuLi5cbiAqICAgY2FzZSAxOlxuICogICAgIC4uLlxuICogICBkZWZhdWx0OlxuICogICAgIGFzc2VydEV4aGF1c3RpdmUoc25hcFByZWZpeCk7XG4gKiB9XG4gKiBgYGBcbiAqIEBwYXJhbSBfb2JqZWN0IC0gVGhlIG9iamVjdCBvbiB3aGljaCB0aGUgc3dpdGNoIGlzIGJlaW5nIG9wZXJhdGVkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRFeGhhdXN0aXZlKF9vYmplY3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnJhbmNoIHJlYWNoZWQuIFNob3VsZCBiZSBkZXRlY3RlZCBkdXJpbmcgY29tcGlsYXRpb24uJyk7XG59XG5leHBvcnRzLmFzc2VydEV4aGF1c3RpdmUgPSBhc3NlcnRFeGhhdXN0aXZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXJ0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5iYXNlNjQgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgcHJvdmlkZWQgc3RyaW5nLWJhc2VkIHN0cnVjdCBpcyB2YWxpZCBiYXNlNjQuXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJpbmcgYmFzZWQgc3RydWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBvcHRpb25zIHRvIHNwZWNpYWxpemUgYmFzZTY0IHZhbGlkYXRpb24uIFNlZSB7QGxpbmsgQmFzZTY0T3B0aW9uc30gZG9jdW1lbnRhdGlvbi5cbiAqIEByZXR1cm5zIEEgc3VwZXJzdHJ1Y3QgdmFsaWRhdGluZyBiYXNlNjQuXG4gKi9cbmNvbnN0IGJhc2U2NCA9IChzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgcGFkZGluZ1JlcXVpcmVkID0gKF9hID0gb3B0aW9ucy5wYWRkaW5nUmVxdWlyZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgIGNvbnN0IGNoYXJhY3RlclNldCA9IChfYiA9IG9wdGlvbnMuY2hhcmFjdGVyU2V0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnYmFzZTY0JztcbiAgICBsZXQgbGV0dGVycztcbiAgICBpZiAoY2hhcmFjdGVyU2V0ID09PSAnYmFzZTY0Jykge1xuICAgICAgICBsZXR0ZXJzID0gU3RyaW5nLnJhdyBgW0EtWmEtejAtOStcXC9dYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGNoYXJhY3RlclNldCA9PT0gJ2Jhc2U2NHVybCcpO1xuICAgICAgICBsZXR0ZXJzID0gU3RyaW5nLnJhdyBgWy1fQS1aYS16MC05XWA7XG4gICAgfVxuICAgIGxldCByZTtcbiAgICBpZiAocGFkZGluZ1JlcXVpcmVkKSB7XG4gICAgICAgIHJlID0gbmV3IFJlZ0V4cChgXig/OiR7bGV0dGVyc317NH0pKig/OiR7bGV0dGVyc317M309fCR7bGV0dGVyc317Mn09PSk/JGAsICd1Jyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZSA9IG5ldyBSZWdFeHAoYF4oPzoke2xldHRlcnN9ezR9KSooPzoke2xldHRlcnN9ezIsM318JHtsZXR0ZXJzfXszfT18JHtsZXR0ZXJzfXsyfT09KT8kYCwgJ3UnKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLnBhdHRlcm4pKHN0cnVjdCwgcmUpO1xufTtcbmV4cG9ydHMuYmFzZTY0ID0gYmFzZTY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTY0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVEYXRhVmlldyA9IGV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBleHBvcnRzLnZhbHVlVG9CeXRlcyA9IGV4cG9ydHMuc3RyaW5nVG9CeXRlcyA9IGV4cG9ydHMubnVtYmVyVG9CeXRlcyA9IGV4cG9ydHMuc2lnbmVkQmlnSW50VG9CeXRlcyA9IGV4cG9ydHMuYmlnSW50VG9CeXRlcyA9IGV4cG9ydHMuaGV4VG9CeXRlcyA9IGV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGV4cG9ydHMuYnl0ZXNUb051bWJlciA9IGV4cG9ydHMuYnl0ZXNUb1NpZ25lZEJpZ0ludCA9IGV4cG9ydHMuYnl0ZXNUb0JpZ0ludCA9IGV4cG9ydHMuYnl0ZXNUb0hleCA9IGV4cG9ydHMuYXNzZXJ0SXNCeXRlcyA9IGV4cG9ydHMuaXNCeXRlcyA9IHZvaWQgMDtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuY29uc3QgaGV4XzEgPSByZXF1aXJlKFwiLi9oZXhcIik7XG4vLyAnMCcuY2hhckNvZGVBdCgwKSA9PT0gNDhcbmNvbnN0IEhFWF9NSU5JTVVNX05VTUJFUl9DSEFSQUNURVIgPSA0ODtcbi8vICc5Jy5jaGFyQ29kZUF0KDApID09PSA1N1xuY29uc3QgSEVYX01BWElNVU1fTlVNQkVSX0NIQVJBQ1RFUiA9IDU4O1xuY29uc3QgSEVYX0NIQVJBQ1RFUl9PRkZTRVQgPSA4Nztcbi8qKlxuICogTWVtb2l6ZWQgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGFycmF5IHRvIGJlIHVzZWQgYXMgYSBsb29rdXAgdGFibGUgZm9yXG4gKiBjb252ZXJ0aW5nIGJ5dGVzIHRvIGhleGFkZWNpbWFsIHZhbHVlcy5cbiAqXG4gKiBUaGUgYXJyYXkgaXMgY3JlYXRlZCBsYXppbHkgYW5kIHRoZW4gY2FjaGVkIGZvciBmdXR1cmUgdXNlLiBUaGUgYmVuZWZpdCBvZlxuICogdGhpcyBhcHByb2FjaCBpcyB0aGF0IHRoZSBwZXJmb3JtYW5jZSBvZiBjb252ZXJ0aW5nIGJ5dGVzIHRvIGhleCBpcyBtdWNoXG4gKiBiZXR0ZXIgdGhhbiBpZiB3ZSB3ZXJlIHRvIGNhbGwgYHRvU3RyaW5nKDE2KWAgb24gZWFjaCBieXRlLlxuICpcbiAqIFRoZSBkb3duc2lkZSBpcyB0aGF0IHRoZSBhcnJheSBpcyBjcmVhdGVkIG9uY2UgYW5kIHRoZW4gbmV2ZXIgZ2FyYmFnZVxuICogY29sbGVjdGVkLiBUaGlzIGlzIG5vdCBhIHByb2JsZW0gaW4gcHJhY3RpY2UgYmVjYXVzZSB0aGUgYXJyYXkgaXMgb25seSAyNTZcbiAqIGVsZW1lbnRzIGxvbmcuXG4gKlxuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGxvb2t1cCB0YWJsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXNCdWlsZGVyKCkge1xuICAgIC8vIFRvIGF2b2lkIGlzc3VlcyB3aXRoIHRyZWUgc2hha2luZywgd2UgbmVlZCB0byB1c2UgYSBmdW5jdGlvbiB0byByZXR1cm4gdGhlXG4gICAgLy8gYXJyYXkuIFRoaXMgaXMgYmVjYXVzZSB0aGUgYXJyYXkgaXMgb25seSB1c2VkIGluIHRoZSBgYnl0ZXNUb0hleGAgZnVuY3Rpb25cbiAgICAvLyBhbmQgaWYgd2Ugd2VyZSB0byB1c2UgYSBnbG9iYWwgdmFyaWFibGUsIHRoZSBhcnJheSBtaWdodCBiZSByZW1vdmVkIGJ5IHRoZVxuICAgIC8vIHRyZWUgc2hha2VyLlxuICAgIGNvbnN0IGxvb2t1cFRhYmxlID0gW107XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKGxvb2t1cFRhYmxlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGxvb2t1cFRhYmxlLnB1c2goaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvb2t1cFRhYmxlO1xuICAgIH07XG59XG4vKipcbiAqIEZ1bmN0aW9uIGltcGxlbWVudGF0aW9uIG9mIHRoZSB7QGxpbmsgZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXNCdWlsZGVyfVxuICogZnVuY3Rpb24uXG4gKi9cbmNvbnN0IGdldFByZWNvbXB1dGVkSGV4VmFsdWVzID0gZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXNCdWlsZGVyKCk7XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBgVWludDhBcnJheWAuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGlzQnl0ZXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xufVxuZXhwb3J0cy5pc0J5dGVzID0gaXNCeXRlcztcbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzQnl0ZXModmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShpc0J5dGVzKHZhbHVlKSwgJ1ZhbHVlIG11c3QgYmUgYSBVaW50OEFycmF5LicpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0J5dGVzID0gYXNzZXJ0SXNCeXRlcztcbi8qKlxuICogQ29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnMHgnO1xuICAgIH1cbiAgICBjb25zdCBsb29rdXBUYWJsZSA9IGdldFByZWNvbXB1dGVkSGV4VmFsdWVzKCk7XG4gICAgY29uc3QgaGV4YWRlY2ltYWwgPSBuZXcgQXJyYXkoYnl0ZXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGhleGFkZWNpbWFsW2ldID0gbG9va3VwVGFibGVbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGhleF8xLmFkZDB4KShoZXhhZGVjaW1hbC5qb2luKCcnKSk7XG59XG5leHBvcnRzLmJ5dGVzVG9IZXggPSBieXRlc1RvSGV4O1xuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgYGJpZ2ludGAuXG4gKlxuICogVG8gY29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBudW1iZXJgIGluc3RlYWQsIHVzZSB7QGxpbmsgYnl0ZXNUb051bWJlcn0uXG4gKiBUbyBjb252ZXJ0IGEgdHdvJ3MgY29tcGxlbWVudCBlbmNvZGVkIGBVaW50OEFycmF5YCB0byBhIGBiaWdpbnRgLCB1c2VcbiAqIHtAbGluayBieXRlc1RvU2lnbmVkQmlnSW50fS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIGBiaWdpbnRgLlxuICogQHJldHVybnMgVGhlIGBiaWdpbnRgLlxuICovXG5mdW5jdGlvbiBieXRlc1RvQmlnSW50KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgY29uc3QgaGV4YWRlY2ltYWwgPSBieXRlc1RvSGV4KGJ5dGVzKTtcbiAgICByZXR1cm4gQmlnSW50KGhleGFkZWNpbWFsKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb0JpZ0ludCA9IGJ5dGVzVG9CaWdJbnQ7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBzaWduZWQgYGJpZ2ludGAuIFRoaXMgYXNzdW1lcyB0aGF0IHRoZSBieXRlcyBhcmVcbiAqIGVuY29kZWQgaW4gdHdvJ3MgY29tcGxlbWVudC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGFuIHVuc2lnbmVkIGBiaWdpbnRgIGluc3RlYWQsIHVzZVxuICoge0BsaW5rIGJ5dGVzVG9CaWdJbnR9LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHdvJTI3c19jb21wbGVtZW50XG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIHNpZ25lZCBgYmlnaW50YC5cbiAqIEByZXR1cm5zIFRoZSBzaWduZWQgYGJpZ2ludGAuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9TaWduZWRCaWdJbnQoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICBsZXQgdmFsdWUgPSBCaWdJbnQoMCk7XG4gICAgZm9yIChjb25zdCBieXRlIG9mIGJ5dGVzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIHZhbHVlID0gKHZhbHVlIDw8IEJpZ0ludCg4KSkgKyBCaWdJbnQoYnl0ZSk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQuYXNJbnROKGJ5dGVzLmxlbmd0aCAqIDgsIHZhbHVlKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb1NpZ25lZEJpZ0ludCA9IGJ5dGVzVG9TaWduZWRCaWdJbnQ7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBgbnVtYmVyYC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgYGJpZ2ludGAgaW5zdGVhZCwgdXNlIHtAbGluayBieXRlc1RvQmlnSW50fS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIG51bWJlci5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIuXG4gKiBAdGhyb3dzIElmIHRoZSByZXN1bHRpbmcgbnVtYmVyIGlzIG5vdCBhIHNhZmUgaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb051bWJlcihieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIGNvbnN0IGJpZ2ludCA9IGJ5dGVzVG9CaWdJbnQoYnl0ZXMpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGJpZ2ludCA8PSBCaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpLCAnTnVtYmVyIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBieXRlc1RvQmlnSW50YCBpbnN0ZWFkLicpO1xuICAgIHJldHVybiBOdW1iZXIoYmlnaW50KTtcbn1cbmV4cG9ydHMuYnl0ZXNUb051bWJlciA9IGJ5dGVzVG9OdW1iZXI7XG4vKipcbiAqIENvbnZlcnQgYSBVVEYtOCBlbmNvZGVkIGBVaW50OEFycmF5YCB0byBhIGBzdHJpbmdgLlxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjb252ZXJ0IHRvIGEgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xufVxuZXhwb3J0cy5ieXRlc1RvU3RyaW5nID0gYnl0ZXNUb1N0cmluZztcbi8qKlxuICogQ29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIGBVaW50OEFycmF5YC4gVGhlIHN0cmluZyBjYW4gb3B0aW9uYWxseSBiZVxuICogcHJlZml4ZWQgd2l0aCBgMHhgLiBJdCBhY2NlcHRzIGV2ZW4gYW5kIG9kZCBsZW5ndGggc3RyaW5ncy5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgXCIweFwiLCBhbiBlbXB0eSBgVWludDhBcnJheWAgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gaGV4VG9CeXRlcyh2YWx1ZSkge1xuICAgIHZhciBfYTtcbiAgICAvLyBcIjB4XCIgaXMgb2Z0ZW4gdXNlZCBhcyBlbXB0eSBieXRlIGFycmF5LlxuICAgIGlmICgoKF9hID0gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLnRvTG93ZXJDYXNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh2YWx1ZSkpID09PSAnMHgnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICAoMCwgaGV4XzEuYXNzZXJ0SXNIZXhTdHJpbmcpKHZhbHVlKTtcbiAgICAvLyBSZW1vdmUgdGhlIGAweGAgcHJlZml4IGlmIGl0IGV4aXN0cywgYW5kIHBhZCB0aGUgc3RyaW5nIHRvIGhhdmUgYW4gZXZlblxuICAgIC8vIG51bWJlciBvZiBjaGFyYWN0ZXJzLlxuICAgIGNvbnN0IHN0cmlwcGVkVmFsdWUgPSAoMCwgaGV4XzEucmVtb3ZlMHgpKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZSA9IHN0cmlwcGVkVmFsdWUubGVuZ3RoICUgMiA9PT0gMCA/IHN0cmlwcGVkVmFsdWUgOiBgMCR7c3RyaXBwZWRWYWx1ZX1gO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobm9ybWFsaXplZFZhbHVlLmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gV2hpbGUgdGhpcyBpcyBub3QgdGhlIHByZXR0aWVzdCB3YXkgdG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhXG4gICAgICAgIC8vIGBVaW50OEFycmF5YCwgaXQgaXMgYSBsb3QgZmFzdGVyIHRoYW4gdXNpbmcgYHBhcnNlSW50YCB0byBjb252ZXJ0IGVhY2hcbiAgICAgICAgLy8gY2hhcmFjdGVyLlxuICAgICAgICBjb25zdCBjMSA9IG5vcm1hbGl6ZWRWYWx1ZS5jaGFyQ29kZUF0KGkgKiAyKTtcbiAgICAgICAgY29uc3QgYzIgPSBub3JtYWxpemVkVmFsdWUuY2hhckNvZGVBdChpICogMiArIDEpO1xuICAgICAgICBjb25zdCBuMSA9IGMxIC1cbiAgICAgICAgICAgIChjMSA8IEhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA/IEhFWF9NSU5JTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA6IEhFWF9DSEFSQUNURVJfT0ZGU0VUKTtcbiAgICAgICAgY29uc3QgbjIgPSBjMiAtXG4gICAgICAgICAgICAoYzIgPCBIRVhfTUFYSU1VTV9OVU1CRVJfQ0hBUkFDVEVSXG4gICAgICAgICAgICAgICAgPyBIRVhfTUlOSU1VTV9OVU1CRVJfQ0hBUkFDVEVSXG4gICAgICAgICAgICAgICAgOiBIRVhfQ0hBUkFDVEVSX09GRlNFVCk7XG4gICAgICAgIGJ5dGVzW2ldID0gbjEgKiAxNiArIG4yO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYGJpZ2ludGAgdG8gYSBgVWludDhBcnJheWAuXG4gKlxuICogVGhpcyBhc3N1bWVzIHRoYXQgdGhlIGBiaWdpbnRgIGlzIGFuIHVuc2lnbmVkIGludGVnZXIuIFRvIGNvbnZlcnQgYSBzaWduZWRcbiAqIGBiaWdpbnRgIGluc3RlYWQsIHVzZSB7QGxpbmsgc2lnbmVkQmlnSW50VG9CeXRlc30uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGJpZ2ludCB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmlnSW50VG9CeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcsICdWYWx1ZSBtdXN0IGJlIGEgYmlnaW50LicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IEJpZ0ludCgwKSwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgYmlnaW50LicpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXhUb0J5dGVzKGhleGFkZWNpbWFsKTtcbn1cbmV4cG9ydHMuYmlnSW50VG9CeXRlcyA9IGJpZ0ludFRvQnl0ZXM7XG4vKipcbiAqIENoZWNrIGlmIGEgYGJpZ2ludGAgZml0cyBpbiBhIGNlcnRhaW4gbnVtYmVyIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBgYmlnaW50YCB0byBjaGVjay5cbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBudW1iZXIgb2YgYnl0ZXMuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBgYmlnaW50YCBmaXRzIGluIHRoZSBudW1iZXIgb2YgYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIGJpZ0ludEZpdHModmFsdWUsIGJ5dGVzKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYnl0ZXMgPiAwKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gICAgY29uc3QgbWFzayA9IHZhbHVlID4+IEJpZ0ludCgzMSk7XG4gICAgcmV0dXJuICEoKCh+dmFsdWUgJiBtYXNrKSArICh2YWx1ZSAmIH5tYXNrKSkgPj4gQmlnSW50KGJ5dGVzICogOCArIH4wKSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1iaXR3aXNlICovXG59XG4vKipcbiAqIENvbnZlcnQgYSBzaWduZWQgYGJpZ2ludGAgdG8gYSBgVWludDhBcnJheWAuIFRoaXMgdXNlcyB0d28ncyBjb21wbGVtZW50XG4gKiBlbmNvZGluZyB0byByZXByZXNlbnQgbmVnYXRpdmUgbnVtYmVycy5cbiAqXG4gKiBUbyBjb252ZXJ0IGFuIHVuc2lnbmVkIGBiaWdpbnRgIHRvIGEgYFVpbnQ4QXJyYXlgIGluc3RlYWQsIHVzZVxuICoge0BsaW5rIGJpZ0ludFRvQnl0ZXN9LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHdvJTI3c19jb21wbGVtZW50XG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcGFyYW0gYnl0ZUxlbmd0aCAtIFRoZSBsZW5ndGggb2YgdGhlIHJlc3VsdGluZyBgVWludDhBcnJheWAuIElmIHRoZSBudW1iZXJcbiAqIGlzIGxhcmdlciB0aGFuIHRoZSBtYXhpbXVtIHZhbHVlIHRoYXQgY2FuIGJlIHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiBsZW5ndGgsXG4gKiBhbiBlcnJvciBpcyB0aHJvd24uXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBzaWduZWRCaWdJbnRUb0J5dGVzKHZhbHVlLCBieXRlTGVuZ3RoKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JywgJ1ZhbHVlIG11c3QgYmUgYSBiaWdpbnQuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIGJ5dGVMZW5ndGggPT09ICdudW1iZXInLCAnQnl0ZSBsZW5ndGggbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShieXRlTGVuZ3RoID4gMCwgJ0J5dGUgbGVuZ3RoIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYmlnSW50Rml0cyh2YWx1ZSwgYnl0ZUxlbmd0aCksICdCeXRlIGxlbmd0aCBpcyB0b28gc21hbGwgdG8gcmVwcmVzZW50IHRoZSBnaXZlbiB2YWx1ZS4nKTtcbiAgICAvLyBFU0xpbnQgZG9lc24ndCBsaWtlIG11dGF0aW5nIGZ1bmN0aW9uIHBhcmFtZXRlcnMsIHNvIHRvIGF2b2lkIGhhdmluZyB0b1xuICAgIC8vIGRpc2FibGUgdGhlIHJ1bGUsIHdlIGNyZWF0ZSBhIG5ldyB2YXJpYWJsZS5cbiAgICBsZXQgbnVtYmVyVmFsdWUgPSB2YWx1ZTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBOdW1iZXIoQmlnSW50LmFzVWludE4oOCwgbnVtYmVyVmFsdWUpKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgbnVtYmVyVmFsdWUgPj49IEJpZ0ludCg4KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzLnJldmVyc2UoKTtcbn1cbmV4cG9ydHMuc2lnbmVkQmlnSW50VG9CeXRlcyA9IHNpZ25lZEJpZ0ludFRvQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgbnVtYmVyYCB0byBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICogQHRocm93cyBJZiB0aGUgbnVtYmVyIGlzIG5vdCBhIHNhZmUgaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gbnVtYmVyVG9CeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdWYWx1ZSBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IDAsICdWYWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSksICdWYWx1ZSBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgYmlnSW50VG9CeXRlc2AgaW5zdGVhZC4nKTtcbiAgICBjb25zdCBoZXhhZGVjaW1hbCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhoZXhhZGVjaW1hbCk7XG59XG5leHBvcnRzLm51bWJlclRvQnl0ZXMgPSBudW1iZXJUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYHN0cmluZ2AgdG8gYSBVVEYtOCBlbmNvZGVkIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJywgJ1ZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG59XG5leHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBzdHJpbmdUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYnl0ZS1saWtlIHZhbHVlIHRvIGEgYFVpbnQ4QXJyYXlgLiBUaGUgdmFsdWUgY2FuIGJlIGEgYFVpbnQ4QXJyYXlgLFxuICogYSBgYmlnaW50YCwgYSBgbnVtYmVyYCwgb3IgYSBgc3RyaW5nYC5cbiAqXG4gKiBUaGlzIHdpbGwgYXR0ZW1wdCB0byBndWVzcyB0aGUgdHlwZSBvZiB0aGUgdmFsdWUgYmFzZWQgb24gaXRzIHR5cGUgYW5kXG4gKiBjb250ZW50cy4gRm9yIG1vcmUgY29udHJvbCBvdmVyIHRoZSBjb252ZXJzaW9uLCB1c2UgdGhlIG1vcmUgc3BlY2lmaWNcbiAqIGNvbnZlcnNpb24gZnVuY3Rpb25zLCBzdWNoIGFzIHtAbGluayBoZXhUb0J5dGVzfSBvciB7QGxpbmsgc3RyaW5nVG9CeXRlc30uXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIGEgYHN0cmluZ2AsIGFuZCBpdCBpcyBwcmVmaXhlZCB3aXRoIGAweGAsIGl0IHdpbGwgYmVcbiAqIGludGVycHJldGVkIGFzIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBPdGhlcndpc2UsIGl0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgYVxuICogVVRGLTggc3RyaW5nLiBUbyBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGJ5dGVzIHdpdGhvdXQgaW50ZXJwcmV0aW5nXG4gKiBpdCBhcyBhIFVURi04IHN0cmluZywgdXNlIHtAbGluayBoZXhUb0J5dGVzfSBpbnN0ZWFkLlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyBhIGBiaWdpbnRgLCBpdCBpcyBhc3N1bWVkIHRvIGJlIHVuc2lnbmVkLiBUbyBjb252ZXJ0IGEgc2lnbmVkXG4gKiBgYmlnaW50YCB0byBieXRlcywgdXNlIHtAbGluayBzaWduZWRCaWdJbnRUb0J5dGVzfSBpbnN0ZWFkLlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YCwgaXQgd2lsbCBiZSByZXR1cm5lZCBhcy1pcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIHZhbHVlVG9CeXRlcyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHJldHVybiBiaWdJbnRUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlclRvQnl0ZXModmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGlzQnl0ZXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdmFsdWUgdHlwZTogXCIke3R5cGVvZiB2YWx1ZX1cIi5gKTtcbn1cbmV4cG9ydHMudmFsdWVUb0J5dGVzID0gdmFsdWVUb0J5dGVzO1xuLyoqXG4gKiBDb25jYXRlbmF0ZSBtdWx0aXBsZSBieXRlLWxpa2UgdmFsdWVzIGludG8gYSBzaW5nbGUgYFVpbnQ4QXJyYXlgLiBUaGUgdmFsdWVzXG4gKiBjYW4gYmUgYFVpbnQ4QXJyYXlgLCBgYmlnaW50YCwgYG51bWJlcmAsIG9yIGBzdHJpbmdgLiBUaGlzIHVzZXNcbiAqIHtAbGluayB2YWx1ZVRvQnl0ZXN9IHVuZGVyIHRoZSBob29kIHRvIGNvbnZlcnQgZWFjaCB2YWx1ZSB0byBieXRlcy4gUmVmZXIgdG9cbiAqIHRoZSBkb2N1bWVudGF0aW9uIG9mIHRoYXQgZnVuY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gKiBAcmV0dXJucyBUaGUgY29uY2F0ZW5hdGVkIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29uY2F0Qnl0ZXModmFsdWVzKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlcyA9IG5ldyBBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICBsZXQgYnl0ZUxlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZVRvQnl0ZXModmFsdWVzW2ldKTtcbiAgICAgICAgbm9ybWFsaXplZFZhbHVlc1tpXSA9IHZhbHVlO1xuICAgICAgICBieXRlTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShieXRlTGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IG5vcm1hbGl6ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gV2hpbGUgd2UgY291bGQgc2ltcGx5IHNwcmVhZCB0aGUgdmFsdWVzIGludG8gYW4gYXJyYXkgYW5kIHVzZVxuICAgICAgICAvLyBgVWludDhBcnJheS5mcm9tYCwgdGhhdCBpcyBhIGxvdCBzbG93ZXIgdGhhbiB1c2luZyBgVWludDhBcnJheS5zZXRgLlxuICAgICAgICBieXRlcy5zZXQobm9ybWFsaXplZFZhbHVlc1tpXSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IG5vcm1hbGl6ZWRWYWx1ZXNbaV0ubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnRzLmNvbmNhdEJ5dGVzID0gY29uY2F0Qnl0ZXM7XG4vKipcbiAqIENyZWF0ZSBhIHtAbGluayBEYXRhVmlld30gZnJvbSBhIHtAbGluayBVaW50OEFycmF5fS4gVGhpcyBpcyBhIGNvbnZlbmllbmNlXG4gKiBmdW5jdGlvbiB0aGF0IGF2b2lkcyBoYXZpbmcgdG8gY3JlYXRlIGEge0BsaW5rIERhdGFWaWV3fSBtYW51YWxseSwgd2hpY2hcbiAqIHJlcXVpcmVzIHBhc3NpbmcgdGhlIGBieXRlT2Zmc2V0YCBhbmQgYGJ5dGVMZW5ndGhgIHBhcmFtZXRlcnMgZXZlcnkgdGltZS5cbiAqXG4gKiBOb3QgcGFzc2luZyB0aGUgYGJ5dGVPZmZzZXRgIGFuZCBgYnl0ZUxlbmd0aGAgcGFyYW1ldGVycyBjYW4gcmVzdWx0IGluXG4gKiB1bmV4cGVjdGVkIGJlaGF2aW9yIHdoZW4gdGhlIHtAbGluayBVaW50OEFycmF5fSBpcyBhIHZpZXcgb2YgYSBsYXJnZXJcbiAqIHtAbGluayBBcnJheUJ1ZmZlcn0sIGUuZy4sIHdoZW4gdXNpbmcge0BsaW5rIFVpbnQ4QXJyYXkuc3ViYXJyYXl9LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYWxzbyBzdXBwb3J0cyBOb2RlLmpzIHtAbGluayBCdWZmZXJ9cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShbMSwgMiwgM10pO1xuICpcbiAqIC8vIFRoaXMgaXMgZXF1aXZhbGVudCB0bzpcbiAqIC8vIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gKiBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZURhdGFWaWV3KGJ5dGVzKTtcbiAqIGBgYFxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNyZWF0ZSB0aGUge0BsaW5rIERhdGFWaWV3fSBmcm9tLlxuICogQHJldHVybnMgVGhlIHtAbGluayBEYXRhVmlld30uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURhdGFWaWV3KGJ5dGVzKSB7XG4gICAgLy8gVG8gbWFpbnRhaW4gY29tcGF0aWJpbGl0eSB3aXRoIE5vZGUuanMsIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIGJ5dGVzIGFyZVxuICAgIC8vIGEgQnVmZmVyLiBJZiBzbywgd2UgbmVlZCB0byBzbGljZSB0aGUgYnVmZmVyIHRvIGdldCB0aGUgdW5kZXJseWluZ1xuICAgIC8vIEFycmF5QnVmZmVyLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgYnl0ZXMgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gYnl0ZXMuYnVmZmVyLnNsaWNlKGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVPZmZzZXQgKyBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aCk7XG59XG5leHBvcnRzLmNyZWF0ZURhdGFWaWV3ID0gY3JlYXRlRGF0YVZpZXc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hlY2tzdW1TdHJ1Y3QgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYmFzZTY0XzEgPSByZXF1aXJlKFwiLi9iYXNlNjRcIik7XG5leHBvcnRzLkNoZWNrc3VtU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEuc2l6ZSkoKDAsIGJhc2U2NF8xLmJhc2U2NCkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCB7IHBhZGRpbmdSZXF1aXJlZDogdHJ1ZSB9KSwgNDQsIDQ0KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrc3VtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVIZXggPSBleHBvcnRzLmNyZWF0ZUJ5dGVzID0gZXhwb3J0cy5jcmVhdGVCaWdJbnQgPSBleHBvcnRzLmNyZWF0ZU51bWJlciA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbmNvbnN0IGhleF8xID0gcmVxdWlyZShcIi4vaGV4XCIpO1xuY29uc3QgTnVtYmVyTGlrZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbKDAsIHN1cGVyc3RydWN0XzEubnVtYmVyKSgpLCAoMCwgc3VwZXJzdHJ1Y3RfMS5iaWdpbnQpKCksICgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgaGV4XzEuU3RyaWN0SGV4U3RydWN0XSk7XG5jb25zdCBOdW1iZXJDb2VyY2VyID0gKDAsIHN1cGVyc3RydWN0XzEuY29lcmNlKSgoMCwgc3VwZXJzdHJ1Y3RfMS5udW1iZXIpKCksIE51bWJlckxpa2VTdHJ1Y3QsIE51bWJlcik7XG5jb25zdCBCaWdJbnRDb2VyY2VyID0gKDAsIHN1cGVyc3RydWN0XzEuY29lcmNlKSgoMCwgc3VwZXJzdHJ1Y3RfMS5iaWdpbnQpKCksIE51bWJlckxpa2VTdHJ1Y3QsIEJpZ0ludCk7XG5jb25zdCBCeXRlc0xpa2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoW2hleF8xLlN0cmljdEhleFN0cnVjdCwgKDAsIHN1cGVyc3RydWN0XzEuaW5zdGFuY2UpKFVpbnQ4QXJyYXkpXSk7XG5jb25zdCBCeXRlc0NvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKCgwLCBzdXBlcnN0cnVjdF8xLmluc3RhbmNlKShVaW50OEFycmF5KSwgKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFtoZXhfMS5TdHJpY3RIZXhTdHJ1Y3RdKSwgYnl0ZXNfMS5oZXhUb0J5dGVzKTtcbmNvbnN0IEhleENvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKGhleF8xLlN0cmljdEhleFN0cnVjdCwgKDAsIHN1cGVyc3RydWN0XzEuaW5zdGFuY2UpKFVpbnQ4QXJyYXkpLCBieXRlc18xLmJ5dGVzVG9IZXgpO1xuLyoqXG4gKiBDcmVhdGUgYSBudW1iZXIgZnJvbSBhIG51bWJlci1saWtlIHZhbHVlLlxuICpcbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgbnVtYmVyLCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgYGJpZ2ludGAsIGl0IGlzIGNvbnZlcnRlZCB0byBhIG51bWJlci5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLCBpdCBpcyBpbnRlcnByZXRlZCBhcyBhIGRlY2ltYWwgbnVtYmVyLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpc1xuICogaW50ZXJwcmV0ZWQgYXMgYSBoZXhhZGVjaW1hbCBudW1iZXIuXG4gKlxuICogVGhpcyB2YWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaXMgYSBudW1iZXItbGlrZSB2YWx1ZSwgYW5kIHRoYXQgdGhlIHJlc3VsdGluZ1xuICogbnVtYmVyIGlzIG5vdCBgTmFOYCBvciBgSW5maW5pdHlgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCB2YWx1ZSA9IGNyZWF0ZU51bWJlcignMHgwMTAyMDMnKTtcbiAqIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gNjYwNTFcbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlTnVtYmVyKDEyM24pO1xuICogY29uc29sZS5sb2cob3RoZXJWYWx1ZSk7IC8vIDEyM1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY3JlYXRlIHRoZSBudW1iZXIgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIG51bWJlci5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIG51bWJlci1saWtlIHZhbHVlLCBvciBpZiB0aGUgcmVzdWx0aW5nIG51bWJlclxuICogaXMgYE5hTmAgb3IgYEluZmluaXR5YC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTnVtYmVyKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKSh2YWx1ZSwgTnVtYmVyQ29lcmNlcik7XG4gICAgICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc0Zpbml0ZShyZXN1bHQpLCBgRXhwZWN0ZWQgYSBudW1iZXItbGlrZSB2YWx1ZSwgZ290IFwiJHt2YWx1ZX1cIi5gKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBudW1iZXItbGlrZSB2YWx1ZSwgZ290IFwiJHt2YWx1ZX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZU51bWJlciA9IGNyZWF0ZU51bWJlcjtcbi8qKlxuICogQ3JlYXRlIGEgYGJpZ2ludGAgZnJvbSBhIG51bWJlci1saWtlIHZhbHVlLlxuICpcbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgbnVtYmVyLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBgYmlnaW50YC5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgYGJpZ2ludGAsIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGl0IGlzIGludGVycHJldGVkIGFzIGEgZGVjaW1hbCBudW1iZXIgYW5kXG4gKiBjb252ZXJ0ZWQgdG8gYSBgYmlnaW50YC5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgaGV4IHN0cmluZyAoaS5lLiwgaXQgc3RhcnRzIHdpdGggXCIweFwiKSwgaXQgaXNcbiAqIGludGVycHJldGVkIGFzIGEgaGV4YWRlY2ltYWwgbnVtYmVyIGFuZCBjb252ZXJ0ZWQgdG8gYSBgYmlnaW50YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgdmFsdWUgPSBjcmVhdGVCaWdJbnQoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vIDE2OTA5MDYwblxuICpcbiAqIGNvbnN0IG90aGVyVmFsdWUgPSBjcmVhdGVCaWdJbnQoMTIzKTtcbiAqIGNvbnNvbGUubG9nKG90aGVyVmFsdWUpOyAvLyAxMjNuXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjcmVhdGUgdGhlIGJpZ2ludCBmcm9tLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgYmlnaW50LlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJpZ0ludCh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFRoZSBgQmlnSW50YCBjb25zdHJ1Y3RvciB0aHJvd3MgaWYgdGhlIHZhbHVlIGlzIG5vdCBhIG51bWJlci1saWtlIHZhbHVlLlxuICAgICAgICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIHZhbGlkYXRlIHRoZSB2YWx1ZSBtYW51YWxseS5cbiAgICAgICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmNyZWF0ZSkodmFsdWUsIEJpZ0ludENvZXJjZXIpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2Ygc3VwZXJzdHJ1Y3RfMS5TdHJ1Y3RFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG51bWJlci1saWtlIHZhbHVlLCBnb3QgXCIke1N0cmluZyhlcnJvci52YWx1ZSl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVCaWdJbnQgPSBjcmVhdGVCaWdJbnQ7XG4vKipcbiAqIENyZWF0ZSBhIGJ5dGUgYXJyYXkgZnJvbSBhIGJ5dGVzLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBieXRlIGFycmF5LCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgaGV4IHN0cmluZyAoaS5lLiwgaXQgc3RhcnRzIHdpdGggXCIweFwiKSwgaXQgaXMgaW50ZXJwcmV0ZWRcbiAqIGFzIGEgaGV4YWRlY2ltYWwgbnVtYmVyIGFuZCBjb252ZXJ0ZWQgdG8gYSBieXRlIGFycmF5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCB2YWx1ZSA9IGNyZWF0ZUJ5dGVzKCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2codmFsdWUpOyAvLyBVaW50OEFycmF5IFsgMSwgMiwgMyBdXG4gKlxuICogY29uc3Qgb3RoZXJWYWx1ZSA9IGNyZWF0ZUJ5dGVzKCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2cob3RoZXJWYWx1ZSk7IC8vIFVpbnQ4QXJyYXkgWyAxLCAyLCAzIF1cbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgYnl0ZSBhcnJheSBmcm9tLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgYnl0ZSBhcnJheS5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIGJ5dGVzLWxpa2UgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ5dGVzKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJzB4Jykge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmNyZWF0ZSkodmFsdWUsIEJ5dGVzQ29lcmNlcik7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBzdXBlcnN0cnVjdF8xLlN0cnVjdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgYnl0ZXMtbGlrZSB2YWx1ZSwgZ290IFwiJHtTdHJpbmcoZXJyb3IudmFsdWUpfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlQnl0ZXMgPSBjcmVhdGVCeXRlcztcbi8qKlxuICogQ3JlYXRlIGEgaGV4YWRlY2ltYWwgc3RyaW5nIGZyb20gYSBieXRlcy1saWtlIHZhbHVlLlxuICpcbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgaGV4IHN0cmluZyAoaS5lLiwgaXQgc3RhcnRzIHdpdGggXCIweFwiKSwgaXQgaXMgcmV0dXJuZWRcbiAqIGFzLWlzLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBgVWludDhBcnJheWAsIGl0IGlzIGNvbnZlcnRlZCB0byBhIGhleCBzdHJpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlSGV4KG5ldyBVaW50OEFycmF5KFsxLCAyLCAzXSkpO1xuICogY29uc29sZS5sb2codmFsdWUpOyAvLyAnMHgwMTAyMDMnXG4gKlxuICogY29uc3Qgb3RoZXJWYWx1ZSA9IGNyZWF0ZUhleCgnMHgwMTAyMDMnKTtcbiAqIGNvbnNvbGUubG9nKG90aGVyVmFsdWUpOyAvLyAnMHgwMTAyMDMnXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjcmVhdGUgdGhlIGhleCBzdHJpbmcgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGhleCBzdHJpbmcuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBieXRlcy1saWtlIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVIZXgodmFsdWUpIHtcbiAgICBpZiAoKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICcweCcpKSB7XG4gICAgICAgIHJldHVybiAnMHgnO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKSh2YWx1ZSwgSGV4Q29lcmNlcik7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBzdXBlcnN0cnVjdF8xLlN0cnVjdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgYnl0ZXMtbGlrZSB2YWx1ZSwgZ290IFwiJHtTdHJpbmcoZXJyb3IudmFsdWUpfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlSGV4ID0gY3JlYXRlSGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29lcmNlcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0Zyb3plbk1hcF9tYXAsIF9Gcm96ZW5TZXRfc2V0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Gcm96ZW5TZXQgPSBleHBvcnRzLkZyb3plbk1hcCA9IHZvaWQgMDtcbi8qKlxuICogQSB7QGxpbmsgUmVhZG9ubHlNYXB9IHRoYXQgY2Fubm90IGJlIG1vZGlmaWVkIGFmdGVyIGluc3RhbnRpYXRpb24uXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gdXNlcyBhbiBpbm5lciBtYXAgaGlkZGVuIHZpYSBhIHByaXZhdGUgZmllbGQsIGFuZCB0aGVcbiAqIGltbXV0YWJpbGl0eSBndWFyYW50ZWUgcmVsaWVzIG9uIGl0IGJlaW5nIGltcG9zc2libGUgdG8gZ2V0IGEgcmVmZXJlbmNlXG4gKiB0byB0aGlzIG1hcC5cbiAqL1xuY2xhc3MgRnJvemVuTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihlbnRyaWVzKSB7XG4gICAgICAgIF9Gcm96ZW5NYXBfbWFwLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBuZXcgTWFwKGVudHJpZXMpLCBcImZcIik7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLnNpemU7XG4gICAgfVxuICAgIFsoX0Zyb3plbk1hcF9tYXAgPSBuZXcgV2Vha01hcCgpLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuZW50cmllcygpO1xuICAgIH1cbiAgICBmb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSB0byB3cmFwIHRoZSBzcGVjaWZpZWQgY2FsbGJhY2sgaW4gb3JkZXIgdG8gcHJldmVudCBpdCBmcm9tXG4gICAgICAgIC8vIHJlY2VpdmluZyBhIHJlZmVyZW5jZSB0byB0aGUgaW5uZXIgbWFwLlxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLmZvckVhY2goKHZhbHVlLCBrZXksIF9tYXApID0+IGNhbGxiYWNrZm4uY2FsbCh0aGlzQXJnLCB2YWx1ZSwga2V5LCB0aGlzKSk7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5nZXQoa2V5KTtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLmhhcyhrZXkpO1xuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLmtleXMoKTtcbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLnZhbHVlcygpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBGcm96ZW5NYXAoJHt0aGlzLnNpemV9KSB7JHt0aGlzLnNpemUgPiAwXG4gICAgICAgICAgICA/IGAgJHtbLi4udGhpcy5lbnRyaWVzKCldXG4gICAgICAgICAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgJHtTdHJpbmcoa2V5KX0gPT4gJHtTdHJpbmcodmFsdWUpfWApXG4gICAgICAgICAgICAgICAgLmpvaW4oJywgJyl9IGBcbiAgICAgICAgICAgIDogJyd9fWA7XG4gICAgfVxufVxuZXhwb3J0cy5Gcm96ZW5NYXAgPSBGcm96ZW5NYXA7XG4vKipcbiAqIEEge0BsaW5rIFJlYWRvbmx5U2V0fSB0aGF0IGNhbm5vdCBiZSBtb2RpZmllZCBhZnRlciBpbnN0YW50aWF0aW9uLlxuICogVGhlIGltcGxlbWVudGF0aW9uIHVzZXMgYW4gaW5uZXIgc2V0IGhpZGRlbiB2aWEgYSBwcml2YXRlIGZpZWxkLCBhbmQgdGhlXG4gKiBpbW11dGFiaWxpdHkgZ3VhcmFudGVlIHJlbGllcyBvbiBpdCBiZWluZyBpbXBvc3NpYmxlIHRvIGdldCBhIHJlZmVyZW5jZVxuICogdG8gdGhpcyBzZXQuXG4gKi9cbmNsYXNzIEZyb3plblNldCB7XG4gICAgY29uc3RydWN0b3IodmFsdWVzKSB7XG4gICAgICAgIF9Gcm96ZW5TZXRfc2V0LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBuZXcgU2V0KHZhbHVlcyksIFwiZlwiKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikuc2l6ZTtcbiAgICB9XG4gICAgWyhfRnJvemVuU2V0X3NldCA9IG5ldyBXZWFrTWFwKCksIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5lbnRyaWVzKCk7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICAvLyBXZSBoYXZlIHRvIHdyYXAgdGhlIHNwZWNpZmllZCBjYWxsYmFjayBpbiBvcmRlciB0byBwcmV2ZW50IGl0IGZyb21cbiAgICAgICAgLy8gcmVjZWl2aW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBpbm5lciBzZXQuXG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikuZm9yRWFjaCgodmFsdWUsIHZhbHVlMiwgX3NldCkgPT4gY2FsbGJhY2tmbi5jYWxsKHRoaXNBcmcsIHZhbHVlLCB2YWx1ZTIsIHRoaXMpKTtcbiAgICB9XG4gICAgaGFzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikuaGFzKHZhbHVlKTtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5rZXlzKCk7XG4gICAgfVxuICAgIHZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS52YWx1ZXMoKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgRnJvemVuU2V0KCR7dGhpcy5zaXplfSkgeyR7dGhpcy5zaXplID4gMFxuICAgICAgICAgICAgPyBgICR7Wy4uLnRoaXMudmFsdWVzKCldLm1hcCgobWVtYmVyKSA9PiBTdHJpbmcobWVtYmVyKSkuam9pbignLCAnKX0gYFxuICAgICAgICAgICAgOiAnJ319YDtcbiAgICB9XG59XG5leHBvcnRzLkZyb3plblNldCA9IEZyb3plblNldDtcbk9iamVjdC5mcmVlemUoRnJvemVuTWFwKTtcbk9iamVjdC5mcmVlemUoRnJvemVuTWFwLnByb3RvdHlwZSk7XG5PYmplY3QuZnJlZXplKEZyb3plblNldCk7XG5PYmplY3QuZnJlZXplKEZyb3plblNldC5wcm90b3R5cGUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sbGVjdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlbW92ZTB4ID0gZXhwb3J0cy5hZGQweCA9IGV4cG9ydHMuYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmcgPSBleHBvcnRzLmFzc2VydElzSGV4U3RyaW5nID0gZXhwb3J0cy5pc1N0cmljdEhleFN0cmluZyA9IGV4cG9ydHMuaXNIZXhTdHJpbmcgPSBleHBvcnRzLlN0cmljdEhleFN0cnVjdCA9IGV4cG9ydHMuSGV4U3RydWN0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuZXhwb3J0cy5IZXhTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5wYXR0ZXJuKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIC9eKD86MHgpP1swLTlhLWZdKyQvaXUpO1xuZXhwb3J0cy5TdHJpY3RIZXhTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5wYXR0ZXJuKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIC9eMHhbMC05YS1mXSskL2l1KTtcbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBoZXggc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkhleFN0cnVjdCk7XG59XG5leHBvcnRzLmlzSGV4U3RyaW5nID0gaXNIZXhTdHJpbmc7XG4vKipcbiAqIFN0cmljdGx5IGNoZWNrIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgaGV4IHN0cmluZy4gQSB2YWxpZCBoZXggc3RyaW5nIG11c3RcbiAqIHN0YXJ0IHdpdGggdGhlIFwiMHhcIi1wcmVmaXguXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdEhleFN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuU3RyaWN0SGV4U3RydWN0KTtcbn1cbmV4cG9ydHMuaXNTdHJpY3RIZXhTdHJpbmcgPSBpc1N0cmljdEhleFN0cmluZztcbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNIZXhTdHJpbmcodmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShpc0hleFN0cmluZyh2YWx1ZSksICdWYWx1ZSBtdXN0IGJlIGEgaGV4YWRlY2ltYWwgc3RyaW5nLicpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0hleFN0cmluZyA9IGFzc2VydElzSGV4U3RyaW5nO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgaGV4IHN0cmluZy4gQSB2YWxpZCBoZXggc3RyaW5nIG11c3Qgc3RhcnQgd2l0aFxuICogdGhlIFwiMHhcIi1wcmVmaXguXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmcodmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShpc1N0cmljdEhleFN0cmluZyh2YWx1ZSksICdWYWx1ZSBtdXN0IGJlIGEgaGV4YWRlY2ltYWwgc3RyaW5nLCBzdGFydGluZyB3aXRoIFwiMHhcIi4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmcgPSBhc3NlcnRJc1N0cmljdEhleFN0cmluZztcbi8qKlxuICogQWRkIHRoZSBgMHhgLXByZWZpeCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy4gSWYgdGhlIHN0cmluZyBhbHJlYWR5IGhhcyB0aGVcbiAqIHByZWZpeCwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKlxuICogQHBhcmFtIGhleGFkZWNpbWFsIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBhZGQgdGhlIHByZWZpeCB0by5cbiAqIEByZXR1cm5zIFRoZSBwcmVmaXhlZCBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGFkZDB4KGhleGFkZWNpbWFsKSB7XG4gICAgaWYgKGhleGFkZWNpbWFsLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgcmV0dXJuIGhleGFkZWNpbWFsO1xuICAgIH1cbiAgICBpZiAoaGV4YWRlY2ltYWwuc3RhcnRzV2l0aCgnMFgnKSkge1xuICAgICAgICByZXR1cm4gYDB4JHtoZXhhZGVjaW1hbC5zdWJzdHJpbmcoMil9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAweCR7aGV4YWRlY2ltYWx9YDtcbn1cbmV4cG9ydHMuYWRkMHggPSBhZGQweDtcbi8qKlxuICogUmVtb3ZlIHRoZSBgMHhgLXByZWZpeCBmcm9tIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBJZiB0aGUgc3RyaW5nIGRvZXNuJ3QgaGF2ZVxuICogdGhlIHByZWZpeCwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKlxuICogQHBhcmFtIGhleGFkZWNpbWFsIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byByZW1vdmUgdGhlIHByZWZpeCBmcm9tLlxuICogQHJldHVybnMgVGhlIHVuLXByZWZpeGVkIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlMHgoaGV4YWRlY2ltYWwpIHtcbiAgICBpZiAoaGV4YWRlY2ltYWwuc3RhcnRzV2l0aCgnMHgnKSB8fCBoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcwWCcpKSB7XG4gICAgICAgIHJldHVybiBoZXhhZGVjaW1hbC5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiBoZXhhZGVjaW1hbDtcbn1cbmV4cG9ydHMucmVtb3ZlMHggPSByZW1vdmUweDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc2VydFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZTY0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ieXRlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2hlY2tzdW1cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvZXJjZXJzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2xsZWN0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaGV4XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9qc29uXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9sb2dnaW5nXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9taXNjXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9udW1iZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL29wYXF1ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdGltZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmVyc2lvbnNcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlSnNvbkFuZEdldFNpemUgPSBleHBvcnRzLmdldEpzb25ScGNJZFZhbGlkYXRvciA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjRXJyb3IgPSBleHBvcnRzLmlzSnNvblJwY0Vycm9yID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNGYWlsdXJlID0gZXhwb3J0cy5pc0pzb25ScGNGYWlsdXJlID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNTdWNjZXNzID0gZXhwb3J0cy5pc0pzb25ScGNTdWNjZXNzID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNSZXNwb25zZSA9IGV4cG9ydHMuaXNKc29uUnBjUmVzcG9uc2UgPSBleHBvcnRzLmFzc2VydElzUGVuZGluZ0pzb25ScGNSZXNwb25zZSA9IGV4cG9ydHMuaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlID0gZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNGYWlsdXJlU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCA9IGV4cG9ydHMuUGVuZGluZ0pzb25ScGNSZXNwb25zZVN0cnVjdCA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjUmVxdWVzdCA9IGV4cG9ydHMuaXNKc29uUnBjUmVxdWVzdCA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjTm90aWZpY2F0aW9uID0gZXhwb3J0cy5pc0pzb25ScGNOb3RpZmljYXRpb24gPSBleHBvcnRzLkpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjUGFyYW1zU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QgPSBleHBvcnRzLmpzb25ycGMyID0gZXhwb3J0cy5pc1ZhbGlkSnNvbiA9IGV4cG9ydHMuSnNvblN0cnVjdCA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbmNvbnN0IG1pc2NfMSA9IHJlcXVpcmUoXCIuL21pc2NcIik7XG5leHBvcnRzLkpzb25TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5kZWZpbmUpKCdKc29uJywgKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgW2lzVmFsaWRdID0gdmFsaWRhdGVKc29uQW5kR2V0U2l6ZSh2YWx1ZSwgdHJ1ZSk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgIHJldHVybiAnRXhwZWN0ZWQgYSB2YWxpZCBKU09OLXNlcmlhbGl6YWJsZSB2YWx1ZSc7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29ufSB2YWx1ZSwgaS5lLiwgYSB2YWx1ZSB0aGF0IGlzXG4gKiBzZXJpYWxpemFibGUgdG8gSlNPTi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29ufSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEpzb24odmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1ZhbGlkSnNvbiA9IGlzVmFsaWRKc29uO1xuLyoqXG4gKiBUaGUgc3RyaW5nICcyLjAnLlxuICovXG5leHBvcnRzLmpzb25ycGMyID0gJzIuMCc7XG5leHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEubGl0ZXJhbCkoZXhwb3J0cy5qc29ucnBjMik7XG5leHBvcnRzLkpzb25ScGNJZFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm51bGxhYmxlKSgoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoWygwLCBzdXBlcnN0cnVjdF8xLm51bWJlcikoKSwgKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpXSkpO1xuZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vYmplY3QpKHtcbiAgICBjb2RlOiAoMCwgc3VwZXJzdHJ1Y3RfMS5pbnRlZ2VyKSgpLFxuICAgIG1lc3NhZ2U6ICgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSxcbiAgICBkYXRhOiAoMCwgc3VwZXJzdHJ1Y3RfMS5vcHRpb25hbCkoZXhwb3J0cy5Kc29uU3RydWN0KSxcbiAgICBzdGFjazogKDAsIHN1cGVyc3RydWN0XzEub3B0aW9uYWwpKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSksXG59KTtcbmV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKSgoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoWygwLCBzdXBlcnN0cnVjdF8xLnJlY29yZCkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCBleHBvcnRzLkpzb25TdHJ1Y3QpLCAoMCwgc3VwZXJzdHJ1Y3RfMS5hcnJheSkoZXhwb3J0cy5Kc29uU3RydWN0KV0pKTtcbmV4cG9ydHMuSnNvblJwY1JlcXVlc3RTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vYmplY3QpKHtcbiAgICBpZDogZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QsXG4gICAganNvbnJwYzogZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgICBtZXRob2Q6ICgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSxcbiAgICBwYXJhbXM6IGV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub21pdCkoZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCwgWydpZCddKTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufVxuICogb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNOb3RpZmljYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNOb3RpZmljYXRpb24gPSBpc0pzb25ScGNOb3RpZmljYXRpb247XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbih2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyBub3RpZmljYXRpb24nLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb24gPSBhc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb247XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXF1ZXN0fSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1JlcXVlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjUmVxdWVzdCA9IGlzSnNvblJwY1JlcXVlc3Q7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBKU09OLVJQQyByZXF1ZXN0IG9yIG5vdGlmaWNhdGlvbiB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1JlcXVlc3R9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjUmVxdWVzdCh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgcmVxdWVzdCcsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1JlcXVlc3QgPSBhc3NlcnRJc0pzb25ScGNSZXF1ZXN0O1xuZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KSh7XG4gICAgaWQ6IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgcmVzdWx0OiAoMCwgc3VwZXJzdHJ1Y3RfMS5vcHRpb25hbCkoKDAsIHN1cGVyc3RydWN0XzEudW5rbm93bikoKSksXG4gICAgZXJyb3I6ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKShleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCksXG59KTtcbmV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vYmplY3QpKHtcbiAgICBpZDogZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QsXG4gICAganNvbnJwYzogZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgICByZXN1bHQ6IGV4cG9ydHMuSnNvblN0cnVjdCxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9iamVjdCkoe1xuICAgIGlkOiBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCxcbiAgICBqc29ucnBjOiBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIGVycm9yOiBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoW1xuICAgIGV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QsXG4gICAgZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCxcbl0pO1xuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIHdoZXRoZXIgc3BlY2lmaWVkIEpTT04tUlBDIHJlc3BvbnNlIGlzIGFcbiAqIHtAbGluayBQZW5kaW5nSnNvblJwY1Jlc3BvbnNlfS5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgSlNPTi1SUEMgcmVzcG9uc2UgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgSlNPTi1SUEMgcmVzcG9uc2UgaXMgcGVuZGluZy5cbiAqL1xuZnVuY3Rpb24gaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKShyZXNwb25zZSwgZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlID0gaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgUGVuZGluZ0pzb25ScGNSZXNwb25zZX0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBKU09OLVJQQyByZXNwb25zZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgUGVuZGluZ0pzb25ScGNSZXNwb25zZX1cbiAqIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHJlc3BvbnNlLCBleHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QsICdJbnZhbGlkIHBlbmRpbmcgSlNPTi1SUEMgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBhc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHtAbGluayBKc29uUnBjUmVzcG9uc2V9LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBvYmplY3QgaXMgYSBKc29uUnBjUmVzcG9uc2UuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKShyZXNwb25zZSwgZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNSZXNwb25zZSA9IGlzSnNvblJwY1Jlc3BvbnNlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1Jlc3BvbnNlfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVzcG9uc2V9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY1Jlc3BvbnNlU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1Jlc3BvbnNlID0gYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNTdWNjZXNzfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1N1Y2Nlc3ModmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjU3VjY2VzcyA9IGlzSnNvblJwY1N1Y2Nlc3M7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1N1Y2Nlc3N9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjU3VjY2Vzcyh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgc3VjY2VzcyByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1N1Y2Nlc3MgPSBhc3NlcnRJc0pzb25ScGNTdWNjZXNzO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRmFpbHVyZX0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNGYWlsdXJlKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY0ZhaWx1cmUgPSBpc0pzb25ScGNGYWlsdXJlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNGYWlsdXJlfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY0ZhaWx1cmUodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIGZhaWx1cmUgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNGYWlsdXJlID0gYXNzZXJ0SXNKc29uUnBjRmFpbHVyZTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNFcnJvcih2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjRXJyb3IgPSBpc0pzb25ScGNFcnJvcjtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0Vycm9yfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY0Vycm9yKHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgZXJyb3InLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNFcnJvciA9IGFzc2VydElzSnNvblJwY0Vycm9yO1xuLyoqXG4gKiBHZXRzIGEgZnVuY3Rpb24gZm9yIHZhbGlkYXRpbmcgSlNPTi1SUEMgcmVxdWVzdCAvIHJlc3BvbnNlIGBpZGAgdmFsdWVzLlxuICpcbiAqIEJ5IG1hbmlwdWxhdGluZyB0aGUgb3B0aW9ucyBvZiB0aGlzIGZhY3RvcnksIHlvdSBjYW4gY29udHJvbCB0aGUgYmVoYXZpb3JcbiAqIG9mIHRoZSByZXN1bHRpbmcgdmFsaWRhdG9yIGZvciBzb21lIGVkZ2UgY2FzZXMuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2UgZS5nLlxuICogYG51bGxgIHNob3VsZCBzb21ldGltZXMgYnV0IG5vdCBhbHdheXMgYmUgcGVybWl0dGVkLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgZW1wdHkgc3RyaW5nIChgJydgKSBpcyBhbHdheXMgcGVybWl0dGVkIGJ5IHRoZSBKU09OLVJQQ1xuICogc3BlY2lmaWNhdGlvbiwgYnV0IHRoYXQga2luZCBvZiBzdWNrcyBhbmQgeW91IG1heSB3YW50IHRvIGZvcmJpZCBpdCBpbiBzb21lXG4gKiBpbnN0YW5jZXMgYW55d2F5LlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB0aGVcbiAqIFtKU09OLVJQQyBTcGVjaWZpY2F0aW9uXShodHRwczovL3d3dy5qc29ucnBjLm9yZy9zcGVjaWZpY2F0aW9uKS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIG9wdGlvbnMucGVybWl0RW1wdHlTdHJpbmcgLSBXaGV0aGVyIHRoZSBlbXB0eSBzdHJpbmcgKGkuZS4gYCcnYClcbiAqIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgdmFsaWQgSUQuIERlZmF1bHQ6IGB0cnVlYFxuICogQHBhcmFtIG9wdGlvbnMucGVybWl0RnJhY3Rpb25zIC0gV2hldGhlciBmcmFjdGlvbmFsIG51bWJlcnMgKGUuZy4gYDEuMmApXG4gKiBzaG91bGQgYmUgdHJlYXRlZCBhcyB2YWxpZCBJRHMuIERlZmF1bHQ6IGBmYWxzZWBcbiAqIEBwYXJhbSBvcHRpb25zLnBlcm1pdE51bGwgLSBXaGV0aGVyIGBudWxsYCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHZhbGlkIElELlxuICogRGVmYXVsdDogYHRydWVgXG4gKiBAcmV0dXJucyBUaGUgSlNPTi1SUEMgSUQgdmFsaWRhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRKc29uUnBjSWRWYWxpZGF0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcGVybWl0RW1wdHlTdHJpbmcsIHBlcm1pdEZyYWN0aW9ucywgcGVybWl0TnVsbCB9ID0gT2JqZWN0LmFzc2lnbih7IHBlcm1pdEVtcHR5U3RyaW5nOiB0cnVlLCBwZXJtaXRGcmFjdGlvbnM6IGZhbHNlLCBwZXJtaXROdWxsOiB0cnVlIH0sIG9wdGlvbnMpO1xuICAgIC8qKlxuICAgICAqIFR5cGUgZ3VhcmQgZm9yIHtAbGluayBKc29uUnBjSWR9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIEpTT04tUlBDIElEIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIElEIGlzIHZhbGlkIHBlciB0aGUgb3B0aW9ucyBnaXZlbiB0byB0aGVcbiAgICAgKiBmYWN0b3J5LlxuICAgICAqL1xuICAgIGNvbnN0IGlzVmFsaWRKc29uUnBjSWQgPSAoaWQpID0+IHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKHR5cGVvZiBpZCA9PT0gJ251bWJlcicgJiYgKHBlcm1pdEZyYWN0aW9ucyB8fCBOdW1iZXIuaXNJbnRlZ2VyKGlkKSkpIHx8XG4gICAgICAgICAgICAodHlwZW9mIGlkID09PSAnc3RyaW5nJyAmJiAocGVybWl0RW1wdHlTdHJpbmcgfHwgaWQubGVuZ3RoID4gMCkpIHx8XG4gICAgICAgICAgICAocGVybWl0TnVsbCAmJiBpZCA9PT0gbnVsbCkpO1xuICAgIH07XG4gICAgcmV0dXJuIGlzVmFsaWRKc29uUnBjSWQ7XG59XG5leHBvcnRzLmdldEpzb25ScGNJZFZhbGlkYXRvciA9IGdldEpzb25ScGNJZFZhbGlkYXRvcjtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSB2YWx1ZSBpcyBKU09OIHNlcmlhbGl6YWJsZSBhbmQgY291bnRzIHRoZSB0b3RhbCBudW1iZXJcbiAqIG9mIGJ5dGVzIG5lZWRlZCB0byBzdG9yZSB0aGUgc2VyaWFsaXplZCB2ZXJzaW9uIG9mIHRoZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ganNPYmplY3QgLSBQb3RlbnRpYWwgSlNPTiBzZXJpYWxpemFibGUgb2JqZWN0LlxuICogQHBhcmFtIHNraXBTaXppbmdQcm9jZXNzIC0gU2tpcCBKU09OIHNpemUgY2FsY3VsYXRpb24gKGRlZmF1bHQ6IGZhbHNlKS5cbiAqIEByZXR1cm5zIFR1cGxlIFtpc1ZhbGlkLCBwbGFpblRleHRTaXplSW5CeXRlc10gY29udGFpbmluZyBhIGJvb2xlYW4gdGhhdCBzaWduYWxzIHdoZXRoZXJcbiAqIHRoZSB2YWx1ZSB3YXMgc2VyaWFsaXphYmxlIGFuZCBhIG51bWJlciBvZiBieXRlcyB0aGF0IGl0IHdpbGwgdXNlIHdoZW4gc2VyaWFsaXplZCB0byBKU09OLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUpzb25BbmRHZXRTaXplKGpzT2JqZWN0LCBza2lwU2l6aW5nUHJvY2VzcyA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc2Vlbk9iamVjdHMgPSBuZXcgU2V0KCk7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYSB2YWx1ZSBpcyBKU09OIHNlcmlhbGl6YWJsZSBhbmQgY291bnRzIHRoZSB0b3RhbCBudW1iZXJcbiAgICAgKiBvZiBieXRlcyBuZWVkZWQgdG8gc3RvcmUgdGhlIHNlcmlhbGl6ZWQgdmVyc2lvbiBvZiB0aGUgdmFsdWUuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhlIGVuY29kaW5nIG9mIHRoZSBKU09OIGlzIGRvbmUgaW4gVVRGLTguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBQb3RlbnRpYWwgSlNPTiBzZXJpYWxpemFibGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHNraXBTaXppbmcgLSBTa2lwIEpTT04gc2l6ZSBjYWxjdWxhdGlvbiAoZGVmYXVsdDogZmFsc2UpLlxuICAgICAqIEByZXR1cm5zIFR1cGxlIFtpc1ZhbGlkLCBwbGFpblRleHRTaXplSW5CeXRlc10gY29udGFpbmluZyBhIGJvb2xlYW4gdGhhdCBzaWduYWxzIHdoZXRoZXJcbiAgICAgKiB0aGUgdmFsdWUgd2FzIHNlcmlhbGl6YWJsZSBhbmQgYSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBpdCB3aWxsIHVzZSB3aGVuIHNlcmlhbGl6ZWQgdG8gSlNPTi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRKc29uU2VyaWFsaXphYmxlSW5mbyh2YWx1ZSwgc2tpcFNpemluZykge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtmYWxzZSwgMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFJldHVybiBhbHJlYWR5IHNwZWNpZmllZCBjb25zdGFudCBzaXplIGZvciBudWxsIChzcGVjaWFsIG9iamVjdClcbiAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgc2tpcFNpemluZyA/IDAgOiBtaXNjXzEuSnNvblNpemUuTnVsbF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgYW5kIGNhbGN1bGF0ZSBzaXplcyBmb3IgYmFzaWMgKGFuZCBzb21lIHNwZWNpYWwpIHR5cGVzXG4gICAgICAgIGNvbnN0IHR5cGVPZlZhbHVlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVPZlZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtmYWxzZSwgMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlT2ZWYWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBza2lwU2l6aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKDAsIG1pc2NfMS5jYWxjdWxhdGVTdHJpbmdTaXplKSh2YWx1ZSkgKyBtaXNjXzEuSnNvblNpemUuUXVvdGUgKiAyLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlT2ZWYWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgICAgICAgICAgICAgIGlmIChza2lwU2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgICAgICAgICByZXR1cm4gW3RydWUsIHZhbHVlID09IHRydWUgPyBtaXNjXzEuSnNvblNpemUuVHJ1ZSA6IG1pc2NfMS5Kc29uU2l6ZS5GYWxzZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlT2ZWYWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcFNpemluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3RydWUsIDBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW3RydWUsICgwLCBtaXNjXzEuY2FsY3VsYXRlTnVtYmVyU2l6ZSkodmFsdWUpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChza2lwU2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IEludmFsaWQgZGF0ZXMgd2lsbCBzZXJpYWxpemUgdG8gbnVsbFxuICAgICAgICAgICAgICAgICAgICBpc05hTih2YWx1ZS5nZXREYXRlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG1pc2NfMS5Kc29uU2l6ZS5OdWxsXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG1pc2NfMS5Kc29uU2l6ZS5EYXRlICsgbWlzY18xLkpzb25TaXplLlF1b3RlICogMixcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gW2ZhbHNlLCAwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBvYmplY3QgaXMgbm90IHBsYWluIGFuZCBjYW5ub3QgYmUgc2VyaWFsaXplZCBwcm9wZXJseSxcbiAgICAgICAgLy8gc3RvcCBoZXJlIGFuZCByZXR1cm4gZmFsc2UgZm9yIHNlcmlhbGl6YXRpb25cbiAgICAgICAgaWYgKCEoMCwgbWlzY18xLmlzUGxhaW5PYmplY3QpKHZhbHVlKSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIDBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIENpcmN1bGFyIG9iamVjdCBkZXRlY3Rpb24gKGhhbmRsaW5nKVxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc2FtZSBvYmplY3QgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgaWYgKHNlZW5PYmplY3RzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIDBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBuZXcgb2JqZWN0IHRvIHRoZSBzZWVuIG9iamVjdHMgc2V0XG4gICAgICAgIC8vIE9ubHkgdGhlIHBsYWluIG9iamVjdHMgc2hvdWxkIGJlIGFkZGVkIChQcmltaXRpdmUgdHlwZXMgYXJlIHNraXBwZWQpXG4gICAgICAgIHNlZW5PYmplY3RzLmFkZCh2YWx1ZSk7XG4gICAgICAgIC8vIENvbnRpbnVlIG9iamVjdCBkZWNvbXBvc2l0aW9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLnJlZHVjZSgoc3VtLCBba2V5LCBuZXN0ZWRWYWx1ZV0sIGlkeCwgYXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHByb2Nlc3MgbmV4dCBuZXN0ZWQgb2JqZWN0IG9yIHByaW1pdGl2ZSB0eXBlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICAgICAgICAgICAgICAgICAgbGV0IFt2YWxpZCwgc2l6ZV0gPSBnZXRKc29uU2VyaWFsaXphYmxlSW5mbyhuZXN0ZWRWYWx1ZSwgc2tpcFNpemluZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlNPTiB2YWxpZGF0aW9uIGRpZCBub3QgcGFzcy4gVmFsaWRhdGlvbiBwcm9jZXNzIHN0b3BwZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2lyY3VsYXIgb2JqZWN0IGRldGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBPbmNlIGEgY2hpbGQgbm9kZSBpcyB2aXNpdGVkIGFuZCBwcm9jZXNzZWQgcmVtb3ZlIGl0IGZyb20gdGhlIHNldC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHByZXZlbnQgZmFsc2UgcG9zaXRpdmVzIHdpdGggdGhlIHNhbWUgYWRqYWNlbnQgb2JqZWN0cy5cbiAgICAgICAgICAgICAgICAgICAgc2Vlbk9iamVjdHMuZGVsZXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNraXBTaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE9iamVjdHMgd2lsbCBoYXZlIGJlIHNlcmlhbGl6ZWQgd2l0aCBcImtleVwiOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlcmVmb3JlIHdlIGluY2x1ZGUgdGhlIGtleSBpbiB0aGUgY2FsY3VsYXRpb24gaGVyZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlTaXplID0gQXJyYXkuaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBrZXkubGVuZ3RoICsgbWlzY18xLkpzb25TaXplLkNvbW1hICsgbWlzY18xLkpzb25TaXplLkNvbG9uICogMjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VwYXJhdG9yID0gaWR4IDwgYXJyLmxlbmd0aCAtIDEgPyBtaXNjXzEuSnNvblNpemUuQ29tbWEgOiAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VtICsga2V5U2l6ZSArIHNpemUgKyBzZXBhcmF0b3I7XG4gICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgLy8gU3RhcnRzIGF0IDIgYmVjYXVzZSB0aGUgc2VyaWFsaXplZCBKU09OIHN0cmluZyBkYXRhIChwbGFpbiB0ZXh0KVxuICAgICAgICAgICAgICAgIC8vIHdpbGwgbWluaW1hbGx5IGNvbnRhaW4ge30vW11cbiAgICAgICAgICAgICAgICBza2lwU2l6aW5nID8gMCA6IG1pc2NfMS5Kc29uU2l6ZS5XcmFwcGVyICogMiksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gW2ZhbHNlLCAwXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2V0SnNvblNlcmlhbGl6YWJsZUluZm8oanNPYmplY3QsIHNraXBTaXppbmdQcm9jZXNzKTtcbn1cbmV4cG9ydHMudmFsaWRhdGVKc29uQW5kR2V0U2l6ZSA9IHZhbGlkYXRlSnNvbkFuZEdldFNpemU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVNb2R1bGVMb2dnZXIgPSBleHBvcnRzLmNyZWF0ZVByb2plY3RMb2dnZXIgPSB2b2lkIDA7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBnbG9iYWxMb2dnZXIgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnbWV0YW1hc2snKTtcbi8qKlxuICogQ3JlYXRlcyBhIGxvZ2dlciB2aWEgdGhlIGBkZWJ1Z2AgbGlicmFyeSB3aG9zZSBsb2cgbWVzc2FnZXMgd2lsbCBiZSB0YWdnZWRcbiAqIHVzaW5nIHRoZSBuYW1lIG9mIHlvdXIgcHJvamVjdC4gQnkgZGVmYXVsdCwgc3VjaCBtZXNzYWdlcyB3aWxsIGJlXG4gKiBzdXBwcmVzc2VkLCBidXQgeW91IGNhbiByZXZlYWwgdGhlbSBieSBzZXR0aW5nIHRoZSBgREVCVUdgIGVudmlyb25tZW50XG4gKiB2YXJpYWJsZSB0byBgbWV0YW1hc2s6PHByb2plY3ROYW1lPmAuIFlvdSBjYW4gYWxzbyBzZXQgdGhpcyB2YXJpYWJsZSB0b1xuICogYG1ldGFtYXNrOipgIGlmIHlvdSB3YW50IHRvIHNlZSBsb2cgbWVzc2FnZXMgZnJvbSBhbGwgTWV0YU1hc2sgcHJvamVjdHMgdGhhdFxuICogYXJlIGFsc28gdXNpbmcgdGhpcyBmdW5jdGlvbiB0byBjcmVhdGUgdGhlaXIgbG9nZ2Vycy5cbiAqXG4gKiBAcGFyYW0gcHJvamVjdE5hbWUgLSBUaGUgbmFtZSBvZiB5b3VyIHByb2plY3QuIFRoaXMgc2hvdWxkIGJlIHRoZSBuYW1lIG9mXG4gKiB5b3VyIE5QTSBwYWNrYWdlIGlmIHlvdSdyZSBkZXZlbG9waW5nIG9uZS5cbiAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIGBkZWJ1Z2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb2plY3RMb2dnZXIocHJvamVjdE5hbWUpIHtcbiAgICByZXR1cm4gZ2xvYmFsTG9nZ2VyLmV4dGVuZChwcm9qZWN0TmFtZSk7XG59XG5leHBvcnRzLmNyZWF0ZVByb2plY3RMb2dnZXIgPSBjcmVhdGVQcm9qZWN0TG9nZ2VyO1xuLyoqXG4gKiBDcmVhdGVzIGEgbG9nZ2VyIHZpYSB0aGUgYGRlYnVnYCBsaWJyYXJ5IHdoaWNoIGlzIGRlcml2ZWQgZnJvbSB0aGUgbG9nZ2VyIGZvclxuICogdGhlIHdob2xlIHByb2plY3Qgd2hvc2UgbG9nIG1lc3NhZ2VzIHdpbGwgYmUgdGFnZ2VkIHVzaW5nIHRoZSBuYW1lIG9mIHlvdXJcbiAqIG1vZHVsZS4gQnkgZGVmYXVsdCwgc3VjaCBtZXNzYWdlcyB3aWxsIGJlIHN1cHByZXNzZWQsIGJ1dCB5b3UgY2FuIHJldmVhbCB0aGVtXG4gKiBieSBzZXR0aW5nIHRoZSBgREVCVUdgIGVudmlyb25tZW50IHZhcmlhYmxlIHRvXG4gKiBgbWV0YW1hc2s6PHByb2plY3ROYW1lPjo8bW9kdWxlTmFtZT5gLiBZb3UgY2FuIGFsc28gc2V0IHRoaXMgdmFyaWFibGUgdG9cbiAqIGBtZXRhbWFzazo8cHJvamVjdE5hbWU+OipgIGlmIHlvdSB3YW50IHRvIHNlZSBsb2cgbWVzc2FnZXMgZnJvbSB0aGUgcHJvamVjdCxcbiAqIG9yIGBtZXRhbWFzazoqYCBpZiB5b3Ugd2FudCB0byBzZWUgbG9nIG1lc3NhZ2VzIGZyb20gYWxsIE1ldGFNYXNrIHByb2plY3RzLlxuICpcbiAqIEBwYXJhbSBwcm9qZWN0TG9nZ2VyIC0gVGhlIGxvZ2dlciBjcmVhdGVkIHZpYSB7QGxpbmsgY3JlYXRlUHJvamVjdExvZ2dlcn0uXG4gKiBAcGFyYW0gbW9kdWxlTmFtZSAtIFRoZSBuYW1lIG9mIHlvdXIgbW9kdWxlLiBZb3UgY291bGQgdXNlIHRoZSBuYW1lIG9mIHRoZVxuICogZmlsZSB3aGVyZSB5b3UncmUgdXNpbmcgdGhpcyBsb2dnZXIgb3Igc29tZSBvdGhlciBuYW1lLlxuICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgYGRlYnVnYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9kdWxlTG9nZ2VyKHByb2plY3RMb2dnZXIsIG1vZHVsZU5hbWUpIHtcbiAgICByZXR1cm4gcHJvamVjdExvZ2dlci5leHRlbmQobW9kdWxlTmFtZSk7XG59XG5leHBvcnRzLmNyZWF0ZU1vZHVsZUxvZ2dlciA9IGNyZWF0ZU1vZHVsZUxvZ2dlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dpbmcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vL1xuLy8gVHlwZXNcbi8vXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhbGN1bGF0ZU51bWJlclNpemUgPSBleHBvcnRzLmNhbGN1bGF0ZVN0cmluZ1NpemUgPSBleHBvcnRzLmlzQVNDSUkgPSBleHBvcnRzLmlzUGxhaW5PYmplY3QgPSBleHBvcnRzLkVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCA9IGV4cG9ydHMuSnNvblNpemUgPSBleHBvcnRzLmhhc1Byb3BlcnR5ID0gZXhwb3J0cy5pc09iamVjdCA9IGV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBleHBvcnRzLmlzTm9uRW1wdHlBcnJheSA9IHZvaWQgMDtcbi8vXG4vLyBUeXBlIEd1YXJkc1xuLy9cbi8qKlxuICogQSB7QGxpbmsgTm9uRW1wdHlBcnJheX0gdHlwZSBndWFyZC5cbiAqXG4gKiBAdGVtcGxhdGUgRWxlbWVudCAtIFRoZSBub24tZW1wdHkgYXJyYXkgbWVtYmVyIHR5cGUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIG5vbi1lbXB0eSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gaXNOb25FbXB0eUFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA+IDA7XG59XG5leHBvcnRzLmlzTm9uRW1wdHlBcnJheSA9IGlzTm9uRW1wdHlBcnJheTtcbi8qKlxuICogVHlwZSBndWFyZCBmb3IgXCJudWxsaXNobmVzc1wiLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuLyoqXG4gKiBBIHR5cGUgZ3VhcmQgZm9yIHtAbGluayBSdW50aW1lT2JqZWN0fS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgdmFsdWUgaGFzIGEgcnVudGltZSB0eXBlIG9mIGBvYmplY3RgIGFuZCBpc1xuICogbmVpdGhlciBgbnVsbGAgbm9yIGFuIGBBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odmFsdWUpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuLy9cbi8vIE90aGVyIHV0aWxpdHkgZnVuY3Rpb25zXG4vL1xuLyoqXG4gKiBBIHR5cGUgZ3VhcmQgZm9yIGVuc3VyaW5nIGFuIG9iamVjdCBoYXMgYSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0VG9DaGVjayAtIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBwcm9wZXJ0eSBuYW1lIHRvIGNoZWNrIGZvci5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHNwZWNpZmllZCBvYmplY3QgaGFzIGFuIG93biBwcm9wZXJ0eSB3aXRoIHRoZSBzcGVjaWZpZWRcbiAqIG5hbWUsIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBpdCBpcyBlbnVtZXJhYmxlIG9yIG5vdC5cbiAqL1xuY29uc3QgaGFzUHJvcGVydHkgPSAob2JqZWN0VG9DaGVjaywgbmFtZSkgPT4gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0VG9DaGVjaywgbmFtZSk7XG5leHBvcnRzLmhhc1Byb3BlcnR5ID0gaGFzUHJvcGVydHk7XG4vKipcbiAqIFByZWRlZmluZWQgc2l6ZXMgKGluIEJ5dGVzKSBvZiBzcGVjaWZpYyBwYXJ0cyBvZiBKU09OIHN0cnVjdHVyZS5cbiAqL1xudmFyIEpzb25TaXplO1xuKGZ1bmN0aW9uIChKc29uU2l6ZSkge1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiTnVsbFwiXSA9IDRdID0gXCJOdWxsXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJDb21tYVwiXSA9IDFdID0gXCJDb21tYVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiV3JhcHBlclwiXSA9IDFdID0gXCJXcmFwcGVyXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJUcnVlXCJdID0gNF0gPSBcIlRydWVcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIkZhbHNlXCJdID0gNV0gPSBcIkZhbHNlXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJRdW90ZVwiXSA9IDFdID0gXCJRdW90ZVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiQ29sb25cIl0gPSAxXSA9IFwiQ29sb25cIjtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiRGF0ZVwiXSA9IDI0XSA9IFwiRGF0ZVwiO1xufSkoSnNvblNpemUgPSBleHBvcnRzLkpzb25TaXplIHx8IChleHBvcnRzLkpzb25TaXplID0ge30pKTtcbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHdpdGggcGF0dGVybiBtYXRjaGluZyBmb3IgKHNwZWNpYWwpIGVzY2FwZWQgY2hhcmFjdGVycy5cbiAqL1xuZXhwb3J0cy5FU0NBUEVfQ0hBUkFDVEVSU19SRUdFWFAgPSAvXCJ8XFxcXHxcXG58XFxyfFxcdC9ndTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgVHJ1ZSBpZiBhbiBvYmplY3QgaXMgdGhlIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0LFxuICogZmFsc2UgaWYgdGhlIG9iamVjdCBpcyBub3QgcGxhaW4gKGUuZy4gZnVuY3Rpb24pLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBsZXQgcHJvdG8gPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gcHJvdG87XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuLyoqXG4gKiBDaGVjayBpZiBjaGFyYWN0ZXIgaXMgQVNDSUkuXG4gKlxuICogQHBhcmFtIGNoYXJhY3RlciAtIENoYXJhY3Rlci5cbiAqIEByZXR1cm5zIFRydWUgaWYgYSBjaGFyYWN0ZXIgY29kZSBpcyBBU0NJSSwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBpc0FTQ0lJKGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIuY2hhckNvZGVBdCgwKSA8PSAxMjc7XG59XG5leHBvcnRzLmlzQVNDSUkgPSBpc0FTQ0lJO1xuLyoqXG4gKiBDYWxjdWxhdGUgc3RyaW5nIHNpemUuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gU3RyaW5nIHZhbHVlIHRvIGNhbGN1bGF0ZSBzaXplLlxuICogQHJldHVybnMgTnVtYmVyIG9mIGJ5dGVzIHVzZWQgdG8gc3RvcmUgd2hvbGUgc3RyaW5nIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVTdHJpbmdTaXplKHZhbHVlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHNpemUgPSB2YWx1ZS5zcGxpdCgnJykucmVkdWNlKCh0b3RhbCwgY2hhcmFjdGVyKSA9PiB7XG4gICAgICAgIGlmIChpc0FTQ0lJKGNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgIHJldHVybiB0b3RhbCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsICsgMjtcbiAgICB9LCAwKTtcbiAgICAvLyBBbHNvIGRldGVjdCBjaGFyYWN0ZXJzIHRoYXQgbmVlZCBiYWNrc2xhc2ggZXNjYXBlXG4gICAgcmV0dXJuIHNpemUgKyAoKF9hID0gdmFsdWUubWF0Y2goZXhwb3J0cy5FU0NBUEVfQ0hBUkFDVEVSU19SRUdFWFApKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSkubGVuZ3RoO1xufVxuZXhwb3J0cy5jYWxjdWxhdGVTdHJpbmdTaXplID0gY2FsY3VsYXRlU3RyaW5nU2l6ZTtcbi8qKlxuICogQ2FsY3VsYXRlIHNpemUgb2YgYSBudW1iZXIgb2Z0ZXIgSlNPTiBzZXJpYWxpemF0aW9uLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIE51bWJlciB2YWx1ZSB0byBjYWxjdWxhdGUgc2l6ZS5cbiAqIEByZXR1cm5zIE51bWJlciBvZiBieXRlcyB1c2VkIHRvIHN0b3JlIHdob2xlIG51bWJlciBpbiBKU09OLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVOdW1iZXJTaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCkubGVuZ3RoO1xufVxuZXhwb3J0cy5jYWxjdWxhdGVOdW1iZXJTaXplID0gY2FsY3VsYXRlTnVtYmVyU2l6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pc2MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhleFRvQmlnSW50ID0gZXhwb3J0cy5oZXhUb051bWJlciA9IGV4cG9ydHMuYmlnSW50VG9IZXggPSBleHBvcnRzLm51bWJlclRvSGV4ID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG5jb25zdCBoZXhfMSA9IHJlcXVpcmUoXCIuL2hleFwiKTtcbi8qKlxuICogQ29udmVydCBhIG51bWJlciB0byBhIGhleGFkZWNpbWFsIHN0cmluZy4gVGhpcyB2ZXJpZmllcyB0aGF0IHRoZSBudW1iZXIgaXMgYVxuICogbm9uLW5lZ2F0aXZlIHNhZmUgaW50ZWdlci5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgYGJpZ2ludGAgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcgaW5zdGVhZCwgdXNlXG4gKiB7QGxpbmsgYmlnSW50VG9IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBudW1iZXJUb0hleCgwKTsgLy8gJzB4MCdcbiAqIG51bWJlclRvSGV4KDEpOyAvLyAnMHgxJ1xuICogbnVtYmVyVG9IZXgoMTYpOyAvLyAnMHgxMCdcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIG51bWJlciB0byBjb252ZXJ0IHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIGhleGFkZWNpbWFsIHN0cmluZywgd2l0aCB0aGUgXCIweFwiLXByZWZpeC5cbiAqIEB0aHJvd3MgSWYgdGhlIG51bWJlciBpcyBub3QgYSBub24tbmVnYXRpdmUgc2FmZSBpbnRlZ2VyLlxuICovXG5jb25zdCBudW1iZXJUb0hleCA9ICh2YWx1ZSkgPT4ge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdWYWx1ZSBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IDAsICdWYWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSksICdWYWx1ZSBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgYmlnSW50VG9IZXhgIGluc3RlYWQuJyk7XG4gICAgcmV0dXJuICgwLCBoZXhfMS5hZGQweCkodmFsdWUudG9TdHJpbmcoMTYpKTtcbn07XG5leHBvcnRzLm51bWJlclRvSGV4ID0gbnVtYmVyVG9IZXg7XG4vKipcbiAqIENvbnZlcnQgYSBgYmlnaW50YCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy4gVGhpcyB2ZXJpZmllcyB0aGF0IHRoZSBgYmlnaW50YFxuICogaXMgYSBub24tbmVnYXRpdmUgaW50ZWdlci5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgbnVtYmVyIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nIGluc3RlYWQsIHVzZSB7QGxpbmsgbnVtYmVyVG9IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBiaWdJbnRUb0hleCgwbik7IC8vICcweDAnXG4gKiBiaWdJbnRUb0hleCgxbik7IC8vICcweDEnXG4gKiBiaWdJbnRUb0hleCgxNm4pOyAvLyAnMHgxMCdcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGBiaWdpbnRgIHRvIGNvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nLCB3aXRoIHRoZSBcIjB4XCItcHJlZml4LlxuICogQHRocm93cyBJZiB0aGUgYGJpZ2ludGAgaXMgbm90IGEgbm9uLW5lZ2F0aXZlIGludGVnZXIuXG4gKi9cbmNvbnN0IGJpZ0ludFRvSGV4ID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JywgJ1ZhbHVlIG11c3QgYmUgYSBiaWdpbnQuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodmFsdWUgPj0gMCwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgYmlnaW50LicpO1xuICAgIHJldHVybiAoMCwgaGV4XzEuYWRkMHgpKHZhbHVlLnRvU3RyaW5nKDE2KSk7XG59O1xuZXhwb3J0cy5iaWdJbnRUb0hleCA9IGJpZ0ludFRvSGV4O1xuLyoqXG4gKiBDb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgbnVtYmVyLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIHN0cmluZyBpcyBhXG4gKiB2YWxpZCBoZXggc3RyaW5nLCBhbmQgdGhhdCB0aGUgcmVzdWx0aW5nIG51bWJlciBpcyBhIHNhZmUgaW50ZWdlci4gQm90aFxuICogXCIweFwiLXByZWZpeGVkIGFuZCB1bnByZWZpeGVkIHN0cmluZ3MgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgYGJpZ2ludGAgaW5zdGVhZCwgdXNlXG4gKiB7QGxpbmsgaGV4VG9CaWdJbnR9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBoZXhUb051bWJlcignMHgwJyk7IC8vIDBcbiAqIGhleFRvTnVtYmVyKCcweDEnKTsgLy8gMVxuICogaGV4VG9OdW1iZXIoJzB4MTAnKTsgLy8gMTZcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0IHRvIGEgbnVtYmVyLlxuICogQHJldHVybnMgVGhlIG51bWJlci5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGhleGFkZWNpbWFsIHN0cmluZywgb3IgaWYgdGhlIHJlc3VsdGluZ1xuICogbnVtYmVyIGlzIG5vdCBhIHNhZmUgaW50ZWdlci5cbiAqL1xuY29uc3QgaGV4VG9OdW1iZXIgPSAodmFsdWUpID0+IHtcbiAgICAoMCwgaGV4XzEuYXNzZXJ0SXNIZXhTdHJpbmcpKHZhbHVlKTtcbiAgICAvLyBgcGFyc2VJbnRgIGFjY2VwdHMgdmFsdWVzIHdpdGhvdXQgdGhlIFwiMHhcIi1wcmVmaXgsIHdoZXJlYXMgYE51bWJlcmAgZG9lc1xuICAgIC8vIG5vdC4gVXNpbmcgdGhpcyBpcyBzbGlnaHRseSBmYXN0ZXIgdGhhbiBgTnVtYmVyKGFkZDB4KHZhbHVlKSlgLlxuICAgIGNvbnN0IG51bWJlclZhbHVlID0gcGFyc2VJbnQodmFsdWUsIDE2KTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShOdW1iZXIuaXNTYWZlSW50ZWdlcihudW1iZXJWYWx1ZSksICdWYWx1ZSBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgaGV4VG9CaWdJbnRgIGluc3RlYWQuJyk7XG4gICAgcmV0dXJuIG51bWJlclZhbHVlO1xufTtcbmV4cG9ydHMuaGV4VG9OdW1iZXIgPSBoZXhUb051bWJlcjtcbi8qKlxuICogQ29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIGBiaWdpbnRgLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIHN0cmluZyBpc1xuICogYSB2YWxpZCBoZXggc3RyaW5nLiBCb3RoIFwiMHhcIi1wcmVmaXhlZCBhbmQgdW5wcmVmaXhlZCBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQuXG4gKlxuICogVG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIG51bWJlciBpbnN0ZWFkLCB1c2Uge0BsaW5rIGhleFRvTnVtYmVyfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaGV4VG9CaWdJbnQoJzB4MCcpOyAvLyAwblxuICogaGV4VG9CaWdJbnQoJzB4MScpOyAvLyAxblxuICogaGV4VG9CaWdJbnQoJzB4MTAnKTsgLy8gMTZuXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydCB0byBhIGBiaWdpbnRgLlxuICogQHJldHVybnMgVGhlIGBiaWdpbnRgLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5jb25zdCBoZXhUb0JpZ0ludCA9ICh2YWx1ZSkgPT4ge1xuICAgICgwLCBoZXhfMS5hc3NlcnRJc0hleFN0cmluZykodmFsdWUpO1xuICAgIC8vIFRoZSBgQmlnSW50YCBjb25zdHJ1Y3RvciByZXF1aXJlcyB0aGUgXCIweFwiLXByZWZpeCB0byBwYXJzZSBhIGhleCBzdHJpbmcuXG4gICAgcmV0dXJuIEJpZ0ludCgoMCwgaGV4XzEuYWRkMHgpKHZhbHVlKSk7XG59O1xuZXhwb3J0cy5oZXhUb0JpZ0ludCA9IGhleFRvQmlnSW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3BhcXVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50aW1lU2luY2UgPSBleHBvcnRzLmluTWlsbGlzZWNvbmRzID0gZXhwb3J0cy5EdXJhdGlvbiA9IHZvaWQgMDtcbi8qKlxuICogQ29tbW9uIGR1cmF0aW9uIGNvbnN0YW50cywgaW4gbWlsbGlzZWNvbmRzLlxuICovXG52YXIgRHVyYXRpb247XG4oZnVuY3Rpb24gKER1cmF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQSBtaWxsaXNlY29uZC5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIk1pbGxpc2Vjb25kXCJdID0gMV0gPSBcIk1pbGxpc2Vjb25kXCI7XG4gICAgLyoqXG4gICAgICogQSBzZWNvbmQsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIlNlY29uZFwiXSA9IDEwMDBdID0gXCJTZWNvbmRcIjtcbiAgICAvKipcbiAgICAgKiBBIG1pbnV0ZSwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiTWludXRlXCJdID0gNjAwMDBdID0gXCJNaW51dGVcIjtcbiAgICAvKipcbiAgICAgKiBBbiBob3VyLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJIb3VyXCJdID0gMzYwMDAwMF0gPSBcIkhvdXJcIjtcbiAgICAvKipcbiAgICAgKiBBIGRheSwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiRGF5XCJdID0gODY0MDAwMDBdID0gXCJEYXlcIjtcbiAgICAvKipcbiAgICAgKiBBIHdlZWssIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIldlZWtcIl0gPSA2MDQ4MDAwMDBdID0gXCJXZWVrXCI7XG4gICAgLyoqXG4gICAgICogQSB5ZWFyLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJZZWFyXCJdID0gMzE1MzYwMDAwMDBdID0gXCJZZWFyXCI7XG59KShEdXJhdGlvbiA9IGV4cG9ydHMuRHVyYXRpb24gfHwgKGV4cG9ydHMuRHVyYXRpb24gPSB7fSkpO1xuY29uc3QgaXNOb25OZWdhdGl2ZUludGVnZXIgPSAobnVtYmVyKSA9PiBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcikgJiYgbnVtYmVyID49IDA7XG5jb25zdCBhc3NlcnRJc05vbk5lZ2F0aXZlSW50ZWdlciA9IChudW1iZXIsIG5hbWUpID0+IHtcbiAgICBpZiAoIWlzTm9uTmVnYXRpdmVJbnRlZ2VyKG51bWJlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7bmFtZX1cIiBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIuIFJlY2VpdmVkOiBcIiR7bnVtYmVyfVwiLmApO1xuICAgIH1cbn07XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIG1pbGxpc2Vjb25kIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHVuaXRzIG9mIHRpbWUuXG4gKlxuICogQHBhcmFtIGNvdW50IC0gVGhlIG51bWJlciBvZiB1bml0cyBvZiB0aW1lLlxuICogQHBhcmFtIGR1cmF0aW9uIC0gVGhlIHVuaXQgb2YgdGltZSB0byBjb3VudC5cbiAqIEByZXR1cm5zIFRoZSBjb3VudCBtdWx0aXBsaWVkIGJ5IHRoZSBzcGVjaWZpZWQgZHVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGluTWlsbGlzZWNvbmRzKGNvdW50LCBkdXJhdGlvbikge1xuICAgIGFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyKGNvdW50LCAnY291bnQnKTtcbiAgICByZXR1cm4gY291bnQgKiBkdXJhdGlvbjtcbn1cbmV4cG9ydHMuaW5NaWxsaXNlY29uZHMgPSBpbk1pbGxpc2Vjb25kcztcbi8qKlxuICogR2V0cyB0aGUgbWlsbGlzZWNvbmRzIHNpbmNlIGEgcGFydGljdWxhciBVbml4IGVwb2NoIHRpbWVzdGFtcC5cbiAqXG4gKiBAcGFyYW0gdGltZXN0YW1wIC0gQSBVbml4IG1pbGxpc2Vjb25kIHRpbWVzdGFtcC5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGVsYXBzZWQgc2luY2UgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXAuXG4gKi9cbmZ1bmN0aW9uIHRpbWVTaW5jZSh0aW1lc3RhbXApIHtcbiAgICBhc3NlcnRJc05vbk5lZ2F0aXZlSW50ZWdlcih0aW1lc3RhbXAsICd0aW1lc3RhbXAnKTtcbiAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHRpbWVzdGFtcDtcbn1cbmV4cG9ydHMudGltZVNpbmNlID0gdGltZVNpbmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2F0aXNmaWVzVmVyc2lvblJhbmdlID0gZXhwb3J0cy5ndFJhbmdlID0gZXhwb3J0cy5ndFZlcnNpb24gPSBleHBvcnRzLmFzc2VydElzU2VtVmVyUmFuZ2UgPSBleHBvcnRzLmFzc2VydElzU2VtVmVyVmVyc2lvbiA9IGV4cG9ydHMuaXNWYWxpZFNlbVZlclJhbmdlID0gZXhwb3J0cy5pc1ZhbGlkU2VtVmVyVmVyc2lvbiA9IGV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0ID0gZXhwb3J0cy5WZXJzaW9uU3RydWN0ID0gdm9pZCAwO1xuY29uc3Qgc2VtdmVyXzEgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuLyoqXG4gKiBBIHN0cnVjdCBmb3IgdmFsaWRhdGluZyBhIHZlcnNpb24gc3RyaW5nLlxuICovXG5leHBvcnRzLlZlcnNpb25TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5yZWZpbmUpKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgJ1ZlcnNpb24nLCAodmFsdWUpID0+IHtcbiAgICBpZiAoKDAsIHNlbXZlcl8xLnZhbGlkKSh2YWx1ZSkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCBTZW1WZXIgdmVyc2lvbiwgZ290IFwiJHt2YWx1ZX1cImA7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufSk7XG5leHBvcnRzLlZlcnNpb25SYW5nZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnJlZmluZSkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAnVmVyc2lvbiByYW5nZScsICh2YWx1ZSkgPT4ge1xuICAgIGlmICgoMCwgc2VtdmVyXzEudmFsaWRSYW5nZSkodmFsdWUpID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBgRXhwZWN0ZWQgU2VtVmVyIHJhbmdlLCBnb3QgXCIke3ZhbHVlfVwiYDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBTZW1WZXIgdmVyc2lvbiBpcyB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbiAtIEEgcG90ZW50aWFsIHZlcnNpb24uXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZlcnNpb24gaXMgdmFsaWQsIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFNlbVZlclZlcnNpb24odmVyc2lvbikge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmVyc2lvbiwgZXhwb3J0cy5WZXJzaW9uU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNWYWxpZFNlbVZlclZlcnNpb24gPSBpc1ZhbGlkU2VtVmVyVmVyc2lvbjtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBTZW1WZXIgdmVyc2lvbiByYW5nZSBpcyB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvblJhbmdlIC0gQSBwb3RlbnRpYWwgdmVyc2lvbiByYW5nZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVyc2lvbiByYW5nZSBpcyB2YWxpZCwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU2VtVmVyUmFuZ2UodmVyc2lvblJhbmdlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2ZXJzaW9uUmFuZ2UsIGV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNWYWxpZFNlbVZlclJhbmdlID0gaXNWYWxpZFNlbVZlclJhbmdlO1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIGNvbmNyZXRlIFNlbVZlciB2ZXJzaW9uLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gQSBwb3RlbnRpYWwgU2VtVmVyIGNvbmNyZXRlIHZlcnNpb24uXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzU2VtVmVyVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmVyc2lvbiwgZXhwb3J0cy5WZXJzaW9uU3RydWN0KTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNTZW1WZXJWZXJzaW9uID0gYXNzZXJ0SXNTZW1WZXJWZXJzaW9uO1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIFNlbVZlciByYW5nZS5cbiAqXG4gKiBAcGFyYW0gcmFuZ2UgLSBBIHBvdGVudGlhbCBTZW1WZXIgcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzU2VtVmVyUmFuZ2UocmFuZ2UpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KShyYW5nZSwgZXhwb3J0cy5WZXJzaW9uUmFuZ2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1NlbVZlclJhbmdlID0gYXNzZXJ0SXNTZW1WZXJSYW5nZTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBTZW1WZXIgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYW5vdGhlci5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbjEgLSBUaGUgbGVmdC1oYW5kIHZlcnNpb24uXG4gKiBAcGFyYW0gdmVyc2lvbjIgLSBUaGUgcmlnaHQtaGFuZCB2ZXJzaW9uLlxuICogQHJldHVybnMgYHZlcnNpb24xID4gdmVyc2lvbjJgLlxuICovXG5mdW5jdGlvbiBndFZlcnNpb24odmVyc2lvbjEsIHZlcnNpb24yKSB7XG4gICAgcmV0dXJuICgwLCBzZW12ZXJfMS5ndCkodmVyc2lvbjEsIHZlcnNpb24yKTtcbn1cbmV4cG9ydHMuZ3RWZXJzaW9uID0gZ3RWZXJzaW9uO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbGwgcG9zc2liaWxpdGllcyBpbiBhIHJhbmdlLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gQSBTZW12VmVyIHZlcnNpb24uXG4gKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIGB2ZXJzaW9uID4gcmFuZ2VgLlxuICovXG5mdW5jdGlvbiBndFJhbmdlKHZlcnNpb24sIHJhbmdlKSB7XG4gICAgcmV0dXJuICgwLCBzZW12ZXJfMS5ndHIpKHZlcnNpb24sIHJhbmdlKTtcbn1cbmV4cG9ydHMuZ3RSYW5nZSA9IGd0UmFuZ2U7XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIHNhdGlzZmllcyBhIFNlbVZlciByYW5nZS5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbiAtIFRoZSBTZW1WZXIgdmVyc2lvbiB0byBjaGVjay5cbiAqIEBwYXJhbSB2ZXJzaW9uUmFuZ2UgLSBUaGUgU2VtVmVyIHZlcnNpb24gcmFuZ2UgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZlcnNpb24gc2F0aXNmaWVkIHRoZSB2ZXJzaW9uIHJhbmdlLlxuICovXG5mdW5jdGlvbiBzYXRpc2ZpZXNWZXJzaW9uUmFuZ2UodmVyc2lvbiwgdmVyc2lvblJhbmdlKSB7XG4gICAgcmV0dXJuICgwLCBzZW12ZXJfMS5zYXRpc2ZpZXMpKHZlcnNpb24sIHZlcnNpb25SYW5nZSwge1xuICAgICAgICBpbmNsdWRlUHJlcmVsZWFzZTogdHJ1ZSxcbiAgICB9KTtcbn1cbmV4cG9ydHMuc2F0aXNmaWVzVmVyc2lvblJhbmdlID0gc2F0aXNmaWVzVmVyc2lvblJhbmdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbnMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBwcm9jZXNzRm4gPSAoZm4sIG9wdHMpID0+IGZ1bmN0aW9uICgpIHtcblx0Y29uc3QgUCA9IG9wdHMucHJvbWlzZU1vZHVsZTtcblx0Y29uc3QgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG5cdH1cblxuXHRyZXR1cm4gbmV3IFAoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdGlmIChvcHRzLmVycm9yRmlyc3QpIHtcblx0XHRcdGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcblx0XHRcdFx0aWYgKG9wdHMubXVsdGlBcmdzKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0cmVzdWx0c1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRcdFx0cmVzdWx0cy51bnNoaWZ0KGVycik7XG5cdFx0XHRcdFx0XHRyZWplY3QocmVzdWx0cyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlc29sdmUocmVzdWx0cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGVycikge1xuXHRcdFx0XHRcdHJlamVjdChlcnIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFyZ3MucHVzaChmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0XHRcdGlmIChvcHRzLm11bHRpQXJncykge1xuXHRcdFx0XHRcdGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHJlc3VsdHNbaV0gPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHRzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHR9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKG9iaiwgb3B0cykgPT4ge1xuXHRvcHRzID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0ZXhjbHVkZTogWy8uKyhTeW5jfFN0cmVhbSkkL10sXG5cdFx0ZXJyb3JGaXJzdDogdHJ1ZSxcblx0XHRwcm9taXNlTW9kdWxlOiBQcm9taXNlXG5cdH0sIG9wdHMpO1xuXG5cdGNvbnN0IGZpbHRlciA9IGtleSA9PiB7XG5cdFx0Y29uc3QgbWF0Y2ggPSBwYXR0ZXJuID0+IHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJyA/IGtleSA9PT0gcGF0dGVybiA6IHBhdHRlcm4udGVzdChrZXkpO1xuXHRcdHJldHVybiBvcHRzLmluY2x1ZGUgPyBvcHRzLmluY2x1ZGUuc29tZShtYXRjaCkgOiAhb3B0cy5leGNsdWRlLnNvbWUobWF0Y2gpO1xuXHR9O1xuXG5cdGxldCByZXQ7XG5cdGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKG9wdHMuZXhjbHVkZU1haW4pIHtcblx0XHRcdFx0cmV0dXJuIG9iai5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcHJvY2Vzc0ZuKG9iaiwgb3B0cykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHJldCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikpO1xuXHR9XG5cblx0Zm9yIChjb25zdCBrZXkgaW4gb2JqKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ3VhcmQtZm9yLWluXG5cdFx0Y29uc3QgeCA9IG9ialtrZXldO1xuXHRcdHJldFtrZXldID0gdHlwZW9mIHggPT09ICdmdW5jdGlvbicgJiYgZmlsdGVyKGtleSkgPyBwcm9jZXNzRm4oeCwgb3B0cykgOiB4O1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWZyb20tZW5naW5lXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcm92aWRlci1mcm9tLW1pZGRsZXdhcmVcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnByb3ZpZGVyRnJvbUVuZ2luZSA9IHZvaWQgMDtcbmNvbnN0IHNhZmVfZXZlbnRfZW1pdHRlcl9wcm92aWRlcl8xID0gcmVxdWlyZShcIi4vc2FmZS1ldmVudC1lbWl0dGVyLXByb3ZpZGVyXCIpO1xuLyoqXG4gKiBDb25zdHJ1Y3QgYW4gRXRoZXJldW0gcHJvdmlkZXIgZnJvbSB0aGUgZ2l2ZW4gSlNPTi1SUEMgZW5naW5lLlxuICpcbiAqIEBwYXJhbSBlbmdpbmUgLSBUaGUgSlNPTi1SUEMgZW5naW5lIHRvIGNvbnN0cnVjdCBhIHByb3ZpZGVyIGZyb20uXG4gKiBAcmV0dXJucyBBbiBFdGhlcmV1bSBwcm92aWRlci5cbiAqL1xuZnVuY3Rpb24gcHJvdmlkZXJGcm9tRW5naW5lKGVuZ2luZSkge1xuICAgIHJldHVybiBuZXcgc2FmZV9ldmVudF9lbWl0dGVyX3Byb3ZpZGVyXzEuU2FmZUV2ZW50RW1pdHRlclByb3ZpZGVyKHsgZW5naW5lIH0pO1xufVxuZXhwb3J0cy5wcm92aWRlckZyb21FbmdpbmUgPSBwcm92aWRlckZyb21FbmdpbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1mcm9tLWVuZ2luZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucHJvdmlkZXJGcm9tTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IHByb3ZpZGVyX2Zyb21fZW5naW5lXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1mcm9tLWVuZ2luZVwiKTtcbi8qKlxuICogQ29uc3RydWN0IGFuIEV0aGVyZXVtIHByb3ZpZGVyIGZyb20gdGhlIGdpdmVuIG1pZGRsZXdhcmUuXG4gKlxuICogQHBhcmFtIG1pZGRsZXdhcmUgLSBUaGUgbWlkZGxld2FyZSB0byBjb25zdHJ1Y3QgYSBwcm92aWRlciBmcm9tLlxuICogQHJldHVybnMgQW4gRXRoZXJldW0gcHJvdmlkZXIuXG4gKi9cbmZ1bmN0aW9uIHByb3ZpZGVyRnJvbU1pZGRsZXdhcmUobWlkZGxld2FyZSkge1xuICAgIGNvbnN0IGVuZ2luZSA9IG5ldyBqc29uX3JwY19lbmdpbmVfMS5Kc29uUnBjRW5naW5lKCk7XG4gICAgZW5naW5lLnB1c2gobWlkZGxld2FyZSk7XG4gICAgY29uc3QgcHJvdmlkZXIgPSAoMCwgcHJvdmlkZXJfZnJvbV9lbmdpbmVfMS5wcm92aWRlckZyb21FbmdpbmUpKGVuZ2luZSk7XG4gICAgcmV0dXJuIHByb3ZpZGVyO1xufVxuZXhwb3J0cy5wcm92aWRlckZyb21NaWRkbGV3YXJlID0gcHJvdmlkZXJGcm9tTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWZyb20tbWlkZGxld2FyZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbnZhciBfU2FmZUV2ZW50RW1pdHRlclByb3ZpZGVyX2VuZ2luZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2FmZUV2ZW50RW1pdHRlclByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3Qgc2FmZV9ldmVudF9lbWl0dGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBtZXRhbWFzay9zYWZlLWV2ZW50LWVtaXR0ZXJcIikpO1xuLyoqXG4gKiBBbiBFdGhlcmV1bSBwcm92aWRlci5cbiAqXG4gKiBUaGlzIHByb3ZpZGVyIGxvb3NlbHkgZm9sbG93cyBjb252ZW50aW9ucyB0aGF0IHByZS1kYXRlIEVJUC0xMTkzLlxuICogSXQgaXMgbm90IGNvbXBsaWFudCB3aXRoIGFueSBFdGhlcmV1bSBwcm92aWRlciBzdGFuZGFyZC5cbiAqL1xuY2xhc3MgU2FmZUV2ZW50RW1pdHRlclByb3ZpZGVyIGV4dGVuZHMgc2FmZV9ldmVudF9lbWl0dGVyXzEuZGVmYXVsdCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgU2FmZUV2ZW50RW1pdHRlclByb3ZpZGVyIGZyb20gYSBKU09OLVJQQyBlbmdpbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZW5naW5lIC0gVGhlIEpTT04tUlBDIGVuZ2luZSB1c2VkIHRvIHByb2Nlc3MgcmVxdWVzdHMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBlbmdpbmUgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBfU2FmZUV2ZW50RW1pdHRlclByb3ZpZGVyX2VuZ2luZS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbmQgYSBwcm92aWRlciByZXF1ZXN0IGFzeW5jaHJvbm91c2x5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcmVxIC0gVGhlIHJlcXVlc3QgdG8gc2VuZC5cbiAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrIC0gQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB1cG9uIHRoZSBzdWNjZXNzIG9yIGZhaWx1cmUgb2YgdGhlIHJlcXVlc3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbmRBc3luYyA9IChyZXEsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TYWZlRXZlbnRFbWl0dGVyUHJvdmlkZXJfZW5naW5lLCBcImZcIikuaGFuZGxlKHJlcSwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VuZCBhIHByb3ZpZGVyIHJlcXVlc3QgYXN5bmNocm9ub3VzbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHNlcnZlcyB0aGUgc2FtZSBwdXJwb3NlIGFzIGBzZW5kQXN5bmNgLiBJdCBvbmx5IGV4aXN0cyBmb3JcbiAgICAgICAgICogbGVnYWN5IHJlYXNvbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBgc2VuZEFzeW5jYCBpbnN0ZWFkLlxuICAgICAgICAgKiBAcGFyYW0gcmVxIC0gVGhlIHJlcXVlc3QgdG8gc2VuZC5cbiAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrIC0gQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB1cG9uIHRoZSBzdWNjZXNzIG9yIGZhaWx1cmUgb2YgdGhlIHJlcXVlc3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbmQgPSAocmVxLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGNhbGxiYWNrIHRvIFwic2VuZFwiIG1ldGhvZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NhZmVFdmVudEVtaXR0ZXJQcm92aWRlcl9lbmdpbmUsIFwiZlwiKS5oYW5kbGUocmVxLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1NhZmVFdmVudEVtaXR0ZXJQcm92aWRlcl9lbmdpbmUsIGVuZ2luZSwgXCJmXCIpO1xuICAgICAgICBpZiAoZW5naW5lLm9uKSB7XG4gICAgICAgICAgICBlbmdpbmUub24oJ25vdGlmaWNhdGlvbicsIChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgbnVsbCwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU2FmZUV2ZW50RW1pdHRlclByb3ZpZGVyID0gU2FmZUV2ZW50RW1pdHRlclByb3ZpZGVyO1xuX1NhZmVFdmVudEVtaXR0ZXJQcm92aWRlcl9lbmdpbmUgPSBuZXcgV2Vha01hcCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FmZS1ldmVudC1lbWl0dGVyLXByb3ZpZGVyLmpzLm1hcCIsImNvbnN0IGVuY3J5cHRvciA9IHJlcXVpcmUoJ0BtZXRhbWFzay9icm93c2VyLXBhc3N3b3JkZXInKTtcbmNvbnN0IEhkS2V5cmluZyA9IHJlcXVpcmUoJ0BtZXRhbWFzay9ldGgtaGQta2V5cmluZycpO1xuY29uc3QgeyBub3JtYWxpemU6IG5vcm1hbGl6ZUFkZHJlc3MgfSA9IHJlcXVpcmUoJ0BtZXRhbWFzay9ldGgtc2lnLXV0aWwnKTtcbmNvbnN0IFNpbXBsZUtleXJpbmcgPSByZXF1aXJlKCdAbWV0YW1hc2svZXRoLXNpbXBsZS1rZXlyaW5nJyk7XG4vLyBUT0RPOiBTdG9wIHVzaW5nIGBldmVudHNgLCBhbmQgcmVtb3ZlIHRoZSBub3RpY2UgYWJvdXQgdGhpcyBmcm9tIHRoZSBSRUFETUVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tbm9kZWpzLW1vZHVsZXNcbmNvbnN0IHsgRXZlbnRFbWl0dGVyIH0gPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IE9ic2VydmFibGVTdG9yZSA9IHJlcXVpcmUoJ29icy1zdG9yZScpO1xuXG5jb25zdCBkZWZhdWx0S2V5cmluZ0J1aWxkZXJzID0gW1xuICBrZXlyaW5nQnVpbGRlckZhY3RvcnkoU2ltcGxlS2V5cmluZyksXG4gIGtleXJpbmdCdWlsZGVyRmFjdG9yeShIZEtleXJpbmcpLFxuXTtcblxuY29uc3QgS0VZUklOR1NfVFlQRV9NQVAgPSB7XG4gIEhEX0tFWVJJTkc6ICdIRCBLZXkgVHJlZScsXG4gIFNJTVBMRV9LRVlSSU5HOiAnU2ltcGxlIEtleSBQYWlyJyxcbn07XG5cbi8qKlxuICogU3RyaXAgdGhlIGhleCBwcmVmaXggZnJvbSBhbiBhZGRyZXNzLCBpZiBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdGhhdCBtaWdodCBiZSBoZXggcHJlZml4ZWQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgYWRkcmVzcyB3aXRob3V0IGEgaGV4IHByZWZpeC5cbiAqL1xuZnVuY3Rpb24gc3RyaXBIZXhQcmVmaXgoYWRkcmVzcykge1xuICBpZiAoYWRkcmVzcy5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgcmV0dXJuIGFkZHJlc3Muc2xpY2UoMik7XG4gIH1cbiAgcmV0dXJuIGFkZHJlc3M7XG59XG5cbmNsYXNzIEtleXJpbmdDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLy9cbiAgLy8gUFVCTElDIE1FVEhPRFNcbiAgLy9cblxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBpbml0U3RhdGUgPSBvcHRzLmluaXRTdGF0ZSB8fCB7fTtcbiAgICB0aGlzLmtleXJpbmdCdWlsZGVycyA9IG9wdHMua2V5cmluZ0J1aWxkZXJzXG4gICAgICA/IGRlZmF1bHRLZXlyaW5nQnVpbGRlcnMuY29uY2F0KG9wdHMua2V5cmluZ0J1aWxkZXJzKVxuICAgICAgOiBkZWZhdWx0S2V5cmluZ0J1aWxkZXJzO1xuICAgIHRoaXMuc3RvcmUgPSBuZXcgT2JzZXJ2YWJsZVN0b3JlKGluaXRTdGF0ZSk7XG4gICAgdGhpcy5tZW1TdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoe1xuICAgICAgaXNVbmxvY2tlZDogZmFsc2UsXG4gICAgICBrZXlyaW5nVHlwZXM6IHRoaXMua2V5cmluZ0J1aWxkZXJzLm1hcChcbiAgICAgICAgKGtleXJpbmdCdWlsZGVyKSA9PiBrZXlyaW5nQnVpbGRlci50eXBlLFxuICAgICAgKSxcbiAgICAgIGtleXJpbmdzOiBbXSxcbiAgICAgIGVuY3J5cHRpb25LZXk6IG51bGwsXG4gICAgfSk7XG5cbiAgICB0aGlzLmVuY3J5cHRvciA9IG9wdHMuZW5jcnlwdG9yIHx8IGVuY3J5cHRvcjtcbiAgICB0aGlzLmtleXJpbmdzID0gW107XG4gICAgdGhpcy5fdW5zdXBwb3J0ZWRLZXlyaW5ncyA9IFtdO1xuXG4gICAgLy8gVGhpcyBvcHRpb24gYWxsb3dzIHRoZSBjb250cm9sbGVyIHRvIGNhY2hlIGFuIGV4cG9ydGVkIGtleVxuICAgIC8vIGZvciB1c2UgaW4gZGVjcnlwdGluZyBhbmQgZW5jcnlwdGluZyBkYXRhIHdpdGhvdXQgcGFzc3dvcmRcbiAgICB0aGlzLmNhY2hlRW5jcnlwdGlvbktleSA9IEJvb2xlYW4ob3B0cy5jYWNoZUVuY3J5cHRpb25LZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZ1bGwgVXBkYXRlXG4gICAqXG4gICAqIEVtaXRzIHRoZSBgdXBkYXRlYCBldmVudCBhbmQgQHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG9cbiAgICogdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAqXG4gICAqIEZyZXF1ZW50bHkgdXNlZCB0byBlbmQgYXN5bmNocm9ub3VzIGNoYWlucyBpbiB0aGlzIGNsYXNzLFxuICAgKiBpbmRpY2F0aW5nIGNvbnN1bWVycyBjYW4gb2Z0ZW4gZWl0aGVyIGxpc3RlbiBmb3IgdXBkYXRlcyxcbiAgICogb3IgYWNjZXB0IGEgc3RhdGUtcmVzb2x2aW5nIHByb21pc2UgdG8gY29uc3VtZSB0aGVpciByZXN1bHRzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgY29udHJvbGxlciBzdGF0ZS5cbiAgICovXG4gIGZ1bGxVcGRhdGUoKSB7XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLm1lbVN0b3JlLmdldFN0YXRlKCkpO1xuICAgIHJldHVybiB0aGlzLm1lbVN0b3JlLmdldFN0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIE5ldyBWYXVsdCBBbmQgS2V5Y2hhaW5cbiAgICpcbiAgICogRGVzdHJveXMgYW55IG9sZCBlbmNyeXB0ZWQgc3RvcmFnZSxcbiAgICogY3JlYXRlcyBhIG5ldyBlbmNyeXB0ZWQgc3RvcmUgd2l0aCB0aGUgZ2l2ZW4gcGFzc3dvcmQsXG4gICAqIHJhbmRvbWx5IGNyZWF0ZXMgYSBuZXcgSEQgd2FsbGV0IHdpdGggMSBhY2NvdW50LFxuICAgKiBmYXVjZXRzIHRoYXQgYWNjb3VudCBvbiB0aGUgdGVzdG5ldC5cbiAgICpcbiAgICogQGZpcmVzIEtleXJpbmdDb250cm9sbGVyI3VubG9ja1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBUaGUgcGFzc3dvcmQgdG8gZW5jcnlwdCB0aGUgdmF1bHQgd2l0aC5cbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHN0YXRlLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlTmV3VmF1bHRBbmRLZXljaGFpbihwYXNzd29yZCkge1xuICAgIHRoaXMucGFzc3dvcmQgPSBwYXNzd29yZDtcblxuICAgIGF3YWl0IHRoaXMuY3JlYXRlRmlyc3RLZXlUcmVlKCk7XG4gICAgdGhpcy5zZXRVbmxvY2tlZCgpO1xuICAgIHJldHVybiB0aGlzLmZ1bGxVcGRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVOZXdWYXVsdEFuZFJlc3RvcmVcbiAgICpcbiAgICogRGVzdHJveXMgYW55IG9sZCBlbmNyeXB0ZWQgc3RvcmFnZSxcbiAgICogY3JlYXRlcyBhIG5ldyBlbmNyeXB0ZWQgc3RvcmUgd2l0aCB0aGUgZ2l2ZW4gcGFzc3dvcmQsXG4gICAqIGNyZWF0ZXMgYSBuZXcgSEQgd2FsbGV0IGZyb20gdGhlIGdpdmVuIHNlZWQgd2l0aCAxIGFjY291bnQuXG4gICAqXG4gICAqIEBmaXJlcyBLZXlyaW5nQ29udHJvbGxlciN1bmxvY2tcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIC0gVGhlIHBhc3N3b3JkIHRvIGVuY3J5cHQgdGhlIHZhdWx0IHdpdGguXG4gICAqIEBwYXJhbSB7VWludDhBcnJheSB8IHN0cmluZ30gc2VlZFBocmFzZSAtIFRoZSBCSVAzOS1jb21wbGlhbnQgc2VlZCBwaHJhc2UsXG4gICAqIGVpdGhlciBhcyBhIHN0cmluZyBvciBVaW50OEFycmF5LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgc3RhdGUuXG4gICAqL1xuICBhc3luYyBjcmVhdGVOZXdWYXVsdEFuZFJlc3RvcmUocGFzc3dvcmQsIHNlZWRQaHJhc2UpIHtcbiAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXNzd29yZCBtdXN0IGJlIHRleHQuJyk7XG4gICAgfVxuICAgIHRoaXMucGFzc3dvcmQgPSBwYXNzd29yZDtcblxuICAgIGF3YWl0IHRoaXMuY2xlYXJLZXlyaW5ncygpO1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmFkZE5ld0tleXJpbmcoS0VZUklOR1NfVFlQRV9NQVAuSERfS0VZUklORywge1xuICAgICAgbW5lbW9uaWM6IHNlZWRQaHJhc2UsXG4gICAgICBudW1iZXJPZkFjY291bnRzOiAxLFxuICAgIH0pO1xuICAgIGNvbnN0IFtmaXJzdEFjY291bnRdID0gYXdhaXQga2V5cmluZy5nZXRBY2NvdW50cygpO1xuXG4gICAgaWYgKCFmaXJzdEFjY291bnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignS2V5cmluZ0NvbnRyb2xsZXIgLSBGaXJzdCBBY2NvdW50IG5vdCBmb3VuZC4nKTtcbiAgICB9XG4gICAgdGhpcy5zZXRVbmxvY2tlZCgpO1xuICAgIHJldHVybiB0aGlzLmZ1bGxVcGRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgTG9ja2VkXG4gICAqIFRoaXMgbWV0aG9kIGRlYWxsb2NhdGVzIGFsbCBzZWNyZXRzLCBhbmQgZWZmZWN0aXZlbHkgbG9ja3MgTWV0YU1hc2suXG4gICAqXG4gICAqIEBmaXJlcyBLZXlyaW5nQ29udHJvbGxlciNsb2NrXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBzdGF0ZS5cbiAgICovXG4gIGFzeW5jIHNldExvY2tlZCgpIHtcbiAgICBkZWxldGUgdGhpcy5wYXNzd29yZDtcblxuICAgIC8vIHNldCBsb2NrZWRcbiAgICB0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIGlzVW5sb2NrZWQ6IGZhbHNlLFxuICAgICAgZW5jcnlwdGlvbktleTogbnVsbCxcbiAgICAgIGVuY3J5cHRpb25TYWx0OiBudWxsLFxuICAgIH0pO1xuXG4gICAgLy8gcmVtb3ZlIGtleXJpbmdzXG4gICAgdGhpcy5rZXlyaW5ncyA9IFtdO1xuICAgIGF3YWl0IHRoaXMuX3VwZGF0ZU1lbVN0b3JlS2V5cmluZ3MoKTtcbiAgICB0aGlzLmVtaXQoJ2xvY2snKTtcbiAgICByZXR1cm4gdGhpcy5mdWxsVXBkYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogU3VibWl0IHBhc3N3b3JkLlxuICAgKlxuICAgKiBBdHRlbXB0cyB0byBkZWNyeXB0IHRoZSBjdXJyZW50IHZhdWx0IGFuZCBsb2FkIGl0cyBrZXlyaW5nc1xuICAgKiBpbnRvIG1lbW9yeS5cbiAgICpcbiAgICogVGVtcG9yYXJpbHkgYWxzbyBtaWdyYXRlcyBhbnkgb2xkLXN0eWxlIHZhdWx0cyBmaXJzdCwgYXMgd2VsbFxuICAgKiAoUHJlIE1ldGFNYXNrIDMuMC4wKS5cbiAgICpcbiAgICogQGZpcmVzIEtleXJpbmdDb250cm9sbGVyI3VubG9ja1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBUaGUga2V5cmluZyBjb250cm9sbGVyIHBhc3N3b3JkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgc3RhdGUuXG4gICAqL1xuICBhc3luYyBzdWJtaXRQYXNzd29yZChwYXNzd29yZCkge1xuICAgIHRoaXMua2V5cmluZ3MgPSBhd2FpdCB0aGlzLnVubG9ja0tleXJpbmdzKHBhc3N3b3JkKTtcblxuICAgIHRoaXMuc2V0VW5sb2NrZWQoKTtcbiAgICByZXR1cm4gdGhpcy5mdWxsVXBkYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogU3VibWl0IEVuY3J5cHRpb24gS2V5LlxuICAgKlxuICAgKiBBdHRlbXB0cyB0byBkZWNyeXB0IHRoZSBjdXJyZW50IHZhdWx0IGFuZCBsb2FkIGl0cyBrZXlyaW5nc1xuICAgKiBpbnRvIG1lbW9yeSBiYXNlZCBvbiB0aGUgdmF1bHQgYW5kIENyeXB0b0tleSBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogQGZpcmVzIEtleXJpbmdDb250cm9sbGVyI3VubG9ja1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZW5jcnlwdGlvbktleSAtIFRoZSBlbmNyeXB0ZWQga2V5IGluZm9ybWF0aW9uIHVzZWQgdG8gZGVjcnlwdCB0aGUgdmF1bHQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbmNyeXB0aW9uU2FsdCAtIFRoZSBzYWx0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGxhc3Qga2V5LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgc3RhdGUuXG4gICAqL1xuICBhc3luYyBzdWJtaXRFbmNyeXB0aW9uS2V5KGVuY3J5cHRpb25LZXksIGVuY3J5cHRpb25TYWx0KSB7XG4gICAgdGhpcy5rZXlyaW5ncyA9IGF3YWl0IHRoaXMudW5sb2NrS2V5cmluZ3MoXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBlbmNyeXB0aW9uS2V5LFxuICAgICAgZW5jcnlwdGlvblNhbHQsXG4gICAgKTtcbiAgICB0aGlzLnNldFVubG9ja2VkKCk7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFVwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSBQYXNzd29yZFxuICAgKlxuICAgKiBBdHRlbXB0cyB0byBkZWNyeXB0IHRoZSBjdXJyZW50IHZhdWx0IHdpdGggYSBnaXZlbiBwYXNzd29yZFxuICAgKiB0byB2ZXJpZnkgaXRzIHZhbGlkaXR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBUaGUgdmF1bHQgcGFzc3dvcmQuXG4gICAqL1xuICBhc3luYyB2ZXJpZnlQYXNzd29yZChwYXNzd29yZCkge1xuICAgIGNvbnN0IGVuY3J5cHRlZFZhdWx0ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLnZhdWx0O1xuICAgIGlmICghZW5jcnlwdGVkVmF1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVubG9jayB3aXRob3V0IGEgcHJldmlvdXMgdmF1bHQuJyk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuZW5jcnlwdG9yLmRlY3J5cHQocGFzc3dvcmQsIGVuY3J5cHRlZFZhdWx0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgTmV3IEtleXJpbmdcbiAgICpcbiAgICogQWRkcyBhIG5ldyBLZXlyaW5nIG9mIHRoZSBnaXZlbiBgdHlwZWAgdG8gdGhlIHZhdWx0XG4gICAqIGFuZCB0aGUgY3VycmVudCBkZWNyeXB0ZWQgS2V5cmluZ3MgYXJyYXkuXG4gICAqXG4gICAqIEFsbCBLZXlyaW5nIGNsYXNzZXMgaW1wbGVtZW50IGEgdW5pcXVlIGB0eXBlYCBzdHJpbmcsXG4gICAqIGFuZCB0aGlzIGlzIHVzZWQgdG8gcmV0cmlldmUgdGhlbSBmcm9tIHRoZSBrZXlyaW5nQnVpbGRlcnMgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2Yga2V5cmluZyB0byBhZGQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIC0gVGhlIGNvbnN0cnVjdG9yIG9wdGlvbnMgZm9yIHRoZSBrZXlyaW5nLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxLZXlyaW5nPn0gVGhlIG5ldyBrZXlyaW5nLlxuICAgKi9cbiAgYXN5bmMgYWRkTmV3S2V5cmluZyh0eXBlLCBvcHRzKSB7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuX25ld0tleXJpbmcodHlwZSwgb3B0cyk7XG5cbiAgICBpZiAoKCFvcHRzIHx8ICFvcHRzLm1uZW1vbmljKSAmJiB0eXBlID09PSBLRVlSSU5HU19UWVBFX01BUC5IRF9LRVlSSU5HKSB7XG4gICAgICBrZXlyaW5nLmdlbmVyYXRlUmFuZG9tTW5lbW9uaWMoKTtcbiAgICAgIGF3YWl0IGtleXJpbmcuYWRkQWNjb3VudHMoKTtcbiAgICB9XG5cbiAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGtleXJpbmcuZ2V0QWNjb3VudHMoKTtcbiAgICBhd2FpdCB0aGlzLmNoZWNrRm9yRHVwbGljYXRlKHR5cGUsIGFjY291bnRzKTtcblxuICAgIHRoaXMua2V5cmluZ3MucHVzaChrZXlyaW5nKTtcbiAgICBhd2FpdCB0aGlzLnBlcnNpc3RBbGxLZXlyaW5ncygpO1xuXG4gICAgdGhpcy5mdWxsVXBkYXRlKCk7XG5cbiAgICByZXR1cm4ga2V5cmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgRW1wdHkgS2V5cmluZ3MuXG4gICAqXG4gICAqIExvb3BzIHRocm91Z2ggdGhlIGtleXJpbmdzIGFuZCByZW1vdmVzIHRoZSBvbmVzIHdpdGggZW1wdHkgYWNjb3VudHNcbiAgICogKHVzdWFsbHkgYWZ0ZXIgcmVtb3ZpbmcgdGhlIGxhc3QgLyBvbmx5IGFjY291bnQpIGZyb20gYSBrZXlyaW5nLlxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlRW1wdHlLZXlyaW5ncygpIHtcbiAgICBjb25zdCB2YWxpZEtleXJpbmdzID0gW107XG5cbiAgICAvLyBTaW5jZSBnZXRBY2NvdW50cyByZXR1cm5zIGEgUHJvbWlzZVxuICAgIC8vIFdlIG5lZWQgdG8gd2FpdCB0byBoZWFyIGJhY2sgZm9ybSBlYWNoIGtleXJpbmdcbiAgICAvLyBpbiBvcmRlciB0byBkZWNpZGUgd2hpY2ggb25lcyBhcmUgbm93IHZhbGlkIChhY2NvdW50cy5sZW5ndGggPiAwKVxuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICB0aGlzLmtleXJpbmdzLm1hcChhc3luYyAoa2V5cmluZykgPT4ge1xuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGtleXJpbmcuZ2V0QWNjb3VudHMoKTtcbiAgICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YWxpZEtleXJpbmdzLnB1c2goa2V5cmluZyk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICk7XG4gICAgdGhpcy5rZXlyaW5ncyA9IHZhbGlkS2V5cmluZ3M7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGZvciBkdXBsaWNhdGUga2V5cGFpcnMsIHVzaW5nIHRoZSB0aGUgZmlyc3QgYWNjb3VudCBpbiB0aGUgZ2l2ZW5cbiAgICogYXJyYXkuIFJlamVjdHMgaWYgYSBkdXBsaWNhdGUgaXMgZm91bmQuXG4gICAqXG4gICAqIE9ubHkgc3VwcG9ydHMgJ1NpbXBsZSBLZXkgUGFpcicuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIGtleSBwYWlyIHR5cGUgdG8gY2hlY2sgZm9yLlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IG5ld0FjY291bnRBcnJheSAtIEFycmF5IG9mIG5ldyBhY2NvdW50cy5cbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8c3RyaW5nPj59IFRoZSBhY2NvdW50LCBpZiBubyBkdXBsaWNhdGUgaXMgZm91bmQuXG4gICAqL1xuICBhc3luYyBjaGVja0ZvckR1cGxpY2F0ZSh0eXBlLCBuZXdBY2NvdW50QXJyYXkpIHtcbiAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudHMoKTtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBLRVlSSU5HU19UWVBFX01BUC5TSU1QTEVfS0VZUklORzoge1xuICAgICAgICBjb25zdCBpc0luY2x1ZGVkID0gQm9vbGVhbihcbiAgICAgICAgICBhY2NvdW50cy5maW5kKFxuICAgICAgICAgICAgKGtleSkgPT5cbiAgICAgICAgICAgICAga2V5ID09PSBuZXdBY2NvdW50QXJyYXlbMF0gfHxcbiAgICAgICAgICAgICAga2V5ID09PSBzdHJpcEhleFByZWZpeChuZXdBY2NvdW50QXJyYXlbMF0pLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGlzSW5jbHVkZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnVGhlIGFjY291bnQgeW91IGFyZSB0cnlpbmcgdG8gaW1wb3J0IGlzIGEgZHVwbGljYXRlJyxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdBY2NvdW50QXJyYXk7XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgcmV0dXJuIG5ld0FjY291bnRBcnJheTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIE5ldyBBY2NvdW50LlxuICAgKlxuICAgKiBDYWxscyB0aGUgYGFkZEFjY291bnRzYCBtZXRob2Qgb24gdGhlIGdpdmVuIGtleXJpbmcsXG4gICAqIGFuZCB0aGVuIHNhdmVzIHRob3NlIGNoYW5nZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5cmluZ30gc2VsZWN0ZWRLZXlyaW5nIC0gVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBrZXlyaW5nLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgc3RhdGUuXG4gICAqL1xuICBhc3luYyBhZGROZXdBY2NvdW50KHNlbGVjdGVkS2V5cmluZykge1xuICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgc2VsZWN0ZWRLZXlyaW5nLmFkZEFjY291bnRzKDEpO1xuICAgIGFjY291bnRzLmZvckVhY2goKGhleEFjY291bnQpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnbmV3QWNjb3VudCcsIGhleEFjY291bnQpO1xuICAgIH0pO1xuXG4gICAgYXdhaXQgdGhpcy5wZXJzaXN0QWxsS2V5cmluZ3MoKTtcbiAgICByZXR1cm4gdGhpcy5mdWxsVXBkYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogRXhwb3J0IEFjY291bnRcbiAgICpcbiAgICogUmVxdWVzdHMgdGhlIHByaXZhdGUga2V5IGZyb20gdGhlIGtleXJpbmcgY29udHJvbGxpbmdcbiAgICogdGhlIHNwZWNpZmllZCBhZGRyZXNzLlxuICAgKlxuICAgKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IG1heSByZXNvbHZlIHdpdGggdGhlIHByaXZhdGUga2V5IHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCB0byBleHBvcnQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFRoZSBwcml2YXRlIGtleSBvZiB0aGUgYWNjb3VudC5cbiAgICovXG4gIGFzeW5jIGV4cG9ydEFjY291bnQoYWRkcmVzcykge1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmdldEtleXJpbmdGb3JBY2NvdW50KGFkZHJlc3MpO1xuICAgIHJldHVybiBhd2FpdCBrZXlyaW5nLmV4cG9ydEFjY291bnQobm9ybWFsaXplQWRkcmVzcyhhZGRyZXNzKSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIEFjY291bnQuXG4gICAqXG4gICAqIFJlbW92ZXMgYSBzcGVjaWZpYyBhY2NvdW50IGZyb20gYSBrZXlyaW5nXG4gICAqIElmIHRoZSBhY2NvdW50IGlzIHRoZSBsYXN0L29ubHkgb25lIHRoZW4gaXQgYWxzbyByZW1vdmVzIHRoZSBrZXlyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBhZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIGlmIHRoZSBvcGVyYXRpb24gd2FzIHN1Y2Nlc3NmdWwuXG4gICAqL1xuICBhc3luYyByZW1vdmVBY2NvdW50KGFkZHJlc3MpIHtcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5nZXRLZXlyaW5nRm9yQWNjb3VudChhZGRyZXNzKTtcblxuICAgIC8vIE5vdCBhbGwgdGhlIGtleXJpbmdzIHN1cHBvcnQgdGhpcywgc28gd2UgaGF2ZSB0byBjaGVja1xuICAgIGlmICh0eXBlb2Yga2V5cmluZy5yZW1vdmVBY2NvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBrZXlyaW5nLnJlbW92ZUFjY291bnQoYWRkcmVzcyk7XG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZWRBY2NvdW50JywgYWRkcmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEtleXJpbmcgJHtrZXlyaW5nLnR5cGV9IGRvZXNuJ3Qgc3VwcG9ydCBhY2NvdW50IHJlbW92YWwgb3BlcmF0aW9uc2AsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQga2V5cmluZy5nZXRBY2NvdW50cygpO1xuICAgIC8vIENoZWNrIGlmIHRoaXMgd2FzIHRoZSBsYXN0L29ubHkgYWNjb3VudFxuICAgIGlmIChhY2NvdW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGF3YWl0IHRoaXMucmVtb3ZlRW1wdHlLZXlyaW5ncygpO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMucGVyc2lzdEFsbEtleXJpbmdzKCk7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFVwZGF0ZSgpO1xuICB9XG5cbiAgLy9cbiAgLy8gU0lHTklORyBNRVRIT0RTXG4gIC8vXG5cbiAgLyoqXG4gICAqIFNpZ24gRXRoZXJldW0gVHJhbnNhY3Rpb25cbiAgICpcbiAgICogU2lnbnMgYW4gRXRoZXJldW0gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXRoVHggLSBUaGUgdHJhbnNhY3Rpb24gdG8gc2lnbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9mcm9tQWRkcmVzcyAtIFRoZSB0cmFuc2FjdGlvbiAnZnJvbScgYWRkcmVzcy5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHMgLSBTaWduaW5nIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IFRoZSBzaWduZWQgdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgKi9cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKGV0aFR4LCBfZnJvbUFkZHJlc3MsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGZyb21BZGRyZXNzID0gbm9ybWFsaXplQWRkcmVzcyhfZnJvbUFkZHJlc3MpO1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmdldEtleXJpbmdGb3JBY2NvdW50KGZyb21BZGRyZXNzKTtcbiAgICByZXR1cm4gYXdhaXQga2V5cmluZy5zaWduVHJhbnNhY3Rpb24oZnJvbUFkZHJlc3MsIGV0aFR4LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIE1lc3NhZ2VcbiAgICpcbiAgICogQXR0ZW1wdHMgdG8gc2lnbiB0aGUgcHJvdmlkZWQgbWVzc2FnZSBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbXNnUGFyYW1zIC0gVGhlIG1lc3NhZ2UgcGFyYW1ldGVycyB0byBzaWduLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0cyAtIEFkZGl0aW9uYWwgc2lnbmluZyBvcHRpb25zLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWZmZXI+fSBUaGUgcmF3IHNpZ25hdHVyZS5cbiAgICovXG4gIGFzeW5jIHNpZ25NZXNzYWdlKG1zZ1BhcmFtcywgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgYWRkcmVzcyA9IG5vcm1hbGl6ZUFkZHJlc3MobXNnUGFyYW1zLmZyb20pO1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmdldEtleXJpbmdGb3JBY2NvdW50KGFkZHJlc3MpO1xuICAgIHJldHVybiBhd2FpdCBrZXlyaW5nLnNpZ25NZXNzYWdlKGFkZHJlc3MsIG1zZ1BhcmFtcy5kYXRhLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIFBlcnNvbmFsIE1lc3NhZ2VcbiAgICpcbiAgICogQXR0ZW1wdHMgdG8gc2lnbiB0aGUgcHJvdmlkZWQgbWVzc2FnZSBwYXJhbWV0ZXJzLlxuICAgKiBQcmVmaXhlcyB0aGUgaGFzaCBiZWZvcmUgc2lnbmluZyBwZXIgdGhlIHBlcnNvbmFsIHNpZ24gZXhwZWN0YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgbWVzc2FnZSBwYXJhbWV0ZXJzIHRvIHNpZ24uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIC0gQWRkaXRpb25hbCBzaWduaW5nIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1ZmZlcj59IFRoZSByYXcgc2lnbmF0dXJlLlxuICAgKi9cbiAgYXN5bmMgc2lnblBlcnNvbmFsTWVzc2FnZShtc2dQYXJhbXMsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGFkZHJlc3MgPSBub3JtYWxpemVBZGRyZXNzKG1zZ1BhcmFtcy5mcm9tKTtcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5nZXRLZXlyaW5nRm9yQWNjb3VudChhZGRyZXNzKTtcbiAgICByZXR1cm4gYXdhaXQga2V5cmluZy5zaWduUGVyc29uYWxNZXNzYWdlKGFkZHJlc3MsIG1zZ1BhcmFtcy5kYXRhLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZW5jcnlwdGlvbiBwdWJsaWMga2V5XG4gICAqXG4gICAqIEdldCBlbmNyeXB0aW9uIHB1YmxpYyBrZXkgZm9yIHVzaW5nIGluIGVuY3J5cHQvZGVjcnlwdCBwcm9jZXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYWRkcmVzcyAtIFRoZSBhZGRyZXNzIHRvIGdldCB0aGUgZW5jcnlwdGlvbiBwdWJsaWMga2V5IGZvci5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHMgLSBBZGRpdGlvbmFsIGVuY3J5cHRpb24gb3B0aW9ucy5cbiAgICogQHJldHVybnMge1Byb21pc2U8QnVmZmVyPn0gVGhlIHB1YmxpYyBrZXkuXG4gICAqL1xuICBhc3luYyBnZXRFbmNyeXB0aW9uUHVibGljS2V5KGFkZHJlc3MsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRBZGRyZXNzID0gbm9ybWFsaXplQWRkcmVzcyhhZGRyZXNzKTtcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5nZXRLZXlyaW5nRm9yQWNjb3VudChhZGRyZXNzKTtcbiAgICByZXR1cm4gYXdhaXQga2V5cmluZy5nZXRFbmNyeXB0aW9uUHVibGljS2V5KG5vcm1hbGl6ZWRBZGRyZXNzLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNyeXB0IE1lc3NhZ2VcbiAgICpcbiAgICogQXR0ZW1wdHMgdG8gZGVjcnlwdCB0aGUgcHJvdmlkZWQgbWVzc2FnZSBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbXNnUGFyYW1zIC0gVGhlIGRlY3J5cHRpb24gbWVzc2FnZSBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0cyAtIEFkZGl0aW9uYWwgZGVjcnlwdGlvbiBvcHRpb25zLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWZmZXI+fSBUaGUgcmF3IGRlY3J5cHRpb24gcmVzdWx0LlxuICAgKi9cbiAgYXN5bmMgZGVjcnlwdE1lc3NhZ2UobXNnUGFyYW1zLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBhZGRyZXNzID0gbm9ybWFsaXplQWRkcmVzcyhtc2dQYXJhbXMuZnJvbSk7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuZ2V0S2V5cmluZ0ZvckFjY291bnQoYWRkcmVzcyk7XG4gICAgcmV0dXJuIGtleXJpbmcuZGVjcnlwdE1lc3NhZ2UoYWRkcmVzcywgbXNnUGFyYW1zLmRhdGEsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gVHlwZWQgRGF0YS5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL0VJUHMvcHVsbC83MTIjaXNzdWVjb21tZW50LTMyOTk4ODQ1NHxFSVA3MTJ9LlxuICAgKiBAcGFyYW0ge29iamVjdH0gbXNnUGFyYW1zIC0gVGhlIG1lc3NhZ2UgcGFyYW1ldGVycyB0byBzaWduLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0cyAtIEFkZGl0aW9uYWwgc2lnbmluZyBvcHRpb25zLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWZmZXI+fSBUaGUgcmF3IHNpZ25hdHVyZS5cbiAgICovXG4gIGFzeW5jIHNpZ25UeXBlZE1lc3NhZ2UobXNnUGFyYW1zLCBvcHRzID0geyB2ZXJzaW9uOiAnVjEnIH0pIHtcbiAgICBjb25zdCBhZGRyZXNzID0gbm9ybWFsaXplQWRkcmVzcyhtc2dQYXJhbXMuZnJvbSk7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuZ2V0S2V5cmluZ0ZvckFjY291bnQoYWRkcmVzcyk7XG4gICAgcmV0dXJuIGtleXJpbmcuc2lnblR5cGVkRGF0YShhZGRyZXNzLCBtc2dQYXJhbXMuZGF0YSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgYXBwIGtleSBhZGRyZXNzIGZvciB0aGUgZ2l2ZW4gRXRoZXJldW0gYWRkcmVzcyBhbmQgb3JpZ2luLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX2FkZHJlc3MgLSBUaGUgRXRoZXJldW0gYWRkcmVzcyBmb3IgdGhlIGFwcCBrZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW4gLSBUaGUgb3JpZ2luIGZvciB0aGUgYXBwIGtleS5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGFwcCBrZXkgYWRkcmVzcy5cbiAgICovXG4gIGFzeW5jIGdldEFwcEtleUFkZHJlc3MoX2FkZHJlc3MsIG9yaWdpbikge1xuICAgIGNvbnN0IGFkZHJlc3MgPSBub3JtYWxpemVBZGRyZXNzKF9hZGRyZXNzKTtcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5nZXRLZXlyaW5nRm9yQWNjb3VudChhZGRyZXNzKTtcbiAgICByZXR1cm4ga2V5cmluZy5nZXRBcHBLZXlBZGRyZXNzKGFkZHJlc3MsIG9yaWdpbik7XG4gIH1cblxuICAvKipcbiAgICogRXhwb3J0cyBhbiBhcHAga2V5IHByaXZhdGUga2V5IGZvciB0aGUgZ2l2ZW4gRXRoZXJldW0gYWRkcmVzcyBhbmQgb3JpZ2luLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX2FkZHJlc3MgLSBUaGUgRXRoZXJldW0gYWRkcmVzcyBmb3IgdGhlIGFwcCBrZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW4gLSBUaGUgb3JpZ2luIGZvciB0aGUgYXBwIGtleS5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGFwcCBrZXkgcHJpdmF0ZSBrZXkuXG4gICAqL1xuICBhc3luYyBleHBvcnRBcHBLZXlGb3JBZGRyZXNzKF9hZGRyZXNzLCBvcmlnaW4pIHtcbiAgICBjb25zdCBhZGRyZXNzID0gbm9ybWFsaXplQWRkcmVzcyhfYWRkcmVzcyk7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuZ2V0S2V5cmluZ0ZvckFjY291bnQoYWRkcmVzcyk7XG4gICAgLy8gVGhlIFwiaW5cIiBvcGVyYXRvciBpcyB0eXBpY2FsbHkgcmVzdHJpY3RlZCBiZWNhdXNlIGl0IGFsc28gY2hlY2tzIGluaGVyaXRlZCBwcm9wZXJ0aWVzLFxuICAgIC8vIHdoaWNoIGNhbiBiZSB1bmV4cGVjdGVkIGZvciBwbGFpbiBvYmplY3RzLiBXZSdyZSBhbGxvd2luZyBpdCBoZXJlIGJlY2F1c2UgYGtleXJpbmdgIGlzIG5vdFxuICAgIC8vIGEgcGxhaW4gb2JqZWN0LCBhbmQgd2UgZXhwbGljaXRseSB3YW50IHRvIGluY2x1ZGUgaW5oZXJpdGVkIG1ldGhvZHMgaW4gdGhpcyBjaGVjay5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICBpZiAoISgnZXhwb3J0QWNjb3VudCcgaW4ga2V5cmluZykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRoZSBrZXlyaW5nIGZvciBhZGRyZXNzICR7X2FkZHJlc3N9IGRvZXMgbm90IHN1cHBvcnQgZXhwb3J0aW5nLmAsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cmluZy5leHBvcnRBY2NvdW50KGFkZHJlc3MsIHsgd2l0aEFwcEtleU9yaWdpbjogb3JpZ2luIH0pO1xuICB9XG5cbiAgLy9cbiAgLy8gUFJJVkFURSBNRVRIT0RTXG4gIC8vXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBGaXJzdCBLZXkgVHJlZS5cbiAgICpcbiAgICogLSBDbGVhcnMgdGhlIGV4aXN0aW5nIHZhdWx0LlxuICAgKiAtIENyZWF0ZXMgYSBuZXcgdmF1bHQuXG4gICAqIC0gQ3JlYXRlcyBhIHJhbmRvbSBuZXcgSEQgS2V5cmluZyB3aXRoIDEgYWNjb3VudC5cbiAgICogLSBNYWtlcyB0aGF0IGFjY291bnQgdGhlIHNlbGVjdGVkIGFjY291bnQuXG4gICAqIC0gRmF1Y2V0cyB0aGF0IGFjY291bnQgb24gdGVzdG5ldC5cbiAgICogLSBQdXRzIHRoZSBjdXJyZW50IHNlZWQgd29yZHMgaW50byB0aGUgc3RhdGUgdHJlZS5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGlmIHRoZSBvcGVyYXRpb24gd2FzIHN1Y2Nlc3NmdWwuXG4gICAqL1xuICBhc3luYyBjcmVhdGVGaXJzdEtleVRyZWUoKSB7XG4gICAgdGhpcy5jbGVhcktleXJpbmdzKCk7XG5cbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5hZGROZXdLZXlyaW5nKEtFWVJJTkdTX1RZUEVfTUFQLkhEX0tFWVJJTkcpO1xuICAgIGNvbnN0IFtmaXJzdEFjY291bnRdID0gYXdhaXQga2V5cmluZy5nZXRBY2NvdW50cygpO1xuICAgIGlmICghZmlyc3RBY2NvdW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleXJpbmdDb250cm9sbGVyIC0gTm8gYWNjb3VudCBmb3VuZCBvbiBrZXljaGFpbi4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBoZXhBY2NvdW50ID0gbm9ybWFsaXplQWRkcmVzcyhmaXJzdEFjY291bnQpO1xuICAgIHRoaXMuZW1pdCgnbmV3VmF1bHQnLCBoZXhBY2NvdW50KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJzaXN0IEFsbCBLZXlyaW5nc1xuICAgKlxuICAgKiBJdGVyYXRlcyB0aGUgY3VycmVudCBga2V5cmluZ3NgIGFycmF5LFxuICAgKiBzZXJpYWxpemVzIGVhY2ggb25lIGludG8gYSBzZXJpYWxpemVkIGFycmF5LFxuICAgKiBlbmNyeXB0cyB0aGF0IGFycmF5IHdpdGggdGhlIHByb3ZpZGVkIGBwYXNzd29yZGAsXG4gICAqIGFuZCBwZXJzaXN0cyB0aGF0IGVuY3J5cHRlZCBzdHJpbmcgdG8gc3RvcmFnZS5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IFJlc29sdmVzIHRvIHRydWUgb25jZSBrZXlyaW5ncyBhcmUgcGVyc2lzdGVkLlxuICAgKi9cbiAgYXN5bmMgcGVyc2lzdEFsbEtleXJpbmdzKCkge1xuICAgIGNvbnN0IHsgZW5jcnlwdGlvbktleSwgZW5jcnlwdGlvblNhbHQgfSA9IHRoaXMubWVtU3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgIGlmICghdGhpcy5wYXNzd29yZCAmJiAhZW5jcnlwdGlvbktleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2Fubm90IHBlcnNpc3QgdmF1bHQgd2l0aG91dCBwYXNzd29yZCBhbmQgZW5jcnlwdGlvbiBrZXknLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZXJpYWxpemVkS2V5cmluZ3MgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHRoaXMua2V5cmluZ3MubWFwKGFzeW5jIChrZXlyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IFt0eXBlLCBkYXRhXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICBrZXlyaW5nLnR5cGUsXG4gICAgICAgICAga2V5cmluZy5zZXJpYWxpemUoKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiB7IHR5cGUsIGRhdGEgfTtcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICBzZXJpYWxpemVkS2V5cmluZ3MucHVzaCguLi50aGlzLl91bnN1cHBvcnRlZEtleXJpbmdzKTtcblxuICAgIGxldCB2YXVsdDtcbiAgICBsZXQgbmV3RW5jcnlwdGlvbktleTtcblxuICAgIGlmICh0aGlzLmNhY2hlRW5jcnlwdGlvbktleSkge1xuICAgICAgaWYgKHRoaXMucGFzc3dvcmQpIHtcbiAgICAgICAgY29uc3QgeyB2YXVsdDogbmV3VmF1bHQsIGV4cG9ydGVkS2V5U3RyaW5nIH0gPVxuICAgICAgICAgIGF3YWl0IHRoaXMuZW5jcnlwdG9yLmVuY3J5cHRXaXRoRGV0YWlsKFxuICAgICAgICAgICAgdGhpcy5wYXNzd29yZCxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRLZXlyaW5ncyxcbiAgICAgICAgICApO1xuXG4gICAgICAgIHZhdWx0ID0gbmV3VmF1bHQ7XG4gICAgICAgIG5ld0VuY3J5cHRpb25LZXkgPSBleHBvcnRlZEtleVN0cmluZztcbiAgICAgIH0gZWxzZSBpZiAoZW5jcnlwdGlvbktleSkge1xuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCB0aGlzLmVuY3J5cHRvci5pbXBvcnRLZXkoZW5jcnlwdGlvbktleSk7XG4gICAgICAgIGNvbnN0IHZhdWx0SlNPTiA9IGF3YWl0IHRoaXMuZW5jcnlwdG9yLmVuY3J5cHRXaXRoS2V5KFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBzZXJpYWxpemVkS2V5cmluZ3MsXG4gICAgICAgICk7XG4gICAgICAgIHZhdWx0SlNPTi5zYWx0ID0gZW5jcnlwdGlvblNhbHQ7XG4gICAgICAgIHZhdWx0ID0gSlNPTi5zdHJpbmdpZnkodmF1bHRKU09OKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmF1bHQgPSBhd2FpdCB0aGlzLmVuY3J5cHRvci5lbmNyeXB0KHRoaXMucGFzc3dvcmQsIHNlcmlhbGl6ZWRLZXlyaW5ncyk7XG4gICAgfVxuXG4gICAgaWYgKCF2YXVsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcGVyc2lzdCB2YXVsdCB3aXRob3V0IHZhdWx0IGluZm9ybWF0aW9uJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IHZhdWx0IH0pO1xuXG4gICAgLy8gVGhlIGtleXJpbmcgdXBkYXRlcyBuZWVkIHRvIGJlIGFubm91bmNlZCBiZWZvcmUgdXBkYXRpbmcgdGhlIGVuY3J5cHRpb25LZXlcbiAgICAvLyBzbyB0aGF0IHRoZSB1cGRhdGVkIGtleXJpbmcgZ2V0cyBwcm9wYWdhdGVkIHRvIHRoZSBleHRlbnNpb24gZmlyc3QuXG4gICAgLy8gTm90IGNhbGxpbmcgX3VwZGF0ZU1lbVN0b3JlS2V5cmluZ3MgcmVzdWx0cyBpbiB0aGUgd3JvbmcgYWNjb3VudCBiZWluZyBzZWxlY3RlZFxuICAgIC8vIGluIHRoZSBleHRlbnNpb24uXG4gICAgYXdhaXQgdGhpcy5fdXBkYXRlTWVtU3RvcmVLZXlyaW5ncygpO1xuXG4gICAgaWYgKG5ld0VuY3J5cHRpb25LZXkpIHtcbiAgICAgIHRoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgICBlbmNyeXB0aW9uS2V5OiBuZXdFbmNyeXB0aW9uS2V5LFxuICAgICAgICBlbmNyeXB0aW9uU2FsdDogSlNPTi5wYXJzZSh2YXVsdCkuc2FsdCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVubG9jayBLZXlyaW5ncy5cbiAgICpcbiAgICogQXR0ZW1wdHMgdG8gdW5sb2NrIHRoZSBwZXJzaXN0ZWQgZW5jcnlwdGVkIHN0b3JhZ2UsXG4gICAqIGluaXRpYWxpemluZyB0aGUgcGVyc2lzdGVkIGtleXJpbmdzIHRvIFJBTS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIC0gVGhlIGtleXJpbmcgY29udHJvbGxlciBwYXNzd29yZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGVuY3J5cHRpb25LZXkgLSBBbiBleHBvcnRlZCBrZXkgc3RyaW5nIHRvIHVubG9jayBrZXlyaW5ncyB3aXRoLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZW5jcnlwdGlvblNhbHQgLSBUaGUgc2FsdCB1c2VkIHRvIGVuY3J5cHQgdGhlIHZhdWx0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxLZXlyaW5nPj59IFRoZSBrZXlyaW5ncy5cbiAgICovXG4gIGFzeW5jIHVubG9ja0tleXJpbmdzKHBhc3N3b3JkLCBlbmNyeXB0aW9uS2V5LCBlbmNyeXB0aW9uU2FsdCkge1xuICAgIGNvbnN0IGVuY3J5cHRlZFZhdWx0ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLnZhdWx0O1xuICAgIGlmICghZW5jcnlwdGVkVmF1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVubG9jayB3aXRob3V0IGEgcHJldmlvdXMgdmF1bHQuJyk7XG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5jbGVhcktleXJpbmdzKCk7XG5cbiAgICBsZXQgdmF1bHQ7XG5cbiAgICBpZiAodGhpcy5jYWNoZUVuY3J5cHRpb25LZXkpIHtcbiAgICAgIGlmIChwYXNzd29yZCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmVuY3J5cHRvci5kZWNyeXB0V2l0aERldGFpbChcbiAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICBlbmNyeXB0ZWRWYXVsdCxcbiAgICAgICAgKTtcbiAgICAgICAgdmF1bHQgPSByZXN1bHQudmF1bHQ7XG4gICAgICAgIHRoaXMucGFzc3dvcmQgPSBwYXNzd29yZDtcblxuICAgICAgICB0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgICBlbmNyeXB0aW9uS2V5OiByZXN1bHQuZXhwb3J0ZWRLZXlTdHJpbmcsXG4gICAgICAgICAgZW5jcnlwdGlvblNhbHQ6IHJlc3VsdC5zYWx0LFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEVuY3J5cHRlZFZhdWx0ID0gSlNPTi5wYXJzZShlbmNyeXB0ZWRWYXVsdCk7XG5cbiAgICAgICAgaWYgKGVuY3J5cHRpb25TYWx0ICE9PSBwYXJzZWRFbmNyeXB0ZWRWYXVsdC5zYWx0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIGtleSBhbmQgc2FsdCBwcm92aWRlZCBhcmUgZXhwaXJlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgdGhpcy5lbmNyeXB0b3IuaW1wb3J0S2V5KGVuY3J5cHRpb25LZXkpO1xuICAgICAgICB2YXVsdCA9IGF3YWl0IHRoaXMuZW5jcnlwdG9yLmRlY3J5cHRXaXRoS2V5KGtleSwgcGFyc2VkRW5jcnlwdGVkVmF1bHQpO1xuXG4gICAgICAgIC8vIFRoaXMgY2FsbCBpcyByZXF1aXJlZCBvbiB0aGUgZmlyc3QgY2FsbCBiZWNhdXNlIGVuY3J5cHRpb25LZXlcbiAgICAgICAgLy8gaXMgbm90IHlldCBpbnNpZGUgdGhlIG1lbVN0b3JlXG4gICAgICAgIHRoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgICAgIGVuY3J5cHRpb25LZXksXG4gICAgICAgICAgZW5jcnlwdGlvblNhbHQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXVsdCA9IGF3YWl0IHRoaXMuZW5jcnlwdG9yLmRlY3J5cHQocGFzc3dvcmQsIGVuY3J5cHRlZFZhdWx0KTtcbiAgICAgIHRoaXMucGFzc3dvcmQgPSBwYXNzd29yZDtcbiAgICB9XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbCh2YXVsdC5tYXAodGhpcy5fcmVzdG9yZUtleXJpbmcuYmluZCh0aGlzKSkpO1xuICAgIGF3YWl0IHRoaXMuX3VwZGF0ZU1lbVN0b3JlS2V5cmluZ3MoKTtcbiAgICByZXR1cm4gdGhpcy5rZXlyaW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN0b3JlIEtleXJpbmdcbiAgICpcbiAgICogQXR0ZW1wdHMgdG8gaW5pdGlhbGl6ZSBhIG5ldyBrZXlyaW5nIGZyb20gdGhlIHByb3ZpZGVkIHNlcmlhbGl6ZWQgcGF5bG9hZC5cbiAgICogT24gc3VjY2VzcywgdXBkYXRlcyB0aGUgbWVtU3RvcmUga2V5cmluZ3MgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZ1xuICAgKiBrZXlyaW5nIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc2VyaWFsaXplZCAtIFRoZSBzZXJpYWxpemVkIGtleXJpbmcuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEtleXJpbmc+fSBUaGUgZGVzZXJpYWxpemVkIGtleXJpbmcuXG4gICAqL1xuICBhc3luYyByZXN0b3JlS2V5cmluZyhzZXJpYWxpemVkKSB7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuX3Jlc3RvcmVLZXlyaW5nKHNlcmlhbGl6ZWQpO1xuICAgIGlmIChrZXlyaW5nKSB7XG4gICAgICBhd2FpdCB0aGlzLl91cGRhdGVNZW1TdG9yZUtleXJpbmdzKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXlyaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3RvcmUgS2V5cmluZyBIZWxwZXJcbiAgICpcbiAgICogQXR0ZW1wdHMgdG8gaW5pdGlhbGl6ZSBhIG5ldyBrZXlyaW5nIGZyb20gdGhlIHByb3ZpZGVkIHNlcmlhbGl6ZWQgcGF5bG9hZC5cbiAgICogT24gc3VjY2VzcywgcmV0dXJucyB0aGUgcmVzdWx0aW5nIGtleXJpbmcgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzZXJpYWxpemVkIC0gVGhlIHNlcmlhbGl6ZWQga2V5cmluZy5cbiAgICogQHJldHVybnMge1Byb21pc2U8S2V5cmluZ3x1bmRlZmluZWQ+fSBUaGUgZGVzZXJpYWxpemVkIGtleXJpbmcgb3IgdW5kZWZpbmVkIGlmIHRoZSBrZXlyaW5nIHR5cGUgaXMgdW5zdXBwb3J0ZWQuXG4gICAqL1xuICBhc3luYyBfcmVzdG9yZUtleXJpbmcoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHsgdHlwZSwgZGF0YSB9ID0gc2VyaWFsaXplZDtcblxuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLl9uZXdLZXlyaW5nKHR5cGUsIGRhdGEpO1xuICAgIGlmICgha2V5cmluZykge1xuICAgICAgdGhpcy5fdW5zdXBwb3J0ZWRLZXlyaW5ncy5wdXNoKHNlcmlhbGl6ZWQpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBnZXRBY2NvdW50cyBhbHNvIHZhbGlkYXRlcyB0aGUgYWNjb3VudHMgZm9yIHNvbWUga2V5cmluZ3NcbiAgICBhd2FpdCBrZXlyaW5nLmdldEFjY291bnRzKCk7XG4gICAgdGhpcy5rZXlyaW5ncy5wdXNoKGtleXJpbmcpO1xuICAgIHJldHVybiBrZXlyaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBLZXlyaW5nIENsYXNzIEZvciBUeXBlXG4gICAqXG4gICAqIFNlYXJjaGVzIHRoZSBjdXJyZW50IGBrZXlyaW5nQnVpbGRlcnNgIGFycmF5XG4gICAqIGZvciBhIEtleXJpbmcgYnVpbGRlciB3aG9zZSB1bmlxdWUgYHR5cGVgIHByb3BlcnR5XG4gICAqIG1hdGNoZXMgdGhlIHByb3ZpZGVkIGB0eXBlYCxcbiAgICogcmV0dXJuaW5nIGl0IGlmIGl0IGV4aXN0cy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSB3aG9zZSBjbGFzcyB0byBnZXQuXG4gICAqIEByZXR1cm5zIHtLZXlyaW5nfHVuZGVmaW5lZH0gVGhlIGNsYXNzLCBpZiBpdCBleGlzdHMuXG4gICAqL1xuICBnZXRLZXlyaW5nQnVpbGRlckZvclR5cGUodHlwZSkge1xuICAgIHJldHVybiB0aGlzLmtleXJpbmdCdWlsZGVycy5maW5kKFxuICAgICAgKGtleXJpbmdCdWlsZGVyKSA9PiBrZXlyaW5nQnVpbGRlci50eXBlID09PSB0eXBlLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IEtleXJpbmdzIGJ5IFR5cGVcbiAgICpcbiAgICogR2V0cyBhbGwga2V5cmluZ3Mgb2YgdGhlIGdpdmVuIHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIGtleXJpbmcgdHlwZXMgdG8gcmV0cmlldmUuXG4gICAqIEByZXR1cm5zIHtBcnJheTxLZXlyaW5nPn0gVGhlIGtleXJpbmdzLlxuICAgKi9cbiAgZ2V0S2V5cmluZ3NCeVR5cGUodHlwZSkge1xuICAgIHJldHVybiB0aGlzLmtleXJpbmdzLmZpbHRlcigoa2V5cmluZykgPT4ga2V5cmluZy50eXBlID09PSB0eXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgQWNjb3VudHNcbiAgICpcbiAgICogUmV0dXJucyB0aGUgcHVibGljIGFkZHJlc3NlcyBvZiBhbGwgY3VycmVudCBhY2NvdW50c1xuICAgKiBtYW5hZ2VkIGJ5IGFsbCBjdXJyZW50bHkgdW5sb2NrZWQga2V5cmluZ3MuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PHN0cmluZz4+fSBUaGUgYXJyYXkgb2YgYWNjb3VudHMuXG4gICAqL1xuICBhc3luYyBnZXRBY2NvdW50cygpIHtcbiAgICBjb25zdCBrZXlyaW5ncyA9IHRoaXMua2V5cmluZ3MgfHwgW107XG5cbiAgICBjb25zdCBrZXlyaW5nQXJyYXlzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBrZXlyaW5ncy5tYXAoKGtleXJpbmcpID0+IGtleXJpbmcuZ2V0QWNjb3VudHMoKSksXG4gICAgKTtcbiAgICBjb25zdCBhZGRyZXNzZXMgPSBrZXlyaW5nQXJyYXlzLnJlZHVjZSgocmVzLCBhcnIpID0+IHtcbiAgICAgIHJldHVybiByZXMuY29uY2F0KGFycik7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIGFkZHJlc3Nlcy5tYXAobm9ybWFsaXplQWRkcmVzcyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IEtleXJpbmcgRm9yIEFjY291bnRcbiAgICpcbiAgICogUmV0dXJucyB0aGUgY3VycmVudGx5IGluaXRpYWxpemVkIGtleXJpbmcgdGhhdCBtYW5hZ2VzXG4gICAqIHRoZSBzcGVjaWZpZWQgYGFkZHJlc3NgIGlmIG9uZSBleGlzdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gQW4gYWNjb3VudCBhZGRyZXNzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxLZXlyaW5nPn0gVGhlIGtleXJpbmcgb2YgdGhlIGFjY291bnQsIGlmIGl0IGV4aXN0cy5cbiAgICovXG4gIGFzeW5jIGdldEtleXJpbmdGb3JBY2NvdW50KGFkZHJlc3MpIHtcbiAgICBjb25zdCBoZXhlZCA9IG5vcm1hbGl6ZUFkZHJlc3MoYWRkcmVzcyk7XG5cbiAgICBjb25zdCBjYW5kaWRhdGVzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICB0aGlzLmtleXJpbmdzLm1hcCgoa2V5cmluZykgPT4ge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW2tleXJpbmcsIGtleXJpbmcuZ2V0QWNjb3VudHMoKV0pO1xuICAgICAgfSksXG4gICAgKTtcblxuICAgIGNvbnN0IHdpbm5lcnMgPSBjYW5kaWRhdGVzLmZpbHRlcigoY2FuZGlkYXRlKSA9PiB7XG4gICAgICBjb25zdCBhY2NvdW50cyA9IGNhbmRpZGF0ZVsxXS5tYXAobm9ybWFsaXplQWRkcmVzcyk7XG4gICAgICByZXR1cm4gYWNjb3VudHMuaW5jbHVkZXMoaGV4ZWQpO1xuICAgIH0pO1xuICAgIGlmICh3aW5uZXJzICYmIHdpbm5lcnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHdpbm5lcnNbMF1bMF07XG4gICAgfVxuXG4gICAgLy8gQWRkaW5nIG1vcmUgaW5mbyB0byB0aGUgZXJyb3JcbiAgICBsZXQgZXJyb3JJbmZvID0gJyc7XG4gICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICBlcnJvckluZm8gPSAnVGhlIGFkZHJlc3MgcGFzc2VkIGluIGlzIGludmFsaWQvZW1wdHknO1xuICAgIH0gZWxzZSBpZiAoIWNhbmRpZGF0ZXMgfHwgIWNhbmRpZGF0ZXMubGVuZ3RoKSB7XG4gICAgICBlcnJvckluZm8gPSAnVGhlcmUgYXJlIG5vIGtleXJpbmdzJztcbiAgICB9IGVsc2UgaWYgKCF3aW5uZXJzIHx8ICF3aW5uZXJzLmxlbmd0aCkge1xuICAgICAgZXJyb3JJbmZvID0gJ1RoZXJlIGFyZSBrZXlyaW5ncywgYnV0IG5vbmUgbWF0Y2ggdGhlIGFkZHJlc3MnO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgTm8ga2V5cmluZyBmb3VuZCBmb3IgdGhlIHJlcXVlc3RlZCBhY2NvdW50LiBFcnJvciBpbmZvOiAke2Vycm9ySW5mb31gLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRGlzcGxheSBGb3IgS2V5cmluZ1xuICAgKlxuICAgKiBJcyB1c2VkIGZvciBhZGRpbmcgdGhlIGN1cnJlbnQga2V5cmluZ3MgdG8gdGhlIHN0YXRlIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtLZXlyaW5nfSBrZXlyaW5nIC0gVGhlIGtleXJpbmcgdG8gZGlzcGxheS5cbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gQSBrZXlyaW5nIGRpc3BsYXkgb2JqZWN0LCB3aXRoIHR5cGUgYW5kIGFjY291bnRzIHByb3BlcnRpZXMuXG4gICAqL1xuICBhc3luYyBkaXNwbGF5Rm9yS2V5cmluZyhrZXlyaW5nKSB7XG4gICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBrZXlyaW5nLmdldEFjY291bnRzKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZToga2V5cmluZy50eXBlLFxuICAgICAgYWNjb3VudHM6IGFjY291bnRzLm1hcChub3JtYWxpemVBZGRyZXNzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIEtleXJpbmdzXG4gICAqXG4gICAqIERlYWxsb2NhdGVzIGFsbCBjdXJyZW50bHkgbWFuYWdlZCBrZXlyaW5ncyBhbmQgYWNjb3VudHMuXG4gICAqIFVzZWQgYmVmb3JlIGluaXRpYWxpemluZyBhIG5ldyB2YXVsdC5cbiAgICovXG5cbiAgLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1hd2FpdCAqL1xuICBhc3luYyBjbGVhcktleXJpbmdzKCkge1xuICAgIC8vIGNsZWFyIGtleXJpbmdzIGZyb20gbWVtb3J5XG4gICAgdGhpcy5rZXlyaW5ncyA9IFtdO1xuICAgIHRoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAga2V5cmluZ3M6IFtdLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBtZW1TdG9yZSBLZXlyaW5nc1xuICAgKlxuICAgKiBVcGRhdGVzIHRoZSBpbi1tZW1vcnkga2V5cmluZ3MsIHdpdGhvdXQgcGVyc2lzdGluZy5cbiAgICovXG4gIGFzeW5jIF91cGRhdGVNZW1TdG9yZUtleXJpbmdzKCkge1xuICAgIGNvbnN0IGtleXJpbmdzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICB0aGlzLmtleXJpbmdzLm1hcCh0aGlzLmRpc3BsYXlGb3JLZXlyaW5nKSxcbiAgICApO1xuICAgIHJldHVybiB0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHsga2V5cmluZ3MgfSk7XG4gIH1cblxuICAvKipcbiAgICogVW5sb2NrIEtleXJpbmdzXG4gICAqXG4gICAqIFVubG9ja3MgdGhlIGtleXJpbmdzLlxuICAgKlxuICAgKiBAZmlyZXMgS2V5cmluZ0NvbnRyb2xsZXIjdW5sb2NrXG4gICAqL1xuICBzZXRVbmxvY2tlZCgpIHtcbiAgICB0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHsgaXNVbmxvY2tlZDogdHJ1ZSB9KTtcbiAgICB0aGlzLmVtaXQoJ3VubG9jaycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmdldCBoYXJkd2FyZSBrZXlyaW5nLlxuICAgKlxuICAgKiBGb3JnZXQgaGFyZHdhcmUgYW5kIHVwZGF0ZSBtZW1vcml6ZWQgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5cmluZ30ga2V5cmluZyAtIFRoZSBrZXlyaW5nIHRvIGZvcmdldC5cbiAgICovXG4gIGZvcmdldEtleXJpbmcoa2V5cmluZykge1xuICAgIGlmIChrZXlyaW5nLmZvcmdldERldmljZSkge1xuICAgICAga2V5cmluZy5mb3JnZXREZXZpY2UoKTtcbiAgICAgIHRoaXMucGVyc2lzdEFsbEtleXJpbmdzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEtleXJpbmdDb250cm9sbGVyIC0ga2V5cmluZyBkb2VzIG5vdCBoYXZlIG1ldGhvZCBcImZvcmdldERldmljZVwiLCBrZXlyaW5nIHR5cGU6ICR7a2V5cmluZy50eXBlfWAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSwgaW5pdGlhbGl6ZSBhbmQgcmV0dXJuIGEgbmV3IGtleXJpbmdcbiAgICpcbiAgICogVGhlIGtleXJpbmcgaW5zdGFudGlhdGVkIGlzIG9mIHRoZSBnaXZlbiBgdHlwZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2Yga2V5cmluZyB0byBhZGQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgdG8gcmVzdG9yZSBhIHByZXZpb3VzbHkgc2VyaWFsaXplZCBrZXlyaW5nLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxLZXlyaW5nPn0gVGhlIG5ldyBrZXlyaW5nLlxuICAgKi9cbiAgYXN5bmMgX25ld0tleXJpbmcodHlwZSwgZGF0YSkge1xuICAgIGNvbnN0IGtleXJpbmdCdWlsZGVyID0gdGhpcy5nZXRLZXlyaW5nQnVpbGRlckZvclR5cGUodHlwZSk7XG5cbiAgICBpZiAoIWtleXJpbmdCdWlsZGVyKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IGtleXJpbmcgPSBrZXlyaW5nQnVpbGRlcigpO1xuXG4gICAgYXdhaXQga2V5cmluZy5kZXNlcmlhbGl6ZShkYXRhKTtcblxuICAgIGlmIChrZXlyaW5nLmluaXQpIHtcbiAgICAgIGF3YWl0IGtleXJpbmcuaW5pdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlyaW5nO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGJ1aWxkZXIgZnVuY3Rpb24gZm9yIGBLZXlyaW5nYFxuICpcbiAqIFJldHVybnMgYSBidWlsZGVyIGZ1bmN0aW9uIGZvciBgS2V5cmluZ2Agd2l0aCBhIGB0eXBlYCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge0tleXJpbmd9IEtleXJpbmcgLSBUaGUgS2V5cmluZyBjbGFzcyBmb3IgdGhlIGJ1aWxkZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgYnVpbGRlciBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIEtleXJpbmcuXG4gKi9cbmZ1bmN0aW9uIGtleXJpbmdCdWlsZGVyRmFjdG9yeShLZXlyaW5nKSB7XG4gIGNvbnN0IGJ1aWxkZXIgPSAoKSA9PiBuZXcgS2V5cmluZygpO1xuXG4gIGJ1aWxkZXIudHlwZSA9IEtleXJpbmcudHlwZTtcblxuICByZXR1cm4gYnVpbGRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtleXJpbmdDb250cm9sbGVyLFxuICBrZXlyaW5nQnVpbGRlckZhY3RvcnksXG59O1xuIiwiY29uc3QgeyBFdmVudEVtaXR0ZXIgfSA9IHJlcXVpcmUoJ2V2ZW50cycpXG5jb25zdCBIREtleSA9IHJlcXVpcmUoJ2hka2V5JylcbmNvbnN0IGV0aFV0aWwgPSByZXF1aXJlKCdldGhlcmV1bWpzLXV0aWwnKVxuY29uc3Qgc2lnVXRpbCA9IHJlcXVpcmUoJ2V0aC1zaWctdXRpbCcpXG5jb25zdCB7IFRyYW5zYWN0aW9uRmFjdG9yeSB9ID0gcmVxdWlyZSgnQGV0aGVyZXVtanMvdHgnKVxuXG5jb25zdCBwYXRoQmFzZSA9ICdtJ1xuY29uc3QgaGRQYXRoU3RyaW5nID0gYCR7cGF0aEJhc2V9LzQ0Jy82MCcvMCdgXG5jb25zdCB0eXBlID0gJ0xlZGdlciBIYXJkd2FyZSdcblxuY29uc3QgQlJJREdFX1VSTCA9ICdodHRwczovL21ldGFtYXNrLmdpdGh1Yi5pby9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nJ1xuXG5jb25zdCBNQVhfSU5ERVggPSAxMDAwXG5jb25zdCBORVRXT1JLX0FQSV9VUkxTID0ge1xuICByb3BzdGVuOiAnaHR0cDovL2FwaS1yb3BzdGVuLmV0aGVyc2Nhbi5pbycsXG4gIGtvdmFuOiAnaHR0cDovL2FwaS1rb3Zhbi5ldGhlcnNjYW4uaW8nLFxuICByaW5rZWJ5OiAnaHR0cHM6Ly9hcGktcmlua2VieS5ldGhlcnNjYW4uaW8nLFxuICBtYWlubmV0OiAnaHR0cHM6Ly9hcGkuZXRoZXJzY2FuLmlvJyxcbn1cblxuY29uc3QgQ09OTkVDVElPTl9FVkVOVCA9ICdsZWRnZXItY29ubmVjdGlvbi1jaGFuZ2UnXG5cbmNsYXNzIExlZGdlckJyaWRnZUtleXJpbmcgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuYWNjb3VudERldGFpbHMgPSB7fVxuICAgIHRoaXMuYnJpZGdlVXJsID0gbnVsbFxuICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgICB0aGlzLnBhZ2UgPSAwXG4gICAgdGhpcy5wZXJQYWdlID0gNVxuICAgIHRoaXMudW5sb2NrZWRBY2NvdW50ID0gMFxuICAgIHRoaXMuaGRrID0gbmV3IEhES2V5KClcbiAgICB0aGlzLnBhdGhzID0ge31cbiAgICB0aGlzLmlmcmFtZSA9IG51bGxcbiAgICB0aGlzLm5ldHdvcmsgPSAnbWFpbm5ldCdcbiAgICB0aGlzLmltcGxlbWVudEZ1bGxCSVA0NCA9IGZhbHNlXG4gICAgdGhpcy5kZXNlcmlhbGl6ZShvcHRzKVxuXG4gICAgdGhpcy5pZnJhbWVMb2FkZWQgPSBmYWxzZVxuICAgIHRoaXMuX3NldHVwSWZyYW1lKClcblxuICAgIHRoaXMuY3VycmVudE1lc3NhZ2VJZCA9IDBcbiAgICB0aGlzLm1lc3NhZ2VDYWxsYmFja3MgPSB7fVxuICAgIHRoaXMuX3NldHVwTGlzdGVuZXIoKVxuICB9XG5cbiAgc2VyaWFsaXplICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIGhkUGF0aDogdGhpcy5oZFBhdGgsXG4gICAgICBhY2NvdW50czogdGhpcy5hY2NvdW50cyxcbiAgICAgIGFjY291bnREZXRhaWxzOiB0aGlzLmFjY291bnREZXRhaWxzLFxuICAgICAgYnJpZGdlVXJsOiB0aGlzLmJyaWRnZVVybCxcbiAgICAgIGltcGxlbWVudEZ1bGxCSVA0NDogZmFsc2UsXG4gICAgfSlcbiAgfVxuXG4gIGRlc2VyaWFsaXplIChvcHRzID0ge30pIHtcbiAgICB0aGlzLmhkUGF0aCA9IG9wdHMuaGRQYXRoIHx8IGhkUGF0aFN0cmluZ1xuICAgIHRoaXMuYnJpZGdlVXJsID0gb3B0cy5icmlkZ2VVcmwgfHwgQlJJREdFX1VSTFxuICAgIHRoaXMuYWNjb3VudHMgPSBvcHRzLmFjY291bnRzIHx8IFtdXG4gICAgdGhpcy5hY2NvdW50RGV0YWlscyA9IG9wdHMuYWNjb3VudERldGFpbHMgfHwge31cbiAgICBpZiAoIW9wdHMuYWNjb3VudERldGFpbHMpIHtcbiAgICAgIHRoaXMuX21pZ3JhdGVBY2NvdW50RGV0YWlscyhvcHRzKVxuICAgIH1cblxuICAgIHRoaXMuaW1wbGVtZW50RnVsbEJJUDQ0ID0gb3B0cy5pbXBsZW1lbnRGdWxsQklQNDQgfHwgZmFsc2VcblxuICAgIC8vIFJlbW92ZSBhY2NvdW50cyB0aGF0IGRvbid0IGhhdmUgY29ycmVzcG9uZGluZyBhY2NvdW50IGRldGFpbHNcbiAgICB0aGlzLmFjY291bnRzID0gdGhpcy5hY2NvdW50c1xuICAgICAgLmZpbHRlcigoYWNjb3VudCkgPT4gT2JqZWN0LmtleXModGhpcy5hY2NvdW50RGV0YWlscykuaW5jbHVkZXMoZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhY2NvdW50KSkpXG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgfVxuXG4gIF9taWdyYXRlQWNjb3VudERldGFpbHMgKG9wdHMpIHtcbiAgICBpZiAodGhpcy5faXNMZWRnZXJMaXZlSGRQYXRoKCkgJiYgb3B0cy5hY2NvdW50SW5kZXhlcykge1xuICAgICAgZm9yIChjb25zdCBhY2NvdW50IG9mIE9iamVjdC5rZXlzKG9wdHMuYWNjb3VudEluZGV4ZXMpKSB7XG4gICAgICAgIHRoaXMuYWNjb3VudERldGFpbHNbYWNjb3VudF0gPSB7XG4gICAgICAgICAgYmlwNDQ6IHRydWUsXG4gICAgICAgICAgaGRQYXRoOiB0aGlzLl9nZXRQYXRoRm9ySW5kZXgob3B0cy5hY2NvdW50SW5kZXhlc1thY2NvdW50XSksXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0cnkgdG8gbWlncmF0ZSBub24tTGVkZ2VyTGl2ZSBhY2NvdW50cyB0b29cbiAgICBpZiAoIXRoaXMuX2lzTGVkZ2VyTGl2ZUhkUGF0aCgpKSB7XG4gICAgICB0aGlzLmFjY291bnRzXG4gICAgICAgIC5maWx0ZXIoKGFjY291bnQpID0+ICFPYmplY3Qua2V5cyh0aGlzLmFjY291bnREZXRhaWxzKS5pbmNsdWRlcyhldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFjY291bnQpKSlcbiAgICAgICAgLmZvckVhY2goKGFjY291bnQpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5hY2NvdW50RGV0YWlsc1tldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFjY291bnQpXSA9IHtcbiAgICAgICAgICAgICAgYmlwNDQ6IGZhbHNlLFxuICAgICAgICAgICAgICBoZFBhdGg6IHRoaXMuX3BhdGhGcm9tQWRkcmVzcyhhY2NvdW50KSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgZmFpbGVkIHRvIG1pZ3JhdGUgYWNjb3VudCAke2FjY291bnR9YClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaXNVbmxvY2tlZCAoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5oZGsgJiYgdGhpcy5oZGsucHVibGljS2V5KVxuICB9XG5cbiAgaXNDb25uZWN0ZWQgKCkge1xuICAgIHJldHVybiB0aGlzLmlzRGV2aWNlQ29ubmVjdGVkXG4gIH1cblxuICBzZXRBY2NvdW50VG9VbmxvY2sgKGluZGV4KSB7XG4gICAgdGhpcy51bmxvY2tlZEFjY291bnQgPSBwYXJzZUludChpbmRleCwgMTApXG4gIH1cblxuICBzZXRIZFBhdGggKGhkUGF0aCkge1xuICAgIC8vIFJlc2V0IEhES2V5IGlmIHRoZSBwYXRoIGNoYW5nZXNcbiAgICBpZiAodGhpcy5oZFBhdGggIT09IGhkUGF0aCkge1xuICAgICAgdGhpcy5oZGsgPSBuZXcgSERLZXkoKVxuICAgIH1cbiAgICB0aGlzLmhkUGF0aCA9IGhkUGF0aFxuICB9XG5cbiAgdW5sb2NrIChoZFBhdGgsIHVwZGF0ZUhkayA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5pc1VubG9ja2VkKCkgJiYgIWhkUGF0aCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgnYWxyZWFkeSB1bmxvY2tlZCcpXG4gICAgfVxuICAgIGNvbnN0IHBhdGggPSBoZFBhdGggPyB0aGlzLl90b0xlZGdlclBhdGgoaGRQYXRoKSA6IHRoaXMuaGRQYXRoXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgYWN0aW9uOiAnbGVkZ2VyLXVubG9jaycsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIGhkUGF0aDogcGF0aCxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICAoeyBzdWNjZXNzLCBwYXlsb2FkIH0pID0+IHtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICBpZiAodXBkYXRlSGRrKSB7XG4gICAgICAgICAgICB0aGlzLmhkay5wdWJsaWNLZXkgPSBCdWZmZXIuZnJvbShwYXlsb2FkLnB1YmxpY0tleSwgJ2hleCcpXG4gICAgICAgICAgICB0aGlzLmhkay5jaGFpbkNvZGUgPSBCdWZmZXIuZnJvbShwYXlsb2FkLmNoYWluQ29kZSwgJ2hleCcpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocGF5bG9hZC5hZGRyZXNzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChwYXlsb2FkLmVycm9yIHx8IG5ldyBFcnJvcignVW5rbm93biBlcnJvcicpKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBhZGRBY2NvdW50cyAobiA9IDEpIHtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnVubG9jaygpXG4gICAgICAgIC50aGVuKGFzeW5jIChfKSA9PiB7XG4gICAgICAgICAgY29uc3QgZnJvbSA9IHRoaXMudW5sb2NrZWRBY2NvdW50XG4gICAgICAgICAgY29uc3QgdG8gPSBmcm9tICsgblxuICAgICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMuX2dldFBhdGhGb3JJbmRleChpKVxuICAgICAgICAgICAgbGV0IGFkZHJlc3NcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0xlZGdlckxpdmVIZFBhdGgoKSkge1xuICAgICAgICAgICAgICBhZGRyZXNzID0gYXdhaXQgdGhpcy51bmxvY2socGF0aClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLl9hZGRyZXNzRnJvbUluZGV4KHBhdGhCYXNlLCBpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hY2NvdW50RGV0YWlsc1tldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpXSA9IHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogY29uc2lkZXIgcmVuYW1pbmcgdGhpcyBwcm9wZXJ0eSwgYXMgdGhlIGN1cnJlbnQgbmFtZSBpcyBtaXNsZWFkaW5nXG4gICAgICAgICAgICAgIC8vIEl0J3MgY3VycmVudGx5IHVzZWQgdG8gcmVwcmVzZW50IHdoZXRoZXIgYW4gYWNjb3VudCB1c2VzIHRoZSBMZWRnZXIgTGl2ZSBwYXRoLlxuICAgICAgICAgICAgICBiaXA0NDogdGhpcy5faXNMZWRnZXJMaXZlSGRQYXRoKCksXG4gICAgICAgICAgICAgIGhkUGF0aDogcGF0aCxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLmFjY291bnRzLmluY2x1ZGVzKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWNjb3VudHMucHVzaChhZGRyZXNzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wYWdlID0gMFxuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHRoaXMuYWNjb3VudHMpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgfSlcbiAgfVxuXG4gIGdldEZpcnN0UGFnZSAoKSB7XG4gICAgdGhpcy5wYWdlID0gMFxuICAgIHJldHVybiB0aGlzLl9fZ2V0UGFnZSgxKVxuICB9XG5cbiAgZ2V0TmV4dFBhZ2UgKCkge1xuICAgIHJldHVybiB0aGlzLl9fZ2V0UGFnZSgxKVxuICB9XG5cbiAgZ2V0UHJldmlvdXNQYWdlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2dldFBhZ2UoLTEpXG4gIH1cblxuICBnZXRBY2NvdW50cyAoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmFjY291bnRzLnNsaWNlKCkpXG4gIH1cblxuICByZW1vdmVBY2NvdW50IChhZGRyZXNzKSB7XG4gICAgaWYgKCF0aGlzLmFjY291bnRzLm1hcCgoYSkgPT4gYS50b0xvd2VyQ2FzZSgpKS5pbmNsdWRlcyhhZGRyZXNzLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFkZHJlc3MgJHthZGRyZXNzfSBub3QgZm91bmQgaW4gdGhpcyBrZXlyaW5nYClcbiAgICB9XG4gICAgdGhpcy5hY2NvdW50cyA9IHRoaXMuYWNjb3VudHMuZmlsdGVyKChhKSA9PiBhLnRvTG93ZXJDYXNlKCkgIT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSlcbiAgICBkZWxldGUgdGhpcy5hY2NvdW50RGV0YWlsc1tldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpXVxuICB9XG5cbiAgYXR0ZW1wdE1ha2VBcHAgKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgIGFjdGlvbjogJ2xlZGdlci1tYWtlLWFwcCcsXG4gICAgICB9LCAoeyBzdWNjZXNzLCBlcnJvciB9KSA9PiB7XG4gICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgcmVzb2x2ZSh0cnVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgdXBkYXRlVHJhbnNwb3J0TWV0aG9kICh0cmFuc3BvcnRUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIElmIHRoZSBpZnJhbWUgaXNuJ3QgbG9hZGVkIHlldCwgbGV0J3Mgc3RvcmUgdGhlIGRlc2lyZWQgdHJhbnNwb3J0VHlwZSB2YWx1ZSBhbmRcbiAgICAgIC8vIG9wdGltaXN0aWNhbGx5IHJldHVybiBhIHN1Y2Nlc3NmdWwgcHJvbWlzZVxuICAgICAgaWYgKCF0aGlzLmlmcmFtZUxvYWRlZCkge1xuICAgICAgICB0aGlzLmRlbGF5ZWRQcm9taXNlID0ge1xuICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgIHRyYW5zcG9ydFR5cGUsXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgYWN0aW9uOiAnbGVkZ2VyLXVwZGF0ZS10cmFuc3BvcnQnLFxuICAgICAgICBwYXJhbXM6IHsgdHJhbnNwb3J0VHlwZSB9LFxuICAgICAgfSwgKHsgc3VjY2VzcyB9KSA9PiB7XG4gICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgcmVzb2x2ZSh0cnVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0xlZGdlciB0cmFuc3BvcnQgY291bGQgbm90IGJlIHVwZGF0ZWQnKSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLy8gdHggaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIGV0aGVyZXVtanMtdHJhbnNhY3Rpb24gY2xhc3MuXG4gIHNpZ25UcmFuc2FjdGlvbiAoYWRkcmVzcywgdHgpIHtcbiAgICBsZXQgcmF3VHhIZXhcbiAgICAvLyB0cmFuc2FjdGlvbnMgYnVpbHQgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBldGhlcmV1bWpzLXR4IGhhdmUgYVxuICAgIC8vIGdldENoYWluSWQgbWV0aG9kIHRoYXQgbmV3ZXIgdmVyc2lvbnMgZG8gbm90LiBPbGRlciB2ZXJzaW9ucyBhcmUgbXV0YWJsZVxuICAgIC8vIHdoaWxlIG5ld2VyIHZlcnNpb25zIGRlZmF1bHQgdG8gYmVpbmcgaW1tdXRhYmxlLiBFeHBlY3RlZCBzaGFwZSBhbmQgdHlwZVxuICAgIC8vIG9mIGRhdGEgZm9yIHYsIHIgYW5kIHMgZGlmZmVyIChCdWZmZXIgKG9sZCkgdnMgQk4gKG5ldykpXG4gICAgaWYgKHR5cGVvZiB0eC5nZXRDaGFpbklkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBJbiB0aGlzIHZlcnNpb24gb2YgZXRoZXJldW1qcy10eCB3ZSBtdXN0IGFkZCB0aGUgY2hhaW5JZCBpbiBoZXggZm9ybWF0XG4gICAgICAvLyB0byB0aGUgaW5pdGlhbCB2IHZhbHVlLiBUaGUgY2hhaW5JZCBtdXN0IGJlIGluY2x1ZGVkIGluIHRoZSBzZXJpYWxpemVkXG4gICAgICAvLyB0cmFuc2FjdGlvbiB3aGljaCBpcyBvbmx5IGNvbW11bmljYXRlZCB0byBldGhlcmV1bWpzLXR4IGluIHRoaXNcbiAgICAgIC8vIHZhbHVlLiBJbiBuZXdlciB2ZXJzaW9ucyB0aGUgY2hhaW5JZCBpcyBjb21tdW5pY2F0ZWQgdmlhIHRoZSAnQ29tbW9uJ1xuICAgICAgLy8gb2JqZWN0LlxuICAgICAgdHgudiA9IGV0aFV0aWwuYnVmZmVyVG9IZXgodHguZ2V0Q2hhaW5JZCgpKVxuICAgICAgdHguciA9ICcweDAwJ1xuICAgICAgdHgucyA9ICcweDAwJ1xuXG4gICAgICByYXdUeEhleCA9IHR4LnNlcmlhbGl6ZSgpLnRvU3RyaW5nKCdoZXgnKVxuXG4gICAgICByZXR1cm4gdGhpcy5fc2lnblRyYW5zYWN0aW9uKGFkZHJlc3MsIHJhd1R4SGV4LCAocGF5bG9hZCkgPT4ge1xuICAgICAgICB0eC52ID0gQnVmZmVyLmZyb20ocGF5bG9hZC52LCAnaGV4JylcbiAgICAgICAgdHguciA9IEJ1ZmZlci5mcm9tKHBheWxvYWQuciwgJ2hleCcpXG4gICAgICAgIHR4LnMgPSBCdWZmZXIuZnJvbShwYXlsb2FkLnMsICdoZXgnKVxuICAgICAgICByZXR1cm4gdHhcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gVGhlIGJlbG93IGBlbmNvZGVgIGNhbGwgaXMgb25seSBuZWNlc3NhcnkgZm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMsIGFzIGBnZXRNZXNzYWdlVG9TaWduYFxuICAgIC8vIGNhbGxzIGBybHAuZW5jb2RlYCBpbnRlcm5hbGx5IGZvciBub24tbGVnYWN5IHRyYW5zYWN0aW9ucy4gQXMgcGVyIHRoZSBcIlRyYW5zYWN0aW9uIEV4ZWN1dGlvblwiXG4gICAgLy8gc2VjdGlvbiBvZiB0aGUgZXRoZXJldW0geWVsbG93IHBhcGVyLCB0cmFuc2FjdGlvbnMgbmVlZCB0byBiZSBcIndlbGwtZm9ybWVkIFJMUCwgd2l0aCBubyBhZGRpdGlvbmFsXG4gICAgLy8gdHJhaWxpbmcgYnl0ZXNcIi5cblxuICAgIC8vIE5vdGUgYWxzbyB0aGF0IGBnZXRNZXNzYWdlVG9TaWduYCB3aWxsIHJldHVybiB2YWxpZCBSTFAgZm9yIGFsbCB0cmFuc2FjdGlvbiB0eXBlcywgd2hlcmVhcyB0aGVcbiAgICAvLyBgc2VyaWFsaXplYCBtZXRob2Qgd2lsbCBub3QgZm9yIGFueSB0cmFuc2FjdGlvbiB0eXBlIGV4Y2VwdCBsZWdhY3kuIFRoaXMgaXMgYmVjYXVzZSBgc2VyaWFsaXplYCBpbmNsdWRlc1xuICAgIC8vIGVtcHR5IHIsIHMgYW5kIHYgdmFsdWVzIGluIHRoZSBlbmNvZGVkIHJscC4gVGhpcyBpcyB3aHkgd2UgdXNlIGBnZXRNZXNzYWdlVG9TaWduYCBoZXJlIGluc3RlYWQgb2YgYHNlcmlhbGl6ZWAuXG4gICAgY29uc3QgbWVzc2FnZVRvU2lnbiA9IHR4LmdldE1lc3NhZ2VUb1NpZ24oZmFsc2UpXG5cbiAgICByYXdUeEhleCA9IEJ1ZmZlci5pc0J1ZmZlcihtZXNzYWdlVG9TaWduKVxuICAgICAgPyBtZXNzYWdlVG9TaWduLnRvU3RyaW5nKCdoZXgnKVxuICAgICAgOiBldGhVdGlsLnJscC5lbmNvZGUobWVzc2FnZVRvU2lnbikudG9TdHJpbmcoJ2hleCcpXG5cbiAgICByZXR1cm4gdGhpcy5fc2lnblRyYW5zYWN0aW9uKGFkZHJlc3MsIHJhd1R4SGV4LCAocGF5bG9hZCkgPT4ge1xuICAgICAgLy8gQmVjYXVzZSB0eCB3aWxsIGJlIGltbXV0YWJsZSwgZmlyc3QgZ2V0IGEgcGxhaW4gamF2YXNjcmlwdCBvYmplY3QgdGhhdFxuICAgICAgLy8gcmVwcmVzZW50cyB0aGUgdHJhbnNhY3Rpb24uIFVzaW5nIHR4RGF0YSBoZXJlIGFzIGl0IGFsaWducyB3aXRoIHRoZVxuICAgICAgLy8gbm9tZW5jbGF0dXJlIG9mIGV0aGVyZXVtanMvdHguXG4gICAgICBjb25zdCB0eERhdGEgPSB0eC50b0pTT04oKVxuICAgICAgLy8gVGhlIGZyb21UeERhdGEgdXRpbGl0eSBleHBlY3RzIGEgdHlwZSB0byBzdXBwb3J0IHRyYW5zYWN0aW9ucyB3aXRoIGEgdHlwZSBvdGhlciB0aGFuIDBcbiAgICAgIHR4RGF0YS50eXBlID0gdHgudHlwZVxuICAgICAgLy8gVGhlIGZyb21UeERhdGEgdXRpbGl0eSBleHBlY3RzIHYsciBhbmQgcyB0byBiZSBoZXggcHJlZml4ZWRcbiAgICAgIHR4RGF0YS52ID0gZXRoVXRpbC5hZGRIZXhQcmVmaXgocGF5bG9hZC52KVxuICAgICAgdHhEYXRhLnIgPSBldGhVdGlsLmFkZEhleFByZWZpeChwYXlsb2FkLnIpXG4gICAgICB0eERhdGEucyA9IGV0aFV0aWwuYWRkSGV4UHJlZml4KHBheWxvYWQucylcbiAgICAgIC8vIEFkb3B0IHRoZSAnY29tbW9uJyBvcHRpb24gZnJvbSB0aGUgb3JpZ2luYWwgdHJhbnNhY3Rpb24gYW5kIHNldCB0aGVcbiAgICAgIC8vIHJldHVybmVkIG9iamVjdCB0byBiZSBmcm96ZW4gaWYgdGhlIG9yaWdpbmFsIGlzIGZyb3plbi5cbiAgICAgIHJldHVybiBUcmFuc2FjdGlvbkZhY3RvcnkuZnJvbVR4RGF0YSh0eERhdGEsIHsgY29tbW9uOiB0eC5jb21tb24sIGZyZWV6ZTogT2JqZWN0LmlzRnJvemVuKHR4KSB9KVxuICAgIH0pXG4gIH1cblxuICBfc2lnblRyYW5zYWN0aW9uIChhZGRyZXNzLCByYXdUeEhleCwgaGFuZGxlU2lnbmluZykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnVubG9ja0FjY291bnRCeUFkZHJlc3MoYWRkcmVzcylcbiAgICAgICAgLnRoZW4oKGhkUGF0aCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIGFjdGlvbjogJ2xlZGdlci1zaWduLXRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICB0eDogcmF3VHhIZXgsXG4gICAgICAgICAgICAgIGhkUGF0aCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICAoeyBzdWNjZXNzLCBwYXlsb2FkIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG5cbiAgICAgICAgICAgICAgY29uc3QgbmV3T3JNdXRhdGVkVHggPSBoYW5kbGVTaWduaW5nKHBheWxvYWQpXG4gICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gbmV3T3JNdXRhdGVkVHgudmVyaWZ5U2lnbmF0dXJlKClcbiAgICAgICAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShuZXdPck11dGF0ZWRUeClcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdMZWRnZXI6IFRoZSB0cmFuc2FjdGlvbiBzaWduYXR1cmUgaXMgbm90IHZhbGlkJykpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdChwYXlsb2FkLmVycm9yIHx8IG5ldyBFcnJvcignTGVkZ2VyOiBVbmtub3duIGVycm9yIHdoaWxlIHNpZ25pbmcgdHJhbnNhY3Rpb24nKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgIH0pXG4gIH1cblxuICBzaWduTWVzc2FnZSAod2l0aEFjY291bnQsIGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5zaWduUGVyc29uYWxNZXNzYWdlKHdpdGhBY2NvdW50LCBkYXRhKVxuICB9XG5cbiAgLy8gRm9yIHBlcnNvbmFsX3NpZ24sIHdlIG5lZWQgdG8gcHJlZml4IHRoZSBtZXNzYWdlOlxuICBzaWduUGVyc29uYWxNZXNzYWdlICh3aXRoQWNjb3VudCwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnVubG9ja0FjY291bnRCeUFkZHJlc3Mod2l0aEFjY291bnQpXG4gICAgICAgIC50aGVuKChoZFBhdGgpID0+IHtcbiAgICAgICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICBhY3Rpb246ICdsZWRnZXItc2lnbi1wZXJzb25hbC1tZXNzYWdlJyxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICBoZFBhdGgsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGV0aFV0aWwuc3RyaXBIZXhQcmVmaXgobWVzc2FnZSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgKHsgc3VjY2VzcywgcGF5bG9hZCB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICBsZXQgdiA9IHBhcnNlSW50KHBheWxvYWQudiwgMTApXG4gICAgICAgICAgICAgIHYgPSB2LnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgICBpZiAodi5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgdiA9IGAwJHt2fWBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBgMHgke3BheWxvYWQucn0ke3BheWxvYWQuc30ke3Z9YFxuICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzU2lnbmVkV2l0aCA9IHNpZ1V0aWwucmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlKHsgZGF0YTogbWVzc2FnZSwgc2lnOiBzaWduYXR1cmUgfSlcbiAgICAgICAgICAgICAgaWYgKGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzc1NpZ25lZFdpdGgpICE9PSBldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKHdpdGhBY2NvdW50KSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0xlZGdlcjogVGhlIHNpZ25hdHVyZSBkb2VzbnQgbWF0Y2ggdGhlIHJpZ2h0IGFkZHJlc3MnKSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHNpZ25hdHVyZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdChwYXlsb2FkLmVycm9yIHx8IG5ldyBFcnJvcignTGVkZ2VyOiBVbmtub3duIGVycm9yIHdoaWxlIHNpZ25pbmcgbWVzc2FnZScpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIHVubG9ja0FjY291bnRCeUFkZHJlc3MgKGFkZHJlc3MpIHtcbiAgICBjb25zdCBjaGVja3N1bW1lZEFkZHJlc3MgPSBldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpXG4gICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLmFjY291bnREZXRhaWxzKS5pbmNsdWRlcyhjaGVja3N1bW1lZEFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYExlZGdlcjogQWNjb3VudCBmb3IgYWRkcmVzcyAnJHtjaGVja3N1bW1lZEFkZHJlc3N9JyBub3QgZm91bmRgKVxuICAgIH1cbiAgICBjb25zdCB7IGhkUGF0aCB9ID0gdGhpcy5hY2NvdW50RGV0YWlsc1tjaGVja3N1bW1lZEFkZHJlc3NdXG4gICAgY29uc3QgdW5sb2NrZWRBZGRyZXNzID0gYXdhaXQgdGhpcy51bmxvY2soaGRQYXRoLCBmYWxzZSlcblxuICAgIC8vIHVubG9jayByZXNvbHZlcyB0byB0aGUgYWRkcmVzcyBmb3IgdGhlIGdpdmVuIGhkUGF0aCBhcyByZXBvcnRlZCBieSB0aGUgbGVkZ2VyIGRldmljZVxuICAgIC8vIGlmIHRoYXQgYWRkcmVzcyBpcyBub3QgdGhlIHJlcXVlc3RlZCBhZGRyZXNzLCB0aGVuIHRoaXMgYWNjb3VudCBiZWxvbmdzIHRvIGEgZGlmZmVyZW50IGRldmljZSBvciBzZWVkXG4gICAgaWYgKHVubG9ja2VkQWRkcmVzcy50b0xvd2VyQ2FzZSgpICE9PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTGVkZ2VyOiBBY2NvdW50ICR7YWRkcmVzc30gZG9lcyBub3QgYmVsb25nIHRvIHRoZSBjb25uZWN0ZWQgZGV2aWNlYClcbiAgICB9XG4gICAgcmV0dXJuIGhkUGF0aFxuICB9XG5cbiAgYXN5bmMgc2lnblR5cGVkRGF0YSAod2l0aEFjY291bnQsIGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGlzVjQgPSBvcHRpb25zLnZlcnNpb24gPT09ICdWNCdcbiAgICBpZiAoIWlzVjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTGVkZ2VyOiBPbmx5IHZlcnNpb24gNCBvZiB0eXBlZCBkYXRhIHNpZ25pbmcgaXMgc3VwcG9ydGVkJylcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBkb21haW4sXG4gICAgICB0eXBlcyxcbiAgICAgIHByaW1hcnlUeXBlLFxuICAgICAgbWVzc2FnZSxcbiAgICB9ID0gc2lnVXRpbC5UeXBlZERhdGFVdGlscy5zYW5pdGl6ZURhdGEoZGF0YSlcbiAgICBjb25zdCBkb21haW5TZXBhcmF0b3JIZXggPSBzaWdVdGlsLlR5cGVkRGF0YVV0aWxzLmhhc2hTdHJ1Y3QoJ0VJUDcxMkRvbWFpbicsIGRvbWFpbiwgdHlwZXMsIGlzVjQpLnRvU3RyaW5nKCdoZXgnKVxuICAgIGNvbnN0IGhhc2hTdHJ1Y3RNZXNzYWdlSGV4ID0gc2lnVXRpbC5UeXBlZERhdGFVdGlscy5oYXNoU3RydWN0KHByaW1hcnlUeXBlLCBtZXNzYWdlLCB0eXBlcywgaXNWNCkudG9TdHJpbmcoJ2hleCcpXG5cbiAgICBjb25zdCBoZFBhdGggPSBhd2FpdCB0aGlzLnVubG9ja0FjY291bnRCeUFkZHJlc3Mod2l0aEFjY291bnQpXG4gICAgY29uc3QgeyBzdWNjZXNzLCBwYXlsb2FkIH0gPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBhY3Rpb246ICdsZWRnZXItc2lnbi10eXBlZC1kYXRhJyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgaGRQYXRoLFxuICAgICAgICAgIGRvbWFpblNlcGFyYXRvckhleCxcbiAgICAgICAgICBoYXNoU3RydWN0TWVzc2FnZUhleCxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICAocmVzdWx0KSA9PiByZXNvbHZlKHJlc3VsdCkpXG4gICAgfSlcblxuICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICBsZXQgdiA9IHBhcnNlSW50KHBheWxvYWQudiwgMTApXG4gICAgICB2ID0gdi50b1N0cmluZygxNilcbiAgICAgIGlmICh2Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdiA9IGAwJHt2fWBcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGAweCR7cGF5bG9hZC5yfSR7cGF5bG9hZC5zfSR7dn1gXG4gICAgICBjb25zdCBhZGRyZXNzU2lnbmVkV2l0aCA9IHNpZ1V0aWwucmVjb3ZlclR5cGVkU2lnbmF0dXJlX3Y0KHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc2lnOiBzaWduYXR1cmUsXG4gICAgICB9KVxuICAgICAgaWYgKGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzc1NpZ25lZFdpdGgpICE9PSBldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKHdpdGhBY2NvdW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xlZGdlcjogVGhlIHNpZ25hdHVyZSBkb2VzbnQgbWF0Y2ggdGhlIHJpZ2h0IGFkZHJlc3MnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNpZ25hdHVyZVxuICAgIH1cbiAgICB0aHJvdyBwYXlsb2FkLmVycm9yIHx8IG5ldyBFcnJvcignTGVkZ2VyOiBVbmtub3duIGVycm9yIHdoaWxlIHNpZ25pbmcgbWVzc2FnZScpXG4gIH1cblxuICBleHBvcnRBY2NvdW50ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2UnKVxuICB9XG5cbiAgZm9yZ2V0RGV2aWNlICgpIHtcbiAgICB0aGlzLmFjY291bnRzID0gW11cbiAgICB0aGlzLnBhZ2UgPSAwXG4gICAgdGhpcy51bmxvY2tlZEFjY291bnQgPSAwXG4gICAgdGhpcy5wYXRocyA9IHt9XG4gICAgdGhpcy5hY2NvdW50RGV0YWlscyA9IHt9XG4gICAgdGhpcy5oZGsgPSBuZXcgSERLZXkoKVxuICB9XG5cbiAgLyogUFJJVkFURSBNRVRIT0RTICovXG5cbiAgX3NldHVwSWZyYW1lICgpIHtcbiAgICB0aGlzLmlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpXG4gICAgdGhpcy5pZnJhbWUuc3JjID0gdGhpcy5icmlkZ2VVcmxcbiAgICB0aGlzLmlmcmFtZS5hbGxvdyA9IGBoaWQgJ3NyYydgXG4gICAgdGhpcy5pZnJhbWUub25sb2FkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gSWYgdGhlIGxlZGdlciBsaXZlIHByZWZlcmVuY2Ugd2FzIHNldCBiZWZvcmUgdGhlIGlmcmFtZSBpcyBsb2FkZWQsXG4gICAgICAvLyBzZXQgaXQgYWZ0ZXIgdGhlIGlmcmFtZSBoYXMgbG9hZGVkXG4gICAgICB0aGlzLmlmcmFtZUxvYWRlZCA9IHRydWVcbiAgICAgIGlmICh0aGlzLmRlbGF5ZWRQcm9taXNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy51cGRhdGVUcmFuc3BvcnRNZXRob2QoXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRQcm9taXNlLnRyYW5zcG9ydFR5cGUsXG4gICAgICAgICAgKVxuICAgICAgICAgIHRoaXMuZGVsYXllZFByb21pc2UucmVzb2x2ZShyZXN1bHQpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLmRlbGF5ZWRQcm9taXNlLnJlamVjdChlKVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmRlbGF5ZWRQcm9taXNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0aGlzLmlmcmFtZSlcbiAgfVxuXG4gIF9nZXRPcmlnaW4gKCkge1xuICAgIGNvbnN0IHRtcCA9IHRoaXMuYnJpZGdlVXJsLnNwbGl0KCcvJylcbiAgICB0bXAuc3BsaWNlKC0xLCAxKVxuICAgIHJldHVybiB0bXAuam9pbignLycpXG4gIH1cblxuICBfc2VuZE1lc3NhZ2UgKG1zZywgY2IpIHtcbiAgICBtc2cudGFyZ2V0ID0gJ0xFREdFUi1JRlJBTUUnXG5cbiAgICB0aGlzLmN1cnJlbnRNZXNzYWdlSWQgKz0gMVxuICAgIG1zZy5tZXNzYWdlSWQgPSB0aGlzLmN1cnJlbnRNZXNzYWdlSWRcblxuICAgIHRoaXMubWVzc2FnZUNhbGxiYWNrc1t0aGlzLmN1cnJlbnRNZXNzYWdlSWRdID0gY2JcbiAgICB0aGlzLmlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1zZywgJyonKVxuICB9XG5cbiAgX3NldHVwTGlzdGVuZXIgKCkge1xuICAgIHRoaXMuX2V2ZW50TGlzdGVuZXIgPSAoeyBvcmlnaW4sIGRhdGEgfSkgPT4ge1xuICAgICAgaWYgKG9yaWdpbiAhPT0gdGhpcy5fZ2V0T3JpZ2luKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLm1lc3NhZ2VDYWxsYmFja3NbZGF0YS5tZXNzYWdlSWRdKSB7XG4gICAgICAgICAgdGhpcy5tZXNzYWdlQ2FsbGJhY2tzW2RhdGEubWVzc2FnZUlkXShkYXRhKVxuICAgICAgICB9IGVsc2UgaWYgKGRhdGEuYWN0aW9uID09PSBDT05ORUNUSU9OX0VWRU5UKSB7XG4gICAgICAgICAgdGhpcy5pc0RldmljZUNvbm5lY3RlZCA9IGRhdGEucGF5bG9hZC5jb25uZWN0ZWRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fZXZlbnRMaXN0ZW5lcilcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fZXZlbnRMaXN0ZW5lcilcbiAgfVxuXG4gIGFzeW5jIF9fZ2V0UGFnZSAoaW5jcmVtZW50KSB7XG5cbiAgICB0aGlzLnBhZ2UgKz0gaW5jcmVtZW50XG5cbiAgICBpZiAodGhpcy5wYWdlIDw9IDApIHtcbiAgICAgIHRoaXMucGFnZSA9IDFcbiAgICB9XG4gICAgY29uc3QgZnJvbSA9ICh0aGlzLnBhZ2UgLSAxKSAqIHRoaXMucGVyUGFnZVxuICAgIGNvbnN0IHRvID0gZnJvbSArIHRoaXMucGVyUGFnZVxuXG4gICAgYXdhaXQgdGhpcy51bmxvY2soKVxuICAgIGxldCBhY2NvdW50c1xuICAgIGlmICh0aGlzLl9pc0xlZGdlckxpdmVIZFBhdGgoKSkge1xuICAgICAgYWNjb3VudHMgPSBhd2FpdCB0aGlzLl9nZXRBY2NvdW50c0JJUDQ0KGZyb20sIHRvKVxuICAgIH0gZWxzZSB7XG4gICAgICBhY2NvdW50cyA9IHRoaXMuX2dldEFjY291bnRzTGVnYWN5KGZyb20sIHRvKVxuICAgIH1cbiAgICByZXR1cm4gYWNjb3VudHNcbiAgfVxuXG4gIGFzeW5jIF9nZXRBY2NvdW50c0JJUDQ0IChmcm9tLCB0bykge1xuICAgIGNvbnN0IGFjY291bnRzID0gW11cblxuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgY29uc3QgcGF0aCA9IHRoaXMuX2dldFBhdGhGb3JJbmRleChpKVxuICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHRoaXMudW5sb2NrKHBhdGgpXG4gICAgICBjb25zdCB2YWxpZCA9IHRoaXMuaW1wbGVtZW50RnVsbEJJUDQ0ID8gYXdhaXQgdGhpcy5faGFzUHJldmlvdXNUcmFuc2FjdGlvbnMoYWRkcmVzcykgOiB0cnVlXG4gICAgICBhY2NvdW50cy5wdXNoKHtcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgYmFsYW5jZTogbnVsbCxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICB9KVxuICAgICAgLy8gUEVSIEJJUDQ0XG4gICAgICAvLyBcIlNvZnR3YXJlIHNob3VsZCBwcmV2ZW50IGEgY3JlYXRpb24gb2YgYW4gYWNjb3VudCBpZlxuICAgICAgLy8gYSBwcmV2aW91cyBhY2NvdW50IGRvZXMgbm90IGhhdmUgYSB0cmFuc2FjdGlvbiBoaXN0b3J5XG4gICAgICAvLyAobWVhbmluZyBub25lIG9mIGl0cyBhZGRyZXNzZXMgaGF2ZSBiZWVuIHVzZWQgYmVmb3JlKS5cIlxuICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWNjb3VudHNcbiAgfVxuXG4gIF9nZXRBY2NvdW50c0xlZ2FjeSAoZnJvbSwgdG8pIHtcbiAgICBjb25zdCBhY2NvdW50cyA9IFtdXG5cbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLl9hZGRyZXNzRnJvbUluZGV4KHBhdGhCYXNlLCBpKVxuICAgICAgYWNjb3VudHMucHVzaCh7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGJhbGFuY2U6IG51bGwsXG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgfSlcbiAgICAgIHRoaXMucGF0aHNbZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKV0gPSBpXG4gICAgfVxuICAgIHJldHVybiBhY2NvdW50c1xuICB9XG5cbiAgX3BhZExlZnRFdmVuIChoZXgpIHtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAlIDIgPT09IDAgPyBoZXggOiBgMCR7aGV4fWBcbiAgfVxuXG4gIF9ub3JtYWxpemUgKGJ1Zikge1xuICAgIHJldHVybiB0aGlzLl9wYWRMZWZ0RXZlbihldGhVdGlsLmJ1ZmZlclRvSGV4KGJ1ZikudG9Mb3dlckNhc2UoKSlcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcbiAgX2FkZHJlc3NGcm9tSW5kZXggKHBhdGhCYXNlLCBpKSB7XG4gICAgY29uc3QgZGtleSA9IHRoaXMuaGRrLmRlcml2ZShgJHtwYXRoQmFzZX0vJHtpfWApXG4gICAgY29uc3QgYWRkcmVzcyA9IGV0aFV0aWxcbiAgICAgIC5wdWJsaWNUb0FkZHJlc3MoZGtleS5wdWJsaWNLZXksIHRydWUpXG4gICAgICAudG9TdHJpbmcoJ2hleCcpXG4gICAgcmV0dXJuIGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYDB4JHthZGRyZXNzfWApXG4gIH1cblxuICBfcGF0aEZyb21BZGRyZXNzIChhZGRyZXNzKSB7XG4gICAgY29uc3QgY2hlY2tzdW1tZWRBZGRyZXNzID0gZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKVxuICAgIGxldCBpbmRleCA9IHRoaXMucGF0aHNbY2hlY2tzdW1tZWRBZGRyZXNzXVxuICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1BWF9JTkRFWDsgaSsrKSB7XG4gICAgICAgIGlmIChjaGVja3N1bW1lZEFkZHJlc3MgPT09IHRoaXMuX2FkZHJlc3NGcm9tSW5kZXgocGF0aEJhc2UsIGkpKSB7XG4gICAgICAgICAgaW5kZXggPSBpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gYWRkcmVzcycpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9nZXRQYXRoRm9ySW5kZXgoaW5kZXgpXG4gIH1cblxuICBfdG9Bc2NpaSAoaGV4KSB7XG4gICAgbGV0IHN0ciA9ICcnXG4gICAgbGV0IGkgPSAwXG4gICAgY29uc3QgbCA9IGhleC5sZW5ndGhcbiAgICBpZiAoaGV4LnN1YnN0cmluZygwLCAyKSA9PT0gJzB4Jykge1xuICAgICAgaSA9IDJcbiAgICB9XG4gICAgZm9yICg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNilcbiAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0clxuICB9XG5cbiAgX2dldFBhdGhGb3JJbmRleCAoaW5kZXgpIHtcbiAgICAvLyBDaGVjayBpZiB0aGUgcGF0aCBpcyBCSVAgNDQgKExlZGdlciBMaXZlKVxuICAgIHJldHVybiB0aGlzLl9pc0xlZGdlckxpdmVIZFBhdGgoKSA/IGBtLzQ0Jy82MCcvJHtpbmRleH0nLzAvMGAgOiBgJHt0aGlzLmhkUGF0aH0vJHtpbmRleH1gXG4gIH1cblxuICBfaXNMZWRnZXJMaXZlSGRQYXRoICgpIHtcbiAgICByZXR1cm4gdGhpcy5oZFBhdGggPT09IGBtLzQ0Jy82MCcvMCcvMC8wYFxuICB9XG5cbiAgX3RvTGVkZ2VyUGF0aCAocGF0aCkge1xuICAgIHJldHVybiBwYXRoLnRvU3RyaW5nKCkucmVwbGFjZSgnbS8nLCAnJylcbiAgfVxuXG4gIGFzeW5jIF9oYXNQcmV2aW91c1RyYW5zYWN0aW9ucyAoYWRkcmVzcykge1xuICAgIGNvbnN0IGFwaVVybCA9IHRoaXMuX2dldEFwaVVybCgpXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB3aW5kb3cuZmV0Y2goYCR7YXBpVXJsfS9hcGk/bW9kdWxlPWFjY291bnQmYWN0aW9uPXR4bGlzdCZhZGRyZXNzPSR7YWRkcmVzc30mdGFnPWxhdGVzdCZwYWdlPTEmb2Zmc2V0PTFgKVxuICAgIGNvbnN0IHBhcnNlZFJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgaWYgKHBhcnNlZFJlc3BvbnNlLnN0YXR1cyAhPT0gJzAnICYmIHBhcnNlZFJlc3BvbnNlLnJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIF9nZXRBcGlVcmwgKCkge1xuICAgIHJldHVybiBORVRXT1JLX0FQSV9VUkxTW3RoaXMubmV0d29ya10gfHwgTkVUV09SS19BUElfVVJMUy5tYWlubmV0XG4gIH1cblxufVxuXG5MZWRnZXJCcmlkZ2VLZXlyaW5nLnR5cGUgPSB0eXBlXG5tb2R1bGUuZXhwb3J0cyA9IExlZGdlckJyaWRnZUtleXJpbmdcbiIsImNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgZXRoVXRpbCA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtdXRpbCcpXG5jb25zdCBldGhBYmkgPSByZXF1aXJlKCdldGhlcmV1bWpzLWFiaScpXG5jb25zdCBuYWNsID0gcmVxdWlyZSgndHdlZXRuYWNsJylcbm5hY2wudXRpbCA9IHJlcXVpcmUoJ3R3ZWV0bmFjbC11dGlsJylcblxuY29uc3QgVFlQRURfTUVTU0FHRV9TQ0hFTUEgPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdHlwZXM6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHtcbiAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBuYW1lOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgICAgICB0eXBlOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXF1aXJlZDogWyduYW1lJywgJ3R5cGUnXSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBwcmltYXJ5VHlwZTogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgIGRvbWFpbjogeyB0eXBlOiAnb2JqZWN0JyB9LFxuICAgIG1lc3NhZ2U6IHsgdHlwZTogJ29iamVjdCcgfSxcbiAgfSxcbiAgcmVxdWlyZWQ6IFsndHlwZXMnLCAncHJpbWFyeVR5cGUnLCAnZG9tYWluJywgJ21lc3NhZ2UnXSxcbn1cblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgdXRpbGl0eSBmdW5jdGlvbnMgdXNlZCBmb3Igc2lnbmluZyB0eXBlZCBkYXRhXG4gKi9cbmNvbnN0IFR5cGVkRGF0YVV0aWxzID0ge1xuXG4gIC8qKlxuICAgKiBFbmNvZGVzIGFuIG9iamVjdCBieSBlbmNvZGluZyBhbmQgY29uY2F0ZW5hdGluZyBlYWNoIG9mIGl0cyBtZW1iZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmltYXJ5VHlwZSAtIFJvb3QgdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIE9iamVjdCB0byBlbmNvZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVzIC0gVHlwZSBkZWZpbml0aW9uc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIEVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0XG4gICAqL1xuICBlbmNvZGVEYXRhIChwcmltYXJ5VHlwZSwgZGF0YSwgdHlwZXMsIHVzZVY0ID0gdHJ1ZSkge1xuICAgIGNvbnN0IGVuY29kZWRUeXBlcyA9IFsnYnl0ZXMzMiddXG4gICAgY29uc3QgZW5jb2RlZFZhbHVlcyA9IFt0aGlzLmhhc2hUeXBlKHByaW1hcnlUeXBlLCB0eXBlcyldXG5cbiAgICBpZiAodXNlVjQpIHtcbiAgICAgIGNvbnN0IGVuY29kZUZpZWxkID0gKG5hbWUsIHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlc1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcgOlxuICAgICAgICAgICAgZXRoVXRpbC5rZWNjYWsodGhpcy5lbmNvZGVEYXRhKHR5cGUsIHZhbHVlLCB0eXBlcywgdXNlVjQpKV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIHZhbHVlIGZvciBmaWVsZCAke25hbWV9IG9mIHR5cGUgJHt0eXBlfWApXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ2J5dGVzJykge1xuICAgICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCBldGhVdGlsLmtlY2Nhayh2YWx1ZSldXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBjb252ZXJ0IHN0cmluZyB0byBidWZmZXIgLSBwcmV2ZW50cyBldGhVdGlsIGZyb20gaW50ZXJwcmV0aW5nIHN0cmluZ3MgbGlrZSAnMHhhYmNkJyBhcyBoZXhcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSwgJ3V0ZjgnKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gWydieXRlczMyJywgZXRoVXRpbC5rZWNjYWsodmFsdWUpXVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUubGFzdEluZGV4T2YoJ10nKSA9PT0gdHlwZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHR5cGUuc2xpY2UoMCwgdHlwZS5sYXN0SW5kZXhPZignWycpKVxuICAgICAgICAgIGNvbnN0IHR5cGVWYWx1ZVBhaXJzID0gdmFsdWUubWFwKChpdGVtKSA9PiBlbmNvZGVGaWVsZChuYW1lLCBwYXJzZWRUeXBlLCBpdGVtKSlcbiAgICAgICAgICByZXR1cm4gWydieXRlczMyJywgZXRoVXRpbC5rZWNjYWsoZXRoQWJpLnJhd0VuY29kZShcbiAgICAgICAgICAgIHR5cGVWYWx1ZVBhaXJzLm1hcCgoW190eXBlXSkgPT4gX3R5cGUpLFxuICAgICAgICAgICAgdHlwZVZhbHVlUGFpcnMubWFwKChbLCBfdmFsdWVdKSA9PiBfdmFsdWUpLFxuICAgICAgICAgICkpXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFt0eXBlLCB2YWx1ZV1cbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlc1twcmltYXJ5VHlwZV0pIHtcbiAgICAgICAgY29uc3QgW3R5cGUsIHZhbHVlXSA9IGVuY29kZUZpZWxkKGZpZWxkLm5hbWUsIGZpZWxkLnR5cGUsIGRhdGFbZmllbGQubmFtZV0pXG4gICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKHR5cGUpXG4gICAgICAgIGVuY29kZWRWYWx1ZXMucHVzaCh2YWx1ZSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlc1twcmltYXJ5VHlwZV0pIHtcbiAgICAgICAgbGV0IHZhbHVlID0gZGF0YVtmaWVsZC5uYW1lXVxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChmaWVsZC50eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgICAgICAgICBlbmNvZGVkVHlwZXMucHVzaCgnYnl0ZXMzMicpXG4gICAgICAgICAgICB2YWx1ZSA9IGV0aFV0aWwua2VjY2FrKHZhbHVlKVxuICAgICAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKCdieXRlczMyJylcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgc3RyaW5nIHRvIGJ1ZmZlciAtIHByZXZlbnRzIGV0aFV0aWwgZnJvbSBpbnRlcnByZXRpbmcgc3RyaW5ncyBsaWtlICcweGFiY2QnIGFzIGhleFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSwgJ3V0ZjgnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBldGhVdGlsLmtlY2Nhayh2YWx1ZSlcbiAgICAgICAgICAgIGVuY29kZWRWYWx1ZXMucHVzaCh2YWx1ZSlcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVzW2ZpZWxkLnR5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKCdieXRlczMyJylcbiAgICAgICAgICAgIHZhbHVlID0gZXRoVXRpbC5rZWNjYWsodGhpcy5lbmNvZGVEYXRhKGZpZWxkLnR5cGUsIHZhbHVlLCB0eXBlcywgdXNlVjQpKVxuICAgICAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQudHlwZS5sYXN0SW5kZXhPZignXScpID09PSBmaWVsZC50eXBlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXJyYXlzIGN1cnJlbnRseSB1bmltcGxlbWVudGVkIGluIGVuY29kZURhdGEnKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmNvZGVkVHlwZXMucHVzaChmaWVsZC50eXBlKVxuICAgICAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBldGhBYmkucmF3RW5jb2RlKGVuY29kZWRUeXBlcywgZW5jb2RlZFZhbHVlcylcbiAgfSxcblxuICAvKipcbiAgICogRW5jb2RlcyB0aGUgdHlwZSBvZiBhbiBvYmplY3QgYnkgZW5jb2RpbmcgYSBjb21tYSBkZWxpbWl0ZWQgbGlzdCBvZiBpdHMgbWVtYmVyc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJpbWFyeVR5cGUgLSBSb290IHR5cGUgdG8gZW5jb2RlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnNcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBFbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0eXBlIG9mIGFuIG9iamVjdFxuICAgKi9cbiAgZW5jb2RlVHlwZSAocHJpbWFyeVR5cGUsIHR5cGVzKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnXG4gICAgbGV0IGRlcHMgPSB0aGlzLmZpbmRUeXBlRGVwZW5kZW5jaWVzKHByaW1hcnlUeXBlLCB0eXBlcykuZmlsdGVyKChkZXApID0+IGRlcCAhPT0gcHJpbWFyeVR5cGUpXG4gICAgZGVwcyA9IFtwcmltYXJ5VHlwZV0uY29uY2F0KGRlcHMuc29ydCgpKVxuICAgIGZvciAoY29uc3QgdHlwZSBvZiBkZXBzKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHR5cGVzW3R5cGVdXG4gICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gdHlwZSBkZWZpbml0aW9uIHNwZWNpZmllZDogJHt0eXBlfWApXG4gICAgICB9XG4gICAgICByZXN1bHQgKz0gYCR7dHlwZX0oJHt0eXBlc1t0eXBlXS5tYXAoKHsgbmFtZSwgdHlwZTogX3R5cGUgfSkgPT4gYCR7X3R5cGV9ICR7bmFtZX1gKS5qb2luKCcsJyl9KWBcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbGwgdHlwZXMgd2l0aGluIGEgdHlwZSBkZWZpbnRpb24gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmltYXJ5VHlwZSAtIFJvb3QgdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlc3VsdHMgLSBjdXJyZW50IHNldCBvZiBhY2N1bXVsYXRlZCB0eXBlc1xuICAgKiBAcmV0dXJucyB7QXJyYXl9IC0gU2V0IG9mIGFsbCB0eXBlcyBmb3VuZCBpbiB0aGUgdHlwZSBkZWZpbml0aW9uXG4gICAqL1xuICBmaW5kVHlwZURlcGVuZGVuY2llcyAocHJpbWFyeVR5cGUsIHR5cGVzLCByZXN1bHRzID0gW10pIHtcbiAgICBjb25zdCBbZmlyc3RXb3JkXSA9IHByaW1hcnlUeXBlLm1hdGNoKC9eXFx3Ki91KVxuICAgIHByaW1hcnlUeXBlID0gZmlyc3RXb3JkXG4gICAgaWYgKHJlc3VsdHMuaW5jbHVkZXMocHJpbWFyeVR5cGUpIHx8IHR5cGVzW3ByaW1hcnlUeXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0c1xuICAgIH1cbiAgICByZXN1bHRzLnB1c2gocHJpbWFyeVR5cGUpXG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlc1twcmltYXJ5VHlwZV0pIHtcbiAgICAgIGZvciAoY29uc3QgZGVwIG9mIHRoaXMuZmluZFR5cGVEZXBlbmRlbmNpZXMoZmllbGQudHlwZSwgdHlwZXMsIHJlc3VsdHMpKSB7XG4gICAgICAgICFyZXN1bHRzLmluY2x1ZGVzKGRlcCkgJiYgcmVzdWx0cy5wdXNoKGRlcClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfSxcblxuICAvKipcbiAgICogSGFzaGVzIGFuIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJpbWFyeVR5cGUgLSBSb290IHR5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBPYmplY3QgdG8gaGFzaFxuICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gSGFzaCBvZiBhbiBvYmplY3RcbiAgICovXG4gIGhhc2hTdHJ1Y3QgKHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdXNlVjQgPSB0cnVlKSB7XG4gICAgcmV0dXJuIGV0aFV0aWwua2VjY2FrKHRoaXMuZW5jb2RlRGF0YShwcmltYXJ5VHlwZSwgZGF0YSwgdHlwZXMsIHVzZVY0KSlcbiAgfSxcblxuICAvKipcbiAgICogSGFzaGVzIHRoZSB0eXBlIG9mIGFuIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJpbWFyeVR5cGUgLSBSb290IHR5cGUgdG8gaGFzaFxuICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gSGFzaCBvZiBhbiBvYmplY3RcbiAgICovXG4gIGhhc2hUeXBlIChwcmltYXJ5VHlwZSwgdHlwZXMpIHtcbiAgICByZXR1cm4gZXRoVXRpbC5rZWNjYWsodGhpcy5lbmNvZGVUeXBlKHByaW1hcnlUeXBlLCB0eXBlcykpXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgcHJvcGVydGllcyBmcm9tIGEgbWVzc2FnZSBvYmplY3QgdGhhdCBhcmUgbm90IGRlZmluZWQgcGVyIEVJUC03MTJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSB0eXBlZCBtZXNzYWdlIG9iamVjdFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSAtIHR5cGVkIG1lc3NhZ2Ugb2JqZWN0IHdpdGggb25seSBhbGxvd2VkIGZpZWxkc1xuICAgKi9cbiAgc2FuaXRpemVEYXRhIChkYXRhKSB7XG4gICAgY29uc3Qgc2FuaXRpemVkRGF0YSA9IHt9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoVFlQRURfTUVTU0FHRV9TQ0hFTUEucHJvcGVydGllcykpIHtcbiAgICAgIGRhdGFba2V5XSAmJiAoc2FuaXRpemVkRGF0YVtrZXldID0gZGF0YVtrZXldKVxuICAgIH1cbiAgICBpZiAoc2FuaXRpemVkRGF0YS50eXBlcykge1xuICAgICAgc2FuaXRpemVkRGF0YS50eXBlcyA9IHsgRUlQNzEyRG9tYWluOiBbXSwgLi4uc2FuaXRpemVkRGF0YS50eXBlcyB9XG4gICAgfVxuICAgIHJldHVybiBzYW5pdGl6ZWREYXRhXG4gIH0sXG5cbiAgLyoqXG4gICAqIFNpZ25zIGEgdHlwZWQgbWVzc2FnZSBhcyBwZXIgRUlQLTcxMiBhbmQgcmV0dXJucyBpdHMga2VjY2FrIGhhc2hcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVkRGF0YSAtIFR5cGVzIG1lc3NhZ2UgZGF0YSB0byBzaWduXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0ga2VjY2FrIGhhc2ggb2YgdGhlIHJlc3VsdGluZyBzaWduZWQgbWVzc2FnZVxuICAgKi9cbiAgc2lnbiAodHlwZWREYXRhLCB1c2VWNCA9IHRydWUpIHtcbiAgICBjb25zdCBzYW5pdGl6ZWREYXRhID0gdGhpcy5zYW5pdGl6ZURhdGEodHlwZWREYXRhKVxuICAgIGNvbnN0IHBhcnRzID0gW0J1ZmZlci5mcm9tKCcxOTAxJywgJ2hleCcpXVxuICAgIHBhcnRzLnB1c2godGhpcy5oYXNoU3RydWN0KCdFSVA3MTJEb21haW4nLCBzYW5pdGl6ZWREYXRhLmRvbWFpbiwgc2FuaXRpemVkRGF0YS50eXBlcywgdXNlVjQpKVxuICAgIGlmIChzYW5pdGl6ZWREYXRhLnByaW1hcnlUeXBlICE9PSAnRUlQNzEyRG9tYWluJykge1xuICAgICAgcGFydHMucHVzaCh0aGlzLmhhc2hTdHJ1Y3Qoc2FuaXRpemVkRGF0YS5wcmltYXJ5VHlwZSwgc2FuaXRpemVkRGF0YS5tZXNzYWdlLCBzYW5pdGl6ZWREYXRhLnR5cGVzLCB1c2VWNCkpXG4gICAgfVxuICAgIHJldHVybiBldGhVdGlsLmtlY2NhayhCdWZmZXIuY29uY2F0KHBhcnRzKSlcbiAgfSxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFRZUEVEX01FU1NBR0VfU0NIRU1BLFxuICBUeXBlZERhdGFVdGlscyxcblxuICBjb25jYXRTaWcgKHYsIHIsIHMpIHtcbiAgICBjb25zdCByU2lnID0gZXRoVXRpbC5mcm9tU2lnbmVkKHIpXG4gICAgY29uc3Qgc1NpZyA9IGV0aFV0aWwuZnJvbVNpZ25lZChzKVxuICAgIGNvbnN0IHZTaWcgPSBldGhVdGlsLmJ1ZmZlclRvSW50KHYpXG4gICAgY29uc3QgclN0ciA9IHBhZFdpdGhaZXJvZXMoZXRoVXRpbC50b1Vuc2lnbmVkKHJTaWcpLnRvU3RyaW5nKCdoZXgnKSwgNjQpXG4gICAgY29uc3Qgc1N0ciA9IHBhZFdpdGhaZXJvZXMoZXRoVXRpbC50b1Vuc2lnbmVkKHNTaWcpLnRvU3RyaW5nKCdoZXgnKSwgNjQpXG4gICAgY29uc3QgdlN0ciA9IGV0aFV0aWwuc3RyaXBIZXhQcmVmaXgoZXRoVXRpbC5pbnRUb0hleCh2U2lnKSlcbiAgICByZXR1cm4gZXRoVXRpbC5hZGRIZXhQcmVmaXgoclN0ci5jb25jYXQoc1N0ciwgdlN0cikpLnRvU3RyaW5nKCdoZXgnKVxuICB9LFxuXG4gIG5vcm1hbGl6ZSAoaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGV0aFV0aWwudG9CdWZmZXIoaW5wdXQpXG4gICAgICBpbnB1dCA9IGV0aFV0aWwuYnVmZmVyVG9IZXgoYnVmZmVyKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBsZXQgbXNnID0gJ2V0aC1zaWctdXRpbC5ub3JtYWxpemUoKSByZXF1aXJlcyBoZXggc3RyaW5nIG9yIGludGVnZXIgaW5wdXQuJ1xuICAgICAgbXNnICs9IGAgcmVjZWl2ZWQgJHt0eXBlb2YgaW5wdXR9OiAke2lucHV0fWBcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpXG4gICAgfVxuXG4gICAgcmV0dXJuIGV0aFV0aWwuYWRkSGV4UHJlZml4KGlucHV0LnRvTG93ZXJDYXNlKCkpXG4gIH0sXG5cbiAgcGVyc29uYWxTaWduIChwcml2YXRlS2V5LCBtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZXRoVXRpbC50b0J1ZmZlcihtc2dQYXJhbXMuZGF0YSlcbiAgICBjb25zdCBtc2dIYXNoID0gZXRoVXRpbC5oYXNoUGVyc29uYWxNZXNzYWdlKG1lc3NhZ2UpXG4gICAgY29uc3Qgc2lnID0gZXRoVXRpbC5lY3NpZ24obXNnSGFzaCwgcHJpdmF0ZUtleSlcbiAgICBjb25zdCBzZXJpYWxpemVkID0gZXRoVXRpbC5idWZmZXJUb0hleCh0aGlzLmNvbmNhdFNpZyhzaWcudiwgc2lnLnIsIHNpZy5zKSlcbiAgICByZXR1cm4gc2VyaWFsaXplZFxuICB9LFxuXG4gIHJlY292ZXJQZXJzb25hbFNpZ25hdHVyZSAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5Rm9yKG1zZ1BhcmFtcylcbiAgICBjb25zdCBzZW5kZXIgPSBldGhVdGlsLnB1YmxpY1RvQWRkcmVzcyhwdWJsaWNLZXkpXG4gICAgY29uc3Qgc2VuZGVySGV4ID0gZXRoVXRpbC5idWZmZXJUb0hleChzZW5kZXIpXG4gICAgcmV0dXJuIHNlbmRlckhleFxuICB9LFxuXG4gIGV4dHJhY3RQdWJsaWNLZXkgKG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGdldFB1YmxpY0tleUZvcihtc2dQYXJhbXMpXG4gICAgcmV0dXJuIGAweCR7cHVibGljS2V5LnRvU3RyaW5nKCdoZXgnKX1gXG4gIH0sXG5cbiAgdHlwZWRTaWduYXR1cmVIYXNoICh0eXBlZERhdGEpIHtcbiAgICBjb25zdCBoYXNoQnVmZmVyID0gdHlwZWRTaWduYXR1cmVIYXNoKHR5cGVkRGF0YSlcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleChoYXNoQnVmZmVyKVxuICB9LFxuXG4gIHNpZ25UeXBlZERhdGFMZWdhY3kgKHByaXZhdGVLZXksIG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IG1zZ0hhc2ggPSB0eXBlZFNpZ25hdHVyZUhhc2gobXNnUGFyYW1zLmRhdGEpXG4gICAgY29uc3Qgc2lnID0gZXRoVXRpbC5lY3NpZ24obXNnSGFzaCwgcHJpdmF0ZUtleSlcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleCh0aGlzLmNvbmNhdFNpZyhzaWcudiwgc2lnLnIsIHNpZy5zKSlcbiAgfSxcblxuICByZWNvdmVyVHlwZWRTaWduYXR1cmVMZWdhY3kgKG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IG1zZ0hhc2ggPSB0eXBlZFNpZ25hdHVyZUhhc2gobXNnUGFyYW1zLmRhdGEpXG4gICAgY29uc3QgcHVibGljS2V5ID0gcmVjb3ZlclB1YmxpY0tleShtc2dIYXNoLCBtc2dQYXJhbXMuc2lnKVxuICAgIGNvbnN0IHNlbmRlciA9IGV0aFV0aWwucHVibGljVG9BZGRyZXNzKHB1YmxpY0tleSlcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleChzZW5kZXIpXG4gIH0sXG5cbiAgZW5jcnlwdCAocmVjZWl2ZXJQdWJsaWNLZXksIG1zZ1BhcmFtcywgdmVyc2lvbikge1xuXG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICBjYXNlICd4MjU1MTkteHNhbHNhMjAtcG9seTEzMDUnOiB7XG4gICAgICAgIGlmICh0eXBlb2YgbXNnUGFyYW1zLmRhdGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGV0ZWN0IHNlY3JldCBtZXNzYWdlLCBtZXNzYWdlIHBhcmFtcyBzaG91bGQgYmUgb2YgdGhlIGZvcm0ge2RhdGE6IFwic2VjcmV0IG1lc3NhZ2VcIn0gJylcbiAgICAgICAgfVxuICAgICAgICAvLyBnZW5lcmF0ZSBlcGhlbWVyYWwga2V5cGFpclxuICAgICAgICBjb25zdCBlcGhlbWVyYWxLZXlQYWlyID0gbmFjbC5ib3gua2V5UGFpcigpXG5cbiAgICAgICAgLy8gYXNzZW1ibGUgZW5jcnlwdGlvbiBwYXJhbWV0ZXJzIC0gZnJvbSBzdHJpbmcgdG8gVUludDhcbiAgICAgICAgbGV0IHB1YktleVVJbnQ4QXJyYXlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwdWJLZXlVSW50OEFycmF5ID0gbmFjbC51dGlsLmRlY29kZUJhc2U2NChyZWNlaXZlclB1YmxpY0tleSlcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgcHVibGljIGtleScpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtc2dQYXJhbXNVSW50OEFycmF5ID0gbmFjbC51dGlsLmRlY29kZVVURjgobXNnUGFyYW1zLmRhdGEpXG4gICAgICAgIGNvbnN0IG5vbmNlID0gbmFjbC5yYW5kb21CeXRlcyhuYWNsLmJveC5ub25jZUxlbmd0aClcblxuICAgICAgICAvLyBlbmNyeXB0XG4gICAgICAgIGNvbnN0IGVuY3J5cHRlZE1lc3NhZ2UgPSBuYWNsLmJveChtc2dQYXJhbXNVSW50OEFycmF5LCBub25jZSwgcHViS2V5VUludDhBcnJheSwgZXBoZW1lcmFsS2V5UGFpci5zZWNyZXRLZXkpXG5cbiAgICAgICAgLy8gaGFuZGxlIGVuY3J5cHRlZCBkYXRhXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgICAgICB2ZXJzaW9uOiAneDI1NTE5LXhzYWxzYTIwLXBvbHkxMzA1JyxcbiAgICAgICAgICBub25jZTogbmFjbC51dGlsLmVuY29kZUJhc2U2NChub25jZSksXG4gICAgICAgICAgZXBoZW1QdWJsaWNLZXk6IG5hY2wudXRpbC5lbmNvZGVCYXNlNjQoZXBoZW1lcmFsS2V5UGFpci5wdWJsaWNLZXkpLFxuICAgICAgICAgIGNpcGhlcnRleHQ6IG5hY2wudXRpbC5lbmNvZGVCYXNlNjQoZW5jcnlwdGVkTWVzc2FnZSksXG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIGVuY3J5cHRlZCBtc2cgZGF0YVxuICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gdHlwZS92ZXJzaW9uIG5vdCBzdXBwb3J0ZWQnKVxuXG4gICAgfVxuICB9LFxuXG4gIGVuY3J5cHRTYWZlbHkgKHJlY2VpdmVyUHVibGljS2V5LCBtc2dQYXJhbXMsIHZlcnNpb24pIHtcblxuICAgIGNvbnN0IERFRkFVTFRfUEFERElOR19MRU5HVEggPSAoMiAqKiAxMSlcbiAgICBjb25zdCBOQUNMX0VYVFJBX0JZVEVTID0gMTZcblxuICAgIGNvbnN0IHsgZGF0YSB9ID0gbXNnUGFyYW1zXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBlbmNyeXB0IGVtcHR5IG1zZy5kYXRhJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEudG9KU09OKSB7XG4gICAgICAvLyByZW1vdmUgdG9KU09OIGF0dGFjayB2ZWN0b3JcbiAgICAgIC8vIFRPRE8sIGNoZWNrIGFsbCBwb3NzaWJsZSBjaGlsZHJlblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZW5jcnlwdCB3aXRoIHRvSlNPTiBwcm9wZXJ0eS4gIFBsZWFzZSByZW1vdmUgdG9KU09OIHByb3BlcnR5JylcbiAgICB9XG5cbiAgICAvLyBhZGQgcGFkZGluZ1xuICAgIGNvbnN0IGRhdGFXaXRoUGFkZGluZyA9IHtcbiAgICAgIGRhdGEsXG4gICAgICBwYWRkaW5nOiAnJyxcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgcGFkZGluZ1xuICAgIGNvbnN0IGRhdGFMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChKU09OLnN0cmluZ2lmeShkYXRhV2l0aFBhZGRpbmcpLCAndXRmLTgnKVxuICAgIGNvbnN0IG1vZFZhbCA9IChkYXRhTGVuZ3RoICUgREVGQVVMVF9QQURESU5HX0xFTkdUSClcbiAgICBsZXQgcGFkTGVuZ3RoID0gMFxuICAgIC8vIE9ubHkgcGFkIGlmIG5lY2Vzc2FyeVxuICAgIGlmIChtb2RWYWwgPiAwKSB7XG4gICAgICBwYWRMZW5ndGggPSAoREVGQVVMVF9QQURESU5HX0xFTkdUSCAtIG1vZFZhbCkgLSBOQUNMX0VYVFJBX0JZVEVTIC8vIG5hY2wgZXh0cmEgYnl0ZXNcbiAgICB9XG4gICAgZGF0YVdpdGhQYWRkaW5nLnBhZGRpbmcgPSAnMCcucmVwZWF0KHBhZExlbmd0aClcblxuICAgIGNvbnN0IHBhZGRlZE1zZ1BhcmFtcyA9IHsgZGF0YTogSlNPTi5zdHJpbmdpZnkoZGF0YVdpdGhQYWRkaW5nKSB9XG4gICAgcmV0dXJuIHRoaXMuZW5jcnlwdChyZWNlaXZlclB1YmxpY0tleSwgcGFkZGVkTXNnUGFyYW1zLCB2ZXJzaW9uKVxuICB9LFxuXG4gIGRlY3J5cHQgKGVuY3J5cHRlZERhdGEsIHJlY2VpdmVyUHJpdmF0ZUtleSkge1xuXG4gICAgc3dpdGNoIChlbmNyeXB0ZWREYXRhLnZlcnNpb24pIHtcbiAgICAgIGNhc2UgJ3gyNTUxOS14c2Fsc2EyMC1wb2x5MTMwNSc6IHtcbiAgICAgICAgLy8gc3RyaW5nIHRvIGJ1ZmZlciB0byBVSW50OEFycmF5XG4gICAgICAgIGNvbnN0IHJlY2lldmVyUHJpdmF0ZUtleVVpbnQ4QXJyYXkgPSBuYWNsX2RlY29kZUhleChyZWNlaXZlclByaXZhdGVLZXkpXG4gICAgICAgIGNvbnN0IHJlY2lldmVyRW5jcnlwdGlvblByaXZhdGVLZXkgPSBuYWNsLmJveC5rZXlQYWlyLmZyb21TZWNyZXRLZXkocmVjaWV2ZXJQcml2YXRlS2V5VWludDhBcnJheSkuc2VjcmV0S2V5XG5cbiAgICAgICAgLy8gYXNzZW1ibGUgZGVjcnlwdGlvbiBwYXJhbWV0ZXJzXG4gICAgICAgIGNvbnN0IG5vbmNlID0gbmFjbC51dGlsLmRlY29kZUJhc2U2NChlbmNyeXB0ZWREYXRhLm5vbmNlKVxuICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gbmFjbC51dGlsLmRlY29kZUJhc2U2NChlbmNyeXB0ZWREYXRhLmNpcGhlcnRleHQpXG4gICAgICAgIGNvbnN0IGVwaGVtUHVibGljS2V5ID0gbmFjbC51dGlsLmRlY29kZUJhc2U2NChlbmNyeXB0ZWREYXRhLmVwaGVtUHVibGljS2V5KVxuXG4gICAgICAgIC8vIGRlY3J5cHRcbiAgICAgICAgY29uc3QgZGVjcnlwdGVkTWVzc2FnZSA9IG5hY2wuYm94Lm9wZW4oY2lwaGVydGV4dCwgbm9uY2UsIGVwaGVtUHVibGljS2V5LCByZWNpZXZlckVuY3J5cHRpb25Qcml2YXRlS2V5KVxuXG4gICAgICAgIC8vIHJldHVybiBkZWNyeXB0ZWQgbXNnIGRhdGFcbiAgICAgICAgbGV0IG91dHB1dFxuICAgICAgICB0cnkge1xuICAgICAgICAgIG91dHB1dCA9IG5hY2wudXRpbC5lbmNvZGVVVEY4KGRlY3J5cHRlZE1lc3NhZ2UpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjcnlwdGlvbiBmYWlsZWQuJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNyeXB0aW9uIGZhaWxlZC4nKVxuICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gdHlwZS92ZXJzaW9uIG5vdCBzdXBwb3J0ZWQuJylcbiAgICB9XG4gIH0sXG5cbiAgZGVjcnlwdFNhZmVseSAoZW5jcnlwdGVkRGF0YSwgcmVjZWl2ZXJQcml2YXRlS2V5KSB7XG4gICAgY29uc3QgZGF0YVdpdGhQYWRkaW5nID0gSlNPTi5wYXJzZSh0aGlzLmRlY3J5cHQoZW5jcnlwdGVkRGF0YSwgcmVjZWl2ZXJQcml2YXRlS2V5KSlcbiAgICByZXR1cm4gZGF0YVdpdGhQYWRkaW5nLmRhdGFcbiAgfSxcblxuXG4gIGdldEVuY3J5cHRpb25QdWJsaWNLZXkgKHByaXZhdGVLZXkpIHtcbiAgICBjb25zdCBwcml2YXRlS2V5VWludDhBcnJheSA9IG5hY2xfZGVjb2RlSGV4KHByaXZhdGVLZXkpXG4gICAgY29uc3QgZW5jcnlwdGlvblB1YmxpY0tleSA9IG5hY2wuYm94LmtleVBhaXIuZnJvbVNlY3JldEtleShwcml2YXRlS2V5VWludDhBcnJheSkucHVibGljS2V5XG4gICAgcmV0dXJuIG5hY2wudXRpbC5lbmNvZGVCYXNlNjQoZW5jcnlwdGlvblB1YmxpY0tleSlcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBBIGdlbmVyaWMgZW50cnkgcG9pbnQgZm9yIGFsbCB0eXBlZCBkYXRhIG1ldGhvZHMgdG8gYmUgcGFzc2VkLCBpbmNsdWRlcyBhIHZlcnNpb24gcGFyYW1ldGVyLlxuICAgKi9cbiAgc2lnblR5cGVkTWVzc2FnZSAocHJpdmF0ZUtleSwgbXNnUGFyYW1zLCB2ZXJzaW9uID0gJ1Y0Jykge1xuICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgICAgY2FzZSAnVjEnOlxuICAgICAgICByZXR1cm4gdGhpcy5zaWduVHlwZWREYXRhTGVnYWN5KHByaXZhdGVLZXksIG1zZ1BhcmFtcylcbiAgICAgIGNhc2UgJ1YzJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnblR5cGVkRGF0YShwcml2YXRlS2V5LCBtc2dQYXJhbXMpXG4gICAgICBjYXNlICdWNCc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5zaWduVHlwZWREYXRhX3Y0KHByaXZhdGVLZXksIG1zZ1BhcmFtcylcbiAgICB9XG4gIH0sXG5cbiAgcmVjb3ZlclR5cGVkTWVzc2FnZSAobXNnUGFyYW1zLCB2ZXJzaW9uID0gJ1Y0Jykge1xuICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgICAgY2FzZSAnVjEnOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWNvdmVyVHlwZWRTaWduYXR1cmVMZWdhY3kobXNnUGFyYW1zKVxuICAgICAgY2FzZSAnVjMnOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWNvdmVyVHlwZWRTaWduYXR1cmUobXNnUGFyYW1zKVxuICAgICAgY2FzZSAnVjQnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjb3ZlclR5cGVkU2lnbmF0dXJlX3Y0KG1zZ1BhcmFtcylcbiAgICB9XG4gIH0sXG5cbiAgc2lnblR5cGVkRGF0YSAocHJpdmF0ZUtleSwgbXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IFR5cGVkRGF0YVV0aWxzLnNpZ24obXNnUGFyYW1zLmRhdGEsIGZhbHNlKVxuICAgIGNvbnN0IHNpZyA9IGV0aFV0aWwuZWNzaWduKG1lc3NhZ2UsIHByaXZhdGVLZXkpXG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgodGhpcy5jb25jYXRTaWcoc2lnLnYsIHNpZy5yLCBzaWcucykpXG4gIH0sXG5cbiAgc2lnblR5cGVkRGF0YV92NCAocHJpdmF0ZUtleSwgbXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IFR5cGVkRGF0YVV0aWxzLnNpZ24obXNnUGFyYW1zLmRhdGEpXG4gICAgY29uc3Qgc2lnID0gZXRoVXRpbC5lY3NpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSlcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleCh0aGlzLmNvbmNhdFNpZyhzaWcudiwgc2lnLnIsIHNpZy5zKSlcbiAgfSxcblxuICByZWNvdmVyVHlwZWRTaWduYXR1cmUgKG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBUeXBlZERhdGFVdGlscy5zaWduKG1zZ1BhcmFtcy5kYXRhLCBmYWxzZSlcbiAgICBjb25zdCBwdWJsaWNLZXkgPSByZWNvdmVyUHVibGljS2V5KG1lc3NhZ2UsIG1zZ1BhcmFtcy5zaWcpXG4gICAgY29uc3Qgc2VuZGVyID0gZXRoVXRpbC5wdWJsaWNUb0FkZHJlc3MocHVibGljS2V5KVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KHNlbmRlcilcbiAgfSxcblxuICByZWNvdmVyVHlwZWRTaWduYXR1cmVfdjQgKG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBUeXBlZERhdGFVdGlscy5zaWduKG1zZ1BhcmFtcy5kYXRhKVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IHJlY292ZXJQdWJsaWNLZXkobWVzc2FnZSwgbXNnUGFyYW1zLnNpZylcbiAgICBjb25zdCBzZW5kZXIgPSBldGhVdGlsLnB1YmxpY1RvQWRkcmVzcyhwdWJsaWNLZXkpXG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoc2VuZGVyKVxuICB9LFxuXG59XG5cbi8qKlxuICogQHBhcmFtIHR5cGVkRGF0YSAtIEFycmF5IG9mIGRhdGEgYWxvbmcgd2l0aCB0eXBlcywgYXMgcGVyIEVJUDcxMi5cbiAqIEByZXR1cm5zIEJ1ZmZlclxuICovXG5mdW5jdGlvbiB0eXBlZFNpZ25hdHVyZUhhc2ggKHR5cGVkRGF0YSkge1xuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignRXhwZWN0IGFyZ3VtZW50IHRvIGJlIG5vbi1lbXB0eSBhcnJheScpXG4gIGlmICh0eXBlb2YgdHlwZWREYXRhICE9PSAnb2JqZWN0JyB8fCAhdHlwZWREYXRhLmxlbmd0aCkge1xuICAgIHRocm93IGVycm9yXG4gIH1cblxuICBjb25zdCBkYXRhID0gdHlwZWREYXRhLm1hcChmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBlLnR5cGUgPT09ICdieXRlcycgPyBldGhVdGlsLnRvQnVmZmVyKGUudmFsdWUpIDogZS52YWx1ZVxuICB9KVxuICBjb25zdCB0eXBlcyA9IHR5cGVkRGF0YS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZS50eXBlXG4gIH0pXG4gIGNvbnN0IHNjaGVtYSA9IHR5cGVkRGF0YS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIWUubmFtZSkge1xuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gICAgcmV0dXJuIGAke2UudHlwZX0gJHtlLm5hbWV9YFxuICB9KVxuXG4gIHJldHVybiBldGhBYmkuc29saWRpdHlTSEEzKFxuICAgIFsnYnl0ZXMzMicsICdieXRlczMyJ10sXG4gICAgW1xuICAgICAgZXRoQWJpLnNvbGlkaXR5U0hBMyhuZXcgQXJyYXkodHlwZWREYXRhLmxlbmd0aCkuZmlsbCgnc3RyaW5nJyksIHNjaGVtYSksXG4gICAgICBldGhBYmkuc29saWRpdHlTSEEzKHR5cGVzLCBkYXRhKSxcbiAgICBdLFxuICApXG59XG5cbmZ1bmN0aW9uIHJlY292ZXJQdWJsaWNLZXkgKGhhc2gsIHNpZykge1xuICBjb25zdCBzaWduYXR1cmUgPSBldGhVdGlsLnRvQnVmZmVyKHNpZylcbiAgY29uc3Qgc2lnUGFyYW1zID0gZXRoVXRpbC5mcm9tUnBjU2lnKHNpZ25hdHVyZSlcbiAgcmV0dXJuIGV0aFV0aWwuZWNyZWNvdmVyKGhhc2gsIHNpZ1BhcmFtcy52LCBzaWdQYXJhbXMuciwgc2lnUGFyYW1zLnMpXG59XG5cbmZ1bmN0aW9uIGdldFB1YmxpY0tleUZvciAobXNnUGFyYW1zKSB7XG4gIGNvbnN0IG1lc3NhZ2UgPSBldGhVdGlsLnRvQnVmZmVyKG1zZ1BhcmFtcy5kYXRhKVxuICBjb25zdCBtc2dIYXNoID0gZXRoVXRpbC5oYXNoUGVyc29uYWxNZXNzYWdlKG1lc3NhZ2UpXG4gIHJldHVybiByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gsIG1zZ1BhcmFtcy5zaWcpXG59XG5cblxuZnVuY3Rpb24gcGFkV2l0aFplcm9lcyAobnVtYmVyLCBsZW5ndGgpIHtcbiAgbGV0IG15U3RyaW5nID0gYCR7bnVtYmVyfWBcbiAgd2hpbGUgKG15U3RyaW5nLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgIG15U3RyaW5nID0gYDAke215U3RyaW5nfWBcbiAgfVxuICByZXR1cm4gbXlTdHJpbmdcbn1cblxuLy8gY29udmVydHMgaGV4IHN0cmluZ3MgdG8gdGhlIFVpbnQ4QXJyYXkgZm9ybWF0IHVzZWQgYnkgbmFjbFxuZnVuY3Rpb24gbmFjbF9kZWNvZGVIZXggKG1zZ0hleCkge1xuICBjb25zdCBtc2dCYXNlNjQgPSAoQnVmZmVyLmZyb20obXNnSGV4LCAnaGV4JykpLnRvU3RyaW5nKCdiYXNlNjQnKVxuICByZXR1cm4gbmFjbC51dGlsLmRlY29kZUJhc2U2NChtc2dCYXNlNjQpXG59XG5cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9rZWNjYWsnKSxcbiAgICBrZWNjYWsyMjQgPSBfcmVxdWlyZS5rZWNjYWsyMjQsXG4gICAga2VjY2FrMzg0ID0gX3JlcXVpcmUua2VjY2FrMzg0LFxuICAgIGsyNTYgPSBfcmVxdWlyZS5rZWNjYWsyNTYsXG4gICAga2VjY2FrNTEyID0gX3JlcXVpcmUua2VjY2FrNTEyO1xuXG52YXIgc2VjcDI1NmsxID0gcmVxdWlyZSgnLi9zZWNwMjU2azEtYWRhcHRlcicpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIHJscCA9IHJlcXVpcmUoJ3JscCcpO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbk9iamVjdC5hc3NpZ24oZXhwb3J0cywgcmVxdWlyZSgnZXRoanMtdXRpbCcpKTtcblxuLyoqXG4gKiB0aGUgbWF4IGludGVnZXIgdGhhdCB0aGlzIFZNIGNhbiBoYW5kbGUgKGEgYGBgQk5gYGApXG4gKiBAdmFyIHtCTn0gTUFYX0lOVEVHRVJcbiAqL1xuZXhwb3J0cy5NQVhfSU5URUdFUiA9IG5ldyBCTignZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicsIDE2KTtcblxuLyoqXG4gKiAyXjI1NiAoYSBgYGBCTmBgYClcbiAqIEB2YXIge0JOfSBUV09fUE9XMjU2XG4gKi9cbmV4cG9ydHMuVFdPX1BPVzI1NiA9IG5ldyBCTignMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAxNik7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGwgKGEgYGBgU3RyaW5nYGBgKVxuICogQHZhciB7U3RyaW5nfSBLRUNDQUsyNTZfTlVMTF9TXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUyA9ICdjNWQyNDYwMTg2ZjcyMzNjOTI3ZTdkYjJkY2M3MDNjMGU1MDBiNjUzY2E4MjI3M2I3YmZhZDgwNDVkODVhNDcwJztcbmV4cG9ydHMuU0hBM19OVUxMX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1M7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGwgKGEgYGBgQnVmZmVyYGBgKVxuICogQHZhciB7QnVmZmVyfSBLRUNDQUsyNTZfTlVMTFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9OVUxMID0gQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TLCAnaGV4Jyk7XG5leHBvcnRzLlNIQTNfTlVMTCA9IGV4cG9ydHMuS0VDQ0FLMjU2X05VTEw7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBvZiBhbiBSTFAgb2YgYW4gZW1wdHkgYXJyYXkgKGEgYGBgU3RyaW5nYGBgKVxuICogQHZhciB7U3RyaW5nfSBLRUNDQUsyNTZfUkxQX0FSUkFZX1NcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MgPSAnMWRjYzRkZThkZWM3NWQ3YWFiODViNTY3YjZjY2Q0MWFkMzEyNDUxYjk0OGE3NDEzZjBhMTQyZmQ0MGQ0OTM0Nyc7XG5leHBvcnRzLlNIQTNfUkxQX0FSUkFZX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUztcblxuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheSAoYSBgYGBCdWZmZXJgYGApXG4gKiBAdmFyIHtCdWZmZXJ9IEtFQ0NBSzI1Nl9STFBfQVJSQVlcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZID0gQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MsICdoZXgnKTtcbmV4cG9ydHMuU0hBM19STFBfQVJSQVkgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVk7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbCAgKGEgYGBgU3RyaW5nYGBgKVxuICogQHZhciB7U3RyaW5nfSBLRUNDQUsyNTZfUkxQX1NcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1MgPSAnNTZlODFmMTcxYmNjNTVhNmZmODM0NWU2OTJjMGY4NmU1YjQ4ZTAxYjk5NmNhZGMwMDE2MjJmYjVlMzYzYjQyMSc7XG5leHBvcnRzLlNIQTNfUkxQX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfUztcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIFJMUCBvZiBudWxsIChhIGBgYEJ1ZmZlcmBgYClcbiAqIEB2YXIge0J1ZmZlcn0gS0VDQ0FLMjU2X1JMUFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFAgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfUywgJ2hleCcpO1xuZXhwb3J0cy5TSEEzX1JMUCA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUDtcblxuLyoqXG4gKiBbYEJOYF0oaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMpXG4gKiBAdmFyIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0cy5CTiA9IEJOO1xuXG4vKipcbiAqIFtgcmxwYF0oaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtanMvcmxwKVxuICogQHZhciB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydHMucmxwID0gcmxwO1xuXG4vKipcbiAqIFtgc2VjcDI1NmsxYF0oaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9zZWNwMjU2azEtbm9kZS8pXG4gKiBAdmFyIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuc2VjcDI1NmsxID0gc2VjcDI1NmsxO1xuXG4vKipcbiAqIFJldHVybnMgYSBidWZmZXIgZmlsbGVkIHdpdGggMHNcbiAqIEBtZXRob2QgemVyb3NcbiAqIEBwYXJhbSB7TnVtYmVyfSBieXRlcyAgdGhlIG51bWJlciBvZiBieXRlcyB0aGUgYnVmZmVyIHNob3VsZCBiZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnplcm9zID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoYnl0ZXMpLmZpbGwoMCk7XG59O1xuXG4vKipcbiAgKiBSZXR1cm5zIGEgemVybyBhZGRyZXNzXG4gICogQG1ldGhvZCB6ZXJvQWRkcmVzc1xuICAqIEByZXR1cm4ge1N0cmluZ31cbiAgKi9cbmV4cG9ydHMuemVyb0FkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhZGRyZXNzTGVuZ3RoID0gMjA7XG4gIHZhciB6ZXJvQWRkcmVzcyA9IGV4cG9ydHMuemVyb3MoYWRkcmVzc0xlbmd0aCk7XG4gIHJldHVybiBleHBvcnRzLmJ1ZmZlclRvSGV4KHplcm9BZGRyZXNzKTtcbn07XG5cbi8qKlxuICogTGVmdCBQYWRzIGFuIGBBcnJheWAgb3IgYEJ1ZmZlcmAgd2l0aCBsZWFkaW5nIHplcm9zIHRpbGwgaXQgaGFzIGBsZW5ndGhgIGJ5dGVzLlxuICogT3IgaXQgdHJ1bmNhdGVzIHRoZSBiZWdpbm5pbmcgaWYgaXQgZXhjZWVkcy5cbiAqIEBtZXRob2QgbHNldExlbmd0aFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl9IG1zZyB0aGUgdmFsdWUgdG8gcGFkXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JpZ2h0PWZhbHNlXSB3aGV0aGVyIHRvIHN0YXJ0IHBhZGRpbmcgZm9ybSB0aGUgbGVmdCBvciByaWdodFxuICogQHJldHVybiB7QnVmZmVyfEFycmF5fVxuICovXG5leHBvcnRzLnNldExlbmd0aExlZnQgPSBleHBvcnRzLnNldExlbmd0aCA9IGZ1bmN0aW9uIChtc2csIGxlbmd0aCwgcmlnaHQpIHtcbiAgdmFyIGJ1ZiA9IGV4cG9ydHMuemVyb3MobGVuZ3RoKTtcbiAgbXNnID0gZXhwb3J0cy50b0J1ZmZlcihtc2cpO1xuICBpZiAocmlnaHQpIHtcbiAgICBpZiAobXNnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgbXNnLmNvcHkoYnVmKTtcbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHJldHVybiBtc2cuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobXNnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgbXNnLmNvcHkoYnVmLCBsZW5ndGggLSBtc2cubGVuZ3RoKTtcbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHJldHVybiBtc2cuc2xpY2UoLWxlbmd0aCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmlnaHQgUGFkcyBhbiBgQXJyYXlgIG9yIGBCdWZmZXJgIHdpdGggbGVhZGluZyB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIE9yIGl0IHRydW5jYXRlcyB0aGUgYmVnaW5uaW5nIGlmIGl0IGV4Y2VlZHMuXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheX0gbXNnIHRoZSB2YWx1ZSB0byBwYWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHJldHVybiB7QnVmZmVyfEFycmF5fVxuICovXG5leHBvcnRzLnNldExlbmd0aFJpZ2h0ID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoKSB7XG4gIHJldHVybiBleHBvcnRzLnNldExlbmd0aChtc2csIGxlbmd0aCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIGBCdWZmZXJgIG9yIGFuIGBBcnJheWBcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ30gYVxuICogQHJldHVybiB7QnVmZmVyfEFycmF5fFN0cmluZ31cbiAqL1xuZXhwb3J0cy51bnBhZCA9IGV4cG9ydHMuc3RyaXBaZXJvcyA9IGZ1bmN0aW9uIChhKSB7XG4gIGEgPSBleHBvcnRzLnN0cmlwSGV4UHJlZml4KGEpO1xuICB2YXIgZmlyc3QgPSBhWzBdO1xuICB3aGlsZSAoYS5sZW5ndGggPiAwICYmIGZpcnN0LnRvU3RyaW5nKCkgPT09ICcwJykge1xuICAgIGEgPSBhLnNsaWNlKDEpO1xuICAgIGZpcnN0ID0gYVswXTtcbiAgfVxuICByZXR1cm4gYTtcbn07XG4vKipcbiAqIEF0dGVtcHRzIHRvIHR1cm4gYSB2YWx1ZSBpbnRvIGEgYEJ1ZmZlcmAuIEFzIGlucHV0IGl0IHN1cHBvcnRzIGBCdWZmZXJgLCBgU3RyaW5nYCwgYE51bWJlcmAsIG51bGwvdW5kZWZpbmVkLCBgQk5gIGFuZCBvdGhlciBvYmplY3RzIHdpdGggYSBgdG9BcnJheSgpYCBtZXRob2QuXG4gKiBAcGFyYW0geyp9IHYgdGhlIHZhbHVlXG4gKi9cbmV4cG9ydHMudG9CdWZmZXIgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICB2ID0gQnVmZmVyLmZyb20odik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChleHBvcnRzLmlzSGV4U3RyaW5nKHYpKSB7XG4gICAgICAgIHYgPSBCdWZmZXIuZnJvbShleHBvcnRzLnBhZFRvRXZlbihleHBvcnRzLnN0cmlwSGV4UHJlZml4KHYpKSwgJ2hleCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKHYpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XG4gICAgICB2ID0gZXhwb3J0cy5pbnRUb0J1ZmZlcih2KTtcbiAgICB9IGVsc2UgaWYgKHYgPT09IG51bGwgfHwgdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgIH0gZWxzZSBpZiAoQk4uaXNCTih2KSkge1xuICAgICAgdiA9IHYudG9BcnJheUxpa2UoQnVmZmVyKTtcbiAgICB9IGVsc2UgaWYgKHYudG9BcnJheSkge1xuICAgICAgLy8gY29udmVydHMgYSBCTiB0byBhIEJ1ZmZlclxuICAgICAgdiA9IEJ1ZmZlci5mcm9tKHYudG9BcnJheSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR5cGUnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgdG8gYSBgTnVtYmVyYFxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQHRocm93cyBJZiB0aGUgaW5wdXQgbnVtYmVyIGV4Y2VlZHMgNTMgYml0cy5cbiAqL1xuZXhwb3J0cy5idWZmZXJUb0ludCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgcmV0dXJuIG5ldyBCTihleHBvcnRzLnRvQnVmZmVyKGJ1ZikpLnRvTnVtYmVyKCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgaW50byBhIGhleCBgU3RyaW5nYFxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLmJ1ZmZlclRvSGV4ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBidWYgPSBleHBvcnRzLnRvQnVmZmVyKGJ1Zik7XG4gIHJldHVybiAnMHgnICsgYnVmLnRvU3RyaW5nKCdoZXgnKTtcbn07XG5cbi8qKlxuICogSW50ZXJwcmV0cyBhIGBCdWZmZXJgIGFzIGEgc2lnbmVkIGludGVnZXIgYW5kIHJldHVybnMgYSBgQk5gLiBBc3N1bWVzIDI1Ni1iaXQgbnVtYmVycy5cbiAqIEBwYXJhbSB7QnVmZmVyfSBudW1cbiAqIEByZXR1cm4ge0JOfVxuICovXG5leHBvcnRzLmZyb21TaWduZWQgPSBmdW5jdGlvbiAobnVtKSB7XG4gIHJldHVybiBuZXcgQk4obnVtKS5mcm9tVHdvcygyNTYpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBCTmAgdG8gYW4gdW5zaWduZWQgaW50ZWdlciBhbmQgcmV0dXJucyBpdCBhcyBhIGBCdWZmZXJgLiBBc3N1bWVzIDI1Ni1iaXQgbnVtYmVycy5cbiAqIEBwYXJhbSB7Qk59IG51bVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnRvVW5zaWduZWQgPSBmdW5jdGlvbiAobnVtKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShudW0udG9Ud29zKDI1NikudG9BcnJheSgpKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBLZWNjYWsgaGFzaCBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYml0cz0yNTZdIHRoZSBLZWNjYWsgd2lkdGhcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5rZWNjYWsgPSBmdW5jdGlvbiAoYSwgYml0cykge1xuICBhID0gZXhwb3J0cy50b0J1ZmZlcihhKTtcbiAgaWYgKCFiaXRzKSBiaXRzID0gMjU2O1xuXG4gIHN3aXRjaCAoYml0cykge1xuICAgIGNhc2UgMjI0OlxuICAgICAge1xuICAgICAgICByZXR1cm4ga2VjY2FrMjI0KGEpO1xuICAgICAgfVxuICAgIGNhc2UgMjU2OlxuICAgICAge1xuICAgICAgICByZXR1cm4gazI1NihhKTtcbiAgICAgIH1cbiAgICBjYXNlIDM4NDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGtlY2NhazM4NChhKTtcbiAgICAgIH1cbiAgICBjYXNlIDUxMjpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGtlY2NhazUxMihhKTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsZCBhbGdvcml0aG06IGtlY2NhaycgKyBiaXRzKTtcbiAgICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgaW5wdXQsIGFsaWFzIGZvciBrZWNjYWsoYSwgMjU2KVxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLmtlY2NhazI1NiA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBleHBvcnRzLmtlY2NhayhhKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBTSEEtMyAoS2VjY2FrKSBoYXNoIG9mIHRoZSBpbnB1dCBbT0JTT0xFVEVdXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge051bWJlcn0gW2JpdHM9MjU2XSB0aGUgU0hBLTMgd2lkdGhcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5zaGEzID0gZXhwb3J0cy5rZWNjYWs7XG5cbi8qKlxuICogQ3JlYXRlcyBTSEEyNTYgaGFzaCBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5zaGEyNTYgPSBmdW5jdGlvbiAoYSkge1xuICBhID0gZXhwb3J0cy50b0J1ZmZlcihhKTtcbiAgcmV0dXJuIGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShhKS5kaWdlc3QoKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBSSVBFTUQxNjAgaGFzaCBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFkZGVkIHdoZXRoZXIgaXQgc2hvdWxkIGJlIHBhZGRlZCB0byAyNTYgYml0cyBvciBub3RcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5yaXBlbWQxNjAgPSBmdW5jdGlvbiAoYSwgcGFkZGVkKSB7XG4gIGEgPSBleHBvcnRzLnRvQnVmZmVyKGEpO1xuICB2YXIgaGFzaCA9IGNyZWF0ZUhhc2goJ3JtZDE2MCcpLnVwZGF0ZShhKS5kaWdlc3QoKTtcbiAgaWYgKHBhZGRlZCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBleHBvcnRzLnNldExlbmd0aChoYXNoLCAzMik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBTSEEtMyBoYXNoIG9mIHRoZSBSTFAgZW5jb2RlZCB2ZXJzaW9uIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnJscGhhc2ggPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gZXhwb3J0cy5rZWNjYWsocmxwLmVuY29kZShhKSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJpdmF0ZSBrZXkgc2F0aXNmaWVzIHRoZSBydWxlcyBvZiB0aGUgY3VydmUgc2VjcDI1NmsxLlxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZFByaXZhdGUgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICByZXR1cm4gc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkocHJpdmF0ZUtleSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHVibGljIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azFcbiAqIGFuZCB0aGUgcmVxdWlyZW1lbnRzIG9mIEV0aGVyZXVtLlxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5LCB1bmxlc3Mgc2FuaXRpemUgaXMgZW5hYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBbc2FuaXRpemU9ZmFsc2VdIEFjY2VwdCBwdWJsaWMga2V5cyBpbiBvdGhlciBmb3JtYXRzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRQdWJsaWMgPSBmdW5jdGlvbiAocHVibGljS2V5LCBzYW5pdGl6ZSkge1xuICBpZiAocHVibGljS2V5Lmxlbmd0aCA9PT0gNjQpIHtcbiAgICAvLyBDb252ZXJ0IHRvIFNFQzEgZm9yIHNlY3AyNTZrMVxuICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFs0XSksIHB1YmxpY0tleV0pKTtcbiAgfVxuXG4gIGlmICghc2FuaXRpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShwdWJsaWNLZXkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBhZGRyZXNzIG9mIGEgZ2l2ZW4gcHVibGljIGtleS5cbiAqIEFjY2VwdHMgXCJFdGhlcmV1bSBwdWJsaWMga2V5c1wiIGFuZCBTRUMxIGVuY29kZWQga2V5cy5cbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJLZXkgVGhlIHR3byBwb2ludHMgb2YgYW4gdW5jb21wcmVzc2VkIGtleSwgdW5sZXNzIHNhbml0aXplIGlzIGVuYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Nhbml0aXplPWZhbHNlXSBBY2NlcHQgcHVibGljIGtleXMgaW4gb3RoZXIgZm9ybWF0c1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnB1YlRvQWRkcmVzcyA9IGV4cG9ydHMucHVibGljVG9BZGRyZXNzID0gZnVuY3Rpb24gKHB1YktleSwgc2FuaXRpemUpIHtcbiAgcHViS2V5ID0gZXhwb3J0cy50b0J1ZmZlcihwdWJLZXkpO1xuICBpZiAoc2FuaXRpemUgJiYgcHViS2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICBwdWJLZXkgPSBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChwdWJLZXksIGZhbHNlKS5zbGljZSgxKTtcbiAgfVxuICBhc3NlcnQocHViS2V5Lmxlbmd0aCA9PT0gNjQpO1xuICAvLyBPbmx5IHRha2UgdGhlIGxvd2VyIDE2MGJpdHMgb2YgdGhlIGhhc2hcbiAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKHB1YktleSkuc2xpY2UoLTIwKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gcHVibGljIGtleSBvZiBhIGdpdmVuIHByaXZhdGUga2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZVRvUHVibGljID0gZXhwb3J0cy5wcml2YXRlVG9QdWJsaWMgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICBwcml2YXRlS2V5ID0gZXhwb3J0cy50b0J1ZmZlcihwcml2YXRlS2V5KTtcbiAgLy8gc2tpcCB0aGUgdHlwZSBmbGFnIGFuZCB1c2UgdGhlIFgsIFkgcG9pbnRzXG4gIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKHByaXZhdGVLZXksIGZhbHNlKS5zbGljZSgxKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIHRoZSBFdGhlcmV1bSBmb3JtYXQuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuaW1wb3J0UHVibGljID0gZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICBwdWJsaWNLZXkgPSBleHBvcnRzLnRvQnVmZmVyKHB1YmxpY0tleSk7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgIHB1YmxpY0tleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHB1YmxpY0tleSwgZmFsc2UpLnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBwdWJsaWNLZXk7XG59O1xuXG4vKipcbiAqIEVDRFNBIHNpZ25cbiAqIEBwYXJhbSB7QnVmZmVyfSBtc2dIYXNoXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnRzLmVjc2lnbiA9IGZ1bmN0aW9uIChtc2dIYXNoLCBwcml2YXRlS2V5KSB7XG4gIHZhciBzaWcgPSBzZWNwMjU2azEuc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5KTtcblxuICB2YXIgcmV0ID0ge307XG4gIHJldC5yID0gc2lnLnNpZ25hdHVyZS5zbGljZSgwLCAzMik7XG4gIHJldC5zID0gc2lnLnNpZ25hdHVyZS5zbGljZSgzMiwgNjQpO1xuICByZXQudiA9IHNpZy5yZWNvdmVyeSArIDI3O1xuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBrZWNjYWstMjU2IGhhc2ggb2YgYG1lc3NhZ2VgLCBwcmVmaXhlZCB3aXRoIHRoZSBoZWFkZXIgdXNlZCBieSB0aGUgYGV0aF9zaWduYCBSUEMgY2FsbC5cbiAqIFRoZSBvdXRwdXQgb2YgdGhpcyBmdW5jdGlvbiBjYW4gYmUgZmVkIGludG8gYGVjc2lnbmAgdG8gcHJvZHVjZSB0aGUgc2FtZSBzaWduYXR1cmUgYXMgdGhlIGBldGhfc2lnbmBcbiAqIGNhbGwgZm9yIGEgZ2l2ZW4gYG1lc3NhZ2VgLCBvciBmZWQgdG8gYGVjcmVjb3ZlcmAgYWxvbmcgd2l0aCBhIHNpZ25hdHVyZSB0byByZWNvdmVyIHRoZSBwdWJsaWMga2V5XG4gKiB1c2VkIHRvIHByb2R1Y2UgdGhlIHNpZ25hdHVyZS5cbiAqIEBwYXJhbSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBoYXNoXG4gKi9cbmV4cG9ydHMuaGFzaFBlcnNvbmFsTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIHZhciBwcmVmaXggPSBleHBvcnRzLnRvQnVmZmVyKCdcXHgxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcbicgKyBtZXNzYWdlLmxlbmd0aC50b1N0cmluZygpKTtcbiAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKEJ1ZmZlci5jb25jYXQoW3ByZWZpeCwgbWVzc2FnZV0pKTtcbn07XG5cbi8qKlxuICogRUNEU0EgcHVibGljIGtleSByZWNvdmVyeSBmcm9tIHNpZ25hdHVyZVxuICogQHBhcmFtIHtCdWZmZXJ9IG1zZ0hhc2hcbiAqIEBwYXJhbSB7TnVtYmVyfSB2XG4gKiBAcGFyYW0ge0J1ZmZlcn0gclxuICogQHBhcmFtIHtCdWZmZXJ9IHNcbiAqIEByZXR1cm4ge0J1ZmZlcn0gcHVibGljS2V5XG4gKi9cbmV4cG9ydHMuZWNyZWNvdmVyID0gZnVuY3Rpb24gKG1zZ0hhc2gsIHYsIHIsIHMpIHtcbiAgdmFyIHNpZ25hdHVyZSA9IEJ1ZmZlci5jb25jYXQoW2V4cG9ydHMuc2V0TGVuZ3RoKHIsIDMyKSwgZXhwb3J0cy5zZXRMZW5ndGgocywgMzIpXSwgNjQpO1xuICB2YXIgcmVjb3ZlcnkgPSB2IC0gMjc7XG4gIGlmIChyZWNvdmVyeSAhPT0gMCAmJiByZWNvdmVyeSAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgdiB2YWx1ZScpO1xuICB9XG4gIHZhciBzZW5kZXJQdWJLZXkgPSBzZWNwMjU2azEucmVjb3Zlcihtc2dIYXNoLCBzaWduYXR1cmUsIHJlY292ZXJ5KTtcbiAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHNlbmRlclB1YktleSwgZmFsc2UpLnNsaWNlKDEpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHNpZ25hdHVyZSBwYXJhbWV0ZXJzIGludG8gdGhlIGZvcm1hdCBvZiBgZXRoX3NpZ25gIFJQQyBtZXRob2RcbiAqIEBwYXJhbSB7TnVtYmVyfSB2XG4gKiBAcGFyYW0ge0J1ZmZlcn0gclxuICogQHBhcmFtIHtCdWZmZXJ9IHNcbiAqIEByZXR1cm4ge1N0cmluZ30gc2lnXG4gKi9cbmV4cG9ydHMudG9ScGNTaWcgPSBmdW5jdGlvbiAodiwgciwgcykge1xuICAvLyBOT1RFOiB3aXRoIHBvdGVudGlhbCBpbnRyb2R1Y3Rpb24gb2YgY2hhaW5JZCB0aGlzIG1pZ2h0IG5lZWQgdG8gYmUgdXBkYXRlZFxuICBpZiAodiAhPT0gMjcgJiYgdiAhPT0gMjgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVjb3ZlcnkgaWQnKTtcbiAgfVxuXG4gIC8vIGdldGggKGFuZCB0aGUgUlBDIGV0aF9zaWduIG1ldGhvZCkgdXNlcyB0aGUgNjUgYnl0ZSBmb3JtYXQgdXNlZCBieSBCaXRjb2luXG4gIC8vIEZJWE1FOiB0aGlzIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlIC0gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL2lzc3Vlcy8yMDUzXG4gIHJldHVybiBleHBvcnRzLmJ1ZmZlclRvSGV4KEJ1ZmZlci5jb25jYXQoW2V4cG9ydHMuc2V0TGVuZ3RoTGVmdChyLCAzMiksIGV4cG9ydHMuc2V0TGVuZ3RoTGVmdChzLCAzMiksIGV4cG9ydHMudG9CdWZmZXIodiAtIDI3KV0pKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBzaWduYXR1cmUgZm9ybWF0IG9mIHRoZSBgZXRoX3NpZ25gIFJQQyBtZXRob2QgdG8gc2lnbmF0dXJlIHBhcmFtZXRlcnNcbiAqIE5PVEU6IGFsbCBiZWNhdXNlIG9mIGEgYnVnIGluIGdldGg6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMjA1M1xuICogQHBhcmFtIHtTdHJpbmd9IHNpZ1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnRzLmZyb21ScGNTaWcgPSBmdW5jdGlvbiAoc2lnKSB7XG4gIHNpZyA9IGV4cG9ydHMudG9CdWZmZXIoc2lnKTtcblxuICAvLyBOT1RFOiB3aXRoIHBvdGVudGlhbCBpbnRyb2R1Y3Rpb24gb2YgY2hhaW5JZCB0aGlzIG1pZ2h0IG5lZWQgdG8gYmUgdXBkYXRlZFxuICBpZiAoc2lnLmxlbmd0aCAhPT0gNjUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFyIHYgPSBzaWdbNjRdO1xuICAvLyBzdXBwb3J0IGJvdGggdmVyc2lvbnMgb2YgYGV0aF9zaWduYCByZXNwb25zZXNcbiAgaWYgKHYgPCAyNykge1xuICAgIHYgKz0gMjc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHY6IHYsXG4gICAgcjogc2lnLnNsaWNlKDAsIDMyKSxcbiAgICBzOiBzaWcuc2xpY2UoMzIsIDY0KVxuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBhZGRyZXNzIG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHJpdmF0ZVRvQWRkcmVzcyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHJldHVybiBleHBvcnRzLnB1YmxpY1RvQWRkcmVzcyhwcml2YXRlVG9QdWJsaWMocHJpdmF0ZUtleSkpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZC4gQWNjZXB0cyBjaGVja3N1bW1lZCBhZGRyZXNzZXMgdG9vXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHJldHVybiAoL14weFswLTlhLWZBLUZdezQwfSQvLnRlc3QoYWRkcmVzcylcbiAgKTtcbn07XG5cbi8qKlxuICAqIENoZWNrcyBpZiBhIGdpdmVuIGFkZHJlc3MgaXMgYSB6ZXJvIGFkZHJlc3NcbiAgKiBAbWV0aG9kIGlzWmVyb0FkZHJlc3NcbiAgKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICovXG5leHBvcnRzLmlzWmVyb0FkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICB2YXIgemVyb0FkZHJlc3MgPSBleHBvcnRzLnplcm9BZGRyZXNzKCk7XG4gIHJldHVybiB6ZXJvQWRkcmVzcyA9PT0gZXhwb3J0cy5hZGRIZXhQcmVmaXgoYWRkcmVzcyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBjaGVja3N1bW1lZCBhZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgYWRkcmVzcyA9IGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgoYWRkcmVzcykudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGhhc2ggPSBleHBvcnRzLmtlY2NhayhhZGRyZXNzKS50b1N0cmluZygnaGV4Jyk7XG4gIHZhciByZXQgPSAnMHgnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWRkcmVzcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwYXJzZUludChoYXNoW2ldLCAxNikgPj0gOCkge1xuICAgICAgcmV0ICs9IGFkZHJlc3NbaV0udG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0ICs9IGFkZHJlc3NbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBhZGRyZXNzIGlzIGEgdmFsaWQgY2hlY2tzdW1tZWQgYWRkcmVzc1xuICogQHBhcmFtIHtCdWZmZXJ9IGFkZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZENoZWNrc3VtQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHJldHVybiBleHBvcnRzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpICYmIGV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcykgPT09IGFkZHJlc3M7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIG9mIGEgbmV3bHkgY3JlYXRlZCBjb250cmFjdFxuICogQHBhcmFtIHtCdWZmZXJ9IGZyb20gdGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xuICogQHBhcmFtIHtCdWZmZXJ9IG5vbmNlIHRoZSBub25jZSBvZiB0aGUgZnJvbSBhY2NvdW50XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzID0gZnVuY3Rpb24gKGZyb20sIG5vbmNlKSB7XG4gIGZyb20gPSBleHBvcnRzLnRvQnVmZmVyKGZyb20pO1xuICBub25jZSA9IG5ldyBCTihub25jZSk7XG5cbiAgaWYgKG5vbmNlLmlzWmVybygpKSB7XG4gICAgLy8gaW4gUkxQIHdlIHdhbnQgdG8gZW5jb2RlIG51bGwgaW4gdGhlIGNhc2Ugb2YgemVybyBub25jZVxuICAgIC8vIHJlYWQgdGhlIFJMUCBkb2N1bWVudGF0aW9uIGZvciBhbiBhbnN3ZXIgaWYgeW91IGRhcmVcbiAgICBub25jZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgbm9uY2UgPSBCdWZmZXIuZnJvbShub25jZS50b0FycmF5KCkpO1xuICB9XG5cbiAgLy8gT25seSB0YWtlIHRoZSBsb3dlciAxNjBiaXRzIG9mIHRoZSBoYXNoXG4gIHJldHVybiBleHBvcnRzLnJscGhhc2goW2Zyb20sIG5vbmNlXSkuc2xpY2UoLTIwKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzdXBwbGllZCBhZGRyZXNzIGJlbG9uZ3MgdG8gYSBwcmVjb21waWxlZCBhY2NvdW50IChCeXphbnRpdW0pXG4gKiBAcGFyYW0ge0J1ZmZlcnxTdHJpbmd9IGFkZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNQcmVjb21waWxlZCA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHZhciBhID0gZXhwb3J0cy51bnBhZChhZGRyZXNzKTtcbiAgcmV0dXJuIGEubGVuZ3RoID09PSAxICYmIGFbMF0gPj0gMSAmJiBhWzBdIDw9IDg7XG59O1xuXG4vKipcbiAqIEFkZHMgXCIweFwiIHRvIGEgZ2l2ZW4gYFN0cmluZ2AgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBzdGFydCB3aXRoIFwiMHhcIlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLmFkZEhleFByZWZpeCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ciA6ICcweCcgKyBzdHI7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIEVDRFNBIHNpZ25hdHVyZVxuICogQG1ldGhvZCBpc1ZhbGlkU2lnbmF0dXJlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gdlxuICogQHBhcmFtIHtCdWZmZXJ9IHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtob21lc3RlYWQ9dHJ1ZV1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZXhwb3J0cy5pc1ZhbGlkU2lnbmF0dXJlID0gZnVuY3Rpb24gKHYsIHIsIHMsIGhvbWVzdGVhZCkge1xuICB2YXIgU0VDUDI1NksxX05fRElWXzIgPSBuZXcgQk4oJzdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmNWQ1NzZlNzM1N2E0NTAxZGRmZTkyZjQ2NjgxYjIwYTAnLCAxNik7XG4gIHZhciBTRUNQMjU2SzFfTiA9IG5ldyBCTignZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScsIDE2KTtcblxuICBpZiAoci5sZW5ndGggIT09IDMyIHx8IHMubGVuZ3RoICE9PSAzMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh2ICE9PSAyNyAmJiB2ICE9PSAyOCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHIgPSBuZXcgQk4ocik7XG4gIHMgPSBuZXcgQk4ocyk7XG5cbiAgaWYgKHIuaXNaZXJvKCkgfHwgci5ndChTRUNQMjU2SzFfTikgfHwgcy5pc1plcm8oKSB8fCBzLmd0KFNFQ1AyNTZLMV9OKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChob21lc3RlYWQgPT09IGZhbHNlICYmIG5ldyBCTihzKS5jbXAoU0VDUDI1NksxX05fRElWXzIpID09PSAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgb3IgYEFycmF5YCB0byBKU09OXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheX0gYmFcbiAqIEByZXR1cm4ge0FycmF5fFN0cmluZ3xudWxsfVxuICovXG5leHBvcnRzLmJhVG9KU09OID0gZnVuY3Rpb24gKGJhKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYmEpKSB7XG4gICAgcmV0dXJuICcweCcgKyBiYS50b1N0cmluZygnaGV4Jyk7XG4gIH0gZWxzZSBpZiAoYmEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycmF5LnB1c2goZXhwb3J0cy5iYVRvSlNPTihiYVtpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVmaW5lcyBwcm9wZXJ0aWVzIG9uIGEgYE9iamVjdGAuIEl0IG1ha2UgdGhlIGFzc3VtcHRpb24gdGhhdCB1bmRlcmx5aW5nIGRhdGEgaXMgYmluYXJ5LlxuICogQHBhcmFtIHtPYmplY3R9IHNlbGYgdGhlIGBPYmplY3RgIHRvIGRlZmluZSBwcm9wZXJ0aWVzIG9uXG4gKiBAcGFyYW0ge0FycmF5fSBmaWVsZHMgYW4gYXJyYXkgZmllbGRzIHRvIGRlZmluZS4gRmllbGRzIGNhbiBjb250YWluOlxuICogKiBgbmFtZWAgLSB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydGllc1xuICogKiBgbGVuZ3RoYCAtIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGZpZWxkIGNhbiBoYXZlXG4gKiAqIGBhbGxvd0xlc3NgIC0gaWYgdGhlIGZpZWxkIGNhbiBiZSBsZXNzIHRoYW4gdGhlIGxlbmd0aFxuICogKiBgYWxsb3dFbXB0eWBcbiAqIEBwYXJhbSB7Kn0gZGF0YSBkYXRhIHRvIGJlIHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBkZWZpbml0aW9uc1xuICovXG5leHBvcnRzLmRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoc2VsZiwgZmllbGRzLCBkYXRhKSB7XG4gIHNlbGYucmF3ID0gW107XG4gIHNlbGYuX2ZpZWxkcyA9IFtdO1xuXG4gIC8vIGF0dGFjaCB0aGUgYHRvSlNPTmBcbiAgc2VsZi50b0pTT04gPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgIHNlbGYuX2ZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICBvYmpbZmllbGRdID0gJzB4JyArIHNlbGZbZmllbGRdLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgcmV0dXJuIGV4cG9ydHMuYmFUb0pTT04odGhpcy5yYXcpO1xuICB9O1xuXG4gIHNlbGYuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBybHAuZW5jb2RlKHNlbGYucmF3KTtcbiAgfTtcblxuICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQsIGkpIHtcbiAgICBzZWxmLl9maWVsZHMucHVzaChmaWVsZC5uYW1lKTtcbiAgICBmdW5jdGlvbiBnZXR0ZXIoKSB7XG4gICAgICByZXR1cm4gc2VsZi5yYXdbaV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldHRlcih2KSB7XG4gICAgICB2ID0gZXhwb3J0cy50b0J1ZmZlcih2KTtcblxuICAgICAgaWYgKHYudG9TdHJpbmcoJ2hleCcpID09PSAnMDAnICYmICFmaWVsZC5hbGxvd1plcm8pIHtcbiAgICAgICAgdiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpZWxkLmFsbG93TGVzcyAmJiBmaWVsZC5sZW5ndGgpIHtcbiAgICAgICAgdiA9IGV4cG9ydHMuc3RyaXBaZXJvcyh2KTtcbiAgICAgICAgYXNzZXJ0KGZpZWxkLmxlbmd0aCA+PSB2Lmxlbmd0aCwgJ1RoZSBmaWVsZCAnICsgZmllbGQubmFtZSArICcgbXVzdCBub3QgaGF2ZSBtb3JlICcgKyBmaWVsZC5sZW5ndGggKyAnIGJ5dGVzJyk7XG4gICAgICB9IGVsc2UgaWYgKCEoZmllbGQuYWxsb3daZXJvICYmIHYubGVuZ3RoID09PSAwKSAmJiBmaWVsZC5sZW5ndGgpIHtcbiAgICAgICAgYXNzZXJ0KGZpZWxkLmxlbmd0aCA9PT0gdi5sZW5ndGgsICdUaGUgZmllbGQgJyArIGZpZWxkLm5hbWUgKyAnIG11c3QgaGF2ZSBieXRlIGxlbmd0aCBvZiAnICsgZmllbGQubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5yYXdbaV0gPSB2O1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBmaWVsZC5uYW1lLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBnZXR0ZXIsXG4gICAgICBzZXQ6IHNldHRlclxuICAgIH0pO1xuXG4gICAgaWYgKGZpZWxkLmRlZmF1bHQpIHtcbiAgICAgIHNlbGZbZmllbGQubmFtZV0gPSBmaWVsZC5kZWZhdWx0O1xuICAgIH1cblxuICAgIC8vIGF0dGFjaCBhbGlhc1xuICAgIGlmIChmaWVsZC5hbGlhcykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGZpZWxkLmFsaWFzLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHNldDogc2V0dGVyLFxuICAgICAgICBnZXQ6IGdldHRlclxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBpZiB0aGUgY29uc3R1Y3RvciBpcyBwYXNzZWQgZGF0YVxuICBpZiAoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShleHBvcnRzLnN0cmlwSGV4UHJlZml4KGRhdGEpLCAnaGV4Jyk7XG4gICAgfVxuXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgZGF0YSA9IHJscC5kZWNvZGUoZGF0YSk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA+IHNlbGYuX2ZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBudW1iZXIgb2YgZmllbGRzIGluIGRhdGEnKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBzdXJlIGFsbCB0aGUgaXRlbXMgYXJlIGJ1ZmZlcnNcbiAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICBzZWxmW3NlbGYuX2ZpZWxkc1tpXV0gPSBleHBvcnRzLnRvQnVmZmVyKGQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICgodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGRhdGEpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgaWYgKGtleXMuaW5kZXhPZihmaWVsZC5uYW1lKSAhPT0gLTEpIHNlbGZbZmllbGQubmFtZV0gPSBkYXRhW2ZpZWxkLm5hbWVdO1xuICAgICAgICBpZiAoa2V5cy5pbmRleE9mKGZpZWxkLmFsaWFzKSAhPT0gLTEpIHNlbGZbZmllbGQuYWxpYXNdID0gZGF0YVtmaWVsZC5hbGlhc107XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRhdGEnKTtcbiAgICB9XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2VjcDI1NmsxID0gcmVxdWlyZSgnZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3NlY3AyNTZrMScpO1xuXG5mdW5jdGlvbiBnZXRTZWNwMjU2azEgKCkgeyByZXR1cm4gcmVxdWlyZSgnLi9zZWNwMjU2azEtbGliL2luZGV4Jyk7IH1cbnZhciBkZXIgPSByZXF1aXJlKCcuL3NlY3AyNTZrMS1saWIvZGVyJyk7XG5cbi8qKlxuICogVmVyaWZ5IGFuIEVDRFNBIHByaXZhdGVLZXlcbiAqIEBtZXRob2QgcHJpdmF0ZUtleVZlcmlmeVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbnZhciBwcml2YXRlS2V5VmVyaWZ5ID0gZnVuY3Rpb24gcHJpdmF0ZUtleVZlcmlmeShwcml2YXRlS2V5KSB7XG4gIC8vIHNlY3AyNTZrMSB2NCB2ZXJzaW9uIHRocm93cyB3aGVuIHByaXZhdGVLZXkgbGVuZ3RoIGlzIG5vdCAzMlxuICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHNlY3AyNTZrMS5wcml2YXRlS2V5VmVyaWZ5KFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSk7XG59O1xuXG4vKipcbiAqIEV4cG9ydCBhIHByaXZhdGVLZXkgaW4gREVSIGZvcm1hdFxuICogQG1ldGhvZCBwcml2YXRlS2V5RXhwb3J0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG52YXIgcHJpdmF0ZUtleUV4cG9ydCA9IGZ1bmN0aW9uIHByaXZhdGVLZXlFeHBvcnQocHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICB2YXIgc2VjcDI1NmsxdjMgPSBnZXRTZWNwMjU2azEoKTtcbiAgLy8gcHJpdmF0ZUtleUV4cG9ydCBtZXRob2QgaXMgbm90IHBhcnQgb2Ygc2VjcDI1NmsxIHY0IHBhY2thZ2VcbiAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB2M1xuICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ByaXZhdGUga2V5IGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICB2YXIgcHVibGljS2V5ID0gc2VjcDI1NmsxdjMucHJpdmF0ZUtleUV4cG9ydChwcml2YXRlS2V5LCBjb21wcmVzc2VkKTtcblxuICByZXR1cm4gZGVyLnByaXZhdGVLZXlFeHBvcnQocHJpdmF0ZUtleSwgcHVibGljS2V5LCBjb21wcmVzc2VkKTtcbn07XG5cbi8qKlxuICogSW1wb3J0IGEgcHJpdmF0ZUtleSBpbiBERVIgZm9ybWF0XG4gKiBAbWV0aG9kIHByaXZhdGVLZXlJbXBvcnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cblxudmFyIHByaXZhdGVLZXlJbXBvcnQgPSBmdW5jdGlvbiBwcml2YXRlS2V5SW1wb3J0KHByaXZhdGVLZXkpIHtcbiAgLy8gcHJpdmF0ZUtleUltcG9ydCBtZXRob2QgaXMgbm90IHBhcnQgb2Ygc2VjcDI1NmsxIHY0IHBhY2thZ2VcbiAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB2M1xuICBwcml2YXRlS2V5ID0gZGVyLnByaXZhdGVLZXlJbXBvcnQocHJpdmF0ZUtleSk7XG4gIGlmIChwcml2YXRlS2V5ICE9PSBudWxsICYmIHByaXZhdGVLZXkubGVuZ3RoID09PSAzMiAmJiBwcml2YXRlS2V5VmVyaWZ5KHByaXZhdGVLZXkpKSB7XG4gICAgcmV0dXJuIHByaXZhdGVLZXk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZG4ndCBpbXBvcnQgZnJvbSBERVIgZm9ybWF0XCIpO1xufTtcblxuLyoqXG4gKiBOZWdhdGUgYSBwcml2YXRlS2V5IGJ5IHN1YnRyYWN0aW5nIGl0IGZyb20gdGhlIG9yZGVyIG9mIHRoZSBjdXJ2ZSdzIGJhc2UgcG9pbnRcbiAqIEBtZXRob2QgcHJpdmF0ZUtleU5lZ2F0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHByaXZhdGVLZXlOZWdhdGUgPSBmdW5jdGlvbiBwcml2YXRlS2V5TmVnYXRlKHByaXZhdGVLZXkpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wcml2YXRlS2V5TmVnYXRlKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSkpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBpbnZlcnNlIG9mIGEgcHJpdmF0ZUtleSAobW9kdWxvIHRoZSBvcmRlciBvZiB0aGUgY3VydmUncyBiYXNlIHBvaW50KS5cbiAqIEBtZXRob2QgcHJpdmF0ZUtleU1vZEludmVyc2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwcml2YXRlS2V5TW9kSW52ZXJzZSA9IGZ1bmN0aW9uIHByaXZhdGVLZXlNb2RJbnZlcnNlKHByaXZhdGVLZXkpIHtcbiAgaWYgKHByaXZhdGVLZXkubGVuZ3RoICE9PSAzMikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJpdmF0ZSBrZXkgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgfVxuICB2YXIgc2VjcDI1NmsxdjMgPSBnZXRTZWNwMjU2azEoKTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMXYzLnByaXZhdGVLZXlNb2RJbnZlcnNlKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSkpO1xufTtcblxuLyoqXG4gKiBUd2VhayBhIHByaXZhdGVLZXkgYnkgYWRkaW5nIHR3ZWFrIHRvIGl0LlxuICogQG1ldGhvZCBwcml2YXRlS2V5VHdlYWtBZGRcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gdHdlYWtcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHByaXZhdGVLZXlUd2Vha0FkZCA9IGZ1bmN0aW9uIHByaXZhdGVLZXlUd2Vha0FkZChwcml2YXRlS2V5LCB0d2Vhaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnByaXZhdGVLZXlUd2Vha0FkZChVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIHR3ZWFrKSk7XG59O1xuXG4vKipcbiAqIFR3ZWFrIGEgcHJpdmF0ZUtleSBieSBtdWx0aXBseWluZyBpdCBieSBhIHR3ZWFrLlxuICogQG1ldGhvZCBwcml2YXRlS2V5VHdlYWtNdWxcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gdHdlYWtcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHByaXZhdGVLZXlUd2Vha011bCA9IGZ1bmN0aW9uIHByaXZhdGVLZXlUd2Vha011bChwcml2YXRlS2V5LCB0d2Vhaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnByaXZhdGVLZXlUd2Vha011bChVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIFVpbnQ4QXJyYXkuZnJvbSh0d2VhaykpKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgcHVibGljIGtleSBmb3IgYSBwcml2YXRlS2V5LlxuICogQG1ldGhvZCBwdWJsaWNLZXlDcmVhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHB1YmxpY0tleUNyZWF0ZSA9IGZ1bmN0aW9uIHB1YmxpY0tleUNyZWF0ZShwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgY29tcHJlc3NlZCkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgcHVibGljS2V5IHRvIGNvbXByZXNzZWQgb3IgdW5jb21wcmVzc2VkIGZvcm0uXG4gKiBAbWV0aG9kIHB1YmxpY0tleUNvbnZlcnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHVibGljS2V5Q29udmVydCA9IGZ1bmN0aW9uIHB1YmxpY0tleUNvbnZlcnQocHVibGljS2V5LCBjb21wcmVzc2VkKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5Q29udmVydChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgY29tcHJlc3NlZCkpO1xufTtcblxuLyoqXG4gKiBWZXJpZnkgYW4gRUNEU0EgcHVibGljS2V5LlxuICogQG1ldGhvZCBwdWJsaWNLZXlWZXJpZnlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbnZhciBwdWJsaWNLZXlWZXJpZnkgPSBmdW5jdGlvbiBwdWJsaWNLZXlWZXJpZnkocHVibGljS2V5KSB7XG4gIC8vIHNlY3AyNTZrMSB2NCB2ZXJzaW9uIHRocm93cyB3aGVuIHB1YmxpY0tleSBsZW5ndGggaXMgbm90IDMzIG9yIDY1XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSAzMyAmJiBwdWJsaWNLZXkubGVuZ3RoICE9PSA2NSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpKTtcbn07XG5cbi8qKlxuICogVHdlYWsgYSBwdWJsaWNLZXkgYnkgYWRkaW5nIHR3ZWFrIHRpbWVzIHRoZSBnZW5lcmF0b3IgdG8gaXQuXG4gKiBAbWV0aG9kIHB1YmxpY0tleVR3ZWFrQWRkXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gdHdlYWtcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHVibGljS2V5VHdlYWtBZGQgPSBmdW5jdGlvbiBwdWJsaWNLZXlUd2Vha0FkZChwdWJsaWNLZXksIHR3ZWFrLCBjb21wcmVzc2VkKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5VHdlYWtBZGQoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIFVpbnQ4QXJyYXkuZnJvbSh0d2VhayksIGNvbXByZXNzZWQpKTtcbn07XG5cbi8qKlxuICogVHdlYWsgYSBwdWJsaWNLZXkgYnkgbXVsdGlwbHlpbmcgaXQgYnkgYSB0d2VhayB2YWx1ZVxuICogQG1ldGhvZCBwdWJsaWNLZXlUd2Vha011bFxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtCdWZmZXJ9IHR3ZWFrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHB1YmxpY0tleVR3ZWFrTXVsID0gZnVuY3Rpb24gcHVibGljS2V5VHdlYWtNdWwocHVibGljS2V5LCB0d2VhaywgY29tcHJlc3NlZCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleVR3ZWFrTXVsKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBVaW50OEFycmF5LmZyb20odHdlYWspLCBjb21wcmVzc2VkKSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIGdpdmVuIHB1YmxpY0tleXMgdG9nZXRoZXIuXG4gKiBAbWV0aG9kIHB1YmxpY0tleUNvbWJpbmVcbiAqIEBwYXJhbSB7QXJyYXk8QnVmZmVyPn0gcHVibGljS2V5c1xuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwdWJsaWNLZXlDb21iaW5lID0gZnVuY3Rpb24gcHVibGljS2V5Q29tYmluZShwdWJsaWNLZXlzLCBjb21wcmVzc2VkKSB7XG4gIHZhciBrZXlzID0gW107XG4gIHB1YmxpY0tleXMuZm9yRWFjaChmdW5jdGlvbiAocHVibGljS2V5KSB7XG4gICAga2V5cy5wdXNoKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpKTtcbiAgfSk7XG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlDb21iaW5lKGtleXMsIGNvbXByZXNzZWQpKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIHNpZ25hdHVyZSB0byBhIG5vcm1hbGl6ZWQgbG93ZXItUyBmb3JtLlxuICogQG1ldGhvZCBzaWduYXR1cmVOb3JtYWxpemVcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHNpZ25hdHVyZU5vcm1hbGl6ZSA9IGZ1bmN0aW9uIHNpZ25hdHVyZU5vcm1hbGl6ZShzaWduYXR1cmUpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5zaWduYXR1cmVOb3JtYWxpemUoVWludDhBcnJheS5mcm9tKHNpZ25hdHVyZSkpKTtcbn07XG5cbi8qKlxuICogU2VyaWFsaXplIGFuIEVDRFNBIHNpZ25hdHVyZSBpbiBERVIgZm9ybWF0LlxuICogQG1ldGhvZCBzaWduYXR1cmVFeHBvcnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHNpZ25hdHVyZUV4cG9ydCA9IGZ1bmN0aW9uIHNpZ25hdHVyZUV4cG9ydChzaWduYXR1cmUpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5zaWduYXR1cmVFeHBvcnQoVWludDhBcnJheS5mcm9tKHNpZ25hdHVyZSkpKTtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBERVIgRUNEU0Egc2lnbmF0dXJlIChmb2xsb3cgYnkgW0JJUDY2XShodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDY2Lm1lZGlhd2lraSkpLlxuICogQG1ldGhvZCBzaWduYXR1cmVJbXBvcnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHNpZ25hdHVyZUltcG9ydCA9IGZ1bmN0aW9uIHNpZ25hdHVyZUltcG9ydChzaWduYXR1cmUpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5zaWduYXR1cmVJbXBvcnQoVWludDhBcnJheS5mcm9tKHNpZ25hdHVyZSkpKTtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBERVIgRUNEU0Egc2lnbmF0dXJlIChub3QgZm9sbG93IGJ5IFtCSVA2Nl0oaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDA2Ni5tZWRpYXdpa2kpKS5cbiAqIEBtZXRob2Qgc2lnbmF0dXJlSW1wb3J0TGF4XG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBzaWduYXR1cmVJbXBvcnRMYXggPSBmdW5jdGlvbiBzaWduYXR1cmVJbXBvcnRMYXgoc2lnbmF0dXJlKSB7XG4gIC8vIHNpZ25hdHVyZUltcG9ydExheCBtZXRob2QgaXMgbm90IHBhcnQgb2Ygc2VjcDI1NmsxIHY0IHBhY2thZ2VcbiAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB2M1xuICAvLyBlbnN1cmUgdGhhdCBzaWduYXR1cmUgaXMgZ3JlYXRlciB0aGFuIDBcbiAgaWYgKHNpZ25hdHVyZS5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2lnbmF0dXJlIGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gIH1cbiAgdmFyIHNlY3AyNTZrMXYzID0gZ2V0U2VjcDI1NmsxKCk7XG5cbiAgdmFyIHNpZ09iaiA9IGRlci5zaWduYXR1cmVJbXBvcnRMYXgoc2lnbmF0dXJlKTtcbiAgaWYgKHNpZ09iaiA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxkbid0IHBhcnNlIERFUiBzaWduYXR1cmVcIik7XG4gIH1cblxuICByZXR1cm4gc2VjcDI1NmsxdjMuc2lnbmF0dXJlSW1wb3J0KHNpZ09iaik7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFQ0RTQSBzaWduYXR1cmUuIEFsd2F5cyByZXR1cm4gbG93LVMgc2lnbmF0dXJlLlxuICogQG1ldGhvZCBzaWduXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVzc2FnZVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBzaWduID0gZnVuY3Rpb24gc2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBzaG91bGQgYmUgYW4gT2JqZWN0Jyk7XG4gIH1cblxuICB2YXIgc2lnbk9wdGlvbnMgPSB2b2lkIDA7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBzaWduT3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKG9wdGlvbnMuZGF0YSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5kYXRhIHNob3VsZCBiZSBhIEJ1ZmZlcicpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgIC8vIHZhbGlkYXRlIG9wdGlvbi5kYXRhIGxlbmd0aFxuICAgICAgaWYgKG9wdGlvbnMuZGF0YS5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvcHRpb25zLmRhdGEgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgICAgIH1cblxuICAgICAgc2lnbk9wdGlvbnMuZGF0YSA9IG5ldyBVaW50OEFycmF5KG9wdGlvbnMuZGF0YSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubm9uY2VmbiA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5ub25jZWZuIHNob3VsZCBiZSBhIEZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubm9uY2Vmbikge1xuICAgICAgLy8gIGNvbnZlcnQgb3B0aW9uLm5vbmNlZm4gZnVuY3Rpb24gc2lnbmF0dXJlXG4gICAgICBzaWduT3B0aW9ucy5ub25jZWZuID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHByaXZhdGVLZXksIGFsZ28sIGRhdGEsIGF0dGVtcHQpIHtcbiAgICAgICAgdmFyIGJ1ZmZlckFsZ28gPSBhbGdvICE9IG51bGwgPyBCdWZmZXIuZnJvbShhbGdvKSA6IG51bGw7XG4gICAgICAgIHZhciBidWZmZXJEYXRhID0gZGF0YSAhPSBudWxsID8gQnVmZmVyLmZyb20oZGF0YSkgOiBudWxsO1xuXG4gICAgICAgIHZhciBidWZmZXIgPSBCdWZmZXIuZnJvbSgnJyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubm9uY2Vmbikge1xuICAgICAgICAgIGJ1ZmZlciA9IG9wdGlvbnMubm9uY2VmbihCdWZmZXIuZnJvbShtZXNzYWdlKSwgQnVmZmVyLmZyb20ocHJpdmF0ZUtleSksIGJ1ZmZlckFsZ28sIGJ1ZmZlckRhdGEsIGF0dGVtcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShidWZmZXIpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgc2lnID0gc2VjcDI1NmsxLmVjZHNhU2lnbihVaW50OEFycmF5LmZyb20obWVzc2FnZSksIFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgc2lnbk9wdGlvbnMpO1xuXG4gIHJldHVybiB7XG4gICAgc2lnbmF0dXJlOiBCdWZmZXIuZnJvbShzaWcuc2lnbmF0dXJlKSxcbiAgICByZWNvdmVyeTogc2lnLnJlY2lkXG4gIH07XG59O1xuXG4vKipcbiAqIFZlcmlmeSBhbiBFQ0RTQSBzaWduYXR1cmUuXG4gKiBAbWV0aG9kIHZlcmlmeVxuICogQHBhcmFtIHtCdWZmZXJ9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbnZhciB2ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpIHtcbiAgLy8gbm90ZTogc2VjcDI1NmsxIHY0IHZlcmlmeSBtZXRob2QgaGFzIGEgZGlmZmVyZW50IGFyZ3VtZW50IG9yZGVyXG4gIHJldHVybiBzZWNwMjU2azEuZWNkc2FWZXJpZnkoVWludDhBcnJheS5mcm9tKHNpZ25hdHVyZSksIFVpbnQ4QXJyYXkuZnJvbShtZXNzYWdlKSwgcHVibGljS2V5KTtcbn07XG5cbi8qKlxuICogUmVjb3ZlciBhbiBFQ0RTQSBwdWJsaWMga2V5IGZyb20gYSBzaWduYXR1cmUuXG4gKiBAbWV0aG9kIHJlY292ZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXNzYWdlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcGFyYW0ge051bWJlcn0gcmVjaWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcmVjb3ZlciA9IGZ1bmN0aW9uIHJlY292ZXIobWVzc2FnZSwgc2lnbmF0dXJlLCByZWNpZCwgY29tcHJlc3NlZCkge1xuICAvLyBub3RlOiBzZWNwMjU2azEgdjQgcmVjb3ZlciBtZXRob2QgaGFzIGEgZGlmZmVyZW50IGFyZ3VtZW50IG9yZGVyXG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuZWNkc2FSZWNvdmVyKFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpLCByZWNpZCwgVWludDhBcnJheS5mcm9tKG1lc3NhZ2UpLCBjb21wcmVzc2VkKSk7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgYW4gRUMgRGlmZmllLUhlbGxtYW4gc2VjcmV0IGFuZCBhcHBsaWVkIHNoYTI1NiB0byBjb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gKiBAbWV0aG9kIGVjZGhcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBlY2RoID0gZnVuY3Rpb24gZWNkaChwdWJsaWNLZXksIHByaXZhdGVLZXkpIHtcbiAgLy8gbm90ZTogc2VjcDI1NmsxIHYzIGRvZXNuJ3QgYWxsb3cgb3B0aW9uYWwgcGFyYW1ldGVyXG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuZWNkaChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCB7fSkpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIGFuIEVDIERpZmZpZS1IZWxsbWFuIHNlY3JldCBhbmQgcmV0dXJuIHB1YmxpYyBrZXkgYXMgcmVzdWx0XG4gKiBAbWV0aG9kIGVjZGhVbnNhZmVcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIGVjZGhVbnNhZmUgPSBmdW5jdGlvbiBlY2RoVW5zYWZlKHB1YmxpY0tleSwgcHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICAvLyBlY2RoVW5zYWZlIG1ldGhvZCBpcyBub3QgcGFydCBvZiBzZWNwMjU2azEgdjQgcGFja2FnZVxuICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHYzXG4gIC8vIGVuc3VyZSB2YWxpZCBwdWJsaWNLZXkgbGVuZ3RoXG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSAzMyAmJiBwdWJsaWNLZXkubGVuZ3RoICE9PSA2NSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdwdWJsaWMga2V5IGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICAvLyBlbnN1cmUgdmFsaWQgcHJpdmF0ZUtleSBsZW5ndGhcbiAgaWYgKHByaXZhdGVLZXkubGVuZ3RoICE9PSAzMikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdwcml2YXRlIGtleSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICB9XG4gIHZhciBzZWNwMjU2azF2MyA9IGdldFNlY3AyNTZrMSgpO1xuXG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azF2My5lY2RoVW5zYWZlKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIGNvbXByZXNzZWQpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwcml2YXRlS2V5VmVyaWZ5OiBwcml2YXRlS2V5VmVyaWZ5LFxuICBwcml2YXRlS2V5RXhwb3J0OiBwcml2YXRlS2V5RXhwb3J0LFxuICBwcml2YXRlS2V5SW1wb3J0OiBwcml2YXRlS2V5SW1wb3J0LFxuICBwcml2YXRlS2V5TmVnYXRlOiBwcml2YXRlS2V5TmVnYXRlLFxuICBwcml2YXRlS2V5TW9kSW52ZXJzZTogcHJpdmF0ZUtleU1vZEludmVyc2UsXG4gIHByaXZhdGVLZXlUd2Vha0FkZDogcHJpdmF0ZUtleVR3ZWFrQWRkLFxuICBwcml2YXRlS2V5VHdlYWtNdWw6IHByaXZhdGVLZXlUd2Vha011bCxcblxuICBwdWJsaWNLZXlDcmVhdGU6IHB1YmxpY0tleUNyZWF0ZSxcbiAgcHVibGljS2V5Q29udmVydDogcHVibGljS2V5Q29udmVydCxcbiAgcHVibGljS2V5VmVyaWZ5OiBwdWJsaWNLZXlWZXJpZnksXG4gIHB1YmxpY0tleVR3ZWFrQWRkOiBwdWJsaWNLZXlUd2Vha0FkZCxcbiAgcHVibGljS2V5VHdlYWtNdWw6IHB1YmxpY0tleVR3ZWFrTXVsLFxuICBwdWJsaWNLZXlDb21iaW5lOiBwdWJsaWNLZXlDb21iaW5lLFxuXG4gIHNpZ25hdHVyZU5vcm1hbGl6ZTogc2lnbmF0dXJlTm9ybWFsaXplLFxuICBzaWduYXR1cmVFeHBvcnQ6IHNpZ25hdHVyZUV4cG9ydCxcbiAgc2lnbmF0dXJlSW1wb3J0OiBzaWduYXR1cmVJbXBvcnQsXG4gIHNpZ25hdHVyZUltcG9ydExheDogc2lnbmF0dXJlSW1wb3J0TGF4LFxuXG4gIHNpZ246IHNpZ24sXG4gIHZlcmlmeTogdmVyaWZ5LFxuICByZWNvdmVyOiByZWNvdmVyLFxuXG4gIGVjZGg6IGVjZGgsXG4gIGVjZGhVbnNhZmU6IGVjZGhVbnNhZmVcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFRoaXMgZmlsZSBpcyBpbXBvcnRlZCBmcm9tIHNlY3AyNTZrMSB2M1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9zZWNwMjU2azEtbm9kZS9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbnZhciBFQ19QUklWS0VZX0VYUE9SVF9ERVJfQ09NUFJFU1NFRCA9IEJ1ZmZlci5mcm9tKFtcbi8vIGJlZ2luXG4weDMwLCAweDgxLCAweGQzLCAweDAyLCAweDAxLCAweDAxLCAweDA0LCAweDIwLFxuLy8gcHJpdmF0ZSBrZXlcbjB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4vLyBtaWRkbGVcbjB4YTAsIDB4ODEsIDB4ODUsIDB4MzAsIDB4ODEsIDB4ODIsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MzAsIDB4MmMsIDB4MDYsIDB4MDcsIDB4MmEsIDB4ODYsIDB4NDgsIDB4Y2UsIDB4M2QsIDB4MDEsIDB4MDEsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmUsIDB4ZmYsIDB4ZmYsIDB4ZmMsIDB4MmYsIDB4MzAsIDB4MDYsIDB4MDQsIDB4MDEsIDB4MDAsIDB4MDQsIDB4MDEsIDB4MDcsIDB4MDQsIDB4MjEsIDB4MDIsIDB4NzksIDB4YmUsIDB4NjYsIDB4N2UsIDB4ZjksIDB4ZGMsIDB4YmIsIDB4YWMsIDB4NTUsIDB4YTAsIDB4NjIsIDB4OTUsIDB4Y2UsIDB4ODcsIDB4MGIsIDB4MDcsIDB4MDIsIDB4OWIsIDB4ZmMsIDB4ZGIsIDB4MmQsIDB4Y2UsIDB4MjgsIDB4ZDksIDB4NTksIDB4ZjIsIDB4ODEsIDB4NWIsIDB4MTYsIDB4ZjgsIDB4MTcsIDB4OTgsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmUsIDB4YmEsIDB4YWUsIDB4ZGMsIDB4ZTYsIDB4YWYsIDB4NDgsIDB4YTAsIDB4M2IsIDB4YmYsIDB4ZDIsIDB4NWUsIDB4OGMsIDB4ZDAsIDB4MzYsIDB4NDEsIDB4NDEsIDB4MDIsIDB4MDEsIDB4MDEsIDB4YTEsIDB4MjQsIDB4MDMsIDB4MjIsIDB4MDAsXG4vLyBwdWJsaWMga2V5XG4weDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwXSk7XG5cbnZhciBFQ19QUklWS0VZX0VYUE9SVF9ERVJfVU5DT01QUkVTU0VEID0gQnVmZmVyLmZyb20oW1xuLy8gYmVnaW5cbjB4MzAsIDB4ODIsIDB4MDEsIDB4MTMsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MDQsIDB4MjAsXG4vLyBwcml2YXRlIGtleVxuMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbi8vIG1pZGRsZVxuMHhhMCwgMHg4MSwgMHhhNSwgMHgzMCwgMHg4MSwgMHhhMiwgMHgwMiwgMHgwMSwgMHgwMSwgMHgzMCwgMHgyYywgMHgwNiwgMHgwNywgMHgyYSwgMHg4NiwgMHg0OCwgMHhjZSwgMHgzZCwgMHgwMSwgMHgwMSwgMHgwMiwgMHgyMSwgMHgwMCwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZSwgMHhmZiwgMHhmZiwgMHhmYywgMHgyZiwgMHgzMCwgMHgwNiwgMHgwNCwgMHgwMSwgMHgwMCwgMHgwNCwgMHgwMSwgMHgwNywgMHgwNCwgMHg0MSwgMHgwNCwgMHg3OSwgMHhiZSwgMHg2NiwgMHg3ZSwgMHhmOSwgMHhkYywgMHhiYiwgMHhhYywgMHg1NSwgMHhhMCwgMHg2MiwgMHg5NSwgMHhjZSwgMHg4NywgMHgwYiwgMHgwNywgMHgwMiwgMHg5YiwgMHhmYywgMHhkYiwgMHgyZCwgMHhjZSwgMHgyOCwgMHhkOSwgMHg1OSwgMHhmMiwgMHg4MSwgMHg1YiwgMHgxNiwgMHhmOCwgMHgxNywgMHg5OCwgMHg0OCwgMHgzYSwgMHhkYSwgMHg3NywgMHgyNiwgMHhhMywgMHhjNCwgMHg2NSwgMHg1ZCwgMHhhNCwgMHhmYiwgMHhmYywgMHgwZSwgMHgxMSwgMHgwOCwgMHhhOCwgMHhmZCwgMHgxNywgMHhiNCwgMHg0OCwgMHhhNiwgMHg4NSwgMHg1NCwgMHgxOSwgMHg5YywgMHg0NywgMHhkMCwgMHg4ZiwgMHhmYiwgMHgxMCwgMHhkNCwgMHhiOCwgMHgwMiwgMHgyMSwgMHgwMCwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZSwgMHhiYSwgMHhhZSwgMHhkYywgMHhlNiwgMHhhZiwgMHg0OCwgMHhhMCwgMHgzYiwgMHhiZiwgMHhkMiwgMHg1ZSwgMHg4YywgMHhkMCwgMHgzNiwgMHg0MSwgMHg0MSwgMHgwMiwgMHgwMSwgMHgwMSwgMHhhMSwgMHg0NCwgMHgwMywgMHg0MiwgMHgwMCxcbi8vIHB1YmxpYyBrZXlcbjB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDBdKTtcblxuZXhwb3J0cy5wcml2YXRlS2V5RXhwb3J0ID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIHB1YmxpY0tleSwgY29tcHJlc3NlZCkge1xuICB2YXIgcmVzdWx0ID0gQnVmZmVyLmZyb20oY29tcHJlc3NlZCA/IEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9DT01QUkVTU0VEIDogRUNfUFJJVktFWV9FWFBPUlRfREVSX1VOQ09NUFJFU1NFRCk7XG4gIHByaXZhdGVLZXkuY29weShyZXN1bHQsIGNvbXByZXNzZWQgPyA4IDogOSk7XG4gIHB1YmxpY0tleS5jb3B5KHJlc3VsdCwgY29tcHJlc3NlZCA/IDE4MSA6IDIxNCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnRzLnByaXZhdGVLZXlJbXBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICB2YXIgbGVuZ3RoID0gcHJpdmF0ZUtleS5sZW5ndGg7XG5cbiAgLy8gc2VxdWVuY2UgaGVhZGVyXG4gIHZhciBpbmRleCA9IDA7XG4gIGlmIChsZW5ndGggPCBpbmRleCArIDEgfHwgcHJpdmF0ZUtleVtpbmRleF0gIT09IDB4MzApIHJldHVybiBudWxsO1xuICBpbmRleCArPSAxO1xuXG4gIC8vIHNlcXVlbmNlIGxlbmd0aCBjb25zdHJ1Y3RvclxuICBpZiAobGVuZ3RoIDwgaW5kZXggKyAxIHx8ICEocHJpdmF0ZUtleVtpbmRleF0gJiAweDgwKSkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGxlbmIgPSBwcml2YXRlS2V5W2luZGV4XSAmIDB4N2Y7XG4gIGluZGV4ICs9IDE7XG4gIGlmIChsZW5iIDwgMSB8fCBsZW5iID4gMikgcmV0dXJuIG51bGw7XG4gIGlmIChsZW5ndGggPCBpbmRleCArIGxlbmIpIHJldHVybiBudWxsO1xuXG4gIC8vIHNlcXVlbmNlIGxlbmd0aFxuICB2YXIgbGVuID0gcHJpdmF0ZUtleVtpbmRleCArIGxlbmIgLSAxXSB8IChsZW5iID4gMSA/IHByaXZhdGVLZXlbaW5kZXggKyBsZW5iIC0gMl0gPDwgOCA6IDApO1xuICBpbmRleCArPSBsZW5iO1xuICBpZiAobGVuZ3RoIDwgaW5kZXggKyBsZW4pIHJldHVybiBudWxsO1xuXG4gIC8vIHNlcXVlbmNlIGVsZW1lbnQgMDogdmVyc2lvbiBudW1iZXIgKD0xKVxuICBpZiAobGVuZ3RoIDwgaW5kZXggKyAzIHx8IHByaXZhdGVLZXlbaW5kZXhdICE9PSAweDAyIHx8IHByaXZhdGVLZXlbaW5kZXggKyAxXSAhPT0gMHgwMSB8fCBwcml2YXRlS2V5W2luZGV4ICsgMl0gIT09IDB4MDEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpbmRleCArPSAzO1xuXG4gIC8vIHNlcXVlbmNlIGVsZW1lbnQgMTogb2N0ZXQgc3RyaW5nLCB1cCB0byAzMiBieXRlc1xuICBpZiAobGVuZ3RoIDwgaW5kZXggKyAyIHx8IHByaXZhdGVLZXlbaW5kZXhdICE9PSAweDA0IHx8IHByaXZhdGVLZXlbaW5kZXggKyAxXSA+IDB4MjAgfHwgbGVuZ3RoIDwgaW5kZXggKyAyICsgcHJpdmF0ZUtleVtpbmRleCArIDFdKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcHJpdmF0ZUtleS5zbGljZShpbmRleCArIDIsIGluZGV4ICsgMiArIHByaXZhdGVLZXlbaW5kZXggKyAxXSk7XG59O1xuXG5leHBvcnRzLnNpZ25hdHVyZUltcG9ydExheCA9IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgdmFyIHIgPSBCdWZmZXIuYWxsb2MoMzIsIDApO1xuICB2YXIgcyA9IEJ1ZmZlci5hbGxvYygzMiwgMCk7XG5cbiAgdmFyIGxlbmd0aCA9IHNpZ25hdHVyZS5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgLy8gc2VxdWVuY2UgdGFnIGJ5dGVcbiAgaWYgKHNpZ25hdHVyZVtpbmRleCsrXSAhPT0gMHgzMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gc2VxdWVuY2UgbGVuZ3RoIGJ5dGVcbiAgdmFyIGxlbmJ5dGUgPSBzaWduYXR1cmVbaW5kZXgrK107XG4gIGlmIChsZW5ieXRlICYgMHg4MCkge1xuICAgIGluZGV4ICs9IGxlbmJ5dGUgLSAweDgwO1xuICAgIGlmIChpbmRleCA+IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gc2VxdWVuY2UgdGFnIGJ5dGUgZm9yIHJcbiAgaWYgKHNpZ25hdHVyZVtpbmRleCsrXSAhPT0gMHgwMikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gbGVuZ3RoIGZvciByXG4gIHZhciBybGVuID0gc2lnbmF0dXJlW2luZGV4KytdO1xuICBpZiAocmxlbiAmIDB4ODApIHtcbiAgICBsZW5ieXRlID0gcmxlbiAtIDB4ODA7XG4gICAgaWYgKGluZGV4ICsgbGVuYnl0ZSA+IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvciAoOyBsZW5ieXRlID4gMCAmJiBzaWduYXR1cmVbaW5kZXhdID09PSAweDAwOyBpbmRleCArPSAxLCBsZW5ieXRlIC09IDEpIHt9XG4gICAgZm9yIChybGVuID0gMDsgbGVuYnl0ZSA+IDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSkge1xuICAgICAgcmxlbiA9IChybGVuIDw8IDgpICsgc2lnbmF0dXJlW2luZGV4XTtcbiAgICB9XG4gIH1cbiAgaWYgKHJsZW4gPiBsZW5ndGggLSBpbmRleCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciByaW5kZXggPSBpbmRleDtcbiAgaW5kZXggKz0gcmxlbjtcblxuICAvLyBzZXF1ZW5jZSB0YWcgYnl0ZSBmb3Igc1xuICBpZiAoc2lnbmF0dXJlW2luZGV4KytdICE9PSAweDAyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBsZW5ndGggZm9yIHNcbiAgdmFyIHNsZW4gPSBzaWduYXR1cmVbaW5kZXgrK107XG4gIGlmIChzbGVuICYgMHg4MCkge1xuICAgIGxlbmJ5dGUgPSBzbGVuIC0gMHg4MDtcbiAgICBpZiAoaW5kZXggKyBsZW5ieXRlID4gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yICg7IGxlbmJ5dGUgPiAwICYmIHNpZ25hdHVyZVtpbmRleF0gPT09IDB4MDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSkge31cbiAgICBmb3IgKHNsZW4gPSAwOyBsZW5ieXRlID4gMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKSB7XG4gICAgICBzbGVuID0gKHNsZW4gPDwgOCkgKyBzaWduYXR1cmVbaW5kZXhdO1xuICAgIH1cbiAgfVxuICBpZiAoc2xlbiA+IGxlbmd0aCAtIGluZGV4KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHNpbmRleCA9IGluZGV4O1xuICBpbmRleCArPSBzbGVuO1xuXG4gIC8vIGlnbm9yZSBsZWFkaW5nIHplcm9zIGluIHJcbiAgZm9yICg7IHJsZW4gPiAwICYmIHNpZ25hdHVyZVtyaW5kZXhdID09PSAweDAwOyBybGVuIC09IDEsIHJpbmRleCArPSAxKSB7fVxuICAvLyBjb3B5IHIgdmFsdWVcbiAgaWYgKHJsZW4gPiAzMikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBydmFsdWUgPSBzaWduYXR1cmUuc2xpY2UocmluZGV4LCByaW5kZXggKyBybGVuKTtcbiAgcnZhbHVlLmNvcHkociwgMzIgLSBydmFsdWUubGVuZ3RoKTtcblxuICAvLyBpZ25vcmUgbGVhZGluZyB6ZXJvcyBpbiBzXG4gIGZvciAoOyBzbGVuID4gMCAmJiBzaWduYXR1cmVbc2luZGV4XSA9PT0gMHgwMDsgc2xlbiAtPSAxLCBzaW5kZXggKz0gMSkge31cbiAgLy8gY29weSBzIHZhbHVlXG4gIGlmIChzbGVuID4gMzIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgc3ZhbHVlID0gc2lnbmF0dXJlLnNsaWNlKHNpbmRleCwgc2luZGV4ICsgc2xlbik7XG4gIHN2YWx1ZS5jb3B5KHMsIDMyIC0gc3ZhbHVlLmxlbmd0aCk7XG5cbiAgcmV0dXJuIHsgcjogciwgczogcyB9O1xufTsiLCIndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgZmlsZSBpcyBpbXBvcnRlZCBmcm9tIHNlY3AyNTZrMSB2M1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9zZWNwMjU2azEtbm9kZS9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgRUMgPSByZXF1aXJlKCdlbGxpcHRpYycpLmVjO1xuXG52YXIgZWMgPSBuZXcgRUMoJ3NlY3AyNTZrMScpO1xudmFyIGVjcGFyYW1zID0gZWMuY3VydmU7XG5cbmV4cG9ydHMucHJpdmF0ZUtleUV4cG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIHZhciBkID0gbmV3IEJOKHByaXZhdGVLZXkpO1xuICBpZiAoZC51Y21wKGVjcGFyYW1zLm4pID49IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkblxcJ3QgZXhwb3J0IHRvIERFUiBmb3JtYXQnKTtcbiAgfVxuXG4gIHZhciBwb2ludCA9IGVjLmcubXVsKGQpO1xuICByZXR1cm4gdG9QdWJsaWNLZXkocG9pbnQuZ2V0WCgpLCBwb2ludC5nZXRZKCksIGNvbXByZXNzZWQpO1xufTtcblxuZXhwb3J0cy5wcml2YXRlS2V5TW9kSW52ZXJzZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHZhciBibiA9IG5ldyBCTihwcml2YXRlS2V5KTtcbiAgaWYgKGJuLnVjbXAoZWNwYXJhbXMubikgPj0gMCB8fCBibi5pc1plcm8oKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJpdmF0ZSBrZXkgcmFuZ2UgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIGJuLmludm0oZWNwYXJhbXMubikudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMik7XG59O1xuXG5leHBvcnRzLnNpZ25hdHVyZUltcG9ydCA9IGZ1bmN0aW9uIChzaWdPYmopIHtcbiAgdmFyIHIgPSBuZXcgQk4oc2lnT2JqLnIpO1xuICBpZiAoci51Y21wKGVjcGFyYW1zLm4pID49IDApIHtcbiAgICByID0gbmV3IEJOKDApO1xuICB9XG5cbiAgdmFyIHMgPSBuZXcgQk4oc2lnT2JqLnMpO1xuICBpZiAocy51Y21wKGVjcGFyYW1zLm4pID49IDApIHtcbiAgICBzID0gbmV3IEJOKDApO1xuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3IudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMiksIHMudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMildKTtcbn07XG5cbmV4cG9ydHMuZWNkaFVuc2FmZSA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgdmFyIHBvaW50ID0gZWMua2V5RnJvbVB1YmxpYyhwdWJsaWNLZXkpO1xuXG4gIHZhciBzY2FsYXIgPSBuZXcgQk4ocHJpdmF0ZUtleSk7XG4gIGlmIChzY2FsYXIudWNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHNjYWxhci5pc1plcm8oKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2NhbGFyIHdhcyBpbnZhbGlkICh6ZXJvIG9yIG92ZXJmbG93KScpO1xuICB9XG5cbiAgdmFyIHNoYXJlZCA9IHBvaW50LnB1Yi5tdWwoc2NhbGFyKTtcbiAgcmV0dXJuIHRvUHVibGljS2V5KHNoYXJlZC5nZXRYKCksIHNoYXJlZC5nZXRZKCksIGNvbXByZXNzZWQpO1xufTtcblxudmFyIHRvUHVibGljS2V5ID0gZnVuY3Rpb24gdG9QdWJsaWNLZXkoeCwgeSwgY29tcHJlc3NlZCkge1xuICB2YXIgcHVibGljS2V5ID0gdm9pZCAwO1xuXG4gIGlmIChjb21wcmVzc2VkKSB7XG4gICAgcHVibGljS2V5ID0gQnVmZmVyLmFsbG9jKDMzKTtcbiAgICBwdWJsaWNLZXlbMF0gPSB5LmlzT2RkKCkgPyAweDAzIDogMHgwMjtcbiAgICB4LnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpLmNvcHkocHVibGljS2V5LCAxKTtcbiAgfSBlbHNlIHtcbiAgICBwdWJsaWNLZXkgPSBCdWZmZXIuYWxsb2MoNjUpO1xuICAgIHB1YmxpY0tleVswXSA9IDB4MDQ7XG4gICAgeC50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKS5jb3B5KHB1YmxpY0tleSwgMSk7XG4gICAgeS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKS5jb3B5KHB1YmxpY0tleSwgMzMpO1xuICB9XG5cbiAgcmV0dXJuIHB1YmxpY0tleTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBjcmVhdGVIYXNoRnVuY3Rpb24oaGFzaENvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIGhhc2ggPSBoYXNoQ29uc3RydWN0b3IoKTtcbiAgICAgICAgaGFzaC51cGRhdGUobXNnKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhhc2guZGlnZXN0KCkpO1xuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZUhhc2hGdW5jdGlvbiA9IGNyZWF0ZUhhc2hGdW5jdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2gtdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaGFzaF91dGlsc18xID0gcmVxdWlyZShcIi4vaGFzaC11dGlsc1wiKTtcbnZhciBjcmVhdGVLZWNjYWtIYXNoID0gcmVxdWlyZShcImtlY2Nha1wiKTtcbmV4cG9ydHMua2VjY2FrMjI0ID0gaGFzaF91dGlsc18xLmNyZWF0ZUhhc2hGdW5jdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUtlY2Nha0hhc2goXCJrZWNjYWsyMjRcIik7XG59KTtcbmV4cG9ydHMua2VjY2FrMjU2ID0gaGFzaF91dGlsc18xLmNyZWF0ZUhhc2hGdW5jdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUtlY2Nha0hhc2goXCJrZWNjYWsyNTZcIik7XG59KTtcbmV4cG9ydHMua2VjY2FrMzg0ID0gaGFzaF91dGlsc18xLmNyZWF0ZUhhc2hGdW5jdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUtlY2Nha0hhc2goXCJrZWNjYWszODRcIik7XG59KTtcbmV4cG9ydHMua2VjY2FrNTEyID0gaGFzaF91dGlsc18xLmNyZWF0ZUhhc2hGdW5jdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUtlY2Nha0hhc2goXCJrZWNjYWs1MTJcIik7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtlY2Nhay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciByYW5kb21ieXRlcyA9IHJlcXVpcmUoXCJyYW5kb21ieXRlc1wiKTtcbmZ1bmN0aW9uIGdldFJhbmRvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcmFuZG9tYnl0ZXMoYnl0ZXMsIGZ1bmN0aW9uIChlcnIsIHJlc3ApIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3ApO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2V0UmFuZG9tQnl0ZXMgPSBnZXRSYW5kb21CeXRlcztcbmZ1bmN0aW9uIGdldFJhbmRvbUJ5dGVzU3luYyhieXRlcykge1xuICAgIHJldHVybiByYW5kb21ieXRlcyhieXRlcyk7XG59XG5leHBvcnRzLmdldFJhbmRvbUJ5dGVzU3luYyA9IGdldFJhbmRvbUJ5dGVzU3luYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhbmRvbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNlY3AyNTZrMV8xID0gcmVxdWlyZShcInNlY3AyNTZrMVwiKTtcbnZhciByYW5kb21fMSA9IHJlcXVpcmUoXCIuL3JhbmRvbVwiKTtcbnZhciBTRUNQMjU2SzFfUFJJVkFURV9LRVlfU0laRSA9IDMyO1xuZnVuY3Rpb24gY3JlYXRlUHJpdmF0ZUtleSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwaztcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cnVlKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmFuZG9tXzEuZ2V0UmFuZG9tQnl0ZXMoU0VDUDI1NksxX1BSSVZBVEVfS0VZX1NJWkUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHBrID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VjcDI1NmsxXzEucHJpdmF0ZUtleVZlcmlmeShwaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBwa107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMF07XG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVQcml2YXRlS2V5ID0gY3JlYXRlUHJpdmF0ZUtleTtcbmZ1bmN0aW9uIGNyZWF0ZVByaXZhdGVLZXlTeW5jKCkge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBwayA9IHJhbmRvbV8xLmdldFJhbmRvbUJ5dGVzU3luYyhTRUNQMjU2SzFfUFJJVkFURV9LRVlfU0laRSk7XG4gICAgICAgIGlmIChzZWNwMjU2azFfMS5wcml2YXRlS2V5VmVyaWZ5KHBrKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBrO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVQcml2YXRlS2V5U3luYyA9IGNyZWF0ZVByaXZhdGVLZXlTeW5jO1xuX19leHBvcnQocmVxdWlyZShcInNlY3AyNTZrMVwiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWNwMjU2azEuanMubWFwIl0sInByZUV4aXN0aW5nQ29tbWVudCI6Ii8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ5dGVzLmpzLm1hcCJ9
