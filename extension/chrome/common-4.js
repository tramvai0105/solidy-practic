LavaPack.loadBundle([
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\rlp\\dist.browser\\index.js", {"bn.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\rlp\\node_modules\\bn.js\\lib\\bn.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Crlp%5Cdist.browser%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLength = exports.decode = exports.encode = void 0;
var bn_js_1 = __importDefault(require("bn.js"));
/**
 * RLP Encoding based on: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP
 * This function takes in a data, convert it to buffer if not, and a length for recursion
 * @param input - will be converted to buffer
 * @returns returns buffer of encoded data
 **/
function encode(input) {
    if (Array.isArray(input)) {
        var output = [];
        for (var i = 0; i < input.length; i++) {
            output.push(encode(input[i]));
        }
        var buf = Buffer.concat(output);
        return Buffer.concat([encodeLength(buf.length, 192), buf]);
    }
    else {
        var inputBuf = toBuffer(input);
        return inputBuf.length === 1 && inputBuf[0] < 128
            ? inputBuf
            : Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf]);
    }
}
exports.encode = encode;
/**
 * Parse integers. Check if there is no leading zeros
 * @param v The value to parse
 * @param base The base to parse the integer into
 */
function safeParseInt(v, base) {
    if (v[0] === '0' && v[1] === '0') {
        throw new Error('invalid RLP: extra zeros');
    }
    return parseInt(v, base);
}
function encodeLength(len, offset) {
    if (len < 56) {
        return Buffer.from([len + offset]);
    }
    else {
        var hexLength = intToHex(len);
        var lLength = hexLength.length / 2;
        var firstByte = intToHex(offset + 55 + lLength);
        return Buffer.from(firstByte + hexLength, 'hex');
    }
}
function decode(input, stream) {
    if (stream === void 0) { stream = false; }
    if (!input || input.length === 0) {
        return Buffer.from([]);
    }
    var inputBuffer = toBuffer(input);
    var decoded = _decode(inputBuffer);
    if (stream) {
        return decoded;
    }
    if (decoded.remainder.length !== 0) {
        throw new Error('invalid remainder');
    }
    return decoded.data;
}
exports.decode = decode;
/**
 * Get the length of the RLP input
 * @param input
 * @returns The length of the input or an empty Buffer if no input
 */
function getLength(input) {
    if (!input || input.length === 0) {
        return Buffer.from([]);
    }
    var inputBuffer = toBuffer(input);
    var firstByte = inputBuffer[0];
    if (firstByte <= 0x7f) {
        return inputBuffer.length;
    }
    else if (firstByte <= 0xb7) {
        return firstByte - 0x7f;
    }
    else if (firstByte <= 0xbf) {
        return firstByte - 0xb6;
    }
    else if (firstByte <= 0xf7) {
        // a list between  0-55 bytes long
        return firstByte - 0xbf;
    }
    else {
        // a list  over 55 bytes long
        var llength = firstByte - 0xf6;
        var length_1 = safeParseInt(inputBuffer.slice(1, llength).toString('hex'), 16);
        return llength + length_1;
    }
}
exports.getLength = getLength;
/** Decode an input with RLP */
function _decode(input) {
    var length, llength, data, innerRemainder, d;
    var decoded = [];
    var firstByte = input[0];
    if (firstByte <= 0x7f) {
        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
        return {
            data: input.slice(0, 1),
            remainder: input.slice(1),
        };
    }
    else if (firstByte <= 0xb7) {
        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
        // The range of the first byte is [0x80, 0xb7]
        length = firstByte - 0x7f;
        // set 0x80 null to 0
        if (firstByte === 0x80) {
            data = Buffer.from([]);
        }
        else {
            data = input.slice(1, length);
        }
        if (length === 2 && data[0] < 0x80) {
            throw new Error('invalid rlp encoding: byte must be less 0x80');
        }
        return {
            data: data,
            remainder: input.slice(length),
        };
    }
    else if (firstByte <= 0xbf) {
        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),
        // followed by the length, followed by the string
        llength = firstByte - 0xb6;
        if (input.length - 1 < llength) {
            throw new Error('invalid RLP: not enough bytes for string length');
        }
        length = safeParseInt(input.slice(1, llength).toString('hex'), 16);
        if (length <= 55) {
            throw new Error('invalid RLP: expected string length to be greater than 55');
        }
        data = input.slice(llength, length + llength);
        if (data.length < length) {
            throw new Error('invalid RLP: not enough bytes for string');
        }
        return {
            data: data,
            remainder: input.slice(length + llength),
        };
    }
    else if (firstByte <= 0xf7) {
        // a list between  0-55 bytes long
        length = firstByte - 0xbf;
        innerRemainder = input.slice(1, length);
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(length),
        };
    }
    else {
        // a list  over 55 bytes long
        llength = firstByte - 0xf6;
        length = safeParseInt(input.slice(1, llength).toString('hex'), 16);
        var totalLength = llength + length;
        if (totalLength > input.length) {
            throw new Error('invalid rlp: total length is larger than the data');
        }
        innerRemainder = input.slice(llength, totalLength);
        if (innerRemainder.length === 0) {
            throw new Error('invalid rlp, List has a invalid length');
        }
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(totalLength),
        };
    }
}
/** Check if a string is prefixed by 0x */
function isHexPrefixed(str) {
    return str.slice(0, 2) === '0x';
}
/** Removes 0x from a given String */
function stripHexPrefix(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return isHexPrefixed(str) ? str.slice(2) : str;
}
/** Transform an integer into its hexadecimal value */
function intToHex(integer) {
    if (integer < 0) {
        throw new Error('Invalid integer as argument, must be unsigned!');
    }
    var hex = integer.toString(16);
    return hex.length % 2 ? "0" + hex : hex;
}
/** Pad a string to be even */
function padToEven(a) {
    return a.length % 2 ? "0" + a : a;
}
/** Transform an integer into a Buffer */
function intToBuffer(integer) {
    var hex = intToHex(integer);
    return Buffer.from(hex, 'hex');
}
/** Transform anything into a Buffer */
function toBuffer(v) {
    if (!Buffer.isBuffer(v)) {
        if (typeof v === 'string') {
            if (isHexPrefixed(v)) {
                return Buffer.from(padToEven(stripHexPrefix(v)), 'hex');
            }
            else {
                return Buffer.from(v);
            }
        }
        else if (typeof v === 'number' || typeof v === 'bigint') {
            if (!v) {
                return Buffer.from([]);
            }
            else {
                return intToBuffer(v);
            }
        }
        else if (v === null || v === undefined) {
            return Buffer.from([]);
        }
        else if (v instanceof Uint8Array) {
            return Buffer.from(v);
        }
        else if (bn_js_1.default.isBN(v)) {
            // converts a BN to a Buffer
            return Buffer.from(v.toArray());
        }
        else {
            throw new Error('invalid type');
        }
    }
    return v;
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"ethereumjs-util>rlp",file:"node_modules\\rlp\\dist.browser\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\rlp\\node_modules\\bn.js\\lib\\bn.js", {"buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Crlp%5Cnode_modules%5Cbn.js%5Clib%5Cbn.js
      return function (require, module, exports) {
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this._strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // '0' - '9'
    if (c >= 48 && c <= 57) {
      return c - 48;
    // 'A' - 'F'
    } else if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    } else {
      assert(false, 'Invalid character in ' + string);
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this._strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        b = c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        b = c - 17 + 0xa;

      // '0' - '9'
      } else {
        b = c;
      }
      assert(c >= 0 && b < mul, 'Invalid character');
      r += b;
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this._strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  function move (dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }

  BN.prototype._move = function _move (dest) {
    move(dest, this);
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype._strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  // Check Symbol.for because not everywhere where Symbol defined
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    try {
      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
      BN.prototype.inspect = inspect;
    }
  } else {
    BN.prototype.inspect = inspect;
  }

  function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  }

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16, 2);
  };

  if (Buffer) {
    BN.prototype.toBuffer = function toBuffer (endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    };
  }

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  var allocate = function allocate (ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    this._strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = (word >> 8) & 0xff;
      }
      if (position < res.length) {
        res[position++] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = (word >> 8) & 0xff;
      }
      if (position >= 0) {
        res[position--] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] >>> wbit) & 0x01;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this._strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this._strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this._strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this._strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this._strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this._strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out._strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out._strip();
  }

  function jumboMulTo (self, num, out) {
    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    // var fftm = new FFTM();
    // return fftm.mulp(self, num, out);
    return bigMulTo(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this._strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this._strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this._strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this._strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this._strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this._strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q._strip();
    }
    a._strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modrn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modrn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modrn = function modrn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return isNegNum ? -acc : acc;
  };

  // WARNING: DEPRECATED
  BN.prototype.modn = function modn (num) {
    return this.modrn(num);
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    this._strip();
    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this._strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is a BN v4 instance
        r.strip();
      } else {
        // r is a BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

    move(a, a.umod(this.m)._forceRed(this));
    return a;
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

      };
    };
  }
  }
}, {package:"ethereumjs-util>rlp>bn.js",file:"node_modules\\rlp\\node_modules\\bn.js\\lib\\bn.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\safe-buffer\\index.js", {"buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csafe-buffer%5Cindex.js
      return function (require, module, exports) {
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

      };
    };
  }
  }
}, {package:"ethereumjs-wallet>safe-buffer",file:"node_modules\\safe-buffer\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\safe-event-emitter\\index.js", {"events/":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\events\\events.js","util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\util\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csafe-event-emitter%5Cindex.js
      return function (require, module, exports) {
const util = require('util')
const EventEmitter = require('events/')

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
}

module.exports = SafeEventEmitter


function SafeEventEmitter() {
  EventEmitter.call(this)
}

util.inherits(SafeEventEmitter, EventEmitter)

SafeEventEmitter.prototype.emit = function (type) {
  // copied from https://github.com/Gozala/events/blob/master/events.js
  // modified lines are commented with "edited:"
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    // edited: using safeApply
    safeApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      // edited: using safeApply
      safeApply(listeners[i], this, args);
  }

  return true;
}

function safeApply(handler, context, args) {
  try {
    ReflectApply(handler, context, args)
  } catch (err) {
    // throw error after timeout so as not to interupt the stack
    setTimeout(() => {
      throw err
    })
  }
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

      };
    };
  }
  }
}, {package:"@metamask/eth-token-tracker>safe-event-emitter",file:"node_modules\\safe-event-emitter\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\secp256k1\\elliptic.js", {"./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\secp256k1\\lib\\index.js","./lib/elliptic":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\secp256k1\\lib\\elliptic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csecp256k1%5Celliptic.js
      return function (require, module, exports) {
module.exports = require('./lib')(require('./lib/elliptic'))

      };
    };
  }
  }
}, {package:"ethereumjs-util>ethereum-cryptography>secp256k1",file:"node_modules\\secp256k1\\elliptic.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\secp256k1\\lib\\elliptic.js", {"elliptic":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\elliptic\\lib\\elliptic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csecp256k1%5Clib%5Celliptic.js
      return function (require, module, exports) {
const EC = require('elliptic').ec

const ec = new EC('secp256k1')
const ecparams = ec.curve

// Hack, we can not use bn.js@5, while elliptic uses bn.js@4
// See https://github.com/indutny/elliptic/issues/191#issuecomment-569888758
const BN = ecparams.n.constructor

function loadCompressedPublicKey (first, xbuf) {
  let x = new BN(xbuf)

  // overflow
  if (x.cmp(ecparams.p) >= 0) return null
  x = x.toRed(ecparams.red)

  // compute corresponding Y
  let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt()
  if ((first === 0x03) !== y.isOdd()) y = y.redNeg()

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadUncompressedPublicKey (first, xbuf, ybuf) {
  let x = new BN(xbuf)
  let y = new BN(ybuf)

  // overflow
  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null

  x = x.toRed(ecparams.red)
  y = y.toRed(ecparams.red)

  // is odd flag
  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null

  // x*x*x + b = y*y
  const x3 = x.redSqr().redIMul(x)
  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadPublicKey (pubkey) {
  // length should be validated in interface
  const first = pubkey[0]
  switch (first) {
    case 0x02:
    case 0x03:
      if (pubkey.length !== 33) return null
      return loadCompressedPublicKey(first, pubkey.subarray(1, 33))
    case 0x04:
    case 0x06:
    case 0x07:
      if (pubkey.length !== 65) return null
      return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65))
    default:
      return null
  }
}

function savePublicKey (output, point) {
  const pubkey = point.encode(null, output.length === 33)
  // Loop should be faster because we do not need create extra Uint8Array
  // output.set(new Uint8Array(pubkey))
  for (let i = 0; i < output.length; ++i) output[i] = pubkey[i]
}

module.exports = {
  contextRandomize () {
    return 0
  },

  privateKeyVerify (seckey) {
    const bn = new BN(seckey)
    return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1
  },

  privateKeyNegate (seckey) {
    const bn = new BN(seckey)
    const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, 'be', 32)
    seckey.set(negate)
    return 0
  },

  privateKeyTweakAdd (seckey, tweak) {
    const bn = new BN(tweak)
    if (bn.cmp(ecparams.n) >= 0) return 1

    bn.iadd(new BN(seckey))
    if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n)
    if (bn.isZero()) return 1

    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32)
    seckey.set(tweaked)

    return 0
  },

  privateKeyTweakMul (seckey, tweak) {
    let bn = new BN(tweak)
    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1

    bn.imul(new BN(seckey))
    if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n)

    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32)
    seckey.set(tweaked)

    return 0
  },

  publicKeyVerify (pubkey) {
    const pair = loadPublicKey(pubkey)
    return pair === null ? 1 : 0
  },

  publicKeyCreate (output, seckey) {
    const bn = new BN(seckey)
    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1

    const point = ec.keyFromPrivate(seckey).getPublic()
    savePublicKey(output, point)

    return 0
  },

  publicKeyConvert (output, pubkey) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    const point = pair.getPublic()
    savePublicKey(output, point)

    return 0
  },

  publicKeyNegate (output, pubkey) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    const point = pair.getPublic()
    point.y = point.y.redNeg()
    savePublicKey(output, point)

    return 0
  },

  publicKeyCombine (output, pubkeys) {
    const pairs = new Array(pubkeys.length)
    for (let i = 0; i < pubkeys.length; ++i) {
      pairs[i] = loadPublicKey(pubkeys[i])
      if (pairs[i] === null) return 1
    }

    let point = pairs[0].getPublic()
    for (let i = 1; i < pairs.length; ++i) point = point.add(pairs[i].pub)
    if (point.isInfinity()) return 2

    savePublicKey(output, point)

    return 0
  },

  publicKeyTweakAdd (output, pubkey, tweak) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    tweak = new BN(tweak)
    if (tweak.cmp(ecparams.n) >= 0) return 2

    const point = pair.getPublic().add(ecparams.g.mul(tweak))
    if (point.isInfinity()) return 2

    savePublicKey(output, point)

    return 0
  },

  publicKeyTweakMul (output, pubkey, tweak) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    tweak = new BN(tweak)
    if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2

    const point = pair.getPublic().mul(tweak)
    savePublicKey(output, point)

    return 0
  },

  signatureNormalize (sig) {
    const r = new BN(sig.subarray(0, 32))
    const s = new BN(sig.subarray(32, 64))
    if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1

    if (s.cmp(ec.nh) === 1) {
      sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, 'be', 32), 32)
    }

    return 0
  },

  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
  // Adapted for Uint8Array instead Buffer
  signatureExport (obj, sig) {
    const sigR = sig.subarray(0, 32)
    const sigS = sig.subarray(32, 64)
    if (new BN(sigR).cmp(ecparams.n) >= 0) return 1
    if (new BN(sigS).cmp(ecparams.n) >= 0) return 1

    const { output } = obj

    // Prepare R
    let r = output.subarray(4, 4 + 33)
    r[0] = 0x00
    r.set(sigR, 1)

    let lenR = 33
    let posR = 0
    for (; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);

    r = r.subarray(posR)
    if (r[0] & 0x80) return 1
    if (lenR > 1 && (r[0] === 0x00) && !(r[1] & 0x80)) return 1

    // Prepare S
    let s = output.subarray(6 + 33, 6 + 33 + 33)
    s[0] = 0x00
    s.set(sigS, 1)

    let lenS = 33
    let posS = 0
    for (; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);

    s = s.subarray(posS)
    if (s[0] & 0x80) return 1
    if (lenS > 1 && (s[0] === 0x00) && !(s[1] & 0x80)) return 1

    // Set output length for return
    obj.outputlen = 6 + lenR + lenS

    // Output in specified format
    // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
    output[0] = 0x30
    output[1] = obj.outputlen - 2
    output[2] = 0x02
    output[3] = r.length
    output.set(r, 4)
    output[4 + lenR] = 0x02
    output[5 + lenR] = s.length
    output.set(s, 6 + lenR)

    return 0
  },

  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
  // Adapted for Uint8Array instead Buffer
  signatureImport (output, sig) {
    if (sig.length < 8) return 1
    if (sig.length > 72) return 1
    if (sig[0] !== 0x30) return 1
    if (sig[1] !== sig.length - 2) return 1
    if (sig[2] !== 0x02) return 1

    const lenR = sig[3]
    if (lenR === 0) return 1
    if (5 + lenR >= sig.length) return 1
    if (sig[4 + lenR] !== 0x02) return 1

    const lenS = sig[5 + lenR]
    if (lenS === 0) return 1
    if ((6 + lenR + lenS) !== sig.length) return 1

    if (sig[4] & 0x80) return 1
    if (lenR > 1 && (sig[4] === 0x00) && !(sig[5] & 0x80)) return 1

    if (sig[lenR + 6] & 0x80) return 1
    if (lenS > 1 && (sig[lenR + 6] === 0x00) && !(sig[lenR + 7] & 0x80)) return 1

    let sigR = sig.subarray(4, 4 + lenR)
    if (sigR.length === 33 && sigR[0] === 0x00) sigR = sigR.subarray(1)
    if (sigR.length > 32) return 1

    let sigS = sig.subarray(6 + lenR)
    if (sigS.length === 33 && sigS[0] === 0x00) sigS = sigS.slice(1)
    if (sigS.length > 32) throw new Error('S length is too long')

    let r = new BN(sigR)
    if (r.cmp(ecparams.n) >= 0) r = new BN(0)

    let s = new BN(sig.subarray(6 + lenR))
    if (s.cmp(ecparams.n) >= 0) s = new BN(0)

    output.set(r.toArrayLike(Uint8Array, 'be', 32), 0)
    output.set(s.toArrayLike(Uint8Array, 'be', 32), 32)

    return 0
  },

  ecdsaSign (obj, message, seckey, data, noncefn) {
    if (noncefn) {
      const _noncefn = noncefn
      noncefn = (counter) => {
        const nonce = _noncefn(message, seckey, null, data, counter)

        const isValid = nonce instanceof Uint8Array && nonce.length === 32
        if (!isValid) throw new Error('This is the way')

        return new BN(nonce)
      }
    }

    const d = new BN(seckey)
    if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1

    let sig
    try {
      sig = ec.sign(message, seckey, { canonical: true, k: noncefn, pers: data })
    } catch (err) {
      return 1
    }

    obj.signature.set(sig.r.toArrayLike(Uint8Array, 'be', 32), 0)
    obj.signature.set(sig.s.toArrayLike(Uint8Array, 'be', 32), 32)
    obj.recid = sig.recoveryParam

    return 0
  },

  ecdsaVerify (sig, msg32, pubkey) {
    const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) }

    const sigr = new BN(sigObj.r)
    const sigs = new BN(sigObj.s)
    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1
    if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3

    const pair = loadPublicKey(pubkey)
    if (pair === null) return 2

    const point = pair.getPublic()
    const isValid = ec.verify(msg32, sigObj, point)
    return isValid ? 0 : 3
  },

  ecdsaRecover (output, sig, recid, msg32) {
    const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) }

    const sigr = new BN(sigObj.r)
    const sigs = new BN(sigObj.s)
    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1

    if (sigr.isZero() || sigs.isZero()) return 2

    // Can throw `throw new Error('Unable to find sencond key candinate');`
    let point
    try {
      point = ec.recoverPubKey(msg32, sigObj, recid)
    } catch (err) {
      return 2
    }

    savePublicKey(output, point)

    return 0
  },

  ecdh (output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    const scalar = new BN(seckey)
    if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2

    const point = pair.getPublic().mul(scalar)

    if (hashfn === undefined) {
      const data = point.encode(null, true)
      const sha256 = ec.hash().update(data).digest()
      for (let i = 0; i < 32; ++i) output[i] = sha256[i]
    } else {
      if (!xbuf) xbuf = new Uint8Array(32)
      const x = point.getX().toArray('be', 32)
      for (let i = 0; i < 32; ++i) xbuf[i] = x[i]

      if (!ybuf) ybuf = new Uint8Array(32)
      const y = point.getY().toArray('be', 32)
      for (let i = 0; i < 32; ++i) ybuf[i] = y[i]

      const hash = hashfn(xbuf, ybuf, data)

      const isValid = hash instanceof Uint8Array && hash.length === output.length
      if (!isValid) return 2

      output.set(hash)
    }

    return 0
  }
}

      };
    };
  }
  }
}, {package:"ethereumjs-util>ethereum-cryptography>secp256k1",file:"node_modules\\secp256k1\\lib\\elliptic.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\secp256k1\\lib\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csecp256k1%5Clib%5Cindex.js
      return function (require, module, exports) {
const errors = {
  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',
  TWEAK_ADD:
    'The tweak was out of range or the resulted private key is invalid',
  TWEAK_MUL: 'The tweak was out of range or equal to zero',
  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',
  SECKEY_INVALID: 'Private Key is invalid',
  PUBKEY_PARSE: 'Public Key could not be parsed',
  PUBKEY_SERIALIZE: 'Public Key serialization error',
  PUBKEY_COMBINE: 'The sum of the public keys is not valid',
  SIG_PARSE: 'Signature could not be parsed',
  SIGN: 'The nonce generation function failed, or the private key was invalid',
  RECOVER: 'Public key could not be recover',
  ECDH: 'Scalar was invalid (zero or overflow)'
}

function assert (cond, msg) {
  if (!cond) throw new Error(msg)
}

function isUint8Array (name, value, length) {
  assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`)

  if (length !== undefined) {
    if (Array.isArray(length)) {
      const numbers = length.join(', ')
      const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`
      assert(length.includes(value.length), msg)
    } else {
      const msg = `Expected ${name} to be an Uint8Array with length ${length}`
      assert(value.length === length, msg)
    }
  }
}

function isCompressed (value) {
  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean')
}

function getAssertedOutput (output = (len) => new Uint8Array(len), length) {
  if (typeof output === 'function') output = output(length)
  isUint8Array('output', output, length)
  return output
}

function toTypeString (value) {
  return Object.prototype.toString.call(value).slice(8, -1)
}

module.exports = (secp256k1) => {
  return {
    contextRandomize (seed) {
      assert(
        seed === null || seed instanceof Uint8Array,
        'Expected seed to be an Uint8Array or null'
      )
      if (seed !== null) isUint8Array('seed', seed, 32)

      switch (secp256k1.contextRandomize(seed)) {
        case 1:
          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW)
      }
    },

    privateKeyVerify (seckey) {
      isUint8Array('private key', seckey, 32)

      return secp256k1.privateKeyVerify(seckey) === 0
    },

    privateKeyNegate (seckey) {
      isUint8Array('private key', seckey, 32)

      switch (secp256k1.privateKeyNegate(seckey)) {
        case 0:
          return seckey
        case 1:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    privateKeyTweakAdd (seckey, tweak) {
      isUint8Array('private key', seckey, 32)
      isUint8Array('tweak', tweak, 32)

      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
        case 0:
          return seckey
        case 1:
          throw new Error(errors.TWEAK_ADD)
      }
    },

    privateKeyTweakMul (seckey, tweak) {
      isUint8Array('private key', seckey, 32)
      isUint8Array('tweak', tweak, 32)

      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
        case 0:
          return seckey
        case 1:
          throw new Error(errors.TWEAK_MUL)
      }
    },

    publicKeyVerify (pubkey) {
      isUint8Array('public key', pubkey, [33, 65])

      return secp256k1.publicKeyVerify(pubkey) === 0
    },

    publicKeyCreate (seckey, compressed = true, output) {
      isUint8Array('private key', seckey, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyCreate(output, seckey)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.SECKEY_INVALID)
        case 2:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyConvert (pubkey, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyConvert(output, pubkey)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyNegate (pubkey, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyNegate(output, pubkey)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
        case 3:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyCombine (pubkeys, compressed = true, output) {
      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array')
      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items')
      for (const pubkey of pubkeys) {
        isUint8Array('public key', pubkey, [33, 65])
      }
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyCombine(output, pubkeys)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.PUBKEY_COMBINE)
        case 3:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyTweakAdd (pubkey, tweak, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isUint8Array('tweak', tweak, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.TWEAK_ADD)
      }
    },

    publicKeyTweakMul (pubkey, tweak, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isUint8Array('tweak', tweak, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.TWEAK_MUL)
      }
    },

    signatureNormalize (sig) {
      isUint8Array('signature', sig, 64)

      switch (secp256k1.signatureNormalize(sig)) {
        case 0:
          return sig
        case 1:
          throw new Error(errors.SIG_PARSE)
      }
    },

    signatureExport (sig, output) {
      isUint8Array('signature', sig, 64)
      output = getAssertedOutput(output, 72)

      const obj = { output, outputlen: 72 }
      switch (secp256k1.signatureExport(obj, sig)) {
        case 0:
          return output.slice(0, obj.outputlen)
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    signatureImport (sig, output) {
      isUint8Array('signature', sig)
      output = getAssertedOutput(output, 64)

      switch (secp256k1.signatureImport(output, sig)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    ecdsaSign (msg32, seckey, options = {}, output) {
      isUint8Array('message', msg32, 32)
      isUint8Array('private key', seckey, 32)
      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')
      if (options.data !== undefined) isUint8Array('options.data', options.data)
      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function')
      output = getAssertedOutput(output, 64)

      const obj = { signature: output, recid: null }
      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
        case 0:
          return obj
        case 1:
          throw new Error(errors.SIGN)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    ecdsaVerify (sig, msg32, pubkey) {
      isUint8Array('signature', sig, 64)
      isUint8Array('message', msg32, 32)
      isUint8Array('public key', pubkey, [33, 65])

      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
        case 0:
          return true
        case 3:
          return false
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.PUBKEY_PARSE)
      }
    },

    ecdsaRecover (sig, recid, msg32, compressed = true, output) {
      isUint8Array('signature', sig, 64)
      assert(
        toTypeString(recid) === 'Number' &&
          recid >= 0 &&
          recid <= 3,
        'Expected recovery id to be a Number within interval [0, 3]'
      )
      isUint8Array('message', msg32, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.RECOVER)
        case 3:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    ecdh (pubkey, seckey, options = {}, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isUint8Array('private key', seckey, 32)
      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')
      if (options.data !== undefined) isUint8Array('options.data', options.data)
      if (options.hashfn !== undefined) {
        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function')
        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32)
        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32)
        isUint8Array('output', output)
      } else {
        output = getAssertedOutput(output, 32)
      }

      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.ECDH)
      }
    }
  }
}

      };
    };
  }
  }
}, {package:"ethereumjs-util>ethereum-cryptography>secp256k1",file:"node_modules\\secp256k1\\lib\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\comparator.js", {"../functions/cmp":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\cmp.js","../internal/debug":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\debug.js","../internal/parse-options":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\parse-options.js","../internal/re":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\re.js","./range":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\range.js","./semver":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cclasses%5Ccomparator.js
      return function (require, module, exports) {
const ANY = Symbol('SemVer ANY')
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }

  constructor (comp, options) {
    options = parseOptions(options)

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const m = comp.match(r)

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new Range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new Range(this.value, options).test(comp.semver)
    }

    options = parseOptions(options)

    // Special cases where nothing can possibly be lower
    if (options.includePrerelease &&
      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
      return false
    }
    if (!options.includePrerelease &&
      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
      return false
    }

    // Same direction increasing (> or >=)
    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
      return true
    }
    // Same direction decreasing (< or <=)
    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
      return true
    }
    // same SemVer and both sides are inclusive (<= or >=)
    if (
      (this.semver.version === comp.semver.version) &&
      this.operator.includes('=') && comp.operator.includes('=')) {
      return true
    }
    // opposite directions less than
    if (cmp(this.semver, '<', comp.semver, options) &&
      this.operator.startsWith('>') && comp.operator.startsWith('<')) {
      return true
    }
    // opposite directions greater than
    if (cmp(this.semver, '>', comp.semver, options) &&
      this.operator.startsWith('<') && comp.operator.startsWith('>')) {
      return true
    }
    return false
  }
}

module.exports = Comparator

const parseOptions = require('../internal/parse-options')
const { re, t } = require('../internal/re')
const cmp = require('../functions/cmp')
const debug = require('../internal/debug')
const SemVer = require('./semver')
const Range = require('./range')

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\classes\\comparator.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\range.js", {"../internal/constants":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\constants.js","../internal/debug":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\debug.js","../internal/parse-options":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\parse-options.js","../internal/re":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\re.js","./comparator":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\comparator.js","./semver":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\semver.js","lru-cache":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lru-cache\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cclasses%5Crange.js
      return function (require, module, exports) {
// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    options = parseOptions(options)

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.format()
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First, split based on boolean or ||
    this.raw = range
    this.set = range
      .split('||')
      // map the range to a 2d array of comparators
      .map(r => this.parseRange(r.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range}`)
    }

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      const first = this.set[0]
      this.set = this.set.filter(c => !isNullSet(c[0]))
      if (this.set.length === 0) {
        this.set = [first]
      } else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c]
            break
          }
        }
      }
    }

    this.format()
  }

  format () {
    this.range = this.set
      .map((comps) => {
        return comps.join(' ').trim()
      })
      .join('||')
      .trim()
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    range = range.trim()

    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts =
      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
      (this.options.loose && FLAG_LOOSE)
    const memoKey = memoOpts + ':' + range
    const cached = cache.get(memoKey)
    if (cached) {
      return cached
    }

    const loose = this.options.loose
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range)

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)

    // normalize spaces
    range = range.split(/\s+/).join(' ')

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    let rangeList = range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(comp => replaceGTE0(comp, this.options))

    if (loose) {
      // in loose mode, throw out any that are not valid comparators
      rangeList = rangeList.filter(comp => {
        debug('loose invalid filter', comp, this.options)
        return !!comp.match(re[t.COMPARATORLOOSE])
      })
    }
    debug('range list', rangeList)

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once
    const rangeMap = new Map()
    const comparators = rangeList.map(comp => new Comparator(comp, this.options))
    for (const comp of comparators) {
      if (isNullSet(comp)) {
        return [comp]
      }
      rangeMap.set(comp.value, comp)
    }
    if (rangeMap.size > 1 && rangeMap.has('')) {
      rangeMap.delete('')
    }

    const result = [...rangeMap.values()]
    cache.set(memoKey, result)
    return result
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}

module.exports = Range

const LRU = require('lru-cache')
const cache = new LRU({ max: 1000 })

const parseOptions = require('../internal/parse-options')
const Comparator = require('./comparator')
const debug = require('../internal/debug')
const SemVer = require('./semver')
const {
  re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace,
} = require('../internal/re')
const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require('../internal/constants')

const isNullSet = c => c.value === '<0.0.0-0'
const isAny = c => c.value === ''

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> -- > * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x -- > >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x -- > >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x -- > >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 -- > >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 -- > >=1.2.0 <1.3.0-0
// ~0.0.1 -- > >=0.0.1 <0.1.0-0
const replaceTildes = (comp, options) =>
  comp.trim().split(/\s+/).map((c) => {
    return replaceTilde(c, options)
  }).join(' ')

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ -- > * (any, kinda silly)
// ^2, ^2.x, ^2.x.x -- > >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x -- > >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x -- > >=1.2.0 <2.0.0-0
// ^1.2.3 -- > >=1.2.3 <2.0.0-0
// ^1.2.0 -- > >=1.2.0 <2.0.0-0
// ^0.0.1 -- > >=0.0.1 <0.0.2-0
// ^0.1.0 -- > >=0.1.0 <0.2.0-0
const replaceCarets = (comp, options) =>
  comp.trim().split(/\s+/).map((c) => {
    return replaceCaret(c, options)
  }).join(' ')

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map((c) => {
    return replaceXRange(c, options)
  }).join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === '<') {
        pr = '-0'
      }

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => {
  debug('replaceGTE0', comp, options)
  return comp.trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
  } else if (fpr) {
    from = `>=${from}`
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `<=${to}`
  }

  return (`${from} ${to}`).trim()
}

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\classes\\range.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\semver.js", {"../internal/constants":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\constants.js","../internal/debug":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\debug.js","../internal/identifiers":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\identifiers.js","../internal/parse-options":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\parse-options.js","../internal/re":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\re.js","util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\util\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cclasses%5Csemver.js
      return function (require, module, exports) {
const debug = require('../internal/debug')
const { MAX_LENGTH, MAX_SAFE_INTEGER } = require('../internal/constants')
const { re, t } = require('../internal/re')

const parseOptions = require('../internal/parse-options')
const { compareIdentifiers } = require('../internal/identifiers')
class SemVer {
  constructor (version, options) {
    options = parseOptions(options)

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid Version: ${require('util').inspect(version)}`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier, identifierBase) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier, identifierBase)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier, identifierBase)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier, identifierBase)
        this.inc('pre', identifier, identifierBase)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier, identifierBase)
        }
        this.inc('pre', identifier, identifierBase)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre': {
        const base = Number(identifierBase) ? 1 : 0

        if (!identifier && identifierBase === false) {
          throw new Error('invalid increment argument: identifier is empty')
        }

        if (this.prerelease.length === 0) {
          this.prerelease = [base]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            if (identifier === this.prerelease.join('.') && identifierBase === false) {
              throw new Error('invalid increment argument: identifier already exists')
            }
            this.prerelease.push(base)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          let prerelease = [identifier, base]
          if (identifierBase === false) {
            prerelease = [identifier]
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease
            }
          } else {
            this.prerelease = prerelease
          }
        }
        break
      }
      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.format()
    this.raw = this.version
    return this
  }
}

module.exports = SemVer

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\classes\\semver.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\clean.js", {"./parse":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\parse.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Cclean.js
      return function (require, module, exports) {
const parse = require('./parse')
const clean = (version, options) => {
  const s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}
module.exports = clean

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\clean.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\cmp.js", {"./eq":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\eq.js","./gt":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\gt.js","./gte":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\gte.js","./lt":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\lt.js","./lte":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\lte.js","./neq":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\neq.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Ccmp.js
      return function (require, module, exports) {
const eq = require('./eq')
const neq = require('./neq')
const gt = require('./gt')
const gte = require('./gte')
const lt = require('./lt')
const lte = require('./lte')

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a === b

    case '!==':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
module.exports = cmp

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\cmp.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\coerce.js", {"../classes/semver":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\semver.js","../internal/re":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\re.js","./parse":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\parse.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Ccoerce.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const parse = require('./parse')
const { re, t } = require('../internal/re')

const coerce = (version, options) => {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  let match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next
    while ((next = re[t.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null) {
    return null
  }

  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
}
module.exports = coerce

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\coerce.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\compare-build.js", {"../classes/semver":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Ccompare-build.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const compareBuild = (a, b, loose) => {
  const versionA = new SemVer(a, loose)
  const versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}
module.exports = compareBuild

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\compare-build.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\compare-loose.js", {"./compare":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Ccompare-loose.js
      return function (require, module, exports) {
const compare = require('./compare')
const compareLoose = (a, b) => compare(a, b, true)
module.exports = compareLoose

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\compare-loose.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\compare.js", {"../classes/semver":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Ccompare.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\compare.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\diff.js", {"./parse.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\parse.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Cdiff.js
      return function (require, module, exports) {
const parse = require('./parse.js')

const diff = (version1, version2) => {
  const v1 = parse(version1, null, true)
  const v2 = parse(version2, null, true)
  const comparison = v1.compare(v2)

  if (comparison === 0) {
    return null
  }

  const v1Higher = comparison > 0
  const highVersion = v1Higher ? v1 : v2
  const lowVersion = v1Higher ? v2 : v1
  const highHasPre = !!highVersion.prerelease.length

  // add the `pre` prefix if we are going to a prerelease version
  const prefix = highHasPre ? 'pre' : ''

  if (v1.major !== v2.major) {
    return prefix + 'major'
  }

  if (v1.minor !== v2.minor) {
    return prefix + 'minor'
  }

  if (v1.patch !== v2.patch) {
    return prefix + 'patch'
  }

  // at this point we know stable versions match but overall versions are not equal,
  // so either they are both prereleases, or the lower version is a prerelease

  if (highHasPre) {
    // high and low are preleases
    return 'prerelease'
  }

  if (lowVersion.patch) {
    // anything higher than a patch bump would result in the wrong version
    return 'patch'
  }

  if (lowVersion.minor) {
    // anything higher than a minor bump would result in the wrong version
    return 'minor'
  }

  // bumping major/minor/patch all have same result
  return 'major'
}

module.exports = diff

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\diff.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\eq.js", {"./compare":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Ceq.js
      return function (require, module, exports) {
const compare = require('./compare')
const eq = (a, b, loose) => compare(a, b, loose) === 0
module.exports = eq

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\eq.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\gt.js", {"./compare":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Cgt.js
      return function (require, module, exports) {
const compare = require('./compare')
const gt = (a, b, loose) => compare(a, b, loose) > 0
module.exports = gt

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\gt.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\gte.js", {"./compare":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Cgte.js
      return function (require, module, exports) {
const compare = require('./compare')
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\gte.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\inc.js", {"../classes/semver":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Cinc.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')

const inc = (version, release, options, identifier, identifierBase) => {
  if (typeof (options) === 'string') {
    identifierBase = identifier
    identifier = options
    options = undefined
  }

  try {
    return new SemVer(
      version instanceof SemVer ? version.version : version,
      options
    ).inc(release, identifier, identifierBase).version
  } catch (er) {
    return null
  }
}
module.exports = inc

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\inc.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\lt.js", {"./compare":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Clt.js
      return function (require, module, exports) {
const compare = require('./compare')
const lt = (a, b, loose) => compare(a, b, loose) < 0
module.exports = lt

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\lt.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\lte.js", {"./compare":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Clte.js
      return function (require, module, exports) {
const compare = require('./compare')
const lte = (a, b, loose) => compare(a, b, loose) <= 0
module.exports = lte

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\lte.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\major.js", {"../classes/semver":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Cmajor.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const major = (a, loose) => new SemVer(a, loose).major
module.exports = major

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\major.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\minor.js", {"../classes/semver":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Cminor.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const minor = (a, loose) => new SemVer(a, loose).minor
module.exports = minor

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\minor.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\neq.js", {"./compare":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Cneq.js
      return function (require, module, exports) {
const compare = require('./compare')
const neq = (a, b, loose) => compare(a, b, loose) !== 0
module.exports = neq

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\neq.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\parse.js", {"../classes/semver":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Cparse.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const parse = (version, options, throwErrors = false) => {
  if (version instanceof SemVer) {
    return version
  }
  try {
    return new SemVer(version, options)
  } catch (er) {
    if (!throwErrors) {
      return null
    }
    throw er
  }
}

module.exports = parse

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\parse.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\patch.js", {"../classes/semver":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Cpatch.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const patch = (a, loose) => new SemVer(a, loose).patch
module.exports = patch

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\patch.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\prerelease.js", {"./parse":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\parse.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Cprerelease.js
      return function (require, module, exports) {
const parse = require('./parse')
const prerelease = (version, options) => {
  const parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}
module.exports = prerelease

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\prerelease.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\rcompare.js", {"./compare":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Crcompare.js
      return function (require, module, exports) {
const compare = require('./compare')
const rcompare = (a, b, loose) => compare(b, a, loose)
module.exports = rcompare

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\rcompare.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\rsort.js", {"./compare-build":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\compare-build.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Crsort.js
      return function (require, module, exports) {
const compareBuild = require('./compare-build')
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))
module.exports = rsort

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\rsort.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\satisfies.js", {"../classes/range":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\range.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Csatisfies.js
      return function (require, module, exports) {
const Range = require('../classes/range')
const satisfies = (version, range, options) => {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}
module.exports = satisfies

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\satisfies.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\sort.js", {"./compare-build":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\compare-build.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Csort.js
      return function (require, module, exports) {
const compareBuild = require('./compare-build')
const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))
module.exports = sort

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\sort.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\valid.js", {"./parse":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\parse.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cfunctions%5Cvalid.js
      return function (require, module, exports) {
const parse = require('./parse')
const valid = (version, options) => {
  const v = parse(version, options)
  return v ? v.version : null
}
module.exports = valid

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\valid.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\index.js", {"./classes/comparator":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\comparator.js","./classes/range":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\range.js","./classes/semver":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\semver.js","./functions/clean":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\clean.js","./functions/cmp":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\cmp.js","./functions/coerce":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\coerce.js","./functions/compare":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\compare.js","./functions/compare-build":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\compare-build.js","./functions/compare-loose":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\compare-loose.js","./functions/diff":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\diff.js","./functions/eq":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\eq.js","./functions/gt":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\gt.js","./functions/gte":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\gte.js","./functions/inc":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\inc.js","./functions/lt":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\lt.js","./functions/lte":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\lte.js","./functions/major":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\major.js","./functions/minor":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\minor.js","./functions/neq":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\neq.js","./functions/parse":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\parse.js","./functions/patch":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\patch.js","./functions/prerelease":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\prerelease.js","./functions/rcompare":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\rcompare.js","./functions/rsort":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\rsort.js","./functions/satisfies":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\satisfies.js","./functions/sort":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\sort.js","./functions/valid":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\valid.js","./internal/constants":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\constants.js","./internal/identifiers":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\identifiers.js","./internal/re":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\re.js","./ranges/gtr":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\gtr.js","./ranges/intersects":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\intersects.js","./ranges/ltr":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\ltr.js","./ranges/max-satisfying":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\max-satisfying.js","./ranges/min-satisfying":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\min-satisfying.js","./ranges/min-version":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\min-version.js","./ranges/outside":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\outside.js","./ranges/simplify":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\simplify.js","./ranges/subset":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\subset.js","./ranges/to-comparators":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\to-comparators.js","./ranges/valid":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\valid.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cindex.js
      return function (require, module, exports) {
// just pre-load all the stuff that index.js lazily exports
const internalRe = require('./internal/re')
const constants = require('./internal/constants')
const SemVer = require('./classes/semver')
const identifiers = require('./internal/identifiers')
const parse = require('./functions/parse')
const valid = require('./functions/valid')
const clean = require('./functions/clean')
const inc = require('./functions/inc')
const diff = require('./functions/diff')
const major = require('./functions/major')
const minor = require('./functions/minor')
const patch = require('./functions/patch')
const prerelease = require('./functions/prerelease')
const compare = require('./functions/compare')
const rcompare = require('./functions/rcompare')
const compareLoose = require('./functions/compare-loose')
const compareBuild = require('./functions/compare-build')
const sort = require('./functions/sort')
const rsort = require('./functions/rsort')
const gt = require('./functions/gt')
const lt = require('./functions/lt')
const eq = require('./functions/eq')
const neq = require('./functions/neq')
const gte = require('./functions/gte')
const lte = require('./functions/lte')
const cmp = require('./functions/cmp')
const coerce = require('./functions/coerce')
const Comparator = require('./classes/comparator')
const Range = require('./classes/range')
const satisfies = require('./functions/satisfies')
const toComparators = require('./ranges/to-comparators')
const maxSatisfying = require('./ranges/max-satisfying')
const minSatisfying = require('./ranges/min-satisfying')
const minVersion = require('./ranges/min-version')
const validRange = require('./ranges/valid')
const outside = require('./ranges/outside')
const gtr = require('./ranges/gtr')
const ltr = require('./ranges/ltr')
const intersects = require('./ranges/intersects')
const simplifyRange = require('./ranges/simplify')
const subset = require('./ranges/subset')
module.exports = {
  parse,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
}

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\constants.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cinternal%5Cconstants.js
      return function (require, module, exports) {
// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

const RELEASE_TYPES = [
  'major',
  'premajor',
  'minor',
  'preminor',
  'patch',
  'prepatch',
  'prerelease',
]

module.exports = {
  MAX_LENGTH,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_INTEGER,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 0b001,
  FLAG_LOOSE: 0b010,
}

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\internal\\constants.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\debug.js", {"_process":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\process\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cinternal%5Cdebug.js
      return function (require, module, exports) {
(function (process){(function (){
const debug = (
  typeof process === 'object' &&
  process.env &&
  "" &&
  /\bsemver\b/i.test("")
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug

}).call(this)}).call(this,require('_process'))

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\internal\\debug.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\identifiers.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cinternal%5Cidentifiers.js
      return function (require, module, exports) {
const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers,
}

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\internal\\identifiers.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\parse-options.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cinternal%5Cparse-options.js
      return function (require, module, exports) {
// parse out just the options we care about
const looseOption = Object.freeze({ loose: true })
const emptyOpts = Object.freeze({ })
const parseOptions = options => {
  if (!options) {
    return emptyOpts
  }

  if (typeof options !== 'object') {
    return looseOption
  }

  return options
}
module.exports = parseOptions

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\internal\\parse-options.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\re.js", {"./constants":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\constants.js","./debug":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\internal\\debug.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cinternal%5Cre.js
      return function (require, module, exports) {
const { MAX_SAFE_COMPONENT_LENGTH } = require('./constants')
const debug = require('./debug')
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const src = exports.src = []
const t = exports.t = {}
let R = 0

const createToken = (name, value, isGlobal) => {
  const index = R++
  debug(name, index, value)
  t[name] = index
  src[index] = value
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*')

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCE', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$')

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\internal\\re.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\gtr.js", {"./outside":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\outside.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cranges%5Cgtr.js
      return function (require, module, exports) {
// Determine if version is greater than all the versions possible in the range.
const outside = require('./outside')
const gtr = (version, range, options) => outside(version, range, '>', options)
module.exports = gtr

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\gtr.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\intersects.js", {"../classes/range":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\range.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cranges%5Cintersects.js
      return function (require, module, exports) {
const Range = require('../classes/range')
const intersects = (r1, r2, options) => {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2, options)
}
module.exports = intersects

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\intersects.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\ltr.js", {"./outside":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\outside.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cranges%5Cltr.js
      return function (require, module, exports) {
const outside = require('./outside')
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside(version, range, '<', options)
module.exports = ltr

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\ltr.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\max-satisfying.js", {"../classes/range":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\range.js","../classes/semver":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cranges%5Cmax-satisfying.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const Range = require('../classes/range')

const maxSatisfying = (versions, range, options) => {
  let max = null
  let maxSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}
module.exports = maxSatisfying

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\max-satisfying.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\min-satisfying.js", {"../classes/range":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\range.js","../classes/semver":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cranges%5Cmin-satisfying.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const Range = require('../classes/range')
const minSatisfying = (versions, range, options) => {
  let min = null
  let minSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}
module.exports = minSatisfying

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\min-satisfying.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\min-version.js", {"../classes/range":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\range.js","../classes/semver":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\semver.js","../functions/gt":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\gt.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cranges%5Cmin-version.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const Range = require('../classes/range')
const gt = require('../functions/gt')

const minVersion = (range, loose) => {
  range = new Range(range, loose)

  let minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let setMin = null
    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!setMin || gt(compver, setMin)) {
            setMin = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    })
    if (setMin && (!minver || gt(minver, setMin))) {
      minver = setMin
    }
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}
module.exports = minVersion

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\min-version.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\outside.js", {"../classes/comparator":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\comparator.js","../classes/range":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\range.js","../classes/semver":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\semver.js","../functions/gt":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\gt.js","../functions/gte":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\gte.js","../functions/lt":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\lt.js","../functions/lte":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\lte.js","../functions/satisfies":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\satisfies.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cranges%5Coutside.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const Comparator = require('../classes/comparator')
const { ANY } = Comparator
const Range = require('../classes/range')
const satisfies = require('../functions/satisfies')
const gt = require('../functions/gt')
const lt = require('../functions/lt')
const lte = require('../functions/lte')
const gte = require('../functions/gte')

const outside = (version, range, hilo, options) => {
  version = new SemVer(version, options)
  range = new Range(range, options)

  let gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisfies the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let high = null
    let low = null

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

module.exports = outside

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\outside.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\simplify.js", {"../functions/compare.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\compare.js","../functions/satisfies.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\satisfies.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cranges%5Csimplify.js
      return function (require, module, exports) {
// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = require('../functions/satisfies.js')
const compare = require('../functions/compare.js')
module.exports = (versions, range, options) => {
  const set = []
  let first = null
  let prev = null
  const v = versions.sort((a, b) => compare(a, b, options))
  for (const version of v) {
    const included = satisfies(version, range, options)
    if (included) {
      prev = version
      if (!first) {
        first = version
      }
    } else {
      if (prev) {
        set.push([first, prev])
      }
      prev = null
      first = null
    }
  }
  if (first) {
    set.push([first, null])
  }

  const ranges = []
  for (const [min, max] of set) {
    if (min === max) {
      ranges.push(min)
    } else if (!max && min === v[0]) {
      ranges.push('*')
    } else if (!max) {
      ranges.push(`>=${min}`)
    } else if (min === v[0]) {
      ranges.push(`<=${max}`)
    } else {
      ranges.push(`${min} - ${max}`)
    }
  }
  const simplified = ranges.join(' || ')
  const original = typeof range.raw === 'string' ? range.raw : String(range)
  return simplified.length < original.length ? simplified : range
}

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\simplify.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\subset.js", {"../classes/comparator.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\comparator.js","../classes/range.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\range.js","../functions/compare.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\compare.js","../functions/satisfies.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\functions\\satisfies.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cranges%5Csubset.js
      return function (require, module, exports) {
const Range = require('../classes/range.js')
const Comparator = require('../classes/comparator.js')
const { ANY } = Comparator
const satisfies = require('../functions/satisfies.js')
const compare = require('../functions/compare.js')

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true

const subset = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true
  }

  sub = new Range(sub, options)
  dom = new Range(dom, options)
  let sawNonNull = false

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub) {
        continue OUTER
      }
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull) {
      return false
    }
  }
  return true
}

const minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')]
const minimumVersion = [new Comparator('>=0.0.0')]

const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true
  }

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease
    } else {
      sub = minimumVersion
    }
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true
    } else {
      dom = minimumVersion
    }
  }

  const eqSet = new Set()
  let gt, lt
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=') {
      gt = higherGT(gt, c, options)
    } else if (c.operator === '<' || c.operator === '<=') {
      lt = lowerLT(lt, c, options)
    } else {
      eqSet.add(c.semver)
    }
  }

  if (eqSet.size > 1) {
    return null
  }

  let gtltComp
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options)
    if (gtltComp > 0) {
      return null
    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
      return null
    }
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options)) {
      return null
    }

    if (lt && !satisfies(eq, String(lt), options)) {
      return null
    }

    for (const c of dom) {
      if (!satisfies(eq, String(c), options)) {
        return false
      }
    }

    return true
  }

  let higher, lower
  let hasDomLT, hasDomGT
  // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset
  let needDomLTPre = lt &&
    !options.includePrerelease &&
    lt.semver.prerelease.length ? lt.semver : false
  let needDomGTPre = gt &&
    !options.includePrerelease &&
    gt.semver.prerelease.length ? gt.semver : false
  // exception: <1.2.3-0 is the same as <1.2.3
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false
  }

  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
    if (gt) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomGTPre.major &&
            c.semver.minor === needDomGTPre.minor &&
            c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false
        }
      }
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options)
        if (higher === c && higher !== gt) {
          return false
        }
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
        return false
      }
    }
    if (lt) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomLTPre.major &&
            c.semver.minor === needDomLTPre.minor &&
            c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false
        }
      }
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options)
        if (lower === c && lower !== lt) {
          return false
        }
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
        return false
      }
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0) {
      return false
    }
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0) {
    return false
  }

  if (lt && hasDomGT && !gt && gtltComp !== 0) {
    return false
  }

  // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple
  if (needDomGTPre || needDomLTPre) {
    return false
  }

  return true
}

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare(a.semver, b.semver, options)
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
}

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare(a.semver, b.semver, options)
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
}

module.exports = subset

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\subset.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\to-comparators.js", {"../classes/range":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\range.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cranges%5Cto-comparators.js
      return function (require, module, exports) {
const Range = require('../classes/range')

// Mostly just for testing and legacy API reasons
const toComparators = (range, options) =>
  new Range(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))

module.exports = toComparators

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\to-comparators.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\ranges\\valid.js", {"../classes/range":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\semver\\classes\\range.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csemver%5Cranges%5Cvalid.js
      return function (require, module, exports) {
const Range = require('../classes/range')
const validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}
module.exports = validRange

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\valid.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\set-immediate-shim\\index.js", {"timers":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\timers-browserify\\main.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cset-immediate-shim%5Cindex.js
      return function (require, module, exports) {
(function (setImmediate){(function (){
'use strict';
module.exports = typeof setImmediate === 'function' ? setImmediate :
	function setImmediate() {
		var args = [].slice.apply(arguments);
		args.splice(1, 0, 0);
		setTimeout.apply(null, args);
	};

}).call(this)}).call(this,require("timers").setImmediate)

      };
    };
  }
  }
}, {package:"promise-to-callback>set-immediate-shim",file:"node_modules\\set-immediate-shim\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\sha.js\\hash.js", {"safe-buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csha.js%5Chash.js
      return function (require, module, exports) {
var Buffer = require('safe-buffer').Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\hash.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\sha.js\\index.js", {"./sha":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\sha.js\\sha.js","./sha1":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\sha.js\\sha1.js","./sha224":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\sha.js\\sha224.js","./sha256":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\sha.js\\sha256.js","./sha384":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\sha.js\\sha384.js","./sha512":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\sha.js\\sha512.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csha.js%5Cindex.js
      return function (require, module, exports) {
var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = require('./sha')
exports.sha1 = require('./sha1')
exports.sha224 = require('./sha224')
exports.sha256 = require('./sha256')
exports.sha384 = require('./sha384')
exports.sha512 = require('./sha512')

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\sha.js\\sha.js", {"./hash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\sha.js\\hash.js","inherits":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\inherits\\inherits_browser.js","safe-buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csha.js%5Csha.js
      return function (require, module, exports) {
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\sha.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\sha.js\\sha1.js", {"./hash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\sha.js\\hash.js","inherits":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\inherits\\inherits_browser.js","safe-buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csha.js%5Csha1.js
      return function (require, module, exports) {
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\sha1.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\sha.js\\sha224.js", {"./hash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\sha.js\\hash.js","./sha256":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\sha.js\\sha256.js","inherits":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\inherits\\inherits_browser.js","safe-buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csha.js%5Csha224.js
      return function (require, module, exports) {
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Sha256 = require('./sha256')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\sha224.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\sha.js\\sha256.js", {"./hash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\sha.js\\hash.js","inherits":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\inherits\\inherits_browser.js","safe-buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csha.js%5Csha256.js
      return function (require, module, exports) {
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\sha256.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\sha.js\\sha384.js", {"./hash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\sha.js\\hash.js","./sha512":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\sha.js\\sha512.js","inherits":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\inherits\\inherits_browser.js","safe-buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csha.js%5Csha384.js
      return function (require, module, exports) {
var inherits = require('inherits')
var SHA512 = require('./sha512')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\sha384.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\sha.js\\sha512.js", {"./hash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\sha.js\\hash.js","inherits":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\inherits\\inherits_browser.js","safe-buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csha.js%5Csha512.js
      return function (require, module, exports) {
var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\sha512.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\single-call-balance-checker-abi\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csingle-call-balance-checker-abi%5Cindex.js
      return function (require, module, exports) {

module.exports = [
    {
     "payable": true,
     "stateMutability": "payable",
     "type": "fallback"
    },
    {
     "constant": true,
     "inputs": [
      {
       "name": "user",
       "type": "address"
      },
      {
       "name": "token",
       "type": "address"
      }
     ],
     "name": "tokenBalance",
     "outputs": [
      {
       "name": "",
       "type": "uint256"
      }
     ],
     "payable": false,
     "stateMutability": "view",
     "type": "function"
    },
    {
     "constant": true,
     "inputs": [
      {
       "name": "users",
       "type": "address[]"
      },
      {
       "name": "tokens",
       "type": "address[]"
      }
     ],
     "name": "balances",
     "outputs": [
      {
       "name": "",
       "type": "uint256[]"
      }
     ],
     "payable": false,
     "stateMutability": "view",
     "type": "function"
    }
   ]

      };
    };
  }
  }
}, {package:"single-call-balance-checker-abi",file:"node_modules\\single-call-balance-checker-abi\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\string_decoder\\lib\\string_decoder.js", {"safe-buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cstring_decoder%5Clib%5Cstring_decoder.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
      };
    };
  }
  }
}, {package:"browserify>string_decoder",file:"node_modules\\string_decoder\\lib\\string_decoder.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\strip-hex-prefix\\src\\index.js", {"is-hex-prefixed":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\is-hex-prefixed\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cstrip-hex-prefix%5Csrc%5Cindex.js
      return function (require, module, exports) {
var isHexPrefixed = require('is-hex-prefixed');

/**
 * Removes '0x' from a given `String` is present
 * @param {String} str the string value
 * @return {String|Optional} a string by pass if necessary
 */
module.exports = function stripHexPrefix(str) {
  if (typeof str !== 'string') {
    return str;
  }

  return isHexPrefixed(str) ? str.slice(2) : str;
}

      };
    };
  }
  }
}, {package:"ethjs>ethjs-util>strip-hex-prefix",file:"node_modules\\strip-hex-prefix\\src\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\superstruct\\dist\\index.cjs", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Csuperstruct%5Cdist%5Cindex.cjs
      return function (require, module, exports) {
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Superstruct = {}));
})(this, (function (exports) { 'use strict';

    /**
     * A `StructFailure` represents a single specific failure in validation.
     */
    /**
     * `StructError` objects are thrown (or returned) when validation fails.
     *
     * Validation logic is design to exit early for maximum performance. The error
     * represents the first error encountered during validation. For more detail,
     * the `error.failures` property is a generator function that can be run to
     * continue validation and receive all the failures in the data.
     */
    class StructError extends TypeError {
        constructor(failure, failures) {
            let cached;
            const { message, explanation, ...rest } = failure;
            const { path } = failure;
            const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;
            super(explanation ?? msg);
            if (explanation != null)
                this.cause = msg;
            Object.assign(this, rest);
            this.name = this.constructor.name;
            this.failures = () => {
                return (cached ?? (cached = [failure, ...failures()]));
            };
        }
    }

    /**
     * Check if a value is an iterator.
     */
    function isIterable(x) {
        return isObject(x) && typeof x[Symbol.iterator] === 'function';
    }
    /**
     * Check if a value is a plain object.
     */
    function isObject(x) {
        return typeof x === 'object' && x != null;
    }
    /**
     * Check if a value is a plain object.
     */
    function isPlainObject(x) {
        if (Object.prototype.toString.call(x) !== '[object Object]') {
            return false;
        }
        const prototype = Object.getPrototypeOf(x);
        return prototype === null || prototype === Object.prototype;
    }
    /**
     * Return a value as a printable string.
     */
    function print(value) {
        if (typeof value === 'symbol') {
            return value.toString();
        }
        return typeof value === 'string' ? JSON.stringify(value) : `${value}`;
    }
    /**
     * Shifts (removes and returns) the first value from the `input` iterator.
     * Like `Array.prototype.shift()` but for an `Iterator`.
     */
    function shiftIterator(input) {
        const { done, value } = input.next();
        return done ? undefined : value;
    }
    /**
     * Convert a single validation result to a failure.
     */
    function toFailure(result, context, struct, value) {
        if (result === true) {
            return;
        }
        else if (result === false) {
            result = {};
        }
        else if (typeof result === 'string') {
            result = { message: result };
        }
        const { path, branch } = context;
        const { type } = struct;
        const { refinement, message = `Expected a value of type \`${type}\`${refinement ? ` with refinement \`${refinement}\`` : ''}, but received: \`${print(value)}\``, } = result;
        return {
            value,
            type,
            refinement,
            key: path[path.length - 1],
            path,
            branch,
            ...result,
            message,
        };
    }
    /**
     * Convert a validation result to an iterable of failures.
     */
    function* toFailures(result, context, struct, value) {
        if (!isIterable(result)) {
            result = [result];
        }
        for (const r of result) {
            const failure = toFailure(r, context, struct, value);
            if (failure) {
                yield failure;
            }
        }
    }
    /**
     * Check a value against a struct, traversing deeply into nested values, and
     * returning an iterator of failures or success.
     */
    function* run(value, struct, options = {}) {
        const { path = [], branch = [value], coerce = false, mask = false } = options;
        const ctx = { path, branch };
        if (coerce) {
            value = struct.coercer(value, ctx);
            if (mask &&
                struct.type !== 'type' &&
                isObject(struct.schema) &&
                isObject(value) &&
                !Array.isArray(value)) {
                for (const key in value) {
                    if (struct.schema[key] === undefined) {
                        delete value[key];
                    }
                }
            }
        }
        let status = 'valid';
        for (const failure of struct.validator(value, ctx)) {
            failure.explanation = options.message;
            status = 'not_valid';
            yield [failure, undefined];
        }
        for (let [k, v, s] of struct.entries(value, ctx)) {
            const ts = run(v, s, {
                path: k === undefined ? path : [...path, k],
                branch: k === undefined ? branch : [...branch, v],
                coerce,
                mask,
                message: options.message,
            });
            for (const t of ts) {
                if (t[0]) {
                    status = t[0].refinement != null ? 'not_refined' : 'not_valid';
                    yield [t[0], undefined];
                }
                else if (coerce) {
                    v = t[1];
                    if (k === undefined) {
                        value = v;
                    }
                    else if (value instanceof Map) {
                        value.set(k, v);
                    }
                    else if (value instanceof Set) {
                        value.add(v);
                    }
                    else if (isObject(value)) {
                        if (v !== undefined || k in value)
                            value[k] = v;
                    }
                }
            }
        }
        if (status !== 'not_valid') {
            for (const failure of struct.refiner(value, ctx)) {
                failure.explanation = options.message;
                status = 'not_refined';
                yield [failure, undefined];
            }
        }
        if (status === 'valid') {
            yield [undefined, value];
        }
    }

    /**
     * `Struct` objects encapsulate the validation logic for a specific type of
     * values. Once constructed, you use the `assert`, `is` or `validate` helpers to
     * validate unknown input data against the struct.
     */
    class Struct {
        constructor(props) {
            const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () { }, } = props;
            this.type = type;
            this.schema = schema;
            this.entries = entries;
            this.coercer = coercer;
            if (validator) {
                this.validator = (value, context) => {
                    const result = validator(value, context);
                    return toFailures(result, context, this, value);
                };
            }
            else {
                this.validator = () => [];
            }
            if (refiner) {
                this.refiner = (value, context) => {
                    const result = refiner(value, context);
                    return toFailures(result, context, this, value);
                };
            }
            else {
                this.refiner = () => [];
            }
        }
        /**
         * Assert that a value passes the struct's validation, throwing if it doesn't.
         */
        assert(value, message) {
            return assert(value, this, message);
        }
        /**
         * Create a value with the struct's coercion logic, then validate it.
         */
        create(value, message) {
            return create(value, this, message);
        }
        /**
         * Check if a value passes the struct's validation.
         */
        is(value) {
            return is(value, this);
        }
        /**
         * Mask a value, coercing and validating it, but returning only the subset of
         * properties defined by the struct's schema.
         */
        mask(value, message) {
            return mask(value, this, message);
        }
        /**
         * Validate a value with the struct's validation logic, returning a tuple
         * representing the result.
         *
         * You may optionally pass `true` for the `withCoercion` argument to coerce
         * the value before attempting to validate it. If you do, the result will
         * contain the coerced result when successful.
         */
        validate(value, options = {}) {
            return validate(value, this, options);
        }
    }
    /**
     * Assert that a value passes a struct, throwing if it doesn't.
     */
    function assert(value, struct, message) {
        const result = validate(value, struct, { message });
        if (result[0]) {
            throw result[0];
        }
    }
    /**
     * Create a value with the coercion logic of struct and validate it.
     */
    function create(value, struct, message) {
        const result = validate(value, struct, { coerce: true, message });
        if (result[0]) {
            throw result[0];
        }
        else {
            return result[1];
        }
    }
    /**
     * Mask a value, returning only the subset of properties defined by a struct.
     */
    function mask(value, struct, message) {
        const result = validate(value, struct, { coerce: true, mask: true, message });
        if (result[0]) {
            throw result[0];
        }
        else {
            return result[1];
        }
    }
    /**
     * Check if a value passes a struct.
     */
    function is(value, struct) {
        const result = validate(value, struct);
        return !result[0];
    }
    /**
     * Validate a value against a struct, returning an error if invalid, or the
     * value (with potential coercion) if valid.
     */
    function validate(value, struct, options = {}) {
        const tuples = run(value, struct, options);
        const tuple = shiftIterator(tuples);
        if (tuple[0]) {
            const error = new StructError(tuple[0], function* () {
                for (const t of tuples) {
                    if (t[0]) {
                        yield t[0];
                    }
                }
            });
            return [error, undefined];
        }
        else {
            const v = tuple[1];
            return [undefined, v];
        }
    }

    function assign(...Structs) {
        const isType = Structs[0].type === 'type';
        const schemas = Structs.map((s) => s.schema);
        const schema = Object.assign({}, ...schemas);
        return isType ? type(schema) : object(schema);
    }
    /**
     * Define a new struct type with a custom validation function.
     */
    function define(name, validator) {
        return new Struct({ type: name, schema: null, validator });
    }
    /**
     * Create a new struct based on an existing struct, but the value is allowed to
     * be `undefined`. `log` will be called if the value is not `undefined`.
     */
    function deprecated(struct, log) {
        return new Struct({
            ...struct,
            refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),
            validator(value, ctx) {
                if (value === undefined) {
                    return true;
                }
                else {
                    log(value, ctx);
                    return struct.validator(value, ctx);
                }
            },
        });
    }
    /**
     * Create a struct with dynamic validation logic.
     *
     * The callback will receive the value currently being validated, and must
     * return a struct object to validate it with. This can be useful to model
     * validation logic that changes based on its input.
     */
    function dynamic(fn) {
        return new Struct({
            type: 'dynamic',
            schema: null,
            *entries(value, ctx) {
                const struct = fn(value, ctx);
                yield* struct.entries(value, ctx);
            },
            validator(value, ctx) {
                const struct = fn(value, ctx);
                return struct.validator(value, ctx);
            },
            coercer(value, ctx) {
                const struct = fn(value, ctx);
                return struct.coercer(value, ctx);
            },
            refiner(value, ctx) {
                const struct = fn(value, ctx);
                return struct.refiner(value, ctx);
            },
        });
    }
    /**
     * Create a struct with lazily evaluated validation logic.
     *
     * The first time validation is run with the struct, the callback will be called
     * and must return a struct object to use. This is useful for cases where you
     * want to have self-referential structs for nested data structures to avoid a
     * circular definition problem.
     */
    function lazy(fn) {
        let struct;
        return new Struct({
            type: 'lazy',
            schema: null,
            *entries(value, ctx) {
                struct ?? (struct = fn());
                yield* struct.entries(value, ctx);
            },
            validator(value, ctx) {
                struct ?? (struct = fn());
                return struct.validator(value, ctx);
            },
            coercer(value, ctx) {
                struct ?? (struct = fn());
                return struct.coercer(value, ctx);
            },
            refiner(value, ctx) {
                struct ?? (struct = fn());
                return struct.refiner(value, ctx);
            },
        });
    }
    /**
     * Create a new struct based on an existing object struct, but excluding
     * specific properties.
     *
     * Like TypeScript's `Omit` utility.
     */
    function omit(struct, keys) {
        const { schema } = struct;
        const subschema = { ...schema };
        for (const key of keys) {
            delete subschema[key];
        }
        switch (struct.type) {
            case 'type':
                return type(subschema);
            default:
                return object(subschema);
        }
    }
    /**
     * Create a new struct based on an existing object struct, but with all of its
     * properties allowed to be `undefined`.
     *
     * Like TypeScript's `Partial` utility.
     */
    function partial(struct) {
        const schema = struct instanceof Struct ? { ...struct.schema } : { ...struct };
        for (const key in schema) {
            schema[key] = optional(schema[key]);
        }
        return object(schema);
    }
    /**
     * Create a new struct based on an existing object struct, but only including
     * specific properties.
     *
     * Like TypeScript's `Pick` utility.
     */
    function pick(struct, keys) {
        const { schema } = struct;
        const subschema = {};
        for (const key of keys) {
            subschema[key] = schema[key];
        }
        return object(subschema);
    }
    /**
     * Define a new struct type with a custom validation function.
     *
     * @deprecated This function has been renamed to `define`.
     */
    function struct(name, validator) {
        console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');
        return define(name, validator);
    }

    /**
     * Ensure that any value passes validation.
     */
    function any() {
        return define('any', () => true);
    }
    function array(Element) {
        return new Struct({
            type: 'array',
            schema: Element,
            *entries(value) {
                if (Element && Array.isArray(value)) {
                    for (const [i, v] of value.entries()) {
                        yield [i, v, Element];
                    }
                }
            },
            coercer(value) {
                return Array.isArray(value) ? value.slice() : value;
            },
            validator(value) {
                return (Array.isArray(value) ||
                    `Expected an array value, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that a value is a bigint.
     */
    function bigint() {
        return define('bigint', (value) => {
            return typeof value === 'bigint';
        });
    }
    /**
     * Ensure that a value is a boolean.
     */
    function boolean() {
        return define('boolean', (value) => {
            return typeof value === 'boolean';
        });
    }
    /**
     * Ensure that a value is a valid `Date`.
     *
     * Note: this also ensures that the value is *not* an invalid `Date` object,
     * which can occur when parsing a date fails but still returns a `Date`.
     */
    function date() {
        return define('date', (value) => {
            return ((value instanceof Date && !isNaN(value.getTime())) ||
                `Expected a valid \`Date\` object, but received: ${print(value)}`);
        });
    }
    function enums(values) {
        const schema = {};
        const description = values.map((v) => print(v)).join();
        for (const key of values) {
            schema[key] = key;
        }
        return new Struct({
            type: 'enums',
            schema,
            validator(value) {
                return (values.includes(value) ||
                    `Expected one of \`${description}\`, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that a value is a function.
     */
    function func() {
        return define('func', (value) => {
            return (typeof value === 'function' ||
                `Expected a function, but received: ${print(value)}`);
        });
    }
    /**
     * Ensure that a value is an instance of a specific class.
     */
    function instance(Class) {
        return define('instance', (value) => {
            return (value instanceof Class ||
                `Expected a \`${Class.name}\` instance, but received: ${print(value)}`);
        });
    }
    /**
     * Ensure that a value is an integer.
     */
    function integer() {
        return define('integer', (value) => {
            return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||
                `Expected an integer, but received: ${print(value)}`);
        });
    }
    /**
     * Ensure that a value matches all of a set of types.
     */
    function intersection(Structs) {
        return new Struct({
            type: 'intersection',
            schema: null,
            *entries(value, ctx) {
                for (const S of Structs) {
                    yield* S.entries(value, ctx);
                }
            },
            *validator(value, ctx) {
                for (const S of Structs) {
                    yield* S.validator(value, ctx);
                }
            },
            *refiner(value, ctx) {
                for (const S of Structs) {
                    yield* S.refiner(value, ctx);
                }
            },
        });
    }
    function literal(constant) {
        const description = print(constant);
        const t = typeof constant;
        return new Struct({
            type: 'literal',
            schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,
            validator(value) {
                return (value === constant ||
                    `Expected the literal \`${description}\`, but received: ${print(value)}`);
            },
        });
    }
    function map(Key, Value) {
        return new Struct({
            type: 'map',
            schema: null,
            *entries(value) {
                if (Key && Value && value instanceof Map) {
                    for (const [k, v] of value.entries()) {
                        yield [k, k, Key];
                        yield [k, v, Value];
                    }
                }
            },
            coercer(value) {
                return value instanceof Map ? new Map(value) : value;
            },
            validator(value) {
                return (value instanceof Map ||
                    `Expected a \`Map\` object, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that no value ever passes validation.
     */
    function never() {
        return define('never', () => false);
    }
    /**
     * Augment an existing struct to allow `null` values.
     */
    function nullable(struct) {
        return new Struct({
            ...struct,
            validator: (value, ctx) => value === null || struct.validator(value, ctx),
            refiner: (value, ctx) => value === null || struct.refiner(value, ctx),
        });
    }
    /**
     * Ensure that a value is a number.
     */
    function number() {
        return define('number', (value) => {
            return ((typeof value === 'number' && !isNaN(value)) ||
                `Expected a number, but received: ${print(value)}`);
        });
    }
    function object(schema) {
        const knowns = schema ? Object.keys(schema) : [];
        const Never = never();
        return new Struct({
            type: 'object',
            schema: schema ? schema : null,
            *entries(value) {
                if (schema && isObject(value)) {
                    const unknowns = new Set(Object.keys(value));
                    for (const key of knowns) {
                        unknowns.delete(key);
                        yield [key, value[key], schema[key]];
                    }
                    for (const key of unknowns) {
                        yield [key, value[key], Never];
                    }
                }
            },
            validator(value) {
                return (isObject(value) || `Expected an object, but received: ${print(value)}`);
            },
            coercer(value) {
                return isObject(value) ? { ...value } : value;
            },
        });
    }
    /**
     * Augment a struct to allow `undefined` values.
     */
    function optional(struct) {
        return new Struct({
            ...struct,
            validator: (value, ctx) => value === undefined || struct.validator(value, ctx),
            refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),
        });
    }
    /**
     * Ensure that a value is an object with keys and values of specific types, but
     * without ensuring any specific shape of properties.
     *
     * Like TypeScript's `Record` utility.
     */
    function record(Key, Value) {
        return new Struct({
            type: 'record',
            schema: null,
            *entries(value) {
                if (isObject(value)) {
                    for (const k in value) {
                        const v = value[k];
                        yield [k, k, Key];
                        yield [k, v, Value];
                    }
                }
            },
            validator(value) {
                return (isObject(value) || `Expected an object, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that a value is a `RegExp`.
     *
     * Note: this does not test the value against the regular expression! For that
     * you need to use the `pattern()` refinement.
     */
    function regexp() {
        return define('regexp', (value) => {
            return value instanceof RegExp;
        });
    }
    function set(Element) {
        return new Struct({
            type: 'set',
            schema: null,
            *entries(value) {
                if (Element && value instanceof Set) {
                    for (const v of value) {
                        yield [v, v, Element];
                    }
                }
            },
            coercer(value) {
                return value instanceof Set ? new Set(value) : value;
            },
            validator(value) {
                return (value instanceof Set ||
                    `Expected a \`Set\` object, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that a value is a string.
     */
    function string() {
        return define('string', (value) => {
            return (typeof value === 'string' ||
                `Expected a string, but received: ${print(value)}`);
        });
    }
    /**
     * Ensure that a value is a tuple of a specific length, and that each of its
     * elements is of a specific type.
     */
    function tuple(Structs) {
        const Never = never();
        return new Struct({
            type: 'tuple',
            schema: null,
            *entries(value) {
                if (Array.isArray(value)) {
                    const length = Math.max(Structs.length, value.length);
                    for (let i = 0; i < length; i++) {
                        yield [i, value[i], Structs[i] || Never];
                    }
                }
            },
            validator(value) {
                return (Array.isArray(value) ||
                    `Expected an array, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that a value has a set of known properties of specific types.
     *
     * Note: Unrecognized properties are allowed and untouched. This is similar to
     * how TypeScript's structural typing works.
     */
    function type(schema) {
        const keys = Object.keys(schema);
        return new Struct({
            type: 'type',
            schema,
            *entries(value) {
                if (isObject(value)) {
                    for (const k of keys) {
                        yield [k, value[k], schema[k]];
                    }
                }
            },
            validator(value) {
                return (isObject(value) || `Expected an object, but received: ${print(value)}`);
            },
            coercer(value) {
                return isObject(value) ? { ...value } : value;
            },
        });
    }
    /**
     * Ensure that a value matches one of a set of types.
     */
    function union(Structs) {
        const description = Structs.map((s) => s.type).join(' | ');
        return new Struct({
            type: 'union',
            schema: null,
            coercer(value) {
                for (const S of Structs) {
                    const [error, coerced] = S.validate(value, { coerce: true });
                    if (!error) {
                        return coerced;
                    }
                }
                return value;
            },
            validator(value, ctx) {
                const failures = [];
                for (const S of Structs) {
                    const [...tuples] = run(value, S, ctx);
                    const [first] = tuples;
                    if (!first[0]) {
                        return [];
                    }
                    else {
                        for (const [failure] of tuples) {
                            if (failure) {
                                failures.push(failure);
                            }
                        }
                    }
                }
                return [
                    `Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`,
                    ...failures,
                ];
            },
        });
    }
    /**
     * Ensure that any value passes validation, without widening its type to `any`.
     */
    function unknown() {
        return define('unknown', () => true);
    }

    /**
     * Augment a `Struct` to add an additional coercion step to its input.
     *
     * This allows you to transform input data before validating it, to increase the
     * likelihood that it passes validationfor example for default values, parsing
     * different formats, etc.
     *
     * Note: You must use `create(value, Struct)` on the value to have the coercion
     * take effect! Using simply `assert()` or `is()` will not use coercion.
     */
    function coerce(struct, condition, coercer) {
        return new Struct({
            ...struct,
            coercer: (value, ctx) => {
                return is(value, condition)
                    ? struct.coercer(coercer(value, ctx), ctx)
                    : struct.coercer(value, ctx);
            },
        });
    }
    /**
     * Augment a struct to replace `undefined` values with a default.
     *
     * Note: You must use `create(value, Struct)` on the value to have the coercion
     * take effect! Using simply `assert()` or `is()` will not use coercion.
     */
    function defaulted(struct, fallback, options = {}) {
        return coerce(struct, unknown(), (x) => {
            const f = typeof fallback === 'function' ? fallback() : fallback;
            if (x === undefined) {
                return f;
            }
            if (!options.strict && isPlainObject(x) && isPlainObject(f)) {
                const ret = { ...x };
                let changed = false;
                for (const key in f) {
                    if (ret[key] === undefined) {
                        ret[key] = f[key];
                        changed = true;
                    }
                }
                if (changed) {
                    return ret;
                }
            }
            return x;
        });
    }
    /**
     * Augment a struct to trim string inputs.
     *
     * Note: You must use `create(value, Struct)` on the value to have the coercion
     * take effect! Using simply `assert()` or `is()` will not use coercion.
     */
    function trimmed(struct) {
        return coerce(struct, string(), (x) => x.trim());
    }

    /**
     * Ensure that a string, array, map, or set is empty.
     */
    function empty(struct) {
        return refine(struct, 'empty', (value) => {
            const size = getSize(value);
            return (size === 0 ||
                `Expected an empty ${struct.type} but received one with a size of \`${size}\``);
        });
    }
    function getSize(value) {
        if (value instanceof Map || value instanceof Set) {
            return value.size;
        }
        else {
            return value.length;
        }
    }
    /**
     * Ensure that a number or date is below a threshold.
     */
    function max(struct, threshold, options = {}) {
        const { exclusive } = options;
        return refine(struct, 'max', (value) => {
            return exclusive
                ? value < threshold
                : value <= threshold ||
                    `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \`${value}\``;
        });
    }
    /**
     * Ensure that a number or date is above a threshold.
     */
    function min(struct, threshold, options = {}) {
        const { exclusive } = options;
        return refine(struct, 'min', (value) => {
            return exclusive
                ? value > threshold
                : value >= threshold ||
                    `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \`${value}\``;
        });
    }
    /**
     * Ensure that a string, array, map or set is not empty.
     */
    function nonempty(struct) {
        return refine(struct, 'nonempty', (value) => {
            const size = getSize(value);
            return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);
        });
    }
    /**
     * Ensure that a string matches a regular expression.
     */
    function pattern(struct, regexp) {
        return refine(struct, 'pattern', (value) => {
            return (regexp.test(value) ||
                `Expected a ${struct.type} matching \`/${regexp.source}/\` but received "${value}"`);
        });
    }
    /**
     * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.
     */
    function size(struct, min, max = min) {
        const expected = `Expected a ${struct.type}`;
        const of = min === max ? `of \`${min}\`` : `between \`${min}\` and \`${max}\``;
        return refine(struct, 'size', (value) => {
            if (typeof value === 'number' || value instanceof Date) {
                return ((min <= value && value <= max) ||
                    `${expected} ${of} but received \`${value}\``);
            }
            else if (value instanceof Map || value instanceof Set) {
                const { size } = value;
                return ((min <= size && size <= max) ||
                    `${expected} with a size ${of} but received one with a size of \`${size}\``);
            }
            else {
                const { length } = value;
                return ((min <= length && length <= max) ||
                    `${expected} with a length ${of} but received one with a length of \`${length}\``);
            }
        });
    }
    /**
     * Augment a `Struct` to add an additional refinement to the validation.
     *
     * The refiner function is guaranteed to receive a value of the struct's type,
     * because the struct's existing validation will already have passed. This
     * allows you to layer additional validation on top of existing structs.
     */
    function refine(struct, name, refiner) {
        return new Struct({
            ...struct,
            *refiner(value, ctx) {
                yield* struct.refiner(value, ctx);
                const result = refiner(value, ctx);
                const failures = toFailures(result, ctx, struct, value);
                for (const failure of failures) {
                    yield { ...failure, refinement: name };
                }
            },
        });
    }

    exports.Struct = Struct;
    exports.StructError = StructError;
    exports.any = any;
    exports.array = array;
    exports.assert = assert;
    exports.assign = assign;
    exports.bigint = bigint;
    exports.boolean = boolean;
    exports.coerce = coerce;
    exports.create = create;
    exports.date = date;
    exports.defaulted = defaulted;
    exports.define = define;
    exports.deprecated = deprecated;
    exports.dynamic = dynamic;
    exports.empty = empty;
    exports.enums = enums;
    exports.func = func;
    exports.instance = instance;
    exports.integer = integer;
    exports.intersection = intersection;
    exports.is = is;
    exports.lazy = lazy;
    exports.literal = literal;
    exports.map = map;
    exports.mask = mask;
    exports.max = max;
    exports.min = min;
    exports.never = never;
    exports.nonempty = nonempty;
    exports.nullable = nullable;
    exports.number = number;
    exports.object = object;
    exports.omit = omit;
    exports.optional = optional;
    exports.partial = partial;
    exports.pattern = pattern;
    exports.pick = pick;
    exports.record = record;
    exports.refine = refine;
    exports.regexp = regexp;
    exports.set = set;
    exports.size = size;
    exports.string = string;
    exports.struct = struct;
    exports.trimmed = trimmed;
    exports.tuple = tuple;
    exports.type = type;
    exports.union = union;
    exports.unknown = unknown;
    exports.validate = validate;

}));
//# sourceMappingURL=index.cjs.map

      };
    };
  }
  }
}, {package:"superstruct",file:"node_modules\\superstruct\\dist\\index.cjs",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\timers-browserify\\main.js", {"process/browser.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\process\\browser.js","timers":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\timers-browserify\\main.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Ctimers-browserify%5Cmain.js
      return function (require, module, exports) {
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

      };
    };
  }
  }
}, {package:"browserify>timers-browserify",file:"node_modules\\timers-browserify\\main.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\tslib\\tslib.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Ctslib%5Ctslib.js
      return function (require, module, exports) {
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __esDecorate;
var __runInitializers;
var __propKey;
var __setFunctionName;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __spreadArrays;
var __spreadArray;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
var __classPrivateFieldGet;
var __classPrivateFieldSet;
var __classPrivateFieldIn;
var __createBinding;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };

    __extends = function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __esDecorate = function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _, done = false;
        for (var i = decorators.length - 1; i >= 0; i--) {
            var context = {};
            for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
            for (var p in contextIn.access) context.access[p] = contextIn.access[p];
            context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
            var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
            if (kind === "accessor") {
                if (result === void 0) continue;
                if (result === null || typeof result !== "object") throw new TypeError("Object expected");
                if (_ = accept(result.get)) descriptor.get = _;
                if (_ = accept(result.set)) descriptor.set = _;
                if (_ = accept(result.init)) initializers.push(_);
            }
            else if (_ = accept(result)) {
                if (kind === "field") initializers.push(_);
                else descriptor[key] = _;
            }
        }
        if (target) Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
    };

    __runInitializers = function (thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i = 0; i < initializers.length; i++) {
            value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
        }
        return useValue ? value : void 0;
    };

    __propKey = function (x) {
        return typeof x === "symbol" ? x : "".concat(x);
    };

    __setFunctionName = function (f, name, prefix) {
        if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
        return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function(m, o) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
    };

    __createBinding = Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    });

    __values = function (o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    /** @deprecated */
    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    /** @deprecated */
    __spreadArrays = function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    __spreadArray = function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    var __setModuleDefault = Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    };

    __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };

    __importDefault = function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    __classPrivateFieldGet = function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    __classPrivateFieldSet = function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };

    __classPrivateFieldIn = function (state, receiver) {
        if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
});

      };
    };
  }
  }
}, {package:"wait-on>rxjs>tslib",file:"node_modules\\tslib\\tslib.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\url\\url.js", {"./util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\url\\util.js","punycode":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\punycode\\punycode.js","querystring":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\querystring-es3\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Curl%5Curl.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

      };
    };
  }
  }
}, {package:"browserify>url",file:"node_modules\\url\\url.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\url\\util.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Curl%5Cutil.js
      return function (require, module, exports) {
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

      };
    };
  }
  }
}, {package:"browserify>url",file:"node_modules\\url\\util.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\utf8\\utf8.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cutf8%5Cutf8.js
      return function (require, module, exports) {
/*! https://mths.be/utf8js v3.0.0 by @mathias */
;(function(root) {

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, its not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	root.version = '3.0.0';
	root.encode = utf8encode;
	root.decode = utf8decode;

}(typeof exports === 'undefined' ? this.utf8 = {} : exports));

      };
    };
  }
  }
}, {package:"@truffle/codec>utf8",file:"node_modules\\utf8\\utf8.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\util-deprecate\\browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cutil-deprecate%5Cbrowser.js
      return function (require, module, exports) {

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

      };
    };
  }
  }
}, {package:"readable-stream>util-deprecate",file:"node_modules\\util-deprecate\\browser.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\index.js", {"./nil.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\nil.js","./parse.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\parse.js","./stringify.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\stringify.js","./v1.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\v1.js","./v3.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\v3.js","./v4.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\v4.js","./v5.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\v5.js","./validate.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\validate.js","./version.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\version.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cuuid%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "v1", {
  enumerable: true,
  get: function () {
    return _v.default;
  }
});
Object.defineProperty(exports, "v3", {
  enumerable: true,
  get: function () {
    return _v2.default;
  }
});
Object.defineProperty(exports, "v4", {
  enumerable: true,
  get: function () {
    return _v3.default;
  }
});
Object.defineProperty(exports, "v5", {
  enumerable: true,
  get: function () {
    return _v4.default;
  }
});
Object.defineProperty(exports, "NIL", {
  enumerable: true,
  get: function () {
    return _nil.default;
  }
});
Object.defineProperty(exports, "version", {
  enumerable: true,
  get: function () {
    return _version.default;
  }
});
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function () {
    return _validate.default;
  }
});
Object.defineProperty(exports, "stringify", {
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function () {
    return _parse.default;
  }
});

var _v = _interopRequireDefault(require("./v1.js"));

var _v2 = _interopRequireDefault(require("./v3.js"));

var _v3 = _interopRequireDefault(require("./v4.js"));

var _v4 = _interopRequireDefault(require("./v5.js"));

var _nil = _interopRequireDefault(require("./nil.js"));

var _version = _interopRequireDefault(require("./version.js"));

var _validate = _interopRequireDefault(require("./validate.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\md5-browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cuuid%5Cdist%5Cmd5-browser.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = '0123456789abcdef';

  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 0xff;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;

  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));

  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  const lsw = (x & 0xffff) + (y & 0xffff);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

var _default = md5;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\md5-browser.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\nil.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cuuid%5Cdist%5Cnil.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\nil.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\parse.js", {"./validate.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\validate.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cuuid%5Cdist%5Cparse.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\parse.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\regex.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cuuid%5Cdist%5Cregex.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\regex.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\rng-browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cuuid%5Cdist%5Crng-browser.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);

function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\rng-browser.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\sha1-browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cuuid%5Cdist%5Csha1-browser.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);

  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);

    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }

    M[i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);

    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }

    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }

    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];

    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

var _default = sha1;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\sha1-browser.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\stringify.js", {"./validate.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\validate.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cuuid%5Cdist%5Cstringify.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\stringify.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\v1.js", {"./rng.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\rng-browser.js","./stringify.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\stringify.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cuuid%5Cdist%5Cv1.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\v1.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\v3.js", {"./md5.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\md5-browser.js","./v35.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\v35.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cuuid%5Cdist%5Cv3.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _md = _interopRequireDefault(require("./md5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\v3.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\v35.js", {"./parse.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\parse.js","./stringify.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\stringify.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cuuid%5Cdist%5Cv35.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\v35.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\v4.js", {"./rng.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\rng-browser.js","./stringify.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\stringify.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cuuid%5Cdist%5Cv4.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\v4.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\v5.js", {"./sha1.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\sha1-browser.js","./v35.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\v35.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cuuid%5Cdist%5Cv5.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _sha = _interopRequireDefault(require("./sha1.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\v5.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\validate.js", {"./regex.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\regex.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cuuid%5Cdist%5Cvalidate.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regex = _interopRequireDefault(require("./regex.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\validate.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\version.js", {"./validate.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\uuid\\dist\\validate.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cuuid%5Cdist%5Cversion.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\version.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\valid-url\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cvalid-url%5Cindex.js
      return function (require, module, exports) {
(function(module) {
    'use strict';

    module.exports.is_uri = is_iri;
    module.exports.is_http_uri = is_http_iri;
    module.exports.is_https_uri = is_https_iri;
    module.exports.is_web_uri = is_web_iri;
    // Create aliases
    module.exports.isUri = is_iri;
    module.exports.isHttpUri = is_http_iri;
    module.exports.isHttpsUri = is_https_iri;
    module.exports.isWebUri = is_web_iri;


    // private function
    // internal URI spitter method - direct from RFC 3986
    var splitUri = function(uri) {
        var splitted = uri.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
        return splitted;
    };

    function is_iri(value) {
        if (!value) {
            return;
        }

        // check for illegal characters
        if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(value)) return;

        // check for hex escapes that aren't complete
        if (/%[^0-9a-f]/i.test(value)) return;
        if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value)) return;

        var splitted = [];
        var scheme = '';
        var authority = '';
        var path = '';
        var query = '';
        var fragment = '';
        var out = '';

        // from RFC 3986
        splitted = splitUri(value);
        scheme = splitted[1]; 
        authority = splitted[2];
        path = splitted[3];
        query = splitted[4];
        fragment = splitted[5];

        // scheme and path are required, though the path can be empty
        if (!(scheme && scheme.length && path.length >= 0)) return;

        // if authority is present, the path must be empty or begin with a /
        if (authority && authority.length) {
            if (!(path.length === 0 || /^\//.test(path))) return;
        } else {
            // if authority is not present, the path must not start with //
            if (/^\/\//.test(path)) return;
        }

        // scheme must begin with a letter, then consist of letters, digits, +, ., or -
        if (!/^[a-z][a-z0-9\+\-\.]*$/.test(scheme.toLowerCase()))  return;

        // re-assemble the URL per section 5.3 in RFC 3986
        out += scheme + ':';
        if (authority && authority.length) {
            out += '//' + authority;
        }

        out += path;

        if (query && query.length) {
            out += '?' + query;
        }

        if (fragment && fragment.length) {
            out += '#' + fragment;
        }

        return out;
    }

    function is_http_iri(value, allowHttps) {
        if (!is_iri(value)) {
            return;
        }

        var splitted = [];
        var scheme = '';
        var authority = '';
        var path = '';
        var port = '';
        var query = '';
        var fragment = '';
        var out = '';

        // from RFC 3986
        splitted = splitUri(value);
        scheme = splitted[1]; 
        authority = splitted[2];
        path = splitted[3];
        query = splitted[4];
        fragment = splitted[5];

        if (!scheme)  return;

        if(allowHttps) {
            if (scheme.toLowerCase() != 'https') return;
        } else {
            if (scheme.toLowerCase() != 'http') return;
        }

        // fully-qualified URIs must have an authority section that is
        // a valid host
        if (!authority) {
            return;
        }

        // enable port component
        if (/:(\d+)$/.test(authority)) {
            port = authority.match(/:(\d+)$/)[0];
            authority = authority.replace(/:\d+$/, '');
        }

        out += scheme + ':';
        out += '//' + authority;
        
        if (port) {
            out += port;
        }
        
        out += path;
        
        if(query && query.length){
            out += '?' + query;
        }

        if(fragment && fragment.length){
            out += '#' + fragment;
        }
        
        return out;
    }

    function is_https_iri(value) {
        return is_http_iri(value, true);
    }

    function is_web_iri(value) {
        return (is_http_iri(value) || is_https_iri(value));
    }

})(module);

      };
    };
  }
  }
}, {package:"valid-url",file:"node_modules\\valid-url\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\varint\\decode.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cvarint%5Cdecode.js
      return function (require, module, exports) {
module.exports = read

var MSB = 0x80
  , REST = 0x7F

function read(buf, offset) {
  var res    = 0
    , offset = offset || 0
    , shift  = 0
    , counter = offset
    , b
    , l = buf.length

  do {
    if (counter >= l) {
      read.bytes = 0
      throw new RangeError('Could not decode varint')
    }
    b = buf[counter++]
    res += shift < 28
      ? (b & REST) << shift
      : (b & REST) * Math.pow(2, shift)
    shift += 7
  } while (b >= MSB)

  read.bytes = counter - offset

  return res
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>varint",file:"node_modules\\varint\\decode.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\varint\\encode.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cvarint%5Cencode.js
      return function (require, module, exports) {
module.exports = encode

var MSB = 0x80
  , REST = 0x7F
  , MSBALL = ~REST
  , INT = Math.pow(2, 31)

function encode(num, out, offset) {
  out = out || []
  offset = offset || 0
  var oldOffset = offset

  while(num >= INT) {
    out[offset++] = (num & 0xFF) | MSB
    num /= 128
  }
  while(num & MSBALL) {
    out[offset++] = (num & 0xFF) | MSB
    num >>>= 7
  }
  out[offset] = num | 0
  
  encode.bytes = offset - oldOffset + 1
  
  return out
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>varint",file:"node_modules\\varint\\encode.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\varint\\index.js", {"./decode.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\varint\\decode.js","./encode.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\varint\\encode.js","./length.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\varint\\length.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cvarint%5Cindex.js
      return function (require, module, exports) {
module.exports = {
    encode: require('./encode.js')
  , decode: require('./decode.js')
  , encodingLength: require('./length.js')
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>varint",file:"node_modules\\varint\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\varint\\length.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cvarint%5Clength.js
      return function (require, module, exports) {

var N1 = Math.pow(2,  7)
var N2 = Math.pow(2, 14)
var N3 = Math.pow(2, 21)
var N4 = Math.pow(2, 28)
var N5 = Math.pow(2, 35)
var N6 = Math.pow(2, 42)
var N7 = Math.pow(2, 49)
var N8 = Math.pow(2, 56)
var N9 = Math.pow(2, 63)

module.exports = function (value) {
  return (
    value < N1 ? 1
  : value < N2 ? 2
  : value < N3 ? 3
  : value < N4 ? 4
  : value < N5 ? 5
  : value < N6 ? 6
  : value < N7 ? 7
  : value < N8 ? 8
  : value < N9 ? 9
  :              10
  )
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>varint",file:"node_modules\\varint\\length.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\vm-browserify\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cvm-browserify%5Cindex.js
      return function (require, module, exports) {
var indexOf = function (xs, item) {
    if (xs.indexOf) return xs.indexOf(item);
    else for (var i = 0; i < xs.length; i++) {
        if (xs[i] === item) return i;
    }
    return -1;
};
var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.(0,eval)() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return (0,eval)(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    if (context) {
        forEach(Object_keys(ctx), function (key) {
            context[key] = ctx[key];
        });
    }

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.isContext = function (context) {
    return context instanceof Context;
};

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};

      };
    };
  }
  }
}, {package:"browserify>vm-browserify",file:"node_modules\\vm-browserify\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\webextension-polyfill\\dist\\browser-polyfill.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cwebextension-polyfill%5Cdist%5Cbrowser-polyfill.js
      return function (require, module, exports) {
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define("webextension-polyfill", ["module"], factory);
  } else if (typeof exports !== "undefined") {
    factory(module);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod);
    global.browser = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (module) {
  /* webextension-polyfill - v0.8.0 - Tue Apr 20 2021 11:27:38 */

  /* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */

  /* vim: set sts=2 sw=2 et tw=80: */

  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
  "use strict";

  if (typeof browser === "undefined" || Object.getPrototypeOf(browser) !== Object.prototype) {
    const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = "The message port closed before a response was received.";
    const SEND_RESPONSE_DEPRECATION_WARNING = "Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)"; // Wrapping the bulk of this polyfill in a one-time-use function is a minor
    // optimization for Firefox. Since Spidermonkey does not fully parse the
    // contents of a function until the first time it's called, and since it will
    // never actually need to be called, this allows the polyfill to be included
    // in Firefox nearly for free.

    const wrapAPIs = extensionAPIs => {
      // NOTE: apiMetadata is associated to the content of the api-metadata.json file
      // at build time by replacing the following "include" with the content of the
      // JSON file.
      const apiMetadata = {
        "alarms": {
          "clear": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "clearAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "get": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "bookmarks": {
          "create": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getChildren": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getRecent": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getSubTree": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTree": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "move": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeTree": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "browserAction": {
          "disable": {
            "minArgs": 0,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "enable": {
            "minArgs": 0,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "getBadgeBackgroundColor": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getBadgeText": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getPopup": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTitle": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "openPopup": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "setBadgeBackgroundColor": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setBadgeText": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setIcon": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "setPopup": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setTitle": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "browsingData": {
          "remove": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "removeCache": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeCookies": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeDownloads": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeFormData": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeHistory": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeLocalStorage": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removePasswords": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removePluginData": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "settings": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "commands": {
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "contextMenus": {
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "cookies": {
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAllCookieStores": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "set": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "devtools": {
          "inspectedWindow": {
            "eval": {
              "minArgs": 1,
              "maxArgs": 2,
              "singleCallbackArg": false
            }
          },
          "panels": {
            "create": {
              "minArgs": 3,
              "maxArgs": 3,
              "singleCallbackArg": true
            },
            "elements": {
              "createSidebarPane": {
                "minArgs": 1,
                "maxArgs": 1
              }
            }
          }
        },
        "downloads": {
          "cancel": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "download": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "erase": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getFileIcon": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "open": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "pause": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeFile": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "resume": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "show": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "extension": {
          "isAllowedFileSchemeAccess": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "isAllowedIncognitoAccess": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "history": {
          "addUrl": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "deleteAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "deleteRange": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "deleteUrl": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getVisits": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "i18n": {
          "detectLanguage": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAcceptLanguages": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "identity": {
          "launchWebAuthFlow": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "idle": {
          "queryState": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "management": {
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getSelf": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "setEnabled": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "uninstallSelf": {
            "minArgs": 0,
            "maxArgs": 1
          }
        },
        "notifications": {
          "clear": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "create": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getPermissionLevel": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "pageAction": {
          "getPopup": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTitle": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "hide": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setIcon": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "setPopup": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setTitle": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "show": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "permissions": {
          "contains": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "request": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "runtime": {
          "getBackgroundPage": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getPlatformInfo": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "openOptionsPage": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "requestUpdateCheck": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "sendMessage": {
            "minArgs": 1,
            "maxArgs": 3
          },
          "sendNativeMessage": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "setUninstallURL": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "sessions": {
          "getDevices": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getRecentlyClosed": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "restore": {
            "minArgs": 0,
            "maxArgs": 1
          }
        },
        "storage": {
          "local": {
            "clear": {
              "minArgs": 0,
              "maxArgs": 0
            },
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "remove": {
              "minArgs": 1,
              "maxArgs": 1
            },
            "set": {
              "minArgs": 1,
              "maxArgs": 1
            }
          },
          "managed": {
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            }
          },
          "sync": {
            "clear": {
              "minArgs": 0,
              "maxArgs": 0
            },
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "remove": {
              "minArgs": 1,
              "maxArgs": 1
            },
            "set": {
              "minArgs": 1,
              "maxArgs": 1
            }
          }
        },
        "tabs": {
          "captureVisibleTab": {
            "minArgs": 0,
            "maxArgs": 2
          },
          "create": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "detectLanguage": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "discard": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "duplicate": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "executeScript": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getCurrent": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getZoom": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getZoomSettings": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "goBack": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "goForward": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "highlight": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "insertCSS": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "move": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "query": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "reload": {
            "minArgs": 0,
            "maxArgs": 2
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeCSS": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "sendMessage": {
            "minArgs": 2,
            "maxArgs": 3
          },
          "setZoom": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "setZoomSettings": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "update": {
            "minArgs": 1,
            "maxArgs": 2
          }
        },
        "topSites": {
          "get": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "webNavigation": {
          "getAllFrames": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getFrame": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "webRequest": {
          "handlerBehaviorChanged": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "windows": {
          "create": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getCurrent": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getLastFocused": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        }
      };

      if (Object.keys(apiMetadata).length === 0) {
        throw new Error("api-metadata.json has not been included in browser-polyfill");
      }
      /**
       * A WeakMap subclass which creates and stores a value for any key which does
       * not exist when accessed, but behaves exactly as an ordinary WeakMap
       * otherwise.
       *
       * @param {function} createItem
       *        A function which will be called in order to create the value for any
       *        key which does not exist, the first time it is accessed. The
       *        function receives, as its only argument, the key being created.
       */


      class DefaultWeakMap extends WeakMap {
        constructor(createItem, items = undefined) {
          super(items);
          this.createItem = createItem;
        }

        get(key) {
          if (!this.has(key)) {
            this.set(key, this.createItem(key));
          }

          return super.get(key);
        }

      }
      /**
       * Returns true if the given object is an object with a `then` method, and can
       * therefore be assumed to behave as a Promise.
       *
       * @param {*} value The value to test.
       * @returns {boolean} True if the value is thenable.
       */


      const isThenable = value => {
        return value && typeof value === "object" && typeof value.then === "function";
      };
      /**
       * Creates and returns a function which, when called, will resolve or reject
       * the given promise based on how it is called:
       *
       * - If, when called, `chrome.runtime.lastError` contains a non-null object,
       *   the promise is rejected with that value.
       * - If the function is called with exactly one argument, the promise is
       *   resolved to that value.
       * - Otherwise, the promise is resolved to an array containing all of the
       *   function's arguments.
       *
       * @param {object} promise
       *        An object containing the resolution and rejection functions of a
       *        promise.
       * @param {function} promise.resolve
       *        The promise's resolution function.
       * @param {function} promise.reject
       *        The promise's rejection function.
       * @param {object} metadata
       *        Metadata about the wrapped method which has created the callback.
       * @param {boolean} metadata.singleCallbackArg
       *        Whether or not the promise is resolved with only the first
       *        argument of the callback, alternatively an array of all the
       *        callback arguments is resolved. By default, if the callback
       *        function is invoked with only a single argument, that will be
       *        resolved to the promise, while all arguments will be resolved as
       *        an array if multiple are given.
       *
       * @returns {function}
       *        The generated callback function.
       */


      const makeCallback = (promise, metadata) => {
        return (...callbackArgs) => {
          if (extensionAPIs.runtime.lastError) {
            promise.reject(new Error(extensionAPIs.runtime.lastError.message));
          } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {
            promise.resolve(callbackArgs[0]);
          } else {
            promise.resolve(callbackArgs);
          }
        };
      };

      const pluralizeArguments = numArgs => numArgs == 1 ? "argument" : "arguments";
      /**
       * Creates a wrapper function for a method with the given name and metadata.
       *
       * @param {string} name
       *        The name of the method which is being wrapped.
       * @param {object} metadata
       *        Metadata about the method being wrapped.
       * @param {integer} metadata.minArgs
       *        The minimum number of arguments which must be passed to the
       *        function. If called with fewer than this number of arguments, the
       *        wrapper will raise an exception.
       * @param {integer} metadata.maxArgs
       *        The maximum number of arguments which may be passed to the
       *        function. If called with more than this number of arguments, the
       *        wrapper will raise an exception.
       * @param {boolean} metadata.singleCallbackArg
       *        Whether or not the promise is resolved with only the first
       *        argument of the callback, alternatively an array of all the
       *        callback arguments is resolved. By default, if the callback
       *        function is invoked with only a single argument, that will be
       *        resolved to the promise, while all arguments will be resolved as
       *        an array if multiple are given.
       *
       * @returns {function(object, ...*)}
       *       The generated wrapper function.
       */


      const wrapAsyncFunction = (name, metadata) => {
        return function asyncFunctionWrapper(target, ...args) {
          if (args.length < metadata.minArgs) {
            throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
          }

          if (args.length > metadata.maxArgs) {
            throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
          }

          return new Promise((resolve, reject) => {
            if (metadata.fallbackToNoCallback) {
              // This API method has currently no callback on Chrome, but it return a promise on Firefox,
              // and so the polyfill will try to call it with a callback first, and it will fallback
              // to not passing the callback if the first call fails.
              try {
                target[name](...args, makeCallback({
                  resolve,
                  reject
                }, metadata));
              } catch (cbError) {
                console.warn(`${name} API method doesn't seem to support the callback parameter, ` + "falling back to call it without a callback: ", cbError);
                target[name](...args); // Update the API method metadata, so that the next API calls will not try to
                // use the unsupported callback anymore.

                metadata.fallbackToNoCallback = false;
                metadata.noCallback = true;
                resolve();
              }
            } else if (metadata.noCallback) {
              target[name](...args);
              resolve();
            } else {
              target[name](...args, makeCallback({
                resolve,
                reject
              }, metadata));
            }
          });
        };
      };
      /**
       * Wraps an existing method of the target object, so that calls to it are
       * intercepted by the given wrapper function. The wrapper function receives,
       * as its first argument, the original `target` object, followed by each of
       * the arguments passed to the original method.
       *
       * @param {object} target
       *        The original target object that the wrapped method belongs to.
       * @param {function} method
       *        The method being wrapped. This is used as the target of the Proxy
       *        object which is created to wrap the method.
       * @param {function} wrapper
       *        The wrapper function which is called in place of a direct invocation
       *        of the wrapped method.
       *
       * @returns {Proxy<function>}
       *        A Proxy object for the given method, which invokes the given wrapper
       *        method in its place.
       */


      const wrapMethod = (target, method, wrapper) => {
        return new Proxy(method, {
          apply(targetMethod, thisObj, args) {
            return wrapper.call(thisObj, target, ...args);
          }

        });
      };

      let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
      /**
       * Wraps an object in a Proxy which intercepts and wraps certain methods
       * based on the given `wrappers` and `metadata` objects.
       *
       * @param {object} target
       *        The target object to wrap.
       *
       * @param {object} [wrappers = {}]
       *        An object tree containing wrapper functions for special cases. Any
       *        function present in this object tree is called in place of the
       *        method in the same location in the `target` object tree. These
       *        wrapper methods are invoked as described in {@see wrapMethod}.
       *
       * @param {object} [metadata = {}]
       *        An object tree containing metadata used to automatically generate
       *        Promise-based wrapper functions for asynchronous. Any function in
       *        the `target` object tree which has a corresponding metadata object
       *        in the same location in the `metadata` tree is replaced with an
       *        automatically-generated wrapper function, as described in
       *        {@see wrapAsyncFunction}
       *
       * @returns {Proxy<object>}
       */

      const wrapObject = (target, wrappers = {}, metadata = {}) => {
        let cache = Object.create(null);
        let handlers = {
          has(proxyTarget, prop) {
            return prop in target || prop in cache;
          },

          get(proxyTarget, prop, receiver) {
            if (prop in cache) {
              return cache[prop];
            }

            if (!(prop in target)) {
              return undefined;
            }

            let value = target[prop];

            if (typeof value === "function") {
              // This is a method on the underlying object. Check if we need to do
              // any wrapping.
              if (typeof wrappers[prop] === "function") {
                // We have a special-case wrapper for this method.
                value = wrapMethod(target, target[prop], wrappers[prop]);
              } else if (hasOwnProperty(metadata, prop)) {
                // This is an async method that we have metadata for. Create a
                // Promise wrapper for it.
                let wrapper = wrapAsyncFunction(prop, metadata[prop]);
                value = wrapMethod(target, target[prop], wrapper);
              } else {
                // This is a method that we don't know or care about. Return the
                // original method, bound to the underlying object.
                value = value.bind(target);
              }
            } else if (typeof value === "object" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {
              // This is an object that we need to do some wrapping for the children
              // of. Create a sub-object wrapper for it with the appropriate child
              // metadata.
              value = wrapObject(value, wrappers[prop], metadata[prop]);
            } else if (hasOwnProperty(metadata, "*")) {
              // Wrap all properties in * namespace.
              value = wrapObject(value, wrappers[prop], metadata["*"]);
            } else {
              // We don't need to do any wrapping for this property,
              // so just forward all access to the underlying object.
              Object.defineProperty(cache, prop, {
                configurable: true,
                enumerable: true,

                get() {
                  return target[prop];
                },

                set(value) {
                  target[prop] = value;
                }

              });
              return value;
            }

            cache[prop] = value;
            return value;
          },

          set(proxyTarget, prop, value, receiver) {
            if (prop in cache) {
              cache[prop] = value;
            } else {
              target[prop] = value;
            }

            return true;
          },

          defineProperty(proxyTarget, prop, desc) {
            return Reflect.defineProperty(cache, prop, desc);
          },

          deleteProperty(proxyTarget, prop) {
            return Reflect.deleteProperty(cache, prop);
          }

        }; // Per contract of the Proxy API, the "get" proxy handler must return the
        // original value of the target if that value is declared read-only and
        // non-configurable. For this reason, we create an object with the
        // prototype set to `target` instead of using `target` directly.
        // Otherwise we cannot return a custom object for APIs that
        // are declared read-only and non-configurable, such as `chrome.devtools`.
        //
        // The proxy handlers themselves will still use the original `target`
        // instead of the `proxyTarget`, so that the methods and properties are
        // dereferenced via the original targets.

        let proxyTarget = Object.create(target);
        return new Proxy(proxyTarget, handlers);
      };
      /**
       * Creates a set of wrapper functions for an event object, which handles
       * wrapping of listener functions that those messages are passed.
       *
       * A single wrapper is created for each listener function, and stored in a
       * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`
       * retrieve the original wrapper, so that  attempts to remove a
       * previously-added listener work as expected.
       *
       * @param {DefaultWeakMap<function, function>} wrapperMap
       *        A DefaultWeakMap object which will create the appropriate wrapper
       *        for a given listener function when one does not exist, and retrieve
       *        an existing one when it does.
       *
       * @returns {object}
       */


      const wrapEvent = wrapperMap => ({
        addListener(target, listener, ...args) {
          target.addListener(wrapperMap.get(listener), ...args);
        },

        hasListener(target, listener) {
          return target.hasListener(wrapperMap.get(listener));
        },

        removeListener(target, listener) {
          target.removeListener(wrapperMap.get(listener));
        }

      });

      const onRequestFinishedWrappers = new DefaultWeakMap(listener => {
        if (typeof listener !== "function") {
          return listener;
        }
        /**
         * Wraps an onRequestFinished listener function so that it will return a
         * `getContent()` property which returns a `Promise` rather than using a
         * callback API.
         *
         * @param {object} req
         *        The HAR entry object representing the network request.
         */


        return function onRequestFinished(req) {
          const wrappedReq = wrapObject(req, {}
          /* wrappers */
          , {
            getContent: {
              minArgs: 0,
              maxArgs: 0
            }
          });
          listener(wrappedReq);
        };
      }); // Keep track if the deprecation warning has been logged at least once.

      let loggedSendResponseDeprecationWarning = false;
      const onMessageWrappers = new DefaultWeakMap(listener => {
        if (typeof listener !== "function") {
          return listener;
        }
        /**
         * Wraps a message listener function so that it may send responses based on
         * its return value, rather than by returning a sentinel value and calling a
         * callback. If the listener function returns a Promise, the response is
         * sent when the promise either resolves or rejects.
         *
         * @param {*} message
         *        The message sent by the other end of the channel.
         * @param {object} sender
         *        Details about the sender of the message.
         * @param {function(*)} sendResponse
         *        A callback which, when called with an arbitrary argument, sends
         *        that value as a response.
         * @returns {boolean}
         *        True if the wrapped listener returned a Promise, which will later
         *        yield a response. False otherwise.
         */


        return function onMessage(message, sender, sendResponse) {
          let didCallSendResponse = false;
          let wrappedSendResponse;
          let sendResponsePromise = new Promise(resolve => {
            wrappedSendResponse = function (response) {
              if (!loggedSendResponseDeprecationWarning) {
                console.warn(SEND_RESPONSE_DEPRECATION_WARNING, new Error().stack);
                loggedSendResponseDeprecationWarning = true;
              }

              didCallSendResponse = true;
              resolve(response);
            };
          });
          let result;

          try {
            result = listener(message, sender, wrappedSendResponse);
          } catch (err) {
            result = Promise.reject(err);
          }

          const isResultThenable = result !== true && isThenable(result); // If the listener didn't returned true or a Promise, or called
          // wrappedSendResponse synchronously, we can exit earlier
          // because there will be no response sent from this listener.

          if (result !== true && !isResultThenable && !didCallSendResponse) {
            return false;
          } // A small helper to send the message if the promise resolves
          // and an error if the promise rejects (a wrapped sendMessage has
          // to translate the message into a resolved promise or a rejected
          // promise).


          const sendPromisedResult = promise => {
            promise.then(msg => {
              // send the message value.
              sendResponse(msg);
            }, error => {
              // Send a JSON representation of the error if the rejected value
              // is an instance of error, or the object itself otherwise.
              let message;

              if (error && (error instanceof Error || typeof error.message === "string")) {
                message = error.message;
              } else {
                message = "An unexpected error occurred";
              }

              sendResponse({
                __mozWebExtensionPolyfillReject__: true,
                message
              });
            }).catch(err => {
              // Print an error on the console if unable to send the response.
              console.error("Failed to send onMessage rejected reply", err);
            });
          }; // If the listener returned a Promise, send the resolved value as a
          // result, otherwise wait the promise related to the wrappedSendResponse
          // callback to resolve and send it as a response.


          if (isResultThenable) {
            sendPromisedResult(result);
          } else {
            sendPromisedResult(sendResponsePromise);
          } // Let Chrome know that the listener is replying.


          return true;
        };
      });

      const wrappedSendMessageCallback = ({
        reject,
        resolve
      }, reply) => {
        if (extensionAPIs.runtime.lastError) {
          // Detect when none of the listeners replied to the sendMessage call and resolve
          // the promise to undefined as in Firefox.
          // See https://github.com/mozilla/webextension-polyfill/issues/130
          if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {
            resolve();
          } else {
            reject(new Error(extensionAPIs.runtime.lastError.message));
          }
        } else if (reply && reply.__mozWebExtensionPolyfillReject__) {
          // Convert back the JSON representation of the error into
          // an Error instance.
          reject(new Error(reply.message));
        } else {
          resolve(reply);
        }
      };

      const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {
        if (args.length < metadata.minArgs) {
          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
        }

        if (args.length > metadata.maxArgs) {
          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
        }

        return new Promise((resolve, reject) => {
          const wrappedCb = wrappedSendMessageCallback.bind(null, {
            resolve,
            reject
          });
          args.push(wrappedCb);
          apiNamespaceObj.sendMessage(...args);
        });
      };

      const staticWrappers = {
        devtools: {
          network: {
            onRequestFinished: wrapEvent(onRequestFinishedWrappers)
          }
        },
        runtime: {
          onMessage: wrapEvent(onMessageWrappers),
          onMessageExternal: wrapEvent(onMessageWrappers),
          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
            minArgs: 1,
            maxArgs: 3
          })
        },
        tabs: {
          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
            minArgs: 2,
            maxArgs: 3
          })
        }
      };
      const settingMetadata = {
        clear: {
          minArgs: 1,
          maxArgs: 1
        },
        get: {
          minArgs: 1,
          maxArgs: 1
        },
        set: {
          minArgs: 1,
          maxArgs: 1
        }
      };
      apiMetadata.privacy = {
        network: {
          "*": settingMetadata
        },
        services: {
          "*": settingMetadata
        },
        websites: {
          "*": settingMetadata
        }
      };
      return wrapObject(extensionAPIs, staticWrappers, apiMetadata);
    };

    if (typeof chrome != "object" || !chrome || !chrome.runtime || !chrome.runtime.id) {
      throw new Error("This script should only be loaded in a browser extension.");
    } // The build process adds a UMD wrapper around this file, which makes the
    // `module` variable available.


    module.exports = wrapAPIs(chrome);
  } else {
    module.exports = browser;
  }
});
//# sourceMappingURL=browser-polyfill.js.map

      };
    };
  }
  }
}, {package:"webextension-polyfill",file:"node_modules\\webextension-polyfill\\dist\\browser-polyfill.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\wrappy\\wrappy.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cwrappy%5Cwrappy.js
      return function (require, module, exports) {
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

      };
    };
  }
  }
}, {package:"pump>once>wrappy",file:"node_modules\\wrappy\\wrappy.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\xtend\\immutable.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cxtend%5Cimmutable.js
      return function (require, module, exports) {
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

      };
    };
  }
  }
}, {package:"watchify>xtend",file:"node_modules\\xtend\\immutable.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\yallist\\iterator.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cyallist%5Citerator.js
      return function (require, module, exports) {
'use strict'
module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = function* () {
    for (let walker = this.head; walker; walker = walker.next) {
      yield walker.value
    }
  }
}

      };
    };
  }
  }
}, {package:"semver>lru-cache>yallist",file:"node_modules\\yallist\\iterator.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\yallist\\yallist.js", {"./iterator.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\yallist\\iterator.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cyallist%5Cyallist.js
      return function (require, module, exports) {
'use strict'
module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null

  return next
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1
  }
  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next
  }

  var ret = []
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value)
    walker = this.removeNode(walker)
  }
  if (walker === null) {
    walker = this.tail
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev
  }

  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i])
  }
  return ret;
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function insert (self, node, value) {
  var inserted = node === self.head ?
    new Node(value, null, node, self) :
    new Node(value, node, node.next, self)

  if (inserted.next === null) {
    self.tail = inserted
  }
  if (inserted.prev === null) {
    self.head = inserted
  }

  self.length++

  return inserted
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}

try {
  // add if support for Symbol.iterator is present
  require('./iterator.js')(Yallist)
} catch (er) {}

      };
    };
  }
  }
}, {package:"semver>lru-cache>yallist",file:"node_modules\\yallist\\yallist.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\alerts.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cconstants%5Calerts.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Web3ShimUsageAlertStates = exports.TOGGLEABLE_ALERT_TYPES = exports.AlertTypes = void 0;
let AlertTypes = /*#__PURE__*/function (AlertTypes) {
  AlertTypes["unconnectedAccount"] = "unconnectedAccount";
  AlertTypes["web3ShimUsage"] = "web3ShimUsage";
  AlertTypes["invalidCustomNetwork"] = "invalidCustomNetwork";
  return AlertTypes;
}({});
/**
 * Alerts that can be enabled or disabled by the user.
 */
exports.AlertTypes = AlertTypes;
const TOGGLEABLE_ALERT_TYPES = [AlertTypes.unconnectedAccount, AlertTypes.web3ShimUsage];
exports.TOGGLEABLE_ALERT_TYPES = TOGGLEABLE_ALERT_TYPES;
let Web3ShimUsageAlertStates = /*#__PURE__*/function (Web3ShimUsageAlertStates) {
  Web3ShimUsageAlertStates[Web3ShimUsageAlertStates["recorded"] = 1] = "recorded";
  Web3ShimUsageAlertStates[Web3ShimUsageAlertStates["dismissed"] = 2] = "dismissed";
  return Web3ShimUsageAlertStates;
}({});
exports.Web3ShimUsageAlertStates = Web3ShimUsageAlertStates;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\alerts.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\app.ts", {"./permissions":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\permissions.ts"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cconstants%5Capp.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UNKNOWN_TICKER_SYMBOL = exports.POLLING_TOKEN_ENVIRONMENT_TYPES = exports.PLATFORM_OPERA = exports.PLATFORM_FIREFOX = exports.PLATFORM_EDGE = exports.PLATFORM_CHROME = exports.PLATFORM_BRAVE = exports.ORIGIN_METAMASK = exports.METAMASK_PROD_CHROME_ID = exports.METAMASK_MMI_PROD_CHROME_ID = exports.METAMASK_MMI_BETA_CHROME_ID = exports.METAMASK_FLASK_CHROME_ID = exports.METAMASK_BETA_CHROME_ID = exports.MESSAGE_TYPE = exports.FIREFOX_BUILD_IDS = exports.EXTENSION_MESSAGES = exports.ENVIRONMENT_TYPE_POPUP = exports.ENVIRONMENT_TYPE_NOTIFICATION = exports.ENVIRONMENT_TYPE_FULLSCREEN = exports.ENVIRONMENT_TYPE_BACKGROUND = exports.CHROME_BUILD_IDS = void 0;
var _permissions = require("./permissions");
/**
 * A string representing the type of environment the application is currently running in
 * popup - When the user click's the icon in their browser's extension bar; the default view
 * notification - When the extension opens due to interaction with a Web3 enabled website
 * fullscreen - When the user clicks 'expand view' to open the extension in a new tab
 * background - The background process that powers the extension
 */

const ENVIRONMENT_TYPE_POPUP = 'popup';
exports.ENVIRONMENT_TYPE_POPUP = ENVIRONMENT_TYPE_POPUP;
const ENVIRONMENT_TYPE_NOTIFICATION = 'notification';
exports.ENVIRONMENT_TYPE_NOTIFICATION = ENVIRONMENT_TYPE_NOTIFICATION;
const ENVIRONMENT_TYPE_FULLSCREEN = 'fullscreen';
exports.ENVIRONMENT_TYPE_FULLSCREEN = ENVIRONMENT_TYPE_FULLSCREEN;
const ENVIRONMENT_TYPE_BACKGROUND = 'background';
exports.ENVIRONMENT_TYPE_BACKGROUND = ENVIRONMENT_TYPE_BACKGROUND;
const PLATFORM_BRAVE = 'Brave';
exports.PLATFORM_BRAVE = PLATFORM_BRAVE;
const PLATFORM_CHROME = 'Chrome';
exports.PLATFORM_CHROME = PLATFORM_CHROME;
const PLATFORM_EDGE = 'Edge';
exports.PLATFORM_EDGE = PLATFORM_EDGE;
const PLATFORM_FIREFOX = 'Firefox';
exports.PLATFORM_FIREFOX = PLATFORM_FIREFOX;
const PLATFORM_OPERA = 'Opera';
exports.PLATFORM_OPERA = PLATFORM_OPERA;
const MESSAGE_TYPE = {
  ADD_ETHEREUM_CHAIN: 'wallet_addEthereumChain',
  ETH_ACCOUNTS: _permissions.RestrictedMethods.eth_accounts,
  ETH_DECRYPT: 'eth_decrypt',
  ETH_GET_ENCRYPTION_PUBLIC_KEY: 'eth_getEncryptionPublicKey',
  ETH_REQUEST_ACCOUNTS: 'eth_requestAccounts',
  ETH_SIGN: 'eth_sign',
  ETH_SIGN_TYPED_DATA: 'eth_signTypedData',
  ETH_SIGN_TYPED_DATA_V3: 'eth_signTypedData_v3',
  ETH_SIGN_TYPED_DATA_V4: 'eth_signTypedData_v4',
  GET_PROVIDER_STATE: 'metamask_getProviderState',
  LOG_WEB3_SHIM_USAGE: 'metamask_logWeb3ShimUsage',
  PERSONAL_SIGN: 'personal_sign',
  SEND_METADATA: 'metamask_sendDomainMetadata',
  SWITCH_ETHEREUM_CHAIN: 'wallet_switchEthereumChain',
  TRANSACTION: 'transaction',
  WALLET_REQUEST_PERMISSIONS: 'wallet_requestPermissions',
  WATCH_ASSET: 'wallet_watchAsset',
  WATCH_ASSET_LEGACY: 'metamask_watchAsset'
};

/**
 * Custom messages to send and be received by the extension
 */
exports.MESSAGE_TYPE = MESSAGE_TYPE;
const EXTENSION_MESSAGES = {
  CONNECTION_READY: 'CONNECTION_READY',
  READY: 'METAMASK_EXTENSION_READY'
};
exports.EXTENSION_MESSAGES = EXTENSION_MESSAGES;
const POLLING_TOKEN_ENVIRONMENT_TYPES = {
  [ENVIRONMENT_TYPE_POPUP]: 'popupGasPollTokens',
  [ENVIRONMENT_TYPE_NOTIFICATION]: 'notificationGasPollTokens',
  [ENVIRONMENT_TYPE_FULLSCREEN]: 'fullScreenGasPollTokens',
  [ENVIRONMENT_TYPE_BACKGROUND]: 'none'
};
exports.POLLING_TOKEN_ENVIRONMENT_TYPES = POLLING_TOKEN_ENVIRONMENT_TYPES;
const ORIGIN_METAMASK = 'metamask';
exports.ORIGIN_METAMASK = ORIGIN_METAMASK;
const METAMASK_BETA_CHROME_ID = 'pbbkamfgmaedccnfkmjcofcecjhfgldn';
exports.METAMASK_BETA_CHROME_ID = METAMASK_BETA_CHROME_ID;
const METAMASK_PROD_CHROME_ID = 'nkbihfbeogaeaoehlefnkodbefgpgknn';
exports.METAMASK_PROD_CHROME_ID = METAMASK_PROD_CHROME_ID;
const METAMASK_FLASK_CHROME_ID = 'ljfoeinjpaedjfecbmggjgodbgkmjkjk';
exports.METAMASK_FLASK_CHROME_ID = METAMASK_FLASK_CHROME_ID;
const METAMASK_MMI_BETA_CHROME_ID = 'kmbhbcbadohhhgdgihejcicbgcehoaeg';
exports.METAMASK_MMI_BETA_CHROME_ID = METAMASK_MMI_BETA_CHROME_ID;
const METAMASK_MMI_PROD_CHROME_ID = 'ikkihjamdhfiojpdbnfllpjigpneipbc';
exports.METAMASK_MMI_PROD_CHROME_ID = METAMASK_MMI_PROD_CHROME_ID;
const CHROME_BUILD_IDS = [METAMASK_BETA_CHROME_ID, METAMASK_PROD_CHROME_ID, METAMASK_FLASK_CHROME_ID, METAMASK_MMI_BETA_CHROME_ID, METAMASK_MMI_PROD_CHROME_ID];
exports.CHROME_BUILD_IDS = CHROME_BUILD_IDS;
const METAMASK_BETA_FIREFOX_ID = 'webextension-beta@metamask.io';
const METAMASK_PROD_FIREFOX_ID = 'webextension@metamask.io';
const METAMASK_FLASK_FIREFOX_ID = 'webextension-flask@metamask.io';
const FIREFOX_BUILD_IDS = [METAMASK_BETA_FIREFOX_ID, METAMASK_PROD_FIREFOX_ID, METAMASK_FLASK_FIREFOX_ID];
exports.FIREFOX_BUILD_IDS = FIREFOX_BUILD_IDS;
const UNKNOWN_TICKER_SYMBOL = 'UNKNOWN';
exports.UNKNOWN_TICKER_SYMBOL = UNKNOWN_TICKER_SYMBOL;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\app.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\common.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cconstants%5Ccommon.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EtherDenomination = void 0;
let EtherDenomination = /*#__PURE__*/function (EtherDenomination) {
  EtherDenomination["ETH"] = "ETH";
  EtherDenomination["GWEI"] = "GWEI";
  EtherDenomination["WEI"] = "WEI";
  return EtherDenomination;
}({});
exports.EtherDenomination = EtherDenomination;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\common.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\gas.ts", {"ethereumjs-util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cconstants%5Cgas.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PriorityLevels = exports.NetworkCongestionThresholds = exports.MIN_GAS_LIMIT_HEX = exports.GasRecommendations = exports.GasEstimateTypes = exports.GAS_LIMITS = exports.EditGasModes = exports.CUSTOM_GAS_ESTIMATE = void 0;
var _ethereumjsUtil = require("ethereumjs-util");
const ONE_HUNDRED_THOUSAND = 100000;
const MIN_GAS_LIMIT_DEC = '21000';
const MIN_GAS_LIMIT_HEX = parseInt(MIN_GAS_LIMIT_DEC, 10).toString(16);
exports.MIN_GAS_LIMIT_HEX = MIN_GAS_LIMIT_HEX;
const GAS_LIMITS = {
  // maximum gasLimit of a simple send
  SIMPLE: (0, _ethereumjsUtil.addHexPrefix)(MIN_GAS_LIMIT_HEX),
  // a base estimate for token transfers.
  BASE_TOKEN_ESTIMATE: (0, _ethereumjsUtil.addHexPrefix)(ONE_HUNDRED_THOUSAND.toString(16))
};

/**
 * @typedef {object} GasEstimateTypes
 * @property {'fee-market'} FEE_MARKET - A gas estimate for a fee market transaction generated by our gas estimation API.
 * @property {'legacy'} LEGACY - A gas estimate for a legacy Transaction generated by our gas estimation API.
 * @property {'eth_gasPrice'} ETH_GAS_PRICE - A gas estimate provided by the Ethereum node via eth_gasPrice.
 * @property {'none'} NONE - No gas estimate available.
 */

/**
 * These are already declared in @metamask/controllers but importing them from
 * that module and re-exporting causes the UI bundle size to expand beyond 4MB
 *
 * (TODO: This comment was added before @metamask/controllers was split up 
 * revisit now that @metamask/gas-fee-controller is available)
 *
 * @type {GasEstimateTypes}
 */
exports.GAS_LIMITS = GAS_LIMITS;
let GasEstimateTypes = /*#__PURE__*/function (GasEstimateTypes) {
  GasEstimateTypes["feeMarket"] = "fee-market";
  GasEstimateTypes["legacy"] = "legacy";
  GasEstimateTypes["ethGasPrice"] = "eth_gasPrice";
  GasEstimateTypes["none"] = "none";
  return GasEstimateTypes;
}({});
/**
 * These represent gas recommendation levels presented in the UI
 */
exports.GasEstimateTypes = GasEstimateTypes;
let GasRecommendations = /*#__PURE__*/function (GasRecommendations) {
  GasRecommendations["low"] = "low";
  GasRecommendations["medium"] = "medium";
  GasRecommendations["high"] = "high";
  return GasRecommendations;
}({});
/**
 * These represent types of gas estimation
 */
exports.GasRecommendations = GasRecommendations;
let PriorityLevels = /*#__PURE__*/function (PriorityLevels) {
  PriorityLevels["tenPercentIncreased"] = "tenPercentIncreased";
  PriorityLevels["low"] = "low";
  PriorityLevels["medium"] = "medium";
  PriorityLevels["high"] = "high";
  PriorityLevels["custom"] = "custom";
  PriorityLevels["dAppSuggested"] = "dappSuggested";
  return PriorityLevels;
}({});
/**
 * Represents the user customizing their gas preference
 */
exports.PriorityLevels = PriorityLevels;
const CUSTOM_GAS_ESTIMATE = 'custom';

/**
 * These represent the different edit modes presented in the UI
 */
exports.CUSTOM_GAS_ESTIMATE = CUSTOM_GAS_ESTIMATE;
let EditGasModes = /*#__PURE__*/function (EditGasModes) {
  EditGasModes["speedUp"] = "speed-up";
  EditGasModes["cancel"] = "cancel";
  EditGasModes["modifyInPlace"] = "modify-in-place";
  EditGasModes["swaps"] = "swaps";
  return EditGasModes;
}({});
/**
 * Represents levels for `networkCongestion` (calculated along with gas fee
 * estimates; represents a number between 0 and 1) that we use to render the
 * network status slider on the send transaction screen and inform users when
 * gas fees are high
 */
exports.EditGasModes = EditGasModes;
let NetworkCongestionThresholds = /*#__PURE__*/function (NetworkCongestionThresholds) {
  NetworkCongestionThresholds[NetworkCongestionThresholds["notBusy"] = 0] = "notBusy";
  NetworkCongestionThresholds[NetworkCongestionThresholds["stable"] = 0.33] = "stable";
  NetworkCongestionThresholds[NetworkCongestionThresholds["busy"] = 0.66] = "busy";
  return NetworkCongestionThresholds;
}({});
exports.NetworkCongestionThresholds = NetworkCongestionThresholds;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\gas.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\hardware-wallets.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cconstants%5Chardware-wallets.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebHIDConnectedStatuses = exports.LedgerTransportTypes = exports.LEDGER_USB_VENDOR_ID = exports.HardwareTransportStates = exports.HardwareKeyringType = exports.HardwareKeyringNames = exports.HardwareDeviceNames = exports.HardwareAffiliateTutorialLinks = exports.HardwareAffiliateLinks = void 0;
/**
 * Hardware wallets supported by MetaMask.
 */
let HardwareKeyringType = /*#__PURE__*/function (HardwareKeyringType) {
  HardwareKeyringType["ledger"] = "Ledger Hardware";
  HardwareKeyringType["trezor"] = "Trezor Hardware";
  HardwareKeyringType["lattice"] = "Lattice Hardware";
  HardwareKeyringType["qr"] = "QR Hardware Wallet Device";
  return HardwareKeyringType;
}({});
exports.HardwareKeyringType = HardwareKeyringType;
let HardwareKeyringNames = /*#__PURE__*/function (HardwareKeyringNames) {
  HardwareKeyringNames["ledger"] = "Ledger";
  HardwareKeyringNames["trezor"] = "Trezor";
  HardwareKeyringNames["lattice"] = "Lattice1";
  HardwareKeyringNames["qr"] = "QR";
  return HardwareKeyringNames;
}({});
exports.HardwareKeyringNames = HardwareKeyringNames;
let HardwareDeviceNames = /*#__PURE__*/function (HardwareDeviceNames) {
  HardwareDeviceNames["ledger"] = "ledger";
  HardwareDeviceNames["trezor"] = "trezor";
  HardwareDeviceNames["lattice"] = "lattice";
  HardwareDeviceNames["qr"] = "QR Hardware";
  return HardwareDeviceNames;
}({});
exports.HardwareDeviceNames = HardwareDeviceNames;
let HardwareTransportStates = /*#__PURE__*/function (HardwareTransportStates) {
  HardwareTransportStates["none"] = "NONE";
  HardwareTransportStates["verified"] = "VERIFIED";
  HardwareTransportStates["deviceOpenFailure"] = "DEVICE_OPEN_FAILURE";
  HardwareTransportStates["unknownFailure"] = "UNKNOWN_FAILURE";
  return HardwareTransportStates;
}({});
exports.HardwareTransportStates = HardwareTransportStates;
let HardwareAffiliateLinks = /*#__PURE__*/function (HardwareAffiliateLinks) {
  HardwareAffiliateLinks["ledger"] = "https://shop.ledger.com/?r=17c4991a03fa";
  HardwareAffiliateLinks["gridplus"] = "https://gridplus.io/?afmc=7p";
  HardwareAffiliateLinks["trezor"] = "https://shop.trezor.io/product/trezor-one-black?offer_id=35&aff_id=11009";
  HardwareAffiliateLinks["keystone"] = "https://keyst.one/metamask?rfsn=6088257.656b3e9&utm_source=refersion&utm_medium=affiliate&utm_campaign=6088257.656b3e9";
  HardwareAffiliateLinks["airgap"] = "https://airgap.it/";
  HardwareAffiliateLinks["coolwallet"] = "https://www.coolwallet.io/";
  HardwareAffiliateLinks["dcent"] = "https://dcentwallet.com/";
  return HardwareAffiliateLinks;
}({});
exports.HardwareAffiliateLinks = HardwareAffiliateLinks;
let HardwareAffiliateTutorialLinks = /*#__PURE__*/function (HardwareAffiliateTutorialLinks) {
  HardwareAffiliateTutorialLinks["ledger"] = "https://support.ledger.com/hc/en-us/articles/4404366864657-Set-up-and-use-MetaMask-to-access-your-Ledger-Ethereum-ETH-account?docs=true";
  HardwareAffiliateTutorialLinks["gridplus"] = "https://docs.gridplus.io/setup/metamask";
  HardwareAffiliateTutorialLinks["trezor"] = "https://wiki.trezor.io/Apps:MetaMask";
  HardwareAffiliateTutorialLinks["keystone"] = "https://support.keyst.one/3rd-party-wallets/eth-and-web3-wallets-keystone/bind-metamask-with-keystone";
  HardwareAffiliateTutorialLinks["airgap"] = "https://support.airgap.it/guides/metamask/";
  HardwareAffiliateTutorialLinks["coolwallet"] = "https://www.coolwallet.io/metamask-step-by-step-guides/";
  HardwareAffiliateTutorialLinks["dcent"] = "https://medium.com/dcentwallet/dcent-wallet-now-supports-qr-based-protocol-to-link-with-metamask-57555f02603f";
  return HardwareAffiliateTutorialLinks;
}({});
/**
 * Used for setting the users preference for ledger transport type
 */
exports.HardwareAffiliateTutorialLinks = HardwareAffiliateTutorialLinks;
let LedgerTransportTypes = /*#__PURE__*/function (LedgerTransportTypes) {
  LedgerTransportTypes["live"] = "ledgerLive";
  LedgerTransportTypes["webhid"] = "webhid";
  LedgerTransportTypes["u2f"] = "u2f";
  return LedgerTransportTypes;
}({});
exports.LedgerTransportTypes = LedgerTransportTypes;
let WebHIDConnectedStatuses = /*#__PURE__*/function (WebHIDConnectedStatuses) {
  WebHIDConnectedStatuses["connected"] = "connected";
  WebHIDConnectedStatuses["notConnected"] = "notConnected";
  WebHIDConnectedStatuses["unknown"] = "unknown";
  return WebHIDConnectedStatuses;
}({});
exports.WebHIDConnectedStatuses = WebHIDConnectedStatuses;
const LEDGER_USB_VENDOR_ID = '0x2c97';
exports.LEDGER_USB_VENDOR_ID = LEDGER_USB_VENDOR_ID;


      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\hardware-wallets.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\keyring.ts", {"./hardware-wallets":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\hardware-wallets.ts"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cconstants%5Ckeyring.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KeyringType = exports.InternalKeyringType = void 0;
var _hardwareWallets = require("./hardware-wallets");
/**
 * These are the keyrings that are managed entirely by MetaMask.
 */
let InternalKeyringType = /*#__PURE__*/function (InternalKeyringType) {
  InternalKeyringType["hdKeyTree"] = "HD Key Tree";
  InternalKeyringType["imported"] = "Simple Key Pair";
  return InternalKeyringType;
}({});
/**
 * All keyrings supported by MetaMask.
 */
exports.InternalKeyringType = InternalKeyringType;
const KeyringType = {
  ..._hardwareWallets.HardwareKeyringType,
  ...InternalKeyringType
};
exports.KeyringType = KeyringType;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\keyring.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\labels.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cconstants%5Clabels.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TRUNCATED_NAME_CHAR_LIMIT = exports.TRUNCATED_ADDRESS_START_CHARS = exports.TRUNCATED_ADDRESS_END_CHARS = void 0;
// The character limit on ENS names, nicknames and addresses before we truncate
const TRUNCATED_NAME_CHAR_LIMIT = 11;

// The number of characters to slice from the beginning of an address for truncated format:
// `${TRUNCATED_ADDRESS_START_CHARS}...${TRUNCATED_ADDRESS_END_CHARS}`
exports.TRUNCATED_NAME_CHAR_LIMIT = TRUNCATED_NAME_CHAR_LIMIT;
const TRUNCATED_ADDRESS_START_CHARS = 5;

// The number of characters to slice from the end of an address for truncated format:
// `${TRUNCATED_ADDRESS_START_CHARS}...${TRUNCATED_ADDRESS_END_CHARS}`
exports.TRUNCATED_ADDRESS_START_CHARS = TRUNCATED_ADDRESS_START_CHARS;
const TRUNCATED_ADDRESS_END_CHARS = 4;
exports.TRUNCATED_ADDRESS_END_CHARS = TRUNCATED_ADDRESS_END_CHARS;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\labels.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\metametrics.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cconstants%5Cmetametrics.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.REJECT_NOTIFICATION_CLOSE_SIG = exports.REJECT_NOTIFICATION_CLOSE = exports.MetaMetricsUserTrait = exports.MetaMetricsTransactionEventSource = exports.MetaMetricsTokenEventSource = exports.MetaMetricsSwapsEventSource = exports.MetaMetricsNetworkEventSource = exports.MetaMetricsEventUiCustomization = exports.MetaMetricsEventOnrampProviderType = exports.MetaMetricsEventName = exports.MetaMetricsEventLocation = exports.MetaMetricsEventLinkType = exports.MetaMetricsEventKeyType = exports.MetaMetricsEventCategory = exports.MetaMetricsEventAccountType = exports.MetaMetricsEventAccountImportType = exports.MetaMetricsContextProp = exports.METAMETRICS_BACKGROUND_PAGE_OBJECT = exports.METAMETRICS_ANONYMOUS_ID = void 0;
/**
 * Used to attach context of where the user was at in the application when the
 * event was triggered. Also included as full details of the current page in
 * page events.
 */
/**
 * The dapp that triggered an interaction (MetaMask only).
 */
/**
 * We attach context to every meta metrics event that help to qualify our
 * analytics. This type has all optional values because it represents a
 * returned object from a method call. Ideally app and userAgent are
 * defined on every event. This is confirmed in the getTrackMetaMetricsEvent
 * function, but still provides the consumer a way to override these values if
 * necessary.
 */
/**
 * Data sent to the `segment.track` method.
 */
/**
 * Data sent to MetaMetrics for page views.
 */
/**
 * Data sent to MetaMetrics for user traits.
 */
let MetaMetricsUserTrait = /*#__PURE__*/function (MetaMetricsUserTrait) {
  MetaMetricsUserTrait["AddressBookEntries"] = "address_book_entries";
  MetaMetricsUserTrait["InstallDateExt"] = "install_date_ext";
  MetaMetricsUserTrait["LedgerConnectionType"] = "ledger_connection_type";
  MetaMetricsUserTrait["NetworksAdded"] = "networks_added";
  MetaMetricsUserTrait["NetworksWithoutTicker"] = "networks_without_ticker";
  MetaMetricsUserTrait["NftAutodetectionEnabled"] = "nft_autodetection_enabled";
  MetaMetricsUserTrait["NumberOfAccounts"] = "number_of_accounts";
  MetaMetricsUserTrait["NumberOfNftCollections"] = "number_of_nft_collections";
  MetaMetricsUserTrait["NumberOfNfts"] = "number_of_nfts";
  MetaMetricsUserTrait["NumberOfTokens"] = "number_of_tokens";
  MetaMetricsUserTrait["OpenSeaApiEnabled"] = "opensea_api_enabled";
  MetaMetricsUserTrait["Theme"] = "theme";
  MetaMetricsUserTrait["ThreeBoxEnabled"] = "three_box_enabled";
  MetaMetricsUserTrait["TokenDetectionEnabled"] = "token_detection_enabled";
  MetaMetricsUserTrait["DesktopEnabled"] = "desktop_enabled";
  MetaMetricsUserTrait["SecurityProviders"] = "security_providers";
  return MetaMetricsUserTrait;
}({});
/**
 * Mixpanel converts the zero address value to a truly anonymous event, which
 * speeds up reporting
 */
exports.MetaMetricsUserTrait = MetaMetricsUserTrait;
const METAMETRICS_ANONYMOUS_ID = '0x0000000000000000';

/**
 * Used to identify events that are triggered by the background process.
 */
exports.METAMETRICS_ANONYMOUS_ID = METAMETRICS_ANONYMOUS_ID;
const METAMETRICS_BACKGROUND_PAGE_OBJECT = {
  path: '/background-process',
  title: 'Background Process',
  url: '/background-process'
};
exports.METAMETRICS_BACKGROUND_PAGE_OBJECT = METAMETRICS_BACKGROUND_PAGE_OBJECT;
const REJECT_NOTIFICATION_CLOSE = 'Cancel Via Notification Close';
exports.REJECT_NOTIFICATION_CLOSE = REJECT_NOTIFICATION_CLOSE;
const REJECT_NOTIFICATION_CLOSE_SIG = 'Cancel Sig Request Via Notification Close';
exports.REJECT_NOTIFICATION_CLOSE_SIG = REJECT_NOTIFICATION_CLOSE_SIG;
let MetaMetricsEventName = /*#__PURE__*/function (MetaMetricsEventName) {
  MetaMetricsEventName["AccountAdded"] = "Account Added";
  MetaMetricsEventName["AccountAddSelected"] = "Account Add Selected";
  MetaMetricsEventName["AccountAddFailed"] = "Account Add Failed";
  MetaMetricsEventName["AccountPasswordCreated"] = "Account Password Created";
  MetaMetricsEventName["AccountReset"] = "Account Reset";
  MetaMetricsEventName["AccountRenamed"] = "Account Renamed";
  MetaMetricsEventName["AppInstalled"] = "App Installed";
  MetaMetricsEventName["AppUnlocked"] = "App Unlocked";
  MetaMetricsEventName["AppUnlockedFailed"] = "App Unlocked Failed";
  MetaMetricsEventName["AppLocked"] = "App Locked";
  MetaMetricsEventName["AppWindowExpanded"] = "App Window Expanded";
  MetaMetricsEventName["BridgeLinkClicked"] = "Bridge Link Clicked";
  MetaMetricsEventName["DecryptionApproved"] = "Decryption Approved";
  MetaMetricsEventName["DecryptionRejected"] = "Decryption Rejected";
  MetaMetricsEventName["DecryptionRequested"] = "Decryption Requested";
  MetaMetricsEventName["EncryptionPublicKeyApproved"] = "Encryption Approved";
  MetaMetricsEventName["EncryptionPublicKeyRejected"] = "Encryption Rejected";
  MetaMetricsEventName["EncryptionPublicKeyRequested"] = "Encryption Requested";
  MetaMetricsEventName["ExternalLinkClicked"] = "External Link Clicked";
  MetaMetricsEventName["KeyExportSelected"] = "Key Export Selected";
  MetaMetricsEventName["KeyExportRequested"] = "Key Export Requested";
  MetaMetricsEventName["KeyExportFailed"] = "Key Export Failed";
  MetaMetricsEventName["KeyExportCanceled"] = "Key Export Canceled";
  MetaMetricsEventName["KeyExportRevealed"] = "Key Material Revealed";
  MetaMetricsEventName["KeyExportCopied"] = "Key Material Copied";
  MetaMetricsEventName["KeyTokenDetectionSelected"] = "Key Token Detection Selected";
  MetaMetricsEventName["KeyGlobalSecurityToggleSelected"] = "Key Global Security/Privacy Settings";
  MetaMetricsEventName["KeyBalanceTokenPriceChecker"] = "Key Show Balance and Token Price Checker Settings";
  MetaMetricsEventName["KeyGasFeeEstimationBuySwapTokens"] = "Key Show Gas Fee Estimation, Buy Crypto and Swap Tokens";
  MetaMetricsEventName["KeyAutoDetectTokens"] = "Key Autodetect tokens";
  MetaMetricsEventName["KeyBatchAccountBalanceRequests"] = "Key Batch account balance requests";
  MetaMetricsEventName["MetricsOptIn"] = "Metrics Opt In";
  MetaMetricsEventName["MetricsOptOut"] = "Metrics Opt Out";
  MetaMetricsEventName["NavAccountMenuOpened"] = "Account Menu Opened";
  MetaMetricsEventName["NavAccountDetailsOpened"] = "Account Details Opened";
  MetaMetricsEventName["NavConnectedSitesOpened"] = "Connected Sites Opened";
  MetaMetricsEventName["NavMainMenuOpened"] = "Main Menu Opened";
  MetaMetricsEventName["NavNetworkMenuOpened"] = "Network Menu Opened";
  MetaMetricsEventName["NavSettingsOpened"] = "Settings Opened";
  MetaMetricsEventName["NavAccountSwitched"] = "Account Switched";
  MetaMetricsEventName["NavNetworkSwitched"] = "Network Switched";
  MetaMetricsEventName["NavBuyButtonClicked"] = "Buy Button Clicked";
  MetaMetricsEventName["NavSendButtonClicked"] = "Send Button Clicked";
  MetaMetricsEventName["NavSwapButtonClicked"] = "Swap Button Clicked";
  MetaMetricsEventName["NftAdded"] = "NFT Added";
  MetaMetricsEventName["OnboardingWelcome"] = "App Installed";
  MetaMetricsEventName["OnboardingWalletCreationStarted"] = "Wallet Setup Selected";
  MetaMetricsEventName["OnboardingWalletImportStarted"] = "Wallet Import Started";
  MetaMetricsEventName["OnboardingWalletCreationAttempted"] = "Wallet Password Created";
  MetaMetricsEventName["OnboardingWalletSecurityStarted"] = "SRP Backup Selected";
  MetaMetricsEventName["OnboardingWalletSecuritySkipInitiated"] = "SRP Skip Backup Selected";
  MetaMetricsEventName["OnboardingWalletSecuritySkipConfirmed"] = "SRP Backup Skipped";
  MetaMetricsEventName["OnboardingWalletSecuritySkipCanceled"] = "SRP Skip Backup Canceled";
  MetaMetricsEventName["OnboardingWalletSecurityPhraseRevealed"] = "SRP Revealed";
  MetaMetricsEventName["OnboardingWalletSecurityPhraseWrittenDown"] = "SRP Backup Confirm Display";
  MetaMetricsEventName["OnboardingWalletSecurityPhraseConfirmed"] = "SRP Backup Confirmed";
  MetaMetricsEventName["OnboardingWalletCreationComplete"] = "Wallet Created";
  MetaMetricsEventName["OnboardingWalletSetupComplete"] = "Application Opened";
  MetaMetricsEventName["OnboardingWalletAdvancedSettings"] = "Settings Updated";
  MetaMetricsEventName["OnboardingWalletImportAttempted"] = "Wallet Import Attempted";
  MetaMetricsEventName["OnboardingWalletVideoPlay"] = "SRP Intro Video Played";
  MetaMetricsEventName["OnboardingTwitterClick"] = "External Link Clicked";
  MetaMetricsEventName["OnrampProviderSelected"] = "On-ramp Provider Selected";
  MetaMetricsEventName["PermissionsApproved"] = "Permissions Approved";
  MetaMetricsEventName["PermissionsRejected"] = "Permissions Rejected";
  MetaMetricsEventName["PermissionsRequested"] = "Permissions Requested";
  MetaMetricsEventName["PhishingPageDisplayed"] = "Phishing Page Displayed";
  MetaMetricsEventName["PortfolioLinkClicked"] = "Portfolio Link Clicked";
  MetaMetricsEventName["ProviderMethodCalled"] = "Provider Method Called";
  MetaMetricsEventName["PublicAddressCopied"] = "Public Address Copied";
  MetaMetricsEventName["ServiceWorkerRestarted"] = "Service Worker Restarted";
  MetaMetricsEventName["SignatureApproved"] = "Signature Approved";
  MetaMetricsEventName["SignatureFailed"] = "Signature Failed";
  MetaMetricsEventName["SignatureRejected"] = "Signature Rejected";
  MetaMetricsEventName["SignatureRequested"] = "Signature Requested";
  MetaMetricsEventName["SrpRevealStarted"] = "Reveal SRP Initiated";
  MetaMetricsEventName["SrpRevealClicked"] = "Clicked Reveal Secret Recovery";
  MetaMetricsEventName["SrpRevealViewed"] = "Views Reveal Secret Recovery";
  MetaMetricsEventName["SrpRevealBackButtonClicked"] = "Clicked Back on Reveal SRP Password Page";
  MetaMetricsEventName["SrpRevealCancelled"] = "Reveal SRP Cancelled";
  MetaMetricsEventName["SrpRevealCancelButtonClicked"] = "Clicks Cancel on Reveal Secret Recovery Phrase Page";
  MetaMetricsEventName["SrpRevealCloseClicked"] = "Clicks CLOSE with SRP";
  MetaMetricsEventName["SrpRevealNextClicked"] = "Clicks Next on Reveal Secret Recovery Phrase";
  MetaMetricsEventName["SrpHoldToRevealClickStarted"] = "Reveal SRP Click Started";
  MetaMetricsEventName["SrpHoldToRevealCloseClicked"] = "Closes Hold To Reveal SRP";
  MetaMetricsEventName["SrpHoldToRevealCompleted"] = "Reveal SRP Completed";
  MetaMetricsEventName["SrpViewsSrpQR"] = "Views SRP QR Code";
  MetaMetricsEventName["SrpViewSrpText"] = "Views SRP";
  MetaMetricsEventName["SrpCopiedToClipboard"] = "Copies SRP to clipboard";
  MetaMetricsEventName["SrpToConfirmBackup"] = "SRP Backup Confirm Displayed";
  MetaMetricsEventName["SupportLinkClicked"] = "Support Link Clicked";
  MetaMetricsEventName["TermsOfUseShown"] = "Terms of Use Shown";
  MetaMetricsEventName["TermsOfUseAccepted"] = "Terms of Use Accepted";
  MetaMetricsEventName["TokenImportButtonClicked"] = "Import Token Button Clicked";
  MetaMetricsEventName["TokenScreenOpened"] = "Token Screen Opened";
  MetaMetricsEventName["TokenAdded"] = "Token Added";
  MetaMetricsEventName["TokenDetected"] = "Token Detected";
  MetaMetricsEventName["TokenHidden"] = "Token Hidden";
  MetaMetricsEventName["TokenImportCanceled"] = "Token Import Canceled";
  MetaMetricsEventName["TokenImportClicked"] = "Token Import Clicked";
  MetaMetricsEventName["WalletSetupStarted"] = "Wallet Setup Selected";
  MetaMetricsEventName["WalletSetupCanceled"] = "Wallet Setup Canceled";
  MetaMetricsEventName["WalletSetupFailed"] = "Wallet Setup Failed";
  MetaMetricsEventName["WalletCreated"] = "Wallet Created";
  MetaMetricsEventName["AccountDetailMenuOpened"] = "Account Details Menu Opened";
  MetaMetricsEventName["BlockExplorerLinkClicked"] = "Block Explorer Clicked";
  MetaMetricsEventName["AccountRemoved"] = "Account Removed";
  MetaMetricsEventName["TestNetworksDisplayed"] = "Test Networks Displayed";
  MetaMetricsEventName["AddNetworkButtonClick"] = "Add Network Button Clicked";
  MetaMetricsEventName["CustomNetworkAdded"] = "Custom Network Added";
  MetaMetricsEventName["TokenDetailsOpened"] = "Token Details Opened";
  MetaMetricsEventName["NftScreenOpened"] = "NFT Screen Opened";
  MetaMetricsEventName["ActivityScreenOpened"] = "Activity Screen Opened";
  MetaMetricsEventName["WhatsNewViewed"] = "What's New Viewed";
  MetaMetricsEventName["WhatsNewClicked"] = "What's New Link Clicked";
  return MetaMetricsEventName;
}({});
exports.MetaMetricsEventName = MetaMetricsEventName;
let MetaMetricsEventAccountType = /*#__PURE__*/function (MetaMetricsEventAccountType) {
  MetaMetricsEventAccountType["Default"] = "metamask";
  MetaMetricsEventAccountType["Hardware"] = "hardware";
  MetaMetricsEventAccountType["Imported"] = "imported";
  return MetaMetricsEventAccountType;
}({});
exports.MetaMetricsEventAccountType = MetaMetricsEventAccountType;
let MetaMetricsEventAccountImportType = /*#__PURE__*/function (MetaMetricsEventAccountImportType) {
  MetaMetricsEventAccountImportType["Json"] = "json";
  MetaMetricsEventAccountImportType["PrivateKey"] = "private_key";
  MetaMetricsEventAccountImportType["Srp"] = "srp";
  return MetaMetricsEventAccountImportType;
}({});
exports.MetaMetricsEventAccountImportType = MetaMetricsEventAccountImportType;
let MetaMetricsEventCategory = /*#__PURE__*/function (MetaMetricsEventCategory) {
  MetaMetricsEventCategory["Accounts"] = "Accounts";
  MetaMetricsEventCategory["App"] = "App";
  MetaMetricsEventCategory["Auth"] = "Auth";
  MetaMetricsEventCategory["Background"] = "Background";
  MetaMetricsEventCategory["Desktop"] = "Desktop";
  MetaMetricsEventCategory["Error"] = "Error";
  MetaMetricsEventCategory["Footer"] = "Footer";
  MetaMetricsEventCategory["Home"] = "Home";
  MetaMetricsEventCategory["InpageProvider"] = "inpage_provider";
  MetaMetricsEventCategory["Keys"] = "Keys";
  MetaMetricsEventCategory["Messages"] = "Messages";
  MetaMetricsEventCategory["Navigation"] = "Navigation";
  MetaMetricsEventCategory["Network"] = "Network";
  MetaMetricsEventCategory["Onboarding"] = "Onboarding";
  MetaMetricsEventCategory["Phishing"] = "Phishing";
  MetaMetricsEventCategory["Retention"] = "Retention";
  MetaMetricsEventCategory["ServiceWorkers"] = "service_workers";
  MetaMetricsEventCategory["Settings"] = "Settings";
  MetaMetricsEventCategory["Snaps"] = "Snaps";
  MetaMetricsEventCategory["Swaps"] = "Swaps";
  MetaMetricsEventCategory["Transactions"] = "Transactions";
  MetaMetricsEventCategory["Wallet"] = "Wallet";
  MetaMetricsEventCategory["Tokens"] = "Tokens";
  return MetaMetricsEventCategory;
}({});
exports.MetaMetricsEventCategory = MetaMetricsEventCategory;
let MetaMetricsEventLinkType = /*#__PURE__*/function (MetaMetricsEventLinkType) {
  MetaMetricsEventLinkType["AccountTracker"] = "Account Tracker";
  MetaMetricsEventLinkType["BlockExplorer"] = "Block Explorer";
  MetaMetricsEventLinkType["TokenTracker"] = "Token Tracker";
  MetaMetricsEventLinkType["TransactionBlockExplorer"] = "Transaction Block Explorer";
  return MetaMetricsEventLinkType;
}({});
exports.MetaMetricsEventLinkType = MetaMetricsEventLinkType;
let MetaMetricsEventKeyType = /*#__PURE__*/function (MetaMetricsEventKeyType) {
  MetaMetricsEventKeyType["Pkey"] = "private_key";
  MetaMetricsEventKeyType["Srp"] = "srp";
  return MetaMetricsEventKeyType;
}({}); // NOTE: This doesn't seem to be used at all
exports.MetaMetricsEventKeyType = MetaMetricsEventKeyType;
let MetaMetricsEventOnrampProviderType = /*#__PURE__*/function (MetaMetricsEventOnrampProviderType) {
  MetaMetricsEventOnrampProviderType["Coinbase"] = "coinbase";
  MetaMetricsEventOnrampProviderType["Moonpay"] = "moonpay";
  MetaMetricsEventOnrampProviderType["SelfDeposit"] = "direct_deposit";
  MetaMetricsEventOnrampProviderType["Transak"] = "transak";
  MetaMetricsEventOnrampProviderType["Wyre"] = "wyre";
  return MetaMetricsEventOnrampProviderType;
}({});
exports.MetaMetricsEventOnrampProviderType = MetaMetricsEventOnrampProviderType;
let MetaMetricsNetworkEventSource = /*#__PURE__*/function (MetaMetricsNetworkEventSource) {
  MetaMetricsNetworkEventSource["CustomNetworkForm"] = "custom_network_form";
  MetaMetricsNetworkEventSource["PopularNetworkList"] = "popular_network_list";
  MetaMetricsNetworkEventSource["Dapp"] = "dapp";
  return MetaMetricsNetworkEventSource;
}({});
exports.MetaMetricsNetworkEventSource = MetaMetricsNetworkEventSource;
let MetaMetricsSwapsEventSource = /*#__PURE__*/function (MetaMetricsSwapsEventSource) {
  MetaMetricsSwapsEventSource["MainView"] = "Main View";
  MetaMetricsSwapsEventSource["TokenView"] = "Token View";
  return MetaMetricsSwapsEventSource;
}({});
exports.MetaMetricsSwapsEventSource = MetaMetricsSwapsEventSource;
let MetaMetricsTokenEventSource = /*#__PURE__*/function (MetaMetricsTokenEventSource) {
  MetaMetricsTokenEventSource["Custom"] = "custom";
  MetaMetricsTokenEventSource["Dapp"] = "dapp";
  MetaMetricsTokenEventSource["Detected"] = "detected";
  MetaMetricsTokenEventSource["List"] = "list";
  return MetaMetricsTokenEventSource;
}({});
exports.MetaMetricsTokenEventSource = MetaMetricsTokenEventSource;
let MetaMetricsTransactionEventSource = /*#__PURE__*/function (MetaMetricsTransactionEventSource) {
  MetaMetricsTransactionEventSource["Dapp"] = "dapp";
  MetaMetricsTransactionEventSource["User"] = "user";
  return MetaMetricsTransactionEventSource;
}({});
exports.MetaMetricsTransactionEventSource = MetaMetricsTransactionEventSource;
let MetaMetricsEventLocation = /*#__PURE__*/function (MetaMetricsEventLocation) {
  MetaMetricsEventLocation["TokenDetails"] = "token_details";
  MetaMetricsEventLocation["TokenDetection"] = "token_detection";
  MetaMetricsEventLocation["TokenMenu"] = "token_menu";
  return MetaMetricsEventLocation;
}({});
exports.MetaMetricsEventLocation = MetaMetricsEventLocation;
let MetaMetricsEventUiCustomization = /*#__PURE__*/function (MetaMetricsEventUiCustomization) {
  MetaMetricsEventUiCustomization["FlaggedAsMalicious"] = "flagged_as_malicious";
  MetaMetricsEventUiCustomization["FlaggedAsSafetyUnknown"] = "flagged_as_safety_unknown";
  MetaMetricsEventUiCustomization["Siwe"] = "sign_in_with_ethereum";
  return MetaMetricsEventUiCustomization;
}({});
/**
 * Values that can used in the "properties" tracking object as keys, e.g. `{
 * location: 'Home' }`.
 */
exports.MetaMetricsEventUiCustomization = MetaMetricsEventUiCustomization;
let MetaMetricsContextProp = /*#__PURE__*/function (MetaMetricsContextProp) {
  MetaMetricsContextProp["PageTitle"] = "location";
  return MetaMetricsContextProp;
}({});
exports.MetaMetricsContextProp = MetaMetricsContextProp;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\metametrics.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\network.ts", {"lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cconstants%5Cnetwork.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.infuraProjectId = exports.getRpcUrl = exports.UNSUPPORTED_RPC_METHODS = exports.TEST_NETWORK_TICKER_MAP = exports.TEST_ETH_TOKEN_IMAGE_URL = exports.TEST_CHAINS = exports.SHOULD_SHOW_LINEA_TESTNET_NETWORK = exports.SEPOLIA_RPC_URL = exports.SEPOLIA_DISPLAY_NAME = exports.POLYGON_DISPLAY_NAME = exports.PALM_TOKEN_IMAGE_URL = exports.PALM_DISPLAY_NAME = exports.OPTIMISM_TOKEN_IMAGE_URL = exports.OPTIMISM_DISPLAY_NAME = exports.NetworkStatus = exports.NETWORK_TYPES = exports.NETWORK_TO_NAME_MAP = exports.NETWORK_NAMES = exports.NETWORK_ID_TO_ETHERS_NETWORK_NAME_MAP = exports.NETWORK_IDS = exports.NATIVE_CURRENCY_TOKEN_IMAGE_MAP = exports.MAX_SAFE_CHAIN_ID = exports.MATIC_TOKEN_IMAGE_URL = exports.MAINNET_RPC_URL = exports.MAINNET_DISPLAY_NAME = exports.LOCALHOST_RPC_URL = exports.LOCALHOST_DISPLAY_NAME = exports.LINEA_TESTNET_RPC_URL = exports.LINEA_TESTNET_DISPLAY_NAME = exports.IPFS_DEFAULT_GATEWAY_URL = exports.INFURA_PROVIDER_TYPES = exports.INFURA_BLOCKED_KEY = exports.HARMONY_ONE_TOKEN_IMAGE_URL = exports.HARMONY_DISPLAY_NAME = exports.GOERLI_RPC_URL = exports.GOERLI_DISPLAY_NAME = exports.FTM_TOKEN_IMAGE_URL = exports.FEATURED_RPCS = exports.FANTOM_DISPLAY_NAME = exports.ETH_TOKEN_IMAGE_URL = exports.ETHERSCAN_SUPPORTED_NETWORKS = exports.CURRENCY_SYMBOLS = exports.CHAIN_ID_TO_TYPE_MAP = exports.CHAIN_ID_TO_RPC_URL_MAP = exports.CHAIN_ID_TO_NETWORK_IMAGE_URL_MAP = exports.CHAIN_ID_TO_NETWORK_ID_MAP = exports.CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP = exports.CHAIN_IDS = exports.CELO_TOKEN_IMAGE_URL = exports.CELO_DISPLAY_NAME = exports.BUYABLE_CHAINS_MAP = exports.BUILT_IN_NETWORKS = exports.BUILT_IN_INFURA_NETWORKS = exports.BSC_DISPLAY_NAME = exports.BNB_TOKEN_IMAGE_URL = exports.BNB_DISPLAY_NAME = exports.AVAX_TOKEN_IMAGE_URL = exports.AVALANCHE_DISPLAY_NAME = exports.AURORA_TOKEN_IMAGE_URL = exports.AURORA_DISPLAY_NAME = exports.ARBITRUM_DISPLAY_NAME = exports.AETH_TOKEN_IMAGE_URL = void 0;
var _lodash = require("lodash");
/**
 * A type representing any valid value for 'type' for setProviderType and other
 * methods that add or manipulate networks in MetaMask state.
 */

/**
 * A union type of all possible hard-coded chain ids. This type is not
 * exhaustive and cannot be used for typing chainId in areas where the user or
 * dapp may specify any chainId.
 */

/**
 * A type that is a union type of all possible hardcoded currency symbols.
 * This type is non-exhaustive, and cannot be used for areas where the user
 * or dapp may supply their own symbol.
 */

/**
 * Test networks have special symbols that combine the network name and 'ETH'
 * so that they are distinct from mainnet and other networks that use 'ETH'.
 */

/**
 * An object containing preferences for an RPC definition
 */

/**
 * An object that describes a network to be used inside of MetaMask
 */

/**
 * For each chain that we support fiat onramps for, we provide a set of
 * configuration options that help for initializing the connectiong to the
 * onramp providers.
 */

/**
 * Throughout the extension we set the current provider by referencing its
 * "type", which can be any of the values in the below object. These values
 * represent the built-in networks of MetaMask, including test nets, as well
 * as "rpc" which is the "type" of a custom network added by the user or via
 * wallet_addEthereumChain.
 */
const NETWORK_TYPES = {
  GOERLI: 'goerli',
  LOCALHOST: 'localhost',
  MAINNET: 'mainnet',
  RPC: 'rpc',
  SEPOLIA: 'sepolia',
  LINEA_TESTNET: 'lineatestnet'
};

/**
 * An object containing shortcut names for any non-builtin network. We need
 * this to be able to differentiate between networks that require custom
 * sections of code for our various features, such as swaps or token lists.
 */
exports.NETWORK_TYPES = NETWORK_TYPES;
const NETWORK_NAMES = {
  HOMESTEAD: 'homestead'
};

/**
 * The Network ID for our builtin networks. This is the decimal equivalent of
 * the chain id for the network, but is expresssed as a string. Many moons ago
 * the decision was made on the extension team to expressly use chainId with
 * hex encoding over network id. Consider that when accessing this object. Note
 * for cross product purposes: alignment with mobile on this matter has not
 * been fully achieved, thus it is possible for some dependencies to still
 * ask for or require network id.
 */
exports.NETWORK_NAMES = NETWORK_NAMES;
const NETWORK_IDS = {
  MAINNET: '1',
  GOERLI: '5',
  LOCALHOST: '1337',
  SEPOLIA: '11155111',
  LINEA_TESTNET: '59140'
};

/**
 * An object containing all of the chain ids for networks both built in and
 * those that we have added custom code to support our feature set.
 */
exports.NETWORK_IDS = NETWORK_IDS;
const CHAIN_IDS = {
  MAINNET: '0x1',
  GOERLI: '0x5',
  LOCALHOST: '0x539',
  BSC: '0x38',
  BSC_TESTNET: '0x61',
  OPTIMISM: '0xa',
  OPTIMISM_TESTNET: '0x1a4',
  POLYGON: '0x89',
  POLYGON_TESTNET: '0x13881',
  AVALANCHE: '0xa86a',
  AVALANCHE_TESTNET: '0xa869',
  FANTOM: '0xfa',
  FANTOM_TESTNET: '0xfa2',
  CELO: '0xa4ec',
  ARBITRUM: '0xa4b1',
  HARMONY: '0x63564c40',
  PALM: '0x2a15c308d',
  SEPOLIA: '0xaa36a7',
  LINEA_TESTNET: '0xe704',
  AURORA: '0x4e454152',
  MOONBEAM: '0x504',
  MOONBEAM_TESTNET: '0x507',
  MOONRIVER: '0x505'
};

/**
 * The largest possible chain ID we can handle.
 * Explanation: https://gist.github.com/rekmarks/a47bd5f2525936c4b8eee31a16345553
 */
exports.CHAIN_IDS = CHAIN_IDS;
const MAX_SAFE_CHAIN_ID = 4503599627370476;
exports.MAX_SAFE_CHAIN_ID = MAX_SAFE_CHAIN_ID;
const MAINNET_DISPLAY_NAME = 'Ethereum Mainnet';
exports.MAINNET_DISPLAY_NAME = MAINNET_DISPLAY_NAME;
const GOERLI_DISPLAY_NAME = 'Goerli';
exports.GOERLI_DISPLAY_NAME = GOERLI_DISPLAY_NAME;
const SEPOLIA_DISPLAY_NAME = 'Sepolia';
exports.SEPOLIA_DISPLAY_NAME = SEPOLIA_DISPLAY_NAME;
const LINEA_TESTNET_DISPLAY_NAME = 'Linea Goerli test network';
exports.LINEA_TESTNET_DISPLAY_NAME = LINEA_TESTNET_DISPLAY_NAME;
const LOCALHOST_DISPLAY_NAME = 'Localhost 8545';
exports.LOCALHOST_DISPLAY_NAME = LOCALHOST_DISPLAY_NAME;
const BSC_DISPLAY_NAME = 'Binance Smart Chain';
exports.BSC_DISPLAY_NAME = BSC_DISPLAY_NAME;
const POLYGON_DISPLAY_NAME = 'Polygon';
exports.POLYGON_DISPLAY_NAME = POLYGON_DISPLAY_NAME;
const AVALANCHE_DISPLAY_NAME = 'Avalanche Network C-Chain';
exports.AVALANCHE_DISPLAY_NAME = AVALANCHE_DISPLAY_NAME;
const ARBITRUM_DISPLAY_NAME = 'Arbitrum One';
exports.ARBITRUM_DISPLAY_NAME = ARBITRUM_DISPLAY_NAME;
const BNB_DISPLAY_NAME = 'BNB Smart Chain (previously Binance Smart Chain Mainnet)';
exports.BNB_DISPLAY_NAME = BNB_DISPLAY_NAME;
const OPTIMISM_DISPLAY_NAME = 'Optimism';
exports.OPTIMISM_DISPLAY_NAME = OPTIMISM_DISPLAY_NAME;
const FANTOM_DISPLAY_NAME = 'Fantom Opera';
exports.FANTOM_DISPLAY_NAME = FANTOM_DISPLAY_NAME;
const HARMONY_DISPLAY_NAME = 'Harmony Mainnet Shard 0';
exports.HARMONY_DISPLAY_NAME = HARMONY_DISPLAY_NAME;
const PALM_DISPLAY_NAME = 'Palm';
exports.PALM_DISPLAY_NAME = PALM_DISPLAY_NAME;
const AURORA_DISPLAY_NAME = 'Aurora Mainnet';
exports.AURORA_DISPLAY_NAME = AURORA_DISPLAY_NAME;
const CELO_DISPLAY_NAME = 'Celo Mainnet';
exports.CELO_DISPLAY_NAME = CELO_DISPLAY_NAME;
const infuraProjectId = "a71ec5187858469f87e5e36080765f7d";
exports.infuraProjectId = infuraProjectId;
const getRpcUrl = ({
  network,
  excludeProjectId = false
}) => `https://${network}.infura.io/v3/${excludeProjectId ? '' : infuraProjectId}`;
exports.getRpcUrl = getRpcUrl;
const MAINNET_RPC_URL = getRpcUrl({
  network: NETWORK_TYPES.MAINNET
});
exports.MAINNET_RPC_URL = MAINNET_RPC_URL;
const GOERLI_RPC_URL = getRpcUrl({
  network: NETWORK_TYPES.GOERLI
});
exports.GOERLI_RPC_URL = GOERLI_RPC_URL;
const SEPOLIA_RPC_URL = getRpcUrl({
  network: NETWORK_TYPES.SEPOLIA
});
exports.SEPOLIA_RPC_URL = SEPOLIA_RPC_URL;
const LINEA_TESTNET_RPC_URL = 'https://rpc.goerli.linea.build';
exports.LINEA_TESTNET_RPC_URL = LINEA_TESTNET_RPC_URL;
const LOCALHOST_RPC_URL = 'http://localhost:8545';

/**
 * An object containing the token symbols for various tokens that are either
 * native currencies or those that have been special cased by the extension
 * for supporting our feature set.
 */
exports.LOCALHOST_RPC_URL = LOCALHOST_RPC_URL;
const CURRENCY_SYMBOLS = {
  ARBITRUM: 'ETH',
  AURORA_ETH: 'AURORA ETH',
  AVALANCHE: 'AVAX',
  BNB: 'BNB',
  BUSD: 'BUSD',
  CELO: 'CELO',
  DAI: 'DAI',
  ETH: 'ETH',
  FANTOM: 'FTM',
  HARMONY: 'ONE',
  PALM: 'PALM',
  MATIC: 'MATIC',
  TEST_ETH: 'TESTETH',
  USDC: 'USDC',
  USDT: 'USDT',
  WETH: 'WETH',
  OPTIMISM: 'OP'
};
exports.CURRENCY_SYMBOLS = CURRENCY_SYMBOLS;
const ETH_TOKEN_IMAGE_URL = './images/eth_logo.png';
exports.ETH_TOKEN_IMAGE_URL = ETH_TOKEN_IMAGE_URL;
const TEST_ETH_TOKEN_IMAGE_URL = './images/black-eth-logo.svg';
exports.TEST_ETH_TOKEN_IMAGE_URL = TEST_ETH_TOKEN_IMAGE_URL;
const BNB_TOKEN_IMAGE_URL = './images/bnb.png';
exports.BNB_TOKEN_IMAGE_URL = BNB_TOKEN_IMAGE_URL;
const MATIC_TOKEN_IMAGE_URL = './images/matic-token.png';
exports.MATIC_TOKEN_IMAGE_URL = MATIC_TOKEN_IMAGE_URL;
const AVAX_TOKEN_IMAGE_URL = './images/avax-token.png';
exports.AVAX_TOKEN_IMAGE_URL = AVAX_TOKEN_IMAGE_URL;
const AETH_TOKEN_IMAGE_URL = './images/arbitrum.svg';
exports.AETH_TOKEN_IMAGE_URL = AETH_TOKEN_IMAGE_URL;
const FTM_TOKEN_IMAGE_URL = './images/fantom-opera.svg';
exports.FTM_TOKEN_IMAGE_URL = FTM_TOKEN_IMAGE_URL;
const HARMONY_ONE_TOKEN_IMAGE_URL = './images/harmony-one.svg';
exports.HARMONY_ONE_TOKEN_IMAGE_URL = HARMONY_ONE_TOKEN_IMAGE_URL;
const OPTIMISM_TOKEN_IMAGE_URL = './images/optimism.svg';
exports.OPTIMISM_TOKEN_IMAGE_URL = OPTIMISM_TOKEN_IMAGE_URL;
const PALM_TOKEN_IMAGE_URL = './images/palm.svg';
exports.PALM_TOKEN_IMAGE_URL = PALM_TOKEN_IMAGE_URL;
const AURORA_TOKEN_IMAGE_URL = './images/aurora.png';
exports.AURORA_TOKEN_IMAGE_URL = AURORA_TOKEN_IMAGE_URL;
const CELO_TOKEN_IMAGE_URL = './images/celo.svg';
exports.CELO_TOKEN_IMAGE_URL = CELO_TOKEN_IMAGE_URL;
const INFURA_PROVIDER_TYPES = [NETWORK_TYPES.MAINNET, NETWORK_TYPES.GOERLI, NETWORK_TYPES.SEPOLIA];
exports.INFURA_PROVIDER_TYPES = INFURA_PROVIDER_TYPES;
const TEST_CHAINS = [CHAIN_IDS.GOERLI, CHAIN_IDS.SEPOLIA, CHAIN_IDS.LINEA_TESTNET, CHAIN_IDS.LOCALHOST];
exports.TEST_CHAINS = TEST_CHAINS;
const typedCapitalize = k => (0, _lodash.capitalize)(k);
const TEST_NETWORK_TICKER_MAP = {
  [NETWORK_TYPES.GOERLI]: `${typedCapitalize(NETWORK_TYPES.GOERLI)}${CURRENCY_SYMBOLS.ETH}`,
  [NETWORK_TYPES.SEPOLIA]: `${typedCapitalize(NETWORK_TYPES.SEPOLIA)}${CURRENCY_SYMBOLS.ETH}`,
  [NETWORK_TYPES.LINEA_TESTNET]: `Linea${CURRENCY_SYMBOLS.ETH}`
};

/**
 * Map of all build-in Infura networks to their network, ticker and chain IDs.
 */
exports.TEST_NETWORK_TICKER_MAP = TEST_NETWORK_TICKER_MAP;
const BUILT_IN_NETWORKS = {
  [NETWORK_TYPES.GOERLI]: {
    networkId: NETWORK_IDS.GOERLI,
    chainId: CHAIN_IDS.GOERLI,
    ticker: TEST_NETWORK_TICKER_MAP[NETWORK_TYPES.GOERLI],
    blockExplorerUrl: `https://${NETWORK_TYPES.GOERLI}.etherscan.io`
  },
  [NETWORK_TYPES.SEPOLIA]: {
    networkId: NETWORK_IDS.SEPOLIA,
    chainId: CHAIN_IDS.SEPOLIA,
    ticker: TEST_NETWORK_TICKER_MAP[NETWORK_TYPES.SEPOLIA],
    blockExplorerUrl: `https://${NETWORK_TYPES.SEPOLIA}.etherscan.io`
  },
  [NETWORK_TYPES.LINEA_TESTNET]: {
    networkId: NETWORK_IDS.LINEA_TESTNET,
    chainId: CHAIN_IDS.LINEA_TESTNET,
    ticker: TEST_NETWORK_TICKER_MAP[NETWORK_TYPES.LINEA_TESTNET],
    blockExplorerUrl: 'https://explorer.goerli.linea.build'
  },
  [NETWORK_TYPES.MAINNET]: {
    networkId: NETWORK_IDS.MAINNET,
    chainId: CHAIN_IDS.MAINNET,
    blockExplorerUrl: `https://etherscan.io`
  },
  [NETWORK_TYPES.LOCALHOST]: {
    networkId: NETWORK_IDS.LOCALHOST,
    chainId: CHAIN_IDS.LOCALHOST
  }
};
exports.BUILT_IN_NETWORKS = BUILT_IN_NETWORKS;
const BUILT_IN_INFURA_NETWORKS = (0, _lodash.pick)(BUILT_IN_NETWORKS, INFURA_PROVIDER_TYPES);
exports.BUILT_IN_INFURA_NETWORKS = BUILT_IN_INFURA_NETWORKS;
const NETWORK_TO_NAME_MAP = {
  [NETWORK_TYPES.MAINNET]: MAINNET_DISPLAY_NAME,
  [NETWORK_TYPES.GOERLI]: GOERLI_DISPLAY_NAME,
  [NETWORK_TYPES.SEPOLIA]: SEPOLIA_DISPLAY_NAME,
  [NETWORK_TYPES.LINEA_TESTNET]: LINEA_TESTNET_DISPLAY_NAME,
  [NETWORK_TYPES.LOCALHOST]: LOCALHOST_DISPLAY_NAME,
  [NETWORK_IDS.GOERLI]: GOERLI_DISPLAY_NAME,
  [NETWORK_IDS.SEPOLIA]: SEPOLIA_DISPLAY_NAME,
  [NETWORK_IDS.LINEA_TESTNET]: LINEA_TESTNET_DISPLAY_NAME,
  [NETWORK_IDS.MAINNET]: MAINNET_DISPLAY_NAME,
  [NETWORK_IDS.LOCALHOST]: LOCALHOST_DISPLAY_NAME,
  [CHAIN_IDS.GOERLI]: GOERLI_DISPLAY_NAME,
  [CHAIN_IDS.SEPOLIA]: SEPOLIA_DISPLAY_NAME,
  [CHAIN_IDS.LINEA_TESTNET]: LINEA_TESTNET_DISPLAY_NAME,
  [CHAIN_IDS.MAINNET]: MAINNET_DISPLAY_NAME,
  [CHAIN_IDS.LOCALHOST]: LOCALHOST_DISPLAY_NAME
};
exports.NETWORK_TO_NAME_MAP = NETWORK_TO_NAME_MAP;
const CHAIN_ID_TO_TYPE_MAP = {
  [CHAIN_IDS.MAINNET]: NETWORK_TYPES.MAINNET,
  [CHAIN_IDS.GOERLI]: NETWORK_TYPES.GOERLI,
  [CHAIN_IDS.SEPOLIA]: NETWORK_TYPES.SEPOLIA,
  [CHAIN_IDS.LINEA_TESTNET]: NETWORK_TYPES.LINEA_TESTNET,
  [CHAIN_IDS.LOCALHOST]: NETWORK_TYPES.LOCALHOST
};
exports.CHAIN_ID_TO_TYPE_MAP = CHAIN_ID_TO_TYPE_MAP;
const CHAIN_ID_TO_RPC_URL_MAP = {
  [CHAIN_IDS.GOERLI]: GOERLI_RPC_URL,
  [CHAIN_IDS.SEPOLIA]: SEPOLIA_RPC_URL,
  [CHAIN_IDS.LINEA_TESTNET]: LINEA_TESTNET_RPC_URL,
  [CHAIN_IDS.MAINNET]: MAINNET_RPC_URL,
  [CHAIN_IDS.LOCALHOST]: LOCALHOST_RPC_URL
};
exports.CHAIN_ID_TO_RPC_URL_MAP = CHAIN_ID_TO_RPC_URL_MAP;
const CHAIN_ID_TO_NETWORK_IMAGE_URL_MAP = {
  [CHAIN_IDS.MAINNET]: ETH_TOKEN_IMAGE_URL,
  [CHAIN_IDS.AVALANCHE]: AVAX_TOKEN_IMAGE_URL,
  [CHAIN_IDS.BSC]: BNB_TOKEN_IMAGE_URL,
  [CHAIN_IDS.POLYGON]: MATIC_TOKEN_IMAGE_URL,
  [CHAIN_IDS.ARBITRUM]: AETH_TOKEN_IMAGE_URL,
  [CHAIN_IDS.FANTOM]: FTM_TOKEN_IMAGE_URL,
  [CHAIN_IDS.HARMONY]: HARMONY_ONE_TOKEN_IMAGE_URL,
  [CHAIN_IDS.OPTIMISM]: OPTIMISM_TOKEN_IMAGE_URL,
  [CHAIN_IDS.PALM]: PALM_TOKEN_IMAGE_URL,
  [CHAIN_IDS.AURORA]: AURORA_TOKEN_IMAGE_URL,
  [CHAIN_IDS.CELO]: CELO_TOKEN_IMAGE_URL
};
exports.CHAIN_ID_TO_NETWORK_IMAGE_URL_MAP = CHAIN_ID_TO_NETWORK_IMAGE_URL_MAP;
const NETWORK_ID_TO_ETHERS_NETWORK_NAME_MAP = {
  [NETWORK_IDS.GOERLI]: NETWORK_TYPES.GOERLI,
  [NETWORK_IDS.SEPOLIA]: NETWORK_TYPES.SEPOLIA,
  [NETWORK_IDS.LINEA_TESTNET]: NETWORK_TYPES.LINEA_TESTNET,
  [NETWORK_IDS.MAINNET]: NETWORK_NAMES.HOMESTEAD
};
exports.NETWORK_ID_TO_ETHERS_NETWORK_NAME_MAP = NETWORK_ID_TO_ETHERS_NETWORK_NAME_MAP;
const CHAIN_ID_TO_NETWORK_ID_MAP = {
  [CHAIN_IDS.MAINNET]: NETWORK_IDS.MAINNET,
  [CHAIN_IDS.GOERLI]: NETWORK_IDS.GOERLI,
  [CHAIN_IDS.SEPOLIA]: NETWORK_IDS.SEPOLIA,
  [CHAIN_IDS.LINEA_TESTNET]: NETWORK_IDS.LINEA_TESTNET,
  [CHAIN_IDS.LOCALHOST]: NETWORK_IDS.LOCALHOST
};
exports.CHAIN_ID_TO_NETWORK_ID_MAP = CHAIN_ID_TO_NETWORK_ID_MAP;
const NATIVE_CURRENCY_TOKEN_IMAGE_MAP = {
  [CURRENCY_SYMBOLS.ETH]: ETH_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.TEST_ETH]: TEST_ETH_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.BNB]: BNB_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.MATIC]: MATIC_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.AVALANCHE]: AVAX_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.OPTIMISM]: OPTIMISM_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.CELO]: CELO_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.AURORA_ETH]: ETH_TOKEN_IMAGE_URL
};
exports.NATIVE_CURRENCY_TOKEN_IMAGE_MAP = NATIVE_CURRENCY_TOKEN_IMAGE_MAP;
const INFURA_BLOCKED_KEY = 'countryBlocked';
exports.INFURA_BLOCKED_KEY = INFURA_BLOCKED_KEY;
const defaultEtherscanDomain = 'etherscan.io';
const defaultEtherscanSubdomainPrefix = 'api';
/**
 * Map of all Etherscan supported networks.
 */
const ETHERSCAN_SUPPORTED_NETWORKS = {
  [CHAIN_IDS.GOERLI]: {
    domain: defaultEtherscanDomain,
    subdomain: `${defaultEtherscanSubdomainPrefix}-${CHAIN_ID_TO_TYPE_MAP[CHAIN_IDS.GOERLI]}`,
    networkId: CHAIN_ID_TO_NETWORK_ID_MAP[CHAIN_IDS.GOERLI]
  },
  [CHAIN_IDS.MAINNET]: {
    domain: defaultEtherscanDomain,
    subdomain: defaultEtherscanSubdomainPrefix,
    networkId: CHAIN_ID_TO_NETWORK_ID_MAP[CHAIN_IDS.MAINNET]
  },
  [CHAIN_IDS.SEPOLIA]: {
    domain: defaultEtherscanDomain,
    subdomain: `${defaultEtherscanSubdomainPrefix}-${CHAIN_ID_TO_TYPE_MAP[CHAIN_IDS.SEPOLIA]}`,
    networkId: CHAIN_ID_TO_NETWORK_ID_MAP[CHAIN_IDS.SEPOLIA]
  },
  [CHAIN_IDS.LINEA_TESTNET]: {
    domain: 'linea.build',
    subdomain: 'explorer.goerli',
    networkId: CHAIN_ID_TO_NETWORK_ID_MAP[CHAIN_IDS.LINEA_TESTNET]
  },
  [CHAIN_IDS.BSC]: {
    domain: 'bscscan.com',
    subdomain: defaultEtherscanSubdomainPrefix,
    networkId: parseInt(CHAIN_IDS.BSC, 16).toString()
  },
  [CHAIN_IDS.BSC_TESTNET]: {
    domain: 'bscscan.com',
    subdomain: `${defaultEtherscanSubdomainPrefix}-testnet`,
    networkId: parseInt(CHAIN_IDS.BSC_TESTNET, 16).toString()
  },
  [CHAIN_IDS.OPTIMISM]: {
    domain: defaultEtherscanDomain,
    subdomain: `${defaultEtherscanSubdomainPrefix}-optimistic`,
    networkId: parseInt(CHAIN_IDS.OPTIMISM, 16).toString()
  },
  [CHAIN_IDS.OPTIMISM_TESTNET]: {
    domain: defaultEtherscanDomain,
    subdomain: `${defaultEtherscanSubdomainPrefix}-goerli-optimistic`,
    networkId: parseInt(CHAIN_IDS.OPTIMISM_TESTNET, 16).toString()
  },
  [CHAIN_IDS.POLYGON]: {
    domain: 'polygonscan.com',
    subdomain: defaultEtherscanSubdomainPrefix,
    networkId: parseInt(CHAIN_IDS.POLYGON, 16).toString()
  },
  [CHAIN_IDS.POLYGON_TESTNET]: {
    domain: 'polygonscan.com',
    subdomain: `${defaultEtherscanSubdomainPrefix}-mumbai`,
    networkId: parseInt(CHAIN_IDS.POLYGON_TESTNET, 16).toString()
  },
  [CHAIN_IDS.AVALANCHE]: {
    domain: 'snowtrace.io',
    subdomain: defaultEtherscanSubdomainPrefix,
    networkId: parseInt(CHAIN_IDS.AVALANCHE, 16).toString()
  },
  [CHAIN_IDS.AVALANCHE_TESTNET]: {
    domain: 'snowtrace.io',
    subdomain: `${defaultEtherscanSubdomainPrefix}-testnet`,
    networkId: parseInt(CHAIN_IDS.AVALANCHE_TESTNET, 16).toString()
  },
  [CHAIN_IDS.FANTOM]: {
    domain: 'ftmscan.com',
    subdomain: defaultEtherscanSubdomainPrefix,
    networkId: parseInt(CHAIN_IDS.FANTOM, 16).toString()
  },
  [CHAIN_IDS.FANTOM_TESTNET]: {
    domain: 'ftmscan.com',
    subdomain: `${defaultEtherscanSubdomainPrefix}-testnet`,
    networkId: parseInt(CHAIN_IDS.FANTOM_TESTNET, 16).toString()
  },
  [CHAIN_IDS.MOONBEAM]: {
    domain: 'moonscan.io',
    subdomain: `${defaultEtherscanSubdomainPrefix}-moonbeam`,
    networkId: parseInt(CHAIN_IDS.MOONBEAM, 16).toString()
  },
  [CHAIN_IDS.MOONBEAM_TESTNET]: {
    domain: 'moonscan.io',
    subdomain: `${defaultEtherscanSubdomainPrefix}-moonbase`,
    networkId: parseInt(CHAIN_IDS.MOONBEAM_TESTNET, 16).toString()
  },
  [CHAIN_IDS.MOONRIVER]: {
    domain: 'moonscan.io',
    subdomain: `${defaultEtherscanSubdomainPrefix}-moonriver`,
    networkId: parseInt(CHAIN_IDS.MOONRIVER, 16).toString()
  }
};
exports.ETHERSCAN_SUPPORTED_NETWORKS = ETHERSCAN_SUPPORTED_NETWORKS;
const CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP = {
  [CHAIN_IDS.OPTIMISM]: 1,
  [CHAIN_IDS.OPTIMISM_TESTNET]: 1
};

/**
 * Ethereum JSON-RPC methods that are known to exist but that we intentionally
 * do not support.
 */
exports.CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP = CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP;
const UNSUPPORTED_RPC_METHODS = new Set([
// This is implemented later in our middleware stack  specifically, in
// eth-json-rpc-middleware  but our UI does not support it.
'eth_signTransaction']);
exports.UNSUPPORTED_RPC_METHODS = UNSUPPORTED_RPC_METHODS;
const IPFS_DEFAULT_GATEWAY_URL = 'dweb.link';

// The first item in transakCurrencies must be the
// default crypto currency for the network
exports.IPFS_DEFAULT_GATEWAY_URL = IPFS_DEFAULT_GATEWAY_URL;
const BUYABLE_CHAIN_ETHEREUM_NETWORK_NAME = 'ethereum';
const BUYABLE_CHAINS_MAP = {
  [CHAIN_IDS.MAINNET]: {
    nativeCurrency: CURRENCY_SYMBOLS.ETH,
    network: BUYABLE_CHAIN_ETHEREUM_NETWORK_NAME
  },
  [CHAIN_IDS.SEPOLIA]: {
    nativeCurrency: TEST_NETWORK_TICKER_MAP[NETWORK_TYPES.SEPOLIA],
    network: BUYABLE_CHAIN_ETHEREUM_NETWORK_NAME
  },
  [CHAIN_IDS.BSC]: {
    nativeCurrency: CURRENCY_SYMBOLS.BNB,
    network: 'bsc'
  },
  [CHAIN_IDS.POLYGON]: {
    nativeCurrency: CURRENCY_SYMBOLS.MATIC,
    network: 'polygon'
  },
  [CHAIN_IDS.AVALANCHE]: {
    nativeCurrency: CURRENCY_SYMBOLS.AVALANCHE,
    network: 'avaxcchain'
  },
  [CHAIN_IDS.FANTOM]: {
    nativeCurrency: CURRENCY_SYMBOLS.FANTOM,
    network: 'fantom'
  },
  [CHAIN_IDS.CELO]: {
    nativeCurrency: CURRENCY_SYMBOLS.CELO,
    network: 'celo'
  },
  [CHAIN_IDS.OPTIMISM]: {
    nativeCurrency: CURRENCY_SYMBOLS.ETH,
    network: 'optimism'
  },
  [CHAIN_IDS.ARBITRUM]: {
    nativeCurrency: CURRENCY_SYMBOLS.ARBITRUM,
    network: 'arbitrum'
  }
};
exports.BUYABLE_CHAINS_MAP = BUYABLE_CHAINS_MAP;
const FEATURED_RPCS = [{
  chainId: CHAIN_IDS.ARBITRUM,
  nickname: ARBITRUM_DISPLAY_NAME,
  rpcUrl: `https://arbitrum-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.ARBITRUM,
  rpcPrefs: {
    blockExplorerUrl: 'https://explorer.arbitrum.io',
    imageUrl: AETH_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.AURORA,
  nickname: AURORA_DISPLAY_NAME,
  rpcUrl: `https://aurora-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.AURORA_ETH,
  rpcPrefs: {
    blockExplorerUrl: 'https://aurorascan.dev/',
    imageUrl: AURORA_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.AVALANCHE,
  nickname: AVALANCHE_DISPLAY_NAME,
  rpcUrl: `https://avalanche-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.AVALANCHE,
  rpcPrefs: {
    blockExplorerUrl: 'https://snowtrace.io/',
    imageUrl: AVAX_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.BSC,
  nickname: BNB_DISPLAY_NAME,
  rpcUrl: 'https://bsc-dataseed.binance.org/',
  ticker: CURRENCY_SYMBOLS.BNB,
  rpcPrefs: {
    blockExplorerUrl: 'https://bscscan.com/',
    imageUrl: BNB_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.FANTOM,
  nickname: FANTOM_DISPLAY_NAME,
  rpcUrl: 'https://rpc.ftm.tools/',
  ticker: CURRENCY_SYMBOLS.FANTOM,
  rpcPrefs: {
    blockExplorerUrl: 'https://ftmscan.com/',
    imageUrl: FTM_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.HARMONY,
  nickname: HARMONY_DISPLAY_NAME,
  rpcUrl: 'https://api.harmony.one/',
  ticker: CURRENCY_SYMBOLS.HARMONY,
  rpcPrefs: {
    blockExplorerUrl: 'https://explorer.harmony.one/',
    imageUrl: HARMONY_ONE_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.OPTIMISM,
  nickname: OPTIMISM_DISPLAY_NAME,
  rpcUrl: `https://optimism-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.ETH,
  rpcPrefs: {
    blockExplorerUrl: 'https://optimistic.etherscan.io/',
    imageUrl: OPTIMISM_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.PALM,
  nickname: PALM_DISPLAY_NAME,
  rpcUrl: `https://palm-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.PALM,
  rpcPrefs: {
    blockExplorerUrl: 'https://explorer.palm.io/',
    imageUrl: PALM_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.POLYGON,
  nickname: `${POLYGON_DISPLAY_NAME} ${(0, _lodash.capitalize)(NETWORK_TYPES.MAINNET)}`,
  rpcUrl: `https://polygon-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.MATIC,
  rpcPrefs: {
    blockExplorerUrl: 'https://polygonscan.com/',
    imageUrl: MATIC_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.CELO,
  nickname: CELO_DISPLAY_NAME,
  rpcUrl: `https://celo-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.CELO,
  rpcPrefs: {
    blockExplorerUrl: 'https://celoscan.io',
    imageUrl: CELO_TOKEN_IMAGE_URL
  }
}];
exports.FEATURED_RPCS = FEATURED_RPCS;
const SHOULD_SHOW_LINEA_TESTNET_NETWORK = new Date().getTime() > Date.UTC(2023, 2, 28, 8);

/**
 * Represents the availability state of the currently selected network.
 */
exports.SHOULD_SHOW_LINEA_TESTNET_NETWORK = SHOULD_SHOW_LINEA_TESTNET_NETWORK;
let NetworkStatus = /*#__PURE__*/function (NetworkStatus) {
  NetworkStatus["Unknown"] = "unknown";
  NetworkStatus["Available"] = "available";
  NetworkStatus["Unavailable"] = "unavailable";
  NetworkStatus["Blocked"] = "blocked";
  return NetworkStatus;
}({});
exports.NetworkStatus = NetworkStatus;


      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\network.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\permissions.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cconstants%5Cpermissions.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RestrictedMethods = exports.CaveatTypes = void 0;
const CaveatTypes = Object.freeze({
  restrictReturnedAccounts: 'restrictReturnedAccounts'
});
exports.CaveatTypes = CaveatTypes;
const RestrictedMethods = Object.freeze({
  eth_accounts: 'eth_accounts'
});
exports.RestrictedMethods = RestrictedMethods;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\permissions.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\preferences.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cconstants%5Cpreferences.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ThemeType = void 0;
let ThemeType = /*#__PURE__*/function (ThemeType) {
  ThemeType["light"] = "light";
  ThemeType["dark"] = "dark";
  ThemeType["os"] = "os";
  return ThemeType;
}({});
exports.ThemeType = ThemeType;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\preferences.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\swaps.ts", {"./network":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\network.ts"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cconstants%5Cswaps.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WMATIC_CONTRACT_ADDRESS = exports.WETH_OPTIMISM_CONTRACT_ADDRESS = exports.WETH_GOERLI_CONTRACT_ADDRESS = exports.WETH_CONTRACT_ADDRESS = exports.WETH_ARBITRUM_CONTRACT_ADDRESS = exports.WBNB_CONTRACT_ADDRESS = exports.WAVAX_CONTRACT_ADDRESS = exports.TokenBucketPriority = exports.TEST_ETH_SWAPS_TOKEN_OBJECT = exports.Slippage = exports.SWAP_FAILED_ERROR = exports.SWAPS_WRAPPED_TOKENS_ADDRESSES = exports.SWAPS_FETCH_ORDER_CONFLICT = exports.SWAPS_DEV_API_V2_BASE_URL = exports.SWAPS_CLIENT_ID = exports.SWAPS_CHAINID_DEFAULT_TOKEN_MAP = exports.SWAPS_CHAINID_DEFAULT_BLOCK_EXPLORER_URL_MAP = exports.SWAPS_CHAINID_CONTRACT_ADDRESS_MAP = exports.SWAPS_API_V2_BASE_URL = exports.QUOTES_NOT_AVAILABLE_ERROR = exports.QUOTES_EXPIRED_ERROR = exports.POLYGON = exports.OPTIMISM_SWAPS_TOKEN_OBJECT = exports.OPTIMISM = exports.OFFLINE_FOR_MAINTENANCE = exports.MATIC_SWAPS_TOKEN_OBJECT = exports.GOERLI_SWAPS_TOKEN_OBJECT = exports.GOERLI = exports.GAS_DEV_API_BASE_URL = exports.GAS_API_BASE_URL = exports.ETH_SWAPS_TOKEN_OBJECT = exports.ETHEREUM = exports.ERROR_FETCHING_QUOTES = exports.DEFAULT_ERC20_APPROVE_GAS = exports.CONTRACT_DATA_DISABLED_ERROR = exports.BSC = exports.BNB_SWAPS_TOKEN_OBJECT = exports.AVAX_SWAPS_TOKEN_OBJECT = exports.AVALANCHE = exports.ARBITRUM_SWAPS_TOKEN_OBJECT = exports.ARBITRUM = exports.ALLOWED_SMART_TRANSACTIONS_CHAIN_IDS = exports.ALLOWED_PROD_SWAPS_CHAIN_IDS = exports.ALLOWED_DEV_SWAPS_CHAIN_IDS = exports.ALLOWED_CONTRACT_ADDRESSES = void 0;
var _network = require("./network");
const QUOTES_EXPIRED_ERROR = 'quotes-expired';
exports.QUOTES_EXPIRED_ERROR = QUOTES_EXPIRED_ERROR;
const SWAP_FAILED_ERROR = 'swap-failed-error';
exports.SWAP_FAILED_ERROR = SWAP_FAILED_ERROR;
const ERROR_FETCHING_QUOTES = 'error-fetching-quotes';
exports.ERROR_FETCHING_QUOTES = ERROR_FETCHING_QUOTES;
const QUOTES_NOT_AVAILABLE_ERROR = 'quotes-not-avilable';
exports.QUOTES_NOT_AVAILABLE_ERROR = QUOTES_NOT_AVAILABLE_ERROR;
const CONTRACT_DATA_DISABLED_ERROR = 'contract-data-disabled';
exports.CONTRACT_DATA_DISABLED_ERROR = CONTRACT_DATA_DISABLED_ERROR;
const OFFLINE_FOR_MAINTENANCE = 'offline-for-maintenance';
exports.OFFLINE_FOR_MAINTENANCE = OFFLINE_FOR_MAINTENANCE;
const SWAPS_FETCH_ORDER_CONFLICT = 'swaps-fetch-order-conflict';

// An address that the metaswap-api recognizes as the default token for the current network,
// in place of the token address that ERC-20 tokens have
exports.SWAPS_FETCH_ORDER_CONFLICT = SWAPS_FETCH_ORDER_CONFLICT;
const DEFAULT_TOKEN_ADDRESS = '0x0000000000000000000000000000000000000000';
const ETH_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.ETH,
  name: 'Ether',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.ETH_TOKEN_IMAGE_URL
};
exports.ETH_SWAPS_TOKEN_OBJECT = ETH_SWAPS_TOKEN_OBJECT;
const BNB_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.BNB,
  name: 'Binance Coin',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.BNB_TOKEN_IMAGE_URL
};
exports.BNB_SWAPS_TOKEN_OBJECT = BNB_SWAPS_TOKEN_OBJECT;
const MATIC_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.MATIC,
  name: 'Matic',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.MATIC_TOKEN_IMAGE_URL
};
exports.MATIC_SWAPS_TOKEN_OBJECT = MATIC_SWAPS_TOKEN_OBJECT;
const AVAX_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.AVALANCHE,
  name: 'Avalanche',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.AVAX_TOKEN_IMAGE_URL
};
exports.AVAX_SWAPS_TOKEN_OBJECT = AVAX_SWAPS_TOKEN_OBJECT;
const TEST_ETH_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.TEST_ETH,
  name: 'Test Ether',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.TEST_ETH_TOKEN_IMAGE_URL
};
exports.TEST_ETH_SWAPS_TOKEN_OBJECT = TEST_ETH_SWAPS_TOKEN_OBJECT;
const GOERLI_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.ETH,
  name: 'Ether',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.TEST_ETH_TOKEN_IMAGE_URL
};
exports.GOERLI_SWAPS_TOKEN_OBJECT = GOERLI_SWAPS_TOKEN_OBJECT;
const ARBITRUM_SWAPS_TOKEN_OBJECT = {
  ...ETH_SWAPS_TOKEN_OBJECT
};
exports.ARBITRUM_SWAPS_TOKEN_OBJECT = ARBITRUM_SWAPS_TOKEN_OBJECT;
const OPTIMISM_SWAPS_TOKEN_OBJECT = {
  ...ETH_SWAPS_TOKEN_OBJECT
};

// A gas value for ERC20 approve calls that should be sufficient for all ERC20 approve implementations
exports.OPTIMISM_SWAPS_TOKEN_OBJECT = OPTIMISM_SWAPS_TOKEN_OBJECT;
const DEFAULT_ERC20_APPROVE_GAS = '0x1d4c0';

// Contract addresses below should be in lowercase.
exports.DEFAULT_ERC20_APPROVE_GAS = DEFAULT_ERC20_APPROVE_GAS;
const MAINNET_CONTRACT_ADDRESS = '0x881d40237659c251811cec9c364ef91dc08d300c';
const TESTNET_CONTRACT_ADDRESS = '0x881d40237659c251811cec9c364ef91dc08d300c';
const BSC_CONTRACT_ADDRESS = '0x1a1ec25dc08e98e5e93f1104b5e5cdd298707d31';
const POLYGON_CONTRACT_ADDRESS = '0x1a1ec25dc08e98e5e93f1104b5e5cdd298707d31';
const AVALANCHE_CONTRACT_ADDRESS = '0x1a1ec25dc08e98e5e93f1104b5e5cdd298707d31';
const OPTIMISM_CONTRACT_ADDRESS = '0x9dda6ef3d919c9bc8885d5560999a3640431e8e6';
const ARBITRUM_CONTRACT_ADDRESS = '0x9dda6ef3d919c9bc8885d5560999a3640431e8e6';
const WETH_CONTRACT_ADDRESS = '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2';
exports.WETH_CONTRACT_ADDRESS = WETH_CONTRACT_ADDRESS;
const WETH_GOERLI_CONTRACT_ADDRESS = '0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6';
exports.WETH_GOERLI_CONTRACT_ADDRESS = WETH_GOERLI_CONTRACT_ADDRESS;
const WBNB_CONTRACT_ADDRESS = '0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c';
exports.WBNB_CONTRACT_ADDRESS = WBNB_CONTRACT_ADDRESS;
const WMATIC_CONTRACT_ADDRESS = '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270';
exports.WMATIC_CONTRACT_ADDRESS = WMATIC_CONTRACT_ADDRESS;
const WAVAX_CONTRACT_ADDRESS = '0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7';
exports.WAVAX_CONTRACT_ADDRESS = WAVAX_CONTRACT_ADDRESS;
const WETH_OPTIMISM_CONTRACT_ADDRESS = '0x4200000000000000000000000000000000000006';
exports.WETH_OPTIMISM_CONTRACT_ADDRESS = WETH_OPTIMISM_CONTRACT_ADDRESS;
const WETH_ARBITRUM_CONTRACT_ADDRESS = '0x82af49447d8a07e3bd95bd0d56f35241523fbab1';
exports.WETH_ARBITRUM_CONTRACT_ADDRESS = WETH_ARBITRUM_CONTRACT_ADDRESS;
const SWAPS_TESTNET_CHAIN_ID = '0x539';
const SWAPS_API_V2_BASE_URL = 'https://swap.metaswap.codefi.network';
exports.SWAPS_API_V2_BASE_URL = SWAPS_API_V2_BASE_URL;
const SWAPS_DEV_API_V2_BASE_URL = 'https://swap.dev-api.cx.metamask.io';
exports.SWAPS_DEV_API_V2_BASE_URL = SWAPS_DEV_API_V2_BASE_URL;
const GAS_API_BASE_URL = 'https://gas-api.metaswap.codefi.network';
exports.GAS_API_BASE_URL = GAS_API_BASE_URL;
const GAS_DEV_API_BASE_URL = 'https://gas-api.metaswap-dev.codefi.network';
exports.GAS_DEV_API_BASE_URL = GAS_DEV_API_BASE_URL;
const BSC_DEFAULT_BLOCK_EXPLORER_URL = 'https://bscscan.com/';
const MAINNET_DEFAULT_BLOCK_EXPLORER_URL = 'https://etherscan.io/';
const GOERLI_DEFAULT_BLOCK_EXPLORER_URL = 'https://goerli.etherscan.io/';
const POLYGON_DEFAULT_BLOCK_EXPLORER_URL = 'https://polygonscan.com/';
const AVALANCHE_DEFAULT_BLOCK_EXPLORER_URL = 'https://snowtrace.io/';
const OPTIMISM_DEFAULT_BLOCK_EXPLORER_URL = 'https://optimistic.etherscan.io/';
const ARBITRUM_DEFAULT_BLOCK_EXPLORER_URL = 'https://arbiscan.io/';
const ALLOWED_PROD_SWAPS_CHAIN_IDS = [_network.CHAIN_IDS.MAINNET, SWAPS_TESTNET_CHAIN_ID, _network.CHAIN_IDS.BSC, _network.CHAIN_IDS.POLYGON, _network.CHAIN_IDS.AVALANCHE, _network.CHAIN_IDS.OPTIMISM, _network.CHAIN_IDS.ARBITRUM];
exports.ALLOWED_PROD_SWAPS_CHAIN_IDS = ALLOWED_PROD_SWAPS_CHAIN_IDS;
const ALLOWED_DEV_SWAPS_CHAIN_IDS = [...ALLOWED_PROD_SWAPS_CHAIN_IDS, _network.CHAIN_IDS.GOERLI];
exports.ALLOWED_DEV_SWAPS_CHAIN_IDS = ALLOWED_DEV_SWAPS_CHAIN_IDS;
const ALLOWED_SMART_TRANSACTIONS_CHAIN_IDS = [_network.CHAIN_IDS.MAINNET, _network.CHAIN_IDS.GOERLI];
exports.ALLOWED_SMART_TRANSACTIONS_CHAIN_IDS = ALLOWED_SMART_TRANSACTIONS_CHAIN_IDS;
const SWAPS_CHAINID_CONTRACT_ADDRESS_MAP = {
  [_network.CHAIN_IDS.MAINNET]: MAINNET_CONTRACT_ADDRESS,
  [SWAPS_TESTNET_CHAIN_ID]: TESTNET_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.BSC]: BSC_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.POLYGON]: POLYGON_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.GOERLI]: TESTNET_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.AVALANCHE]: AVALANCHE_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.OPTIMISM]: OPTIMISM_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.ARBITRUM]: ARBITRUM_CONTRACT_ADDRESS
};
exports.SWAPS_CHAINID_CONTRACT_ADDRESS_MAP = SWAPS_CHAINID_CONTRACT_ADDRESS_MAP;
const SWAPS_WRAPPED_TOKENS_ADDRESSES = {
  [_network.CHAIN_IDS.MAINNET]: WETH_CONTRACT_ADDRESS,
  [SWAPS_TESTNET_CHAIN_ID]: WETH_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.BSC]: WBNB_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.POLYGON]: WMATIC_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.GOERLI]: WETH_GOERLI_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.AVALANCHE]: WAVAX_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.OPTIMISM]: WETH_OPTIMISM_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.ARBITRUM]: WETH_ARBITRUM_CONTRACT_ADDRESS
};
exports.SWAPS_WRAPPED_TOKENS_ADDRESSES = SWAPS_WRAPPED_TOKENS_ADDRESSES;
const ALLOWED_CONTRACT_ADDRESSES = {
  [_network.CHAIN_IDS.MAINNET]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.MAINNET], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.MAINNET]],
  [SWAPS_TESTNET_CHAIN_ID]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[SWAPS_TESTNET_CHAIN_ID], SWAPS_WRAPPED_TOKENS_ADDRESSES[SWAPS_TESTNET_CHAIN_ID]],
  [_network.CHAIN_IDS.GOERLI]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.GOERLI], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.GOERLI]],
  [_network.CHAIN_IDS.BSC]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.BSC], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.BSC]],
  [_network.CHAIN_IDS.POLYGON]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.POLYGON], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.POLYGON]],
  [_network.CHAIN_IDS.AVALANCHE]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.AVALANCHE], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.AVALANCHE]],
  [_network.CHAIN_IDS.OPTIMISM]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.OPTIMISM], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.OPTIMISM]],
  [_network.CHAIN_IDS.ARBITRUM]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.ARBITRUM], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.ARBITRUM]]
};
exports.ALLOWED_CONTRACT_ADDRESSES = ALLOWED_CONTRACT_ADDRESSES;
const SWAPS_CHAINID_DEFAULT_TOKEN_MAP = {
  [_network.CHAIN_IDS.MAINNET]: ETH_SWAPS_TOKEN_OBJECT,
  [SWAPS_TESTNET_CHAIN_ID]: TEST_ETH_SWAPS_TOKEN_OBJECT,
  [_network.CHAIN_IDS.BSC]: BNB_SWAPS_TOKEN_OBJECT,
  [_network.CHAIN_IDS.POLYGON]: MATIC_SWAPS_TOKEN_OBJECT,
  [_network.CHAIN_IDS.GOERLI]: GOERLI_SWAPS_TOKEN_OBJECT,
  [_network.CHAIN_IDS.AVALANCHE]: AVAX_SWAPS_TOKEN_OBJECT,
  [_network.CHAIN_IDS.OPTIMISM]: OPTIMISM_SWAPS_TOKEN_OBJECT,
  [_network.CHAIN_IDS.ARBITRUM]: ARBITRUM_SWAPS_TOKEN_OBJECT
};
exports.SWAPS_CHAINID_DEFAULT_TOKEN_MAP = SWAPS_CHAINID_DEFAULT_TOKEN_MAP;
const SWAPS_CHAINID_DEFAULT_BLOCK_EXPLORER_URL_MAP = {
  [_network.CHAIN_IDS.BSC]: BSC_DEFAULT_BLOCK_EXPLORER_URL,
  [_network.CHAIN_IDS.MAINNET]: MAINNET_DEFAULT_BLOCK_EXPLORER_URL,
  [_network.CHAIN_IDS.POLYGON]: POLYGON_DEFAULT_BLOCK_EXPLORER_URL,
  [_network.CHAIN_IDS.GOERLI]: GOERLI_DEFAULT_BLOCK_EXPLORER_URL,
  [_network.CHAIN_IDS.AVALANCHE]: AVALANCHE_DEFAULT_BLOCK_EXPLORER_URL,
  [_network.CHAIN_IDS.OPTIMISM]: OPTIMISM_DEFAULT_BLOCK_EXPLORER_URL,
  [_network.CHAIN_IDS.ARBITRUM]: ARBITRUM_DEFAULT_BLOCK_EXPLORER_URL
};
exports.SWAPS_CHAINID_DEFAULT_BLOCK_EXPLORER_URL_MAP = SWAPS_CHAINID_DEFAULT_BLOCK_EXPLORER_URL_MAP;
const ETHEREUM = 'ethereum';
exports.ETHEREUM = ETHEREUM;
const POLYGON = 'polygon';
exports.POLYGON = POLYGON;
const BSC = 'bsc';
exports.BSC = BSC;
const GOERLI = 'goerli';
exports.GOERLI = GOERLI;
const AVALANCHE = 'avalanche';
exports.AVALANCHE = AVALANCHE;
const OPTIMISM = 'optimism';
exports.OPTIMISM = OPTIMISM;
const ARBITRUM = 'arbitrum';
exports.ARBITRUM = ARBITRUM;
const SWAPS_CLIENT_ID = 'extension';
exports.SWAPS_CLIENT_ID = SWAPS_CLIENT_ID;
let TokenBucketPriority = /*#__PURE__*/function (TokenBucketPriority) {
  TokenBucketPriority["owned"] = "owned";
  TokenBucketPriority["top"] = "top";
  return TokenBucketPriority;
}({});
exports.TokenBucketPriority = TokenBucketPriority;
let Slippage = /*#__PURE__*/function (Slippage) {
  Slippage[Slippage["default"] = 2] = "default";
  Slippage[Slippage["high"] = 3] = "high";
  return Slippage;
}({});
exports.Slippage = Slippage;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\swaps.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\time.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cconstants%5Ctime.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SECOND = exports.MINUTE = exports.MILLISECOND = exports.HOUR = exports.DAY = void 0;
const MILLISECOND = 1;
exports.MILLISECOND = MILLISECOND;
const SECOND = MILLISECOND * 1000;
exports.SECOND = SECOND;
const MINUTE = SECOND * 60;
exports.MINUTE = MINUTE;
const HOUR = MINUTE * 60;
exports.HOUR = HOUR;
const DAY = HOUR * 24;
exports.DAY = DAY;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\time.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\tokens.js", {"@metamask/contract-metadata":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\contract-metadata\\index.js","bignumber.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\bignumber.js\\bignumber.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cconstants%5Ctokens.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TOKEN_API_METASWAP_CODEFI_URL = exports.STATIC_MAINNET_TOKEN_LIST = exports.NUM_W_OPT_DECIMAL_COMMA_OR_DOT_REGEX = exports.MAX_TOKEN_ALLOWANCE_AMOUNT = exports.LISTED_CONTRACT_ADDRESSES = exports.DECIMAL_REGEX = void 0;
var _contractMetadata = _interopRequireDefault(require("@metamask/contract-metadata"));
var _bignumber = _interopRequireDefault(require("bignumber.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * A normalized list of addresses exported as part of the contractMap in
 * `@metamask/contract-metadata`. Used primarily to validate if manually entered
 * contract addresses do not match one of our listed tokens
 */
const LISTED_CONTRACT_ADDRESSES = Object.keys(_contractMetadata.default).map(address => address.toLowerCase());

/**
 * @typedef {object} TokenDetails
 * @property {string} address - The address of the selected 'TOKEN' or
 *  'NFT' contract.
 * @property {string} [symbol] - The symbol of the token.
 * @property {number} [decimals] - The number of decimals of the selected
 *  'ERC20' asset.
 * @property {number} [tokenId] - The id of the selected 'NFT' asset.
 * @property {TokenStandardStrings} [standard] - The standard of the selected
 *  asset.
 * @property {boolean} [isERC721] - True when the asset is a ERC721 token.
 */
exports.LISTED_CONTRACT_ADDRESSES = LISTED_CONTRACT_ADDRESSES;
const STATIC_MAINNET_TOKEN_LIST = Object.keys(_contractMetadata.default).reduce((acc, base) => {
  const {
    logo,
    ...tokenMetadata
  } = _contractMetadata.default[base];
  return {
    ...acc,
    [base.toLowerCase()]: {
      ...tokenMetadata,
      address: base.toLowerCase(),
      iconUrl: `images/contract/${logo}`,
      aggregators: []
    }
  };
}, {});
exports.STATIC_MAINNET_TOKEN_LIST = STATIC_MAINNET_TOKEN_LIST;
const TOKEN_API_METASWAP_CODEFI_URL = 'https://token-api.metaswap.codefi.network/tokens/';
exports.TOKEN_API_METASWAP_CODEFI_URL = TOKEN_API_METASWAP_CODEFI_URL;
const MAX_TOKEN_ALLOWANCE_AMOUNT = new _bignumber.default(2).pow(256).minus(1).toString(10);
// number with optional decimal point using a comma or dot
exports.MAX_TOKEN_ALLOWANCE_AMOUNT = MAX_TOKEN_ALLOWANCE_AMOUNT;
const NUM_W_OPT_DECIMAL_COMMA_OR_DOT_REGEX = /^[0-9]{1,}([,.][0-9]{1,})?$/u;
exports.NUM_W_OPT_DECIMAL_COMMA_OR_DOT_REGEX = NUM_W_OPT_DECIMAL_COMMA_OR_DOT_REGEX;
const DECIMAL_REGEX = /\.(\d*)/u;
exports.DECIMAL_REGEX = DECIMAL_REGEX;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\tokens.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\transaction.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cconstants%5Ctransaction.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TransactionType = exports.TransactionStatus = exports.TransactionMetaMetricsEvent = exports.TransactionGroupStatus = exports.TransactionGroupCategory = exports.TransactionEnvelopeType = exports.TransactionApprovalAmountType = exports.TokenStandard = exports.SmartTransactionStatus = exports.IN_PROGRESS_TRANSACTION_STATUSES = exports.AssetType = void 0;
let TransactionType = /*#__PURE__*/function (TransactionType) {
  TransactionType["cancel"] = "cancel";
  TransactionType["contractInteraction"] = "contractInteraction";
  TransactionType["deployContract"] = "contractDeployment";
  TransactionType["ethDecrypt"] = "eth_decrypt";
  TransactionType["ethGetEncryptionPublicKey"] = "eth_getEncryptionPublicKey";
  TransactionType["incoming"] = "incoming";
  TransactionType["personalSign"] = "personal_sign";
  TransactionType["retry"] = "retry";
  TransactionType["sign"] = "eth_sign";
  TransactionType["signTypedData"] = "eth_signTypedData";
  TransactionType["simpleSend"] = "simpleSend";
  TransactionType["smart"] = "smart";
  TransactionType["swap"] = "swap";
  TransactionType["swapApproval"] = "swapApproval";
  TransactionType["tokenMethodApprove"] = "approve";
  TransactionType["tokenMethodSafeTransferFrom"] = "safetransferfrom";
  TransactionType["tokenMethodTransfer"] = "transfer";
  TransactionType["tokenMethodTransferFrom"] = "transferfrom";
  TransactionType["tokenMethodSetApprovalForAll"] = "setapprovalforall";
  return TransactionType;
}({});
/**
 * In EIP-2718 typed transaction envelopes were specified, with the very first
 * typed envelope being 'legacy' and describing the shape of the base
 * transaction params that were hitherto the only transaction type sent on
 * Ethereum.
 */
exports.TransactionType = TransactionType;
let TransactionEnvelopeType = /*#__PURE__*/function (TransactionEnvelopeType) {
  TransactionEnvelopeType["legacy"] = "0x0";
  TransactionEnvelopeType["accessList"] = "0x1";
  TransactionEnvelopeType["feeMarket"] = "0x2";
  return TransactionEnvelopeType;
}({});
/**
 * Transaction Status is a mix of Ethereum and MetaMask terminology, used internally
 * for transaction processing.
 */
exports.TransactionEnvelopeType = TransactionEnvelopeType;
let TransactionStatus = /*#__PURE__*/function (TransactionStatus) {
  TransactionStatus["unapproved"] = "unapproved";
  TransactionStatus["approved"] = "approved";
  TransactionStatus["rejected"] = "rejected";
  TransactionStatus["signed"] = "signed";
  TransactionStatus["submitted"] = "submitted";
  TransactionStatus["failed"] = "failed";
  TransactionStatus["dropped"] = "dropped";
  TransactionStatus["confirmed"] = "confirmed";
  TransactionStatus["pending"] = "pending";
  return TransactionStatus;
}({});
/**
 * With this list we can detect if a transaction is still in progress.
 */
exports.TransactionStatus = TransactionStatus;
const IN_PROGRESS_TRANSACTION_STATUSES = [TransactionStatus.unapproved, TransactionStatus.approved, TransactionStatus.signed, TransactionStatus.submitted, TransactionStatus.pending];

/**
 * Transaction Group Status is a MetaMask construct to track the status of groups
 * of transactions.
 */
exports.IN_PROGRESS_TRANSACTION_STATUSES = IN_PROGRESS_TRANSACTION_STATUSES;
let TransactionGroupStatus = /*#__PURE__*/function (TransactionGroupStatus) {
  TransactionGroupStatus["cancelled"] = "cancelled";
  TransactionGroupStatus["pending"] = "pending";
  return TransactionGroupStatus;
}({});
/**
 * Statuses that are specific to Smart Transactions.
 */
exports.TransactionGroupStatus = TransactionGroupStatus;
let SmartTransactionStatus = /*#__PURE__*/function (SmartTransactionStatus) {
  SmartTransactionStatus["cancelled"] = "cancelled";
  SmartTransactionStatus["pending"] = "pending";
  SmartTransactionStatus["success"] = "success";
  return SmartTransactionStatus;
}({});
/**
 * Types that are specific to the transaction approval amount.
 */
exports.SmartTransactionStatus = SmartTransactionStatus;
let TransactionApprovalAmountType = /*#__PURE__*/function (TransactionApprovalAmountType) {
  TransactionApprovalAmountType["custom"] = "custom";
  TransactionApprovalAmountType["revoke"] = "revoke";
  TransactionApprovalAmountType["dappProposed"] = "dapp_proposed";
  return TransactionApprovalAmountType;
}({});
/**
 * Transaction Group Category is a MetaMask construct to categorize the intent
 * of a group of transactions for purposes of displaying in the UI
 */
exports.TransactionApprovalAmountType = TransactionApprovalAmountType;
let TransactionGroupCategory = /*#__PURE__*/function (TransactionGroupCategory) {
  TransactionGroupCategory["approval"] = "approval";
  TransactionGroupCategory["interaction"] = "interaction";
  TransactionGroupCategory["receive"] = "receive";
  TransactionGroupCategory["send"] = "send";
  TransactionGroupCategory["signatureRequest"] = "signature-request";
  TransactionGroupCategory["swap"] = "swap";
  return TransactionGroupCategory;
}({});
/**
 * An object representing parameters of a transaction to submit to the network
 */
/**
 * We attach an object to transactions proposed by dapps to show the values
 * that the dapp suggested for gas fees. This is used to compare to what our
 * internal gas price logic would have the transaction priced at for metrics
 * with the aim of improving our suggestions as well as giving the user the
 * option to return to the defaults suggested by the dapp if they have edited
 * the gas fees on the confirmation screen.
 */
/**
 * An object representing a transaction, in whatever state it is in.
 */
exports.TransactionGroupCategory = TransactionGroupCategory;
/**
 * Defines the possible types
 */
let TransactionMetaMetricsEvent = /*#__PURE__*/function (TransactionMetaMetricsEvent) {
  TransactionMetaMetricsEvent["added"] = "Transaction Added";
  TransactionMetaMetricsEvent["approved"] = "Transaction Approved";
  TransactionMetaMetricsEvent["finalized"] = "Transaction Finalized";
  TransactionMetaMetricsEvent["rejected"] = "Transaction Rejected";
  TransactionMetaMetricsEvent["submitted"] = "Transaction Submitted";
  return TransactionMetaMetricsEvent;
}({});
/**
 * The types of assets that a user can send
 *
 * @type {AssetTypes}
 */
exports.TransactionMetaMetricsEvent = TransactionMetaMetricsEvent;
let AssetType = /*#__PURE__*/function (AssetType) {
  AssetType["native"] = "NATIVE";
  AssetType["token"] = "TOKEN";
  AssetType["NFT"] = "NFT";
  AssetType["unknown"] = "UNKNOWN";
  return AssetType;
}({});
/**
 * Describes the standard which a token conforms to.
 */
exports.AssetType = AssetType;
let TokenStandard = /*#__PURE__*/function (TokenStandard) {
  TokenStandard["ERC20"] = "ERC20";
  TokenStandard["ERC721"] = "ERC721";
  TokenStandard["ERC1155"] = "ERC1155";
  TokenStandard["none"] = "NONE";
  return TokenStandard;
}({});
exports.TokenStandard = TokenStandard;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\transaction.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\lib\\fetch-with-cache.js", {"../constants/time":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\time.ts","../modules/fetch-with-timeout":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\fetch-with-timeout.ts","./storage-helpers":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\lib\\storage-helpers.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Clib%5Cfetch-with-cache.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _time = require("../constants/time");
var _fetchWithTimeout = _interopRequireDefault(require("../modules/fetch-with-timeout"));
var _storageHelpers = require("./storage-helpers");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const fetchWithCache = async (url, fetchOptions = {}, {
  cacheRefreshTime = _time.MINUTE * 6,
  timeout = _time.SECOND * 30
} = {}) => {
  if (fetchOptions.body || fetchOptions.method && fetchOptions.method !== 'GET') {
    throw new Error('fetchWithCache only supports GET requests');
  }
  if (!(fetchOptions.headers instanceof window.Headers)) {
    fetchOptions.headers = new window.Headers(fetchOptions.headers);
  }
  if (fetchOptions.headers.has('Content-Type') && fetchOptions.headers.get('Content-Type') !== 'application/json') {
    throw new Error('fetchWithCache only supports JSON responses');
  }
  const currentTime = Date.now();
  const cacheKey = `cachedFetch:${url}`;
  const {
    cachedResponse,
    cachedTime
  } = (await (0, _storageHelpers.getStorageItem)(cacheKey)) || {};
  if (cachedResponse && currentTime - cachedTime < cacheRefreshTime) {
    return cachedResponse;
  }
  fetchOptions.headers.set('Content-Type', 'application/json');
  const fetchWithTimeout = (0, _fetchWithTimeout.default)(timeout);
  const response = await fetchWithTimeout(url, {
    referrerPolicy: 'no-referrer-when-downgrade',
    body: null,
    method: 'GET',
    mode: 'cors',
    ...fetchOptions
  });
  if (!response.ok) {
    throw new Error(`Fetch failed with status '${response.status}': '${response.statusText}'`);
  }
  const responseJson = await response.json();
  const cacheEntry = {
    cachedResponse: responseJson,
    cachedTime: currentTime
  };
  await (0, _storageHelpers.setStorageItem)(cacheKey, cacheEntry);
  return responseJson;
};
var _default = fetchWithCache;
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\lib\\fetch-with-cache.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\lib\\metamask-controller-utils.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Clib%5Cmetamask-controller-utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTokenValueParam = getTokenValueParam;
function getTokenValueParam(tokenData = {}) {
  var _tokenData$args, _tokenData$args$_valu;
  return tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args = tokenData.args) === null || _tokenData$args === void 0 ? void 0 : (_tokenData$args$_valu = _tokenData$args._value) === null || _tokenData$args$_valu === void 0 ? void 0 : _tokenData$args$_valu.toString();
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\lib\\metamask-controller-utils.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\lib\\storage-helpers.js", {"localforage":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\localforage\\dist\\localforage.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Clib%5Cstorage-helpers.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getStorageItem = getStorageItem;
exports.setStorageItem = setStorageItem;
var _localforage = _interopRequireDefault(require("localforage"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
async function getStorageItem(key) {
  try {
    const serializedData = await _localforage.default.getItem(key);
    if (serializedData === null) {
      return undefined;
    }
    return JSON.parse(serializedData);
  } catch (err) {
    return undefined;
  }
}
async function setStorageItem(key, value) {
  try {
    const serializedData = JSON.stringify(value);
    await _localforage.default.setItem(key, serializedData);
  } catch (err) {
    console.warn(err);
  }
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\lib\\storage-helpers.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\lib\\swaps-utils.js", {"../../app/scripts/lib/util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\app\\scripts\\lib\\util.ts","../constants/network":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\network.ts","../constants/swaps":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\swaps.ts","../constants/time":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\time.ts","../modules/conversion.utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\conversion.utils.ts","../modules/hexstring-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\hexstring-utils.ts","../modules/string-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\string-utils.ts","./fetch-with-cache":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\lib\\fetch-with-cache.js","bignumber.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\bignumber.js\\bignumber.js","loglevel":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Clib%5Cswaps-utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QUOTE_VALIDATORS = void 0;
exports.addHexPrefixToObjectValues = addHexPrefixToObjectValues;
exports.calcTokenValue = calcTokenValue;
exports.constructTxParams = constructTxParams;
exports.fetchTradesInfo = fetchTradesInfo;
exports.validHex = exports.truthyString = exports.truthyDigitString = exports.shouldEnableDirectWrapping = exports.getBaseApi = void 0;
exports.validateData = validateData;
var _bignumber = _interopRequireDefault(require("bignumber.js"));
var _loglevel = _interopRequireDefault(require("loglevel"));
var _network = require("../constants/network");
var _swaps = require("../constants/swaps");
var _time = require("../constants/time");
var _hexstringUtils = require("../modules/hexstring-utils");
var _stringUtils = require("../modules/string-utils");
var _util = require("../../app/scripts/lib/util");
var _conversion = require("../modules/conversion.utils");
var _fetchWithCache = _interopRequireDefault(require("./fetch-with-cache"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TEST_CHAIN_IDS = [_network.CHAIN_IDS.GOERLI, _network.CHAIN_IDS.LOCALHOST];
const clientIdHeader = {
  'X-Client-Id': _swaps.SWAPS_CLIENT_ID
};
const validHex = string => Boolean(string === null || string === void 0 ? void 0 : string.match(/^0x[a-f0-9]+$/u));
exports.validHex = validHex;
const truthyString = string => Boolean(string === null || string === void 0 ? void 0 : string.length);
exports.truthyString = truthyString;
const truthyDigitString = string => truthyString(string) && Boolean(string.match(/^\d+$/u));
exports.truthyDigitString = truthyDigitString;
function validateData(validators, object, urlUsed, logError = true) {
  return validators.every(({
    property,
    type,
    validator
  }) => {
    const types = type.split('|');
    const valid = types.some(_type => typeof object[property] === _type) && (!validator || validator(object[property]));
    if (!valid && logError) {
      _loglevel.default.error(`response to GET ${urlUsed} invalid for property ${property}; value was:`, object[property], '| type was: ', typeof object[property]);
    }
    return valid;
  });
}
const QUOTE_VALIDATORS = [{
  property: 'trade',
  type: 'object',
  validator: trade => trade && validHex(trade.data) && (0, _hexstringUtils.isValidHexAddress)(trade.to, {
    allowNonPrefixed: false
  }) && (0, _hexstringUtils.isValidHexAddress)(trade.from, {
    allowNonPrefixed: false
  }) && truthyString(trade.value)
}, {
  property: 'approvalNeeded',
  type: 'object',
  validator: approvalTx => approvalTx === null || approvalTx && validHex(approvalTx.data) && (0, _hexstringUtils.isValidHexAddress)(approvalTx.to, {
    allowNonPrefixed: false
  }) && (0, _hexstringUtils.isValidHexAddress)(approvalTx.from, {
    allowNonPrefixed: false
  })
}, {
  property: 'sourceAmount',
  type: 'string',
  validator: truthyDigitString
}, {
  property: 'destinationAmount',
  type: 'string',
  validator: truthyDigitString
}, {
  property: 'sourceToken',
  type: 'string',
  validator: input => (0, _hexstringUtils.isValidHexAddress)(input, {
    allowNonPrefixed: false
  })
}, {
  property: 'destinationToken',
  type: 'string',
  validator: input => (0, _hexstringUtils.isValidHexAddress)(input, {
    allowNonPrefixed: false
  })
}, {
  property: 'aggregator',
  type: 'string',
  validator: truthyString
}, {
  property: 'aggType',
  type: 'string',
  validator: truthyString
}, {
  property: 'error',
  type: 'object',
  validator: error => error === null || typeof error === 'object'
}, {
  property: 'averageGas',
  type: 'number'
}, {
  property: 'maxGas',
  type: 'number'
}, {
  property: 'gasEstimate',
  type: 'number|undefined',
  validator: gasEstimate => gasEstimate === undefined || gasEstimate > 0
}, {
  property: 'fee',
  type: 'number'
}];

/**
 * @param {string} type - Type of an API call, e.g. "tokens"
 * @param {string} chainId
 * @returns string
 */
exports.QUOTE_VALIDATORS = QUOTE_VALIDATORS;
const getBaseUrlForNewSwapsApi = (type, chainId) => {
  const useDevApis = false;
  const v2ApiBaseUrl = useDevApis ? _swaps.SWAPS_DEV_API_V2_BASE_URL : _swaps.SWAPS_API_V2_BASE_URL;
  const gasApiBaseUrl = useDevApis ? _swaps.GAS_DEV_API_BASE_URL : _swaps.GAS_API_BASE_URL;
  const noNetworkSpecificTypes = ['refreshTime']; // These types don't need network info in the URL.
  if (noNetworkSpecificTypes.includes(type)) {
    return v2ApiBaseUrl;
  }
  const chainIdDecimal = chainId && parseInt(chainId, 16);
  const gasApiTypes = ['gasPrices'];
  if (gasApiTypes.includes(type)) {
    return `${gasApiBaseUrl}/networks/${chainIdDecimal}`; // Gas calculations are in its own repo.
  }

  return `${v2ApiBaseUrl}/networks/${chainIdDecimal}`;
};
const getBaseApi = function (type, chainId) {
  const _chainId = TEST_CHAIN_IDS.includes(chainId) ? _network.CHAIN_IDS.MAINNET : chainId;
  const baseUrl = getBaseUrlForNewSwapsApi(type, _chainId);
  if (!baseUrl) {
    throw new Error(`Swaps API calls are disabled for chainId: ${_chainId}`);
  }
  switch (type) {
    case 'trade':
      return `${baseUrl}/trades?`;
    case 'tokens':
      return `${baseUrl}/tokens`;
    case 'token':
      return `${baseUrl}/token`;
    case 'topAssets':
      return `${baseUrl}/topAssets`;
    case 'aggregatorMetadata':
      return `${baseUrl}/aggregatorMetadata`;
    case 'gasPrices':
      return `${baseUrl}/gasPrices`;
    case 'network':
      return baseUrl;
    default:
      throw new Error('getBaseApi requires an api call type');
  }
};
exports.getBaseApi = getBaseApi;
function calcTokenValue(value, decimals) {
  const multiplier = Math.pow(10, Number(decimals || 0));
  return new _bignumber.default(String(value)).times(multiplier);
}
const shouldEnableDirectWrapping = (chainId, sourceToken, destinationToken) => {
  var _SWAPS_CHAINID_DEFAUL;
  if (!sourceToken || !destinationToken) {
    return false;
  }
  const wrappedToken = _swaps.SWAPS_WRAPPED_TOKENS_ADDRESSES[chainId];
  const nativeToken = (_SWAPS_CHAINID_DEFAUL = _swaps.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId]) === null || _SWAPS_CHAINID_DEFAUL === void 0 ? void 0 : _SWAPS_CHAINID_DEFAUL.address;
  return (0, _stringUtils.isEqualCaseInsensitive)(sourceToken, wrappedToken) && (0, _stringUtils.isEqualCaseInsensitive)(destinationToken, nativeToken) || (0, _stringUtils.isEqualCaseInsensitive)(sourceToken, nativeToken) && (0, _stringUtils.isEqualCaseInsensitive)(destinationToken, wrappedToken);
};

/**
 * Given and object where all values are strings, returns the same object with all values
 * now prefixed with '0x'
 *
 * @param obj
 */
exports.shouldEnableDirectWrapping = shouldEnableDirectWrapping;
function addHexPrefixToObjectValues(obj) {
  return Object.keys(obj).reduce((newObj, key) => {
    return {
      ...newObj,
      [key]: (0, _util.addHexPrefix)(obj[key])
    };
  }, {});
}

/**
 * Given the standard set of information about a transaction, returns a transaction properly formatted for
 * publishing via JSON RPC and web3
 *
 * @param {object} options
 * @param {boolean} [options.sendToken] - Indicates whether or not the transaciton is a token transaction
 * @param {string} options.data - A hex string containing the data to include in the transaction
 * @param {string} options.to - A hex address of the tx recipient address
 * @param options.amount
 * @param {string} options.from - A hex address of the tx sender address
 * @param {string} options.gas - A hex representation of the gas value for the transaction
 * @param {string} options.gasPrice - A hex representation of the gas price for the transaction
 * @returns {object} An object ready for submission to the blockchain, with all values appropriately hex prefixed
 */
function constructTxParams({
  sendToken,
  data,
  to,
  amount,
  from,
  gas,
  gasPrice
}) {
  const txParams = {
    data,
    from,
    value: '0',
    gas,
    gasPrice
  };
  if (!sendToken) {
    txParams.value = amount;
    txParams.to = to;
  }
  return addHexPrefixToObjectValues(txParams);
}
async function fetchTradesInfo({
  slippage,
  sourceToken,
  sourceDecimals,
  destinationToken,
  value,
  fromAddress,
  exchangeList
}, {
  chainId
}) {
  const urlParams = {
    destinationToken,
    sourceToken,
    sourceAmount: calcTokenValue(value, sourceDecimals).toString(10),
    slippage,
    timeout: _time.SECOND * 10,
    walletAddress: fromAddress
  };
  if (exchangeList) {
    urlParams.exchangeList = exchangeList;
  }
  if (shouldEnableDirectWrapping(chainId, sourceToken, destinationToken)) {
    urlParams.enableDirectWrapping = true;
  }
  const queryString = new URLSearchParams(urlParams).toString();
  const tradeURL = `${getBaseApi('trade', chainId)}${queryString}`;
  const tradesResponse = await (0, _fetchWithCache.default)(tradeURL, {
    method: 'GET',
    headers: clientIdHeader
  }, {
    cacheRefreshTime: 0,
    timeout: _time.SECOND * 15
  });
  const newQuotes = tradesResponse.reduce((aggIdTradeMap, quote) => {
    if (quote.trade && !quote.error && validateData(QUOTE_VALIDATORS, quote, tradeURL)) {
      const constructedTrade = constructTxParams({
        to: quote.trade.to,
        from: quote.trade.from,
        data: quote.trade.data,
        amount: (0, _conversion.decimalToHex)(quote.trade.value),
        gas: (0, _conversion.decimalToHex)(quote.maxGas)
      });
      let {
        approvalNeeded
      } = quote;
      if (approvalNeeded) {
        approvalNeeded = constructTxParams({
          ...approvalNeeded
        });
      }
      return {
        ...aggIdTradeMap,
        [quote.aggregator]: {
          ...quote,
          slippage,
          trade: constructedTrade,
          approvalNeeded
        }
      };
    }
    return aggIdTradeMap;
  }, {});
  return newQuotes;
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\lib\\swaps-utils.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\lib\\token-util.ts", {"@ethersproject/contracts":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ethersproject\\contracts\\lib\\index.js","@ethersproject/providers":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ethersproject\\providers\\lib\\index.js","@metamask/metamask-eth-abis":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\metamask-eth-abis\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Clib%5Ctoken-util.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchTokenBalance = fetchTokenBalance;
exports.getTokenIdParam = getTokenIdParam;
var _metamaskEthAbis = require("@metamask/metamask-eth-abis");
var _contracts = require("@ethersproject/contracts");
var _providers = require("@ethersproject/providers");
/**
 * Gets the '_value' parameter of the given token transaction data
 * (i.e function call) per the Human Standard Token ABI, if present.
 *
 * @param {object} tokenData - ethers Interface token data.
 * @returns {string | undefined} A decimal string value.
 */
/**
 * Gets either the '_tokenId' parameter or the 'id' param of the passed token transaction data.,
 * These are the parsed tokenId values returned by `parseStandardTokenTransactionData` as defined
 * in the ERC721 and ERC1155 ABIs from metamask-eth-abis (https://github.com/MetaMask/metamask-eth-abis/tree/main/src/abis)
 *
 * @param tokenData - ethers Interface token data.
 * @returns A decimal string value.
 */
function getTokenIdParam(tokenData = {}) {
  var _tokenData$args, _tokenData$args$_toke, _tokenData$args2, _tokenData$args2$id;
  return (tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args = tokenData.args) === null || _tokenData$args === void 0 ? void 0 : (_tokenData$args$_toke = _tokenData$args._tokenId) === null || _tokenData$args$_toke === void 0 ? void 0 : _tokenData$args$_toke.toString()) ?? (tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args2 = tokenData.args) === null || _tokenData$args2 === void 0 ? void 0 : (_tokenData$args2$id = _tokenData$args2.id) === null || _tokenData$args2$id === void 0 ? void 0 : _tokenData$args2$id.toString());
}
async function fetchTokenBalance(address, userAddress, provider) {
  const ethersProvider = new _providers.Web3Provider(provider);
  const tokenContract = new _contracts.Contract(address, _metamaskEthAbis.abiERC20, ethersProvider);
  const tokenBalancePromise = tokenContract ? tokenContract.balanceOf(userAddress) : Promise.resolve();
  return await tokenBalancePromise;
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\lib\\token-util.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\lib\\transactions-controller-utils.js", {"../constants/common":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\common.ts","../constants/transaction":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\transaction.ts","../modules/Numeric":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\Numeric.ts","../modules/swaps.utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\swaps.utils.js","bignumber.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\bignumber.js\\bignumber.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Clib%5Ctransactions-controller-utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TRANSACTION_NO_CONTRACT_ERROR_KEY = exports.TRANSACTION_ENVELOPE_TYPE_NAMES = exports.TOKEN_TRANSFER_LOG_TOPIC_HASH = exports.TEN_SECONDS_IN_MILLISECONDS = void 0;
exports.calcGasTotal = calcGasTotal;
exports.calcTokenAmount = calcTokenAmount;
exports.getSwapsTokensReceivedFromTxMeta = getSwapsTokensReceivedFromTxMeta;
exports.toPrecisionWithoutTrailingZeros = toPrecisionWithoutTrailingZeros;
var _bignumber = _interopRequireDefault(require("bignumber.js"));
var _common = require("../constants/common");
var _transaction = require("../constants/transaction");
var _Numeric = require("../modules/Numeric");
var _swaps = require("../modules/swaps.utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TOKEN_TRANSFER_LOG_TOPIC_HASH = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
exports.TOKEN_TRANSFER_LOG_TOPIC_HASH = TOKEN_TRANSFER_LOG_TOPIC_HASH;
const TRANSACTION_NO_CONTRACT_ERROR_KEY = 'transactionErrorNoContract';
exports.TRANSACTION_NO_CONTRACT_ERROR_KEY = TRANSACTION_NO_CONTRACT_ERROR_KEY;
const TEN_SECONDS_IN_MILLISECONDS = 10_000;
exports.TEN_SECONDS_IN_MILLISECONDS = TEN_SECONDS_IN_MILLISECONDS;
function calcGasTotal(gasLimit = '0', gasPrice = '0') {
  return new _Numeric.Numeric(gasLimit, 16).times(new _Numeric.Numeric(gasPrice, 16)).toString();
}

/**
 * Given a number and specified precision, returns that number in base 10 with a maximum of precision
 * significant digits, but without any trailing zeros after the decimal point To be used when wishing
 * to display only as much digits to the user as necessary
 *
 * @param {string | number | BigNumber} n - The number to format
 * @param {number} precision - The maximum number of significant digits in the return value
 * @returns {string} The number in decimal form, with <= precision significant digits and no decimal trailing zeros
 */
function toPrecisionWithoutTrailingZeros(n, precision) {
  return new _bignumber.default(n).toPrecision(precision).replace(/(\.[0-9]*[1-9])0*|(\.0*)/u, '$1');
}
function calcTokenAmount(value, decimals) {
  const multiplier = Math.pow(10, Number(decimals || 0));
  return new _bignumber.default(String(value)).div(multiplier);
}
function getSwapsTokensReceivedFromTxMeta(tokenSymbol, txMeta, tokenAddress, accountAddress, tokenDecimals, approvalTxMeta, chainId) {
  var _txMeta$txReceipt;
  const txReceipt = txMeta === null || txMeta === void 0 ? void 0 : txMeta.txReceipt;
  const networkAndAccountSupports1559 = (txMeta === null || txMeta === void 0 ? void 0 : (_txMeta$txReceipt = txMeta.txReceipt) === null || _txMeta$txReceipt === void 0 ? void 0 : _txMeta$txReceipt.type) === _transaction.TransactionEnvelopeType.feeMarket;
  if ((0, _swaps.isSwapsDefaultTokenSymbol)(tokenSymbol, chainId)) {
    if (!txReceipt || !txMeta || !txMeta.postTxBalance || !txMeta.preTxBalance) {
      return null;
    }
    if (txMeta.swapMetaData && txMeta.preTxBalance === txMeta.postTxBalance) {
      // If preTxBalance and postTxBalance are equal, postTxBalance hasn't been updated on time
      // because of the RPC provider delay, so we return an estimated receiving amount instead.
      return txMeta.swapMetaData.token_to_amount;
    }
    let approvalTxGasCost = new _Numeric.Numeric('0x0', 16);
    if (approvalTxMeta && approvalTxMeta.txReceipt) {
      approvalTxGasCost = new _Numeric.Numeric(calcGasTotal(approvalTxMeta.txReceipt.gasUsed, networkAndAccountSupports1559 ? approvalTxMeta.txReceipt.effectiveGasPrice // Base fee + priority fee.
      : approvalTxMeta.txParams.gasPrice), 16);
    }
    const gasCost = calcGasTotal(txReceipt.gasUsed, networkAndAccountSupports1559 ? txReceipt.effectiveGasPrice : txMeta.txParams.gasPrice);
    const totalGasCost = new _Numeric.Numeric(gasCost, 16).add(approvalTxGasCost);
    const preTxBalanceLessGasCost = new _Numeric.Numeric(txMeta.preTxBalance, 16).minus(totalGasCost);
    const ethReceived = new _Numeric.Numeric(txMeta.postTxBalance, 16, _common.EtherDenomination.WEI).minus(preTxBalanceLessGasCost).toDenomination(_common.EtherDenomination.ETH).toBase(10).round(6);
    return ethReceived.toString();
  }
  const txReceiptLogs = txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.logs;
  if (txReceiptLogs && (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.status) !== '0x0') {
    const tokenTransferLog = txReceiptLogs.find(txReceiptLog => {
      const isTokenTransfer = txReceiptLog.topics && txReceiptLog.topics[0] === TOKEN_TRANSFER_LOG_TOPIC_HASH;
      const isTransferFromGivenToken = txReceiptLog.address === tokenAddress;
      const isTransferFromGivenAddress = txReceiptLog.topics && txReceiptLog.topics[2] && txReceiptLog.topics[2].match(accountAddress.slice(2));
      return isTokenTransfer && isTransferFromGivenToken && isTransferFromGivenAddress;
    });
    return tokenTransferLog ? toPrecisionWithoutTrailingZeros(calcTokenAmount(tokenTransferLog.data, tokenDecimals).toString(10), 6) : '';
  }
  return null;
}
const TRANSACTION_ENVELOPE_TYPE_NAMES = {
  FEE_MARKET: 'fee-market',
  LEGACY: 'legacy'
};
exports.TRANSACTION_ENVELOPE_TYPE_NAMES = TRANSACTION_ENVELOPE_TYPE_NAMES;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\lib\\transactions-controller-utils.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\Numeric.ts", {"../constants/common":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\common.ts","./hexstring-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\hexstring-utils.ts","@metamask/utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\utils\\dist\\index.js","bignumber.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\bignumber.js\\bignumber.js","bn.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\bn.js\\lib\\bn.js","ethereumjs-util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cmodules%5CNumeric.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Numeric = void 0;
var _bignumber = require("bignumber.js");
var _bn = _interopRequireDefault(require("bn.js"));
var _utils = require("@metamask/utils");
var _ethereumjsUtil = require("ethereumjs-util");
var _common = require("../constants/common");
var _hexstringUtils = require("./hexstring-utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * All variations of isHexString from our own utilities and etherumjs-utils
 * return false for a '-' prefixed hex string. This utility method strips the
 * possible '-' from the string before testing its validity so that negative
 * hex values can be properly handled.
 *
 * @param value - The string to check
 * @returns true if the value is a hex string (negative or otherwise)
 */
function isHexStringOrNegatedHexString(value) {
  return (0, _utils.isHexString)(value.replace('-', '')) || (0, _utils.isHexString)(value);
}

/**
 * BigNumber supports hex strings with '.' (aka decimals) in the string.
 * No version of isHexString returs true if the string contains a decimal so
 * this method is used to check if both parts of the string split by the
 * decimal are hex strings. If so we can feed this value into BigNumber to get
 * a valid Numeric.
 *
 * @param value - The string to check
 * @returns true if the string is a hexadecimal split by '.'
 */
function isDecimalHex(value) {
  const parts = value.split('.');
  if (parts.length === 1) {
    return false;
  }
  return parts.every(part => isHexStringOrNegatedHexString(part));
}

/**
 * Converts a hexadecimal in string or number format to a BigNumber.
 * Note that in many places in our codebase we call 'addHexPrefix' on a negated
 * hexadecimal string resulting in '0x-a' which will fail checks for
 * isHexString. Sometimes we DO not add the 0x so we have to check for '-a'
 * as well.
 *
 * @param value - hexadecimal value in string or number format.
 * @returns A BigNumber representation of the value
 */
function hexadecimalToBigNumber(value) {
  const stringified = typeof value === 'number' ? `${value}` : value;
  const isNegative = (0, _hexstringUtils.stripHexPrefix)(stringified)[0] === '-';
  const valueWithoutNegation = stringified.replace('-', '');
  const valueAsBigNumber = new _bignumber.BigNumber((0, _hexstringUtils.stripHexPrefix)(valueWithoutNegation), 16);
  return isNegative ? valueAsBigNumber.negated() : valueAsBigNumber;
}

/**
 * Converts a decimal in string or number format to a BigNumber.
 *
 * @param value - decimal value in string or number format.
 * @returns A BigNumber representation of the value
 */
function decimalToBigNumber(value) {
  return new _bignumber.BigNumber(String(value), 10);
}

/**
 * This method is used to safely convert a string type value to a BigNumber.
 * The only valid strings for this method are those that are either hexadecimal
 * numeric values OR numeric strings that can be converted to BigNumbers. It is
 * impossible to tell the difference between a hex value of 100000 vs a decimal
 * value of 100000 so a second parameter indicating the numeric base of the
 * string value must be provided.
 *
 * @param value - A hexadecimal or decimal string
 * @param numericBase - Either 16 for a hexadeciaml or 10 for a decimal
 * @returns A BigNumber representation of the value
 */
function stringToBigNumber(value, numericBase) {
  if (typeof value !== 'string') {
    throw new Error(`Value of type ${typeof value} passed to stringToBigNumber`);
  }
  if (numericBase === 16 && (isHexStringOrNegatedHexString(value) || isDecimalHex(value))) {
    return hexadecimalToBigNumber(value);
  } else if (numericBase === 10 && (
  // check if we have a finite integer or float
  isFinite(parseInt(value, 10)) || isFinite(parseFloat(value)))) {
    return decimalToBigNumber(value);
  }
  throw new Error(`String provided to stringToBigNumber is not a hexadecimal or decimal string: ${value}, ${numericBase}`);
}

/**
 * This method will convert a hexadecimal or deciaml number into a BigNumber.
 * The second parameter must be supplied and determines whether to treat the
 * value as a hexadecimal or decimal value.
 *
 * @param value - hexadecimal or decimal number[]
 * @param numericBase - 10 for decimal, 16 for hexadecimal
 * @returns BigNumber representation of the value
 */
function numberToBigNumber(value, numericBase) {
  if (typeof value !== 'number') {
    throw new Error(`Value of type ${typeof value} passed to numberToBigNumber`);
  }
  if (numericBase === 16 && (0, _utils.isHexString)(`${value}`)) {
    return new _bignumber.BigNumber(`${value}`, 16);
  }
  return new _bignumber.BigNumber(value, 10);
}

/**
 * Method to convert a BN to a BigNumber
 *
 * @param value - A BN representation of a value
 * @returns A BigNumber representation of the BN's underlying value
 */
function bnToBigNumber(value) {
  if (value instanceof _bn.default === false) {
    throw new Error(`value passed to bnToBigNumber is not a BN. Received type ${typeof value}`);
  }
  return new _bignumber.BigNumber(value.toString(16), 16);
}

/**
 * Converts a value of the supported types (string, number, BN) to a BigNumber.
 *
 * @param value - The value to convert to a BigNumber
 * @param numericBase - The numeric base of the underlying value
 * @returns A BigNumber representation of the value
 */
function valueToBigNumber(value, numericBase) {
  if (typeof value === 'string') {
    return stringToBigNumber(value, numericBase);
  } else if (typeof value === 'number' && isNaN(value) === false) {
    return numberToBigNumber(value, numericBase);
  }
  throw new Error(`Value: ${value} is not a string, number, BigNumber or BN. Type is: ${typeof value}.`);
}

// Big Number Constants
const BIG_NUMBER_WEI_MULTIPLIER = new _bignumber.BigNumber('1000000000000000000');
const BIG_NUMBER_GWEI_MULTIPLIER = new _bignumber.BigNumber('1000000000');
const BIG_NUMBER_ETH_MULTIPLIER = new _bignumber.BigNumber('1');
const toNormalizedDenomination = {
  WEI: bigNumber => bigNumber.div(BIG_NUMBER_WEI_MULTIPLIER),
  GWEI: bigNumber => bigNumber.div(BIG_NUMBER_GWEI_MULTIPLIER),
  ETH: bigNumber => bigNumber.div(BIG_NUMBER_ETH_MULTIPLIER)
};
const toSpecifiedDenomination = {
  WEI: bigNumber => bigNumber.times(BIG_NUMBER_WEI_MULTIPLIER).round(),
  GWEI: bigNumber => bigNumber.times(BIG_NUMBER_GWEI_MULTIPLIER).round(9),
  ETH: bigNumber => bigNumber.times(BIG_NUMBER_ETH_MULTIPLIER).round(9)
};

/**
 * Gets the value in ETH of the numeric supplied, used in this file only to
 * convert to ETH prior to converting to another denomination. The following
 * quirks were programmed into this method to replicate behavior of the
 * predecessor to Numeric, which was 'conversionUtil'. If a denomination is
 * not supplied, and toDenomination is called, then we assume the denomination
 * was originally ETH, otherwise we convert it to ETH.
 *
 * @param numeric
 * @returns value in ETH
 */
function getValueInETH(numeric) {
  if (numeric.denomination === _common.EtherDenomination.ETH || typeof numeric.denomination === 'undefined') {
    return numeric.value;
  }
  return toNormalizedDenomination[numeric.denomination](numeric.value);
}

/**
 * When applying operands to Numerics that have a specified Denomination then
 * we should first convert the provided inputNumeric to the same Denomination
 * as the baseNumeric. There are cases where this doesn't apply:
 *
 * 1. If the denominations are already the same. No conversion is necessary.
 * 2. If the inputNumeric does not have a denomination set. We assume in this
 * case that the value is already in the appropriate denomination.
 *
 * @param baseNumeric
 * @param inputNumeric
 * @returns
 */
function alignOperandDenominations(baseNumeric, inputNumeric) {
  if (typeof inputNumeric.denomination !== 'undefined' && baseNumeric.denomination !== inputNumeric.denomination) {
    return inputNumeric.toDenomination(baseNumeric.denomination);
  }
  return inputNumeric;
}

/**
 * Numeric is a class whose methods will always return a new, not mutated,
 * value. This allows for chaining of non-terminating methods. Previously we
 * had near a hundred helper methods that composed one-another, making tracking
 * through the chain near impossible. This API is designed such that no helper
 * methods should be needed. Take the case of hexWEIToDecGWEI, a helper method
 * for taking a hex string representing a value in WEI and converting that to a
 * decimal of GWEI. Prior to this class the method would call into our root
 * level 'conversionUtil' which was the proverbial kitchen sink doing
 * everything from denomination conversion, currency conversion (with provided
 * conversionRate prop) and more. The same opeartion can now be expressed as:
 * new Numeric(hexString, 16, EtherDenomination.WEI)
 * .toDenomination(EtherDenomination.GWEI)
 * .toBase(10)
 * .toString();
 * This has the benefit of being fairly transparent as you can read each step
 * in the chain and have a good sense of what is being done. It also is highly
 * composable so that we shouldn't need tons of helper methods for shortcuts.
 */
class Numeric {
  constructor(value, base, denomination) {
    /**
     * The underlying value of the Numeric, always in BigNumber form
     */
    _defineProperty(this, "value", void 0);
    /**
     * The numeric base for this Numeric, either 10 for decimal or 16 for Hex
     */
    _defineProperty(this, "base", void 0);
    /**
     * The current denomination, if any. The only supported denominations are
     * ETH, GWEI, WEI.
     */
    _defineProperty(this, "denomination", void 0);
    this.base = base;
    this.denomination = denomination;
    if (value instanceof _bignumber.BigNumber) {
      this.value = value;
    } else if (value instanceof _bn.default) {
      this.value = bnToBigNumber(value);
    } else if ((0, _utils.isNullOrUndefined)(value) || typeof value === 'number' && isNaN(value) || typeof value === 'string' && value === '') {
      // There are parts of the codebase that call this method without a value,
      // or with a 'NaN' (which is probably a bug somewhere in our tests?).
      // Over time of converting to TypeScript we will eradicate those, but the
      // helper methods that those instances employ would default the value to
      // 0. This block keeps that intact.
      this.value = new _bignumber.BigNumber('0', 10);
      this.base = 10;
    } else if (base) {
      this.value = valueToBigNumber(value, base);
    } else {
      throw new Error(`You must specify the base of the provided number if the value is not already a BigNumber`);
    }
  }

  /**
   * This is a tool used internally to check if a value is already a Numeric
   * and return it if it is, otherwise it uses the other provided arguments to
   * create a new Numeric.
   *
   * @param value - The value of the Numeric
   * @param base - Either undefined, 10 for decimal or 16 for hexadecimal
   * @param denomination - The Ether denomination to set, if any
   */
  static from(value, base, denomination) {
    if (value instanceof Numeric) {
      if (base || denomination) {
        throw new Error(`Numeric.from was called with a value (${value.toString()}) that is already a Numeric but a base and/or denomination was provided. Only supply base or denomination when creating a new Numeric`);
      }
      return value;
    }
    return new Numeric(value, base, denomination);
  }

  /** Conversions */

  /**
   * Returns a new Numeric with the base value changed to the provided base,
   * or the original Numeric if the base provided is the same as the current
   * base. No computation or conversion happens here but rather the result of
   * toString will be changed depending on the value of this.base when that
   * method is invoked.
   *
   * @param base - The numeric base to change the Numeric to, either 10 or 16
   * @returns A new Numeric with the base updated
   */
  toBase(base) {
    if (this.base !== base) {
      return new Numeric(this.value, base, this.denomination);
    }
    return this;
  }

  /**
   * Converts the value to the specified denomination. The following quirks of
   * the predecessor to Numeric, 'conversionUtil', were programmed into this
   * method:
   * 1. You may supply a denomination that is undefined, which will result in
   * nothing happening. Coincidently this is also useful due to the nature of
   * chaining operations on Numeric. You may pass an undefined value in this
   * method without breaking the chain to conditionally apply a operator.
   * 2. If the numeric that .toDenomination is called on does not have a
   * denomination set, that is it was constructed without the third parameter,
   * then it is assumed to be in ETH. Otherwise we convert it to ETH prior to
   * attempting to convert it to another denomination because all of the
   * toSpecifiedDenomination methods assume a value in ETH is passed.
   *
   * @param denomination - The denomination to convert to
   * @returns A new numeric with the same base as the previous, but the
   * value and denomination changed accordingly
   */
  toDenomination(denomination) {
    if (denomination && this.denomination !== denomination) {
      const result = new Numeric(toSpecifiedDenomination[denomination](getValueInETH(this)), this.base, denomination);
      return result;
    }
    return this;
  }

  /**
   * Replicates a method of BigNumber that is not in the version of BigNumber
   * that we use currently. Essentially shifting the decimal point backwards by
   * an amount equal to the positive number supplied to the decimals operator.
   * For example, calling shiftedBy(10) on the value 10000000000 will result in
   * a value of 1.0000000000. If passing a negative number, then the decimal
   * position will move forward. 1.0000000000 shiftedBy(-10) yields 10000000000
   *
   * @param decimals - The number of decimal places to move. Positive moves
   * decimal backwards, creating a smaller number. Negative values move the
   * decimal forwards, creating a larger number.
   * @returns A new numeric with the same base and denomination as the current
   * but with a new value.
   */
  shiftedBy(decimals) {
    const powerOf = new Numeric(Math.pow(10, decimals), 10);
    return this.divide(powerOf);
  }

  /**
   * Applies a conversion rate to the Numeric. If rate is undefined returns the
   * same instance that was operated on. Allowing an undefined value makes
   * chaining this operator feasible with undefined values from the user or
   * state without manipulating the number. For example:
   *
   * new Numeric(5, 10)
   * .applyConversionRate(possiblyUndefinedRate)
   * .toBase(16)
   * .toString();
   *
   * Will return a valid result as long as possiblyUndefinedRate is undefined,
   * a BigNumber or a number. In some areas of the codebase we check to see if
   * the target currency is different from the current currency before applying
   * a conversionRate. This functionality is not built into Numeric and will
   * require breaking the chain before calling this method:
   * let value = new Numeric(5, 10);
   *
   * if (fromCurrency !== toCurrency) {
   * value = value.applyConversionRate(possiblyUndefinedRate);
   * }
   *
   * return value.toBase(16).toString();
   *
   * @param rate - The multiplier to apply
   * @param invert - if true, inverts the rate
   * @returns New Numeric value with conversion rate applied.
   */
  applyConversionRate(rate, invert) {
    if (typeof rate === 'undefined') {
      return this;
    }
    let conversionRate = new Numeric(rate, 10);
    if (invert) {
      conversionRate = new Numeric(new _bignumber.BigNumber(1.0)).divide(conversionRate);
    }
    return this.times(conversionRate);
  }
  round(numberOfDecimals, roundingMode = _bignumber.BigNumber.ROUND_HALF_DOWN) {
    if (typeof numberOfDecimals === 'number') {
      return new Numeric(this.value.round(numberOfDecimals, roundingMode), this.base, this.denomination);
    }
    return this;
  }

  /**
   * TODO: make it possible to add ETH + GWEI value. So if you have
   * Numeric 1 with denomination ETH and Numeric 2 with Denomination WEI,
   * first convert Numeric 2 to ETH then add the amount to Numeric 1.
   *
   * @param value
   * @param base
   * @param denomination
   */
  add(value, base, denomination) {
    const numeric = Numeric.from(value, base, denomination);
    return new Numeric(this.value.add(alignOperandDenominations(this, numeric).value), this.base, this.denomination);
  }

  /**
   * TODO: make it possible to subtract ETH - GWEI value. So if you have
   * Numeric 1 with denomination ETH and Numeric 2 with Denomination WEI,
   * first convert Numeric 2 to ETH then subtract the amount from Numeric 1.
   *
   * @param value
   * @param base
   * @param denomination
   */
  minus(value, base, denomination) {
    const numeric = Numeric.from(value, base, denomination);
    return new Numeric(this.value.minus(alignOperandDenominations(this, numeric).value), this.base, this.denomination);
  }
  times(multiplier, base, denomination) {
    const multiplierNumeric = Numeric.from(multiplier, base, denomination);
    return new Numeric(this.value.times(alignOperandDenominations(this, multiplierNumeric).value), this.base, this.denomination);
  }

  /**
   * Divides the Numeric by another supplied Numeric, carrying over the base
   * and denomination from the current Numeric.
   *
   * @param divisor - The Numeric to divide this Numeric by
   * @param base
   * @param denomination
   * @returns A new Numeric that contains the result of the division
   */
  divide(divisor, base, denomination) {
    return new Numeric(this.value.div(alignOperandDenominations(this, Numeric.from(divisor, base, denomination)).value), this.base, this.denomination);
  }
  greaterThan(comparator, base, denomination) {
    return this.value.greaterThan(Numeric.from(comparator, base, denomination).value);
  }
  greaterThanOrEqualTo(comparator, base, denomination) {
    return this.value.greaterThanOrEqualTo(Numeric.from(comparator, base, denomination).value);
  }
  lessThan(comparator, base, denomination) {
    return this.value.lessThan(Numeric.from(comparator, base, denomination).value);
  }
  lessThanOrEqualTo(comparator, base, denomination) {
    return this.value.lessThanOrEqualTo(Numeric.from(comparator, base, denomination).value);
  }
  isNegative() {
    return this.value.isNegative();
  }
  isPositive() {
    return this.isNegative() === false;
  }

  /**
   * Get a base 16 hexadecimal string representation of the Numeric that is
   * 0x prefixed. This operation bypasses the currently set base of the
   * Numeric.
   *
   * @returns 0x prefixed hexstring.
   */
  toPrefixedHexString() {
    return (0, _ethereumjsUtil.addHexPrefix)(this.value.toString(16));
  }

  /**
   * Gets the string representation of the Numeric, using the current value of
   * this.base to determine if it should be a decimal or hexadecimal string.
   *
   * @returns the string representation of the Numeric
   */
  toString() {
    return this.value.toString(this.base);
  }

  /**
   * Returns a fixed-point decimal string representation of the Numeric
   *
   * @param decimals - the amount of decimal precision to use when rounding
   * @returns A fixed point decimal string represenation of the Numeric
   */
  toFixed(decimals) {
    return this.value.toFixed(decimals);
  }

  /**
   * Converts the value to a JavaScript Number, with all of the inaccuracy that
   * could come with that.
   *
   * @returns The value as a JS Number
   */
  toNumber() {
    return this.value.toNumber();
  }
}
exports.Numeric = Numeric;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\Numeric.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\browser-runtime.utils.js", {"loglevel":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\loglevel\\lib\\loglevel.js","webextension-polyfill":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\webextension-polyfill\\dist\\browser-polyfill.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cmodules%5Cbrowser-runtime.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkForLastError = checkForLastError;
exports.checkForLastErrorAndLog = checkForLastErrorAndLog;
exports.checkForLastErrorAndWarn = checkForLastErrorAndWarn;
var _webextensionPolyfill = _interopRequireDefault(require("webextension-polyfill"));
var _loglevel = _interopRequireDefault(require("loglevel"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * Utility Functions to support browser.runtime JavaScript API
 */

/**
 * Returns an Error if extension.runtime.lastError is present
 * this is a workaround for the non-standard error object that's used
 *
 * According to the docs, we are expected to check lastError in runtime API callbacks:
 * "
 * If you call an asynchronous function that may set lastError, you are expected to
 * check for the error when you handle the result of the function. If lastError has been
 * set and you don't check it within the callback function, then an error will be raised.
 * "
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/lastError}
 * @returns {Error|undefined}
 */
function checkForLastError() {
  const {
    lastError
  } = _webextensionPolyfill.default.runtime;
  if (!lastError) {
    return undefined;
  }
  // if it quacks like an Error, its an Error
  if (lastError.stack && lastError.message) {
    return lastError;
  }
  // repair incomplete error object (eg chromium v77)
  return new Error(lastError.message);
}

/** @returns {Error|undefined} */
function checkForLastErrorAndLog() {
  const error = checkForLastError();
  if (error) {
    _loglevel.default.error(error);
  }
  return error;
}

/** @returns {Error|undefined} */
function checkForLastErrorAndWarn() {
  const error = checkForLastError();
  if (error) {
    console.warn(error);
  }
  return error;
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\browser-runtime.utils.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\contract-utils.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cmodules%5Ccontract-utils.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readAddressAsContract = void 0;
const readAddressAsContract = async (ethQuery, address) => {
  let contractCode;
  try {
    contractCode = await ethQuery.getCode(address);
  } catch (e) {
    contractCode = null;
  }
  const isContractAddress = contractCode ? contractCode !== '0x' && contractCode !== '0x0' : false;
  return {
    contractCode,
    isContractAddress
  };
};
exports.readAddressAsContract = readAddressAsContract;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\contract-utils.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\conversion.utils.ts", {"../constants/common":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\common.ts","./Numeric":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\Numeric.ts","bignumber.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\bignumber.js\\bignumber.js","ethereumjs-util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cmodules%5Cconversion.utils.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addHexes = addHexes;
exports.bnToHex = bnToHex;
exports.decEthToConvertedCurrency = decEthToConvertedCurrency;
exports.decGWEIToHexWEI = decGWEIToHexWEI;
exports.decWEIToDecETH = decWEIToDecETH;
exports.decimalToHex = decimalToHex;
exports.getEthConversionFromWeiHex = getEthConversionFromWeiHex;
exports.getValueFromWeiHex = getValueFromWeiHex;
exports.getWeiHexFromDecimalValue = getWeiHexFromDecimalValue;
exports.hexToDecimal = hexToDecimal;
exports.hexWEIToDecETH = hexWEIToDecETH;
exports.hexWEIToDecGWEI = hexWEIToDecGWEI;
exports.subtractHexes = subtractHexes;
exports.sumHexes = sumHexes;
var _bignumber = require("bignumber.js");
var _ethereumjsUtil = require("ethereumjs-util");
var _common = require("../constants/common");
var _Numeric = require("./Numeric");
function decGWEIToHexWEI(decGWEI) {
  return new _Numeric.Numeric(decGWEI, 10, _common.EtherDenomination.GWEI).toBase(16).toDenomination(_common.EtherDenomination.WEI).toString();
}
function subtractHexes(aHexWEI, bHexWEI) {
  return new _Numeric.Numeric(aHexWEI, 16).minus(new _Numeric.Numeric(bHexWEI, 16)).round(6, _bignumber.BigNumber.ROUND_HALF_DOWN).toString();
}
function addHexes(aHexWEI, bHexWEI) {
  return new _Numeric.Numeric(aHexWEI, 16).add(new _Numeric.Numeric(bHexWEI, 16)).round(6, _bignumber.BigNumber.ROUND_HALF_DOWN).toString();
}
function decWEIToDecETH(decWEI) {
  return new _Numeric.Numeric(decWEI, 10, _common.EtherDenomination.WEI).toDenomination(_common.EtherDenomination.ETH).toString();
}
function hexWEIToDecETH(hexWEI) {
  return new _Numeric.Numeric(hexWEI, 16, _common.EtherDenomination.WEI).toDenomination(_common.EtherDenomination.ETH).toBase(10).toString();
}
function decEthToConvertedCurrency(ethTotal, convertedCurrency, conversionRate) {
  let numeric = new _Numeric.Numeric(ethTotal, 10, _common.EtherDenomination.ETH);
  if (convertedCurrency !== _common.EtherDenomination.ETH) {
    numeric = numeric.applyConversionRate(conversionRate);
  }
  return numeric.round(2);
}
function getWeiHexFromDecimalValue({
  value,
  conversionRate = 1,
  fromDenomination,
  fromCurrency,
  invertConversionRate = false
}) {
  let numeric = new _Numeric.Numeric(value, 10, fromDenomination);
  if (fromCurrency !== _common.EtherDenomination.ETH) {
    numeric = numeric.applyConversionRate(conversionRate, invertConversionRate);
  }
  return numeric.toBase(16).toDenomination(_common.EtherDenomination.WEI).toString();
}

/**
 * Converts a BN object to a hex string with a '0x' prefix
 *
 * @param inputBn - The BN to convert to a hex string
 * @returns A '0x' prefixed hex string
 */
function bnToHex(inputBn) {
  return (0, _ethereumjsUtil.addHexPrefix)(inputBn.toString(16));
}
function getEthConversionFromWeiHex({
  value,
  fromCurrency = _common.EtherDenomination.ETH,
  conversionRate,
  numberOfDecimals = 6
}) {
  const denominations = [_common.EtherDenomination.ETH, _common.EtherDenomination.GWEI, _common.EtherDenomination.WEI];
  let nonZeroDenomination;
  for (let i = 0; i < denominations.length; i++) {
    const convertedValue = getValueFromWeiHex({
      value,
      conversionRate,
      fromCurrency,
      toCurrency: fromCurrency,
      numberOfDecimals,
      toDenomination: denominations[i]
    });
    if (convertedValue !== '0' || i === denominations.length - 1) {
      nonZeroDenomination = `${convertedValue} ${denominations[i]}`;
      break;
    }
  }
  return nonZeroDenomination;
}
function getValueFromWeiHex({
  value,
  fromCurrency = _common.EtherDenomination.ETH,
  toCurrency,
  conversionRate,
  numberOfDecimals,
  toDenomination = _common.EtherDenomination.ETH
}) {
  let numeric = new _Numeric.Numeric(value, 16, _common.EtherDenomination.WEI);
  if (fromCurrency !== toCurrency) {
    numeric = numeric.applyConversionRate(conversionRate);
  }
  return numeric.toBase(10).toDenomination(toDenomination).round(numberOfDecimals, _bignumber.BigNumber.ROUND_HALF_DOWN).toString();
}
function sumHexes(first, ...args) {
  const firstValue = new _Numeric.Numeric(first, 16);
  const total = args.reduce((acc, hexAmount) => acc.add(new _Numeric.Numeric(hexAmount, 16)), firstValue);
  return total.toPrefixedHexString();
}
function hexWEIToDecGWEI(value) {
  return new _Numeric.Numeric(value, 16, _common.EtherDenomination.WEI).toBase(10).toDenomination(_common.EtherDenomination.GWEI).toString();
}
function decimalToHex(decimal) {
  return new _Numeric.Numeric(decimal, 10).toBase(16).toString();
}
function hexToDecimal(hexValue) {
  return new _Numeric.Numeric(hexValue, 16).toBase(10).toString();
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\conversion.utils.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\error.ts", {"loglevel":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cmodules%5Cerror.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isErrorWithMessage = isErrorWithMessage;
exports.logErrorWithMessage = logErrorWithMessage;
var _loglevel = _interopRequireDefault(require("loglevel"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * Type guard for determining whether the given value is an error object with a
 * `message` property, such as an instance of Error.
 *
 * TODO: Remove once this becomes available at @metamask/utils
 *
 * @param error - The object to check.
 * @returns True or false, depending on the result.
 */
function isErrorWithMessage(error) {
  return typeof error === 'object' && error !== null && 'message' in error;
}
function logErrorWithMessage(error) {
  if (isErrorWithMessage(error)) {
    _loglevel.default.error(error.message);
  } else {
    _loglevel.default.error(error);
  }
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\error.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\fetch-with-timeout.ts", {"../constants/time":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\time.ts","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cmodules%5Cfetch-with-timeout.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _time = require("../constants/time");
/**
 * Returns a function that can be used to make an HTTP request but timing out
 * automatically after a desired amount of time.
 *
 * @param timeout - The number of milliseconds to wait until the request times
 * out.
 * @returns A function that, when called, returns a promise that either resolves
 * to the HTTP response object or is rejected if a network error is encountered
 * or the request times out.
 */
const getFetchWithTimeout = (0, _lodash.memoize)((timeout = _time.SECOND * 30) => {
  if (!Number.isInteger(timeout) || timeout < 1) {
    throw new Error('Must specify positive integer timeout.');
  }
  return async function fetchWithTimeout(url, opts) {
    const abortController = new window.AbortController();
    const {
      signal
    } = abortController;
    const f = window.fetch(url, {
      ...opts,
      signal
    });
    const timer = setTimeout(() => abortController.abort(), timeout);
    try {
      return await f;
    } finally {
      clearTimeout(timer);
    }
  };
});
var _default = getFetchWithTimeout;
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\fetch-with-timeout.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\hexstring-utils.ts", {"ethereumjs-util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cmodules%5Chexstring-utils.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BURN_ADDRESS = void 0;
exports.isBurnAddress = isBurnAddress;
exports.isEmptyHexString = isEmptyHexString;
exports.isValidHexAddress = isValidHexAddress;
exports.stripHexPrefix = stripHexPrefix;
exports.toChecksumHexAddress = toChecksumHexAddress;
var _ethereumjsUtil = require("ethereumjs-util");
const BURN_ADDRESS = (0, _ethereumjsUtil.zeroAddress)();
exports.BURN_ADDRESS = BURN_ADDRESS;
function isBurnAddress(address) {
  return address === BURN_ADDRESS;
}
function isEmptyHexString(value) {
  return [undefined, null, '0x', '0x0', '0x0000000000000000000000000000000000000000000000000000000000000000'].includes(value);
}

/**
 * Validates that the input is a hex address. This utility method is a thin
 * wrapper around ethereumjs-util.isValidAddress, with the exception that it
 * does not throw an error when provided values that are not hex strings. In
 * addition, and by default, this method will return true for hex strings that
 * meet the length requirement of a hex address, but are not prefixed with `0x`
 * Finally, if the mixedCaseUseChecksum flag is true and a mixed case string is
 * provided this method will validate it has the proper checksum formatting.
 *
 * @param possibleAddress - Input parameter to check against
 * @param [options] - options bag
 * @param [options.allowNonPrefixed] - If true will first ensure '0x'
 * is prepended to the string
 * @param [options.mixedCaseUseChecksum] - If true will treat mixed
 * case addresses as checksum addresses and validate that proper checksum
 * format is used
 * @returns whether or not the input is a valid hex address
 */
function isValidHexAddress(possibleAddress, {
  allowNonPrefixed = true,
  mixedCaseUseChecksum = false
} = {}) {
  const addressToCheck = allowNonPrefixed ? (0, _ethereumjsUtil.addHexPrefix)(possibleAddress) : possibleAddress;
  if (!(0, _ethereumjsUtil.isHexString)(addressToCheck)) {
    return false;
  }
  if (mixedCaseUseChecksum) {
    const prefixRemoved = addressToCheck.slice(2);
    const lower = prefixRemoved.toLowerCase();
    const upper = prefixRemoved.toUpperCase();
    const allOneCase = prefixRemoved === lower || prefixRemoved === upper;
    if (!allOneCase) {
      return (0, _ethereumjsUtil.isValidChecksumAddress)(addressToCheck);
    }
  }
  return (0, _ethereumjsUtil.isValidAddress)(addressToCheck);
}
function toChecksumHexAddress(address) {
  if (!address) {
    // our internal checksumAddress function that this method replaces would
    // return an empty string for nullish input. If any direct usages of
    // ethereumjs-util.toChecksumAddress were called with nullish input it
    // would have resulted in an error on version 5.1.
    return '';
  }
  const hexPrefixed = (0, _ethereumjsUtil.addHexPrefix)(address);
  if (!(0, _ethereumjsUtil.isHexString)(hexPrefixed)) {
    // Version 5.1 of ethereumjs-utils would have returned '0xY' for input 'y'
    // but we shouldn't waste effort trying to change case on a clearly invalid
    // string. Instead just return the hex prefixed original string which most
    // closely mimics the original behavior.
    return hexPrefixed;
  }
  return (0, _ethereumjsUtil.toChecksumAddress)(hexPrefixed);
}
function stripHexPrefix(str) {
  if (typeof str !== 'string') {
    return str;
  }
  return (0, _ethereumjsUtil.isHexPrefixed)(str) ? str.slice(2) : str;
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\hexstring-utils.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\mv3.utils.js", {"webextension-polyfill":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\webextension-polyfill\\dist\\browser-polyfill.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cmodules%5Cmv3.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isManifestV3 = void 0;
var _webextensionPolyfill = _interopRequireDefault(require("webextension-polyfill"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const isManifestV3 = _webextensionPolyfill.default.runtime.getManifest().manifest_version === 3;
exports.isManifestV3 = isManifestV3;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\mv3.utils.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\network.utils.ts", {"../constants/network":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\network.ts"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cmodules%5Cnetwork.utils.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPrefixedFormattedHexString = isPrefixedFormattedHexString;
exports.isSafeChainId = isSafeChainId;
exports.isTokenDetectionEnabledForNetwork = isTokenDetectionEnabledForNetwork;
var _network = require("../constants/network");
/**
 * Checks whether the given number primitive chain ID is safe.
 * Because some cryptographic libraries we use expect the chain ID to be a
 * number primitive, it must not exceed a certain size.
 *
 * @param chainId - The chain ID to check for safety.
 * @returns Whether the given chain ID is safe.
 */
function isSafeChainId(chainId) {
  return isSafeInteger(chainId) && chainId > 0 && chainId <= _network.MAX_SAFE_CHAIN_ID;
}

/**
 * Checks whether the given value is a 0x-prefixed, non-zero, non-zero-padded,
 * hexadecimal string.
 *
 * @param value - The value to check.
 * @returns True if the value is a correctly formatted hex string,
 * false otherwise.
 */
function isPrefixedFormattedHexString(value) {
  if (typeof value !== 'string') {
    return false;
  }
  return /^0x[1-9a-f]+[0-9a-f]*$/iu.test(value);
}

/**
 * Check if token detection is enabled for certain networks
 *
 * @param chainId - ChainID of network
 * @returns Whether the current network supports token detection
 */
function isTokenDetectionEnabledForNetwork(chainId) {
  switch (chainId) {
    case _network.CHAIN_IDS.MAINNET:
    case _network.CHAIN_IDS.BSC:
    case _network.CHAIN_IDS.POLYGON:
    case _network.CHAIN_IDS.AVALANCHE:
    case _network.CHAIN_IDS.AURORA:
      return true;
    default:
      return false;
  }
}

/**
 * Like {@link Number.isSafeInteger}, but types the input as a `number` if it is
 * indeed a safe integer.
 *
 * @param value - The value to check.
 * @returns True if the value is a safe integer, false otherwise.
 */
function isSafeInteger(value) {
  return Number.isSafeInteger(value);
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\network.utils.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\object.utils.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cmodules%5Cobject.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.maskObject = maskObject;
/**
 * Return a "masked" copy of the given object.
 *
 * The returned object includes only the properties present in the mask. The
 * mask is an object that mirrors the structure of the given object, except
 * the only values are `true` or a sub-mask. `true` implies the property
 * should be included, and a sub-mask implies the property should be further
 * masked according to that sub-mask.
 *
 * @param {object} object - The object to mask
 * @param {Object<object | boolean>} mask - The mask to apply to the object
 */
function maskObject(object, mask) {
  return Object.keys(object).reduce((state, key) => {
    if (mask[key] === true) {
      state[key] = object[key];
    } else if (mask[key]) {
      state[key] = maskObject(object[key], mask[key]);
    }
    return state;
  }, {});
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\object.utils.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\random-id.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cmodules%5Crandom-id.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createRandomId;
const MAX = Number.MAX_SAFE_INTEGER;
let idCounter = Math.round(Math.random() * MAX);
function createRandomId() {
  idCounter %= MAX;
  // eslint-disable-next-line no-plusplus
  return idCounter++;
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\random-id.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\string-utils.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cmodules%5Cstring-utils.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isEqualCaseInsensitive = isEqualCaseInsensitive;
exports.prependZero = prependZero;
/**
 * Compare 2 given strings and return boolean
 * eg: "foo" and "FOO" => true
 * eg: "foo" and "bar" => false
 * eg: "foo" and 123 => false
 *
 * @param value1 - first string to compare
 * @param value2 - first string to compare
 * @returns true if 2 strings are identical when they are lowercase
 */
function isEqualCaseInsensitive(value1, value2) {
  if (typeof value1 !== 'string' || typeof value2 !== 'string') {
    return false;
  }
  return value1.toLowerCase() === value2.toLowerCase();
}

/**
 * Takes a number with max length until the resulting string reaches the given length
 *
 * @param num
 * @param maxLength
 */
function prependZero(num, maxLength) {
  return num.toString().padStart(maxLength, '0');
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\string-utils.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\swaps.utils.js", {"../constants/swaps":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\swaps.ts"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cmodules%5Cswaps.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSwapsDefaultTokenAddress = isSwapsDefaultTokenAddress;
exports.isSwapsDefaultTokenSymbol = isSwapsDefaultTokenSymbol;
var _swaps = require("../constants/swaps");
/**
 * Checks whether the provided address is strictly equal to the address for
 * the default swaps token of the provided chain.
 *
 * @param {string} address - The string to compare to the default token address
 * @param {string} chainId - The hex encoded chain ID of the default swaps token to check
 * @returns {boolean} Whether the address is the provided chain's default token address
 */
function isSwapsDefaultTokenAddress(address, chainId) {
  var _SWAPS_CHAINID_DEFAUL;
  if (!address || !chainId) {
    return false;
  }
  return address === ((_SWAPS_CHAINID_DEFAUL = _swaps.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId]) === null || _SWAPS_CHAINID_DEFAUL === void 0 ? void 0 : _SWAPS_CHAINID_DEFAUL.address);
}

/**
 * Checks whether the provided symbol is strictly equal to the symbol for
 * the default swaps token of the provided chain.
 *
 * @param {string} symbol - The string to compare to the default token symbol
 * @param {string} chainId - The hex encoded chain ID of the default swaps token to check
 * @returns {boolean} Whether the symbl is the provided chain's default token symbol
 */
function isSwapsDefaultTokenSymbol(symbol, chainId) {
  var _SWAPS_CHAINID_DEFAUL2;
  if (!symbol || !chainId) {
    return false;
  }
  return symbol === ((_SWAPS_CHAINID_DEFAUL2 = _swaps.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId]) === null || _SWAPS_CHAINID_DEFAUL2 === void 0 ? void 0 : _SWAPS_CHAINID_DEFAUL2.symbol);
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\swaps.utils.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\transaction.utils.js", {"../constants/transaction":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\transaction.ts","./contract-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\contract-utils.ts","./string-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\string-utils.ts","@ethersproject/abi":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ethersproject\\abi\\lib\\index.js","@metamask/metamask-eth-abis":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\metamask-eth-abis\\dist\\index.js","ethereumjs-util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\ethereumjs-util\\dist.browser\\index.js","loglevel":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cmodules%5Ctransaction.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.determineTransactionAssetType = determineTransactionAssetType;
exports.determineTransactionContractCode = determineTransactionContractCode;
exports.determineTransactionType = determineTransactionType;
exports.isEIP1559Transaction = isEIP1559Transaction;
exports.isLegacyTransaction = isLegacyTransaction;
exports.parseStandardTokenTransactionData = parseStandardTokenTransactionData;
exports.transactionMatchesNetwork = transactionMatchesNetwork;
exports.txParamsAreDappSuggested = txParamsAreDappSuggested;
var _ethereumjsUtil = require("ethereumjs-util");
var _abi = require("@ethersproject/abi");
var _metamaskEthAbis = require("@metamask/metamask-eth-abis");
var _loglevel = _interopRequireDefault(require("loglevel"));
var _transaction = require("../constants/transaction");
var _contractUtils = require("./contract-utils");
var _stringUtils = require("./string-utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @typedef { 'transfer' | 'approve' | 'setapprovalforall' | 'transferfrom' | 'contractInteraction'| 'simpleSend' } InferrableTransactionTypes
 */

/**
 * @typedef {object} InferTransactionTypeResult
 * @property {InferrableTransactionTypes} type - The type of transaction
 * @property {string} getCodeResponse - The contract code, in hex format if
 *  it exists. '0x0' or '0x' are also indicators of non-existent contract
 *  code
 */
/**
 * @typedef EthersContractCall
 * @type object
 * @property {any[]} args - The args/params to the function call.
 * An array-like object with numerical and string indices.
 * @property {string} name - The name of the function.
 * @property {string} signature - The function signature.
 * @property {string} sighash - The function signature hash.
 * @property {EthersBigNumber} value - The ETH value associated with the call.
 * @property {FunctionFragment} functionFragment - The Ethers function fragment
 * representation of the function.
 */
const erc20Interface = new _abi.Interface(_metamaskEthAbis.abiERC20);
const erc721Interface = new _abi.Interface(_metamaskEthAbis.abiERC721);
const erc1155Interface = new _abi.Interface(_metamaskEthAbis.abiERC1155);
function transactionMatchesNetwork(transaction, chainId, networkId) {
  if (typeof transaction.chainId !== 'undefined') {
    return transaction.chainId === chainId;
  }
  return transaction.metamaskNetworkId === networkId;
}

/**
 * Determines if the maxFeePerGas and maxPriorityFeePerGas fields are supplied
 * and valid inputs. This will return false for non hex string inputs.
 *
 * @param {__import__("../constants/transaction").TransactionMeta} transaction -
 *  the transaction to check
 * @returns {boolean} true if transaction uses valid EIP1559 fields
 */
function isEIP1559Transaction(transaction) {
  var _transaction$txParams, _transaction$txParams2;
  return (0, _ethereumjsUtil.isHexString)(transaction === null || transaction === void 0 ? void 0 : (_transaction$txParams = transaction.txParams) === null || _transaction$txParams === void 0 ? void 0 : _transaction$txParams.maxFeePerGas) && (0, _ethereumjsUtil.isHexString)(transaction === null || transaction === void 0 ? void 0 : (_transaction$txParams2 = transaction.txParams) === null || _transaction$txParams2 === void 0 ? void 0 : _transaction$txParams2.maxPriorityFeePerGas);
}

/**
 * Determine if the maxFeePerGas and maxPriorityFeePerGas fields are not
 * supplied and that the gasPrice field is valid if it is provided. This will
 * return false if gasPrice is a non hex string.
 *
 * @param {__import__("../constants/transaction").TransactionMeta} transaction -
 *  the transaction to check
 * @returns {boolean} true if transaction uses valid Legacy fields OR lacks
 *  EIP1559 fields
 */
function isLegacyTransaction(transaction) {
  return typeof transaction.txParams.maxFeePerGas === 'undefined' && typeof transaction.txParams.maxPriorityFeePerGas === 'undefined' && (typeof transaction.txParams.gasPrice === 'undefined' || (0, _ethereumjsUtil.isHexString)(transaction.txParams.gasPrice));
}

/**
 * Determine if a transactions gas fees in txParams match those in its dappSuggestedGasFees property
 *
 * @param {__import__("../constants/transaction").TransactionMeta} transaction -
 *  the transaction to check
 * @returns {boolean} true if both the txParams and dappSuggestedGasFees are objects with truthy gas fee properties,
 *   and those properties are strictly equal
 */
function txParamsAreDappSuggested(transaction) {
  var _transaction$dappSugg, _transaction$dappSugg2, _transaction$dappSugg3;
  const {
    gasPrice,
    maxPriorityFeePerGas,
    maxFeePerGas
  } = (transaction === null || transaction === void 0 ? void 0 : transaction.txParams) || {};
  return gasPrice && gasPrice === (transaction === null || transaction === void 0 ? void 0 : (_transaction$dappSugg = transaction.dappSuggestedGasFees) === null || _transaction$dappSugg === void 0 ? void 0 : _transaction$dappSugg.gasPrice) || maxPriorityFeePerGas && maxFeePerGas && (transaction === null || transaction === void 0 ? void 0 : (_transaction$dappSugg2 = transaction.dappSuggestedGasFees) === null || _transaction$dappSugg2 === void 0 ? void 0 : _transaction$dappSugg2.maxPriorityFeePerGas) === maxPriorityFeePerGas && (transaction === null || transaction === void 0 ? void 0 : (_transaction$dappSugg3 = transaction.dappSuggestedGasFees) === null || _transaction$dappSugg3 === void 0 ? void 0 : _transaction$dappSugg3.maxFeePerGas) === maxFeePerGas;
}

/**
 * Attempts to decode transaction data using ABIs for three different token standards: ERC20, ERC721, ERC1155.
 * The data will decode correctly if the transaction is an interaction with a contract that matches one of these
 * contract standards
 *
 * @param data - encoded transaction data
 * @returns {EthersContractCall | undefined}
 */
function parseStandardTokenTransactionData(data) {
  try {
    return erc20Interface.parseTransaction({
      data
    });
  } catch {
    // ignore and next try to parse with erc721 ABI
  }
  try {
    return erc721Interface.parseTransaction({
      data
    });
  } catch {
    // ignore and next try to parse with erc1155 ABI
  }
  try {
    return erc1155Interface.parseTransaction({
      data
    });
  } catch {
    // ignore and return undefined
  }
  return undefined;
}

/**
 * Determines the contractCode of the transaction by analyzing the txParams.
 *
 * @param {object} txParams - Parameters for the transaction
 * @param {EthQuery} query - EthQuery instance
 * @returns {InferTransactionTypeResult}
 */
async function determineTransactionContractCode(txParams, query) {
  const {
    to
  } = txParams;
  const {
    contractCode
  } = await (0, _contractUtils.readAddressAsContract)(query, to);
  return contractCode;
}

/**
 * Determines the type of the transaction by analyzing the txParams.
 * This method will return one of the types defined in shared/constants/transactions
 * It will never return TRANSACTION_TYPE_CANCEL or TRANSACTION_TYPE_RETRY as these
 * represent specific events that we control from the extension and are added manually
 * at transaction creation.
 *
 * @param {object} txParams - Parameters for the transaction
 * @param {EthQuery} query - EthQuery instance
 * @returns {InferTransactionTypeResult}
 */
async function determineTransactionType(txParams, query) {
  const {
    data,
    to
  } = txParams;
  let name;
  try {
    ({
      name
    } = data && parseStandardTokenTransactionData(data));
  } catch (error) {
    _loglevel.default.debug('Failed to parse transaction data.', error, data);
  }
  let result;
  let contractCode;
  if (data && !to) {
    result = _transaction.TransactionType.deployContract;
  } else {
    const {
      contractCode: resultCode,
      isContractAddress
    } = await (0, _contractUtils.readAddressAsContract)(query, to);
    contractCode = resultCode;
    if (isContractAddress) {
      const hasValue = txParams.value && txParams.value !== '0x0';
      const tokenMethodName = [_transaction.TransactionType.tokenMethodApprove, _transaction.TransactionType.tokenMethodSetApprovalForAll, _transaction.TransactionType.tokenMethodTransfer, _transaction.TransactionType.tokenMethodTransferFrom, _transaction.TransactionType.tokenMethodSafeTransferFrom].find(methodName => (0, _stringUtils.isEqualCaseInsensitive)(methodName, name));
      result = data && tokenMethodName && !hasValue ? tokenMethodName : _transaction.TransactionType.contractInteraction;
    } else {
      result = _transaction.TransactionType.simpleSend;
    }
  }
  return {
    type: result,
    getCodeResponse: contractCode
  };
}
const INFERRABLE_TRANSACTION_TYPES = [_transaction.TransactionType.tokenMethodApprove, _transaction.TransactionType.tokenMethodSetApprovalForAll, _transaction.TransactionType.tokenMethodTransfer, _transaction.TransactionType.tokenMethodTransferFrom, _transaction.TransactionType.contractInteraction, _transaction.TransactionType.simpleSend];

/**
 * Given a transaction meta object, determine the asset type that the
 * transaction is dealing with, as well as the standard for the token if it
 * is a token transaction.
 *
 * @param {__import__('../constants/transaction').TransactionMeta} txMeta -
 *  transaction meta object
 * @param {EthQuery} query - EthQuery instance
 * @param {Function} getTokenStandardAndDetails - function to get token
 *  standards and details.
 * @returns {{ assetType: string, tokenStandard: string}}
 */
async function determineTransactionAssetType(txMeta, query, getTokenStandardAndDetails) {
  // If the transaction type is already one of the inferrable types, then we do
  // not need to re-establish the type.
  let inferrableType = txMeta.type;
  if (INFERRABLE_TRANSACTION_TYPES.includes(txMeta.type) === false) {
    // Because we will deal with all types of transactions (including swaps)
    // we want to get an inferrable type of transaction that isn't special cased
    // that way we can narrow the number of logic gates required.
    const result = await determineTransactionType(txMeta.txParams, query);
    inferrableType = result.type;
  }

  // If the inferred type of the transaction is one of those that are part of
  // the token contract standards, we can use the getTokenStandardAndDetails
  // method to get the asset type.
  const isTokenMethod = [_transaction.TransactionType.tokenMethodApprove, _transaction.TransactionType.tokenMethodSetApprovalForAll, _transaction.TransactionType.tokenMethodTransfer, _transaction.TransactionType.tokenMethodTransferFrom].find(methodName => methodName === inferrableType);
  if (isTokenMethod ||
  // We can also check any contract interaction type to see if the to address
  // is a token contract. If it isn't, then the method will throw and we can
  // fall through to the other checks.
  inferrableType === _transaction.TransactionType.contractInteraction) {
    try {
      // We don't need a balance check, so the second parameter to
      // getTokenStandardAndDetails is omitted.
      const details = await getTokenStandardAndDetails(txMeta.txParams.to);
      if (details.standard) {
        return {
          assetType: details.standard === _transaction.TokenStandard.ERC20 ? _transaction.AssetType.token : _transaction.AssetType.NFT,
          tokenStandard: details.standard
        };
      }
    } catch {
      // noop, We expect errors here but we don't need to report them or do
      // anything in response.
    }
  }

  // If the transaction is interacting with a contract but isn't a token method
  // we use the 'UNKNOWN' value to show that it isn't a transaction sending any
  // particular asset.
  if (inferrableType === _transaction.TransactionType.contractInteraction) {
    return {
      assetType: _transaction.AssetType.unknown,
      tokenStandard: _transaction.TokenStandard.none
    };
  }
  return {
    assetType: _transaction.AssetType.native,
    tokenStandard: _transaction.TokenStandard.none
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\transaction.utils.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\notifications\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cshared%5Cnotifications%5Cindex.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTranslatedUINotifications = exports.UI_NOTIFICATIONS = void 0;
// Messages and descriptions for these locale keys are in app/_locales/en/messages.json
const UI_NOTIFICATIONS = {
  1: {
    id: 1,
    date: '2021-03-17',
    image: {
      src: 'images/mobile-link-qr.svg',
      height: '230px',
      width: '230px',
      placeImageBelowDescription: true
    }
  },
  3: {
    id: 3,
    date: '2021-03-08'
  },
  4: {
    id: 4,
    date: '2021-05-11',
    image: {
      src: 'images/source-logos-bsc.svg',
      width: '100%'
    }
  },
  5: {
    id: 5,
    date: '2021-06-09'
  },
  6: {
    id: 6,
    date: '2021-05-26'
  },
  7: {
    id: 7,
    date: '2021-09-17'
  },
  8: {
    id: 8,
    date: '2021-11-01'
  },
  9: {
    id: 9,
    date: '2021-12-07',
    image: {
      src: 'images/txinsights.png',
      width: '80%'
    }
  },
  10: {
    id: 10,
    date: '2022-09-15',
    image: {
      src: 'images/token-detection.svg',
      width: '100%'
    }
  },
  11: {
    id: 11,
    date: '2022-09-15'
  },
  12: {
    id: 12,
    date: '2022-05-18',
    image: {
      src: 'images/darkmode-banner.png',
      width: '100%'
    }
  },
  13: {
    id: 13,
    date: '2022-09-15'
  },
  14: {
    id: 14,
    date: '2022-09-15'
  },
  15: {
    id: 15,
    date: '2022-09-15'
  },
  16: {
    id: 16,
    date: null
  },
  17: {
    id: 17,
    date: null
  },
  18: {
    id: 18,
    date: null,
    image: {
      src: 'images/open-sea-security-provider.svg',
      width: '100%'
    }
  },
  19: {
    id: 19,
    date: null,
    image: {
      src: 'images/nfts.svg',
      width: '100%'
    }
  },
  20: {
    id: 20,
    date: null
  }
};
exports.UI_NOTIFICATIONS = UI_NOTIFICATIONS;
const getTranslatedUINotifications = (t, locale) => {
  const formattedLocale = locale.replace('_', '-');
  return {
    1: {
      ...UI_NOTIFICATIONS[1],
      title: t('notifications1Title'),
      description: t('notifications1Description'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[1].date))
    },
    3: {
      ...UI_NOTIFICATIONS[3],
      title: t('notifications3Title'),
      description: t('notifications3Description'),
      actionText: t('notifications3ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[3].date))
    },
    4: {
      ...UI_NOTIFICATIONS[4],
      title: t('notifications4Title'),
      description: t('notifications4Description'),
      actionText: t('notifications4ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[4].date))
    },
    5: {
      ...UI_NOTIFICATIONS[5],
      title: t('secretRecoveryPhrase'),
      description: t('notifications5Description'),
      actionText: t('notifications3ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[5].date))
    },
    6: {
      ...UI_NOTIFICATIONS[6],
      title: t('notifications6Title'),
      description: [t('notifications6DescriptionOne'), t('notifications6DescriptionTwo'), t('notifications6DescriptionThree')],
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[6].date))
    },
    7: {
      ...UI_NOTIFICATIONS[7],
      title: t('notifications7Title'),
      description: [t('notifications7DescriptionOne'), t('notifications7DescriptionTwo')],
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[7].date))
    },
    8: {
      ...UI_NOTIFICATIONS[8],
      title: t('notifications8Title'),
      description: [t('notifications8DescriptionOne'), t('notifications8DescriptionTwo')],
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[8].date)),
      actionText: t('notifications8ActionText')
    },
    9: {
      ...UI_NOTIFICATIONS[9],
      title: t('notifications9Title'),
      description: [t('notifications9DescriptionOne'), t('notifications9DescriptionTwo')],
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[9].date))
    },
    10: {
      ...UI_NOTIFICATIONS[10],
      title: t('notifications10Title'),
      description: [t('notifications10DescriptionOne'), t('notifications10DescriptionTwo'), t('notifications10DescriptionThree')],
      actionText: t('notifications10ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[10].date))
    },
    11: {
      ...UI_NOTIFICATIONS[11],
      title: t('notifications11Title'),
      description: t('notifications11Description'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[11].date))
    },
    12: {
      ...UI_NOTIFICATIONS[12],
      title: t('notifications12Title'),
      description: t('notifications12Description'),
      actionText: t('notifications12ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[12].date))
    },
    13: {
      ...UI_NOTIFICATIONS[13],
      title: t('notifications13Title'),
      description: t('notifications13Description'),
      actionText: t('notifications13ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[13].date))
    },
    14: {
      ...UI_NOTIFICATIONS[14],
      title: t('notifications14Title'),
      description: t('notifications14Description'),
      actionText: t('notifications14ActionText'),
      date: UI_NOTIFICATIONS[14].date ? new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[14].date)) : ''
    },
    15: {
      ...UI_NOTIFICATIONS[15],
      title: t('notifications15Title'),
      description: t('notifications15Description'),
      date: UI_NOTIFICATIONS[15].date ? new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[15].date)) : ''
    },
    18: {
      ...UI_NOTIFICATIONS[18],
      title: t('notifications18Title'),
      description: [t('notifications18DescriptionOne'), t('notifications18DescriptionTwo'), t('notifications18DescriptionThree')],
      actionText: t('notifications18ActionText'),
      date: UI_NOTIFICATIONS[18].date ? new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[18].date)) : ''
    },
    19: {
      ...UI_NOTIFICATIONS[19],
      title: t('notifications19Title'),
      description: [t('notifications19DescriptionOne'), t('notifications19DescriptionTwo'), t('notifications19DescriptionThree')],
      actionText: t('notifications19ActionText'),
      date: UI_NOTIFICATIONS[19].date ? new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[19].date)) : ''
    },
    20: {
      ...UI_NOTIFICATIONS[20],
      title: t('notifications20Title'),
      description: [t('notifications20Description')],
      actionText: t('notifications20ActionText'),
      date: UI_NOTIFICATIONS[20].date ? new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[20].date)) : ''
    }
  };
};
exports.getTranslatedUINotifications = getTranslatedUINotifications;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\notifications\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\ui\\helpers\\constants\\common.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cui%5Chelpers%5Cconstants%5Ccommon.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SUPPORT_REQUEST_LINK = exports.SECONDARY = exports.PRIMARY = exports.PASSWORD_MIN_LENGTH = exports.OUTDATED_BROWSER_VERSIONS = exports.CONTRACT_ADDRESS_LINK = void 0;
const PRIMARY = 'PRIMARY';
exports.PRIMARY = PRIMARY;
const SECONDARY = 'SECONDARY';
exports.SECONDARY = SECONDARY;
const _contractAddressLink = 'https://metamask.zendesk.com/hc/en-us/articles/360020028092-What-is-the-known-contract-address-warning-';

// eslint-disable-next-line prefer-destructuring
const SUPPORT_REQUEST_LINK = "https://metamask.zendesk.com/hc/en-us";
exports.SUPPORT_REQUEST_LINK = SUPPORT_REQUEST_LINK;
const CONTRACT_ADDRESS_LINK = _contractAddressLink;
exports.CONTRACT_ADDRESS_LINK = CONTRACT_ADDRESS_LINK;
const PASSWORD_MIN_LENGTH = 8;
exports.PASSWORD_MIN_LENGTH = PASSWORD_MIN_LENGTH;
const OUTDATED_BROWSER_VERSIONS = {
  // Chrome and Edge should match the latest Chrome version released ~2 years ago
  chrome: '<90',
  edge: '<90',
  // Firefox should match the most recent end-of-life extended support release
  firefox: '<91',
  // Opera should be set to the equivalent of the Chrome version set
  // See https://en.wikipedia.org/wiki/History_of_the_Opera_web_browser
  opera: '<76'
};
exports.OUTDATED_BROWSER_VERSIONS = OUTDATED_BROWSER_VERSIONS;

      };
    };
  }
  }
}, {package:"$root$",file:"ui\\helpers\\constants\\common.ts",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\ui\\helpers\\utils\\build-types.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cui%5Chelpers%5Cutils%5Cbuild-types.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBuildSpecificAsset = getBuildSpecificAsset;
exports.isBeta = isBeta;
const assetList = {
  main: {
    // Will use default provided by the @metamask/logo library
    foxMeshJson: undefined
  }
};
function isBeta() {
  return "main" === 'beta';
}

// Returns a specific version of an asset based on
// the current metamask version (i.e. main, beta, etc.)
function getBuildSpecificAsset(assetName) {
  const buildType = "main";
  if (!assetList[buildType] || !Object.keys(assetList[buildType]).includes(assetName)) {
    console.error(`Cannot find asset "${assetName}" for build "${buildType}", returning main build asset.`);
    return assetList.main[assetName];
  }
  return assetList[buildType][assetName];
}

      };
    };
  }
  }
}, {package:"$root$",file:"ui\\helpers\\utils\\build-types.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\ui\\helpers\\utils\\optimism\\buildUnserializedTransaction.js", {"../../../../shared/modules/hexstring-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\hexstring-utils.ts","@ethereumjs/common":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ethereumjs\\common\\dist\\index.js","@ethereumjs/tx":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ethereumjs\\tx\\dist\\index.js","ethereumjs-util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\ethereumjs-util\\dist.browser\\index.js","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cui%5Chelpers%5Cutils%5Coptimism%5CbuildUnserializedTransaction.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = buildUnserializedTransaction;
var _lodash = require("lodash");
var _ethereumjsUtil = require("ethereumjs-util");
var _common = require("@ethereumjs/common");
var _tx = require("@ethereumjs/tx");
var _hexstringUtils = require("../../../../shared/modules/hexstring-utils");
function buildTxParams(txMeta) {
  return {
    ...(0, _lodash.omit)(txMeta.txParams, 'gas'),
    gasLimit: txMeta.txParams.gas
  };
}
function buildTransactionCommon(txMeta) {
  // This produces a transaction whose information does not completely match an
  // Optimism transaction  for instance, DEFAULT_CHAIN is still 'mainnet' and
  // genesis points to the mainnet genesis, not the Optimism genesis  but
  // considering that all we want to do is serialize a transaction, this works
  // fine for our use case.
  return _common.Common.custom({
    chainId: new _ethereumjsUtil.BN((0, _hexstringUtils.stripHexPrefix)(txMeta.chainId), 16),
    networkId: new _ethereumjsUtil.BN(txMeta.metamaskNetworkId, 10),
    // Optimism only supports type-0 transactions; it does not support any of
    // the newer EIPs since EIP-155. Source:
    // <https://github.com/ethereum-optimism/optimism/blob/develop/specs/l2geth/transaction-types.md>
    defaultHardfork: _common.Hardfork.SpuriousDragon
  });
}
function buildUnserializedTransaction(txMeta) {
  const txParams = buildTxParams(txMeta);
  const common = buildTransactionCommon(txMeta);
  return _tx.TransactionFactory.fromTxData(txParams, {
    common
  });
}

      };
    };
  }
  }
}, {package:"$root$",file:"ui\\helpers\\utils\\optimism\\buildUnserializedTransaction.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\ui\\helpers\\utils\\optimism\\fetchEstimatedL1Fee.js", {"./buildUnserializedTransaction":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\ui\\helpers\\utils\\optimism\\buildUnserializedTransaction.js","@ethersproject/contracts":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ethersproject\\contracts\\lib\\index.js","@ethersproject/providers":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@ethersproject\\providers\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cui%5Chelpers%5Cutils%5Coptimism%5CfetchEstimatedL1Fee.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fetchEstimatedL1Fee;
var _contracts = require("@ethersproject/contracts");
var _providers = require("@ethersproject/providers");
var _buildUnserializedTransaction = _interopRequireDefault(require("./buildUnserializedTransaction"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// Snippet of the ABI that we need
// Should we need more of it at some point, the full ABI can be found here:
// https://github.com/ethereum-optimism/optimism/blob/develop/gas-oracle/abis/OVM_GasPriceOracle.json
const OPTIMISM_GAS_PRICE_ORACLE_ABI = [{
  inputs: [{
    internalType: 'bytes',
    name: '_data',
    type: 'bytes'
  }],
  name: 'getL1Fee',
  outputs: [{
    internalType: 'uint256',
    name: '',
    type: 'uint256'
  }],
  stateMutability: 'view',
  type: 'function'
}];

// BlockExplorer link: https://optimistic.etherscan.io/address/0x420000000000000000000000000000000000000f#code
const OPTIMISM_GAS_PRICE_ORACLE_ADDRESS = '0x420000000000000000000000000000000000000F';
async function fetchEstimatedL1Fee(chainId, txMeta, ethersProvider) {
  const networkId = Number(chainId);
  const provider = global.ethereumProvider ? new _providers.Web3Provider(global.ethereumProvider, networkId) : ethersProvider;
  if (false) {
    provider.detectNetwork = async () => ({
      name: 'optimism',
      chainId: networkId
    });
  }
  const contract = new _contracts.Contract(OPTIMISM_GAS_PRICE_ORACLE_ADDRESS, OPTIMISM_GAS_PRICE_ORACLE_ABI, provider);
  const serializedTransaction = (0, _buildUnserializedTransaction.default)(txMeta).serialize();
  const result = await contract.getL1Fee(serializedTransaction);
  return result === null || result === void 0 ? void 0 : result.toHexString();
}

      };
    };
  }
  }
}, {package:"$root$",file:"ui\\helpers\\utils\\optimism\\fetchEstimatedL1Fee.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\ui\\helpers\\utils\\util.js", {"../../../shared/constants/labels":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\labels.ts","../../../shared/constants/network":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\constants\\network.ts","../../../shared/modules/Numeric":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\Numeric.ts","../../../shared/modules/hexstring-utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\shared\\modules\\hexstring-utils.ts","../constants/common":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\ui\\helpers\\constants\\common.ts","@metamask/assets-controllers":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\assets-controllers\\dist\\index.js","@metamask/slip44":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@metamask\\slip44\\slip44.json","bignumber.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\bignumber.js\\bignumber.js","bowser":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\bowser\\es5.js","ethereumjs-util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\ethereumjs-util\\dist.browser\\index.js","human-standard-token-abi":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\human-standard-token-abi\\index.js","lodash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\lodash.js","luxon":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\luxon\\build\\cjs-browser\\luxon.js","punycode/punycode":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\punycode\\punycode.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cui%5Chelpers%5Cutils%5Cutil.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addressSummary = addressSummary;
exports.bnGreaterThan = bnGreaterThan;
exports.bnGreaterThanEqualTo = bnGreaterThanEqualTo;
exports.bnLessThan = bnLessThan;
exports.bnLessThanEqualTo = bnLessThanEqualTo;
exports.checkExistingAddresses = checkExistingAddresses;
exports.clearClipboard = clearClipboard;
exports.coinTypeToProtocolName = coinTypeToProtocolName;
exports.formatBalance = formatBalance;
exports.formatDate = formatDate;
exports.formatDateWithYearContext = formatDateWithYearContext;
exports.getAccountByAddress = getAccountByAddress;
exports.getAssetImageURL = getAssetImageURL;
exports.getContractAtAddress = getContractAtAddress;
exports.getIsBrowserDeprecated = getIsBrowserDeprecated;
exports.getNetworkNameFromProviderType = void 0;
exports.getRandomFileName = getRandomFileName;
exports.getURL = getURL;
exports.getURLHost = getURLHost;
exports.getURLHostName = getURLHostName;
exports.isDefaultMetaMaskChain = isDefaultMetaMaskChain;
exports.isExtensionUrl = isExtensionUrl;
exports.isNullish = isNullish;
exports.isOriginContractAddress = isOriginContractAddress;
exports.isValidDomainName = isValidDomainName;
exports.numericBalance = numericBalance;
exports.parseBalance = parseBalance;
exports.roundToDecimalPlacesRemovingExtraZeroes = roundToDecimalPlacesRemovingExtraZeroes;
exports.sanitizeString = exports.sanitizeMessage = void 0;
exports.shortenAddress = shortenAddress;
exports.stripHttpSchemes = stripHttpSchemes;
exports.stripHttpsScheme = stripHttpsScheme;
exports.stripHttpsSchemeWithoutPort = stripHttpsSchemeWithoutPort;
exports.toHumanReadableTime = void 0;
exports.valuesFor = valuesFor;
var _punycode = _interopRequireDefault(require("punycode/punycode"));
var _humanStandardTokenAbi = _interopRequireDefault(require("human-standard-token-abi"));
var _bignumber = _interopRequireDefault(require("bignumber.js"));
var ethUtil = _interopRequireWildcard(require("ethereumjs-util"));
var _luxon = require("luxon");
var _assetsControllers = require("@metamask/assets-controllers");
var _slip = _interopRequireDefault(require("@metamask/slip44"));
var lodash = _interopRequireWildcard(require("lodash"));
var _bowser = _interopRequireDefault(require("bowser"));
var _network = require("../../../shared/constants/network");
var _hexstringUtils = require("../../../shared/modules/hexstring-utils");
var _labels = require("../../../shared/constants/labels");
var _Numeric = require("../../../shared/modules/Numeric");
var _common = require("../constants/common");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// formatData :: ( date: <Unix Timestamp> ) -> String
function formatDate(date, format = "M/d/y 'at' T") {
  if (!date) {
    return '';
  }
  return _luxon.DateTime.fromMillis(date).toFormat(format);
}
function formatDateWithYearContext(date, formatThisYear = 'MMM d', fallback = 'MMM d, y') {
  if (!date) {
    return '';
  }
  const dateTime = _luxon.DateTime.fromMillis(date);
  const now = _luxon.DateTime.local();
  return dateTime.toFormat(now.year === dateTime.year ? formatThisYear : fallback);
}
/**
 * Determines if the provided chainId is a default MetaMask chain
 *
 * @param {string} chainId - chainId to check
 */
function isDefaultMetaMaskChain(chainId) {
  if (!chainId || chainId === _network.CHAIN_IDS.MAINNET || chainId === _network.CHAIN_IDS.GOERLI || chainId === _network.CHAIN_IDS.SEPOLIA || chainId === _network.CHAIN_IDS.LINEA_TESTNET || chainId === _network.CHAIN_IDS.LOCALHOST) {
    return true;
  }
  return false;
}
function valuesFor(obj) {
  if (!obj) {
    return [];
  }
  return Object.keys(obj).map(function (key) {
    return obj[key];
  });
}
function addressSummary(address, firstSegLength = 10, lastSegLength = 4, includeHex = true) {
  if (!address) {
    return '';
  }
  let checked = (0, _hexstringUtils.toChecksumHexAddress)(address);
  if (!includeHex) {
    checked = (0, _hexstringUtils.stripHexPrefix)(checked);
  }
  return checked ? `${checked.slice(0, firstSegLength)}...${checked.slice(checked.length - lastSegLength)}` : '...';
}
function isValidDomainName(address) {
  const match = _punycode.default.toASCII(address).toLowerCase()
  // Checks that the domain consists of at least one valid domain pieces separated by periods, followed by a tld
  // Each piece of domain name has only the characters a-z, 0-9, and a hyphen (but not at the start or end of chunk)
  // A chunk has minimum length of 1, but minimum tld is set to 2 for now (no 1-character tlds exist yet)
  .match(/^(?:[a-z0-9](?:[-a-z0-9]*[a-z0-9])?\.)+[a-z0-9][-a-z0-9]*[a-z0-9]$/u);
  return match !== null;
}
function isOriginContractAddress(to, sendTokenAddress) {
  if (!to || !sendTokenAddress) {
    return false;
  }
  return to.toLowerCase() === sendTokenAddress.toLowerCase();
}

// Takes wei Hex, returns wei BN, even if input is null
function numericBalance(balance) {
  if (!balance) {
    return new ethUtil.BN(0, 16);
  }
  const stripped = (0, _hexstringUtils.stripHexPrefix)(balance);
  return new ethUtil.BN(stripped, 16);
}

// Takes  hex, returns [beforeDecimal, afterDecimal]
function parseBalance(balance) {
  let afterDecimal;
  const wei = numericBalance(balance);
  const weiString = wei.toString();
  const trailingZeros = /0+$/u;
  const beforeDecimal = weiString.length > 18 ? weiString.slice(0, weiString.length - 18) : '0';
  afterDecimal = `000000000000000000${wei}`.slice(-18).replace(trailingZeros, '');
  if (afterDecimal === '') {
    afterDecimal = '0';
  }
  return [beforeDecimal, afterDecimal];
}

// Takes wei hex, returns an object with three properties.
// Its "formatted" property is what we generally use to render values.
function formatBalance(balance, decimalsToKeep, needsParse = true, ticker = 'ETH') {
  const parsed = needsParse ? parseBalance(balance) : balance.split('.');
  const beforeDecimal = parsed[0];
  let afterDecimal = parsed[1];
  let formatted = 'None';
  if (decimalsToKeep === undefined) {
    if (beforeDecimal === '0') {
      if (afterDecimal !== '0') {
        const sigFigs = afterDecimal.match(/^0*(.{2})/u); // default: grabs 2 most significant digits
        if (sigFigs) {
          afterDecimal = sigFigs[0];
        }
        formatted = `0.${afterDecimal} ${ticker}`;
      }
    } else {
      formatted = `${beforeDecimal}.${afterDecimal.slice(0, 3)} ${ticker}`;
    }
  } else {
    afterDecimal += Array(decimalsToKeep).join('0');
    formatted = `${beforeDecimal}.${afterDecimal.slice(0, decimalsToKeep)} ${ticker}`;
  }
  return formatted;
}
function getContractAtAddress(tokenAddress) {
  return global.eth.contract(_humanStandardTokenAbi.default).at(tokenAddress);
}
function getRandomFileName() {
  let fileName = '';
  const charBank = [...'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'];
  const fileNameLength = Math.floor(Math.random() * 7 + 6);
  for (let i = 0; i < fileNameLength; i++) {
    fileName += charBank[Math.floor(Math.random() * charBank.length)];
  }
  return fileName;
}

/**
 * Shortens an Ethereum address for display, preserving the beginning and end.
 * Returns the given address if it is no longer than 10 characters.
 * Shortened addresses are 13 characters long.
 *
 * Example output: 0xabcd...1234
 *
 * @param {string} address - The address to shorten.
 * @returns {string} The shortened address, or the original if it was no longer
 * than 10 characters.
 */
function shortenAddress(address = '') {
  if (address.length < _labels.TRUNCATED_NAME_CHAR_LIMIT) {
    return address;
  }
  return `${address.slice(0, _labels.TRUNCATED_ADDRESS_START_CHARS)}...${address.slice(-_labels.TRUNCATED_ADDRESS_END_CHARS)}`;
}
function getAccountByAddress(accounts = [], targetAddress) {
  return accounts.find(({
    address
  }) => address === targetAddress);
}

/**
 * Strips the following schemes from URL strings:
 * - http
 * - https
 *
 * @param {string} urlString - The URL string to strip the scheme from.
 * @returns {string} The URL string, without the scheme, if it was stripped.
 */
function stripHttpSchemes(urlString) {
  return urlString.replace(/^https?:\/\//u, '');
}

/**
 * Strips the following schemes from URL strings:
 * - https
 *
 * @param {string} urlString - The URL string to strip the scheme from.
 * @returns {string} The URL string, without the scheme, if it was stripped.
 */
function stripHttpsScheme(urlString) {
  return urlString.replace(/^https:\/\//u, '');
}

/**
 * Strips `https` schemes from URL strings, if the URL does not have a port.
 * This is useful
 *
 * @param {string} urlString - The URL string to strip the scheme from.
 * @returns {string} The URL string, without the scheme, if it was stripped.
 */
function stripHttpsSchemeWithoutPort(urlString) {
  if (getURL(urlString).port) {
    return urlString;
  }
  return stripHttpsScheme(urlString);
}

/**
 * Checks whether a URL-like value (object or string) is an extension URL.
 *
 * @param {string | URL | object} urlLike - The URL-like value to test.
 * @returns {boolean} Whether the URL-like value is an extension URL.
 */
function isExtensionUrl(urlLike) {
  const EXT_PROTOCOLS = ['chrome-extension:', 'moz-extension:'];
  if (typeof urlLike === 'string') {
    for (const protocol of EXT_PROTOCOLS) {
      if (urlLike.startsWith(protocol)) {
        return true;
      }
    }
  }
  if (urlLike !== null && urlLike !== void 0 && urlLike.protocol) {
    return EXT_PROTOCOLS.includes(urlLike.protocol);
  }
  return false;
}

/**
 * Checks whether an address is in a passed list of objects with address properties. The check is performed on the
 * lowercased version of the addresses.
 *
 * @param {string} address - The hex address to check
 * @param {Array} list - The array of objects to check
 * @returns {boolean} Whether or not the address is in the list
 */
function checkExistingAddresses(address, list = []) {
  if (!address) {
    return false;
  }
  const matchesAddress = obj => {
    return obj.address.toLowerCase() === address.toLowerCase();
  };
  return list.some(matchesAddress);
}
function bnGreaterThan(a, b) {
  if (a === null || a === undefined || b === null || b === undefined) {
    return null;
  }
  return new _bignumber.default(a, 10).gt(b, 10);
}
function bnLessThan(a, b) {
  if (a === null || a === undefined || b === null || b === undefined) {
    return null;
  }
  return new _bignumber.default(a, 10).lt(b, 10);
}
function bnGreaterThanEqualTo(a, b) {
  if (a === null || a === undefined || b === null || b === undefined) {
    return null;
  }
  return new _bignumber.default(a, 10).gte(b, 10);
}
function bnLessThanEqualTo(a, b) {
  if (a === null || a === undefined || b === null || b === undefined) {
    return null;
  }
  return new _bignumber.default(a, 10).lte(b, 10);
}
function getURL(url) {
  try {
    return new URL(url);
  } catch (err) {
    return '';
  }
}
function getIsBrowserDeprecated(browser = _bowser.default.getParser(window.navigator.userAgent)) {
  return browser.satisfies(_common.OUTDATED_BROWSER_VERSIONS) ?? false;
}
function getURLHost(url) {
  var _getURL;
  return ((_getURL = getURL(url)) === null || _getURL === void 0 ? void 0 : _getURL.host) || '';
}
function getURLHostName(url) {
  var _getURL2;
  return ((_getURL2 = getURL(url)) === null || _getURL2 === void 0 ? void 0 : _getURL2.hostname) || '';
}

// Once we reach this threshold, we switch to higher unit
const MINUTE_CUTOFF = 90 * 60;
const SECOND_CUTOFF = 90;
const toHumanReadableTime = (t, milliseconds) => {
  if (milliseconds === undefined || milliseconds === null) {
    return '';
  }
  const seconds = Math.ceil(milliseconds / 1000);
  if (seconds <= SECOND_CUTOFF) {
    return t('gasTimingSecondsShort', [seconds]);
  }
  if (seconds <= MINUTE_CUTOFF) {
    return t('gasTimingMinutesShort', [Math.ceil(seconds / 60)]);
  }
  return t('gasTimingHoursShort', [Math.ceil(seconds / 3600)]);
};
exports.toHumanReadableTime = toHumanReadableTime;
function clearClipboard() {
  window.navigator.clipboard.writeText('');
}
const solidityTypes = () => {
  const types = ['bool', 'address', 'string', 'bytes', 'int', 'uint', 'fixed', 'ufixed'];
  const ints = Array.from(new Array(32)).map((_, index) => `int${(index + 1) * 8}`);
  const uints = Array.from(new Array(32)).map((_, index) => `uint${(index + 1) * 8}`);
  const bytes = Array.from(new Array(32)).map((_, index) => `bytes${index + 1}`);

  /**
   * fixed and ufixed
   * This value type also can be declared keywords such as ufixedMxN and fixedMxN.
   * The M represents the amount of bits that the type takes,
   * with N representing the number of decimal points that are available.
   *  M has to be divisible by 8, and a number from 8 to 256.
   * N has to be a value between 0 and 80, also being inclusive.
   */
  const fixedM = Array.from(new Array(32)).map((_, index) => `fixed${(index + 1) * 8}`);
  const ufixedM = Array.from(new Array(32)).map((_, index) => `ufixed${(index + 1) * 8}`);
  const fixed = Array.from(new Array(80)).map((_, index) => fixedM.map(aFixedM => `${aFixedM}x${index + 1}`));
  const ufixed = Array.from(new Array(80)).map((_, index) => ufixedM.map(auFixedM => `${auFixedM}x${index + 1}`));
  return [...types, ...ints, ...uints, ...bytes, ...fixed.flat(), ...ufixed.flat()];
};
const SOLIDITY_TYPES = solidityTypes();
const stripArrayType = potentialArrayType => potentialArrayType.replace(/\[[[0-9]*\]*/gu, '');
const stripOneLayerofNesting = potentialArrayType => potentialArrayType.replace(/\[[[0-9]*\]/u, '');
const isArrayType = potentialArrayType => potentialArrayType.match(/\[[[0-9]*\]*/u) !== null;
const isSolidityType = type => SOLIDITY_TYPES.includes(type);
const sanitizeMessage = (msg, primaryType, types) => {
  if (!types) {
    throw new Error(`Invalid types definition`);
  }

  // Primary type can be an array.
  const isArray = primaryType && isArrayType(primaryType);
  if (isArray) {
    return {
      value: msg.map(value => sanitizeMessage(value, stripOneLayerofNesting(primaryType), types)),
      type: primaryType
    };
  } else if (isSolidityType(primaryType)) {
    return {
      value: msg,
      type: primaryType
    };
  }

  // If not, assume to be struct
  const baseType = isArray ? stripArrayType(primaryType) : primaryType;
  const baseTypeDefinitions = types[baseType];
  if (!baseTypeDefinitions) {
    throw new Error(`Invalid primary type definition`);
  }
  const sanitizedStruct = {};
  const msgKeys = Object.keys(msg);
  msgKeys.forEach(msgKey => {
    const definedType = Object.values(baseTypeDefinitions).find(baseTypeDefinition => baseTypeDefinition.name === msgKey);
    if (!definedType) {
      return;
    }
    sanitizedStruct[msgKey] = sanitizeMessage(msg[msgKey], definedType.type, types);
  });
  return {
    value: sanitizedStruct,
    type: primaryType
  };
};
exports.sanitizeMessage = sanitizeMessage;
function getAssetImageURL(image, ipfsGateway) {
  if (!image || !ipfsGateway || typeof image !== 'string') {
    return '';
  }
  if (image.startsWith('ipfs://')) {
    return (0, _assetsControllers.getFormattedIpfsUrl)(ipfsGateway, image, true);
  }
  return image;
}
function roundToDecimalPlacesRemovingExtraZeroes(numberish, numberOfDecimalPlaces) {
  if (numberish === undefined || numberish === null) {
    return '';
  }
  return new _Numeric.Numeric(new _Numeric.Numeric(numberish, 10).toFixed(numberOfDecimalPlaces), 10).toNumber();
}

/**
 * Gets the name of the SLIP-44 protocol corresponding to the specified
 * `coin_type`.
 *
 * @param {string | number} coinType - The SLIP-44 `coin_type` value whose name
 * to retrieve.
 * @returns {string | undefined} The name of the protocol if found.
 */
function coinTypeToProtocolName(coinType) {
  var _slip44$coinType;
  if (String(coinType) === '1') {
    return 'Test Networks';
  }
  return ((_slip44$coinType = _slip.default[coinType]) === null || _slip44$coinType === void 0 ? void 0 : _slip44$coinType.name) || undefined;
}

/**
 * Tests "nullishness". Used to guard a section of a component from being
 * rendered based on a value.
 *
 * @param {any} value - A value (literally anything).
 * @returns `true` if the value is null or undefined, `false` otherwise.
 */
function isNullish(value) {
  return value === null || value === undefined;
}

/**
 * The method escape RTL character in string
 *
 * @param {*} value
 * @returns {(string|*)} escaped string or original param value
 */
const sanitizeString = value => {
  if (!value) {
    return value;
  }
  if (!lodash.isString(value)) {
    return value;
  }
  const regex = /\u202E/giu;
  return value.replace(regex, '\\u202E');
};

/**
 * This method checks current provider type and returns its string representation
 *
 * @param {*} provider
 * @param {*} t
 * @returns
 */
exports.sanitizeString = sanitizeString;
const getNetworkNameFromProviderType = providerName => {
  if (providerName === _network.NETWORK_TYPES.RPC) {
    return '';
  }
  return providerName;
};
exports.getNetworkNameFromProviderType = getNetworkNameFromProviderType;


      };
    };
  }
  }
}, {package:"$root$",file:"ui\\helpers\\utils\\util.js",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ybHAvZGlzdC5icm93c2VyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JscC9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzIiwibm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NhZmUtZXZlbnQtZW1pdHRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zZWNwMjU2azEvZWxsaXB0aWMuanMiLCJub2RlX21vZHVsZXMvc2VjcDI1NmsxL2xpYi9lbGxpcHRpYy5qcyIsIm5vZGVfbW9kdWxlcy9zZWNwMjU2azEvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL2NvbXBhcmF0b3IuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvcmFuZ2UuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvc2VtdmVyLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY2xlYW4uanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbXAuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb2VyY2UuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLWJ1aWxkLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS1sb29zZS5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9kaWZmLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZXEuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndC5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2d0ZS5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2luYy5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0LmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbHRlLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbWFqb3IuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9taW5vci5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL25lcS5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhcnNlLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcGF0Y2guanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wcmVyZWxlYXNlLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcmNvbXBhcmUuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9yc29ydC5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3NhdGlzZmllcy5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3NvcnQuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy92YWxpZC5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvZGVidWcuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2lkZW50aWZpZXJzLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9wYXJzZS1vcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9yZS5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2d0ci5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2ludGVyc2VjdHMuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9sdHIuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9tYXgtc2F0aXNmeWluZy5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21pbi1zYXRpc2Z5aW5nLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9vdXRzaWRlLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvc2ltcGxpZnkuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zdWJzZXQuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy90by1jb21wYXJhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3ZhbGlkLmpzIiwibm9kZV9tb2R1bGVzL3NldC1pbW1lZGlhdGUtc2hpbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvaGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2hhLmpzL3NoYS5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvc2hhMS5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvc2hhMjI0LmpzIiwibm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEyNTYuanMiLCJub2RlX21vZHVsZXMvc2hhLmpzL3NoYTM4NC5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvc2hhNTEyLmpzIiwibm9kZV9tb2R1bGVzL3NpbmdsZS1jYWxsLWJhbGFuY2UtY2hlY2tlci1hYmkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3N0cmlwLWhleC1wcmVmaXgvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyc3RydWN0L2Rpc3QvaW5kZXguY2pzIiwibm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuanMiLCJub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIm5vZGVfbW9kdWxlcy91cmwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy91dGY4L3V0ZjguanMiLCJub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L21kNS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9uaWwuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3BhcnNlLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9yZWdleC5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3Qvcm5nLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3NoYTEtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3Qvc3RyaW5naWZ5LmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92MS5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdjMuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3YzNS5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdjQuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3Y1LmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92YWxpZGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdmVyc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy92YWxpZC11cmwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmFyaW50L2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy92YXJpbnQvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3ZhcmludC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92YXJpbnQvbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL3ZtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2ViZXh0ZW5zaW9uLXBvbHlmaWxsL2Rpc3QvYnJvd3Nlci1wb2x5ZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy93cmFwcHkvd3JhcHB5LmpzIiwibm9kZV9tb2R1bGVzL3h0ZW5kL2ltbXV0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy95YWxsaXN0L2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL3lhbGxpc3QveWFsbGlzdC5qcyIsInNoYXJlZC9jb25zdGFudHMvYWxlcnRzLnRzIiwic2hhcmVkL2NvbnN0YW50cy9hcHAudHMiLCJzaGFyZWQvY29uc3RhbnRzL2NvbW1vbi50cyIsInNoYXJlZC9jb25zdGFudHMvZ2FzLnRzIiwic2hhcmVkL2NvbnN0YW50cy9oYXJkd2FyZS13YWxsZXRzLnRzIiwic2hhcmVkL2NvbnN0YW50cy9rZXlyaW5nLnRzIiwic2hhcmVkL2NvbnN0YW50cy9sYWJlbHMudHMiLCJzaGFyZWQvY29uc3RhbnRzL21ldGFtZXRyaWNzLnRzIiwic2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrLnRzIiwic2hhcmVkL2NvbnN0YW50cy9wZXJtaXNzaW9ucy50cyIsInNoYXJlZC9jb25zdGFudHMvcHJlZmVyZW5jZXMudHMiLCJzaGFyZWQvY29uc3RhbnRzL3N3YXBzLnRzIiwic2hhcmVkL2NvbnN0YW50cy90aW1lLnRzIiwic2hhcmVkL2NvbnN0YW50cy90b2tlbnMuanMiLCJzaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uLnRzIiwic2hhcmVkL2xpYi9mZXRjaC13aXRoLWNhY2hlLmpzIiwic2hhcmVkL2xpYi9tZXRhbWFzay1jb250cm9sbGVyLXV0aWxzLmpzIiwic2hhcmVkL2xpYi9zdG9yYWdlLWhlbHBlcnMuanMiLCJzaGFyZWQvbGliL3N3YXBzLXV0aWxzLmpzIiwic2hhcmVkL2xpYi90b2tlbi11dGlsLnRzIiwic2hhcmVkL2xpYi90cmFuc2FjdGlvbnMtY29udHJvbGxlci11dGlscy5qcyIsInNoYXJlZC9tb2R1bGVzL051bWVyaWMudHMiLCJzaGFyZWQvbW9kdWxlcy9icm93c2VyLXJ1bnRpbWUudXRpbHMuanMiLCJzaGFyZWQvbW9kdWxlcy9jb250cmFjdC11dGlscy50cyIsInNoYXJlZC9tb2R1bGVzL2NvbnZlcnNpb24udXRpbHMudHMiLCJzaGFyZWQvbW9kdWxlcy9lcnJvci50cyIsInNoYXJlZC9tb2R1bGVzL2ZldGNoLXdpdGgtdGltZW91dC50cyIsInNoYXJlZC9tb2R1bGVzL2hleHN0cmluZy11dGlscy50cyIsInNoYXJlZC9tb2R1bGVzL212My51dGlscy5qcyIsInNoYXJlZC9tb2R1bGVzL25ldHdvcmsudXRpbHMudHMiLCJzaGFyZWQvbW9kdWxlcy9vYmplY3QudXRpbHMuanMiLCJzaGFyZWQvbW9kdWxlcy9yYW5kb20taWQuanMiLCJzaGFyZWQvbW9kdWxlcy9zdHJpbmctdXRpbHMudHMiLCJzaGFyZWQvbW9kdWxlcy9zd2Fwcy51dGlscy5qcyIsInNoYXJlZC9tb2R1bGVzL3RyYW5zYWN0aW9uLnV0aWxzLmpzIiwic2hhcmVkL25vdGlmaWNhdGlvbnMvaW5kZXguanMiLCJ1aS9oZWxwZXJzL2NvbnN0YW50cy9jb21tb24udHMiLCJ1aS9oZWxwZXJzL3V0aWxzL2J1aWxkLXR5cGVzLmpzIiwidWkvaGVscGVycy91dGlscy9vcHRpbWlzbS9idWlsZFVuc2VyaWFsaXplZFRyYW5zYWN0aW9uLmpzIiwidWkvaGVscGVycy91dGlscy9vcHRpbWlzbS9mZXRjaEVzdGltYXRlZEwxRmVlLmpzIiwidWkvaGVscGVycy91dGlscy91dGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDM1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BGQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdlBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdlNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUM1aENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzV0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3dkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFv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Q0FBQyxLQUFLLEdBQUcsRUFBRTtJQUM1QixPQUFPLGVBQWUsQ0FBQTtHQUN4QjtFQUNBLE9BQU8sQ0FBQSxDQUFBLG1CQUFBLEtBQUEsUUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFBLElBQUEsSUFBQSxnQkFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFoQixnQkFBQSxLQUFzQixLQUFJLFNBQVMsQ0FBQTtDQUM1Qzs7Ozs7Ozs7O0FBU08sMEJBQTBCO0VBQy9CLE9BQU8sS0FBSyxLQUFLLElBQUksSUFBSSxLQUFLLEtBQUssU0FBUyxDQUFBO0NBQzlDOzs7Ozs7OztBQVNPLE1BQU0saUJBQWtCLFNBQVU7RUFDdkMsSUFBSSxDQUFDLEtBQUssRUFBRTtJQUNWLE9BQU8sS0FBSyxDQUFBO0dBQ2Q7RUFDQSxJQUFJLENBQUMsTUFBTSxTQUFTLENBQUMsS0FBSyxDQUFDLEVBQUU7SUFDM0IsT0FBTyxLQUFLLENBQUE7R0FDZDtFQUNBLE1BQU0sUUFBUSxXQUFXLENBQUE7RUFDekIsT0FBTyxLQUFLLFFBQVEsQ0FBQyxLQUFLLEVBQUUsU0FBUyxDQUFDLENBQUE7Q0FDdkMsQ0FBQTs7Ozs7Ozs7O0FBRUQsT0FBQSxlQUFBLEdBQUEsY0FBQSxDQUFBO0FBUU8sTUFBTSxpQ0FBa0MsZ0JBQWlCO0VBQzlELElBQUksWUFBWSxLQUFLLFFBQUEsY0FBYSxJQUFJLEVBQUU7SUFDdEMsT0FBTyxFQUFFLENBQUE7R0FDWDtFQUNBLE9BQU8sWUFBWSxDQUFBO0NBQ3BCLENBQUE7QUFBQyxPQUFBLCtCQUFBLEdBQUEsOEJBQUEsQ0FBQSIsImZpbGUiOiJjb21tb24tNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRMZW5ndGggPSBleHBvcnRzLmRlY29kZSA9IGV4cG9ydHMuZW5jb2RlID0gdm9pZCAwO1xudmFyIGJuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJuLmpzXCIpKTtcbi8qKlxuICogUkxQIEVuY29kaW5nIGJhc2VkIG9uOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpLyU1QkVuZ2xpc2glNUQtUkxQXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGluIGEgZGF0YSwgY29udmVydCBpdCB0byBidWZmZXIgaWYgbm90LCBhbmQgYSBsZW5ndGggZm9yIHJlY3Vyc2lvblxuICogQHBhcmFtIGlucHV0IC0gd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYnVmZmVyXG4gKiBAcmV0dXJucyByZXR1cm5zIGJ1ZmZlciBvZiBlbmNvZGVkIGRhdGFcbiAqKi9cbmZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGVuY29kZShpbnB1dFtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWYgPSBCdWZmZXIuY29uY2F0KG91dHB1dCk7XG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtlbmNvZGVMZW5ndGgoYnVmLmxlbmd0aCwgMTkyKSwgYnVmXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgaW5wdXRCdWYgPSB0b0J1ZmZlcihpbnB1dCk7XG4gICAgICAgIHJldHVybiBpbnB1dEJ1Zi5sZW5ndGggPT09IDEgJiYgaW5wdXRCdWZbMF0gPCAxMjhcbiAgICAgICAgICAgID8gaW5wdXRCdWZcbiAgICAgICAgICAgIDogQnVmZmVyLmNvbmNhdChbZW5jb2RlTGVuZ3RoKGlucHV0QnVmLmxlbmd0aCwgMTI4KSwgaW5wdXRCdWZdKTtcbiAgICB9XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbi8qKlxuICogUGFyc2UgaW50ZWdlcnMuIENoZWNrIGlmIHRoZXJlIGlzIG5vIGxlYWRpbmcgemVyb3NcbiAqIEBwYXJhbSB2IFRoZSB2YWx1ZSB0byBwYXJzZVxuICogQHBhcmFtIGJhc2UgVGhlIGJhc2UgdG8gcGFyc2UgdGhlIGludGVnZXIgaW50b1xuICovXG5mdW5jdGlvbiBzYWZlUGFyc2VJbnQodiwgYmFzZSkge1xuICAgIGlmICh2WzBdID09PSAnMCcgJiYgdlsxXSA9PT0gJzAnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IGV4dHJhIHplcm9zJyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUludCh2LCBiYXNlKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUxlbmd0aChsZW4sIG9mZnNldCkge1xuICAgIGlmIChsZW4gPCA1Nikge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oW2xlbiArIG9mZnNldF0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGhleExlbmd0aCA9IGludFRvSGV4KGxlbik7XG4gICAgICAgIHZhciBsTGVuZ3RoID0gaGV4TGVuZ3RoLmxlbmd0aCAvIDI7XG4gICAgICAgIHZhciBmaXJzdEJ5dGUgPSBpbnRUb0hleChvZmZzZXQgKyA1NSArIGxMZW5ndGgpO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oZmlyc3RCeXRlICsgaGV4TGVuZ3RoLCAnaGV4Jyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVjb2RlKGlucHV0LCBzdHJlYW0pIHtcbiAgICBpZiAoc3RyZWFtID09PSB2b2lkIDApIHsgc3RyZWFtID0gZmFsc2U7IH1cbiAgICBpZiAoIWlucHV0IHx8IGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oW10pO1xuICAgIH1cbiAgICB2YXIgaW5wdXRCdWZmZXIgPSB0b0J1ZmZlcihpbnB1dCk7XG4gICAgdmFyIGRlY29kZWQgPSBfZGVjb2RlKGlucHV0QnVmZmVyKTtcbiAgICBpZiAoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgIH1cbiAgICBpZiAoZGVjb2RlZC5yZW1haW5kZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByZW1haW5kZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZWQuZGF0YTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuLyoqXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiB0aGUgUkxQIGlucHV0XG4gKiBAcGFyYW0gaW5wdXRcbiAqIEByZXR1cm5zIFRoZSBsZW5ndGggb2YgdGhlIGlucHV0IG9yIGFuIGVtcHR5IEJ1ZmZlciBpZiBubyBpbnB1dFxuICovXG5mdW5jdGlvbiBnZXRMZW5ndGgoaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0IHx8IGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oW10pO1xuICAgIH1cbiAgICB2YXIgaW5wdXRCdWZmZXIgPSB0b0J1ZmZlcihpbnB1dCk7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGlucHV0QnVmZmVyWzBdO1xuICAgIGlmIChmaXJzdEJ5dGUgPD0gMHg3Zikge1xuICAgICAgICByZXR1cm4gaW5wdXRCdWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhiNykge1xuICAgICAgICByZXR1cm4gZmlyc3RCeXRlIC0gMHg3ZjtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4YmYpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0Qnl0ZSAtIDB4YjY7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGY3KSB7XG4gICAgICAgIC8vIGEgbGlzdCBiZXR3ZWVuICAwLTU1IGJ5dGVzIGxvbmdcbiAgICAgICAgcmV0dXJuIGZpcnN0Qnl0ZSAtIDB4YmY7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBhIGxpc3QgIG92ZXIgNTUgYnl0ZXMgbG9uZ1xuICAgICAgICB2YXIgbGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4ZjY7XG4gICAgICAgIHZhciBsZW5ndGhfMSA9IHNhZmVQYXJzZUludChpbnB1dEJ1ZmZlci5zbGljZSgxLCBsbGVuZ3RoKS50b1N0cmluZygnaGV4JyksIDE2KTtcbiAgICAgICAgcmV0dXJuIGxsZW5ndGggKyBsZW5ndGhfMTtcbiAgICB9XG59XG5leHBvcnRzLmdldExlbmd0aCA9IGdldExlbmd0aDtcbi8qKiBEZWNvZGUgYW4gaW5wdXQgd2l0aCBSTFAgKi9cbmZ1bmN0aW9uIF9kZWNvZGUoaW5wdXQpIHtcbiAgICB2YXIgbGVuZ3RoLCBsbGVuZ3RoLCBkYXRhLCBpbm5lclJlbWFpbmRlciwgZDtcbiAgICB2YXIgZGVjb2RlZCA9IFtdO1xuICAgIHZhciBmaXJzdEJ5dGUgPSBpbnB1dFswXTtcbiAgICBpZiAoZmlyc3RCeXRlIDw9IDB4N2YpIHtcbiAgICAgICAgLy8gYSBzaW5nbGUgYnl0ZSB3aG9zZSB2YWx1ZSBpcyBpbiB0aGUgWzB4MDAsIDB4N2ZdIHJhbmdlLCB0aGF0IGJ5dGUgaXMgaXRzIG93biBSTFAgZW5jb2RpbmcuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBpbnB1dC5zbGljZSgwLCAxKSxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UoMSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGI3KSB7XG4gICAgICAgIC8vIHN0cmluZyBpcyAwLTU1IGJ5dGVzIGxvbmcuIEEgc2luZ2xlIGJ5dGUgd2l0aCB2YWx1ZSAweDgwIHBsdXMgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIGZvbGxvd2VkIGJ5IHRoZSBzdHJpbmdcbiAgICAgICAgLy8gVGhlIHJhbmdlIG9mIHRoZSBmaXJzdCBieXRlIGlzIFsweDgwLCAweGI3XVxuICAgICAgICBsZW5ndGggPSBmaXJzdEJ5dGUgLSAweDdmO1xuICAgICAgICAvLyBzZXQgMHg4MCBudWxsIHRvIDBcbiAgICAgICAgaWYgKGZpcnN0Qnl0ZSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBpbnB1dC5zbGljZSgxLCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPT09IDIgJiYgZGF0YVswXSA8IDB4ODApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBybHAgZW5jb2Rpbmc6IGJ5dGUgbXVzdCBiZSBsZXNzIDB4ODAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UobGVuZ3RoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4YmYpIHtcbiAgICAgICAgLy8gc3RyaW5nIGlzIGdyZWF0ZXIgdGhhbiA1NSBieXRlcyBsb25nLiBBIHNpbmdsZSBieXRlIHdpdGggdGhlIHZhbHVlICgweGI3IHBsdXMgdGhlIGxlbmd0aCBvZiB0aGUgbGVuZ3RoKSxcbiAgICAgICAgLy8gZm9sbG93ZWQgYnkgdGhlIGxlbmd0aCwgZm9sbG93ZWQgYnkgdGhlIHN0cmluZ1xuICAgICAgICBsbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhiNjtcbiAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCAtIDEgPCBsbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiBub3QgZW5vdWdoIGJ5dGVzIGZvciBzdHJpbmcgbGVuZ3RoJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoID0gc2FmZVBhcnNlSW50KGlucHV0LnNsaWNlKDEsIGxsZW5ndGgpLnRvU3RyaW5nKCdoZXgnKSwgMTYpO1xuICAgICAgICBpZiAobGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiBleHBlY3RlZCBzdHJpbmcgbGVuZ3RoIHRvIGJlIGdyZWF0ZXIgdGhhbiA1NScpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSBpbnB1dC5zbGljZShsbGVuZ3RoLCBsZW5ndGggKyBsbGVuZ3RoKTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiBub3QgZW5vdWdoIGJ5dGVzIGZvciBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UobGVuZ3RoICsgbGxlbmd0aCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGY3KSB7XG4gICAgICAgIC8vIGEgbGlzdCBiZXR3ZWVuICAwLTU1IGJ5dGVzIGxvbmdcbiAgICAgICAgbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhiZjtcbiAgICAgICAgaW5uZXJSZW1haW5kZXIgPSBpbnB1dC5zbGljZSgxLCBsZW5ndGgpO1xuICAgICAgICB3aGlsZSAoaW5uZXJSZW1haW5kZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBkID0gX2RlY29kZShpbm5lclJlbWFpbmRlcik7XG4gICAgICAgICAgICBkZWNvZGVkLnB1c2goZC5kYXRhKTtcbiAgICAgICAgICAgIGlubmVyUmVtYWluZGVyID0gZC5yZW1haW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGRlY29kZWQsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKGxlbmd0aCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBhIGxpc3QgIG92ZXIgNTUgYnl0ZXMgbG9uZ1xuICAgICAgICBsbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhmNjtcbiAgICAgICAgbGVuZ3RoID0gc2FmZVBhcnNlSW50KGlucHV0LnNsaWNlKDEsIGxsZW5ndGgpLnRvU3RyaW5nKCdoZXgnKSwgMTYpO1xuICAgICAgICB2YXIgdG90YWxMZW5ndGggPSBsbGVuZ3RoICsgbGVuZ3RoO1xuICAgICAgICBpZiAodG90YWxMZW5ndGggPiBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBybHA6IHRvdGFsIGxlbmd0aCBpcyBsYXJnZXIgdGhhbiB0aGUgZGF0YScpO1xuICAgICAgICB9XG4gICAgICAgIGlubmVyUmVtYWluZGVyID0gaW5wdXQuc2xpY2UobGxlbmd0aCwgdG90YWxMZW5ndGgpO1xuICAgICAgICBpZiAoaW5uZXJSZW1haW5kZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmxwLCBMaXN0IGhhcyBhIGludmFsaWQgbGVuZ3RoJyk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGlubmVyUmVtYWluZGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgZCA9IF9kZWNvZGUoaW5uZXJSZW1haW5kZXIpO1xuICAgICAgICAgICAgZGVjb2RlZC5wdXNoKGQuZGF0YSk7XG4gICAgICAgICAgICBpbm5lclJlbWFpbmRlciA9IGQucmVtYWluZGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBkZWNvZGVkLFxuICAgICAgICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZSh0b3RhbExlbmd0aCksXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqIENoZWNrIGlmIGEgc3RyaW5nIGlzIHByZWZpeGVkIGJ5IDB4ICovXG5mdW5jdGlvbiBpc0hleFByZWZpeGVkKHN0cikge1xuICAgIHJldHVybiBzdHIuc2xpY2UoMCwgMikgPT09ICcweCc7XG59XG4vKiogUmVtb3ZlcyAweCBmcm9tIGEgZ2l2ZW4gU3RyaW5nICovXG5mdW5jdGlvbiBzdHJpcEhleFByZWZpeChzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIGlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ci5zbGljZSgyKSA6IHN0cjtcbn1cbi8qKiBUcmFuc2Zvcm0gYW4gaW50ZWdlciBpbnRvIGl0cyBoZXhhZGVjaW1hbCB2YWx1ZSAqL1xuZnVuY3Rpb24gaW50VG9IZXgoaW50ZWdlcikge1xuICAgIGlmIChpbnRlZ2VyIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50ZWdlciBhcyBhcmd1bWVudCwgbXVzdCBiZSB1bnNpZ25lZCEnKTtcbiAgICB9XG4gICAgdmFyIGhleCA9IGludGVnZXIudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICUgMiA/IFwiMFwiICsgaGV4IDogaGV4O1xufVxuLyoqIFBhZCBhIHN0cmluZyB0byBiZSBldmVuICovXG5mdW5jdGlvbiBwYWRUb0V2ZW4oYSkge1xuICAgIHJldHVybiBhLmxlbmd0aCAlIDIgPyBcIjBcIiArIGEgOiBhO1xufVxuLyoqIFRyYW5zZm9ybSBhbiBpbnRlZ2VyIGludG8gYSBCdWZmZXIgKi9cbmZ1bmN0aW9uIGludFRvQnVmZmVyKGludGVnZXIpIHtcbiAgICB2YXIgaGV4ID0gaW50VG9IZXgoaW50ZWdlcik7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhleCwgJ2hleCcpO1xufVxuLyoqIFRyYW5zZm9ybSBhbnl0aGluZyBpbnRvIGEgQnVmZmVyICovXG5mdW5jdGlvbiB0b0J1ZmZlcih2KSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGlzSGV4UHJlZml4ZWQodikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20ocGFkVG9FdmVuKHN0cmlwSGV4UHJlZml4KHYpKSwgJ2hleCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50VG9CdWZmZXIodik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChibl9qc18xLmRlZmF1bHQuaXNCTih2KSkge1xuICAgICAgICAgICAgLy8gY29udmVydHMgYSBCTiB0byBhIEJ1ZmZlclxuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYudG9BcnJheSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0eXBlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gVXRpbHNcbiAgZnVuY3Rpb24gYXNzZXJ0ICh2YWwsIG1zZykge1xuICAgIGlmICghdmFsKSB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIH1cblxuICAvLyBDb3VsZCB1c2UgYGluaGVyaXRzYCBtb2R1bGUsIGJ1dCBkb24ndCB3YW50IHRvIG1vdmUgZnJvbSBzaW5nbGUgZmlsZVxuICAvLyBhcmNoaXRlY3R1cmUgeWV0LlxuICBmdW5jdGlvbiBpbmhlcml0cyAoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpO1xuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcbiAgfVxuXG4gIC8vIEJOXG5cbiAgZnVuY3Rpb24gQk4gKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKEJOLmlzQk4obnVtYmVyKSkge1xuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB0aGlzLndvcmRzID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBSZWR1Y3Rpb24gY29udGV4dFxuICAgIHRoaXMucmVkID0gbnVsbDtcblxuICAgIGlmIChudW1iZXIgIT09IG51bGwpIHtcbiAgICAgIGlmIChiYXNlID09PSAnbGUnIHx8IGJhc2UgPT09ICdiZScpIHtcbiAgICAgICAgZW5kaWFuID0gYmFzZTtcbiAgICAgICAgYmFzZSA9IDEwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbml0KG51bWJlciB8fCAwLCBiYXNlIHx8IDEwLCBlbmRpYW4gfHwgJ2JlJyk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gQk47XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CTiA9IEJOO1xuICB9XG5cbiAgQk4uQk4gPSBCTjtcbiAgQk4ud29yZFNpemUgPSAyNjtcblxuICB2YXIgQnVmZmVyO1xuICB0cnkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LkJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIEJ1ZmZlciA9IHdpbmRvdy5CdWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuXG4gIEJOLmlzQk4gPSBmdW5jdGlvbiBpc0JOIChudW0pIHtcbiAgICBpZiAobnVtIGluc3RhbmNlb2YgQk4pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBudW0gIT09IG51bGwgJiYgdHlwZW9mIG51bSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG51bS5jb25zdHJ1Y3Rvci53b3JkU2l6ZSA9PT0gQk4ud29yZFNpemUgJiYgQXJyYXkuaXNBcnJheShudW0ud29yZHMpO1xuICB9O1xuXG4gIEJOLm1heCA9IGZ1bmN0aW9uIG1heCAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC5jbXAocmlnaHQpID4gMCkgcmV0dXJuIGxlZnQ7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9O1xuXG4gIEJOLm1pbiA9IGZ1bmN0aW9uIG1pbiAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC5jbXAocmlnaHQpIDwgMCkgcmV0dXJuIGxlZnQ7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdE51bWJlcihudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdEFycmF5KG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIGJhc2UgPSAxNjtcbiAgICB9XG4gICAgYXNzZXJ0KGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpO1xuXG4gICAgbnVtYmVyID0gbnVtYmVyLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBpZiAobnVtYmVyWzBdID09PSAnLScpIHtcbiAgICAgIHN0YXJ0Kys7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPCBudW1iZXIubGVuZ3RoKSB7XG4gICAgICBpZiAoYmFzZSA9PT0gMTYpIHtcbiAgICAgICAgdGhpcy5fcGFyc2VIZXgobnVtYmVyLCBzdGFydCwgZW5kaWFuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3BhcnNlQmFzZShudW1iZXIsIGJhc2UsIHN0YXJ0KTtcbiAgICAgICAgaWYgKGVuZGlhbiA9PT0gJ2xlJykge1xuICAgICAgICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXROdW1iZXIgPSBmdW5jdGlvbiBfaW5pdE51bWJlciAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICBudW1iZXIgPSAtbnVtYmVyO1xuICAgIH1cbiAgICBpZiAobnVtYmVyIDwgMHg0MDAwMDAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gW251bWJlciAmIDB4M2ZmZmZmZl07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChudW1iZXIgPCAweDEwMDAwMDAwMDAwMDAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gW1xuICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmXG4gICAgICBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQobnVtYmVyIDwgMHgyMDAwMDAwMDAwMDAwMCk7IC8vIDIgXiA1MyAodW5zYWZlKVxuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZixcbiAgICAgICAgMVxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMztcbiAgICB9XG5cbiAgICBpZiAoZW5kaWFuICE9PSAnbGUnKSByZXR1cm47XG5cbiAgICAvLyBSZXZlcnNlIHRoZSBieXRlc1xuICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXRBcnJheSA9IGZ1bmN0aW9uIF9pbml0QXJyYXkgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgLy8gUGVyaGFwcyBhIFVpbnQ4QXJyYXlcbiAgICBhc3NlcnQodHlwZW9mIG51bWJlci5sZW5ndGggPT09ICdudW1iZXInKTtcbiAgICBpZiAobnVtYmVyLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gWzBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwobnVtYmVyLmxlbmd0aCAvIDMpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGosIHc7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuICAgICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDEsIGogPSAwOyBpID49IDA7IGkgLT0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpIC0gMV0gPDwgOCkgfCAobnVtYmVyW2kgLSAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVuZGlhbiA9PT0gJ2xlJykge1xuICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSArIDFdIDw8IDgpIHwgKG51bWJlcltpICsgMl0gPDwgMTYpO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjQ7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlSGV4NEJpdHMgKHN0cmluZywgaW5kZXgpIHtcbiAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAvLyAnMCcgLSAnOSdcbiAgICBpZiAoYyA+PSA0OCAmJiBjIDw9IDU3KSB7XG4gICAgICByZXR1cm4gYyAtIDQ4O1xuICAgIC8vICdBJyAtICdGJ1xuICAgIH0gZWxzZSBpZiAoYyA+PSA2NSAmJiBjIDw9IDcwKSB7XG4gICAgICByZXR1cm4gYyAtIDU1O1xuICAgIC8vICdhJyAtICdmJ1xuICAgIH0gZWxzZSBpZiAoYyA+PSA5NyAmJiBjIDw9IDEwMikge1xuICAgICAgcmV0dXJuIGMgLSA4NztcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KGZhbHNlLCAnSW52YWxpZCBjaGFyYWN0ZXIgaW4gJyArIHN0cmluZyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VIZXhCeXRlIChzdHJpbmcsIGxvd2VyQm91bmQsIGluZGV4KSB7XG4gICAgdmFyIHIgPSBwYXJzZUhleDRCaXRzKHN0cmluZywgaW5kZXgpO1xuICAgIGlmIChpbmRleCAtIDEgPj0gbG93ZXJCb3VuZCkge1xuICAgICAgciB8PSBwYXJzZUhleDRCaXRzKHN0cmluZywgaW5kZXggLSAxKSA8PCA0O1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fcGFyc2VIZXggPSBmdW5jdGlvbiBfcGFyc2VIZXggKG51bWJlciwgc3RhcnQsIGVuZGlhbikge1xuICAgIC8vIENyZWF0ZSBwb3NzaWJseSBiaWdnZXIgYXJyYXkgdG8gZW5zdXJlIHRoYXQgaXQgZml0cyB0aGUgbnVtYmVyXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwoKG51bWJlci5sZW5ndGggLSBzdGFydCkgLyA2KTtcbiAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgIH1cblxuICAgIC8vIDI0LWJpdHMgY2h1bmtzXG4gICAgdmFyIG9mZiA9IDA7XG4gICAgdmFyIGogPSAwO1xuXG4gICAgdmFyIHc7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuICAgICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDE7IGkgPj0gc3RhcnQ7IGkgLT0gMikge1xuICAgICAgICB3ID0gcGFyc2VIZXhCeXRlKG51bWJlciwgc3RhcnQsIGkpIDw8IG9mZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ICYgMHgzZmZmZmZmO1xuICAgICAgICBpZiAob2ZmID49IDE4KSB7XG4gICAgICAgICAgb2ZmIC09IDE4O1xuICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgPj4+IDI2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZiArPSA4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJzZUxlbmd0aCA9IG51bWJlci5sZW5ndGggLSBzdGFydDtcbiAgICAgIGZvciAoaSA9IHBhcnNlTGVuZ3RoICUgMiA9PT0gMCA/IHN0YXJ0ICsgMSA6IHN0YXJ0OyBpIDwgbnVtYmVyLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHcgPSBwYXJzZUhleEJ5dGUobnVtYmVyLCBzdGFydCwgaSkgPDwgb2ZmO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgJiAweDNmZmZmZmY7XG4gICAgICAgIGlmIChvZmYgPj0gMTgpIHtcbiAgICAgICAgICBvZmYgLT0gMTg7XG4gICAgICAgICAgaiArPSAxO1xuICAgICAgICAgIHRoaXMud29yZHNbal0gfD0gdyA+Pj4gMjY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2ZmICs9IDg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlQmFzZSAoc3RyLCBzdGFydCwgZW5kLCBtdWwpIHtcbiAgICB2YXIgciA9IDA7XG4gICAgdmFyIGIgPSAwO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cbiAgICAgIHIgKj0gbXVsO1xuXG4gICAgICAvLyAnYSdcbiAgICAgIGlmIChjID49IDQ5KSB7XG4gICAgICAgIGIgPSBjIC0gNDkgKyAweGE7XG5cbiAgICAgIC8vICdBJ1xuICAgICAgfSBlbHNlIGlmIChjID49IDE3KSB7XG4gICAgICAgIGIgPSBjIC0gMTcgKyAweGE7XG5cbiAgICAgIC8vICcwJyAtICc5J1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYiA9IGM7XG4gICAgICB9XG4gICAgICBhc3NlcnQoYyA+PSAwICYmIGIgPCBtdWwsICdJbnZhbGlkIGNoYXJhY3RlcicpO1xuICAgICAgciArPSBiO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fcGFyc2VCYXNlID0gZnVuY3Rpb24gX3BhcnNlQmFzZSAobnVtYmVyLCBiYXNlLCBzdGFydCkge1xuICAgIC8vIEluaXRpYWxpemUgYXMgemVyb1xuICAgIHRoaXMud29yZHMgPSBbMF07XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuXG4gICAgLy8gRmluZCBsZW5ndGggb2YgbGltYiBpbiBiYXNlXG4gICAgZm9yICh2YXIgbGltYkxlbiA9IDAsIGxpbWJQb3cgPSAxOyBsaW1iUG93IDw9IDB4M2ZmZmZmZjsgbGltYlBvdyAqPSBiYXNlKSB7XG4gICAgICBsaW1iTGVuKys7XG4gICAgfVxuICAgIGxpbWJMZW4tLTtcbiAgICBsaW1iUG93ID0gKGxpbWJQb3cgLyBiYXNlKSB8IDA7XG5cbiAgICB2YXIgdG90YWwgPSBudW1iZXIubGVuZ3RoIC0gc3RhcnQ7XG4gICAgdmFyIG1vZCA9IHRvdGFsICUgbGltYkxlbjtcbiAgICB2YXIgZW5kID0gTWF0aC5taW4odG90YWwsIHRvdGFsIC0gbW9kKSArIHN0YXJ0O1xuXG4gICAgdmFyIHdvcmQgPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBsaW1iTGVuKSB7XG4gICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgaSArIGxpbWJMZW4sIGJhc2UpO1xuXG4gICAgICB0aGlzLmltdWxuKGxpbWJQb3cpO1xuICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb2QgIT09IDApIHtcbiAgICAgIHZhciBwb3cgPSAxO1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIG51bWJlci5sZW5ndGgsIGJhc2UpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbW9kOyBpKyspIHtcbiAgICAgICAgcG93ICo9IGJhc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW11bG4ocG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoZGVzdCkge1xuICAgIGRlc3Qud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzdC53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgfVxuICAgIGRlc3QubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgZGVzdC5uZWdhdGl2ZSA9IHRoaXMubmVnYXRpdmU7XG4gICAgZGVzdC5yZWQgPSB0aGlzLnJlZDtcbiAgfTtcblxuICBmdW5jdGlvbiBtb3ZlIChkZXN0LCBzcmMpIHtcbiAgICBkZXN0LndvcmRzID0gc3JjLndvcmRzO1xuICAgIGRlc3QubGVuZ3RoID0gc3JjLmxlbmd0aDtcbiAgICBkZXN0Lm5lZ2F0aXZlID0gc3JjLm5lZ2F0aXZlO1xuICAgIGRlc3QucmVkID0gc3JjLnJlZDtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uIF9tb3ZlIChkZXN0KSB7XG4gICAgbW92ZShkZXN0LCB0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIHIgPSBuZXcgQk4obnVsbCk7XG4gICAgdGhpcy5jb3B5KHIpO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZXhwYW5kID0gZnVuY3Rpb24gX2V4cGFuZCAoc2l6ZSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IHNpemUpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBSZW1vdmUgbGVhZGluZyBgMGAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLl9zdHJpcCA9IGZ1bmN0aW9uIHN0cmlwICgpIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPiAxICYmIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9ub3JtU2lnbiA9IGZ1bmN0aW9uIF9ub3JtU2lnbiAoKSB7XG4gICAgLy8gLTAgPSAwXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBDaGVjayBTeW1ib2wuZm9yIGJlY2F1c2Ugbm90IGV2ZXJ5d2hlcmUgd2hlcmUgU3ltYm9sIGRlZmluZWRcbiAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N5bWJvbCNCcm93c2VyX2NvbXBhdGliaWxpdHlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBTeW1ib2wuZm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIEJOLnByb3RvdHlwZVtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSA9IGluc3BlY3Q7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgQk4ucHJvdG90eXBlLmluc3BlY3QgPSBpbnNwZWN0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBCTi5wcm90b3R5cGUuaW5zcGVjdCA9IGluc3BlY3Q7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgICByZXR1cm4gKHRoaXMucmVkID8gJzxCTi1SOiAnIDogJzxCTjogJykgKyB0aGlzLnRvU3RyaW5nKDE2KSArICc+JztcbiAgfVxuXG4gIC8qXG5cbiAgdmFyIHplcm9zID0gW107XG4gIHZhciBncm91cFNpemVzID0gW107XG4gIHZhciBncm91cEJhc2VzID0gW107XG5cbiAgdmFyIHMgPSAnJztcbiAgdmFyIGkgPSAtMTtcbiAgd2hpbGUgKCsraSA8IEJOLndvcmRTaXplKSB7XG4gICAgemVyb3NbaV0gPSBzO1xuICAgIHMgKz0gJzAnO1xuICB9XG4gIGdyb3VwU2l6ZXNbMF0gPSAwO1xuICBncm91cFNpemVzWzFdID0gMDtcbiAgZ3JvdXBCYXNlc1swXSA9IDA7XG4gIGdyb3VwQmFzZXNbMV0gPSAwO1xuICB2YXIgYmFzZSA9IDIgLSAxO1xuICB3aGlsZSAoKytiYXNlIDwgMzYgKyAxKSB7XG4gICAgdmFyIGdyb3VwU2l6ZSA9IDA7XG4gICAgdmFyIGdyb3VwQmFzZSA9IDE7XG4gICAgd2hpbGUgKGdyb3VwQmFzZSA8ICgxIDw8IEJOLndvcmRTaXplKSAvIGJhc2UpIHtcbiAgICAgIGdyb3VwQmFzZSAqPSBiYXNlO1xuICAgICAgZ3JvdXBTaXplICs9IDE7XG4gICAgfVxuICAgIGdyb3VwU2l6ZXNbYmFzZV0gPSBncm91cFNpemU7XG4gICAgZ3JvdXBCYXNlc1tiYXNlXSA9IGdyb3VwQmFzZTtcbiAgfVxuXG4gICovXG5cbiAgdmFyIHplcm9zID0gW1xuICAgICcnLFxuICAgICcwJyxcbiAgICAnMDAnLFxuICAgICcwMDAnLFxuICAgICcwMDAwJyxcbiAgICAnMDAwMDAnLFxuICAgICcwMDAwMDAnLFxuICAgICcwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICBdO1xuXG4gIHZhciBncm91cFNpemVzID0gW1xuICAgIDAsIDAsXG4gICAgMjUsIDE2LCAxMiwgMTEsIDEwLCA5LCA4LFxuICAgIDgsIDcsIDcsIDcsIDcsIDYsIDYsXG4gICAgNiwgNiwgNiwgNiwgNiwgNSwgNSxcbiAgICA1LCA1LCA1LCA1LCA1LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDVcbiAgXTtcblxuICB2YXIgZ3JvdXBCYXNlcyA9IFtcbiAgICAwLCAwLFxuICAgIDMzNTU0NDMyLCA0MzA0NjcyMSwgMTY3NzcyMTYsIDQ4ODI4MTI1LCA2MDQ2NjE3NiwgNDAzNTM2MDcsIDE2Nzc3MjE2LFxuICAgIDQzMDQ2NzIxLCAxMDAwMDAwMCwgMTk0ODcxNzEsIDM1ODMxODA4LCA2Mjc0ODUxNywgNzUyOTUzNiwgMTEzOTA2MjUsXG4gICAgMTY3NzcyMTYsIDI0MTM3NTY5LCAzNDAxMjIyNCwgNDcwNDU4ODEsIDY0MDAwMDAwLCA0MDg0MTAxLCA1MTUzNjMyLFxuICAgIDY0MzYzNDMsIDc5NjI2MjQsIDk3NjU2MjUsIDExODgxMzc2LCAxNDM0ODkwNywgMTcyMTAzNjgsIDIwNTExMTQ5LFxuICAgIDI0MzAwMDAwLCAyODYyOTE1MSwgMzM1NTQ0MzIsIDM5MTM1MzkzLCA0NTQzNTQyNCwgNTI1MjE4NzUsIDYwNDY2MTc2XG4gIF07XG5cbiAgQk4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKGJhc2UsIHBhZGRpbmcpIHtcbiAgICBiYXNlID0gYmFzZSB8fCAxMDtcbiAgICBwYWRkaW5nID0gcGFkZGluZyB8IDAgfHwgMTtcblxuICAgIHZhciBvdXQ7XG4gICAgaWYgKGJhc2UgPT09IDE2IHx8IGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBvdXQgPSAnJztcbiAgICAgIHZhciBvZmYgPSAwO1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV07XG4gICAgICAgIHZhciB3b3JkID0gKCgodyA8PCBvZmYpIHwgY2FycnkpICYgMHhmZmZmZmYpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgY2FycnkgPSAodyA+Pj4gKDI0IC0gb2ZmKSkgJiAweGZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYXJyeSAhPT0gMCB8fCBpICE9PSB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBvdXQgPSB6ZXJvc1s2IC0gd29yZC5sZW5ndGhdICsgd29yZCArIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgPSB3b3JkICsgb3V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgICAgb3V0ID0gY2FycnkudG9TdHJpbmcoMTYpICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpIHtcbiAgICAgIC8vIHZhciBncm91cFNpemUgPSBNYXRoLmZsb29yKEJOLndvcmRTaXplICogTWF0aC5MTjIgLyBNYXRoLmxvZyhiYXNlKSk7XG4gICAgICB2YXIgZ3JvdXBTaXplID0gZ3JvdXBTaXplc1tiYXNlXTtcbiAgICAgIC8vIHZhciBncm91cEJhc2UgPSBNYXRoLnBvdyhiYXNlLCBncm91cFNpemUpO1xuICAgICAgdmFyIGdyb3VwQmFzZSA9IGdyb3VwQmFzZXNbYmFzZV07XG4gICAgICBvdXQgPSAnJztcbiAgICAgIHZhciBjID0gdGhpcy5jbG9uZSgpO1xuICAgICAgYy5uZWdhdGl2ZSA9IDA7XG4gICAgICB3aGlsZSAoIWMuaXNaZXJvKCkpIHtcbiAgICAgICAgdmFyIHIgPSBjLm1vZHJuKGdyb3VwQmFzZSkudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgIGMgPSBjLmlkaXZuKGdyb3VwQmFzZSk7XG5cbiAgICAgICAgaWYgKCFjLmlzWmVybygpKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbZ3JvdXBTaXplIC0gci5sZW5ndGhdICsgciArIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgPSByICsgb3V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBhc3NlcnQoZmFsc2UsICdCYXNlIHNob3VsZCBiZSBiZXR3ZWVuIDIgYW5kIDM2Jyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIgKCkge1xuICAgIHZhciByZXQgPSB0aGlzLndvcmRzWzBdO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0ICs9IHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA9PT0gMyAmJiB0aGlzLndvcmRzWzJdID09PSAweDAxKSB7XG4gICAgICAvLyBOT1RFOiBhdCB0aGlzIHN0YWdlIGl0IGlzIGtub3duIHRoYXQgdGhlIHRvcCBiaXQgaXMgc2V0XG4gICAgICByZXQgKz0gMHgxMDAwMDAwMDAwMDAwMCArICh0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gMikge1xuICAgICAgYXNzZXJ0KGZhbHNlLCAnTnVtYmVyIGNhbiBvbmx5IHNhZmVseSBzdG9yZSB1cCB0byA1MyBiaXRzJyk7XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgPyAtcmV0IDogcmV0O1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKDE2LCAyKTtcbiAgfTtcblxuICBpZiAoQnVmZmVyKSB7XG4gICAgQk4ucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gdG9CdWZmZXIgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShCdWZmZXIsIGVuZGlhbiwgbGVuZ3RoKTtcbiAgICB9O1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5IChlbmRpYW4sIGxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEFycmF5LCBlbmRpYW4sIGxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIGFsbG9jYXRlID0gZnVuY3Rpb24gYWxsb2NhdGUgKEFycmF5VHlwZSwgc2l6ZSkge1xuICAgIGlmIChBcnJheVR5cGUuYWxsb2NVbnNhZmUpIHtcbiAgICAgIHJldHVybiBBcnJheVR5cGUuYWxsb2NVbnNhZmUoc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXlUeXBlKHNpemUpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0FycmF5TGlrZSA9IGZ1bmN0aW9uIHRvQXJyYXlMaWtlIChBcnJheVR5cGUsIGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgdGhpcy5fc3RyaXAoKTtcblxuICAgIHZhciBieXRlTGVuZ3RoID0gdGhpcy5ieXRlTGVuZ3RoKCk7XG4gICAgdmFyIHJlcUxlbmd0aCA9IGxlbmd0aCB8fCBNYXRoLm1heCgxLCBieXRlTGVuZ3RoKTtcbiAgICBhc3NlcnQoYnl0ZUxlbmd0aCA8PSByZXFMZW5ndGgsICdieXRlIGFycmF5IGxvbmdlciB0aGFuIGRlc2lyZWQgbGVuZ3RoJyk7XG4gICAgYXNzZXJ0KHJlcUxlbmd0aCA+IDAsICdSZXF1ZXN0ZWQgYXJyYXkgbGVuZ3RoIDw9IDAnKTtcblxuICAgIHZhciByZXMgPSBhbGxvY2F0ZShBcnJheVR5cGUsIHJlcUxlbmd0aCk7XG4gICAgdmFyIHBvc3RmaXggPSBlbmRpYW4gPT09ICdsZScgPyAnTEUnIDogJ0JFJztcbiAgICB0aGlzWydfdG9BcnJheUxpa2UnICsgcG9zdGZpeF0ocmVzLCBieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fdG9BcnJheUxpa2VMRSA9IGZ1bmN0aW9uIF90b0FycmF5TGlrZUxFIChyZXMsIGJ5dGVMZW5ndGgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSAwO1xuICAgIHZhciBjYXJyeSA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgc2hpZnQgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdvcmQgPSAodGhpcy53b3Jkc1tpXSA8PCBzaGlmdCkgfCBjYXJyeTtcblxuICAgICAgcmVzW3Bvc2l0aW9uKytdID0gd29yZCAmIDB4ZmY7XG4gICAgICBpZiAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbisrXSA9ICh3b3JkID4+IDgpICYgMHhmZjtcbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uKytdID0gKHdvcmQgPj4gMTYpICYgMHhmZjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNoaWZ0ID09PSA2KSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXNbcG9zaXRpb24rK10gPSAod29yZCA+PiAyNCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgc2hpZnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3b3JkID4+PiAyNDtcbiAgICAgICAgc2hpZnQgKz0gMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICByZXNbcG9zaXRpb24rK10gPSBjYXJyeTtcblxuICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgICByZXNbcG9zaXRpb24rK10gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX3RvQXJyYXlMaWtlQkUgPSBmdW5jdGlvbiBfdG9BcnJheUxpa2VCRSAocmVzLCBieXRlTGVuZ3RoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gcmVzLmxlbmd0aCAtIDE7XG4gICAgdmFyIGNhcnJ5ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBzaGlmdCA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd29yZCA9ICh0aGlzLndvcmRzW2ldIDw8IHNoaWZ0KSB8IGNhcnJ5O1xuXG4gICAgICByZXNbcG9zaXRpb24tLV0gPSB3b3JkICYgMHhmZjtcbiAgICAgIGlmIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbi0tXSA9ICh3b3JkID4+IDgpICYgMHhmZjtcbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbi0tXSA9ICh3b3JkID4+IDE2KSAmIDB4ZmY7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaGlmdCA9PT0gNikge1xuICAgICAgICBpZiAocG9zaXRpb24gPj0gMCkge1xuICAgICAgICAgIHJlc1twb3NpdGlvbi0tXSA9ICh3b3JkID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgICBzaGlmdCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXJyeSA9IHdvcmQgPj4+IDI0O1xuICAgICAgICBzaGlmdCArPSAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICByZXNbcG9zaXRpb24tLV0gPSBjYXJyeTtcblxuICAgICAgd2hpbGUgKHBvc2l0aW9uID49IDApIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaWYgKE1hdGguY2x6MzIpIHtcbiAgICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHMgKHcpIHtcbiAgICAgIHJldHVybiAzMiAtIE1hdGguY2x6MzIodyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHMgKHcpIHtcbiAgICAgIHZhciB0ID0gdztcbiAgICAgIHZhciByID0gMDtcbiAgICAgIGlmICh0ID49IDB4MTAwMCkge1xuICAgICAgICByICs9IDEzO1xuICAgICAgICB0ID4+Pj0gMTM7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDQwKSB7XG4gICAgICAgIHIgKz0gNztcbiAgICAgICAgdCA+Pj49IDc7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDgpIHtcbiAgICAgICAgciArPSA0O1xuICAgICAgICB0ID4+Pj0gNDtcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4MDIpIHtcbiAgICAgICAgciArPSAyO1xuICAgICAgICB0ID4+Pj0gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByICsgdDtcbiAgICB9O1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl96ZXJvQml0cyA9IGZ1bmN0aW9uIF96ZXJvQml0cyAodykge1xuICAgIC8vIFNob3J0LWN1dFxuICAgIGlmICh3ID09PSAwKSByZXR1cm4gMjY7XG5cbiAgICB2YXIgdCA9IHc7XG4gICAgdmFyIHIgPSAwO1xuICAgIGlmICgodCAmIDB4MWZmZikgPT09IDApIHtcbiAgICAgIHIgKz0gMTM7XG4gICAgICB0ID4+Pj0gMTM7XG4gICAgfVxuICAgIGlmICgodCAmIDB4N2YpID09PSAwKSB7XG4gICAgICByICs9IDc7XG4gICAgICB0ID4+Pj0gNztcbiAgICB9XG4gICAgaWYgKCh0ICYgMHhmKSA9PT0gMCkge1xuICAgICAgciArPSA0O1xuICAgICAgdCA+Pj49IDQ7XG4gICAgfVxuICAgIGlmICgodCAmIDB4MykgPT09IDApIHtcbiAgICAgIHIgKz0gMjtcbiAgICAgIHQgPj4+PSAyO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDEpID09PSAwKSB7XG4gICAgICByKys7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIC8vIFJldHVybiBudW1iZXIgb2YgdXNlZCBiaXRzIGluIGEgQk5cbiAgQk4ucHJvdG90eXBlLmJpdExlbmd0aCA9IGZ1bmN0aW9uIGJpdExlbmd0aCAoKSB7XG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGhpID0gdGhpcy5fY291bnRCaXRzKHcpO1xuICAgIHJldHVybiAodGhpcy5sZW5ndGggLSAxKSAqIDI2ICsgaGk7XG4gIH07XG5cbiAgZnVuY3Rpb24gdG9CaXRBcnJheSAobnVtKSB7XG4gICAgdmFyIHcgPSBuZXcgQXJyYXkobnVtLmJpdExlbmd0aCgpKTtcblxuICAgIGZvciAodmFyIGJpdCA9IDA7IGJpdCA8IHcubGVuZ3RoOyBiaXQrKykge1xuICAgICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuICAgICAgd1tiaXRdID0gKG51bS53b3Jkc1tvZmZdID4+PiB3Yml0KSAmIDB4MDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHc7XG4gIH1cblxuICAvLyBOdW1iZXIgb2YgdHJhaWxpbmcgemVybyBiaXRzXG4gIEJOLnByb3RvdHlwZS56ZXJvQml0cyA9IGZ1bmN0aW9uIHplcm9CaXRzICgpIHtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIDA7XG5cbiAgICB2YXIgciA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYiA9IHRoaXMuX3plcm9CaXRzKHRoaXMud29yZHNbaV0pO1xuICAgICAgciArPSBiO1xuICAgICAgaWYgKGIgIT09IDI2KSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiBieXRlTGVuZ3RoICgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuYml0TGVuZ3RoKCkgLyA4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9Ud29zID0gZnVuY3Rpb24gdG9Ud29zICh3aWR0aCkge1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5hYnMoKS5pbm90bih3aWR0aCkuaWFkZG4oMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZyb21Ud29zID0gZnVuY3Rpb24gZnJvbVR3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMudGVzdG4od2lkdGggLSAxKSkge1xuICAgICAgcmV0dXJuIHRoaXMubm90bih3aWR0aCkuaWFkZG4oMSkuaW5lZygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc05lZyA9IGZ1bmN0aW9uIGlzTmVnICgpIHtcbiAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSAhPT0gMDtcbiAgfTtcblxuICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5lZygpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbmVnID0gZnVuY3Rpb24gaW5lZyAoKSB7XG4gICAgaWYgKCF0aGlzLmlzWmVybygpKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1b3IgPSBmdW5jdGlvbiBpdW9yIChudW0pIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gfCBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlvciA9IGZ1bmN0aW9uIGlvciAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVvcihudW0pO1xuICB9O1xuXG4gIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pb3IodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVvciA9IGZ1bmN0aW9uIHVvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdW9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1b3IodGhpcyk7XG4gIH07XG5cbiAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdWFuZCA9IGZ1bmN0aW9uIGl1YW5kIChudW0pIHtcbiAgICAvLyBiID0gbWluLWxlbmd0aChudW0sIHRoaXMpXG4gICAgdmFyIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSAmIG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGIubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlhbmQgPSBmdW5jdGlvbiBpYW5kIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdWFuZChudW0pO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFuZCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudWFuZCA9IGZ1bmN0aW9uIHVhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVhbmQodGhpcyk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXhvciA9IGZ1bmN0aW9uIGl1eG9yIChudW0pIHtcbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGE7XG4gICAgdmFyIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXSBeIGIud29yZHNbaV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMgIT09IGEpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLml4b3IgPSBmdW5jdGlvbiBpeG9yIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXhvcihudW0pO1xuICB9O1xuXG4gIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml4b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXhvcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXhvciA9IGZ1bmN0aW9uIHV4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXV4b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXV4b3IodGhpcyk7XG4gIH07XG5cbiAgLy8gTm90IGBgdGhpc2BgIHdpdGggYGB3aWR0aGBgIGJpdHdpZHRoXG4gIEJOLnByb3RvdHlwZS5pbm90biA9IGZ1bmN0aW9uIGlub3RuICh3aWR0aCkge1xuICAgIGFzc2VydCh0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInICYmIHdpZHRoID49IDApO1xuXG4gICAgdmFyIGJ5dGVzTmVlZGVkID0gTWF0aC5jZWlsKHdpZHRoIC8gMjYpIHwgMDtcbiAgICB2YXIgYml0c0xlZnQgPSB3aWR0aCAlIDI2O1xuXG4gICAgLy8gRXh0ZW5kIHRoZSBidWZmZXIgd2l0aCBsZWFkaW5nIHplcm9lc1xuICAgIHRoaXMuX2V4cGFuZChieXRlc05lZWRlZCk7XG5cbiAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG4gICAgICBieXRlc05lZWRlZC0tO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBjb21wbGV0ZSB3b3Jkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXNOZWVkZWQ7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSB0aGUgcmVzaWR1ZVxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmICgweDNmZmZmZmYgPj4gKDI2IC0gYml0c0xlZnQpKTtcbiAgICB9XG5cbiAgICAvLyBBbmQgcmVtb3ZlIGxlYWRpbmcgemVyb2VzXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm5vdG4gPSBmdW5jdGlvbiBub3RuICh3aWR0aCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5vdG4od2lkdGgpO1xuICB9O1xuXG4gIC8vIFNldCBgYml0YCBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnNldG4gPSBmdW5jdGlvbiBzZXRuIChiaXQsIHZhbCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG5cbiAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuICAgIHRoaXMuX2V4cGFuZChvZmYgKyAxKTtcblxuICAgIGlmICh2YWwpIHtcbiAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSB8ICgxIDw8IHdiaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gJiB+KDEgPDwgd2JpdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKG51bSkge1xuICAgIHZhciByO1xuXG4gICAgLy8gbmVnYXRpdmUgKyBwb3NpdGl2ZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblxuICAgIC8vIHBvc2l0aXZlICsgbmVnYXRpdmVcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aF0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgLy8gQ29weSB0aGUgcmVzdCBvZiB0aGUgd29yZHNcbiAgICB9IGVsc2UgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG51bSkge1xuICAgIHZhciByZXM7XG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCAmJiB0aGlzLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gdGhpcy5zdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2UgaWYgKG51bS5uZWdhdGl2ZSA9PT0gMCAmJiB0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IG51bS5zdWIodGhpcyk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkKG51bSk7XG5cbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFkZCh0aGlzKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKG51bSkge1xuICAgIC8vIHRoaXMgLSAoLW51bSkgPSB0aGlzICsgbnVtXG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHZhciByID0gdGhpcy5pYWRkKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG5cbiAgICAvLyAtdGhpcyAtIG51bSA9IC0odGhpcyArIG51bSlcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZVxuICAgIHZhciBjbXAgPSB0aGlzLmNtcChudW0pO1xuXG4gICAgLy8gT3B0aW1pemF0aW9uIC0gemVyb2lmeVxuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBhID4gYlxuICAgIHZhciBhLCBiO1xuICAgIGlmIChjbXAgPiAwKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgLSAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gQ29weSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIGlmIChjYXJyeSA9PT0gMCAmJiBpIDwgYS5sZW5ndGggJiYgYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkpO1xuXG4gICAgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1YihudW0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNtYWxsTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgICB2YXIgbGVuID0gKHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aCkgfCAwO1xuICAgIG91dC5sZW5ndGggPSBsZW47XG4gICAgbGVuID0gKGxlbiAtIDEpIHwgMDtcblxuICAgIC8vIFBlZWwgb25lIGl0ZXJhdGlvbiAoY29tcGlsZXIgY2FuJ3QgZG8gaXQsIGJlY2F1c2Ugb2YgY29kZSBjb21wbGV4aXR5KVxuICAgIHZhciBhID0gc2VsZi53b3Jkc1swXSB8IDA7XG4gICAgdmFyIGIgPSBudW0ud29yZHNbMF0gfCAwO1xuICAgIHZhciByID0gYSAqIGI7XG5cbiAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgIHZhciBjYXJyeSA9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgb3V0LndvcmRzWzBdID0gbG87XG5cbiAgICBmb3IgKHZhciBrID0gMTsgayA8IGxlbjsgaysrKSB7XG4gICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgICAgdmFyIG5jYXJyeSA9IGNhcnJ5ID4+PiAyNjtcbiAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICAgIHZhciBpID0gKGsgLSBqKSB8IDA7XG4gICAgICAgIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICAgIHIgPSBhICogYiArIHJ3b3JkO1xuICAgICAgICBuY2FycnkgKz0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICAgICAgcndvcmQgPSByICYgMHgzZmZmZmZmO1xuICAgICAgfVxuICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQgfCAwO1xuICAgICAgY2FycnkgPSBuY2FycnkgfCAwO1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5IHwgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuX3N0cmlwKCk7XG4gIH1cblxuICAvLyBUT0RPKGluZHV0bnkpOiBpdCBtYXkgYmUgcmVhc29uYWJsZSB0byBvbWl0IGl0IGZvciB1c2VycyB3aG8gZG9uJ3QgbmVlZFxuICAvLyB0byB3b3JrIHdpdGggMjU2LWJpdCBudW1iZXJzLCBvdGhlcndpc2UgaXQgZ2l2ZXMgMjAlIGltcHJvdmVtZW50IGZvciAyNTYtYml0XG4gIC8vIG11bHRpcGxpY2F0aW9uIChsaWtlIGVsbGlwdGljIHNlY3AyNTZrMSkuXG4gIHZhciBjb21iMTBNdWxUbyA9IGZ1bmN0aW9uIGNvbWIxME11bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIHZhciBhID0gc2VsZi53b3JkcztcbiAgICB2YXIgYiA9IG51bS53b3JkcztcbiAgICB2YXIgbyA9IG91dC53b3JkcztcbiAgICB2YXIgYyA9IDA7XG4gICAgdmFyIGxvO1xuICAgIHZhciBtaWQ7XG4gICAgdmFyIGhpO1xuICAgIHZhciBhMCA9IGFbMF0gfCAwO1xuICAgIHZhciBhbDAgPSBhMCAmIDB4MWZmZjtcbiAgICB2YXIgYWgwID0gYTAgPj4+IDEzO1xuICAgIHZhciBhMSA9IGFbMV0gfCAwO1xuICAgIHZhciBhbDEgPSBhMSAmIDB4MWZmZjtcbiAgICB2YXIgYWgxID0gYTEgPj4+IDEzO1xuICAgIHZhciBhMiA9IGFbMl0gfCAwO1xuICAgIHZhciBhbDIgPSBhMiAmIDB4MWZmZjtcbiAgICB2YXIgYWgyID0gYTIgPj4+IDEzO1xuICAgIHZhciBhMyA9IGFbM10gfCAwO1xuICAgIHZhciBhbDMgPSBhMyAmIDB4MWZmZjtcbiAgICB2YXIgYWgzID0gYTMgPj4+IDEzO1xuICAgIHZhciBhNCA9IGFbNF0gfCAwO1xuICAgIHZhciBhbDQgPSBhNCAmIDB4MWZmZjtcbiAgICB2YXIgYWg0ID0gYTQgPj4+IDEzO1xuICAgIHZhciBhNSA9IGFbNV0gfCAwO1xuICAgIHZhciBhbDUgPSBhNSAmIDB4MWZmZjtcbiAgICB2YXIgYWg1ID0gYTUgPj4+IDEzO1xuICAgIHZhciBhNiA9IGFbNl0gfCAwO1xuICAgIHZhciBhbDYgPSBhNiAmIDB4MWZmZjtcbiAgICB2YXIgYWg2ID0gYTYgPj4+IDEzO1xuICAgIHZhciBhNyA9IGFbN10gfCAwO1xuICAgIHZhciBhbDcgPSBhNyAmIDB4MWZmZjtcbiAgICB2YXIgYWg3ID0gYTcgPj4+IDEzO1xuICAgIHZhciBhOCA9IGFbOF0gfCAwO1xuICAgIHZhciBhbDggPSBhOCAmIDB4MWZmZjtcbiAgICB2YXIgYWg4ID0gYTggPj4+IDEzO1xuICAgIHZhciBhOSA9IGFbOV0gfCAwO1xuICAgIHZhciBhbDkgPSBhOSAmIDB4MWZmZjtcbiAgICB2YXIgYWg5ID0gYTkgPj4+IDEzO1xuICAgIHZhciBiMCA9IGJbMF0gfCAwO1xuICAgIHZhciBibDAgPSBiMCAmIDB4MWZmZjtcbiAgICB2YXIgYmgwID0gYjAgPj4+IDEzO1xuICAgIHZhciBiMSA9IGJbMV0gfCAwO1xuICAgIHZhciBibDEgPSBiMSAmIDB4MWZmZjtcbiAgICB2YXIgYmgxID0gYjEgPj4+IDEzO1xuICAgIHZhciBiMiA9IGJbMl0gfCAwO1xuICAgIHZhciBibDIgPSBiMiAmIDB4MWZmZjtcbiAgICB2YXIgYmgyID0gYjIgPj4+IDEzO1xuICAgIHZhciBiMyA9IGJbM10gfCAwO1xuICAgIHZhciBibDMgPSBiMyAmIDB4MWZmZjtcbiAgICB2YXIgYmgzID0gYjMgPj4+IDEzO1xuICAgIHZhciBiNCA9IGJbNF0gfCAwO1xuICAgIHZhciBibDQgPSBiNCAmIDB4MWZmZjtcbiAgICB2YXIgYmg0ID0gYjQgPj4+IDEzO1xuICAgIHZhciBiNSA9IGJbNV0gfCAwO1xuICAgIHZhciBibDUgPSBiNSAmIDB4MWZmZjtcbiAgICB2YXIgYmg1ID0gYjUgPj4+IDEzO1xuICAgIHZhciBiNiA9IGJbNl0gfCAwO1xuICAgIHZhciBibDYgPSBiNiAmIDB4MWZmZjtcbiAgICB2YXIgYmg2ID0gYjYgPj4+IDEzO1xuICAgIHZhciBiNyA9IGJbN10gfCAwO1xuICAgIHZhciBibDcgPSBiNyAmIDB4MWZmZjtcbiAgICB2YXIgYmg3ID0gYjcgPj4+IDEzO1xuICAgIHZhciBiOCA9IGJbOF0gfCAwO1xuICAgIHZhciBibDggPSBiOCAmIDB4MWZmZjtcbiAgICB2YXIgYmg4ID0gYjggPj4+IDEzO1xuICAgIHZhciBiOSA9IGJbOV0gfCAwO1xuICAgIHZhciBibDkgPSBiOSAmIDB4MWZmZjtcbiAgICB2YXIgYmg5ID0gYjkgPj4+IDEzO1xuXG4gICAgb3V0Lm5lZ2F0aXZlID0gc2VsZi5uZWdhdGl2ZSBeIG51bS5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0gMTk7XG4gICAgLyogayA9IDAgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDAsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMCwgYmgwKTtcbiAgICB2YXIgdzAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcwID4+PiAyNikpIHwgMDtcbiAgICB3MCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDEsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDEpKSB8IDA7XG4gICAgdmFyIHcxID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MSA+Pj4gMjYpKSB8IDA7XG4gICAgdzEgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwyLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDIsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDIsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMikpIHwgMDtcbiAgICB2YXIgdzIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcyID4+PiAyNikpIHwgMDtcbiAgICB3MiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDMgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDMsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMywgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMykpIHwgMDtcbiAgICB2YXIgdzMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHczID4+PiAyNikpIHwgMDtcbiAgICB3MyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDQgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDQsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNCwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDQpKSB8IDA7XG4gICAgdmFyIHc0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NCA+Pj4gMjYpKSB8IDA7XG4gICAgdzQgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw1LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDUsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDUsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNSkpIHwgMDtcbiAgICB2YXIgdzUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc1ID4+PiAyNikpIHwgMDtcbiAgICB3NSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDYgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDYsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNiwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNikpIHwgMDtcbiAgICB2YXIgdzYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc2ID4+PiAyNikpIHwgMDtcbiAgICB3NiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDcgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDcsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNywgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNywgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDcpKSB8IDA7XG4gICAgdmFyIHc3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NyA+Pj4gMjYpKSB8IDA7XG4gICAgdzcgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw4LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDgsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDgsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoOCkpIHwgMDtcbiAgICB2YXIgdzggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc4ID4+PiAyNikpIHwgMDtcbiAgICB3OCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDkgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzkgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc5ID4+PiAyNikpIHwgMDtcbiAgICB3OSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDEpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMSk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTAgPj4+IDI2KSkgfCAwO1xuICAgIHcxMCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDExICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDIpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMSA+Pj4gMjYpKSB8IDA7XG4gICAgdzExICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTIgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMyk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgzKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwzKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgzKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTIgPj4+IDI2KSkgfCAwO1xuICAgIHcxMiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDQpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEzID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTMgPj4+IDI2KSkgfCAwO1xuICAgIHcxMyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDUpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNSk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNCA+Pj4gMjYpKSB8IDA7XG4gICAgdzE0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTUgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNik7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg2KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw2KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg2KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTUgPj4+IDI2KSkgfCAwO1xuICAgIHcxNSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDcpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTYgPj4+IDI2KSkgfCAwO1xuICAgIHcxNiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDgpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNyA+Pj4gMjYpKSB8IDA7XG4gICAgdzE3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTggKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg5KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw5KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg5KTtcbiAgICB2YXIgdzE4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTggPj4+IDI2KSkgfCAwO1xuICAgIHcxOCAmPSAweDNmZmZmZmY7XG4gICAgb1swXSA9IHcwO1xuICAgIG9bMV0gPSB3MTtcbiAgICBvWzJdID0gdzI7XG4gICAgb1szXSA9IHczO1xuICAgIG9bNF0gPSB3NDtcbiAgICBvWzVdID0gdzU7XG4gICAgb1s2XSA9IHc2O1xuICAgIG9bN10gPSB3NztcbiAgICBvWzhdID0gdzg7XG4gICAgb1s5XSA9IHc5O1xuICAgIG9bMTBdID0gdzEwO1xuICAgIG9bMTFdID0gdzExO1xuICAgIG9bMTJdID0gdzEyO1xuICAgIG9bMTNdID0gdzEzO1xuICAgIG9bMTRdID0gdzE0O1xuICAgIG9bMTVdID0gdzE1O1xuICAgIG9bMTZdID0gdzE2O1xuICAgIG9bMTddID0gdzE3O1xuICAgIG9bMThdID0gdzE4O1xuICAgIGlmIChjICE9PSAwKSB7XG4gICAgICBvWzE5XSA9IGM7XG4gICAgICBvdXQubGVuZ3RoKys7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH07XG5cbiAgLy8gUG9seWZpbGwgY29tYlxuICBpZiAoIU1hdGguaW11bCkge1xuICAgIGNvbWIxME11bFRvID0gc21hbGxNdWxUbztcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpZ011bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aDtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgdmFyIGhuY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3V0Lmxlbmd0aCAtIDE7IGsrKykge1xuICAgICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICAgIHZhciBuY2FycnkgPSBobmNhcnJ5O1xuICAgICAgaG5jYXJyeSA9IDA7XG4gICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcbiAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgICB2YXIgaSA9IGsgLSBqO1xuICAgICAgICB2YXIgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICB2YXIgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICAgIHZhciByID0gYSAqIGI7XG5cbiAgICAgICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArICgociAvIDB4NDAwMDAwMCkgfCAwKSkgfCAwO1xuICAgICAgICBsbyA9IChsbyArIHJ3b3JkKSB8IDA7XG4gICAgICAgIHJ3b3JkID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAobG8gPj4+IDI2KSkgfCAwO1xuXG4gICAgICAgIGhuY2FycnkgKz0gbmNhcnJ5ID4+PiAyNjtcbiAgICAgICAgbmNhcnJ5ICY9IDB4M2ZmZmZmZjtcbiAgICAgIH1cbiAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkO1xuICAgICAgY2FycnkgPSBuY2Fycnk7XG4gICAgICBuY2FycnkgPSBobmNhcnJ5O1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5fc3RyaXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGp1bWJvTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgLy8gVGVtcG9yYXJ5IGRpc2FibGUsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy9pc3N1ZXMvMjExXG4gICAgLy8gdmFyIGZmdG0gPSBuZXcgRkZUTSgpO1xuICAgIC8vIHJldHVybiBmZnRtLm11bHAoc2VsZiwgbnVtLCBvdXQpO1xuICAgIHJldHVybiBiaWdNdWxUbyhzZWxmLCBudW0sIG91dCk7XG4gIH1cblxuICBCTi5wcm90b3R5cGUubXVsVG8gPSBmdW5jdGlvbiBtdWxUbyAobnVtLCBvdXQpIHtcbiAgICB2YXIgcmVzO1xuICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aCArIG51bS5sZW5ndGg7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxMCAmJiBudW0ubGVuZ3RoID09PSAxMCkge1xuICAgICAgcmVzID0gY29tYjEwTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSBpZiAobGVuIDwgNjMpIHtcbiAgICAgIHJlcyA9IHNtYWxsTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSBpZiAobGVuIDwgMTAyNCkge1xuICAgICAgcmVzID0gYmlnTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIENvb2xleS1UdWtleSBhbGdvcml0aG0gZm9yIEZGVFxuICAvLyBzbGlnaHRseSByZXZpc2l0ZWQgdG8gcmVseSBvbiBsb29waW5nIGluc3RlYWQgb2YgcmVjdXJzaW9uXG5cbiAgZnVuY3Rpb24gRkZUTSAoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuXG4gIEZGVE0ucHJvdG90eXBlLm1ha2VSQlQgPSBmdW5jdGlvbiBtYWtlUkJUIChOKSB7XG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGwgPSBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyhOKSAtIDE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHRbaV0gPSB0aGlzLnJldkJpbihpLCBsLCBOKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGJpbmFyeS1yZXZlcnNlZCByZXByZXNlbnRhdGlvbiBvZiBgeGBcbiAgRkZUTS5wcm90b3R5cGUucmV2QmluID0gZnVuY3Rpb24gcmV2QmluICh4LCBsLCBOKSB7XG4gICAgaWYgKHggPT09IDAgfHwgeCA9PT0gTiAtIDEpIHJldHVybiB4O1xuXG4gICAgdmFyIHJiID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgcmIgfD0gKHggJiAxKSA8PCAobCAtIGkgLSAxKTtcbiAgICAgIHggPj49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJiO1xuICB9O1xuXG4gIC8vIFBlcmZvcm1zIFwidHdlZWRsaW5nXCIgcGhhc2UsIHRoZXJlZm9yZSAnZW11bGF0aW5nJ1xuICAvLyBiZWhhdmlvdXIgb2YgdGhlIHJlY3Vyc2l2ZSBhbGdvcml0aG1cbiAgRkZUTS5wcm90b3R5cGUucGVybXV0ZSA9IGZ1bmN0aW9uIHBlcm11dGUgKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgcnR3c1tpXSA9IHJ3c1tyYnRbaV1dO1xuICAgICAgaXR3c1tpXSA9IGl3c1tyYnRbaV1dO1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0gKHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOLCByYnQpIHtcbiAgICB0aGlzLnBlcm11dGUocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTik7XG5cbiAgICBmb3IgKHZhciBzID0gMTsgcyA8IE47IHMgPDw9IDEpIHtcbiAgICAgIHZhciBsID0gcyA8PCAxO1xuXG4gICAgICB2YXIgcnR3ZGYgPSBNYXRoLmNvcygyICogTWF0aC5QSSAvIGwpO1xuICAgICAgdmFyIGl0d2RmID0gTWF0aC5zaW4oMiAqIE1hdGguUEkgLyBsKTtcblxuICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBOOyBwICs9IGwpIHtcbiAgICAgICAgdmFyIHJ0d2RmXyA9IHJ0d2RmO1xuICAgICAgICB2YXIgaXR3ZGZfID0gaXR3ZGY7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzOyBqKyspIHtcbiAgICAgICAgICB2YXIgcmUgPSBydHdzW3AgKyBqXTtcbiAgICAgICAgICB2YXIgaWUgPSBpdHdzW3AgKyBqXTtcblxuICAgICAgICAgIHZhciBybyA9IHJ0d3NbcCArIGogKyBzXTtcbiAgICAgICAgICB2YXIgaW8gPSBpdHdzW3AgKyBqICsgc107XG5cbiAgICAgICAgICB2YXIgcnggPSBydHdkZl8gKiBybyAtIGl0d2RmXyAqIGlvO1xuXG4gICAgICAgICAgaW8gPSBydHdkZl8gKiBpbyArIGl0d2RmXyAqIHJvO1xuICAgICAgICAgIHJvID0gcng7XG5cbiAgICAgICAgICBydHdzW3AgKyBqXSA9IHJlICsgcm87XG4gICAgICAgICAgaXR3c1twICsgal0gPSBpZSArIGlvO1xuXG4gICAgICAgICAgcnR3c1twICsgaiArIHNdID0gcmUgLSBybztcbiAgICAgICAgICBpdHdzW3AgKyBqICsgc10gPSBpZSAtIGlvO1xuXG4gICAgICAgICAgLyoganNoaW50IG1heGRlcHRoIDogZmFsc2UgKi9cbiAgICAgICAgICBpZiAoaiAhPT0gbCkge1xuICAgICAgICAgICAgcnggPSBydHdkZiAqIHJ0d2RmXyAtIGl0d2RmICogaXR3ZGZfO1xuXG4gICAgICAgICAgICBpdHdkZl8gPSBydHdkZiAqIGl0d2RmXyArIGl0d2RmICogcnR3ZGZfO1xuICAgICAgICAgICAgcnR3ZGZfID0gcng7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmd1ZXNzTGVuMTNiID0gZnVuY3Rpb24gZ3Vlc3NMZW4xM2IgKG4sIG0pIHtcbiAgICB2YXIgTiA9IE1hdGgubWF4KG0sIG4pIHwgMTtcbiAgICB2YXIgb2RkID0gTiAmIDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoTiA9IE4gLyAyIHwgMDsgTjsgTiA9IE4gPj4+IDEpIHtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gMSA8PCBpICsgMSArIG9kZDtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5jb25qdWdhdGUgPSBmdW5jdGlvbiBjb25qdWdhdGUgKHJ3cywgaXdzLCBOKSB7XG4gICAgaWYgKE4gPD0gMSkgcmV0dXJuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG4gICAgICB2YXIgdCA9IHJ3c1tpXTtcblxuICAgICAgcndzW2ldID0gcndzW04gLSBpIC0gMV07XG4gICAgICByd3NbTiAtIGkgLSAxXSA9IHQ7XG5cbiAgICAgIHQgPSBpd3NbaV07XG5cbiAgICAgIGl3c1tpXSA9IC1pd3NbTiAtIGkgLSAxXTtcbiAgICAgIGl3c1tOIC0gaSAtIDFdID0gLXQ7XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLm5vcm1hbGl6ZTEzYiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZTEzYiAod3MsIE4pIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHcgPSBNYXRoLnJvdW5kKHdzWzIgKiBpICsgMV0gLyBOKSAqIDB4MjAwMCArXG4gICAgICAgIE1hdGgucm91bmQod3NbMiAqIGldIC8gTikgK1xuICAgICAgICBjYXJyeTtcblxuICAgICAgd3NbaV0gPSB3ICYgMHgzZmZmZmZmO1xuXG4gICAgICBpZiAodyA8IDB4NDAwMDAwMCkge1xuICAgICAgICBjYXJyeSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXJyeSA9IHcgLyAweDQwMDAwMDAgfCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3cztcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5jb252ZXJ0MTNiID0gZnVuY3Rpb24gY29udmVydDEzYiAod3MsIGxlbiwgcndzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYXJyeSA9IGNhcnJ5ICsgKHdzW2ldIHwgMCk7XG5cbiAgICAgIHJ3c1syICogaV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgICByd3NbMiAqIGkgKyAxXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICB9XG5cbiAgICAvLyBQYWQgd2l0aCB6ZXJvZXNcbiAgICBmb3IgKGkgPSAyICogbGVuOyBpIDwgTjsgKytpKSB7XG4gICAgICByd3NbaV0gPSAwO1xuICAgIH1cblxuICAgIGFzc2VydChjYXJyeSA9PT0gMCk7XG4gICAgYXNzZXJ0KChjYXJyeSAmIH4weDFmZmYpID09PSAwKTtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5zdHViID0gZnVuY3Rpb24gc3R1YiAoTikge1xuICAgIHZhciBwaCA9IG5ldyBBcnJheShOKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgcGhbaV0gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBwaDtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5tdWxwID0gZnVuY3Rpb24gbXVscCAoeCwgeSwgb3V0KSB7XG4gICAgdmFyIE4gPSAyICogdGhpcy5ndWVzc0xlbjEzYih4Lmxlbmd0aCwgeS5sZW5ndGgpO1xuXG4gICAgdmFyIHJidCA9IHRoaXMubWFrZVJCVChOKTtcblxuICAgIHZhciBfID0gdGhpcy5zdHViKE4pO1xuXG4gICAgdmFyIHJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgcndzdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgaXdzdCA9IG5ldyBBcnJheShOKTtcblxuICAgIHZhciBucndzID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBucndzdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbml3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgcm13cyA9IG91dC53b3JkcztcbiAgICBybXdzLmxlbmd0aCA9IE47XG5cbiAgICB0aGlzLmNvbnZlcnQxM2IoeC53b3JkcywgeC5sZW5ndGgsIHJ3cywgTik7XG4gICAgdGhpcy5jb252ZXJ0MTNiKHkud29yZHMsIHkubGVuZ3RoLCBucndzLCBOKTtcblxuICAgIHRoaXMudHJhbnNmb3JtKHJ3cywgXywgcndzdCwgaXdzdCwgTiwgcmJ0KTtcbiAgICB0aGlzLnRyYW5zZm9ybShucndzLCBfLCBucndzdCwgbml3c3QsIE4sIHJidCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdmFyIHJ4ID0gcndzdFtpXSAqIG5yd3N0W2ldIC0gaXdzdFtpXSAqIG5pd3N0W2ldO1xuICAgICAgaXdzdFtpXSA9IHJ3c3RbaV0gKiBuaXdzdFtpXSArIGl3c3RbaV0gKiBucndzdFtpXTtcbiAgICAgIHJ3c3RbaV0gPSByeDtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmp1Z2F0ZShyd3N0LCBpd3N0LCBOKTtcbiAgICB0aGlzLnRyYW5zZm9ybShyd3N0LCBpd3N0LCBybXdzLCBfLCBOLCByYnQpO1xuICAgIHRoaXMuY29uanVnYXRlKHJtd3MsIF8sIE4pO1xuICAgIHRoaXMubm9ybWFsaXplMTNiKHJtd3MsIE4pO1xuXG4gICAgb3V0Lm5lZ2F0aXZlID0geC5uZWdhdGl2ZSBeIHkubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IHgubGVuZ3RoICsgeS5sZW5ndGg7XG4gICAgcmV0dXJuIG91dC5fc3RyaXAoKTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBgdGhpc2AgYnkgYG51bWBcbiAgQk4ucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5tdWxUbyhudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgZW1wbG95aW5nIEZGVFxuICBCTi5wcm90b3R5cGUubXVsZiA9IGZ1bmN0aW9uIG11bGYgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIEluLXBsYWNlIE11bHRpcGxpY2F0aW9uXG4gIEJOLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5tdWxUbyhudW0sIHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbXVsbiA9IGZ1bmN0aW9uIGltdWxuIChudW0pIHtcbiAgICB2YXIgaXNOZWdOdW0gPSBudW0gPCAwO1xuICAgIGlmIChpc05lZ051bSkgbnVtID0gLW51bTtcblxuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG5cbiAgICAvLyBDYXJyeVxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKiBudW07XG4gICAgICB2YXIgbG8gPSAodyAmIDB4M2ZmZmZmZikgKyAoY2FycnkgJiAweDNmZmZmZmYpO1xuICAgICAgY2FycnkgPj49IDI2O1xuICAgICAgY2FycnkgKz0gKHcgLyAweDQwMDAwMDApIHwgMDtcbiAgICAgIC8vIE5PVEU6IGxvIGlzIDI3Yml0IG1heGltdW1cbiAgICAgIGNhcnJ5ICs9IGxvID4+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzTmVnTnVtID8gdGhpcy5pbmVnKCkgOiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tdWxuID0gZnVuY3Rpb24gbXVsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbXVsbihudW0pO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwodGhpcyk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bCh0aGlzLmNsb25lKCkpO1xuICB9O1xuXG4gIC8vIE1hdGgucG93KGB0aGlzYCwgYG51bWApXG4gIEJOLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKG51bSkge1xuICAgIHZhciB3ID0gdG9CaXRBcnJheShudW0pO1xuICAgIGlmICh3Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5ldyBCTigxKTtcblxuICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXNcbiAgICB2YXIgcmVzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHcubGVuZ3RoOyBpKyssIHJlcyA9IHJlcy5zcXIoKSkge1xuICAgICAgaWYgKHdbaV0gIT09IDApIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICgrK2kgPCB3Lmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgcSA9IHJlcy5zcXIoKTsgaSA8IHcubGVuZ3RoOyBpKyssIHEgPSBxLnNxcigpKSB7XG4gICAgICAgIGlmICh3W2ldID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSByZXMubXVsKHEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVzaGxuID0gZnVuY3Rpb24gaXVzaGxuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuICAgIHZhciBjYXJyeU1hc2sgPSAoMHgzZmZmZmZmID4+PiAoMjYgLSByKSkgPDwgKDI2IC0gcik7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5ld0NhcnJ5ID0gdGhpcy53b3Jkc1tpXSAmIGNhcnJ5TWFzaztcbiAgICAgICAgdmFyIGMgPSAoKHRoaXMud29yZHNbaV0gfCAwKSAtIG5ld0NhcnJ5KSA8PCByO1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYyB8IGNhcnJ5O1xuICAgICAgICBjYXJyeSA9IG5ld0NhcnJ5ID4+PiAoMjYgLSByKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhcnJ5KSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocyAhPT0gMCkge1xuICAgICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyBzXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoICs9IHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzaGxuID0gZnVuY3Rpb24gaXNobG4gKGJpdHMpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaGxuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LXJpZ2h0IGluLXBsYWNlXG4gIC8vIE5PVEU6IGBoaW50YCBpcyBhIGxvd2VzdCBiaXQgYmVmb3JlIHRyYWlsaW5nIHplcm9lc1xuICAvLyBOT1RFOiBpZiBgZXh0ZW5kZWRgIGlzIHByZXNlbnQgLSBpdCB3aWxsIGJlIGZpbGxlZCB3aXRoIGRlc3Ryb3llZCBiaXRzXG4gIEJOLnByb3RvdHlwZS5pdXNocm4gPSBmdW5jdGlvbiBpdXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciBoO1xuICAgIGlmIChoaW50KSB7XG4gICAgICBoID0gKGhpbnQgLSAoaGludCAlIDI2KSkgLyAyNjtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSBNYXRoLm1pbigoYml0cyAtIHIpIC8gMjYsIHRoaXMubGVuZ3RoKTtcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICB2YXIgbWFza2VkV29yZHMgPSBleHRlbmRlZDtcblxuICAgIGggLT0gcztcbiAgICBoID0gTWF0aC5tYXgoMCwgaCk7XG5cbiAgICAvLyBFeHRlbmRlZCBtb2RlLCBjb3B5IG1hc2tlZCBwYXJ0XG4gICAgaWYgKG1hc2tlZFdvcmRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgICBtYXNrZWRXb3Jkcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG4gICAgICBtYXNrZWRXb3Jkcy5sZW5ndGggPSBzO1xuICAgIH1cblxuICAgIGlmIChzID09PSAwKSB7XG4gICAgICAvLyBOby1vcCwgd2Ugc2hvdWxkIG5vdCBtb3ZlIGFueXRoaW5nIGF0IGFsbFxuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiBzKSB7XG4gICAgICB0aGlzLmxlbmd0aCAtPSBzO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaSArIHNdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwICYmIChjYXJyeSAhPT0gMCB8fCBpID49IGgpOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB0aGlzLndvcmRzW2ldID0gKGNhcnJ5IDw8ICgyNiAtIHIpKSB8ICh3b3JkID4+PiByKTtcbiAgICAgIGNhcnJ5ID0gd29yZCAmIG1hc2s7XG4gICAgfVxuXG4gICAgLy8gUHVzaCBjYXJyaWVkIGJpdHMgYXMgYSBtYXNrXG4gICAgaWYgKG1hc2tlZFdvcmRzICYmIGNhcnJ5ICE9PSAwKSB7XG4gICAgICBtYXNrZWRXb3Jkcy53b3Jkc1ttYXNrZWRXb3Jkcy5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc2hybiA9IGZ1bmN0aW9uIGlzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNocm4oYml0cywgaGludCwgZXh0ZW5kZWQpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LWxlZnRcbiAgQk4ucHJvdG90eXBlLnNobG4gPSBmdW5jdGlvbiBzaGxuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hsbihiaXRzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXNobG4gPSBmdW5jdGlvbiB1c2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaGxuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LXJpZ2h0XG4gIEJOLnByb3RvdHlwZS5zaHJuID0gZnVuY3Rpb24gc2hybiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNocm4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaHJuID0gZnVuY3Rpb24gdXNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hybihiaXRzKTtcbiAgfTtcblxuICAvLyBUZXN0IGlmIG4gYml0IGlzIHNldFxuICBCTi5wcm90b3R5cGUudGVzdG4gPSBmdW5jdGlvbiB0ZXN0biAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBiaXQgYW5kIHJldHVyblxuICAgIHZhciB3ID0gdGhpcy53b3Jkc1tzXTtcblxuICAgIHJldHVybiAhISh3ICYgcSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyIChpbi1wbGFjZSlcbiAgQk4ucHJvdG90eXBlLmltYXNrbiA9IGZ1bmN0aW9uIGltYXNrbiAoYml0cykge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcblxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAnaW1hc2tuIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZSBudW1iZXJzJyk7XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHMrKztcbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1pbihzLCB0aGlzLmxlbmd0aCk7XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gJj0gbWFzaztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXJcbiAgQk4ucHJvdG90eXBlLm1hc2tuID0gZnVuY3Rpb24gbWFza24gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltYXNrbihiaXRzKTtcbiAgfTtcblxuICAvLyBBZGQgcGxhaW4gbnVtYmVyIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaWFkZG4gPSBmdW5jdGlvbiBpYWRkbiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaXN1Ym4oLW51bSk7XG5cbiAgICAvLyBQb3NzaWJsZSBzaWduIGNoYW5nZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgKHRoaXMud29yZHNbMF0gfCAwKSA8PSBudW0pIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSA9IG51bSAtICh0aGlzLndvcmRzWzBdIHwgMCk7XG4gICAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlzdWJuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRob3V0IGNoZWNrc1xuICAgIHJldHVybiB0aGlzLl9pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faWFkZG4gPSBmdW5jdGlvbiBfaWFkZG4gKG51bSkge1xuICAgIHRoaXMud29yZHNbMF0gKz0gbnVtO1xuXG4gICAgLy8gQ2FycnlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPj0gMHg0MDAwMDAwOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gLT0gMHg0MDAwMDAwO1xuICAgICAgaWYgKGkgPT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSsrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpICsgMSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBwbGFpbiBudW1iZXIgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlzdWJuID0gZnVuY3Rpb24gaXN1Ym4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlhZGRuKC1udW0pO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkbihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLndvcmRzWzBdIC09IG51bTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdIDwgMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IC10aGlzLndvcmRzWzBdO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhcnJ5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPCAwOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSArPSAweDQwMDAwMDA7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdIC09IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmFkZG4gPSBmdW5jdGlvbiBhZGRuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGRuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnN1Ym4gPSBmdW5jdGlvbiBzdWJuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWJuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlhYnMgPSBmdW5jdGlvbiBpYWJzICgpIHtcbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiBhYnMgKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFicygpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faXNobG5zdWJtdWwgPSBmdW5jdGlvbiBfaXNobG5zdWJtdWwgKG51bSwgbXVsLCBzaGlmdCkge1xuICAgIHZhciBsZW4gPSBudW0ubGVuZ3RoICsgc2hpZnQ7XG4gICAgdmFyIGk7XG5cbiAgICB0aGlzLl9leHBhbmQobGVuKTtcblxuICAgIHZhciB3O1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgdmFyIHJpZ2h0ID0gKG51bS53b3Jkc1tpXSB8IDApICogbXVsO1xuICAgICAgdyAtPSByaWdodCAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gKHcgPj4gMjYpIC0gKChyaWdodCAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIGZvciAoOyBpIDwgdGhpcy5sZW5ndGggLSBzaGlmdDsgaSsrKSB7XG4gICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIGlmIChjYXJyeSA9PT0gMCkgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG5cbiAgICAvLyBTdWJ0cmFjdGlvbiBvdmVyZmxvd1xuICAgIGFzc2VydChjYXJyeSA9PT0gLTEpO1xuICAgIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdyA9IC0odGhpcy53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX3dvcmREaXYgPSBmdW5jdGlvbiBfd29yZERpdiAobnVtLCBtb2RlKSB7XG4gICAgdmFyIHNoaWZ0ID0gdGhpcy5sZW5ndGggLSBudW0ubGVuZ3RoO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW07XG5cbiAgICAvLyBOb3JtYWxpemVcbiAgICB2YXIgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICB2YXIgYmhpQml0cyA9IHRoaXMuX2NvdW50Qml0cyhiaGkpO1xuICAgIHNoaWZ0ID0gMjYgLSBiaGlCaXRzO1xuICAgIGlmIChzaGlmdCAhPT0gMCkge1xuICAgICAgYiA9IGIudXNobG4oc2hpZnQpO1xuICAgICAgYS5pdXNobG4oc2hpZnQpO1xuICAgICAgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHF1b3RpZW50XG4gICAgdmFyIG0gPSBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICAgIHZhciBxO1xuXG4gICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICBxID0gbmV3IEJOKG51bGwpO1xuICAgICAgcS5sZW5ndGggPSBtICsgMTtcbiAgICAgIHEud29yZHMgPSBuZXcgQXJyYXkocS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHEud29yZHNbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkaWZmID0gYS5jbG9uZSgpLl9pc2hsbnN1Ym11bChiLCAxLCBtKTtcbiAgICBpZiAoZGlmZi5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgYSA9IGRpZmY7XG4gICAgICBpZiAocSkge1xuICAgICAgICBxLndvcmRzW21dID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gbSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICB2YXIgcWogPSAoYS53b3Jkc1tiLmxlbmd0aCArIGpdIHwgMCkgKiAweDQwMDAwMDAgK1xuICAgICAgICAoYS53b3Jkc1tiLmxlbmd0aCArIGogLSAxXSB8IDApO1xuXG4gICAgICAvLyBOT1RFOiAocWogLyBiaGkpIGlzICgweDNmZmZmZmYgKiAweDQwMDAwMDAgKyAweDNmZmZmZmYpIC8gMHgyMDAwMDAwIG1heFxuICAgICAgLy8gKDB4N2ZmZmZmZilcbiAgICAgIHFqID0gTWF0aC5taW4oKHFqIC8gYmhpKSB8IDAsIDB4M2ZmZmZmZik7XG5cbiAgICAgIGEuX2lzaGxuc3VibXVsKGIsIHFqLCBqKTtcbiAgICAgIHdoaWxlIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIHFqLS07XG4gICAgICAgIGEubmVnYXRpdmUgPSAwO1xuICAgICAgICBhLl9pc2hsbnN1Ym11bChiLCAxLCBqKTtcbiAgICAgICAgaWYgKCFhLmlzWmVybygpKSB7XG4gICAgICAgICAgYS5uZWdhdGl2ZSBePSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocSkge1xuICAgICAgICBxLndvcmRzW2pdID0gcWo7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxKSB7XG4gICAgICBxLl9zdHJpcCgpO1xuICAgIH1cbiAgICBhLl9zdHJpcCgpO1xuXG4gICAgLy8gRGVub3JtYWxpemVcbiAgICBpZiAobW9kZSAhPT0gJ2RpdicgJiYgc2hpZnQgIT09IDApIHtcbiAgICAgIGEuaXVzaHJuKHNoaWZ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGl2OiBxIHx8IG51bGwsXG4gICAgICBtb2Q6IGFcbiAgICB9O1xuICB9O1xuXG4gIC8vIE5PVEU6IDEpIGBtb2RlYCBjYW4gYmUgc2V0IHRvIGBtb2RgIHRvIHJlcXVlc3QgbW9kIG9ubHksXG4gIC8vICAgICAgIHRvIGBkaXZgIHRvIHJlcXVlc3QgZGl2IG9ubHksIG9yIGJlIGFic2VudCB0b1xuICAvLyAgICAgICByZXF1ZXN0IGJvdGggZGl2ICYgbW9kXG4gIC8vICAgICAgIDIpIGBwb3NpdGl2ZWAgaXMgdHJ1ZSBpZiB1bnNpZ25lZCBtb2QgaXMgcmVxdWVzdGVkXG4gIEJOLnByb3RvdHlwZS5kaXZtb2QgPSBmdW5jdGlvbiBkaXZtb2QgKG51bSwgbW9kZSwgcG9zaXRpdmUpIHtcbiAgICBhc3NlcnQoIW51bS5pc1plcm8oKSk7XG5cbiAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBuZXcgQk4oMCksXG4gICAgICAgIG1vZDogbmV3IEJOKDApXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkaXYsIG1vZCwgcmVzO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbW9kLmlhZGQobnVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogcmVzLm1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoKHRoaXMubmVnYXRpdmUgJiBudW0ubmVnYXRpdmUpICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pc3ViKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiByZXMuZGl2LFxuICAgICAgICBtb2Q6IG1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCb3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlIGF0IHRoaXMgcG9pbnRcblxuICAgIC8vIFN0cmlwIGJvdGggbnVtYmVycyB0byBhcHByb3hpbWF0ZSBzaGlmdCB2YWx1ZVxuICAgIGlmIChudW0ubGVuZ3RoID4gdGhpcy5sZW5ndGggfHwgdGhpcy5jbXAobnVtKSA8IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IHRoaXNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVmVyeSBzaG9ydCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKG1vZGUgPT09ICdkaXYnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgICBtb2Q6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgPT09ICdtb2QnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiBudWxsLFxuICAgICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kcm4obnVtLndvcmRzWzBdKSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RybihudW0ud29yZHNbMF0pKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd29yZERpdihudW0sIG1vZGUpO1xuICB9O1xuXG4gIC8vIEZpbmQgYHRoaXNgIC8gYG51bWBcbiAgQk4ucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIGRpdiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ2RpdicsIGZhbHNlKS5kaXY7XG4gIH07XG5cbiAgLy8gRmluZCBgdGhpc2AgJSBgbnVtYFxuICBCTi5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gbW9kIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgZmFsc2UpLm1vZDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudW1vZCA9IGZ1bmN0aW9uIHVtb2QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCB0cnVlKS5tb2Q7XG4gIH07XG5cbiAgLy8gRmluZCBSb3VuZChgdGhpc2AgLyBgbnVtYClcbiAgQk4ucHJvdG90eXBlLmRpdlJvdW5kID0gZnVuY3Rpb24gZGl2Um91bmQgKG51bSkge1xuICAgIHZhciBkbSA9IHRoaXMuZGl2bW9kKG51bSk7XG5cbiAgICAvLyBGYXN0IGNhc2UgLSBleGFjdCBkaXZpc2lvblxuICAgIGlmIChkbS5tb2QuaXNaZXJvKCkpIHJldHVybiBkbS5kaXY7XG5cbiAgICB2YXIgbW9kID0gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0ubW9kLmlzdWIobnVtKSA6IGRtLm1vZDtcblxuICAgIHZhciBoYWxmID0gbnVtLnVzaHJuKDEpO1xuICAgIHZhciByMiA9IG51bS5hbmRsbigxKTtcbiAgICB2YXIgY21wID0gbW9kLmNtcChoYWxmKTtcblxuICAgIC8vIFJvdW5kIGRvd25cbiAgICBpZiAoY21wIDwgMCB8fCAocjIgPT09IDEgJiYgY21wID09PSAwKSkgcmV0dXJuIGRtLmRpdjtcblxuICAgIC8vIFJvdW5kIHVwXG4gICAgcmV0dXJuIGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLmRpdi5pc3VibigxKSA6IGRtLmRpdi5pYWRkbigxKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubW9kcm4gPSBmdW5jdGlvbiBtb2RybiAobnVtKSB7XG4gICAgdmFyIGlzTmVnTnVtID0gbnVtIDwgMDtcbiAgICBpZiAoaXNOZWdOdW0pIG51bSA9IC1udW07XG5cbiAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG4gICAgdmFyIHAgPSAoMSA8PCAyNikgJSBudW07XG5cbiAgICB2YXIgYWNjID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgYWNjID0gKHAgKiBhY2MgKyAodGhpcy53b3Jkc1tpXSB8IDApKSAlIG51bTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNOZWdOdW0gPyAtYWNjIDogYWNjO1xuICB9O1xuXG4gIC8vIFdBUk5JTkc6IERFUFJFQ0FURURcbiAgQk4ucHJvdG90eXBlLm1vZG4gPSBmdW5jdGlvbiBtb2RuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5tb2RybihudW0pO1xuICB9O1xuXG4gIC8vIEluLXBsYWNlIGRpdmlzaW9uIGJ5IG51bWJlclxuICBCTi5wcm90b3R5cGUuaWRpdm4gPSBmdW5jdGlvbiBpZGl2biAobnVtKSB7XG4gICAgdmFyIGlzTmVnTnVtID0gbnVtIDwgMDtcbiAgICBpZiAoaXNOZWdOdW0pIG51bSA9IC1udW07XG5cbiAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeSAqIDB4NDAwMDAwMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAodyAvIG51bSkgfCAwO1xuICAgICAgY2FycnkgPSB3ICUgbnVtO1xuICAgIH1cblxuICAgIHRoaXMuX3N0cmlwKCk7XG4gICAgcmV0dXJuIGlzTmVnTnVtID8gdGhpcy5pbmVnKCkgOiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5kaXZuID0gZnVuY3Rpb24gZGl2biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pZGl2bihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lZ2NkID0gZnVuY3Rpb24gZWdjZCAocCkge1xuICAgIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcbiAgICBhc3NlcnQoIXAuaXNaZXJvKCkpO1xuXG4gICAgdmFyIHggPSB0aGlzO1xuICAgIHZhciB5ID0gcC5jbG9uZSgpO1xuXG4gICAgaWYgKHgubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHggPSB4LnVtb2QocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4LmNsb25lKCk7XG4gICAgfVxuXG4gICAgLy8gQSAqIHggKyBCICogeSA9IHhcbiAgICB2YXIgQSA9IG5ldyBCTigxKTtcbiAgICB2YXIgQiA9IG5ldyBCTigwKTtcblxuICAgIC8vIEMgKiB4ICsgRCAqIHkgPSB5XG4gICAgdmFyIEMgPSBuZXcgQk4oMCk7XG4gICAgdmFyIEQgPSBuZXcgQk4oMSk7XG5cbiAgICB2YXIgZyA9IDA7XG5cbiAgICB3aGlsZSAoeC5pc0V2ZW4oKSAmJiB5LmlzRXZlbigpKSB7XG4gICAgICB4Lml1c2hybigxKTtcbiAgICAgIHkuaXVzaHJuKDEpO1xuICAgICAgKytnO1xuICAgIH1cblxuICAgIHZhciB5cCA9IHkuY2xvbmUoKTtcbiAgICB2YXIgeHAgPSB4LmNsb25lKCk7XG5cbiAgICB3aGlsZSAoIXguaXNaZXJvKCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbSA9IDE7ICh4LndvcmRzWzBdICYgaW0pID09PSAwICYmIGkgPCAyNjsgKytpLCBpbSA8PD0gMSk7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgeC5pdXNocm4oaSk7XG4gICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKEEuaXNPZGQoKSB8fCBCLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIEEuaWFkZCh5cCk7XG4gICAgICAgICAgICBCLmlzdWIoeHApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEEuaXVzaHJuKDEpO1xuICAgICAgICAgIEIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7ICh5LndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG4gICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgeS5pdXNocm4oaik7XG4gICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKEMuaXNPZGQoKSB8fCBELmlzT2RkKCkpIHtcbiAgICAgICAgICAgIEMuaWFkZCh5cCk7XG4gICAgICAgICAgICBELmlzdWIoeHApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEMuaXVzaHJuKDEpO1xuICAgICAgICAgIEQuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh4LmNtcCh5KSA+PSAwKSB7XG4gICAgICAgIHguaXN1Yih5KTtcbiAgICAgICAgQS5pc3ViKEMpO1xuICAgICAgICBCLmlzdWIoRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5LmlzdWIoeCk7XG4gICAgICAgIEMuaXN1YihBKTtcbiAgICAgICAgRC5pc3ViKEIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhOiBDLFxuICAgICAgYjogRCxcbiAgICAgIGdjZDogeS5pdXNobG4oZylcbiAgICB9O1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgcmVkdWNlZCBpbmNhcm5hdGlvbiBvZiB0aGUgYmluYXJ5IEVFQVxuICAvLyBhYm92ZSwgZGVzaWduYXRlZCB0byBpbnZlcnQgbWVtYmVycyBvZiB0aGVcbiAgLy8gX3ByaW1lXyBmaWVsZHMgRihwKSBhdCBhIG1heGltYWwgc3BlZWRcbiAgQk4ucHJvdG90eXBlLl9pbnZtcCA9IGZ1bmN0aW9uIF9pbnZtcCAocCkge1xuICAgIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcbiAgICBhc3NlcnQoIXAuaXNaZXJvKCkpO1xuXG4gICAgdmFyIGEgPSB0aGlzO1xuICAgIHZhciBiID0gcC5jbG9uZSgpO1xuXG4gICAgaWYgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGEgPSBhLnVtb2QocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBhLmNsb25lKCk7XG4gICAgfVxuXG4gICAgdmFyIHgxID0gbmV3IEJOKDEpO1xuICAgIHZhciB4MiA9IG5ldyBCTigwKTtcblxuICAgIHZhciBkZWx0YSA9IGIuY2xvbmUoKTtcblxuICAgIHdoaWxlIChhLmNtcG4oMSkgPiAwICYmIGIuY21wbigxKSA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbSA9IDE7IChhLndvcmRzWzBdICYgaW0pID09PSAwICYmIGkgPCAyNjsgKytpLCBpbSA8PD0gMSk7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgYS5pdXNocm4oaSk7XG4gICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKHgxLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIHgxLmlhZGQoZGVsdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgxLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoYi53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIGIuaXVzaHJuKGopO1xuICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgIGlmICh4Mi5pc09kZCgpKSB7XG4gICAgICAgICAgICB4Mi5pYWRkKGRlbHRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4Mi5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGEuY21wKGIpID49IDApIHtcbiAgICAgICAgYS5pc3ViKGIpO1xuICAgICAgICB4MS5pc3ViKHgyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGIuaXN1YihhKTtcbiAgICAgICAgeDIuaXN1Yih4MSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlcztcbiAgICBpZiAoYS5jbXBuKDEpID09PSAwKSB7XG4gICAgICByZXMgPSB4MTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0geDI7XG4gICAgfVxuXG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQocCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ2NkID0gZnVuY3Rpb24gZ2NkIChudW0pIHtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIG51bS5hYnMoKTtcbiAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gdGhpcy5hYnMoKTtcblxuICAgIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuICAgIHZhciBiID0gbnVtLmNsb25lKCk7XG4gICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgYi5uZWdhdGl2ZSA9IDA7XG5cbiAgICAvLyBSZW1vdmUgY29tbW9uIGZhY3RvciBvZiB0d29cbiAgICBmb3IgKHZhciBzaGlmdCA9IDA7IGEuaXNFdmVuKCkgJiYgYi5pc0V2ZW4oKTsgc2hpZnQrKykge1xuICAgICAgYS5pdXNocm4oMSk7XG4gICAgICBiLml1c2hybigxKTtcbiAgICB9XG5cbiAgICBkbyB7XG4gICAgICB3aGlsZSAoYS5pc0V2ZW4oKSkge1xuICAgICAgICBhLml1c2hybigxKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChiLmlzRXZlbigpKSB7XG4gICAgICAgIGIuaXVzaHJuKDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgciA9IGEuY21wKGIpO1xuICAgICAgaWYgKHIgPCAwKSB7XG4gICAgICAgIC8vIFN3YXAgYGFgIGFuZCBgYmAgdG8gbWFrZSBgYWAgYWx3YXlzIGJpZ2dlciB0aGFuIGBiYFxuICAgICAgICB2YXIgdCA9IGE7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBiID0gdDtcbiAgICAgIH0gZWxzZSBpZiAociA9PT0gMCB8fCBiLmNtcG4oMSkgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGEuaXN1YihiKTtcbiAgICB9IHdoaWxlICh0cnVlKTtcblxuICAgIHJldHVybiBiLml1c2hsbihzaGlmdCk7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IG51bWJlciBpbiB0aGUgZmllbGQgRihudW0pXG4gIEJOLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZWdjZChudW0pLmEudW1vZChudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4gKCkge1xuICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkICgpIHtcbiAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMTtcbiAgfTtcblxuICAvLyBBbmQgZmlyc3Qgd29yZCBhbmQgbnVtXG4gIEJOLnByb3RvdHlwZS5hbmRsbiA9IGZ1bmN0aW9uIGFuZGxuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy53b3Jkc1swXSAmIG51bTtcbiAgfTtcblxuICAvLyBJbmNyZW1lbnQgYXQgdGhlIGJpdCBwb3NpdGlvbiBpbi1saW5lXG4gIEJOLnByb3RvdHlwZS5iaW5jbiA9IGZ1bmN0aW9uIGJpbmNuIChiaXQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicpO1xuICAgIHZhciByID0gYml0ICUgMjY7XG4gICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgICB2YXIgcSA9IDEgPDwgcjtcblxuICAgIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICAgIHRoaXMuX2V4cGFuZChzICsgMSk7XG4gICAgICB0aGlzLndvcmRzW3NdIHw9IHE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgYml0IGFuZCBwcm9wYWdhdGUsIGlmIG5lZWRlZFxuICAgIHZhciBjYXJyeSA9IHE7XG4gICAgZm9yICh2YXIgaSA9IHM7IGNhcnJ5ICE9PSAwICYmIGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdyArPSBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+Pj4gMjY7XG4gICAgICB3ICY9IDB4M2ZmZmZmZjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB3O1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8gKCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jbXBuID0gZnVuY3Rpb24gY21wbiAobnVtKSB7XG4gICAgdmFyIG5lZ2F0aXZlID0gbnVtIDwgMDtcblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmICFuZWdhdGl2ZSkgcmV0dXJuIC0xO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG5lZ2F0aXZlKSByZXR1cm4gMTtcblxuICAgIHRoaXMuX3N0cmlwKCk7XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICBudW0gPSAtbnVtO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZiwgJ051bWJlciBpcyB0b28gYmlnJyk7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1swXSB8IDA7XG4gICAgICByZXMgPSB3ID09PSBudW0gPyAwIDogdyA8IG51bSA/IC0xIDogMTtcbiAgICB9XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIENvbXBhcmUgdHdvIG51bWJlcnMgYW5kIHJldHVybjpcbiAgLy8gMSAtIGlmIGB0aGlzYCA+IGBudW1gXG4gIC8vIDAgLSBpZiBgdGhpc2AgPT0gYG51bWBcbiAgLy8gLTEgLSBpZiBgdGhpc2AgPCBgbnVtYFxuICBCTi5wcm90b3R5cGUuY21wID0gZnVuY3Rpb24gY21wIChudW0pIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHJldHVybiAxO1xuXG4gICAgdmFyIHJlcyA9IHRoaXMudWNtcChudW0pO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBVbnNpZ25lZCBjb21wYXJpc29uXG4gIEJOLnByb3RvdHlwZS51Y21wID0gZnVuY3Rpb24gdWNtcCAobnVtKSB7XG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgaGF2ZSB0aGUgc2FtZSBzaWduXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIDE7XG4gICAgaWYgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkgcmV0dXJuIC0xO1xuXG4gICAgdmFyIHJlcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB2YXIgYiA9IG51bS53b3Jkc1tpXSB8IDA7XG5cbiAgICAgIGlmIChhID09PSBiKSBjb250aW51ZTtcbiAgICAgIGlmIChhIDwgYikge1xuICAgICAgICByZXMgPSAtMTtcbiAgICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmVzID0gMTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndG4gPSBmdW5jdGlvbiBndG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiBndCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZW4gPSBmdW5jdGlvbiBndGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RlID0gZnVuY3Rpb24gZ3RlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA+PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdG4gPSBmdW5jdGlvbiBsdG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gbHQgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAtMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlbiA9IGZ1bmN0aW9uIGx0ZW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdGUgPSBmdW5jdGlvbiBsdGUgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pIDw9IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVxbiA9IGZ1bmN0aW9uIGVxbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMDtcbiAgfTtcblxuICAvL1xuICAvLyBBIHJlZHVjZSBjb250ZXh0LCBjb3VsZCBiZSB1c2luZyBtb250Z29tZXJ5IG9yIHNvbWV0aGluZyBiZXR0ZXIsIGRlcGVuZGluZ1xuICAvLyBvbiB0aGUgYG1gIGl0c2VsZi5cbiAgLy9cbiAgQk4ucmVkID0gZnVuY3Rpb24gcmVkIChudW0pIHtcbiAgICByZXR1cm4gbmV3IFJlZChudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1JlZCA9IGZ1bmN0aW9uIHRvUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICByZXR1cm4gY3R4LmNvbnZlcnRUbyh0aGlzKS5fZm9yY2VSZWQoY3R4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVJlZCA9IGZ1bmN0aW9uIGZyb21SZWQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ2Zyb21SZWQgd29ya3Mgb25seSB3aXRoIG51bWJlcnMgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuY29udmVydEZyb20odGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9mb3JjZVJlZCA9IGZ1bmN0aW9uIF9mb3JjZVJlZCAoY3R4KSB7XG4gICAgdGhpcy5yZWQgPSBjdHg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZvcmNlUmVkID0gZnVuY3Rpb24gZm9yY2VSZWQgKGN0eCkge1xuICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEFkZCA9IGZ1bmN0aW9uIHJlZEFkZCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5hZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSUFkZCA9IGZ1bmN0aW9uIHJlZElBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlhZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3ViID0gZnVuY3Rpb24gcmVkU3ViIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJU3ViID0gZnVuY3Rpb24gcmVkSVN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaXN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTaGwgPSBmdW5jdGlvbiByZWRTaGwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNobCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc2hsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZE11bCA9IGZ1bmN0aW9uIHJlZE11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm11bCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJTXVsID0gZnVuY3Rpb24gcmVkSU11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmltdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3FyID0gZnVuY3Rpb24gcmVkU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVNxciA9IGZ1bmN0aW9uIHJlZElTcXIgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzcXIodGhpcyk7XG4gIH07XG5cbiAgLy8gU3F1YXJlIHJvb3Qgb3ZlciBwXG4gIEJOLnByb3RvdHlwZS5yZWRTcXJ0ID0gZnVuY3Rpb24gcmVkU3FydCAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FydCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3FydCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSW52bSA9IGZ1bmN0aW9uIHJlZEludm0gKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEludm0gd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmludm0odGhpcyk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYCAlIGByZWQgbW9kdWxvYFxuICBCTi5wcm90b3R5cGUucmVkTmVnID0gZnVuY3Rpb24gcmVkTmVnICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWROZWcgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm5lZyh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkUG93ID0gZnVuY3Rpb24gcmVkUG93IChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQgJiYgIW51bS5yZWQsICdyZWRQb3cobm9ybWFsTnVtKScpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5wb3codGhpcywgbnVtKTtcbiAgfTtcblxuICAvLyBQcmltZSBudW1iZXJzIHdpdGggZWZmaWNpZW50IHJlZHVjdGlvblxuICB2YXIgcHJpbWVzID0ge1xuICAgIGsyNTY6IG51bGwsXG4gICAgcDIyNDogbnVsbCxcbiAgICBwMTkyOiBudWxsLFxuICAgIHAyNTUxOTogbnVsbFxuICB9O1xuXG4gIC8vIFBzZXVkby1NZXJzZW5uZSBwcmltZVxuICBmdW5jdGlvbiBNUHJpbWUgKG5hbWUsIHApIHtcbiAgICAvLyBQID0gMiBeIE4gLSBLXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnAgPSBuZXcgQk4ocCwgMTYpO1xuICAgIHRoaXMubiA9IHRoaXMucC5iaXRMZW5ndGgoKTtcbiAgICB0aGlzLmsgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMubikuaXN1Yih0aGlzLnApO1xuXG4gICAgdGhpcy50bXAgPSB0aGlzLl90bXAoKTtcbiAgfVxuXG4gIE1QcmltZS5wcm90b3R5cGUuX3RtcCA9IGZ1bmN0aW9uIF90bXAgKCkge1xuICAgIHZhciB0bXAgPSBuZXcgQk4obnVsbCk7XG4gICAgdG1wLndvcmRzID0gbmV3IEFycmF5KE1hdGguY2VpbCh0aGlzLm4gLyAxMykpO1xuICAgIHJldHVybiB0bXA7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5pcmVkdWNlID0gZnVuY3Rpb24gaXJlZHVjZSAobnVtKSB7XG4gICAgLy8gQXNzdW1lcyB0aGF0IGBudW1gIGlzIGxlc3MgdGhhbiBgUF4yYFxuICAgIC8vIG51bSA9IEhJICogKDIgXiBOIC0gSykgKyBISSAqIEsgKyBMTyA9IEhJICogSyArIExPIChtb2QgUClcbiAgICB2YXIgciA9IG51bTtcbiAgICB2YXIgcmxlbjtcblxuICAgIGRvIHtcbiAgICAgIHRoaXMuc3BsaXQociwgdGhpcy50bXApO1xuICAgICAgciA9IHRoaXMuaW11bEsocik7XG4gICAgICByID0gci5pYWRkKHRoaXMudG1wKTtcbiAgICAgIHJsZW4gPSByLmJpdExlbmd0aCgpO1xuICAgIH0gd2hpbGUgKHJsZW4gPiB0aGlzLm4pO1xuXG4gICAgdmFyIGNtcCA9IHJsZW4gPCB0aGlzLm4gPyAtMSA6IHIudWNtcCh0aGlzLnApO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHIud29yZHNbMF0gPSAwO1xuICAgICAgci5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgci5pc3ViKHRoaXMucCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyLnN0cmlwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gciBpcyBhIEJOIHY0IGluc3RhbmNlXG4gICAgICAgIHIuc3RyaXAoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHIgaXMgYSBCTiB2NSBpbnN0YW5jZVxuICAgICAgICByLl9zdHJpcCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dCkge1xuICAgIGlucHV0Lml1c2hybih0aGlzLm4sIDAsIG91dCk7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICByZXR1cm4gbnVtLmltdWwodGhpcy5rKTtcbiAgfTtcblxuICBmdW5jdGlvbiBLMjU2ICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAnazI1NicsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnKTtcbiAgfVxuICBpbmhlcml0cyhLMjU2LCBNUHJpbWUpO1xuXG4gIEsyNTYucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXRwdXQpIHtcbiAgICAvLyAyNTYgPSA5ICogMjYgKyAyMlxuICAgIHZhciBtYXNrID0gMHgzZmZmZmY7XG5cbiAgICB2YXIgb3V0TGVuID0gTWF0aC5taW4oaW5wdXQubGVuZ3RoLCA5KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dExlbjsgaSsrKSB7XG4gICAgICBvdXRwdXQud29yZHNbaV0gPSBpbnB1dC53b3Jkc1tpXTtcbiAgICB9XG4gICAgb3V0cHV0Lmxlbmd0aCA9IG91dExlbjtcblxuICAgIGlmIChpbnB1dC5sZW5ndGggPD0gOSkge1xuICAgICAgaW5wdXQud29yZHNbMF0gPSAwO1xuICAgICAgaW5wdXQubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTaGlmdCBieSA5IGxpbWJzXG4gICAgdmFyIHByZXYgPSBpbnB1dC53b3Jkc1s5XTtcbiAgICBvdXRwdXQud29yZHNbb3V0cHV0Lmxlbmd0aCsrXSA9IHByZXYgJiBtYXNrO1xuXG4gICAgZm9yIChpID0gMTA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5leHQgPSBpbnB1dC53b3Jkc1tpXSB8IDA7XG4gICAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gKChuZXh0ICYgbWFzaykgPDwgNCkgfCAocHJldiA+Pj4gMjIpO1xuICAgICAgcHJldiA9IG5leHQ7XG4gICAgfVxuICAgIHByZXYgPj4+PSAyMjtcbiAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gcHJldjtcbiAgICBpZiAocHJldiA9PT0gMCAmJiBpbnB1dC5sZW5ndGggPiAxMCkge1xuICAgICAgaW5wdXQubGVuZ3RoIC09IDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gOTtcbiAgICB9XG4gIH07XG5cbiAgSzI1Ni5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgLy8gSyA9IDB4MTAwMDAwM2QxID0gWyAweDQwLCAweDNkMSBdXG4gICAgbnVtLndvcmRzW251bS5sZW5ndGhdID0gMDtcbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aCArIDFdID0gMDtcbiAgICBudW0ubGVuZ3RoICs9IDI7XG5cbiAgICAvLyBib3VuZGVkIGF0OiAweDQwICogMHgzZmZmZmZmICsgMHgzZDAgPSAweDEwMDAwMDM5MFxuICAgIHZhciBsbyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gbnVtLndvcmRzW2ldIHwgMDtcbiAgICAgIGxvICs9IHcgKiAweDNkMTtcbiAgICAgIG51bS53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgbG8gPSB3ICogMHg0MCArICgobG8gLyAweDQwMDAwMDApIHwgMCk7XG4gICAgfVxuXG4gICAgLy8gRmFzdCBsZW5ndGggcmVkdWN0aW9uXG4gICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgIG51bS5sZW5ndGgtLTtcbiAgICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICAgIG51bS5sZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICBmdW5jdGlvbiBQMjI0ICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncDIyNCcsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDEnKTtcbiAgfVxuICBpbmhlcml0cyhQMjI0LCBNUHJpbWUpO1xuXG4gIGZ1bmN0aW9uIFAxOTIgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMTkyJyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZicpO1xuICB9XG4gIGluaGVyaXRzKFAxOTIsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDI1NTE5ICgpIHtcbiAgICAvLyAyIF4gMjU1IC0gMTlcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAnMjU1MTknLFxuICAgICAgJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnKTtcbiAgfVxuICBpbmhlcml0cyhQMjU1MTksIE1QcmltZSk7XG5cbiAgUDI1NTE5LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxM1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoaSA9IChudW0ud29yZHNbaV0gfCAwKSAqIDB4MTMgKyBjYXJyeTtcbiAgICAgIHZhciBsbyA9IGhpICYgMHgzZmZmZmZmO1xuICAgICAgaGkgPj4+PSAyNjtcblxuICAgICAgbnVtLndvcmRzW2ldID0gbG87XG4gICAgICBjYXJyeSA9IGhpO1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoKytdID0gY2Fycnk7XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgLy8gRXhwb3J0ZWQgbW9zdGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB1c2UgcGxhaW4gbmFtZSBpbnN0ZWFkXG4gIEJOLl9wcmltZSA9IGZ1bmN0aW9uIHByaW1lIChuYW1lKSB7XG4gICAgLy8gQ2FjaGVkIHZlcnNpb24gb2YgcHJpbWVcbiAgICBpZiAocHJpbWVzW25hbWVdKSByZXR1cm4gcHJpbWVzW25hbWVdO1xuXG4gICAgdmFyIHByaW1lO1xuICAgIGlmIChuYW1lID09PSAnazI1NicpIHtcbiAgICAgIHByaW1lID0gbmV3IEsyNTYoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjI0Jykge1xuICAgICAgcHJpbWUgPSBuZXcgUDIyNCgpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AxOTInKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMTkyKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDI1NTE5Jykge1xuICAgICAgcHJpbWUgPSBuZXcgUDI1NTE5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwcmltZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHByaW1lc1tuYW1lXSA9IHByaW1lO1xuXG4gICAgcmV0dXJuIHByaW1lO1xuICB9O1xuXG4gIC8vXG4gIC8vIEJhc2UgcmVkdWN0aW9uIGVuZ2luZVxuICAvL1xuICBmdW5jdGlvbiBSZWQgKG0pIHtcbiAgICBpZiAodHlwZW9mIG0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgcHJpbWUgPSBCTi5fcHJpbWUobSk7XG4gICAgICB0aGlzLm0gPSBwcmltZS5wO1xuICAgICAgdGhpcy5wcmltZSA9IHByaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQobS5ndG4oMSksICdtb2R1bHVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIDEnKTtcbiAgICAgIHRoaXMubSA9IG07XG4gICAgICB0aGlzLnByaW1lID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBSZWQucHJvdG90eXBlLl92ZXJpZnkxID0gZnVuY3Rpb24gX3ZlcmlmeTEgKGEpIHtcbiAgICBhc3NlcnQoYS5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgYXNzZXJ0KGEucmVkLCAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTIgPSBmdW5jdGlvbiBfdmVyaWZ5MiAoYSwgYikge1xuICAgIGFzc2VydCgoYS5uZWdhdGl2ZSB8IGIubmVnYXRpdmUpID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQgJiYgYS5yZWQgPT09IGIucmVkLFxuICAgICAgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmltb2QgPSBmdW5jdGlvbiBpbW9kIChhKSB7XG4gICAgaWYgKHRoaXMucHJpbWUpIHJldHVybiB0aGlzLnByaW1lLmlyZWR1Y2UoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuXG4gICAgbW92ZShhLCBhLnVtb2QodGhpcy5tKS5fZm9yY2VSZWQodGhpcykpO1xuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnIChhKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiBhLmNsb25lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubS5zdWIoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmFkZChiKTtcbiAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuaWFkZChiKTtcbiAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuc3ViKGIpO1xuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuaXN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc2hsID0gZnVuY3Rpb24gc2hsIChhLCBudW0pIHtcbiAgICB0aGlzLl92ZXJpZnkxKGEpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS51c2hsbihudW0pKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEuaW11bChiKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS5tdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKGEpIHtcbiAgICByZXR1cm4gdGhpcy5pbXVsKGEsIGEuY2xvbmUoKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKGEpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwoYSwgYSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gc3FydCAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIG1vZDMgPSB0aGlzLm0uYW5kbG4oMyk7XG4gICAgYXNzZXJ0KG1vZDMgJSAyID09PSAxKTtcblxuICAgIC8vIEZhc3QgY2FzZVxuICAgIGlmIChtb2QzID09PSAzKSB7XG4gICAgICB2YXIgcG93ID0gdGhpcy5tLmFkZChuZXcgQk4oMSkpLml1c2hybigyKTtcbiAgICAgIHJldHVybiB0aGlzLnBvdyhhLCBwb3cpO1xuICAgIH1cblxuICAgIC8vIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobSAoVG90YWxseSB1bm9wdGltaXplZCBhbmQgc2xvdylcbiAgICAvL1xuICAgIC8vIEZpbmQgUSBhbmQgUywgdGhhdCBRICogMiBeIFMgPSAoUCAtIDEpXG4gICAgdmFyIHEgPSB0aGlzLm0uc3VibigxKTtcbiAgICB2YXIgcyA9IDA7XG4gICAgd2hpbGUgKCFxLmlzWmVybygpICYmIHEuYW5kbG4oMSkgPT09IDApIHtcbiAgICAgIHMrKztcbiAgICAgIHEuaXVzaHJuKDEpO1xuICAgIH1cbiAgICBhc3NlcnQoIXEuaXNaZXJvKCkpO1xuXG4gICAgdmFyIG9uZSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICB2YXIgbk9uZSA9IG9uZS5yZWROZWcoKTtcblxuICAgIC8vIEZpbmQgcXVhZHJhdGljIG5vbi1yZXNpZHVlXG4gICAgLy8gTk9URTogTWF4IGlzIHN1Y2ggYmVjYXVzZSBvZiBnZW5lcmFsaXplZCBSaWVtYW5uIGh5cG90aGVzaXMuXG4gICAgdmFyIGxwb3cgPSB0aGlzLm0uc3VibigxKS5pdXNocm4oMSk7XG4gICAgdmFyIHogPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgeiA9IG5ldyBCTigyICogeiAqIHopLnRvUmVkKHRoaXMpO1xuXG4gICAgd2hpbGUgKHRoaXMucG93KHosIGxwb3cpLmNtcChuT25lKSAhPT0gMCkge1xuICAgICAgei5yZWRJQWRkKG5PbmUpO1xuICAgIH1cblxuICAgIHZhciBjID0gdGhpcy5wb3coeiwgcSk7XG4gICAgdmFyIHIgPSB0aGlzLnBvdyhhLCBxLmFkZG4oMSkuaXVzaHJuKDEpKTtcbiAgICB2YXIgdCA9IHRoaXMucG93KGEsIHEpO1xuICAgIHZhciBtID0gcztcbiAgICB3aGlsZSAodC5jbXAob25lKSAhPT0gMCkge1xuICAgICAgdmFyIHRtcCA9IHQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgdG1wLmNtcChvbmUpICE9PSAwOyBpKyspIHtcbiAgICAgICAgdG1wID0gdG1wLnJlZFNxcigpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KGkgPCBtKTtcbiAgICAgIHZhciBiID0gdGhpcy5wb3coYywgbmV3IEJOKDEpLml1c2hsbihtIC0gaSAtIDEpKTtcblxuICAgICAgciA9IHIucmVkTXVsKGIpO1xuICAgICAgYyA9IGIucmVkU3FyKCk7XG4gICAgICB0ID0gdC5yZWRNdWwoYyk7XG4gICAgICBtID0gaTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgdmFyIGludiA9IGEuX2ludm1wKHRoaXMubSk7XG4gICAgaWYgKGludi5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgaW52Lm5lZ2F0aXZlID0gMDtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KS5yZWROZWcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpO1xuICAgIH1cbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAoYSwgbnVtKSB7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICBpZiAobnVtLmNtcG4oMSkgPT09IDApIHJldHVybiBhLmNsb25lKCk7XG5cbiAgICB2YXIgd2luZG93U2l6ZSA9IDQ7XG4gICAgdmFyIHduZCA9IG5ldyBBcnJheSgxIDw8IHdpbmRvd1NpemUpO1xuICAgIHduZFswXSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICB3bmRbMV0gPSBhO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgd25kLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3bmRbaV0gPSB0aGlzLm11bCh3bmRbaSAtIDFdLCBhKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzID0gd25kWzBdO1xuICAgIHZhciBjdXJyZW50ID0gMDtcbiAgICB2YXIgY3VycmVudExlbiA9IDA7XG4gICAgdmFyIHN0YXJ0ID0gbnVtLmJpdExlbmd0aCgpICUgMjY7XG4gICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICBzdGFydCA9IDI2O1xuICAgIH1cblxuICAgIGZvciAoaSA9IG51bS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSBudW0ud29yZHNbaV07XG4gICAgICBmb3IgKHZhciBqID0gc3RhcnQgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICB2YXIgYml0ID0gKHdvcmQgPj4gaikgJiAxO1xuICAgICAgICBpZiAocmVzICE9PSB3bmRbMF0pIHtcbiAgICAgICAgICByZXMgPSB0aGlzLnNxcihyZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJpdCA9PT0gMCAmJiBjdXJyZW50ID09PSAwKSB7XG4gICAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50IDw8PSAxO1xuICAgICAgICBjdXJyZW50IHw9IGJpdDtcbiAgICAgICAgY3VycmVudExlbisrO1xuICAgICAgICBpZiAoY3VycmVudExlbiAhPT0gd2luZG93U2l6ZSAmJiAoaSAhPT0gMCB8fCBqICE9PSAwKSkgY29udGludWU7XG5cbiAgICAgICAgcmVzID0gdGhpcy5tdWwocmVzLCB3bmRbY3VycmVudF0pO1xuICAgICAgICBjdXJyZW50TGVuID0gMDtcbiAgICAgICAgY3VycmVudCA9IDA7XG4gICAgICB9XG4gICAgICBzdGFydCA9IDI2O1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHZhciByID0gbnVtLnVtb2QodGhpcy5tKTtcblxuICAgIHJldHVybiByID09PSBudW0gPyByLmNsb25lKCkgOiByO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG4gICAgdmFyIHJlcyA9IG51bS5jbG9uZSgpO1xuICAgIHJlcy5yZWQgPSBudWxsO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy9cbiAgLy8gTW9udGdvbWVyeSBtZXRob2QgZW5naW5lXG4gIC8vXG5cbiAgQk4ubW9udCA9IGZ1bmN0aW9uIG1vbnQgKG51bSkge1xuICAgIHJldHVybiBuZXcgTW9udChudW0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIE1vbnQgKG0pIHtcbiAgICBSZWQuY2FsbCh0aGlzLCBtKTtcblxuICAgIHRoaXMuc2hpZnQgPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgaWYgKHRoaXMuc2hpZnQgJSAyNiAhPT0gMCkge1xuICAgICAgdGhpcy5zaGlmdCArPSAyNiAtICh0aGlzLnNoaWZ0ICUgMjYpO1xuICAgIH1cblxuICAgIHRoaXMuciA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5zaGlmdCk7XG4gICAgdGhpcy5yMiA9IHRoaXMuaW1vZCh0aGlzLnIuc3FyKCkpO1xuICAgIHRoaXMucmludiA9IHRoaXMuci5faW52bXAodGhpcy5tKTtcblxuICAgIHRoaXMubWludiA9IHRoaXMucmludi5tdWwodGhpcy5yKS5pc3VibigxKS5kaXYodGhpcy5tKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLm1pbnYudW1vZCh0aGlzLnIpO1xuICAgIHRoaXMubWludiA9IHRoaXMuci5zdWIodGhpcy5taW52KTtcbiAgfVxuICBpbmhlcml0cyhNb250LCBSZWQpO1xuXG4gIE1vbnQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChudW0udXNobG4odGhpcy5zaGlmdCkpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByID0gdGhpcy5pbW9kKG51bS5tdWwodGhpcy5yaW52KSk7XG4gICAgci5yZWQgPSBudWxsO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkge1xuICAgICAgYS53b3Jkc1swXSA9IDA7XG4gICAgICBhLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IGEuaW11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcblxuICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigwKS5fZm9yY2VSZWQodGhpcyk7XG5cbiAgICB2YXIgdCA9IGEubXVsKGIpO1xuICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuICAgIHZhciByZXMgPSB1O1xuICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcbiAgICAvLyAoQVIpXi0xICogUl4yID0gKEFeLTEgKiBSXi0xKSAqIFJeMiA9IEFeLTEgKiBSXG4gICAgdmFyIHJlcyA9IHRoaXMuaW1vZChhLl9pbnZtcCh0aGlzLm0pLm11bCh0aGlzLnIyKSk7XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG59KSh0eXBlb2YgbW9kdWxlID09PSAndW5kZWZpbmVkJyB8fCBtb2R1bGUsIHRoaXMpO1xuIiwiLyohIHNhZmUtYnVmZmVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsImNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJylcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cy8nKVxuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTYWZlRXZlbnRFbWl0dGVyXG5cblxuZnVuY3Rpb24gU2FmZUV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcylcbn1cblxudXRpbC5pbmhlcml0cyhTYWZlRXZlbnRFbWl0dGVyLCBFdmVudEVtaXR0ZXIpXG5cblNhZmVFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAvLyBjb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vR296YWxhL2V2ZW50cy9ibG9iL21hc3Rlci9ldmVudHMuanNcbiAgLy8gbW9kaWZpZWQgbGluZXMgYXJlIGNvbW1lbnRlZCB3aXRoIFwiZWRpdGVkOlwiXG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBlZGl0ZWQ6IHVzaW5nIHNhZmVBcHBseVxuICAgIHNhZmVBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgLy8gZWRpdGVkOiB1c2luZyBzYWZlQXBwbHlcbiAgICAgIHNhZmVBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHNhZmVBcHBseShoYW5kbGVyLCBjb250ZXh0LCBhcmdzKSB7XG4gIHRyeSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIGNvbnRleHQsIGFyZ3MpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIHRocm93IGVycm9yIGFmdGVyIHRpbWVvdXQgc28gYXMgbm90IHRvIGludGVydXB0IHRoZSBzdGFja1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJykocmVxdWlyZSgnLi9saWIvZWxsaXB0aWMnKSlcbiIsImNvbnN0IEVDID0gcmVxdWlyZSgnZWxsaXB0aWMnKS5lY1xuXG5jb25zdCBlYyA9IG5ldyBFQygnc2VjcDI1NmsxJylcbmNvbnN0IGVjcGFyYW1zID0gZWMuY3VydmVcblxuLy8gSGFjaywgd2UgY2FuIG5vdCB1c2UgYm4uanNANSwgd2hpbGUgZWxsaXB0aWMgdXNlcyBibi5qc0A0XG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvZWxsaXB0aWMvaXNzdWVzLzE5MSNpc3N1ZWNvbW1lbnQtNTY5ODg4NzU4XG5jb25zdCBCTiA9IGVjcGFyYW1zLm4uY29uc3RydWN0b3JcblxuZnVuY3Rpb24gbG9hZENvbXByZXNzZWRQdWJsaWNLZXkgKGZpcnN0LCB4YnVmKSB7XG4gIGxldCB4ID0gbmV3IEJOKHhidWYpXG5cbiAgLy8gb3ZlcmZsb3dcbiAgaWYgKHguY21wKGVjcGFyYW1zLnApID49IDApIHJldHVybiBudWxsXG4gIHggPSB4LnRvUmVkKGVjcGFyYW1zLnJlZClcblxuICAvLyBjb21wdXRlIGNvcnJlc3BvbmRpbmcgWVxuICBsZXQgeSA9IHgucmVkU3FyKCkucmVkSU11bCh4KS5yZWRJQWRkKGVjcGFyYW1zLmIpLnJlZFNxcnQoKVxuICBpZiAoKGZpcnN0ID09PSAweDAzKSAhPT0geS5pc09kZCgpKSB5ID0geS5yZWROZWcoKVxuXG4gIHJldHVybiBlYy5rZXlQYWlyKHsgcHViOiB7IHg6IHgsIHk6IHkgfSB9KVxufVxuXG5mdW5jdGlvbiBsb2FkVW5jb21wcmVzc2VkUHVibGljS2V5IChmaXJzdCwgeGJ1ZiwgeWJ1Zikge1xuICBsZXQgeCA9IG5ldyBCTih4YnVmKVxuICBsZXQgeSA9IG5ldyBCTih5YnVmKVxuXG4gIC8vIG92ZXJmbG93XG4gIGlmICh4LmNtcChlY3BhcmFtcy5wKSA+PSAwIHx8IHkuY21wKGVjcGFyYW1zLnApID49IDApIHJldHVybiBudWxsXG5cbiAgeCA9IHgudG9SZWQoZWNwYXJhbXMucmVkKVxuICB5ID0geS50b1JlZChlY3BhcmFtcy5yZWQpXG5cbiAgLy8gaXMgb2RkIGZsYWdcbiAgaWYgKChmaXJzdCA9PT0gMHgwNiB8fCBmaXJzdCA9PT0gMHgwNykgJiYgeS5pc09kZCgpICE9PSAoZmlyc3QgPT09IDB4MDcpKSByZXR1cm4gbnVsbFxuXG4gIC8vIHgqeCp4ICsgYiA9IHkqeVxuICBjb25zdCB4MyA9IHgucmVkU3FyKCkucmVkSU11bCh4KVxuICBpZiAoIXkucmVkU3FyKCkucmVkSVN1Yih4My5yZWRJQWRkKGVjcGFyYW1zLmIpKS5pc1plcm8oKSkgcmV0dXJuIG51bGxcblxuICByZXR1cm4gZWMua2V5UGFpcih7IHB1YjogeyB4OiB4LCB5OiB5IH0gfSlcbn1cblxuZnVuY3Rpb24gbG9hZFB1YmxpY0tleSAocHVia2V5KSB7XG4gIC8vIGxlbmd0aCBzaG91bGQgYmUgdmFsaWRhdGVkIGluIGludGVyZmFjZVxuICBjb25zdCBmaXJzdCA9IHB1YmtleVswXVxuICBzd2l0Y2ggKGZpcnN0KSB7XG4gICAgY2FzZSAweDAyOlxuICAgIGNhc2UgMHgwMzpcbiAgICAgIGlmIChwdWJrZXkubGVuZ3RoICE9PSAzMykgcmV0dXJuIG51bGxcbiAgICAgIHJldHVybiBsb2FkQ29tcHJlc3NlZFB1YmxpY0tleShmaXJzdCwgcHVia2V5LnN1YmFycmF5KDEsIDMzKSlcbiAgICBjYXNlIDB4MDQ6XG4gICAgY2FzZSAweDA2OlxuICAgIGNhc2UgMHgwNzpcbiAgICAgIGlmIChwdWJrZXkubGVuZ3RoICE9PSA2NSkgcmV0dXJuIG51bGxcbiAgICAgIHJldHVybiBsb2FkVW5jb21wcmVzc2VkUHVibGljS2V5KGZpcnN0LCBwdWJrZXkuc3ViYXJyYXkoMSwgMzMpLCBwdWJrZXkuc3ViYXJyYXkoMzMsIDY1KSlcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5mdW5jdGlvbiBzYXZlUHVibGljS2V5IChvdXRwdXQsIHBvaW50KSB7XG4gIGNvbnN0IHB1YmtleSA9IHBvaW50LmVuY29kZShudWxsLCBvdXRwdXQubGVuZ3RoID09PSAzMylcbiAgLy8gTG9vcCBzaG91bGQgYmUgZmFzdGVyIGJlY2F1c2Ugd2UgZG8gbm90IG5lZWQgY3JlYXRlIGV4dHJhIFVpbnQ4QXJyYXlcbiAgLy8gb3V0cHV0LnNldChuZXcgVWludDhBcnJheShwdWJrZXkpKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7ICsraSkgb3V0cHV0W2ldID0gcHVia2V5W2ldXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb250ZXh0UmFuZG9taXplICgpIHtcbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHByaXZhdGVLZXlWZXJpZnkgKHNlY2tleSkge1xuICAgIGNvbnN0IGJuID0gbmV3IEJOKHNlY2tleSlcbiAgICByZXR1cm4gYm4uY21wKGVjcGFyYW1zLm4pIDwgMCAmJiAhYm4uaXNaZXJvKCkgPyAwIDogMVxuICB9LFxuXG4gIHByaXZhdGVLZXlOZWdhdGUgKHNlY2tleSkge1xuICAgIGNvbnN0IGJuID0gbmV3IEJOKHNlY2tleSlcbiAgICBjb25zdCBuZWdhdGUgPSBlY3BhcmFtcy5uLnN1YihibikudW1vZChlY3BhcmFtcy5uKS50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMilcbiAgICBzZWNrZXkuc2V0KG5lZ2F0ZSlcbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHByaXZhdGVLZXlUd2Vha0FkZCAoc2Vja2V5LCB0d2Vhaykge1xuICAgIGNvbnN0IGJuID0gbmV3IEJOKHR3ZWFrKVxuICAgIGlmIChibi5jbXAoZWNwYXJhbXMubikgPj0gMCkgcmV0dXJuIDFcblxuICAgIGJuLmlhZGQobmV3IEJOKHNlY2tleSkpXG4gICAgaWYgKGJuLmNtcChlY3BhcmFtcy5uKSA+PSAwKSBibi5pc3ViKGVjcGFyYW1zLm4pXG4gICAgaWYgKGJuLmlzWmVybygpKSByZXR1cm4gMVxuXG4gICAgY29uc3QgdHdlYWtlZCA9IGJuLnRvQXJyYXlMaWtlKFVpbnQ4QXJyYXksICdiZScsIDMyKVxuICAgIHNlY2tleS5zZXQodHdlYWtlZClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHJpdmF0ZUtleVR3ZWFrTXVsIChzZWNrZXksIHR3ZWFrKSB7XG4gICAgbGV0IGJuID0gbmV3IEJOKHR3ZWFrKVxuICAgIGlmIChibi5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBibi5pc1plcm8oKSkgcmV0dXJuIDFcblxuICAgIGJuLmltdWwobmV3IEJOKHNlY2tleSkpXG4gICAgaWYgKGJuLmNtcChlY3BhcmFtcy5uKSA+PSAwKSBibiA9IGJuLnVtb2QoZWNwYXJhbXMubilcblxuICAgIGNvbnN0IHR3ZWFrZWQgPSBibi50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMilcbiAgICBzZWNrZXkuc2V0KHR3ZWFrZWQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHB1YmxpY0tleVZlcmlmeSAocHVia2V5KSB7XG4gICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KVxuICAgIHJldHVybiBwYWlyID09PSBudWxsID8gMSA6IDBcbiAgfSxcblxuICBwdWJsaWNLZXlDcmVhdGUgKG91dHB1dCwgc2Vja2V5KSB7XG4gICAgY29uc3QgYm4gPSBuZXcgQk4oc2Vja2V5KVxuICAgIGlmIChibi5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBibi5pc1plcm8oKSkgcmV0dXJuIDFcblxuICAgIGNvbnN0IHBvaW50ID0gZWMua2V5RnJvbVByaXZhdGUoc2Vja2V5KS5nZXRQdWJsaWMoKVxuICAgIHNhdmVQdWJsaWNLZXkob3V0cHV0LCBwb2ludClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHVibGljS2V5Q29udmVydCAob3V0cHV0LCBwdWJrZXkpIHtcbiAgICBjb25zdCBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJrZXkpXG4gICAgaWYgKHBhaXIgPT09IG51bGwpIHJldHVybiAxXG5cbiAgICBjb25zdCBwb2ludCA9IHBhaXIuZ2V0UHVibGljKClcbiAgICBzYXZlUHVibGljS2V5KG91dHB1dCwgcG9pbnQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHB1YmxpY0tleU5lZ2F0ZSAob3V0cHV0LCBwdWJrZXkpIHtcbiAgICBjb25zdCBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJrZXkpXG4gICAgaWYgKHBhaXIgPT09IG51bGwpIHJldHVybiAxXG5cbiAgICBjb25zdCBwb2ludCA9IHBhaXIuZ2V0UHVibGljKClcbiAgICBwb2ludC55ID0gcG9pbnQueS5yZWROZWcoKVxuICAgIHNhdmVQdWJsaWNLZXkob3V0cHV0LCBwb2ludClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHVibGljS2V5Q29tYmluZSAob3V0cHV0LCBwdWJrZXlzKSB7XG4gICAgY29uc3QgcGFpcnMgPSBuZXcgQXJyYXkocHVia2V5cy5sZW5ndGgpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwdWJrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBwYWlyc1tpXSA9IGxvYWRQdWJsaWNLZXkocHVia2V5c1tpXSlcbiAgICAgIGlmIChwYWlyc1tpXSA9PT0gbnVsbCkgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBsZXQgcG9pbnQgPSBwYWlyc1swXS5nZXRQdWJsaWMoKVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFpcnMubGVuZ3RoOyArK2kpIHBvaW50ID0gcG9pbnQuYWRkKHBhaXJzW2ldLnB1YilcbiAgICBpZiAocG9pbnQuaXNJbmZpbml0eSgpKSByZXR1cm4gMlxuXG4gICAgc2F2ZVB1YmxpY0tleShvdXRwdXQsIHBvaW50KVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwdWJsaWNLZXlUd2Vha0FkZCAob3V0cHV0LCBwdWJrZXksIHR3ZWFrKSB7XG4gICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KVxuICAgIGlmIChwYWlyID09PSBudWxsKSByZXR1cm4gMVxuXG4gICAgdHdlYWsgPSBuZXcgQk4odHdlYWspXG4gICAgaWYgKHR3ZWFrLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByZXR1cm4gMlxuXG4gICAgY29uc3QgcG9pbnQgPSBwYWlyLmdldFB1YmxpYygpLmFkZChlY3BhcmFtcy5nLm11bCh0d2VhaykpXG4gICAgaWYgKHBvaW50LmlzSW5maW5pdHkoKSkgcmV0dXJuIDJcblxuICAgIHNhdmVQdWJsaWNLZXkob3V0cHV0LCBwb2ludClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHVibGljS2V5VHdlYWtNdWwgKG91dHB1dCwgcHVia2V5LCB0d2Vhaykge1xuICAgIGNvbnN0IHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmtleSlcbiAgICBpZiAocGFpciA9PT0gbnVsbCkgcmV0dXJuIDFcblxuICAgIHR3ZWFrID0gbmV3IEJOKHR3ZWFrKVxuICAgIGlmICh0d2Vhay5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCB0d2Vhay5pc1plcm8oKSkgcmV0dXJuIDJcblxuICAgIGNvbnN0IHBvaW50ID0gcGFpci5nZXRQdWJsaWMoKS5tdWwodHdlYWspXG4gICAgc2F2ZVB1YmxpY0tleShvdXRwdXQsIHBvaW50KVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBzaWduYXR1cmVOb3JtYWxpemUgKHNpZykge1xuICAgIGNvbnN0IHIgPSBuZXcgQk4oc2lnLnN1YmFycmF5KDAsIDMyKSlcbiAgICBjb25zdCBzID0gbmV3IEJOKHNpZy5zdWJhcnJheSgzMiwgNjQpKVxuICAgIGlmIChyLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHMuY21wKGVjcGFyYW1zLm4pID49IDApIHJldHVybiAxXG5cbiAgICBpZiAocy5jbXAoZWMubmgpID09PSAxKSB7XG4gICAgICBzaWcuc2V0KGVjcGFyYW1zLm4uc3ViKHMpLnRvQXJyYXlMaWtlKFVpbnQ4QXJyYXksICdiZScsIDMyKSwgMzIpXG4gICAgfVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICAvLyBDb3BpZWQgMS10by0xIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW5qcy9iaXA2Ni9ibG9iL21hc3Rlci9pbmRleC5qc1xuICAvLyBBZGFwdGVkIGZvciBVaW50OEFycmF5IGluc3RlYWQgQnVmZmVyXG4gIHNpZ25hdHVyZUV4cG9ydCAob2JqLCBzaWcpIHtcbiAgICBjb25zdCBzaWdSID0gc2lnLnN1YmFycmF5KDAsIDMyKVxuICAgIGNvbnN0IHNpZ1MgPSBzaWcuc3ViYXJyYXkoMzIsIDY0KVxuICAgIGlmIChuZXcgQk4oc2lnUikuY21wKGVjcGFyYW1zLm4pID49IDApIHJldHVybiAxXG4gICAgaWYgKG5ldyBCTihzaWdTKS5jbXAoZWNwYXJhbXMubikgPj0gMCkgcmV0dXJuIDFcblxuICAgIGNvbnN0IHsgb3V0cHV0IH0gPSBvYmpcblxuICAgIC8vIFByZXBhcmUgUlxuICAgIGxldCByID0gb3V0cHV0LnN1YmFycmF5KDQsIDQgKyAzMylcbiAgICByWzBdID0gMHgwMFxuICAgIHIuc2V0KHNpZ1IsIDEpXG5cbiAgICBsZXQgbGVuUiA9IDMzXG4gICAgbGV0IHBvc1IgPSAwXG4gICAgZm9yICg7IGxlblIgPiAxICYmIHJbcG9zUl0gPT09IDB4MDAgJiYgIShyW3Bvc1IgKyAxXSAmIDB4ODApOyAtLWxlblIsICsrcG9zUik7XG5cbiAgICByID0gci5zdWJhcnJheShwb3NSKVxuICAgIGlmIChyWzBdICYgMHg4MCkgcmV0dXJuIDFcbiAgICBpZiAobGVuUiA+IDEgJiYgKHJbMF0gPT09IDB4MDApICYmICEoclsxXSAmIDB4ODApKSByZXR1cm4gMVxuXG4gICAgLy8gUHJlcGFyZSBTXG4gICAgbGV0IHMgPSBvdXRwdXQuc3ViYXJyYXkoNiArIDMzLCA2ICsgMzMgKyAzMylcbiAgICBzWzBdID0gMHgwMFxuICAgIHMuc2V0KHNpZ1MsIDEpXG5cbiAgICBsZXQgbGVuUyA9IDMzXG4gICAgbGV0IHBvc1MgPSAwXG4gICAgZm9yICg7IGxlblMgPiAxICYmIHNbcG9zU10gPT09IDB4MDAgJiYgIShzW3Bvc1MgKyAxXSAmIDB4ODApOyAtLWxlblMsICsrcG9zUyk7XG5cbiAgICBzID0gcy5zdWJhcnJheShwb3NTKVxuICAgIGlmIChzWzBdICYgMHg4MCkgcmV0dXJuIDFcbiAgICBpZiAobGVuUyA+IDEgJiYgKHNbMF0gPT09IDB4MDApICYmICEoc1sxXSAmIDB4ODApKSByZXR1cm4gMVxuXG4gICAgLy8gU2V0IG91dHB1dCBsZW5ndGggZm9yIHJldHVyblxuICAgIG9iai5vdXRwdXRsZW4gPSA2ICsgbGVuUiArIGxlblNcblxuICAgIC8vIE91dHB1dCBpbiBzcGVjaWZpZWQgZm9ybWF0XG4gICAgLy8gMHgzMCBbdG90YWwtbGVuZ3RoXSAweDAyIFtSLWxlbmd0aF0gW1JdIDB4MDIgW1MtbGVuZ3RoXSBbU11cbiAgICBvdXRwdXRbMF0gPSAweDMwXG4gICAgb3V0cHV0WzFdID0gb2JqLm91dHB1dGxlbiAtIDJcbiAgICBvdXRwdXRbMl0gPSAweDAyXG4gICAgb3V0cHV0WzNdID0gci5sZW5ndGhcbiAgICBvdXRwdXQuc2V0KHIsIDQpXG4gICAgb3V0cHV0WzQgKyBsZW5SXSA9IDB4MDJcbiAgICBvdXRwdXRbNSArIGxlblJdID0gcy5sZW5ndGhcbiAgICBvdXRwdXQuc2V0KHMsIDYgKyBsZW5SKVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICAvLyBDb3BpZWQgMS10by0xIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW5qcy9iaXA2Ni9ibG9iL21hc3Rlci9pbmRleC5qc1xuICAvLyBBZGFwdGVkIGZvciBVaW50OEFycmF5IGluc3RlYWQgQnVmZmVyXG4gIHNpZ25hdHVyZUltcG9ydCAob3V0cHV0LCBzaWcpIHtcbiAgICBpZiAoc2lnLmxlbmd0aCA8IDgpIHJldHVybiAxXG4gICAgaWYgKHNpZy5sZW5ndGggPiA3MikgcmV0dXJuIDFcbiAgICBpZiAoc2lnWzBdICE9PSAweDMwKSByZXR1cm4gMVxuICAgIGlmIChzaWdbMV0gIT09IHNpZy5sZW5ndGggLSAyKSByZXR1cm4gMVxuICAgIGlmIChzaWdbMl0gIT09IDB4MDIpIHJldHVybiAxXG5cbiAgICBjb25zdCBsZW5SID0gc2lnWzNdXG4gICAgaWYgKGxlblIgPT09IDApIHJldHVybiAxXG4gICAgaWYgKDUgKyBsZW5SID49IHNpZy5sZW5ndGgpIHJldHVybiAxXG4gICAgaWYgKHNpZ1s0ICsgbGVuUl0gIT09IDB4MDIpIHJldHVybiAxXG5cbiAgICBjb25zdCBsZW5TID0gc2lnWzUgKyBsZW5SXVxuICAgIGlmIChsZW5TID09PSAwKSByZXR1cm4gMVxuICAgIGlmICgoNiArIGxlblIgKyBsZW5TKSAhPT0gc2lnLmxlbmd0aCkgcmV0dXJuIDFcblxuICAgIGlmIChzaWdbNF0gJiAweDgwKSByZXR1cm4gMVxuICAgIGlmIChsZW5SID4gMSAmJiAoc2lnWzRdID09PSAweDAwKSAmJiAhKHNpZ1s1XSAmIDB4ODApKSByZXR1cm4gMVxuXG4gICAgaWYgKHNpZ1tsZW5SICsgNl0gJiAweDgwKSByZXR1cm4gMVxuICAgIGlmIChsZW5TID4gMSAmJiAoc2lnW2xlblIgKyA2XSA9PT0gMHgwMCkgJiYgIShzaWdbbGVuUiArIDddICYgMHg4MCkpIHJldHVybiAxXG5cbiAgICBsZXQgc2lnUiA9IHNpZy5zdWJhcnJheSg0LCA0ICsgbGVuUilcbiAgICBpZiAoc2lnUi5sZW5ndGggPT09IDMzICYmIHNpZ1JbMF0gPT09IDB4MDApIHNpZ1IgPSBzaWdSLnN1YmFycmF5KDEpXG4gICAgaWYgKHNpZ1IubGVuZ3RoID4gMzIpIHJldHVybiAxXG5cbiAgICBsZXQgc2lnUyA9IHNpZy5zdWJhcnJheSg2ICsgbGVuUilcbiAgICBpZiAoc2lnUy5sZW5ndGggPT09IDMzICYmIHNpZ1NbMF0gPT09IDB4MDApIHNpZ1MgPSBzaWdTLnNsaWNlKDEpXG4gICAgaWYgKHNpZ1MubGVuZ3RoID4gMzIpIHRocm93IG5ldyBFcnJvcignUyBsZW5ndGggaXMgdG9vIGxvbmcnKVxuXG4gICAgbGV0IHIgPSBuZXcgQk4oc2lnUilcbiAgICBpZiAoci5jbXAoZWNwYXJhbXMubikgPj0gMCkgciA9IG5ldyBCTigwKVxuXG4gICAgbGV0IHMgPSBuZXcgQk4oc2lnLnN1YmFycmF5KDYgKyBsZW5SKSlcbiAgICBpZiAocy5jbXAoZWNwYXJhbXMubikgPj0gMCkgcyA9IG5ldyBCTigwKVxuXG4gICAgb3V0cHV0LnNldChyLnRvQXJyYXlMaWtlKFVpbnQ4QXJyYXksICdiZScsIDMyKSwgMClcbiAgICBvdXRwdXQuc2V0KHMudG9BcnJheUxpa2UoVWludDhBcnJheSwgJ2JlJywgMzIpLCAzMilcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgZWNkc2FTaWduIChvYmosIG1lc3NhZ2UsIHNlY2tleSwgZGF0YSwgbm9uY2Vmbikge1xuICAgIGlmIChub25jZWZuKSB7XG4gICAgICBjb25zdCBfbm9uY2VmbiA9IG5vbmNlZm5cbiAgICAgIG5vbmNlZm4gPSAoY291bnRlcikgPT4ge1xuICAgICAgICBjb25zdCBub25jZSA9IF9ub25jZWZuKG1lc3NhZ2UsIHNlY2tleSwgbnVsbCwgZGF0YSwgY291bnRlcilcblxuICAgICAgICBjb25zdCBpc1ZhbGlkID0gbm9uY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIG5vbmNlLmxlbmd0aCA9PT0gMzJcbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgaXMgdGhlIHdheScpXG5cbiAgICAgICAgcmV0dXJuIG5ldyBCTihub25jZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBkID0gbmV3IEJOKHNlY2tleSlcbiAgICBpZiAoZC5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBkLmlzWmVybygpKSByZXR1cm4gMVxuXG4gICAgbGV0IHNpZ1xuICAgIHRyeSB7XG4gICAgICBzaWcgPSBlYy5zaWduKG1lc3NhZ2UsIHNlY2tleSwgeyBjYW5vbmljYWw6IHRydWUsIGs6IG5vbmNlZm4sIHBlcnM6IGRhdGEgfSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgb2JqLnNpZ25hdHVyZS5zZXQoc2lnLnIudG9BcnJheUxpa2UoVWludDhBcnJheSwgJ2JlJywgMzIpLCAwKVxuICAgIG9iai5zaWduYXR1cmUuc2V0KHNpZy5zLnRvQXJyYXlMaWtlKFVpbnQ4QXJyYXksICdiZScsIDMyKSwgMzIpXG4gICAgb2JqLnJlY2lkID0gc2lnLnJlY292ZXJ5UGFyYW1cblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgZWNkc2FWZXJpZnkgKHNpZywgbXNnMzIsIHB1YmtleSkge1xuICAgIGNvbnN0IHNpZ09iaiA9IHsgcjogc2lnLnN1YmFycmF5KDAsIDMyKSwgczogc2lnLnN1YmFycmF5KDMyLCA2NCkgfVxuXG4gICAgY29uc3Qgc2lnciA9IG5ldyBCTihzaWdPYmoucilcbiAgICBjb25zdCBzaWdzID0gbmV3IEJOKHNpZ09iai5zKVxuICAgIGlmIChzaWdyLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHNpZ3MuY21wKGVjcGFyYW1zLm4pID49IDApIHJldHVybiAxXG4gICAgaWYgKHNpZ3MuY21wKGVjLm5oKSA9PT0gMSB8fCBzaWdyLmlzWmVybygpIHx8IHNpZ3MuaXNaZXJvKCkpIHJldHVybiAzXG5cbiAgICBjb25zdCBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJrZXkpXG4gICAgaWYgKHBhaXIgPT09IG51bGwpIHJldHVybiAyXG5cbiAgICBjb25zdCBwb2ludCA9IHBhaXIuZ2V0UHVibGljKClcbiAgICBjb25zdCBpc1ZhbGlkID0gZWMudmVyaWZ5KG1zZzMyLCBzaWdPYmosIHBvaW50KVxuICAgIHJldHVybiBpc1ZhbGlkID8gMCA6IDNcbiAgfSxcblxuICBlY2RzYVJlY292ZXIgKG91dHB1dCwgc2lnLCByZWNpZCwgbXNnMzIpIHtcbiAgICBjb25zdCBzaWdPYmogPSB7IHI6IHNpZy5zbGljZSgwLCAzMiksIHM6IHNpZy5zbGljZSgzMiwgNjQpIH1cblxuICAgIGNvbnN0IHNpZ3IgPSBuZXcgQk4oc2lnT2JqLnIpXG4gICAgY29uc3Qgc2lncyA9IG5ldyBCTihzaWdPYmoucylcbiAgICBpZiAoc2lnci5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBzaWdzLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByZXR1cm4gMVxuXG4gICAgaWYgKHNpZ3IuaXNaZXJvKCkgfHwgc2lncy5pc1plcm8oKSkgcmV0dXJuIDJcblxuICAgIC8vIENhbiB0aHJvdyBgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBzZW5jb25kIGtleSBjYW5kaW5hdGUnKTtgXG4gICAgbGV0IHBvaW50XG4gICAgdHJ5IHtcbiAgICAgIHBvaW50ID0gZWMucmVjb3ZlclB1YktleShtc2czMiwgc2lnT2JqLCByZWNpZClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiAyXG4gICAgfVxuXG4gICAgc2F2ZVB1YmxpY0tleShvdXRwdXQsIHBvaW50KVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBlY2RoIChvdXRwdXQsIHB1YmtleSwgc2Vja2V5LCBkYXRhLCBoYXNoZm4sIHhidWYsIHlidWYpIHtcbiAgICBjb25zdCBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJrZXkpXG4gICAgaWYgKHBhaXIgPT09IG51bGwpIHJldHVybiAxXG5cbiAgICBjb25zdCBzY2FsYXIgPSBuZXcgQk4oc2Vja2V5KVxuICAgIGlmIChzY2FsYXIuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgc2NhbGFyLmlzWmVybygpKSByZXR1cm4gMlxuXG4gICAgY29uc3QgcG9pbnQgPSBwYWlyLmdldFB1YmxpYygpLm11bChzY2FsYXIpXG5cbiAgICBpZiAoaGFzaGZuID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBwb2ludC5lbmNvZGUobnVsbCwgdHJ1ZSlcbiAgICAgIGNvbnN0IHNoYTI1NiA9IGVjLmhhc2goKS51cGRhdGUoZGF0YSkuZGlnZXN0KClcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7ICsraSkgb3V0cHV0W2ldID0gc2hhMjU2W2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgheGJ1ZikgeGJ1ZiA9IG5ldyBVaW50OEFycmF5KDMyKVxuICAgICAgY29uc3QgeCA9IHBvaW50LmdldFgoKS50b0FycmF5KCdiZScsIDMyKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgKytpKSB4YnVmW2ldID0geFtpXVxuXG4gICAgICBpZiAoIXlidWYpIHlidWYgPSBuZXcgVWludDhBcnJheSgzMilcbiAgICAgIGNvbnN0IHkgPSBwb2ludC5nZXRZKCkudG9BcnJheSgnYmUnLCAzMilcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7ICsraSkgeWJ1ZltpXSA9IHlbaV1cblxuICAgICAgY29uc3QgaGFzaCA9IGhhc2hmbih4YnVmLCB5YnVmLCBkYXRhKVxuXG4gICAgICBjb25zdCBpc1ZhbGlkID0gaGFzaCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgaGFzaC5sZW5ndGggPT09IG91dHB1dC5sZW5ndGhcbiAgICAgIGlmICghaXNWYWxpZCkgcmV0dXJuIDJcblxuICAgICAgb3V0cHV0LnNldChoYXNoKVxuICAgIH1cblxuICAgIHJldHVybiAwXG4gIH1cbn1cbiIsImNvbnN0IGVycm9ycyA9IHtcbiAgSU1QT1NTSUJMRV9DQVNFOiAnSW1wb3NzaWJsZSBjYXNlLiBQbGVhc2UgY3JlYXRlIGlzc3VlLicsXG4gIFRXRUFLX0FERDpcbiAgICAnVGhlIHR3ZWFrIHdhcyBvdXQgb2YgcmFuZ2Ugb3IgdGhlIHJlc3VsdGVkIHByaXZhdGUga2V5IGlzIGludmFsaWQnLFxuICBUV0VBS19NVUw6ICdUaGUgdHdlYWsgd2FzIG91dCBvZiByYW5nZSBvciBlcXVhbCB0byB6ZXJvJyxcbiAgQ09OVEVYVF9SQU5ET01JWkVfVU5LTk9XOiAnVW5rbm93IGVycm9yIG9uIGNvbnRleHQgcmFuZG9taXphdGlvbicsXG4gIFNFQ0tFWV9JTlZBTElEOiAnUHJpdmF0ZSBLZXkgaXMgaW52YWxpZCcsXG4gIFBVQktFWV9QQVJTRTogJ1B1YmxpYyBLZXkgY291bGQgbm90IGJlIHBhcnNlZCcsXG4gIFBVQktFWV9TRVJJQUxJWkU6ICdQdWJsaWMgS2V5IHNlcmlhbGl6YXRpb24gZXJyb3InLFxuICBQVUJLRVlfQ09NQklORTogJ1RoZSBzdW0gb2YgdGhlIHB1YmxpYyBrZXlzIGlzIG5vdCB2YWxpZCcsXG4gIFNJR19QQVJTRTogJ1NpZ25hdHVyZSBjb3VsZCBub3QgYmUgcGFyc2VkJyxcbiAgU0lHTjogJ1RoZSBub25jZSBnZW5lcmF0aW9uIGZ1bmN0aW9uIGZhaWxlZCwgb3IgdGhlIHByaXZhdGUga2V5IHdhcyBpbnZhbGlkJyxcbiAgUkVDT1ZFUjogJ1B1YmxpYyBrZXkgY291bGQgbm90IGJlIHJlY292ZXInLFxuICBFQ0RIOiAnU2NhbGFyIHdhcyBpbnZhbGlkICh6ZXJvIG9yIG92ZXJmbG93KSdcbn1cblxuZnVuY3Rpb24gYXNzZXJ0IChjb25kLCBtc2cpIHtcbiAgaWYgKCFjb25kKSB0aHJvdyBuZXcgRXJyb3IobXNnKVxufVxuXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkgKG5hbWUsIHZhbHVlLCBsZW5ndGgpIHtcbiAgYXNzZXJ0KHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSwgYEV4cGVjdGVkICR7bmFtZX0gdG8gYmUgYW4gVWludDhBcnJheWApXG5cbiAgaWYgKGxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGVuZ3RoKSkge1xuICAgICAgY29uc3QgbnVtYmVycyA9IGxlbmd0aC5qb2luKCcsICcpXG4gICAgICBjb25zdCBtc2cgPSBgRXhwZWN0ZWQgJHtuYW1lfSB0byBiZSBhbiBVaW50OEFycmF5IHdpdGggbGVuZ3RoIFske251bWJlcnN9XWBcbiAgICAgIGFzc2VydChsZW5ndGguaW5jbHVkZXModmFsdWUubGVuZ3RoKSwgbXNnKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtc2cgPSBgRXhwZWN0ZWQgJHtuYW1lfSB0byBiZSBhbiBVaW50OEFycmF5IHdpdGggbGVuZ3RoICR7bGVuZ3RofWBcbiAgICAgIGFzc2VydCh2YWx1ZS5sZW5ndGggPT09IGxlbmd0aCwgbXNnKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0NvbXByZXNzZWQgKHZhbHVlKSB7XG4gIGFzc2VydCh0b1R5cGVTdHJpbmcodmFsdWUpID09PSAnQm9vbGVhbicsICdFeHBlY3RlZCBjb21wcmVzc2VkIHRvIGJlIGEgQm9vbGVhbicpXG59XG5cbmZ1bmN0aW9uIGdldEFzc2VydGVkT3V0cHV0IChvdXRwdXQgPSAobGVuKSA9PiBuZXcgVWludDhBcnJheShsZW4pLCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBvdXRwdXQgPT09ICdmdW5jdGlvbicpIG91dHB1dCA9IG91dHB1dChsZW5ndGgpXG4gIGlzVWludDhBcnJheSgnb3V0cHV0Jywgb3V0cHV0LCBsZW5ndGgpXG4gIHJldHVybiBvdXRwdXRcbn1cblxuZnVuY3Rpb24gdG9UeXBlU3RyaW5nICh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoc2VjcDI1NmsxKSA9PiB7XG4gIHJldHVybiB7XG4gICAgY29udGV4dFJhbmRvbWl6ZSAoc2VlZCkge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBzZWVkID09PSBudWxsIHx8IHNlZWQgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgICAgICAnRXhwZWN0ZWQgc2VlZCB0byBiZSBhbiBVaW50OEFycmF5IG9yIG51bGwnXG4gICAgICApXG4gICAgICBpZiAoc2VlZCAhPT0gbnVsbCkgaXNVaW50OEFycmF5KCdzZWVkJywgc2VlZCwgMzIpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLmNvbnRleHRSYW5kb21pemUoc2VlZCkpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuQ09OVEVYVF9SQU5ET01JWkVfVU5LTk9XKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5VmVyaWZ5IChzZWNrZXkpIHtcbiAgICAgIGlzVWludDhBcnJheSgncHJpdmF0ZSBrZXknLCBzZWNrZXksIDMyKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkoc2Vja2V5KSA9PT0gMFxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5TmVnYXRlIChzZWNrZXkpIHtcbiAgICAgIGlzVWludDhBcnJheSgncHJpdmF0ZSBrZXknLCBzZWNrZXksIDMyKVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wcml2YXRlS2V5TmVnYXRlKHNlY2tleSkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBzZWNrZXlcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuSU1QT1NTSUJMRV9DQVNFKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5VHdlYWtBZGQgKHNlY2tleSwgdHdlYWspIHtcbiAgICAgIGlzVWludDhBcnJheSgncHJpdmF0ZSBrZXknLCBzZWNrZXksIDMyKVxuICAgICAgaXNVaW50OEFycmF5KCd0d2VhaycsIHR3ZWFrLCAzMilcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrQWRkKHNlY2tleSwgdHdlYWspKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gc2Vja2V5XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlRXRUFLX0FERClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleVR3ZWFrTXVsIChzZWNrZXksIHR3ZWFrKSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcbiAgICAgIGlzVWludDhBcnJheSgndHdlYWsnLCB0d2VhaywgMzIpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnByaXZhdGVLZXlUd2Vha011bChzZWNrZXksIHR3ZWFrKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIHNlY2tleVxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5UV0VBS19NVUwpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHB1YmxpY0tleVZlcmlmeSAocHVia2V5KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShwdWJrZXkpID09PSAwXG4gICAgfSxcblxuICAgIHB1YmxpY0tleUNyZWF0ZSAoc2Vja2V5LCBjb21wcmVzc2VkID0gdHJ1ZSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKG91dHB1dCwgc2Vja2V5KSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TRUNLRVlfSU5WQUxJRClcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1NFUklBTElaRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHVibGljS2V5Q29udmVydCAocHVia2V5LCBjb21wcmVzc2VkID0gdHJ1ZSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuICAgICAgaXNDb21wcmVzc2VkKGNvbXByZXNzZWQpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIGNvbXByZXNzZWQgPyAzMyA6IDY1KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KG91dHB1dCwgcHVia2V5KSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9TRVJJQUxJWkUpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHB1YmxpY0tleU5lZ2F0ZSAocHVia2V5LCBjb21wcmVzc2VkID0gdHJ1ZSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuICAgICAgaXNDb21wcmVzc2VkKGNvbXByZXNzZWQpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIGNvbXByZXNzZWQgPyAzMyA6IDY1KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wdWJsaWNLZXlOZWdhdGUob3V0cHV0LCBwdWJrZXkpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuSU1QT1NTSUJMRV9DQVNFKVxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfU0VSSUFMSVpFKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlDb21iaW5lIChwdWJrZXlzLCBjb21wcmVzc2VkID0gdHJ1ZSwgb3V0cHV0KSB7XG4gICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShwdWJrZXlzKSwgJ0V4cGVjdGVkIHB1YmxpYyBrZXlzIHRvIGJlIGFuIEFycmF5JylcbiAgICAgIGFzc2VydChwdWJrZXlzLmxlbmd0aCA+IDAsICdFeHBlY3RlZCBwdWJsaWMga2V5cyBhcnJheSB3aWxsIGhhdmUgbW9yZSB0aGFuIHplcm8gaXRlbXMnKVxuICAgICAgZm9yIChjb25zdCBwdWJrZXkgb2YgcHVia2V5cykge1xuICAgICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuICAgICAgfVxuICAgICAgaXNDb21wcmVzc2VkKGNvbXByZXNzZWQpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIGNvbXByZXNzZWQgPyAzMyA6IDY1KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wdWJsaWNLZXlDb21iaW5lKG91dHB1dCwgcHVia2V5cykpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfQ09NQklORSlcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1NFUklBTElaRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHVibGljS2V5VHdlYWtBZGQgKHB1YmtleSwgdHdlYWssIGNvbXByZXNzZWQgPSB0cnVlLCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgncHVibGljIGtleScsIHB1YmtleSwgWzMzLCA2NV0pXG4gICAgICBpc1VpbnQ4QXJyYXkoJ3R3ZWFrJywgdHdlYWssIDMyKVxuICAgICAgaXNDb21wcmVzc2VkKGNvbXByZXNzZWQpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIGNvbXByZXNzZWQgPyAzMyA6IDY1KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha0FkZChvdXRwdXQsIHB1YmtleSwgdHdlYWspKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuVFdFQUtfQUREKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlUd2Vha011bCAocHVia2V5LCB0d2VhaywgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcbiAgICAgIGlzVWludDhBcnJheSgndHdlYWsnLCB0d2VhaywgMzIpXG4gICAgICBpc0NvbXByZXNzZWQoY29tcHJlc3NlZClcbiAgICAgIG91dHB1dCA9IGdldEFzc2VydGVkT3V0cHV0KG91dHB1dCwgY29tcHJlc3NlZCA/IDMzIDogNjUpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnB1YmxpY0tleVR3ZWFrTXVsKG91dHB1dCwgcHVia2V5LCB0d2VhaykpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5UV0VBS19NVUwpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHNpZ25hdHVyZU5vcm1hbGl6ZSAoc2lnKSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3NpZ25hdHVyZScsIHNpZywgNjQpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnNpZ25hdHVyZU5vcm1hbGl6ZShzaWcpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gc2lnXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlNJR19QQVJTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2lnbmF0dXJlRXhwb3J0IChzaWcsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdzaWduYXR1cmUnLCBzaWcsIDY0KVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCA3MilcblxuICAgICAgY29uc3Qgb2JqID0geyBvdXRwdXQsIG91dHB1dGxlbjogNzIgfVxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuc2lnbmF0dXJlRXhwb3J0KG9iaiwgc2lnKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dC5zbGljZSgwLCBvYmoub3V0cHV0bGVuKVxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2lnbmF0dXJlSW1wb3J0IChzaWcsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdzaWduYXR1cmUnLCBzaWcpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIDY0KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5zaWduYXR1cmVJbXBvcnQob3V0cHV0LCBzaWcpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlNJR19QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuSU1QT1NTSUJMRV9DQVNFKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBlY2RzYVNpZ24gKG1zZzMyLCBzZWNrZXksIG9wdGlvbnMgPSB7fSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ21lc3NhZ2UnLCBtc2czMiwgMzIpXG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcbiAgICAgIGFzc2VydCh0b1R5cGVTdHJpbmcob3B0aW9ucykgPT09ICdPYmplY3QnLCAnRXhwZWN0ZWQgb3B0aW9ucyB0byBiZSBhbiBPYmplY3QnKVxuICAgICAgaWYgKG9wdGlvbnMuZGF0YSAhPT0gdW5kZWZpbmVkKSBpc1VpbnQ4QXJyYXkoJ29wdGlvbnMuZGF0YScsIG9wdGlvbnMuZGF0YSlcbiAgICAgIGlmIChvcHRpb25zLm5vbmNlZm4gIT09IHVuZGVmaW5lZCkgYXNzZXJ0KHRvVHlwZVN0cmluZyhvcHRpb25zLm5vbmNlZm4pID09PSAnRnVuY3Rpb24nLCAnRXhwZWN0ZWQgb3B0aW9ucy5ub25jZWZuIHRvIGJlIGEgRnVuY3Rpb24nKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCA2NClcblxuICAgICAgY29uc3Qgb2JqID0geyBzaWduYXR1cmU6IG91dHB1dCwgcmVjaWQ6IG51bGwgfVxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuZWNkc2FTaWduKG9iaiwgbXNnMzIsIHNlY2tleSwgb3B0aW9ucy5kYXRhLCBvcHRpb25zLm5vbmNlZm4pKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlNJR04pXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZWNkc2FWZXJpZnkgKHNpZywgbXNnMzIsIHB1YmtleSkge1xuICAgICAgaXNVaW50OEFycmF5KCdzaWduYXR1cmUnLCBzaWcsIDY0KVxuICAgICAgaXNVaW50OEFycmF5KCdtZXNzYWdlJywgbXNnMzIsIDMyKVxuICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuZWNkc2FWZXJpZnkoc2lnLCBtc2czMiwgcHVia2V5KSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9QQVJTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZWNkc2FSZWNvdmVyIChzaWcsIHJlY2lkLCBtc2czMiwgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdzaWduYXR1cmUnLCBzaWcsIDY0KVxuICAgICAgYXNzZXJ0KFxuICAgICAgICB0b1R5cGVTdHJpbmcocmVjaWQpID09PSAnTnVtYmVyJyAmJlxuICAgICAgICAgIHJlY2lkID49IDAgJiZcbiAgICAgICAgICByZWNpZCA8PSAzLFxuICAgICAgICAnRXhwZWN0ZWQgcmVjb3ZlcnkgaWQgdG8gYmUgYSBOdW1iZXIgd2l0aGluIGludGVydmFsIFswLCAzXSdcbiAgICAgIClcbiAgICAgIGlzVWludDhBcnJheSgnbWVzc2FnZScsIG1zZzMyLCAzMilcbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuZWNkc2FSZWNvdmVyKG91dHB1dCwgc2lnLCByZWNpZCwgbXNnMzIpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlNJR19QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUkVDT1ZFUilcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuSU1QT1NTSUJMRV9DQVNFKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBlY2RoIChwdWJrZXksIHNlY2tleSwgb3B0aW9ucyA9IHt9LCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgncHVibGljIGtleScsIHB1YmtleSwgWzMzLCA2NV0pXG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcbiAgICAgIGFzc2VydCh0b1R5cGVTdHJpbmcob3B0aW9ucykgPT09ICdPYmplY3QnLCAnRXhwZWN0ZWQgb3B0aW9ucyB0byBiZSBhbiBPYmplY3QnKVxuICAgICAgaWYgKG9wdGlvbnMuZGF0YSAhPT0gdW5kZWZpbmVkKSBpc1VpbnQ4QXJyYXkoJ29wdGlvbnMuZGF0YScsIG9wdGlvbnMuZGF0YSlcbiAgICAgIGlmIChvcHRpb25zLmhhc2hmbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFzc2VydCh0b1R5cGVTdHJpbmcob3B0aW9ucy5oYXNoZm4pID09PSAnRnVuY3Rpb24nLCAnRXhwZWN0ZWQgb3B0aW9ucy5oYXNoZm4gdG8gYmUgYSBGdW5jdGlvbicpXG4gICAgICAgIGlmIChvcHRpb25zLnhidWYgIT09IHVuZGVmaW5lZCkgaXNVaW50OEFycmF5KCdvcHRpb25zLnhidWYnLCBvcHRpb25zLnhidWYsIDMyKVxuICAgICAgICBpZiAob3B0aW9ucy55YnVmICE9PSB1bmRlZmluZWQpIGlzVWludDhBcnJheSgnb3B0aW9ucy55YnVmJywgb3B0aW9ucy55YnVmLCAzMilcbiAgICAgICAgaXNVaW50OEFycmF5KCdvdXRwdXQnLCBvdXRwdXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIDMyKVxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5lY2RoKG91dHB1dCwgcHVia2V5LCBzZWNrZXksIG9wdGlvbnMuZGF0YSwgb3B0aW9ucy5oYXNoZm4sIG9wdGlvbnMueGJ1Ziwgb3B0aW9ucy55YnVmKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLkVDREgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJjb25zdCBBTlkgPSBTeW1ib2woJ1NlbVZlciBBTlknKVxuLy8gaG9pc3RlZCBjbGFzcyBmb3IgY3ljbGljIGRlcGVuZGVuY3lcbmNsYXNzIENvbXBhcmF0b3Ige1xuICBzdGF0aWMgZ2V0IEFOWSAoKSB7XG4gICAgcmV0dXJuIEFOWVxuICB9XG5cbiAgY29uc3RydWN0b3IgKGNvbXAsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICAgIGlmIChjb21wLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXAgPSBjb21wLnZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVidWcoJ2NvbXBhcmF0b3InLCBjb21wLCBvcHRpb25zKVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgdGhpcy5wYXJzZShjb21wKVxuXG4gICAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgIHRoaXMudmFsdWUgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5vcGVyYXRvciArIHRoaXMuc2VtdmVyLnZlcnNpb25cbiAgICB9XG5cbiAgICBkZWJ1ZygnY29tcCcsIHRoaXMpXG4gIH1cblxuICBwYXJzZSAoY29tcCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLm9wdGlvbnMubG9vc2UgPyByZVt0LkNPTVBBUkFUT1JMT09TRV0gOiByZVt0LkNPTVBBUkFUT1JdXG4gICAgY29uc3QgbSA9IGNvbXAubWF0Y2gocilcblxuICAgIGlmICghbSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBjb21wYXJhdG9yOiAke2NvbXB9YClcbiAgICB9XG5cbiAgICB0aGlzLm9wZXJhdG9yID0gbVsxXSAhPT0gdW5kZWZpbmVkID8gbVsxXSA6ICcnXG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICc9Jykge1xuICAgICAgdGhpcy5vcGVyYXRvciA9ICcnXG4gICAgfVxuXG4gICAgLy8gaWYgaXQgbGl0ZXJhbGx5IGlzIGp1c3QgJz4nIG9yICcnIHRoZW4gYWxsb3cgYW55dGhpbmcuXG4gICAgaWYgKCFtWzJdKSB7XG4gICAgICB0aGlzLnNlbXZlciA9IEFOWVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbXZlciA9IG5ldyBTZW1WZXIobVsyXSwgdGhpcy5vcHRpb25zLmxvb3NlKVxuICAgIH1cbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVxuICB9XG5cbiAgdGVzdCAodmVyc2lvbikge1xuICAgIGRlYnVnKCdDb21wYXJhdG9yLnRlc3QnLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMubG9vc2UpXG5cbiAgICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSB8fCB2ZXJzaW9uID09PSBBTlkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNtcCh2ZXJzaW9uLCB0aGlzLm9wZXJhdG9yLCB0aGlzLnNlbXZlciwgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgaW50ZXJzZWN0cyAoY29tcCwgb3B0aW9ucykge1xuICAgIGlmICghKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBDb21wYXJhdG9yIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJycpIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZShjb21wLnZhbHVlLCBvcHRpb25zKS50ZXN0KHRoaXMudmFsdWUpXG4gICAgfSBlbHNlIGlmIChjb21wLm9wZXJhdG9yID09PSAnJykge1xuICAgICAgaWYgKGNvbXAudmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMudmFsdWUsIG9wdGlvbnMpLnRlc3QoY29tcC5zZW12ZXIpXG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgLy8gU3BlY2lhbCBjYXNlcyB3aGVyZSBub3RoaW5nIGNhbiBwb3NzaWJseSBiZSBsb3dlclxuICAgIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgICAodGhpcy52YWx1ZSA9PT0gJzwwLjAuMC0wJyB8fCBjb21wLnZhbHVlID09PSAnPDAuMC4wLTAnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgICAgKHRoaXMudmFsdWUuc3RhcnRzV2l0aCgnPDAuMC4wJykgfHwgY29tcC52YWx1ZS5zdGFydHNXaXRoKCc8MC4wLjAnKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIFNhbWUgZGlyZWN0aW9uIGluY3JlYXNpbmcgKD4gb3IgPj0pXG4gICAgaWYgKHRoaXMub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPicpICYmIGNvbXAub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPicpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBTYW1lIGRpcmVjdGlvbiBkZWNyZWFzaW5nICg8IG9yIDw9KVxuICAgIGlmICh0aGlzLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJzwnKSAmJiBjb21wLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJzwnKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gc2FtZSBTZW1WZXIgYW5kIGJvdGggc2lkZXMgYXJlIGluY2x1c2l2ZSAoPD0gb3IgPj0pXG4gICAgaWYgKFxuICAgICAgKHRoaXMuc2VtdmVyLnZlcnNpb24gPT09IGNvbXAuc2VtdmVyLnZlcnNpb24pICYmXG4gICAgICB0aGlzLm9wZXJhdG9yLmluY2x1ZGVzKCc9JykgJiYgY29tcC5vcGVyYXRvci5pbmNsdWRlcygnPScpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBvcHBvc2l0ZSBkaXJlY3Rpb25zIGxlc3MgdGhhblxuICAgIGlmIChjbXAodGhpcy5zZW12ZXIsICc8JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmXG4gICAgICB0aGlzLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJz4nKSAmJiBjb21wLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJzwnKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gb3Bwb3NpdGUgZGlyZWN0aW9ucyBncmVhdGVyIHRoYW5cbiAgICBpZiAoY21wKHRoaXMuc2VtdmVyLCAnPicsIGNvbXAuc2VtdmVyLCBvcHRpb25zKSAmJlxuICAgICAgdGhpcy5vcGVyYXRvci5zdGFydHNXaXRoKCc8JykgJiYgY29tcC5vcGVyYXRvci5zdGFydHNXaXRoKCc+JykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcGFyYXRvclxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IHsgcmUsIHQgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcbmNvbnN0IGNtcCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jbXAnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4vcmFuZ2UnKVxuIiwiLy8gaG9pc3RlZCBjbGFzcyBmb3IgY3ljbGljIGRlcGVuZGVuY3lcbmNsYXNzIFJhbmdlIHtcbiAgY29uc3RydWN0b3IgKHJhbmdlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpIHtcbiAgICAgIGlmIChcbiAgICAgICAgcmFuZ2UubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJlxuICAgICAgICByYW5nZS5pbmNsdWRlUHJlcmVsZWFzZSA9PT0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnJhdywgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgICAvLyBqdXN0IHB1dCBpdCBpbiB0aGUgc2V0IGFuZCByZXR1cm5cbiAgICAgIHRoaXMucmF3ID0gcmFuZ2UudmFsdWVcbiAgICAgIHRoaXMuc2V0ID0gW1tyYW5nZV1dXG4gICAgICB0aGlzLmZvcm1hdCgpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gICAgLy8gRmlyc3QsIHNwbGl0IGJhc2VkIG9uIGJvb2xlYW4gb3IgfHxcbiAgICB0aGlzLnJhdyA9IHJhbmdlXG4gICAgdGhpcy5zZXQgPSByYW5nZVxuICAgICAgLnNwbGl0KCd8fCcpXG4gICAgICAvLyBtYXAgdGhlIHJhbmdlIHRvIGEgMmQgYXJyYXkgb2YgY29tcGFyYXRvcnNcbiAgICAgIC5tYXAociA9PiB0aGlzLnBhcnNlUmFuZ2Uoci50cmltKCkpKVxuICAgICAgLy8gdGhyb3cgb3V0IGFueSBjb21wYXJhdG9yIGxpc3RzIHRoYXQgYXJlIGVtcHR5XG4gICAgICAvLyB0aGlzIGdlbmVyYWxseSBtZWFucyB0aGF0IGl0IHdhcyBub3QgYSB2YWxpZCByYW5nZSwgd2hpY2ggaXMgYWxsb3dlZFxuICAgICAgLy8gaW4gbG9vc2UgbW9kZSwgYnV0IHdpbGwgc3RpbGwgdGhyb3cgaWYgdGhlIFdIT0xFIHJhbmdlIGlzIGludmFsaWQuXG4gICAgICAuZmlsdGVyKGMgPT4gYy5sZW5ndGgpXG5cbiAgICBpZiAoIXRoaXMuc2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBTZW1WZXIgUmFuZ2U6ICR7cmFuZ2V9YClcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGFueSB0aGF0IGFyZSBub3QgdGhlIG51bGwgc2V0LCB0aHJvdyBvdXQgbnVsbCBzZXRzLlxuICAgIGlmICh0aGlzLnNldC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBrZWVwIHRoZSBmaXJzdCBvbmUsIGluIGNhc2UgdGhleSdyZSBhbGwgbnVsbCBzZXRzXG4gICAgICBjb25zdCBmaXJzdCA9IHRoaXMuc2V0WzBdXG4gICAgICB0aGlzLnNldCA9IHRoaXMuc2V0LmZpbHRlcihjID0+ICFpc051bGxTZXQoY1swXSkpXG4gICAgICBpZiAodGhpcy5zZXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuc2V0ID0gW2ZpcnN0XVxuICAgICAgfSBlbHNlIGlmICh0aGlzLnNldC5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYW55IHRoYXQgYXJlICosIHRoZW4gdGhlIHJhbmdlIGlzIGp1c3QgKlxuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgdGhpcy5zZXQpIHtcbiAgICAgICAgICBpZiAoYy5sZW5ndGggPT09IDEgJiYgaXNBbnkoY1swXSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gW2NdXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZm9ybWF0KClcbiAgfVxuXG4gIGZvcm1hdCAoKSB7XG4gICAgdGhpcy5yYW5nZSA9IHRoaXMuc2V0XG4gICAgICAubWFwKChjb21wcykgPT4ge1xuICAgICAgICByZXR1cm4gY29tcHMuam9pbignICcpLnRyaW0oKVxuICAgICAgfSlcbiAgICAgIC5qb2luKCd8fCcpXG4gICAgICAudHJpbSgpXG4gICAgcmV0dXJuIHRoaXMucmFuZ2VcbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5nZVxuICB9XG5cbiAgcGFyc2VSYW5nZSAocmFuZ2UpIHtcbiAgICByYW5nZSA9IHJhbmdlLnRyaW0oKVxuXG4gICAgLy8gbWVtb2l6ZSByYW5nZSBwYXJzaW5nIGZvciBwZXJmb3JtYW5jZS5cbiAgICAvLyB0aGlzIGlzIGEgdmVyeSBob3QgcGF0aCwgYW5kIGZ1bGx5IGRldGVybWluaXN0aWMuXG4gICAgY29uc3QgbWVtb09wdHMgPVxuICAgICAgKHRoaXMub3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJiBGTEFHX0lOQ0xVREVfUFJFUkVMRUFTRSkgfFxuICAgICAgKHRoaXMub3B0aW9ucy5sb29zZSAmJiBGTEFHX0xPT1NFKVxuICAgIGNvbnN0IG1lbW9LZXkgPSBtZW1vT3B0cyArICc6JyArIHJhbmdlXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KG1lbW9LZXkpXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFxuICAgIH1cblxuICAgIGNvbnN0IGxvb3NlID0gdGhpcy5vcHRpb25zLmxvb3NlXG4gICAgLy8gYDEuMi4zIC0gMS4yLjRgID0+IGA+PTEuMi4zIDw9MS4yLjRgXG4gICAgY29uc3QgaHIgPSBsb29zZSA/IHJlW3QuSFlQSEVOUkFOR0VMT09TRV0gOiByZVt0LkhZUEhFTlJBTkdFXVxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShociwgaHlwaGVuUmVwbGFjZSh0aGlzLm9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpKVxuICAgIGRlYnVnKCdoeXBoZW4gcmVwbGFjZScsIHJhbmdlKVxuICAgIC8vIGA+IDEuMi4zIDwgMS4yLjVgID0+IGA+MS4yLjMgPDEuMi41YFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LkNPTVBBUkFUT1JUUklNXSwgY29tcGFyYXRvclRyaW1SZXBsYWNlKVxuICAgIGRlYnVnKCdjb21wYXJhdG9yIHRyaW0nLCByYW5nZSlcblxuICAgIC8vIGB+IDEuMi4zYCA9PiBgfjEuMi4zYFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LlRJTERFVFJJTV0sIHRpbGRlVHJpbVJlcGxhY2UpXG5cbiAgICAvLyBgXiAxLjIuM2AgPT4gYF4xLjIuM2BcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5DQVJFVFRSSU1dLCBjYXJldFRyaW1SZXBsYWNlKVxuXG4gICAgLy8gbm9ybWFsaXplIHNwYWNlc1xuICAgIHJhbmdlID0gcmFuZ2Uuc3BsaXQoL1xccysvKS5qb2luKCcgJylcblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByYW5nZSBpcyBjb21wbGV0ZWx5IHRyaW1tZWQgYW5kXG4gICAgLy8gcmVhZHkgdG8gYmUgc3BsaXQgaW50byBjb21wYXJhdG9ycy5cblxuICAgIGxldCByYW5nZUxpc3QgPSByYW5nZVxuICAgICAgLnNwbGl0KCcgJylcbiAgICAgIC5tYXAoY29tcCA9PiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKSlcbiAgICAgIC5qb2luKCcgJylcbiAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAvLyA+PTAuMC4wIGlzIGVxdWl2YWxlbnQgdG8gKlxuICAgICAgLm1hcChjb21wID0+IHJlcGxhY2VHVEUwKGNvbXAsIHRoaXMub3B0aW9ucykpXG5cbiAgICBpZiAobG9vc2UpIHtcbiAgICAgIC8vIGluIGxvb3NlIG1vZGUsIHRocm93IG91dCBhbnkgdGhhdCBhcmUgbm90IHZhbGlkIGNvbXBhcmF0b3JzXG4gICAgICByYW5nZUxpc3QgPSByYW5nZUxpc3QuZmlsdGVyKGNvbXAgPT4ge1xuICAgICAgICBkZWJ1ZygnbG9vc2UgaW52YWxpZCBmaWx0ZXInLCBjb21wLCB0aGlzLm9wdGlvbnMpXG4gICAgICAgIHJldHVybiAhIWNvbXAubWF0Y2gocmVbdC5DT01QQVJBVE9STE9PU0VdKVxuICAgICAgfSlcbiAgICB9XG4gICAgZGVidWcoJ3JhbmdlIGxpc3QnLCByYW5nZUxpc3QpXG5cbiAgICAvLyBpZiBhbnkgY29tcGFyYXRvcnMgYXJlIHRoZSBudWxsIHNldCwgdGhlbiByZXBsYWNlIHdpdGggSlVTVCBudWxsIHNldFxuICAgIC8vIGlmIG1vcmUgdGhhbiBvbmUgY29tcGFyYXRvciwgcmVtb3ZlIGFueSAqIGNvbXBhcmF0b3JzXG4gICAgLy8gYWxzbywgZG9uJ3QgaW5jbHVkZSB0aGUgc2FtZSBjb21wYXJhdG9yIG1vcmUgdGhhbiBvbmNlXG4gICAgY29uc3QgcmFuZ2VNYXAgPSBuZXcgTWFwKClcbiAgICBjb25zdCBjb21wYXJhdG9ycyA9IHJhbmdlTGlzdC5tYXAoY29tcCA9PiBuZXcgQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpKVxuICAgIGZvciAoY29uc3QgY29tcCBvZiBjb21wYXJhdG9ycykge1xuICAgICAgaWYgKGlzTnVsbFNldChjb21wKSkge1xuICAgICAgICByZXR1cm4gW2NvbXBdXG4gICAgICB9XG4gICAgICByYW5nZU1hcC5zZXQoY29tcC52YWx1ZSwgY29tcClcbiAgICB9XG4gICAgaWYgKHJhbmdlTWFwLnNpemUgPiAxICYmIHJhbmdlTWFwLmhhcygnJykpIHtcbiAgICAgIHJhbmdlTWFwLmRlbGV0ZSgnJylcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBbLi4ucmFuZ2VNYXAudmFsdWVzKCldXG4gICAgY2FjaGUuc2V0KG1lbW9LZXksIHJlc3VsdClcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBpbnRlcnNlY3RzIChyYW5nZSwgb3B0aW9ucykge1xuICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIFJhbmdlIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXQuc29tZSgodGhpc0NvbXBhcmF0b3JzKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBpc1NhdGlzZmlhYmxlKHRoaXNDb21wYXJhdG9ycywgb3B0aW9ucykgJiZcbiAgICAgICAgcmFuZ2Uuc2V0LnNvbWUoKHJhbmdlQ29tcGFyYXRvcnMpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNTYXRpc2ZpYWJsZShyYW5nZUNvbXBhcmF0b3JzLCBvcHRpb25zKSAmJlxuICAgICAgICAgICAgdGhpc0NvbXBhcmF0b3JzLmV2ZXJ5KCh0aGlzQ29tcGFyYXRvcikgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VDb21wYXJhdG9ycy5ldmVyeSgocmFuZ2VDb21wYXJhdG9yKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNDb21wYXJhdG9yLmludGVyc2VjdHMocmFuZ2VDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSlcbiAgfVxuXG4gIC8vIGlmIEFOWSBvZiB0aGUgc2V0cyBtYXRjaCBBTEwgb2YgaXRzIGNvbXBhcmF0b3JzLCB0aGVuIHBhc3NcbiAgdGVzdCAodmVyc2lvbikge1xuICAgIGlmICghdmVyc2lvbikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRlc3RTZXQodGhpcy5zZXRbaV0sIHZlcnNpb24sIHRoaXMub3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSYW5nZVxuXG5jb25zdCBMUlUgPSByZXF1aXJlKCdscnUtY2FjaGUnKVxuY29uc3QgY2FjaGUgPSBuZXcgTFJVKHsgbWF4OiAxMDAwIH0pXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4vY29tcGFyYXRvcicpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vc2VtdmVyJylcbmNvbnN0IHtcbiAgcmUsXG4gIHQsXG4gIGNvbXBhcmF0b3JUcmltUmVwbGFjZSxcbiAgdGlsZGVUcmltUmVwbGFjZSxcbiAgY2FyZXRUcmltUmVwbGFjZSxcbn0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5jb25zdCB7IEZMQUdfSU5DTFVERV9QUkVSRUxFQVNFLCBGTEFHX0xPT1NFIH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9jb25zdGFudHMnKVxuXG5jb25zdCBpc051bGxTZXQgPSBjID0+IGMudmFsdWUgPT09ICc8MC4wLjAtMCdcbmNvbnN0IGlzQW55ID0gYyA9PiBjLnZhbHVlID09PSAnJ1xuXG4vLyB0YWtlIGEgc2V0IG9mIGNvbXBhcmF0b3JzIGFuZCBkZXRlcm1pbmUgd2hldGhlciB0aGVyZVxuLy8gZXhpc3RzIGEgdmVyc2lvbiB3aGljaCBjYW4gc2F0aXNmeSBpdFxuY29uc3QgaXNTYXRpc2ZpYWJsZSA9IChjb21wYXJhdG9ycywgb3B0aW9ucykgPT4ge1xuICBsZXQgcmVzdWx0ID0gdHJ1ZVxuICBjb25zdCByZW1haW5pbmdDb21wYXJhdG9ycyA9IGNvbXBhcmF0b3JzLnNsaWNlKClcbiAgbGV0IHRlc3RDb21wYXJhdG9yID0gcmVtYWluaW5nQ29tcGFyYXRvcnMucG9wKClcblxuICB3aGlsZSAocmVzdWx0ICYmIHJlbWFpbmluZ0NvbXBhcmF0b3JzLmxlbmd0aCkge1xuICAgIHJlc3VsdCA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLmV2ZXJ5KChvdGhlckNvbXBhcmF0b3IpID0+IHtcbiAgICAgIHJldHVybiB0ZXN0Q29tcGFyYXRvci5pbnRlcnNlY3RzKG90aGVyQ29tcGFyYXRvciwgb3B0aW9ucylcbiAgICB9KVxuXG4gICAgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vLyBjb21wcmlzZWQgb2YgeHJhbmdlcywgdGlsZGVzLCBzdGFycywgYW5kIGd0bHQncyBhdCB0aGlzIHBvaW50LlxuLy8gYWxyZWFkeSByZXBsYWNlZCB0aGUgaHlwaGVuIHJhbmdlc1xuLy8gdHVybiBpbnRvIGEgc2V0IG9mIEpVU1QgY29tcGFyYXRvcnMuXG5jb25zdCBwYXJzZUNvbXBhcmF0b3IgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygnY29tcCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbXAgPSByZXBsYWNlQ2FyZXRzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCdjYXJldCcsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlVGlsZGVzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCd0aWxkZXMnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVhSYW5nZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3hyYW5nZScsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlU3RhcnMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3N0YXJzJywgY29tcClcbiAgcmV0dXJuIGNvbXBcbn1cblxuY29uc3QgaXNYID0gaWQgPT4gIWlkIHx8IGlkLnRvTG93ZXJDYXNlKCkgPT09ICd4JyB8fCBpZCA9PT0gJyonXG5cbi8vIH4sIH4+IC0tID4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIH4yLCB+Mi54LCB+Mi54LngsIH4+Miwgfj4yLnggfj4yLngueCAtLSA+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIH4yLjAsIH4yLjAueCwgfj4yLjAsIH4+Mi4wLnggLS0gPiA+PTIuMC4wIDwyLjEuMC0wXG4vLyB+MS4yLCB+MS4yLngsIH4+MS4yLCB+PjEuMi54IC0tID4gPj0xLjIuMCA8MS4zLjAtMFxuLy8gfjEuMi4zLCB+PjEuMi4zIC0tID4gPj0xLjIuMyA8MS4zLjAtMFxuLy8gfjEuMi4wLCB+PjEuMi4wIC0tID4gPj0xLjIuMCA8MS4zLjAtMFxuLy8gfjAuMC4xIC0tID4gPj0wLjAuMSA8MC4xLjAtMFxuY29uc3QgcmVwbGFjZVRpbGRlcyA9IChjb21wLCBvcHRpb25zKSA9PlxuICBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcCgoYykgPT4ge1xuICAgIHJldHVybiByZXBsYWNlVGlsZGUoYywgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG5cbmNvbnN0IHJlcGxhY2VUaWxkZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5USUxERUxPT1NFXSA6IHJlW3QuVElMREVdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ3RpbGRlJywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAgPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgLy8gfjEuMiA9PSA+PTEuMi4wIDwxLjMuMC0wXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlVGlsZGUgcHInLCBwcilcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gfjEuMi4zID09ID49MS4yLjMgPDEuMy4wLTBcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygndGlsZGUgcmV0dXJuJywgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gXiAtLSA+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyBeMiwgXjIueCwgXjIueC54IC0tID4gPj0yLjAuMCA8My4wLjAtMFxuLy8gXjIuMCwgXjIuMC54IC0tID4gPj0yLjAuMCA8My4wLjAtMFxuLy8gXjEuMiwgXjEuMi54IC0tID4gPj0xLjIuMCA8Mi4wLjAtMFxuLy8gXjEuMi4zIC0tID4gPj0xLjIuMyA8Mi4wLjAtMFxuLy8gXjEuMi4wIC0tID4gPj0xLjIuMCA8Mi4wLjAtMFxuLy8gXjAuMC4xIC0tID4gPj0wLjAuMSA8MC4wLjItMFxuLy8gXjAuMS4wIC0tID4gPj0wLjEuMCA8MC4yLjAtMFxuY29uc3QgcmVwbGFjZUNhcmV0cyA9IChjb21wLCBvcHRpb25zKSA9PlxuICBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcCgoYykgPT4ge1xuICAgIHJldHVybiByZXBsYWNlQ2FyZXQoYywgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG5cbmNvbnN0IHJlcGxhY2VDYXJldCA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5DQVJFVExPT1NFXSA6IHJlW3QuQ0FSRVRdXG4gIGNvbnN0IHogPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gJy0wJyA6ICcnXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ2NhcmV0JywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAke3p9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7en0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZUNhcmV0IHByJywgcHIpXG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgICAgfSA8JHtNfS4ke219LiR7K3AgKyAxfS0wYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zygnbm8gcHInKVxuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7bX0uJHsrcCArIDF9LTBgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH1cblxuICAgIGRlYnVnKCdjYXJldCByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG5jb25zdCByZXBsYWNlWFJhbmdlcyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlWFJhbmdlcycsIGNvbXAsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wLnNwbGl0KC9cXHMrLykubWFwKChjKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VYUmFuZ2UoYywgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG59XG5cbmNvbnN0IHJlcGxhY2VYUmFuZ2UgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBjb21wID0gY29tcC50cmltKClcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlhSQU5HRUxPT1NFXSA6IHJlW3QuWFJBTkdFXVxuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChyZXQsIGd0bHQsIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ3hSYW5nZScsIGNvbXAsIHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpXG4gICAgY29uc3QgeE0gPSBpc1goTSlcbiAgICBjb25zdCB4bSA9IHhNIHx8IGlzWChtKVxuICAgIGNvbnN0IHhwID0geG0gfHwgaXNYKHApXG4gICAgY29uc3QgYW55WCA9IHhwXG5cbiAgICBpZiAoZ3RsdCA9PT0gJz0nICYmIGFueVgpIHtcbiAgICAgIGd0bHQgPSAnJ1xuICAgIH1cblxuICAgIC8vIGlmIHdlJ3JlIGluY2x1ZGluZyBwcmVyZWxlYXNlcyBpbiB0aGUgbWF0Y2gsIHRoZW4gd2UgbmVlZFxuICAgIC8vIHRvIGZpeCB0aGlzIHRvIC0wLCB0aGUgbG93ZXN0IHBvc3NpYmxlIHByZXJlbGVhc2UgdmFsdWVcbiAgICBwciA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyAnLTAnIDogJydcblxuICAgIGlmICh4TSkge1xuICAgICAgaWYgKGd0bHQgPT09ICc+JyB8fCBndGx0ID09PSAnPCcpIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBhbGxvd2VkXG4gICAgICAgIHJldCA9ICc8MC4wLjAtMCdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgZm9yYmlkZGVuXG4gICAgICAgIHJldCA9ICcqJ1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3RsdCAmJiBhbnlYKSB7XG4gICAgICAvLyB3ZSBrbm93IHBhdGNoIGlzIGFuIHgsIGJlY2F1c2Ugd2UgaGF2ZSBhbnkgeCBhdCBhbGwuXG4gICAgICAvLyByZXBsYWNlIFggd2l0aCAwXG4gICAgICBpZiAoeG0pIHtcbiAgICAgICAgbSA9IDBcbiAgICAgIH1cbiAgICAgIHAgPSAwXG5cbiAgICAgIGlmIChndGx0ID09PSAnPicpIHtcbiAgICAgICAgLy8gPjEgPT4gPj0yLjAuMFxuICAgICAgICAvLyA+MS4yID0+ID49MS4zLjBcbiAgICAgICAgZ3RsdCA9ICc+PSdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICAgIG0gPSAwXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChndGx0ID09PSAnPD0nKSB7XG4gICAgICAgIC8vIDw9MC43LnggaXMgYWN0dWFsbHkgPDAuOC4wLCBzaW5jZSBhbnkgMC43Lnggc2hvdWxkXG4gICAgICAgIC8vIHBhc3MuICBTaW1pbGFybHksIDw9Ny54IGlzIGFjdHVhbGx5IDw4LjAuMCwgZXRjLlxuICAgICAgICBndGx0ID0gJzwnXG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGd0bHQgPT09ICc8Jykge1xuICAgICAgICBwciA9ICctMCdcbiAgICAgIH1cblxuICAgICAgcmV0ID0gYCR7Z3RsdCArIE19LiR7bX0uJHtwfSR7cHJ9YFxuICAgIH0gZWxzZSBpZiAoeG0pIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wJHtwcn0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKHhwKSB7XG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygneFJhbmdlIHJldHVybicsIHJldClcblxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gQmVjYXVzZSAqIGlzIEFORC1lZCB3aXRoIGV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgY29tcGFyYXRvcixcbi8vIGFuZCAnJyBtZWFucyBcImFueSB2ZXJzaW9uXCIsIGp1c3QgcmVtb3ZlIHRoZSAqcyBlbnRpcmVseS5cbmNvbnN0IHJlcGxhY2VTdGFycyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlU3RhcnMnLCBjb21wLCBvcHRpb25zKVxuICAvLyBMb29zZW5lc3MgaXMgaWdub3JlZCBoZXJlLiAgc3RhciBpcyBhbHdheXMgYXMgbG9vc2UgYXMgaXQgZ2V0cyFcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnJlcGxhY2UocmVbdC5TVEFSXSwgJycpXG59XG5cbmNvbnN0IHJlcGxhY2VHVEUwID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VHVEUwJywgY29tcCwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAudHJpbSgpXG4gICAgLnJlcGxhY2UocmVbb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/IHQuR1RFMFBSRSA6IHQuR1RFMF0sICcnKVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHBhc3NlZCB0byBzdHJpbmcucmVwbGFjZShyZVt0LkhZUEhFTlJBTkdFXSlcbi8vIE0sIG0sIHBhdGNoLCBwcmVyZWxlYXNlLCBidWlsZFxuLy8gMS4yIC0gMy40LjUgPT4gPj0xLjIuMCA8PTMuNC41XG4vLyAxLjIuMyAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMC0wIEFueSAzLjQueCB3aWxsIGRvXG4vLyAxLjIgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAtMFxuY29uc3QgaHlwaGVuUmVwbGFjZSA9IGluY1ByID0+ICgkMCxcbiAgZnJvbSwgZk0sIGZtLCBmcCwgZnByLCBmYixcbiAgdG8sIHRNLCB0bSwgdHAsIHRwciwgdGIpID0+IHtcbiAgaWYgKGlzWChmTSkpIHtcbiAgICBmcm9tID0gJydcbiAgfSBlbHNlIGlmIChpc1goZm0pKSB7XG4gICAgZnJvbSA9IGA+PSR7Zk19LjAuMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGlzWChmcCkpIHtcbiAgICBmcm9tID0gYD49JHtmTX0uJHtmbX0uMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGZwcikge1xuICAgIGZyb20gPSBgPj0ke2Zyb219YFxuICB9IGVsc2Uge1xuICAgIGZyb20gPSBgPj0ke2Zyb219JHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH1cblxuICBpZiAoaXNYKHRNKSkge1xuICAgIHRvID0gJydcbiAgfSBlbHNlIGlmIChpc1godG0pKSB7XG4gICAgdG8gPSBgPCR7K3RNICsgMX0uMC4wLTBgXG4gIH0gZWxzZSBpZiAoaXNYKHRwKSkge1xuICAgIHRvID0gYDwke3RNfS4keyt0bSArIDF9LjAtMGBcbiAgfSBlbHNlIGlmICh0cHIpIHtcbiAgICB0byA9IGA8PSR7dE19LiR7dG19LiR7dHB9LSR7dHByfWBcbiAgfSBlbHNlIGlmIChpbmNQcikge1xuICAgIHRvID0gYDwke3RNfS4ke3RtfS4keyt0cCArIDF9LTBgXG4gIH0gZWxzZSB7XG4gICAgdG8gPSBgPD0ke3RvfWBcbiAgfVxuXG4gIHJldHVybiAoYCR7ZnJvbX0gJHt0b31gKS50cmltKClcbn1cblxuY29uc3QgdGVzdFNldCA9IChzZXQsIHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXNldFtpXS50ZXN0KHZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXNcbiAgICAvLyBGb3IgZXhhbXBsZSwgXjEuMi4zLXByLjEgZGVzdWdhcnMgdG8gPj0xLjIuMy1wci4xIDwyLjAuMFxuICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLFxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0J3Mgd2l0aGluIHRoZSByYW5nZSBzZXQgYnkgdGhlIGNvbXBhcmF0b3JzLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWJ1ZyhzZXRbaV0uc2VtdmVyKVxuICAgICAgaWYgKHNldFtpXS5zZW12ZXIgPT09IENvbXBhcmF0b3IuQU5ZKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBhbGxvd2VkID0gc2V0W2ldLnNlbXZlclxuICAgICAgICBpZiAoYWxsb3dlZC5tYWpvciA9PT0gdmVyc2lvbi5tYWpvciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5taW5vciA9PT0gdmVyc2lvbi5taW5vciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5wYXRjaCA9PT0gdmVyc2lvbi5wYXRjaCkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWZXJzaW9uIGhhcyBhIC1wcmUsIGJ1dCBpdCdzIG5vdCBvbmUgb2YgdGhlIG9uZXMgd2UgbGlrZS5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCJjb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IHsgTUFYX0xFTkdUSCwgTUFYX1NBRkVfSU5URUdFUiB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvY29uc3RhbnRzJylcbmNvbnN0IHsgcmUsIHQgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCB7IGNvbXBhcmVJZGVudGlmaWVycyB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaWRlbnRpZmllcnMnKVxuY2xhc3MgU2VtVmVyIHtcbiAgY29uc3RydWN0b3IgKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgICAgaWYgKHZlcnNpb24ubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJlxuICAgICAgICAgIHZlcnNpb24uaW5jbHVkZVByZXJlbGVhc2UgPT09ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgICByZXR1cm4gdmVyc2lvblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmVyc2lvbiA9IHZlcnNpb24udmVyc2lvblxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7cmVxdWlyZSgndXRpbCcpLmluc3BlY3QodmVyc2lvbil9YClcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgdmVyc2lvbiBpcyBsb25nZXIgdGhhbiAke01BWF9MRU5HVEh9IGNoYXJhY3RlcnNgXG4gICAgICApXG4gICAgfVxuXG4gICAgZGVidWcoJ1NlbVZlcicsIHZlcnNpb24sIG9wdGlvbnMpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICAvLyB0aGlzIGlzbid0IGFjdHVhbGx5IHJlbGV2YW50IGZvciB2ZXJzaW9ucywgYnV0IGtlZXAgaXQgc28gdGhhdCB3ZVxuICAgIC8vIGRvbid0IHJ1biBpbnRvIHRyb3VibGUgcGFzc2luZyB0aGlzLm9wdGlvbnMgYXJvdW5kLlxuICAgIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAgIGNvbnN0IG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdKVxuXG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7dmVyc2lvbn1gKVxuICAgIH1cblxuICAgIHRoaXMucmF3ID0gdmVyc2lvblxuXG4gICAgLy8gdGhlc2UgYXJlIGFjdHVhbGx5IG51bWJlcnNcbiAgICB0aGlzLm1ham9yID0gK21bMV1cbiAgICB0aGlzLm1pbm9yID0gK21bMl1cbiAgICB0aGlzLnBhdGNoID0gK21bM11cblxuICAgIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5taW5vciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5taW5vciA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWlub3IgdmVyc2lvbicpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGF0Y2ggPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMucGF0Y2ggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhdGNoIHZlcnNpb24nKVxuICAgIH1cblxuICAgIC8vIG51bWJlcmlmeSBhbnkgcHJlcmVsZWFzZSBudW1lcmljIGlkc1xuICAgIGlmICghbVs0XSkge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gbVs0XS5zcGxpdCgnLicpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgaWYgKC9eWzAtOV0rJC8udGVzdChpZCkpIHtcbiAgICAgICAgICBjb25zdCBudW0gPSAraWRcbiAgICAgICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIG51bVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5idWlsZCA9IG1bNV0gPyBtWzVdLnNwbGl0KCcuJykgOiBbXVxuICAgIHRoaXMuZm9ybWF0KClcbiAgfVxuXG4gIGZvcm1hdCAoKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gYCR7dGhpcy5tYWpvcn0uJHt0aGlzLm1pbm9yfS4ke3RoaXMucGF0Y2h9YFxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICB0aGlzLnZlcnNpb24gKz0gYC0ke3RoaXMucHJlcmVsZWFzZS5qb2luKCcuJyl9YFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvblxuICB9XG5cbiAgY29tcGFyZSAob3RoZXIpIHtcbiAgICBkZWJ1ZygnU2VtVmVyLmNvbXBhcmUnLCB0aGlzLnZlcnNpb24sIHRoaXMub3B0aW9ucywgb3RoZXIpXG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBpZiAodHlwZW9mIG90aGVyID09PSAnc3RyaW5nJyAmJiBvdGhlciA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBpZiAob3RoZXIudmVyc2lvbiA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpXG4gIH1cblxuICBjb21wYXJlTWFpbiAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5taW5vciwgb3RoZXIubWlub3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5wYXRjaCwgb3RoZXIucGF0Y2gpXG4gICAgKVxuICB9XG5cbiAgY29tcGFyZVByZSAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIC8vIE5PVCBoYXZpbmcgYSBwcmVyZWxlYXNlIGlzID4gaGF2aW5nIG9uZVxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfSBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiBvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBhID0gdGhpcy5wcmVyZWxlYXNlW2ldXG4gICAgICBjb25zdCBiID0gb3RoZXIucHJlcmVsZWFzZVtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgY29tcGFyZUJ1aWxkIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgbGV0IGkgPSAwXG4gICAgZG8ge1xuICAgICAgY29uc3QgYSA9IHRoaXMuYnVpbGRbaV1cbiAgICAgIGNvbnN0IGIgPSBvdGhlci5idWlsZFtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgLy8gcHJlbWlub3Igd2lsbCBidW1wIHRoZSB2ZXJzaW9uIHVwIHRvIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UsIGFuZCBpbW1lZGlhdGVseVxuICAvLyBkb3duIHRvIHByZS1yZWxlYXNlLiBwcmVtYWpvciBhbmQgcHJlcGF0Y2ggd29yayB0aGUgc2FtZSB3YXkuXG4gIGluYyAocmVsZWFzZSwgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpIHtcbiAgICBzd2l0Y2ggKHJlbGVhc2UpIHtcbiAgICAgIGNhc2UgJ3ByZW1ham9yJzpcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5taW5vciA9IDBcbiAgICAgICAgdGhpcy5tYWpvcisrXG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3ByZW1pbm9yJzpcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5taW5vcisrXG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3ByZXBhdGNoJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhbHJlYWR5IGEgcHJlcmVsZWFzZSwgaXQgd2lsbCBidW1wIHRvIHRoZSBuZXh0IHZlcnNpb25cbiAgICAgICAgLy8gZHJvcCBhbnkgcHJlcmVsZWFzZXMgdGhhdCBtaWdodCBhbHJlYWR5IGV4aXN0LCBzaW5jZSB0aGV5IGFyZSBub3RcbiAgICAgICAgLy8gcmVsZXZhbnQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSlcbiAgICAgICAgYnJlYWtcbiAgICAgIC8vIElmIHRoZSBpbnB1dCBpcyBhIG5vbi1wcmVyZWxlYXNlIHZlcnNpb24sIHRoaXMgYWN0cyB0aGUgc2FtZSBhc1xuICAgICAgLy8gcHJlcGF0Y2guXG4gICAgICBjYXNlICdwcmVyZWxlYXNlJzpcbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ21ham9yJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1tYWpvciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1ham9yIHZlcnNpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWFqb3IuXG4gICAgICAgIC8vIDEuMC4wLTUgYnVtcHMgdG8gMS4wLjBcbiAgICAgICAgLy8gMS4xLjAgYnVtcHMgdG8gMi4wLjBcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMubWlub3IgIT09IDAgfHxcbiAgICAgICAgICB0aGlzLnBhdGNoICE9PSAwIHx8XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLm1ham9yKytcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pbm9yID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbWlub3InOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1pbm9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWlub3IgdmVyc2lvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtaW5vci5cbiAgICAgICAgLy8gMS4yLjAtNSBidW1wcyB0byAxLjIuMFxuICAgICAgICAvLyAxLjIuMSBidW1wcyB0byAxLjMuMFxuICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5taW5vcisrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3BhdGNoJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uLCBpdCB3aWxsIGluY3JlbWVudCB0aGUgcGF0Y2guXG4gICAgICAgIC8vIElmIGl0IGlzIGEgcHJlLXJlbGVhc2UgaXQgd2lsbCBidW1wIHVwIHRvIHRoZSBzYW1lIHBhdGNoIHZlcnNpb24uXG4gICAgICAgIC8vIDEuMi4wLTUgcGF0Y2hlcyB0byAxLjIuMFxuICAgICAgICAvLyAxLjIuMCBwYXRjaGVzIHRvIDEuMi4xXG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wYXRjaCsrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIC8vIFRoaXMgcHJvYmFibHkgc2hvdWxkbid0IGJlIHVzZWQgcHVibGljbHkuXG4gICAgICAvLyAxLjAuMCAncHJlJyB3b3VsZCBiZWNvbWUgMS4wLjAtMCB3aGljaCBpcyB0aGUgd3JvbmcgZGlyZWN0aW9uLlxuICAgICAgY2FzZSAncHJlJzoge1xuICAgICAgICBjb25zdCBiYXNlID0gTnVtYmVyKGlkZW50aWZpZXJCYXNlKSA/IDEgOiAwXG5cbiAgICAgICAgaWYgKCFpZGVudGlmaWVyICYmIGlkZW50aWZpZXJCYXNlID09PSBmYWxzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6IGlkZW50aWZpZXIgaXMgZW1wdHknKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbYmFzZV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgaSA9IHRoaXMucHJlcmVsZWFzZS5sZW5ndGhcbiAgICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmVyZWxlYXNlW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2VbaV0rK1xuICAgICAgICAgICAgICBpID0gLTJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBkaWRuJ3QgaW5jcmVtZW50IGFueXRoaW5nXG4gICAgICAgICAgICBpZiAoaWRlbnRpZmllciA9PT0gdGhpcy5wcmVyZWxlYXNlLmpvaW4oJy4nKSAmJiBpZGVudGlmaWVyQmFzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogaWRlbnRpZmllciBhbHJlYWR5IGV4aXN0cycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UucHVzaChiYXNlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICAgIC8vIDEuMi4wLWJldGEuMSBidW1wcyB0byAxLjIuMC1iZXRhLjIsXG4gICAgICAgICAgLy8gMS4yLjAtYmV0YS5mb29ibHogb3IgMS4yLjAtYmV0YSBidW1wcyB0byAxLjIuMC1iZXRhLjBcbiAgICAgICAgICBsZXQgcHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCBiYXNlXVxuICAgICAgICAgIGlmIChpZGVudGlmaWVyQmFzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHByZXJlbGVhc2UgPSBbaWRlbnRpZmllcl1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnByZXJlbGVhc2VbMF0sIGlkZW50aWZpZXIpID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odGhpcy5wcmVyZWxlYXNlWzFdKSkge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBwcmVyZWxlYXNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IHByZXJlbGVhc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6ICR7cmVsZWFzZX1gKVxuICAgIH1cbiAgICB0aGlzLmZvcm1hdCgpXG4gICAgdGhpcy5yYXcgPSB0aGlzLnZlcnNpb25cbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VtVmVyXG4iLCJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgY2xlYW4gPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBzID0gcGFyc2UodmVyc2lvbi50cmltKCkucmVwbGFjZSgvXls9dl0rLywgJycpLCBvcHRpb25zKVxuICByZXR1cm4gcyA/IHMudmVyc2lvbiA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gY2xlYW5cbiIsImNvbnN0IGVxID0gcmVxdWlyZSgnLi9lcScpXG5jb25zdCBuZXEgPSByZXF1aXJlKCcuL25lcScpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4vZ3QnKVxuY29uc3QgZ3RlID0gcmVxdWlyZSgnLi9ndGUnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuL2x0JylcbmNvbnN0IGx0ZSA9IHJlcXVpcmUoJy4vbHRlJylcblxuY29uc3QgY21wID0gKGEsIG9wLCBiLCBsb29zZSkgPT4ge1xuICBzd2l0Y2ggKG9wKSB7XG4gICAgY2FzZSAnPT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYSA9IGEudmVyc2lvblxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0Jykge1xuICAgICAgICBiID0gYi52ZXJzaW9uXG4gICAgICB9XG4gICAgICByZXR1cm4gYSA9PT0gYlxuXG4gICAgY2FzZSAnIT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYSA9IGEudmVyc2lvblxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0Jykge1xuICAgICAgICBiID0gYi52ZXJzaW9uXG4gICAgICB9XG4gICAgICByZXR1cm4gYSAhPT0gYlxuXG4gICAgY2FzZSAnJzpcbiAgICBjYXNlICc9JzpcbiAgICBjYXNlICc9PSc6XG4gICAgICByZXR1cm4gZXEoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICchPSc6XG4gICAgICByZXR1cm4gbmVxKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPic6XG4gICAgICByZXR1cm4gZ3QoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc+PSc6XG4gICAgICByZXR1cm4gZ3RlKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPCc6XG4gICAgICByZXR1cm4gbHQoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc8PSc6XG4gICAgICByZXR1cm4gbHRlKGEsIGIsIGxvb3NlKVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgb3BlcmF0b3I6ICR7b3B9YClcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBjbXBcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCB7IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IGNvZXJjZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpIHtcbiAgICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgbGV0IG1hdGNoID0gbnVsbFxuICBpZiAoIW9wdGlvbnMucnRsKSB7XG4gICAgbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKHJlW3QuQ09FUkNFXSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSByaWdodC1tb3N0IGNvZXJjaWJsZSBzdHJpbmcgdGhhdCBkb2VzIG5vdCBzaGFyZVxuICAgIC8vIGEgdGVybWludXMgd2l0aCBhIG1vcmUgbGVmdC13YXJkIGNvZXJjaWJsZSBzdHJpbmcuXG4gICAgLy8gRWcsICcxLjIuMy40JyB3YW50cyB0byBjb2VyY2UgJzIuMy40Jywgbm90ICczLjQnIG9yICc0J1xuICAgIC8vXG4gICAgLy8gV2FsayB0aHJvdWdoIHRoZSBzdHJpbmcgY2hlY2tpbmcgd2l0aCBhIC9nIHJlZ2V4cFxuICAgIC8vIE1hbnVhbGx5IHNldCB0aGUgaW5kZXggc28gYXMgdG8gcGljayB1cCBvdmVybGFwcGluZyBtYXRjaGVzLlxuICAgIC8vIFN0b3Agd2hlbiB3ZSBnZXQgYSBtYXRjaCB0aGF0IGVuZHMgYXQgdGhlIHN0cmluZyBlbmQsIHNpbmNlIG5vXG4gICAgLy8gY29lcmNpYmxlIHN0cmluZyBjYW4gYmUgbW9yZSByaWdodC13YXJkIHdpdGhvdXQgdGhlIHNhbWUgdGVybWludXMuXG4gICAgbGV0IG5leHRcbiAgICB3aGlsZSAoKG5leHQgPSByZVt0LkNPRVJDRVJUTF0uZXhlYyh2ZXJzaW9uKSkgJiZcbiAgICAgICAgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCAhPT0gdmVyc2lvbi5sZW5ndGgpXG4gICAgKSB7XG4gICAgICBpZiAoIW1hdGNoIHx8XG4gICAgICAgICAgICBuZXh0LmluZGV4ICsgbmV4dFswXS5sZW5ndGggIT09IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSB7XG4gICAgICAgIG1hdGNoID0gbmV4dFxuICAgICAgfVxuICAgICAgcmVbdC5DT0VSQ0VSVExdLmxhc3RJbmRleCA9IG5leHQuaW5kZXggKyBuZXh0WzFdLmxlbmd0aCArIG5leHRbMl0ubGVuZ3RoXG4gICAgfVxuICAgIC8vIGxlYXZlIGl0IGluIGEgY2xlYW4gc3RhdGVcbiAgICByZVt0LkNPRVJDRVJUTF0ubGFzdEluZGV4ID0gLTFcbiAgfVxuXG4gIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4gcGFyc2UoYCR7bWF0Y2hbMl19LiR7bWF0Y2hbM10gfHwgJzAnfS4ke21hdGNoWzRdIHx8ICcwJ31gLCBvcHRpb25zKVxufVxubW9kdWxlLmV4cG9ydHMgPSBjb2VyY2VcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGNvbXBhcmVCdWlsZCA9IChhLCBiLCBsb29zZSkgPT4ge1xuICBjb25zdCB2ZXJzaW9uQSA9IG5ldyBTZW1WZXIoYSwgbG9vc2UpXG4gIGNvbnN0IHZlcnNpb25CID0gbmV3IFNlbVZlcihiLCBsb29zZSlcbiAgcmV0dXJuIHZlcnNpb25BLmNvbXBhcmUodmVyc2lvbkIpIHx8IHZlcnNpb25BLmNvbXBhcmVCdWlsZCh2ZXJzaW9uQilcbn1cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZUJ1aWxkXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGNvbXBhcmVMb29zZSA9IChhLCBiKSA9PiBjb21wYXJlKGEsIGIsIHRydWUpXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVMb29zZVxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgY29tcGFyZSA9IChhLCBiLCBsb29zZSkgPT5cbiAgbmV3IFNlbVZlcihhLCBsb29zZSkuY29tcGFyZShuZXcgU2VtVmVyKGIsIGxvb3NlKSlcblxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlXG4iLCJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UuanMnKVxuXG5jb25zdCBkaWZmID0gKHZlcnNpb24xLCB2ZXJzaW9uMikgPT4ge1xuICBjb25zdCB2MSA9IHBhcnNlKHZlcnNpb24xLCBudWxsLCB0cnVlKVxuICBjb25zdCB2MiA9IHBhcnNlKHZlcnNpb24yLCBudWxsLCB0cnVlKVxuICBjb25zdCBjb21wYXJpc29uID0gdjEuY29tcGFyZSh2MilcblxuICBpZiAoY29tcGFyaXNvbiA9PT0gMCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCB2MUhpZ2hlciA9IGNvbXBhcmlzb24gPiAwXG4gIGNvbnN0IGhpZ2hWZXJzaW9uID0gdjFIaWdoZXIgPyB2MSA6IHYyXG4gIGNvbnN0IGxvd1ZlcnNpb24gPSB2MUhpZ2hlciA/IHYyIDogdjFcbiAgY29uc3QgaGlnaEhhc1ByZSA9ICEhaGlnaFZlcnNpb24ucHJlcmVsZWFzZS5sZW5ndGhcblxuICAvLyBhZGQgdGhlIGBwcmVgIHByZWZpeCBpZiB3ZSBhcmUgZ29pbmcgdG8gYSBwcmVyZWxlYXNlIHZlcnNpb25cbiAgY29uc3QgcHJlZml4ID0gaGlnaEhhc1ByZSA/ICdwcmUnIDogJydcblxuICBpZiAodjEubWFqb3IgIT09IHYyLm1ham9yKSB7XG4gICAgcmV0dXJuIHByZWZpeCArICdtYWpvcidcbiAgfVxuXG4gIGlmICh2MS5taW5vciAhPT0gdjIubWlub3IpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgJ21pbm9yJ1xuICB9XG5cbiAgaWYgKHYxLnBhdGNoICE9PSB2Mi5wYXRjaCkge1xuICAgIHJldHVybiBwcmVmaXggKyAncGF0Y2gnXG4gIH1cblxuICAvLyBhdCB0aGlzIHBvaW50IHdlIGtub3cgc3RhYmxlIHZlcnNpb25zIG1hdGNoIGJ1dCBvdmVyYWxsIHZlcnNpb25zIGFyZSBub3QgZXF1YWwsXG4gIC8vIHNvIGVpdGhlciB0aGV5IGFyZSBib3RoIHByZXJlbGVhc2VzLCBvciB0aGUgbG93ZXIgdmVyc2lvbiBpcyBhIHByZXJlbGVhc2VcblxuICBpZiAoaGlnaEhhc1ByZSkge1xuICAgIC8vIGhpZ2ggYW5kIGxvdyBhcmUgcHJlbGVhc2VzXG4gICAgcmV0dXJuICdwcmVyZWxlYXNlJ1xuICB9XG5cbiAgaWYgKGxvd1ZlcnNpb24ucGF0Y2gpIHtcbiAgICAvLyBhbnl0aGluZyBoaWdoZXIgdGhhbiBhIHBhdGNoIGJ1bXAgd291bGQgcmVzdWx0IGluIHRoZSB3cm9uZyB2ZXJzaW9uXG4gICAgcmV0dXJuICdwYXRjaCdcbiAgfVxuXG4gIGlmIChsb3dWZXJzaW9uLm1pbm9yKSB7XG4gICAgLy8gYW55dGhpbmcgaGlnaGVyIHRoYW4gYSBtaW5vciBidW1wIHdvdWxkIHJlc3VsdCBpbiB0aGUgd3JvbmcgdmVyc2lvblxuICAgIHJldHVybiAnbWlub3InXG4gIH1cblxuICAvLyBidW1waW5nIG1ham9yL21pbm9yL3BhdGNoIGFsbCBoYXZlIHNhbWUgcmVzdWx0XG4gIHJldHVybiAnbWFqb3InXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGlmZlxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBlcSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPT09IDBcbm1vZHVsZS5leHBvcnRzID0gZXFcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZ3QgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID4gMFxubW9kdWxlLmV4cG9ydHMgPSBndFxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBndGUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID49IDBcbm1vZHVsZS5leHBvcnRzID0gZ3RlXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5cbmNvbnN0IGluYyA9ICh2ZXJzaW9uLCByZWxlYXNlLCBvcHRpb25zLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSkgPT4ge1xuICBpZiAodHlwZW9mIChvcHRpb25zKSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZGVudGlmaWVyQmFzZSA9IGlkZW50aWZpZXJcbiAgICBpZGVudGlmaWVyID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIoXG4gICAgICB2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyID8gdmVyc2lvbi52ZXJzaW9uIDogdmVyc2lvbixcbiAgICAgIG9wdGlvbnNcbiAgICApLmluYyhyZWxlYXNlLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSkudmVyc2lvblxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gaW5jXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGx0ID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8IDBcbm1vZHVsZS5leHBvcnRzID0gbHRcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbHRlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGx0ZVxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWFqb3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1ham9yXG5tb2R1bGUuZXhwb3J0cyA9IG1ham9yXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBtaW5vciA9IChhLCBsb29zZSkgPT4gbmV3IFNlbVZlcihhLCBsb29zZSkubWlub3Jcbm1vZHVsZS5leHBvcnRzID0gbWlub3JcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbmVxID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSAhPT0gMFxubW9kdWxlLmV4cG9ydHMgPSBuZXFcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhcnNlID0gKHZlcnNpb24sIG9wdGlvbnMsIHRocm93RXJyb3JzID0gZmFsc2UpID0+IHtcbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICByZXR1cm4gdmVyc2lvblxuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoIXRocm93RXJyb3JzKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB0aHJvdyBlclxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhdGNoID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5wYXRjaFxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaFxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHByZXJlbGVhc2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gKHBhcnNlZCAmJiBwYXJzZWQucHJlcmVsZWFzZS5sZW5ndGgpID8gcGFyc2VkLnByZXJlbGVhc2UgOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IHByZXJlbGVhc2VcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgcmNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYiwgYSwgbG9vc2UpXG5tb2R1bGUuZXhwb3J0cyA9IHJjb21wYXJlXG4iLCJjb25zdCBjb21wYXJlQnVpbGQgPSByZXF1aXJlKCcuL2NvbXBhcmUtYnVpbGQnKVxuY29uc3QgcnNvcnQgPSAobGlzdCwgbG9vc2UpID0+IGxpc3Quc29ydCgoYSwgYikgPT4gY29tcGFyZUJ1aWxkKGIsIGEsIGxvb3NlKSlcbm1vZHVsZS5leHBvcnRzID0gcnNvcnRcbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBzYXRpc2ZpZXMgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gcmFuZ2UudGVzdCh2ZXJzaW9uKVxufVxubW9kdWxlLmV4cG9ydHMgPSBzYXRpc2ZpZXNcbiIsImNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vY29tcGFyZS1idWlsZCcpXG5jb25zdCBzb3J0ID0gKGxpc3QsIGxvb3NlKSA9PiBsaXN0LnNvcnQoKGEsIGIpID0+IGNvbXBhcmVCdWlsZChhLCBiLCBsb29zZSkpXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCB2YWxpZCA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHYgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gdiA/IHYudmVyc2lvbiA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRcbiIsIi8vIGp1c3QgcHJlLWxvYWQgYWxsIHRoZSBzdHVmZiB0aGF0IGluZGV4LmpzIGxhemlseSBleHBvcnRzXG5jb25zdCBpbnRlcm5hbFJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9yZScpXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGlkZW50aWZpZXJzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9pZGVudGlmaWVycycpXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3BhcnNlJylcbmNvbnN0IHZhbGlkID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvdmFsaWQnKVxuY29uc3QgY2xlYW4gPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jbGVhbicpXG5jb25zdCBpbmMgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9pbmMnKVxuY29uc3QgZGlmZiA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2RpZmYnKVxuY29uc3QgbWFqb3IgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9tYWpvcicpXG5jb25zdCBtaW5vciA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL21pbm9yJylcbmNvbnN0IHBhdGNoID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcGF0Y2gnKVxuY29uc3QgcHJlcmVsZWFzZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3ByZXJlbGVhc2UnKVxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUnKVxuY29uc3QgcmNvbXBhcmUgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9yY29tcGFyZScpXG5jb25zdCBjb21wYXJlTG9vc2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlLWxvb3NlJylcbmNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQnKVxuY29uc3Qgc29ydCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3NvcnQnKVxuY29uc3QgcnNvcnQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9yc29ydCcpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2d0JylcbmNvbnN0IGx0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbHQnKVxuY29uc3QgZXEgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9lcScpXG5jb25zdCBuZXEgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9uZXEnKVxuY29uc3QgZ3RlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvZ3RlJylcbmNvbnN0IGx0ZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2x0ZScpXG5jb25zdCBjbXAgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jbXAnKVxuY29uc3QgY29lcmNlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29lcmNlJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuL2NsYXNzZXMvY29tcGFyYXRvcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9zYXRpc2ZpZXMnKVxuY29uc3QgdG9Db21wYXJhdG9ycyA9IHJlcXVpcmUoJy4vcmFuZ2VzL3RvLWNvbXBhcmF0b3JzJylcbmNvbnN0IG1heFNhdGlzZnlpbmcgPSByZXF1aXJlKCcuL3Jhbmdlcy9tYXgtc2F0aXNmeWluZycpXG5jb25zdCBtaW5TYXRpc2Z5aW5nID0gcmVxdWlyZSgnLi9yYW5nZXMvbWluLXNhdGlzZnlpbmcnKVxuY29uc3QgbWluVmVyc2lvbiA9IHJlcXVpcmUoJy4vcmFuZ2VzL21pbi12ZXJzaW9uJylcbmNvbnN0IHZhbGlkUmFuZ2UgPSByZXF1aXJlKCcuL3Jhbmdlcy92YWxpZCcpXG5jb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9yYW5nZXMvb3V0c2lkZScpXG5jb25zdCBndHIgPSByZXF1aXJlKCcuL3Jhbmdlcy9ndHInKVxuY29uc3QgbHRyID0gcmVxdWlyZSgnLi9yYW5nZXMvbHRyJylcbmNvbnN0IGludGVyc2VjdHMgPSByZXF1aXJlKCcuL3Jhbmdlcy9pbnRlcnNlY3RzJylcbmNvbnN0IHNpbXBsaWZ5UmFuZ2UgPSByZXF1aXJlKCcuL3Jhbmdlcy9zaW1wbGlmeScpXG5jb25zdCBzdWJzZXQgPSByZXF1aXJlKCcuL3Jhbmdlcy9zdWJzZXQnKVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlLFxuICB2YWxpZCxcbiAgY2xlYW4sXG4gIGluYyxcbiAgZGlmZixcbiAgbWFqb3IsXG4gIG1pbm9yLFxuICBwYXRjaCxcbiAgcHJlcmVsZWFzZSxcbiAgY29tcGFyZSxcbiAgcmNvbXBhcmUsXG4gIGNvbXBhcmVMb29zZSxcbiAgY29tcGFyZUJ1aWxkLFxuICBzb3J0LFxuICByc29ydCxcbiAgZ3QsXG4gIGx0LFxuICBlcSxcbiAgbmVxLFxuICBndGUsXG4gIGx0ZSxcbiAgY21wLFxuICBjb2VyY2UsXG4gIENvbXBhcmF0b3IsXG4gIFJhbmdlLFxuICBzYXRpc2ZpZXMsXG4gIHRvQ29tcGFyYXRvcnMsXG4gIG1heFNhdGlzZnlpbmcsXG4gIG1pblNhdGlzZnlpbmcsXG4gIG1pblZlcnNpb24sXG4gIHZhbGlkUmFuZ2UsXG4gIG91dHNpZGUsXG4gIGd0cixcbiAgbHRyLFxuICBpbnRlcnNlY3RzLFxuICBzaW1wbGlmeVJhbmdlLFxuICBzdWJzZXQsXG4gIFNlbVZlcixcbiAgcmU6IGludGVybmFsUmUucmUsXG4gIHNyYzogaW50ZXJuYWxSZS5zcmMsXG4gIHRva2VuczogaW50ZXJuYWxSZS50LFxuICBTRU1WRVJfU1BFQ19WRVJTSU9OOiBjb25zdGFudHMuU0VNVkVSX1NQRUNfVkVSU0lPTixcbiAgUkVMRUFTRV9UWVBFUzogY29uc3RhbnRzLlJFTEVBU0VfVFlQRVMsXG4gIGNvbXBhcmVJZGVudGlmaWVyczogaWRlbnRpZmllcnMuY29tcGFyZUlkZW50aWZpZXJzLFxuICByY29tcGFyZUlkZW50aWZpZXJzOiBpZGVudGlmaWVycy5yY29tcGFyZUlkZW50aWZpZXJzLFxufVxuIiwiLy8gTm90ZTogdGhpcyBpcyB0aGUgc2VtdmVyLm9yZyB2ZXJzaW9uIG9mIHRoZSBzcGVjIHRoYXQgaXQgaW1wbGVtZW50c1xuLy8gTm90IG5lY2Vzc2FyaWx5IHRoZSBwYWNrYWdlIHZlcnNpb24gb2YgdGhpcyBjb2RlLlxuY29uc3QgU0VNVkVSX1NQRUNfVkVSU0lPTiA9ICcyLjAuMCdcblxuY29uc3QgTUFYX0xFTkdUSCA9IDI1NlxuY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA5MDA3MTk5MjU0NzQwOTkxXG5cbi8vIE1heCBzYWZlIHNlZ21lbnQgbGVuZ3RoIGZvciBjb2VyY2lvbi5cbmNvbnN0IE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggPSAxNlxuXG5jb25zdCBSRUxFQVNFX1RZUEVTID0gW1xuICAnbWFqb3InLFxuICAncHJlbWFqb3InLFxuICAnbWlub3InLFxuICAncHJlbWlub3InLFxuICAncGF0Y2gnLFxuICAncHJlcGF0Y2gnLFxuICAncHJlcmVsZWFzZScsXG5dXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBNQVhfTEVOR1RILFxuICBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RILFxuICBNQVhfU0FGRV9JTlRFR0VSLFxuICBSRUxFQVNFX1RZUEVTLFxuICBTRU1WRVJfU1BFQ19WRVJTSU9OLFxuICBGTEFHX0lOQ0xVREVfUFJFUkVMRUFTRTogMGIwMDEsXG4gIEZMQUdfTE9PU0U6IDBiMDEwLFxufVxuIiwiY29uc3QgZGVidWcgPSAoXG4gIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICBwcm9jZXNzLmVudiAmJlxuICBcIlwiICYmXG4gIC9cXGJzZW12ZXJcXGIvaS50ZXN0KFwiXCIpXG4pID8gKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoJ1NFTVZFUicsIC4uLmFyZ3MpXG4gIDogKCkgPT4ge31cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJ1Z1xuIiwiY29uc3QgbnVtZXJpYyA9IC9eWzAtOV0rJC9cbmNvbnN0IGNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiB7XG4gIGNvbnN0IGFudW0gPSBudW1lcmljLnRlc3QoYSlcbiAgY29uc3QgYm51bSA9IG51bWVyaWMudGVzdChiKVxuXG4gIGlmIChhbnVtICYmIGJudW0pIHtcbiAgICBhID0gK2FcbiAgICBiID0gK2JcbiAgfVxuXG4gIHJldHVybiBhID09PSBiID8gMFxuICAgIDogKGFudW0gJiYgIWJudW0pID8gLTFcbiAgICA6IChibnVtICYmICFhbnVtKSA/IDFcbiAgICA6IGEgPCBiID8gLTFcbiAgICA6IDFcbn1cblxuY29uc3QgcmNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiBjb21wYXJlSWRlbnRpZmllcnMoYiwgYSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVycyxcbn1cbiIsIi8vIHBhcnNlIG91dCBqdXN0IHRoZSBvcHRpb25zIHdlIGNhcmUgYWJvdXRcbmNvbnN0IGxvb3NlT3B0aW9uID0gT2JqZWN0LmZyZWV6ZSh7IGxvb3NlOiB0cnVlIH0pXG5jb25zdCBlbXB0eU9wdHMgPSBPYmplY3QuZnJlZXplKHsgfSlcbmNvbnN0IHBhcnNlT3B0aW9ucyA9IG9wdGlvbnMgPT4ge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICByZXR1cm4gZW1wdHlPcHRzXG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGxvb3NlT3B0aW9uXG4gIH1cblxuICByZXR1cm4gb3B0aW9uc1xufVxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZU9wdGlvbnNcbiIsImNvbnN0IHsgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuL2RlYnVnJylcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9XG5cbi8vIFRoZSBhY3R1YWwgcmVnZXhwcyBnbyBvbiBleHBvcnRzLnJlXG5jb25zdCByZSA9IGV4cG9ydHMucmUgPSBbXVxuY29uc3Qgc3JjID0gZXhwb3J0cy5zcmMgPSBbXVxuY29uc3QgdCA9IGV4cG9ydHMudCA9IHt9XG5sZXQgUiA9IDBcblxuY29uc3QgY3JlYXRlVG9rZW4gPSAobmFtZSwgdmFsdWUsIGlzR2xvYmFsKSA9PiB7XG4gIGNvbnN0IGluZGV4ID0gUisrXG4gIGRlYnVnKG5hbWUsIGluZGV4LCB2YWx1ZSlcbiAgdFtuYW1lXSA9IGluZGV4XG4gIHNyY1tpbmRleF0gPSB2YWx1ZVxuICByZVtpbmRleF0gPSBuZXcgUmVnRXhwKHZhbHVlLCBpc0dsb2JhbCA/ICdnJyA6IHVuZGVmaW5lZClcbn1cblxuLy8gVGhlIGZvbGxvd2luZyBSZWd1bGFyIEV4cHJlc3Npb25zIGNhbiBiZSB1c2VkIGZvciB0b2tlbml6aW5nLFxuLy8gdmFsaWRhdGluZywgYW5kIHBhcnNpbmcgU2VtVmVyIHZlcnNpb24gc3RyaW5ncy5cblxuLy8gIyMgTnVtZXJpYyBJZGVudGlmaWVyXG4vLyBBIHNpbmdsZSBgMGAsIG9yIGEgbm9uLXplcm8gZGlnaXQgZm9sbG93ZWQgYnkgemVybyBvciBtb3JlIGRpZ2l0cy5cblxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSJywgJzB8WzEtOV1cXFxcZConKVxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSTE9PU0UnLCAnWzAtOV0rJylcblxuLy8gIyMgTm9uLW51bWVyaWMgSWRlbnRpZmllclxuLy8gWmVybyBvciBtb3JlIGRpZ2l0cywgZm9sbG93ZWQgYnkgYSBsZXR0ZXIgb3IgaHlwaGVuLCBhbmQgdGhlbiB6ZXJvIG9yXG4vLyBtb3JlIGxldHRlcnMsIGRpZ2l0cywgb3IgaHlwaGVucy5cblxuY3JlYXRlVG9rZW4oJ05PTk5VTUVSSUNJREVOVElGSUVSJywgJ1xcXFxkKlthLXpBLVotXVthLXpBLVowLTktXSonKVxuXG4vLyAjIyBNYWluIFZlcnNpb25cbi8vIFRocmVlIGRvdC1zZXBhcmF0ZWQgbnVtZXJpYyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ01BSU5WRVJTSU9OJywgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KWApXG5cbmNyZWF0ZVRva2VuKCdNQUlOVkVSU0lPTkxPT1NFJywgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlgKVxuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uIElkZW50aWZpZXJcbi8vIEEgbnVtZXJpYyBpZGVudGlmaWVyLCBvciBhIG5vbi1udW1lcmljIGlkZW50aWZpZXIuXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFSURFTlRJRklFUicsIGAoPzoke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXVxufXwke3NyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXX0pYClcblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VJREVOVElGSUVSTE9PU0UnLCBgKD86JHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXVxufXwke3NyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXX0pYClcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvblxuLy8gSHlwaGVuLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBkb3Qtc2VwYXJhdGVkIHByZS1yZWxlYXNlIHZlcnNpb25cbi8vIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRScsIGAoPzotKCR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJdXG59KD86XFxcXC4ke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXX0pKikpYClcblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VMT09TRScsIGAoPzotPygke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdXG59KD86XFxcXC4ke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdfSkqKSlgKVxuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YSBJZGVudGlmaWVyXG4vLyBBbnkgY29tYmluYXRpb24gb2YgZGlnaXRzLCBsZXR0ZXJzLCBvciBoeXBoZW5zLlxuXG5jcmVhdGVUb2tlbignQlVJTERJREVOVElGSUVSJywgJ1swLTlBLVphLXotXSsnKVxuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YVxuLy8gUGx1cyBzaWduLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBwZXJpb2Qtc2VwYXJhdGVkIGJ1aWxkIG1ldGFkYXRhXG4vLyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ0JVSUxEJywgYCg/OlxcXFwrKCR7c3JjW3QuQlVJTERJREVOVElGSUVSXVxufSg/OlxcXFwuJHtzcmNbdC5CVUlMRElERU5USUZJRVJdfSkqKSlgKVxuXG4vLyAjIyBGdWxsIFZlcnNpb24gU3RyaW5nXG4vLyBBIG1haW4gdmVyc2lvbiwgZm9sbG93ZWQgb3B0aW9uYWxseSBieSBhIHByZS1yZWxlYXNlIHZlcnNpb24gYW5kXG4vLyBidWlsZCBtZXRhZGF0YS5cblxuLy8gTm90ZSB0aGF0IHRoZSBvbmx5IG1ham9yLCBtaW5vciwgcGF0Y2gsIGFuZCBwcmUtcmVsZWFzZSBzZWN0aW9ucyBvZlxuLy8gdGhlIHZlcnNpb24gc3RyaW5nIGFyZSBjYXB0dXJpbmcgZ3JvdXBzLiAgVGhlIGJ1aWxkIG1ldGFkYXRhIGlzIG5vdCBhXG4vLyBjYXB0dXJpbmcgZ3JvdXAsIGJlY2F1c2UgaXQgc2hvdWxkIG5vdCBldmVyIGJlIHVzZWQgaW4gdmVyc2lvblxuLy8gY29tcGFyaXNvbi5cblxuY3JlYXRlVG9rZW4oJ0ZVTExQTEFJTicsIGB2PyR7c3JjW3QuTUFJTlZFUlNJT05dXG59JHtzcmNbdC5QUkVSRUxFQVNFXX0/JHtcbiAgc3JjW3QuQlVJTERdfT9gKVxuXG5jcmVhdGVUb2tlbignRlVMTCcsIGBeJHtzcmNbdC5GVUxMUExBSU5dfSRgKVxuXG4vLyBsaWtlIGZ1bGwsIGJ1dCBhbGxvd3MgdjEuMi4zIGFuZCA9MS4yLjMsIHdoaWNoIHBlb3BsZSBkbyBzb21ldGltZXMuXG4vLyBhbHNvLCAxLjAuMGFscGhhMSAocHJlcmVsZWFzZSB3aXRob3V0IHRoZSBoeXBoZW4pIHdoaWNoIGlzIHByZXR0eVxuLy8gY29tbW9uIGluIHRoZSBucG0gcmVnaXN0cnkuXG5jcmVhdGVUb2tlbignTE9PU0VQTEFJTicsIGBbdj1cXFxcc10qJHtzcmNbdC5NQUlOVkVSU0lPTkxPT1NFXVxufSR7c3JjW3QuUFJFUkVMRUFTRUxPT1NFXX0/JHtcbiAgc3JjW3QuQlVJTERdfT9gKVxuXG5jcmVhdGVUb2tlbignTE9PU0UnLCBgXiR7c3JjW3QuTE9PU0VQTEFJTl19JGApXG5cbmNyZWF0ZVRva2VuKCdHVExUJywgJygoPzo8fD4pPz0/KScpXG5cbi8vIFNvbWV0aGluZyBsaWtlIFwiMi4qXCIgb3IgXCIxLjIueFwiLlxuLy8gTm90ZSB0aGF0IFwieC54XCIgaXMgYSB2YWxpZCB4UmFuZ2UgaWRlbnRpZmVyLCBtZWFuaW5nIFwiYW55IHZlcnNpb25cIlxuLy8gT25seSB0aGUgZmlyc3QgaXRlbSBpcyBzdHJpY3RseSByZXF1aXJlZC5cbmNyZWF0ZVRva2VuKCdYUkFOR0VJREVOVElGSUVSTE9PU0UnLCBgJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX18eHxYfFxcXFwqYClcbmNyZWF0ZVRva2VuKCdYUkFOR0VJREVOVElGSUVSJywgYCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfXx4fFh8XFxcXCpgKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFUExBSU4nLCBgW3Y9XFxcXHNdKigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzoke3NyY1t0LlBSRVJFTEVBU0VdfSk/JHtcbiAgICAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXX0/YCArXG4gICAgICAgICAgICAgICAgICAgYCk/KT9gKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFUExBSU5MT09TRScsIGBbdj1cXFxcc10qKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuUFJFUkVMRUFTRUxPT1NFXX0pPyR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXX0/YCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKT8pP2ApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqJHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignWFJBTkdFTE9PU0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQ29lcmNpb24uXG4vLyBFeHRyYWN0IGFueXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgYmUgYSBwYXJ0IG9mIGEgdmFsaWQgc2VtdmVyXG5jcmVhdGVUb2tlbignQ09FUkNFJywgYCR7JyhefFteXFxcXGRdKScgK1xuICAgICAgICAgICAgICAnKFxcXFxkezEsJ30ke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSlgICtcbiAgICAgICAgICAgICAgYCg/OlxcXFwuKFxcXFxkezEsJHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pKT9gICtcbiAgICAgICAgICAgICAgYCg/OlxcXFwuKFxcXFxkezEsJHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pKT9gICtcbiAgICAgICAgICAgICAgYCg/OiR8W15cXFxcZF0pYClcbmNyZWF0ZVRva2VuKCdDT0VSQ0VSVEwnLCBzcmNbdC5DT0VSQ0VdLCB0cnVlKVxuXG4vLyBUaWxkZSByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwicmVhc29uYWJseSBhdCBvciBncmVhdGVyIHRoYW5cIlxuY3JlYXRlVG9rZW4oJ0xPTkVUSUxERScsICcoPzp+Pj8pJylcblxuY3JlYXRlVG9rZW4oJ1RJTERFVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuTE9ORVRJTERFXX1cXFxccytgLCB0cnVlKVxuZXhwb3J0cy50aWxkZVRyaW1SZXBsYWNlID0gJyQxfidcblxuY3JlYXRlVG9rZW4oJ1RJTERFJywgYF4ke3NyY1t0LkxPTkVUSUxERV19JHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignVElMREVMT09TRScsIGBeJHtzcmNbdC5MT05FVElMREVdfSR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIENhcmV0IHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJhdCBsZWFzdCBhbmQgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aFwiXG5jcmVhdGVUb2tlbignTE9ORUNBUkVUJywgJyg/OlxcXFxeKScpXG5cbmNyZWF0ZVRva2VuKCdDQVJFVFRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkxPTkVDQVJFVF19XFxcXHMrYCwgdHJ1ZSlcbmV4cG9ydHMuY2FyZXRUcmltUmVwbGFjZSA9ICckMV4nXG5cbmNyZWF0ZVRva2VuKCdDQVJFVCcsIGBeJHtzcmNbdC5MT05FQ0FSRVRdfSR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKVxuY3JlYXRlVG9rZW4oJ0NBUkVUTE9PU0UnLCBgXiR7c3JjW3QuTE9ORUNBUkVUXX0ke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBBIHNpbXBsZSBndC9sdC9lcSB0aGluZywgb3IganVzdCBcIlwiIHRvIGluZGljYXRlIFwiYW55IHZlcnNpb25cIlxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1JMT09TRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyooJHtzcmNbdC5MT09TRVBMQUlOXX0pJHxeJGApXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUicsIGBeJHtzcmNbdC5HVExUXX1cXFxccyooJHtzcmNbdC5GVUxMUExBSU5dfSkkfF4kYClcblxuLy8gQW4gZXhwcmVzc2lvbiB0byBzdHJpcCBhbnkgd2hpdGVzcGFjZSBiZXR3ZWVuIHRoZSBndGx0IGFuZCB0aGUgdGhpbmdcbi8vIGl0IG1vZGlmaWVzLCBzbyB0aGF0IGA+IDEuMi4zYCA9PT4gYD4xLjIuM2BcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9SVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuR1RMVF1cbn1cXFxccyooJHtzcmNbdC5MT09TRVBMQUlOXX18JHtzcmNbdC5YUkFOR0VQTEFJTl19KWAsIHRydWUpXG5leHBvcnRzLmNvbXBhcmF0b3JUcmltUmVwbGFjZSA9ICckMSQyJDMnXG5cbi8vIFNvbWV0aGluZyBsaWtlIGAxLjIuMyAtIDEuMi40YFxuLy8gTm90ZSB0aGF0IHRoZXNlIGFsbCB1c2UgdGhlIGxvb3NlIGZvcm0sIGJlY2F1c2UgdGhleSdsbCBiZVxuLy8gY2hlY2tlZCBhZ2FpbnN0IGVpdGhlciB0aGUgc3RyaWN0IG9yIGxvb3NlIGNvbXBhcmF0b3IgZm9ybVxuLy8gbGF0ZXIuXG5jcmVhdGVUb2tlbignSFlQSEVOUkFOR0UnLCBgXlxcXFxzKigke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYFxcXFxzKy1cXFxccytgICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgICtcbiAgICAgICAgICAgICAgICAgICBgXFxcXHMqJGApXG5cbmNyZWF0ZVRva2VuKCdIWVBIRU5SQU5HRUxPT1NFJywgYF5cXFxccyooJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxcXHMrLVxcXFxzK2AgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcXFxccyokYClcblxuLy8gU3RhciByYW5nZXMgYmFzaWNhbGx5IGp1c3QgYWxsb3cgYW55dGhpbmcgYXQgYWxsLlxuY3JlYXRlVG9rZW4oJ1NUQVInLCAnKDx8Pik/PT9cXFxccypcXFxcKicpXG4vLyA+PTAuMC4wIGlzIGxpa2UgYSBzdGFyXG5jcmVhdGVUb2tlbignR1RFMCcsICdeXFxcXHMqPj1cXFxccyowXFxcXC4wXFxcXC4wXFxcXHMqJCcpXG5jcmVhdGVUb2tlbignR1RFMFBSRScsICdeXFxcXHMqPj1cXFxccyowXFxcXC4wXFxcXC4wLTBcXFxccyokJylcbiIsIi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZS5cbmNvbnN0IG91dHNpZGUgPSByZXF1aXJlKCcuL291dHNpZGUnKVxuY29uc3QgZ3RyID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPicsIG9wdGlvbnMpXG5tb2R1bGUuZXhwb3J0cyA9IGd0clxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IGludGVyc2VjdHMgPSAocjEsIHIyLCBvcHRpb25zKSA9PiB7XG4gIHIxID0gbmV3IFJhbmdlKHIxLCBvcHRpb25zKVxuICByMiA9IG5ldyBSYW5nZShyMiwgb3B0aW9ucylcbiAgcmV0dXJuIHIxLmludGVyc2VjdHMocjIsIG9wdGlvbnMpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGludGVyc2VjdHNcbiIsImNvbnN0IG91dHNpZGUgPSByZXF1aXJlKCcuL291dHNpZGUnKVxuLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgbGVzcyB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlXG5jb25zdCBsdHIgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc8Jywgb3B0aW9ucylcbm1vZHVsZS5leHBvcnRzID0gbHRyXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG5jb25zdCBtYXhTYXRpc2Z5aW5nID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBsZXQgbWF4ID0gbnVsbFxuICBsZXQgbWF4U1YgPSBudWxsXG4gIGxldCByYW5nZU9iaiA9IG51bGxcbiAgdHJ5IHtcbiAgICByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZlcnNpb25zLmZvckVhY2goKHYpID0+IHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtYXggfHwgbWF4U1YuY29tcGFyZSh2KSA9PT0gLTEpIHtcbiAgICAgICAgLy8gY29tcGFyZShtYXgsIHYsIHRydWUpXG4gICAgICAgIG1heCA9IHZcbiAgICAgICAgbWF4U1YgPSBuZXcgU2VtVmVyKG1heCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtYXhcbn1cbm1vZHVsZS5leHBvcnRzID0gbWF4U2F0aXNmeWluZ1xuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IG1pblNhdGlzZnlpbmcgPSAodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGxldCBtaW4gPSBudWxsXG4gIGxldCBtaW5TViA9IG51bGxcbiAgbGV0IHJhbmdlT2JqID0gbnVsbFxuICB0cnkge1xuICAgIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaCgodikgPT4ge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7XG4gICAgICAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgICBpZiAoIW1pbiB8fCBtaW5TVi5jb21wYXJlKHYpID09PSAxKSB7XG4gICAgICAgIC8vIGNvbXBhcmUobWluLCB2LCB0cnVlKVxuICAgICAgICBtaW4gPSB2XG4gICAgICAgIG1pblNWID0gbmV3IFNlbVZlcihtaW4sIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWluXG59XG5tb2R1bGUuZXhwb3J0cyA9IG1pblNhdGlzZnlpbmdcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndCcpXG5cbmNvbnN0IG1pblZlcnNpb24gPSAocmFuZ2UsIGxvb3NlKSA9PiB7XG4gIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSlcblxuICBsZXQgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAnKVxuICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAtMCcpXG4gIGlmIChyYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICBtaW52ZXIgPSBudWxsXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV1cblxuICAgIGxldCBzZXRNaW4gPSBudWxsXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaCgoY29tcGFyYXRvcikgPT4ge1xuICAgICAgLy8gQ2xvbmUgdG8gYXZvaWQgbWFuaXB1bGF0aW5nIHRoZSBjb21wYXJhdG9yJ3Mgc2VtdmVyIG9iamVjdC5cbiAgICAgIGNvbnN0IGNvbXB2ZXIgPSBuZXcgU2VtVmVyKGNvbXBhcmF0b3Iuc2VtdmVyLnZlcnNpb24pXG4gICAgICBzd2l0Y2ggKGNvbXBhcmF0b3Iub3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgaWYgKGNvbXB2ZXIucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbXB2ZXIucGF0Y2grK1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wdmVyLnByZXJlbGVhc2UucHVzaCgwKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb21wdmVyLnJhdyA9IGNvbXB2ZXIuZm9ybWF0KClcbiAgICAgICAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICcnOlxuICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgaWYgKCFzZXRNaW4gfHwgZ3QoY29tcHZlciwgc2V0TWluKSkge1xuICAgICAgICAgICAgc2V0TWluID0gY29tcHZlclxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgIC8qIElnbm9yZSBtYXhpbXVtIHZlcnNpb25zICovXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgb3BlcmF0aW9uOiAke2NvbXBhcmF0b3Iub3BlcmF0b3J9YClcbiAgICAgIH1cbiAgICB9KVxuICAgIGlmIChzZXRNaW4gJiYgKCFtaW52ZXIgfHwgZ3QobWludmVyLCBzZXRNaW4pKSkge1xuICAgICAgbWludmVyID0gc2V0TWluXG4gICAgfVxuICB9XG5cbiAgaWYgKG1pbnZlciAmJiByYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBtaW5WZXJzaW9uXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9jb21wYXJhdG9yJylcbmNvbnN0IHsgQU5ZIH0gPSBDb21wYXJhdG9yXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcycpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndCcpXG5jb25zdCBsdCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9sdCcpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvbHRlJylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndGUnKVxuXG5jb25zdCBvdXRzaWRlID0gKHZlcnNpb24sIHJhbmdlLCBoaWxvLCBvcHRpb25zKSA9PiB7XG4gIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuXG4gIGxldCBndGZuLCBsdGVmbiwgbHRmbiwgY29tcCwgZWNvbXBcbiAgc3dpdGNoIChoaWxvKSB7XG4gICAgY2FzZSAnPic6XG4gICAgICBndGZuID0gZ3RcbiAgICAgIGx0ZWZuID0gbHRlXG4gICAgICBsdGZuID0gbHRcbiAgICAgIGNvbXAgPSAnPidcbiAgICAgIGVjb21wID0gJz49J1xuICAgICAgYnJlYWtcbiAgICBjYXNlICc8JzpcbiAgICAgIGd0Zm4gPSBsdFxuICAgICAgbHRlZm4gPSBndGVcbiAgICAgIGx0Zm4gPSBndFxuICAgICAgY29tcCA9ICc8J1xuICAgICAgZWNvbXAgPSAnPD0nXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNdXN0IHByb3ZpZGUgYSBoaWxvIHZhbCBvZiBcIjxcIiBvciBcIj5cIicpXG4gIH1cblxuICAvLyBJZiBpdCBzYXRpc2ZpZXMgdGhlIHJhbmdlIGl0IGlzIG5vdCBvdXRzaWRlXG4gIGlmIChzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBGcm9tIG5vdyBvbiwgdmFyaWFibGUgdGVybXMgYXJlIGFzIGlmIHdlJ3JlIGluIFwiZ3RyXCIgbW9kZS5cbiAgLy8gYnV0IG5vdGUgdGhhdCBldmVyeXRoaW5nIGlzIGZsaXBwZWQgZm9yIHRoZSBcImx0clwiIGZ1bmN0aW9uLlxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV1cblxuICAgIGxldCBoaWdoID0gbnVsbFxuICAgIGxldCBsb3cgPSBudWxsXG5cbiAgICBjb21wYXJhdG9ycy5mb3JFYWNoKChjb21wYXJhdG9yKSA9PiB7XG4gICAgICBpZiAoY29tcGFyYXRvci5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgICBjb21wYXJhdG9yID0gbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKVxuICAgICAgfVxuICAgICAgaGlnaCA9IGhpZ2ggfHwgY29tcGFyYXRvclxuICAgICAgbG93ID0gbG93IHx8IGNvbXBhcmF0b3JcbiAgICAgIGlmIChndGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBoaWdoLnNlbXZlciwgb3B0aW9ucykpIHtcbiAgICAgICAgaGlnaCA9IGNvbXBhcmF0b3JcbiAgICAgIH0gZWxzZSBpZiAobHRmbihjb21wYXJhdG9yLnNlbXZlciwgbG93LnNlbXZlciwgb3B0aW9ucykpIHtcbiAgICAgICAgbG93ID0gY29tcGFyYXRvclxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBJZiB0aGUgZWRnZSB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGEgb3BlcmF0b3IgdGhlbiBvdXIgdmVyc2lvblxuICAgIC8vIGlzbid0IG91dHNpZGUgaXRcbiAgICBpZiAoaGlnaC5vcGVyYXRvciA9PT0gY29tcCB8fCBoaWdoLm9wZXJhdG9yID09PSBlY29tcCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGxvd2VzdCB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGFuIG9wZXJhdG9yIGFuZCBvdXIgdmVyc2lvblxuICAgIC8vIGlzIGxlc3MgdGhhbiBpdCB0aGVuIGl0IGlzbid0IGhpZ2hlciB0aGFuIHRoZSByYW5nZVxuICAgIGlmICgoIWxvdy5vcGVyYXRvciB8fCBsb3cub3BlcmF0b3IgPT09IGNvbXApICYmXG4gICAgICAgIGx0ZWZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2UgaWYgKGxvdy5vcGVyYXRvciA9PT0gZWNvbXAgJiYgbHRmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3V0c2lkZVxuIiwiLy8gZ2l2ZW4gYSBzZXQgb2YgdmVyc2lvbnMgYW5kIGEgcmFuZ2UsIGNyZWF0ZSBhIFwic2ltcGxpZmllZFwiIHJhbmdlXG4vLyB0aGF0IGluY2x1ZGVzIHRoZSBzYW1lIHZlcnNpb25zIHRoYXQgdGhlIG9yaWdpbmFsIHJhbmdlIGRvZXNcbi8vIElmIHRoZSBvcmlnaW5hbCByYW5nZSBpcyBzaG9ydGVyIHRoYW4gdGhlIHNpbXBsaWZpZWQgb25lLCByZXR1cm4gdGhhdC5cbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMnKVxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jb21wYXJlLmpzJylcbm1vZHVsZS5leHBvcnRzID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBzZXQgPSBbXVxuICBsZXQgZmlyc3QgPSBudWxsXG4gIGxldCBwcmV2ID0gbnVsbFxuICBjb25zdCB2ID0gdmVyc2lvbnMuc29ydCgoYSwgYikgPT4gY29tcGFyZShhLCBiLCBvcHRpb25zKSlcbiAgZm9yIChjb25zdCB2ZXJzaW9uIG9mIHYpIHtcbiAgICBjb25zdCBpbmNsdWRlZCA9IHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucylcbiAgICBpZiAoaW5jbHVkZWQpIHtcbiAgICAgIHByZXYgPSB2ZXJzaW9uXG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gdmVyc2lvblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJldikge1xuICAgICAgICBzZXQucHVzaChbZmlyc3QsIHByZXZdKVxuICAgICAgfVxuICAgICAgcHJldiA9IG51bGxcbiAgICAgIGZpcnN0ID0gbnVsbFxuICAgIH1cbiAgfVxuICBpZiAoZmlyc3QpIHtcbiAgICBzZXQucHVzaChbZmlyc3QsIG51bGxdKVxuICB9XG5cbiAgY29uc3QgcmFuZ2VzID0gW11cbiAgZm9yIChjb25zdCBbbWluLCBtYXhdIG9mIHNldCkge1xuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgcmFuZ2VzLnB1c2gobWluKVxuICAgIH0gZWxzZSBpZiAoIW1heCAmJiBtaW4gPT09IHZbMF0pIHtcbiAgICAgIHJhbmdlcy5wdXNoKCcqJylcbiAgICB9IGVsc2UgaWYgKCFtYXgpIHtcbiAgICAgIHJhbmdlcy5wdXNoKGA+PSR7bWlufWApXG4gICAgfSBlbHNlIGlmIChtaW4gPT09IHZbMF0pIHtcbiAgICAgIHJhbmdlcy5wdXNoKGA8PSR7bWF4fWApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlcy5wdXNoKGAke21pbn0gLSAke21heH1gKVxuICAgIH1cbiAgfVxuICBjb25zdCBzaW1wbGlmaWVkID0gcmFuZ2VzLmpvaW4oJyB8fCAnKVxuICBjb25zdCBvcmlnaW5hbCA9IHR5cGVvZiByYW5nZS5yYXcgPT09ICdzdHJpbmcnID8gcmFuZ2UucmF3IDogU3RyaW5nKHJhbmdlKVxuICByZXR1cm4gc2ltcGxpZmllZC5sZW5ndGggPCBvcmlnaW5hbC5sZW5ndGggPyBzaW1wbGlmaWVkIDogcmFuZ2Vcbn1cbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZS5qcycpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9jb21wYXJhdG9yLmpzJylcbmNvbnN0IHsgQU5ZIH0gPSBDb21wYXJhdG9yXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY29tcGFyZS5qcycpXG5cbi8vIENvbXBsZXggcmFuZ2UgYHIxIHx8IHIyIHx8IC4uLmAgaXMgYSBzdWJzZXQgb2YgYFIxIHx8IFIyIHx8IC4uLmAgaWZmOlxuLy8gLSBFdmVyeSBzaW1wbGUgcmFuZ2UgYHIxLCByMiwgLi4uYCBpcyBhIG51bGwgc2V0LCBPUlxuLy8gLSBFdmVyeSBzaW1wbGUgcmFuZ2UgYHIxLCByMiwgLi4uYCB3aGljaCBpcyBub3QgYSBudWxsIHNldCBpcyBhIHN1YnNldCBvZlxuLy8gICBzb21lIGBSMSwgUjIsIC4uLmBcbi8vXG4vLyBTaW1wbGUgcmFuZ2UgYGMxIGMyIC4uLmAgaXMgYSBzdWJzZXQgb2Ygc2ltcGxlIHJhbmdlIGBDMSBDMiAuLi5gIGlmZjpcbi8vIC0gSWYgYyBpcyBvbmx5IHRoZSBBTlkgY29tcGFyYXRvclxuLy8gICAtIElmIEMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3IsIHJldHVybiB0cnVlXG4vLyAgIC0gRWxzZSBpZiBpbiBwcmVyZWxlYXNlIG1vZGUsIHJldHVybiBmYWxzZVxuLy8gICAtIGVsc2UgcmVwbGFjZSBjIHdpdGggYFs+PTAuMC4wXWBcbi8vIC0gSWYgQyBpcyBvbmx5IHRoZSBBTlkgY29tcGFyYXRvclxuLy8gICAtIGlmIGluIHByZXJlbGVhc2UgbW9kZSwgcmV0dXJuIHRydWVcbi8vICAgLSBlbHNlIHJlcGxhY2UgQyB3aXRoIGBbPj0wLjAuMF1gXG4vLyAtIExldCBFUSBiZSB0aGUgc2V0IG9mID0gY29tcGFyYXRvcnMgaW4gY1xuLy8gLSBJZiBFUSBpcyBtb3JlIHRoYW4gb25lLCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAtIExldCBHVCBiZSB0aGUgaGlnaGVzdCA+IG9yID49IGNvbXBhcmF0b3IgaW4gY1xuLy8gLSBMZXQgTFQgYmUgdGhlIGxvd2VzdCA8IG9yIDw9IGNvbXBhcmF0b3IgaW4gY1xuLy8gLSBJZiBHVCBhbmQgTFQsIGFuZCBHVC5zZW12ZXIgPiBMVC5zZW12ZXIsIHJldHVybiB0cnVlIChudWxsIHNldClcbi8vIC0gSWYgYW55IEMgaXMgYSA9IHJhbmdlLCBhbmQgR1Qgb3IgTFQgYXJlIHNldCwgcmV0dXJuIGZhbHNlXG4vLyAtIElmIEVRXG4vLyAgIC0gSWYgR1QsIGFuZCBFUSBkb2VzIG5vdCBzYXRpc2Z5IEdULCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAgIC0gSWYgTFQsIGFuZCBFUSBkb2VzIG5vdCBzYXRpc2Z5IExULCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAgIC0gSWYgRVEgc2F0aXNmaWVzIGV2ZXJ5IEMsIHJldHVybiB0cnVlXG4vLyAgIC0gRWxzZSByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgR1Rcbi8vICAgLSBJZiBHVC5zZW12ZXIgaXMgbG93ZXIgdGhhbiBhbnkgPiBvciA+PSBjb21wIGluIEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdUIGlzID49LCBhbmQgR1Quc2VtdmVyIGRvZXMgbm90IHNhdGlzZnkgZXZlcnkgQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGhhcyBhIHByZXJlbGVhc2UsIGFuZCBub3QgaW4gcHJlcmVsZWFzZSBtb2RlXG4vLyAgICAgLSBJZiBubyBDIGhhcyBhIHByZXJlbGVhc2UgYW5kIHRoZSBHVC5zZW12ZXIgdHVwbGUsIHJldHVybiBmYWxzZVxuLy8gLSBJZiBMVFxuLy8gICAtIElmIExULnNlbXZlciBpcyBncmVhdGVyIHRoYW4gYW55IDwgb3IgPD0gY29tcCBpbiBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBMVCBpcyA8PSwgYW5kIExULnNlbXZlciBkb2VzIG5vdCBzYXRpc2Z5IGV2ZXJ5IEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdULnNlbXZlciBoYXMgYSBwcmVyZWxlYXNlLCBhbmQgbm90IGluIHByZXJlbGVhc2UgbW9kZVxuLy8gICAgIC0gSWYgbm8gQyBoYXMgYSBwcmVyZWxlYXNlIGFuZCB0aGUgTFQuc2VtdmVyIHR1cGxlLCByZXR1cm4gZmFsc2Vcbi8vIC0gRWxzZSByZXR1cm4gdHJ1ZVxuXG5jb25zdCBzdWJzZXQgPSAoc3ViLCBkb20sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAoc3ViID09PSBkb20pIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgc3ViID0gbmV3IFJhbmdlKHN1Yiwgb3B0aW9ucylcbiAgZG9tID0gbmV3IFJhbmdlKGRvbSwgb3B0aW9ucylcbiAgbGV0IHNhd05vbk51bGwgPSBmYWxzZVxuXG4gIE9VVEVSOiBmb3IgKGNvbnN0IHNpbXBsZVN1YiBvZiBzdWIuc2V0KSB7XG4gICAgZm9yIChjb25zdCBzaW1wbGVEb20gb2YgZG9tLnNldCkge1xuICAgICAgY29uc3QgaXNTdWIgPSBzaW1wbGVTdWJzZXQoc2ltcGxlU3ViLCBzaW1wbGVEb20sIG9wdGlvbnMpXG4gICAgICBzYXdOb25OdWxsID0gc2F3Tm9uTnVsbCB8fCBpc1N1YiAhPT0gbnVsbFxuICAgICAgaWYgKGlzU3ViKSB7XG4gICAgICAgIGNvbnRpbnVlIE9VVEVSXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHRoZSBudWxsIHNldCBpcyBhIHN1YnNldCBvZiBldmVyeXRoaW5nLCBidXQgbnVsbCBzaW1wbGUgcmFuZ2VzIGluXG4gICAgLy8gYSBjb21wbGV4IHJhbmdlIHNob3VsZCBiZSBpZ25vcmVkLiAgc28gaWYgd2Ugc2F3IGEgbm9uLW51bGwgcmFuZ2UsXG4gICAgLy8gdGhlbiB3ZSBrbm93IHRoaXMgaXNuJ3QgYSBzdWJzZXQsIGJ1dCBpZiBFVkVSWSBzaW1wbGUgcmFuZ2Ugd2FzIG51bGwsXG4gICAgLy8gdGhlbiBpdCBpcyBhIHN1YnNldC5cbiAgICBpZiAoc2F3Tm9uTnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmNvbnN0IG1pbmltdW1WZXJzaW9uV2l0aFByZVJlbGVhc2UgPSBbbmV3IENvbXBhcmF0b3IoJz49MC4wLjAtMCcpXVxuY29uc3QgbWluaW11bVZlcnNpb24gPSBbbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKV1cblxuY29uc3Qgc2ltcGxlU3Vic2V0ID0gKHN1YiwgZG9tLCBvcHRpb25zKSA9PiB7XG4gIGlmIChzdWIgPT09IGRvbSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoc3ViLmxlbmd0aCA9PT0gMSAmJiBzdWJbMF0uc2VtdmVyID09PSBBTlkpIHtcbiAgICBpZiAoZG9tLmxlbmd0aCA9PT0gMSAmJiBkb21bMF0uc2VtdmVyID09PSBBTlkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgICBzdWIgPSBtaW5pbXVtVmVyc2lvbldpdGhQcmVSZWxlYXNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YiA9IG1pbmltdW1WZXJzaW9uXG4gICAgfVxuICB9XG5cbiAgaWYgKGRvbS5sZW5ndGggPT09IDEgJiYgZG9tWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbSA9IG1pbmltdW1WZXJzaW9uXG4gICAgfVxuICB9XG5cbiAgY29uc3QgZXFTZXQgPSBuZXcgU2V0KClcbiAgbGV0IGd0LCBsdFxuICBmb3IgKGNvbnN0IGMgb2Ygc3ViKSB7XG4gICAgaWYgKGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nKSB7XG4gICAgICBndCA9IGhpZ2hlckdUKGd0LCBjLCBvcHRpb25zKVxuICAgIH0gZWxzZSBpZiAoYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PScpIHtcbiAgICAgIGx0ID0gbG93ZXJMVChsdCwgYywgb3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgZXFTZXQuYWRkKGMuc2VtdmVyKVxuICAgIH1cbiAgfVxuXG4gIGlmIChlcVNldC5zaXplID4gMSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBsZXQgZ3RsdENvbXBcbiAgaWYgKGd0ICYmIGx0KSB7XG4gICAgZ3RsdENvbXAgPSBjb21wYXJlKGd0LnNlbXZlciwgbHQuc2VtdmVyLCBvcHRpb25zKVxuICAgIGlmIChndGx0Q29tcCA+IDApIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfSBlbHNlIGlmIChndGx0Q29tcCA9PT0gMCAmJiAoZ3Qub3BlcmF0b3IgIT09ICc+PScgfHwgbHQub3BlcmF0b3IgIT09ICc8PScpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8vIHdpbGwgaXRlcmF0ZSBvbmUgb3IgemVybyB0aW1lc1xuICBmb3IgKGNvbnN0IGVxIG9mIGVxU2V0KSB7XG4gICAgaWYgKGd0ICYmICFzYXRpc2ZpZXMoZXEsIFN0cmluZyhndCksIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGlmIChsdCAmJiAhc2F0aXNmaWVzKGVxLCBTdHJpbmcobHQpLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGMgb2YgZG9tKSB7XG4gICAgICBpZiAoIXNhdGlzZmllcyhlcSwgU3RyaW5nKGMpLCBvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgbGV0IGhpZ2hlciwgbG93ZXJcbiAgbGV0IGhhc0RvbUxULCBoYXNEb21HVFxuICAvLyBpZiB0aGUgc3Vic2V0IGhhcyBhIHByZXJlbGVhc2UsIHdlIG5lZWQgYSBjb21wYXJhdG9yIGluIHRoZSBzdXBlcnNldFxuICAvLyB3aXRoIHRoZSBzYW1lIHR1cGxlIGFuZCBhIHByZXJlbGVhc2UsIG9yIGl0J3Mgbm90IGEgc3Vic2V0XG4gIGxldCBuZWVkRG9tTFRQcmUgPSBsdCAmJlxuICAgICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgbHQuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID8gbHQuc2VtdmVyIDogZmFsc2VcbiAgbGV0IG5lZWREb21HVFByZSA9IGd0ICYmXG4gICAgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiZcbiAgICBndC5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPyBndC5zZW12ZXIgOiBmYWxzZVxuICAvLyBleGNlcHRpb246IDwxLjIuMy0wIGlzIHRoZSBzYW1lIGFzIDwxLjIuM1xuICBpZiAobmVlZERvbUxUUHJlICYmIG5lZWREb21MVFByZS5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbHQub3BlcmF0b3IgPT09ICc8JyAmJiBuZWVkRG9tTFRQcmUucHJlcmVsZWFzZVswXSA9PT0gMCkge1xuICAgIG5lZWREb21MVFByZSA9IGZhbHNlXG4gIH1cblxuICBmb3IgKGNvbnN0IGMgb2YgZG9tKSB7XG4gICAgaGFzRG9tR1QgPSBoYXNEb21HVCB8fCBjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49J1xuICAgIGhhc0RvbUxUID0gaGFzRG9tTFQgfHwgYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PSdcbiAgICBpZiAoZ3QpIHtcbiAgICAgIGlmIChuZWVkRG9tR1RQcmUpIHtcbiAgICAgICAgaWYgKGMuc2VtdmVyLnByZXJlbGVhc2UgJiYgYy5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1ham9yID09PSBuZWVkRG9tR1RQcmUubWFqb3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1pbm9yID09PSBuZWVkRG9tR1RQcmUubWlub3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLnBhdGNoID09PSBuZWVkRG9tR1RQcmUucGF0Y2gpIHtcbiAgICAgICAgICBuZWVkRG9tR1RQcmUgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PScpIHtcbiAgICAgICAgaGlnaGVyID0gaGlnaGVyR1QoZ3QsIGMsIG9wdGlvbnMpXG4gICAgICAgIGlmIChoaWdoZXIgPT09IGMgJiYgaGlnaGVyICE9PSBndCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGd0Lm9wZXJhdG9yID09PSAnPj0nICYmICFzYXRpc2ZpZXMoZ3Quc2VtdmVyLCBTdHJpbmcoYyksIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobHQpIHtcbiAgICAgIGlmIChuZWVkRG9tTFRQcmUpIHtcbiAgICAgICAgaWYgKGMuc2VtdmVyLnByZXJlbGVhc2UgJiYgYy5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1ham9yID09PSBuZWVkRG9tTFRQcmUubWFqb3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1pbm9yID09PSBuZWVkRG9tTFRQcmUubWlub3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLnBhdGNoID09PSBuZWVkRG9tTFRQcmUucGF0Y2gpIHtcbiAgICAgICAgICBuZWVkRG9tTFRQcmUgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PScpIHtcbiAgICAgICAgbG93ZXIgPSBsb3dlckxUKGx0LCBjLCBvcHRpb25zKVxuICAgICAgICBpZiAobG93ZXIgPT09IGMgJiYgbG93ZXIgIT09IGx0KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobHQub3BlcmF0b3IgPT09ICc8PScgJiYgIXNhdGlzZmllcyhsdC5zZW12ZXIsIFN0cmluZyhjKSwgb3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmICghYy5vcGVyYXRvciAmJiAobHQgfHwgZ3QpICYmIGd0bHRDb21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGVyZSB3YXMgYSA8IG9yID4sIGFuZCBub3RoaW5nIGluIHRoZSBkb20sIHRoZW4gbXVzdCBiZSBmYWxzZVxuICAvLyBVTkxFU1MgaXQgd2FzIGxpbWl0ZWQgYnkgYW5vdGhlciByYW5nZSBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uLlxuICAvLyBFZywgPjEuMC4wIDwxLjAuMSBpcyBzdGlsbCBhIHN1YnNldCBvZiA8Mi4wLjBcbiAgaWYgKGd0ICYmIGhhc0RvbUxUICYmICFsdCAmJiBndGx0Q29tcCAhPT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGx0ICYmIGhhc0RvbUdUICYmICFndCAmJiBndGx0Q29tcCAhPT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gd2UgbmVlZGVkIGEgcHJlcmVsZWFzZSByYW5nZSBpbiBhIHNwZWNpZmljIHR1cGxlLCBidXQgZGlkbid0IGdldCBvbmVcbiAgLy8gdGhlbiB0aGlzIGlzbid0IGEgc3Vic2V0LiAgZWcgPj0xLjIuMy1wcmUgaXMgbm90IGEgc3Vic2V0IG9mID49MS4wLjAsXG4gIC8vIGJlY2F1c2UgaXQgaW5jbHVkZXMgcHJlcmVsZWFzZXMgaW4gdGhlIDEuMi4zIHR1cGxlXG4gIGlmIChuZWVkRG9tR1RQcmUgfHwgbmVlZERvbUxUUHJlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyA+PTEuMi4zIGlzIGxvd2VyIHRoYW4gPjEuMi4zXG5jb25zdCBoaWdoZXJHVCA9IChhLCBiLCBvcHRpb25zKSA9PiB7XG4gIGlmICghYSkge1xuICAgIHJldHVybiBiXG4gIH1cbiAgY29uc3QgY29tcCA9IGNvbXBhcmUoYS5zZW12ZXIsIGIuc2VtdmVyLCBvcHRpb25zKVxuICByZXR1cm4gY29tcCA+IDAgPyBhXG4gICAgOiBjb21wIDwgMCA/IGJcbiAgICA6IGIub3BlcmF0b3IgPT09ICc+JyAmJiBhLm9wZXJhdG9yID09PSAnPj0nID8gYlxuICAgIDogYVxufVxuXG4vLyA8PTEuMi4zIGlzIGhpZ2hlciB0aGFuIDwxLjIuM1xuY29uc3QgbG93ZXJMVCA9IChhLCBiLCBvcHRpb25zKSA9PiB7XG4gIGlmICghYSkge1xuICAgIHJldHVybiBiXG4gIH1cbiAgY29uc3QgY29tcCA9IGNvbXBhcmUoYS5zZW12ZXIsIGIuc2VtdmVyLCBvcHRpb25zKVxuICByZXR1cm4gY29tcCA8IDAgPyBhXG4gICAgOiBjb21wID4gMCA/IGJcbiAgICA6IGIub3BlcmF0b3IgPT09ICc8JyAmJiBhLm9wZXJhdG9yID09PSAnPD0nID8gYlxuICAgIDogYVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN1YnNldFxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcblxuLy8gTW9zdGx5IGp1c3QgZm9yIHRlc3RpbmcgYW5kIGxlZ2FjeSBBUEkgcmVhc29uc1xuY29uc3QgdG9Db21wYXJhdG9ycyA9IChyYW5nZSwgb3B0aW9ucykgPT5cbiAgbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5zZXRcbiAgICAubWFwKGNvbXAgPT4gY29tcC5tYXAoYyA9PiBjLnZhbHVlKS5qb2luKCcgJykudHJpbSgpLnNwbGl0KCcgJykpXG5cbm1vZHVsZS5leHBvcnRzID0gdG9Db21wYXJhdG9yc1xuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHZhbGlkUmFuZ2UgPSAocmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBSZXR1cm4gJyonIGluc3RlYWQgb2YgJycgc28gdGhhdCB0cnV0aGluZXNzIHdvcmtzLlxuICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiBpdCdzIGludmFsaWQgYW55d2F5XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucykucmFuZ2UgfHwgJyonXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZFJhbmdlXG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicgPyBzZXRJbW1lZGlhdGUgOlxuXHRmdW5jdGlvbiBzZXRJbW1lZGlhdGUoKSB7XG5cdFx0dmFyIGFyZ3MgPSBbXS5zbGljZS5hcHBseShhcmd1bWVudHMpO1xuXHRcdGFyZ3Muc3BsaWNlKDEsIDAsIDApO1xuXHRcdHNldFRpbWVvdXQuYXBwbHkobnVsbCwgYXJncyk7XG5cdH07XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxuLy8gcHJvdG90eXBlIGNsYXNzIGZvciBoYXNoIGZ1bmN0aW9uc1xuZnVuY3Rpb24gSGFzaCAoYmxvY2tTaXplLCBmaW5hbFNpemUpIHtcbiAgdGhpcy5fYmxvY2sgPSBCdWZmZXIuYWxsb2MoYmxvY2tTaXplKVxuICB0aGlzLl9maW5hbFNpemUgPSBmaW5hbFNpemVcbiAgdGhpcy5fYmxvY2tTaXplID0gYmxvY2tTaXplXG4gIHRoaXMuX2xlbiA9IDBcbn1cblxuSGFzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jID0gZW5jIHx8ICd1dGY4J1xuICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCBlbmMpXG4gIH1cblxuICB2YXIgYmxvY2sgPSB0aGlzLl9ibG9ja1xuICB2YXIgYmxvY2tTaXplID0gdGhpcy5fYmxvY2tTaXplXG4gIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aFxuICB2YXIgYWNjdW0gPSB0aGlzLl9sZW5cblxuICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBsZW5ndGg7KSB7XG4gICAgdmFyIGFzc2lnbmVkID0gYWNjdW0gJSBibG9ja1NpemVcbiAgICB2YXIgcmVtYWluZGVyID0gTWF0aC5taW4obGVuZ3RoIC0gb2Zmc2V0LCBibG9ja1NpemUgLSBhc3NpZ25lZClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVtYWluZGVyOyBpKyspIHtcbiAgICAgIGJsb2NrW2Fzc2lnbmVkICsgaV0gPSBkYXRhW29mZnNldCArIGldXG4gICAgfVxuXG4gICAgYWNjdW0gKz0gcmVtYWluZGVyXG4gICAgb2Zmc2V0ICs9IHJlbWFpbmRlclxuXG4gICAgaWYgKChhY2N1bSAlIGJsb2NrU2l6ZSkgPT09IDApIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShibG9jaylcbiAgICB9XG4gIH1cblxuICB0aGlzLl9sZW4gKz0gbGVuZ3RoXG4gIHJldHVybiB0aGlzXG59XG5cbkhhc2gucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgdmFyIHJlbSA9IHRoaXMuX2xlbiAlIHRoaXMuX2Jsb2NrU2l6ZVxuXG4gIHRoaXMuX2Jsb2NrW3JlbV0gPSAweDgwXG5cbiAgLy8gemVybyAocmVtICsgMSkgdHJhaWxpbmcgYml0cywgd2hlcmUgKHJlbSArIDEpIGlzIHRoZSBzbWFsbGVzdFxuICAvLyBub24tbmVnYXRpdmUgc29sdXRpb24gdG8gdGhlIGVxdWF0aW9uIChsZW5ndGggKyAxICsgKHJlbSArIDEpKSA9PT0gZmluYWxTaXplIG1vZCBibG9ja1NpemVcbiAgdGhpcy5fYmxvY2suZmlsbCgwLCByZW0gKyAxKVxuXG4gIGlmIChyZW0gPj0gdGhpcy5fZmluYWxTaXplKSB7XG4gICAgdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKVxuICAgIHRoaXMuX2Jsb2NrLmZpbGwoMClcbiAgfVxuXG4gIHZhciBiaXRzID0gdGhpcy5fbGVuICogOFxuXG4gIC8vIHVpbnQzMlxuICBpZiAoYml0cyA8PSAweGZmZmZmZmZmKSB7XG4gICAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJCRShiaXRzLCB0aGlzLl9ibG9ja1NpemUgLSA0KVxuXG4gIC8vIHVpbnQ2NFxuICB9IGVsc2Uge1xuICAgIHZhciBsb3dCaXRzID0gKGJpdHMgJiAweGZmZmZmZmZmKSA+Pj4gMFxuICAgIHZhciBoaWdoQml0cyA9IChiaXRzIC0gbG93Qml0cykgLyAweDEwMDAwMDAwMFxuXG4gICAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJCRShoaWdoQml0cywgdGhpcy5fYmxvY2tTaXplIC0gOClcbiAgICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkJFKGxvd0JpdHMsIHRoaXMuX2Jsb2NrU2l6ZSAtIDQpXG4gIH1cblxuICB0aGlzLl91cGRhdGUodGhpcy5fYmxvY2spXG4gIHZhciBoYXNoID0gdGhpcy5faGFzaCgpXG5cbiAgcmV0dXJuIGVuYyA/IGhhc2gudG9TdHJpbmcoZW5jKSA6IGhhc2hcbn1cblxuSGFzaC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdXBkYXRlIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3MnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2hcbiIsInZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBTSEEgKGFsZ29yaXRobSkge1xuICBhbGdvcml0aG0gPSBhbGdvcml0aG0udG9Mb3dlckNhc2UoKVxuXG4gIHZhciBBbGdvcml0aG0gPSBleHBvcnRzW2FsZ29yaXRobV1cbiAgaWYgKCFBbGdvcml0aG0pIHRocm93IG5ldyBFcnJvcihhbGdvcml0aG0gKyAnIGlzIG5vdCBzdXBwb3J0ZWQgKHdlIGFjY2VwdCBwdWxsIHJlcXVlc3RzKScpXG5cbiAgcmV0dXJuIG5ldyBBbGdvcml0aG0oKVxufVxuXG5leHBvcnRzLnNoYSA9IHJlcXVpcmUoJy4vc2hhJylcbmV4cG9ydHMuc2hhMSA9IHJlcXVpcmUoJy4vc2hhMScpXG5leHBvcnRzLnNoYTIyNCA9IHJlcXVpcmUoJy4vc2hhMjI0JylcbmV4cG9ydHMuc2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxuZXhwb3J0cy5zaGEzODQgPSByZXF1aXJlKCcuL3NoYTM4NCcpXG5leHBvcnRzLnNoYTUxMiA9IHJlcXVpcmUoJy4vc2hhNTEyJylcbiIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTAsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGRlcml2ZWQgZnJvbSBzaGExLmpzIG9mIHRoZSBzYW1lIHJlcG9zaXRvcnkuXG4gKiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIFNIQS0wIGFuZCBTSEEtMSBpcyBqdXN0IGEgYml0d2lzZSByb3RhdGUgbGVmdFxuICogb3BlcmF0aW9uIHdhcyBhZGRlZC5cbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEsgPSBbXG4gIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMgfCAwLCAweGNhNjJjMWQ2IHwgMFxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg4MClcblxuZnVuY3Rpb24gU2hhICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEsIEhhc2gpXG5cblNoYS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbiAgdGhpcy5fZSA9IDB4YzNkMmUxZjBcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiByb3RsNSAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDUpIHwgKG51bSA+Pj4gMjcpXG59XG5cbmZ1bmN0aW9uIHJvdGwzMCAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDMwKSB8IChudW0gPj4+IDIpXG59XG5cbmZ1bmN0aW9uIGZ0IChzLCBiLCBjLCBkKSB7XG4gIGlmIChzID09PSAwKSByZXR1cm4gKGIgJiBjKSB8ICgofmIpICYgZClcbiAgaWYgKHMgPT09IDIpIHJldHVybiAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZClcbiAgcmV0dXJuIGIgXiBjIF4gZFxufVxuXG5TaGEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDgwOyArK2kpIFdbaV0gPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgKytqKSB7XG4gICAgdmFyIHMgPSB+fihqIC8gMjApXG4gICAgdmFyIHQgPSAocm90bDUoYSkgKyBmdChzLCBiLCBjLCBkKSArIGUgKyBXW2pdICsgS1tzXSkgfCAwXG5cbiAgICBlID0gZFxuICAgIGQgPSBjXG4gICAgYyA9IHJvdGwzMChiKVxuICAgIGIgPSBhXG4gICAgYSA9IHRcbiAgfVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbn1cblxuU2hhLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoMjApXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSB8IDAsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IgfCAwLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jIHwgMCwgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCB8IDAsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lIHwgMCwgMTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGFcbiIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTEsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBWZXJzaW9uIDIuMWEgQ29weXJpZ2h0IFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDIuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBkZXRhaWxzLlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgSyA9IFtcbiAgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYyB8IDAsIDB4Y2E2MmMxZDYgfCAwXG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDgwKVxuXG5mdW5jdGlvbiBTaGExICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGExLCBIYXNoKVxuXG5TaGExLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxuICB0aGlzLl9lID0gMHhjM2QyZTFmMFxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIHJvdGwxIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMSkgfCAobnVtID4+PiAzMSlcbn1cblxuZnVuY3Rpb24gcm90bDUgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCA1KSB8IChudW0gPj4+IDI3KVxufVxuXG5mdW5jdGlvbiByb3RsMzAgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCAzMCkgfCAobnVtID4+PiAyKVxufVxuXG5mdW5jdGlvbiBmdCAocywgYiwgYywgZCkge1xuICBpZiAocyA9PT0gMCkgcmV0dXJuIChiICYgYykgfCAoKH5iKSAmIGQpXG4gIGlmIChzID09PSAyKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpXG4gIHJldHVybiBiIF4gYyBeIGRcbn1cblxuU2hhMS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYSB8IDBcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxuICB2YXIgYyA9IHRoaXMuX2MgfCAwXG4gIHZhciBkID0gdGhpcy5fZCB8IDBcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gIGZvciAoOyBpIDwgODA7ICsraSkgV1tpXSA9IHJvdGwxKFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl0pXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgKytqKSB7XG4gICAgdmFyIHMgPSB+fihqIC8gMjApXG4gICAgdmFyIHQgPSAocm90bDUoYSkgKyBmdChzLCBiLCBjLCBkKSArIGUgKyBXW2pdICsgS1tzXSkgfCAwXG5cbiAgICBlID0gZFxuICAgIGQgPSBjXG4gICAgYyA9IHJvdGwzMChiKVxuICAgIGIgPSBhXG4gICAgYSA9IHRcbiAgfVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbn1cblxuU2hhMS5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIwKVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EgfCAwLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iIHwgMCwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYyB8IDAsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QgfCAwLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSB8IDAsIDE2KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMVxuIiwiLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTI1NiwgYXMgZGVmaW5lZFxuICogaW4gRklQUyAxODAtMlxuICogVmVyc2lvbiAyLjItYmV0YSBDb3B5cmlnaHQgQW5nZWwgTWFyaW4sIFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBTaGEyNTYgPSByZXF1aXJlKCcuL3NoYTI1NicpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIFcgPSBuZXcgQXJyYXkoNjQpXG5cbmZ1bmN0aW9uIFNoYTIyNCAoKSB7XG4gIHRoaXMuaW5pdCgpXG5cbiAgdGhpcy5fdyA9IFcgLy8gbmV3IEFycmF5KDY0KVxuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTIyNCwgU2hhMjU2KVxuXG5TaGEyMjQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweGMxMDU5ZWQ4XG4gIHRoaXMuX2IgPSAweDM2N2NkNTA3XG4gIHRoaXMuX2MgPSAweDMwNzBkZDE3XG4gIHRoaXMuX2QgPSAweGY3MGU1OTM5XG4gIHRoaXMuX2UgPSAweGZmYzAwYjMxXG4gIHRoaXMuX2YgPSAweDY4NTgxNTExXG4gIHRoaXMuX2cgPSAweDY0Zjk4ZmE3XG4gIHRoaXMuX2ggPSAweGJlZmE0ZmE0XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuU2hhMjI0LnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoMjgpXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYywgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UsIDE2KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9mLCAyMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZywgMjQpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEyMjRcbiIsIi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEsgPSBbXG4gIDB4NDI4QTJGOTgsIDB4NzEzNzQ0OTEsIDB4QjVDMEZCQ0YsIDB4RTlCNURCQTUsXG4gIDB4Mzk1NkMyNUIsIDB4NTlGMTExRjEsIDB4OTIzRjgyQTQsIDB4QUIxQzVFRDUsXG4gIDB4RDgwN0FBOTgsIDB4MTI4MzVCMDEsIDB4MjQzMTg1QkUsIDB4NTUwQzdEQzMsXG4gIDB4NzJCRTVENzQsIDB4ODBERUIxRkUsIDB4OUJEQzA2QTcsIDB4QzE5QkYxNzQsXG4gIDB4RTQ5QjY5QzEsIDB4RUZCRTQ3ODYsIDB4MEZDMTlEQzYsIDB4MjQwQ0ExQ0MsXG4gIDB4MkRFOTJDNkYsIDB4NEE3NDg0QUEsIDB4NUNCMEE5REMsIDB4NzZGOTg4REEsXG4gIDB4OTgzRTUxNTIsIDB4QTgzMUM2NkQsIDB4QjAwMzI3QzgsIDB4QkY1OTdGQzcsXG4gIDB4QzZFMDBCRjMsIDB4RDVBNzkxNDcsIDB4MDZDQTYzNTEsIDB4MTQyOTI5NjcsXG4gIDB4MjdCNzBBODUsIDB4MkUxQjIxMzgsIDB4NEQyQzZERkMsIDB4NTMzODBEMTMsXG4gIDB4NjUwQTczNTQsIDB4NzY2QTBBQkIsIDB4ODFDMkM5MkUsIDB4OTI3MjJDODUsXG4gIDB4QTJCRkU4QTEsIDB4QTgxQTY2NEIsIDB4QzI0QjhCNzAsIDB4Qzc2QzUxQTMsXG4gIDB4RDE5MkU4MTksIDB4RDY5OTA2MjQsIDB4RjQwRTM1ODUsIDB4MTA2QUEwNzAsXG4gIDB4MTlBNEMxMTYsIDB4MUUzNzZDMDgsIDB4Mjc0ODc3NEMsIDB4MzRCMEJDQjUsXG4gIDB4MzkxQzBDQjMsIDB4NEVEOEFBNEEsIDB4NUI5Q0NBNEYsIDB4NjgyRTZGRjMsXG4gIDB4NzQ4RjgyRUUsIDB4NzhBNTYzNkYsIDB4ODRDODc4MTQsIDB4OENDNzAyMDgsXG4gIDB4OTBCRUZGRkEsIDB4QTQ1MDZDRUIsIDB4QkVGOUEzRjcsIDB4QzY3MTc4RjJcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoNjQpXG5cbmZ1bmN0aW9uIFNoYTI1NiAoKSB7XG4gIHRoaXMuaW5pdCgpXG5cbiAgdGhpcy5fdyA9IFcgLy8gbmV3IEFycmF5KDY0KVxuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTI1NiwgSGFzaClcblxuU2hhMjU2LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2YTA5ZTY2N1xuICB0aGlzLl9iID0gMHhiYjY3YWU4NVxuICB0aGlzLl9jID0gMHgzYzZlZjM3MlxuICB0aGlzLl9kID0gMHhhNTRmZjUzYVxuICB0aGlzLl9lID0gMHg1MTBlNTI3ZlxuICB0aGlzLl9mID0gMHg5YjA1Njg4Y1xuICB0aGlzLl9nID0gMHgxZjgzZDlhYlxuICB0aGlzLl9oID0gMHg1YmUwY2QxOVxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIGNoICh4LCB5LCB6KSB7XG4gIHJldHVybiB6IF4gKHggJiAoeSBeIHopKVxufVxuXG5mdW5jdGlvbiBtYWogKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgfCAoeiAmICh4IHwgeSkpXG59XG5cbmZ1bmN0aW9uIHNpZ21hMCAoeCkge1xuICByZXR1cm4gKHggPj4+IDIgfCB4IDw8IDMwKSBeICh4ID4+PiAxMyB8IHggPDwgMTkpIF4gKHggPj4+IDIyIHwgeCA8PCAxMClcbn1cblxuZnVuY3Rpb24gc2lnbWExICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gNiB8IHggPDwgMjYpIF4gKHggPj4+IDExIHwgeCA8PCAyMSkgXiAoeCA+Pj4gMjUgfCB4IDw8IDcpXG59XG5cbmZ1bmN0aW9uIGdhbW1hMCAoeCkge1xuICByZXR1cm4gKHggPj4+IDcgfCB4IDw8IDI1KSBeICh4ID4+PiAxOCB8IHggPDwgMTQpIF4gKHggPj4+IDMpXG59XG5cbmZ1bmN0aW9uIGdhbW1hMSAoeCkge1xuICByZXR1cm4gKHggPj4+IDE3IHwgeCA8PCAxNSkgXiAoeCA+Pj4gMTkgfCB4IDw8IDEzKSBeICh4ID4+PiAxMClcbn1cblxuU2hhMjU2LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hIHwgMFxuICB2YXIgYiA9IHRoaXMuX2IgfCAwXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcbiAgdmFyIGQgPSB0aGlzLl9kIHwgMFxuICB2YXIgZSA9IHRoaXMuX2UgfCAwXG4gIHZhciBmID0gdGhpcy5fZiB8IDBcbiAgdmFyIGcgPSB0aGlzLl9nIHwgMFxuICB2YXIgaCA9IHRoaXMuX2ggfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgZm9yICg7IGkgPCA2NDsgKytpKSBXW2ldID0gKGdhbW1hMShXW2kgLSAyXSkgKyBXW2kgLSA3XSArIGdhbW1hMChXW2kgLSAxNV0pICsgV1tpIC0gMTZdKSB8IDBcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDY0OyArK2opIHtcbiAgICB2YXIgVDEgPSAoaCArIHNpZ21hMShlKSArIGNoKGUsIGYsIGcpICsgS1tqXSArIFdbal0pIHwgMFxuICAgIHZhciBUMiA9IChzaWdtYTAoYSkgKyBtYWooYSwgYiwgYykpIHwgMFxuXG4gICAgaCA9IGdcbiAgICBnID0gZlxuICAgIGYgPSBlXG4gICAgZSA9IChkICsgVDEpIHwgMFxuICAgIGQgPSBjXG4gICAgYyA9IGJcbiAgICBiID0gYVxuICAgIGEgPSAoVDEgKyBUMikgfCAwXG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG4gIHRoaXMuX2YgPSAoZiArIHRoaXMuX2YpIHwgMFxuICB0aGlzLl9nID0gKGcgKyB0aGlzLl9nKSB8IDBcbiAgdGhpcy5faCA9IChoICsgdGhpcy5faCkgfCAwXG59XG5cblNoYTI1Ni5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDMyKVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lLCAxNilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZiwgMjApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2csIDI0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9oLCAyOClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTI1NlxuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFNIQTUxMiA9IHJlcXVpcmUoJy4vc2hhNTEyJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgVyA9IG5ldyBBcnJheSgxNjApXG5cbmZ1bmN0aW9uIFNoYTM4NCAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDEyOCwgMTEyKVxufVxuXG5pbmhlcml0cyhTaGEzODQsIFNIQTUxMilcblxuU2hhMzg0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9haCA9IDB4Y2JiYjlkNWRcbiAgdGhpcy5fYmggPSAweDYyOWEyOTJhXG4gIHRoaXMuX2NoID0gMHg5MTU5MDE1YVxuICB0aGlzLl9kaCA9IDB4MTUyZmVjZDhcbiAgdGhpcy5fZWggPSAweDY3MzMyNjY3XG4gIHRoaXMuX2ZoID0gMHg4ZWI0NGE4N1xuICB0aGlzLl9naCA9IDB4ZGIwYzJlMGRcbiAgdGhpcy5faGggPSAweDQ3YjU0ODFkXG5cbiAgdGhpcy5fYWwgPSAweGMxMDU5ZWQ4XG4gIHRoaXMuX2JsID0gMHgzNjdjZDUwN1xuICB0aGlzLl9jbCA9IDB4MzA3MGRkMTdcbiAgdGhpcy5fZGwgPSAweGY3MGU1OTM5XG4gIHRoaXMuX2VsID0gMHhmZmMwMGIzMVxuICB0aGlzLl9mbCA9IDB4Njg1ODE1MTFcbiAgdGhpcy5fZ2wgPSAweDY0Zjk4ZmE3XG4gIHRoaXMuX2hsID0gMHhiZWZhNGZhNFxuXG4gIHJldHVybiB0aGlzXG59XG5cblNoYTM4NC5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQ4KVxuXG4gIGZ1bmN0aW9uIHdyaXRlSW50NjRCRSAoaCwgbCwgb2Zmc2V0KSB7XG4gICAgSC53cml0ZUludDMyQkUoaCwgb2Zmc2V0KVxuICAgIEgud3JpdGVJbnQzMkJFKGwsIG9mZnNldCArIDQpXG4gIH1cblxuICB3cml0ZUludDY0QkUodGhpcy5fYWgsIHRoaXMuX2FsLCAwKVxuICB3cml0ZUludDY0QkUodGhpcy5fYmgsIHRoaXMuX2JsLCA4KVxuICB3cml0ZUludDY0QkUodGhpcy5fY2gsIHRoaXMuX2NsLCAxNilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2RoLCB0aGlzLl9kbCwgMjQpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9laCwgdGhpcy5fZWwsIDMyKVxuICB3cml0ZUludDY0QkUodGhpcy5fZmgsIHRoaXMuX2ZsLCA0MClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTM4NFxuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBLID0gW1xuICAweDQyOGEyZjk4LCAweGQ3MjhhZTIyLCAweDcxMzc0NDkxLCAweDIzZWY2NWNkLFxuICAweGI1YzBmYmNmLCAweGVjNGQzYjJmLCAweGU5YjVkYmE1LCAweDgxODlkYmJjLFxuICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuICAweDkyM2Y4MmE0LCAweGFmMTk0ZjliLCAweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4LFxuICAweGQ4MDdhYTk4LCAweGEzMDMwMjQyLCAweDEyODM1YjAxLCAweDQ1NzA2ZmJlLFxuICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuICAweDcyYmU1ZDc0LCAweGYyN2I4OTZmLCAweDgwZGViMWZlLCAweDNiMTY5NmIxLFxuICAweDliZGMwNmE3LCAweDI1YzcxMjM1LCAweGMxOWJmMTc0LCAweGNmNjkyNjk0LFxuICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuICAweDBmYzE5ZGM2LCAweDhiOGNkNWI1LCAweDI0MGNhMWNjLCAweDc3YWM5YzY1LFxuICAweDJkZTkyYzZmLCAweDU5MmIwMjc1LCAweDRhNzQ4NGFhLCAweDZlYTZlNDgzLFxuICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuICAweDk4M2U1MTUyLCAweGVlNjZkZmFiLCAweGE4MzFjNjZkLCAweDJkYjQzMjEwLFxuICAweGIwMDMyN2M4LCAweDk4ZmIyMTNmLCAweGJmNTk3ZmM3LCAweGJlZWYwZWU0LFxuICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuICAweDA2Y2E2MzUxLCAweGUwMDM4MjZmLCAweDE0MjkyOTY3LCAweDBhMGU2ZTcwLFxuICAweDI3YjcwYTg1LCAweDQ2ZDIyZmZjLCAweDJlMWIyMTM4LCAweDVjMjZjOTI2LFxuICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuICAweDY1MGE3MzU0LCAweDhiYWY2M2RlLCAweDc2NmEwYWJiLCAweDNjNzdiMmE4LFxuICAweDgxYzJjOTJlLCAweDQ3ZWRhZWU2LCAweDkyNzIyYzg1LCAweDE0ODIzNTNiLFxuICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuICAweGMyNGI4YjcwLCAweGQwZjg5NzkxLCAweGM3NmM1MWEzLCAweDA2NTRiZTMwLFxuICAweGQxOTJlODE5LCAweGQ2ZWY1MjE4LCAweGQ2OTkwNjI0LCAweDU1NjVhOTEwLFxuICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuICAweDE5YTRjMTE2LCAweGI4ZDJkMGM4LCAweDFlMzc2YzA4LCAweDUxNDFhYjUzLFxuICAweDI3NDg3NzRjLCAweGRmOGVlYjk5LCAweDM0YjBiY2I1LCAweGUxOWI0OGE4LFxuICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuICAweDViOWNjYTRmLCAweDc3NjNlMzczLCAweDY4MmU2ZmYzLCAweGQ2YjJiOGEzLFxuICAweDc0OGY4MmVlLCAweDVkZWZiMmZjLCAweDc4YTU2MzZmLCAweDQzMTcyZjYwLFxuICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuICAweDkwYmVmZmZhLCAweDIzNjMxZTI4LCAweGE0NTA2Y2ViLCAweGRlODJiZGU5LFxuICAweGJlZjlhM2Y3LCAweGIyYzY3OTE1LCAweGM2NzE3OGYyLCAweGUzNzI1MzJiLFxuICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuICAweGVhZGE3ZGQ2LCAweGNkZTBlYjFlLCAweGY1N2Q0ZjdmLCAweGVlNmVkMTc4LFxuICAweDA2ZjA2N2FhLCAweDcyMTc2ZmJhLCAweDBhNjM3ZGM1LCAweGEyYzg5OGE2LFxuICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuICAweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0LCAweDMyY2FhYjdiLCAweDQwYzcyNDkzLFxuICAweDNjOWViZTBhLCAweDE1YzliZWJjLCAweDQzMWQ2N2M0LCAweDljMTAwZDRjLFxuICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuICAweDVmY2I2ZmFiLCAweDNhZDZmYWVjLCAweDZjNDQxOThjLCAweDRhNDc1ODE3XG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDE2MClcblxuZnVuY3Rpb24gU2hhNTEyICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgMTI4LCAxMTIpXG59XG5cbmluaGVyaXRzKFNoYTUxMiwgSGFzaClcblxuU2hhNTEyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9haCA9IDB4NmEwOWU2NjdcbiAgdGhpcy5fYmggPSAweGJiNjdhZTg1XG4gIHRoaXMuX2NoID0gMHgzYzZlZjM3MlxuICB0aGlzLl9kaCA9IDB4YTU0ZmY1M2FcbiAgdGhpcy5fZWggPSAweDUxMGU1MjdmXG4gIHRoaXMuX2ZoID0gMHg5YjA1Njg4Y1xuICB0aGlzLl9naCA9IDB4MWY4M2Q5YWJcbiAgdGhpcy5faGggPSAweDViZTBjZDE5XG5cbiAgdGhpcy5fYWwgPSAweGYzYmNjOTA4XG4gIHRoaXMuX2JsID0gMHg4NGNhYTczYlxuICB0aGlzLl9jbCA9IDB4ZmU5NGY4MmJcbiAgdGhpcy5fZGwgPSAweDVmMWQzNmYxXG4gIHRoaXMuX2VsID0gMHhhZGU2ODJkMVxuICB0aGlzLl9mbCA9IDB4MmIzZTZjMWZcbiAgdGhpcy5fZ2wgPSAweGZiNDFiZDZiXG4gIHRoaXMuX2hsID0gMHgxMzdlMjE3OVxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIENoICh4LCB5LCB6KSB7XG4gIHJldHVybiB6IF4gKHggJiAoeSBeIHopKVxufVxuXG5mdW5jdGlvbiBtYWogKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgfCAoeiAmICh4IHwgeSkpXG59XG5cbmZ1bmN0aW9uIHNpZ21hMCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAyOCB8IHhsIDw8IDQpIF4gKHhsID4+PiAyIHwgeCA8PCAzMCkgXiAoeGwgPj4+IDcgfCB4IDw8IDI1KVxufVxuXG5mdW5jdGlvbiBzaWdtYTEgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMTQgfCB4bCA8PCAxOCkgXiAoeCA+Pj4gMTggfCB4bCA8PCAxNCkgXiAoeGwgPj4+IDkgfCB4IDw8IDIzKVxufVxuXG5mdW5jdGlvbiBHYW1tYTAgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMSB8IHhsIDw8IDMxKSBeICh4ID4+PiA4IHwgeGwgPDwgMjQpIF4gKHggPj4+IDcpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMGwgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMSB8IHhsIDw8IDMxKSBeICh4ID4+PiA4IHwgeGwgPDwgMjQpIF4gKHggPj4+IDcgfCB4bCA8PCAyNSlcbn1cblxuZnVuY3Rpb24gR2FtbWExICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDE5IHwgeGwgPDwgMTMpIF4gKHhsID4+PiAyOSB8IHggPDwgMykgXiAoeCA+Pj4gNilcbn1cblxuZnVuY3Rpb24gR2FtbWExbCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxOSB8IHhsIDw8IDEzKSBeICh4bCA+Pj4gMjkgfCB4IDw8IDMpIF4gKHggPj4+IDYgfCB4bCA8PCAyNilcbn1cblxuZnVuY3Rpb24gZ2V0Q2FycnkgKGEsIGIpIHtcbiAgcmV0dXJuIChhID4+PiAwKSA8IChiID4+PiAwKSA/IDEgOiAwXG59XG5cblNoYTUxMi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhaCA9IHRoaXMuX2FoIHwgMFxuICB2YXIgYmggPSB0aGlzLl9iaCB8IDBcbiAgdmFyIGNoID0gdGhpcy5fY2ggfCAwXG4gIHZhciBkaCA9IHRoaXMuX2RoIHwgMFxuICB2YXIgZWggPSB0aGlzLl9laCB8IDBcbiAgdmFyIGZoID0gdGhpcy5fZmggfCAwXG4gIHZhciBnaCA9IHRoaXMuX2doIHwgMFxuICB2YXIgaGggPSB0aGlzLl9oaCB8IDBcblxuICB2YXIgYWwgPSB0aGlzLl9hbCB8IDBcbiAgdmFyIGJsID0gdGhpcy5fYmwgfCAwXG4gIHZhciBjbCA9IHRoaXMuX2NsIHwgMFxuICB2YXIgZGwgPSB0aGlzLl9kbCB8IDBcbiAgdmFyIGVsID0gdGhpcy5fZWwgfCAwXG4gIHZhciBmbCA9IHRoaXMuX2ZsIHwgMFxuICB2YXIgZ2wgPSB0aGlzLl9nbCB8IDBcbiAgdmFyIGhsID0gdGhpcy5faGwgfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSArPSAyKSB7XG4gICAgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gICAgV1tpICsgMV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0ICsgNClcbiAgfVxuICBmb3IgKDsgaSA8IDE2MDsgaSArPSAyKSB7XG4gICAgdmFyIHhoID0gV1tpIC0gMTUgKiAyXVxuICAgIHZhciB4bCA9IFdbaSAtIDE1ICogMiArIDFdXG4gICAgdmFyIGdhbW1hMCA9IEdhbW1hMCh4aCwgeGwpXG4gICAgdmFyIGdhbW1hMGwgPSBHYW1tYTBsKHhsLCB4aClcblxuICAgIHhoID0gV1tpIC0gMiAqIDJdXG4gICAgeGwgPSBXW2kgLSAyICogMiArIDFdXG4gICAgdmFyIGdhbW1hMSA9IEdhbW1hMSh4aCwgeGwpXG4gICAgdmFyIGdhbW1hMWwgPSBHYW1tYTFsKHhsLCB4aClcblxuICAgIC8vIFdbaV0gPSBnYW1tYTAgKyBXW2kgLSA3XSArIGdhbW1hMSArIFdbaSAtIDE2XVxuICAgIHZhciBXaTdoID0gV1tpIC0gNyAqIDJdXG4gICAgdmFyIFdpN2wgPSBXW2kgLSA3ICogMiArIDFdXG5cbiAgICB2YXIgV2kxNmggPSBXW2kgLSAxNiAqIDJdXG4gICAgdmFyIFdpMTZsID0gV1tpIC0gMTYgKiAyICsgMV1cblxuICAgIHZhciBXaWwgPSAoZ2FtbWEwbCArIFdpN2wpIHwgMFxuICAgIHZhciBXaWggPSAoZ2FtbWEwICsgV2k3aCArIGdldENhcnJ5KFdpbCwgZ2FtbWEwbCkpIHwgMFxuICAgIFdpbCA9IChXaWwgKyBnYW1tYTFsKSB8IDBcbiAgICBXaWggPSAoV2loICsgZ2FtbWExICsgZ2V0Q2FycnkoV2lsLCBnYW1tYTFsKSkgfCAwXG4gICAgV2lsID0gKFdpbCArIFdpMTZsKSB8IDBcbiAgICBXaWggPSAoV2loICsgV2kxNmggKyBnZXRDYXJyeShXaWwsIFdpMTZsKSkgfCAwXG5cbiAgICBXW2ldID0gV2loXG4gICAgV1tpICsgMV0gPSBXaWxcbiAgfVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgMTYwOyBqICs9IDIpIHtcbiAgICBXaWggPSBXW2pdXG4gICAgV2lsID0gV1tqICsgMV1cblxuICAgIHZhciBtYWpoID0gbWFqKGFoLCBiaCwgY2gpXG4gICAgdmFyIG1hamwgPSBtYWooYWwsIGJsLCBjbClcblxuICAgIHZhciBzaWdtYTBoID0gc2lnbWEwKGFoLCBhbClcbiAgICB2YXIgc2lnbWEwbCA9IHNpZ21hMChhbCwgYWgpXG4gICAgdmFyIHNpZ21hMWggPSBzaWdtYTEoZWgsIGVsKVxuICAgIHZhciBzaWdtYTFsID0gc2lnbWExKGVsLCBlaClcblxuICAgIC8vIHQxID0gaCArIHNpZ21hMSArIGNoICsgS1tqXSArIFdbal1cbiAgICB2YXIgS2loID0gS1tqXVxuICAgIHZhciBLaWwgPSBLW2ogKyAxXVxuXG4gICAgdmFyIGNoaCA9IENoKGVoLCBmaCwgZ2gpXG4gICAgdmFyIGNobCA9IENoKGVsLCBmbCwgZ2wpXG5cbiAgICB2YXIgdDFsID0gKGhsICsgc2lnbWExbCkgfCAwXG4gICAgdmFyIHQxaCA9IChoaCArIHNpZ21hMWggKyBnZXRDYXJyeSh0MWwsIGhsKSkgfCAwXG4gICAgdDFsID0gKHQxbCArIGNobCkgfCAwXG4gICAgdDFoID0gKHQxaCArIGNoaCArIGdldENhcnJ5KHQxbCwgY2hsKSkgfCAwXG4gICAgdDFsID0gKHQxbCArIEtpbCkgfCAwXG4gICAgdDFoID0gKHQxaCArIEtpaCArIGdldENhcnJ5KHQxbCwgS2lsKSkgfCAwXG4gICAgdDFsID0gKHQxbCArIFdpbCkgfCAwXG4gICAgdDFoID0gKHQxaCArIFdpaCArIGdldENhcnJ5KHQxbCwgV2lsKSkgfCAwXG5cbiAgICAvLyB0MiA9IHNpZ21hMCArIG1halxuICAgIHZhciB0MmwgPSAoc2lnbWEwbCArIG1hamwpIHwgMFxuICAgIHZhciB0MmggPSAoc2lnbWEwaCArIG1hamggKyBnZXRDYXJyeSh0MmwsIHNpZ21hMGwpKSB8IDBcblxuICAgIGhoID0gZ2hcbiAgICBobCA9IGdsXG4gICAgZ2ggPSBmaFxuICAgIGdsID0gZmxcbiAgICBmaCA9IGVoXG4gICAgZmwgPSBlbFxuICAgIGVsID0gKGRsICsgdDFsKSB8IDBcbiAgICBlaCA9IChkaCArIHQxaCArIGdldENhcnJ5KGVsLCBkbCkpIHwgMFxuICAgIGRoID0gY2hcbiAgICBkbCA9IGNsXG4gICAgY2ggPSBiaFxuICAgIGNsID0gYmxcbiAgICBiaCA9IGFoXG4gICAgYmwgPSBhbFxuICAgIGFsID0gKHQxbCArIHQybCkgfCAwXG4gICAgYWggPSAodDFoICsgdDJoICsgZ2V0Q2FycnkoYWwsIHQxbCkpIHwgMFxuICB9XG5cbiAgdGhpcy5fYWwgPSAodGhpcy5fYWwgKyBhbCkgfCAwXG4gIHRoaXMuX2JsID0gKHRoaXMuX2JsICsgYmwpIHwgMFxuICB0aGlzLl9jbCA9ICh0aGlzLl9jbCArIGNsKSB8IDBcbiAgdGhpcy5fZGwgPSAodGhpcy5fZGwgKyBkbCkgfCAwXG4gIHRoaXMuX2VsID0gKHRoaXMuX2VsICsgZWwpIHwgMFxuICB0aGlzLl9mbCA9ICh0aGlzLl9mbCArIGZsKSB8IDBcbiAgdGhpcy5fZ2wgPSAodGhpcy5fZ2wgKyBnbCkgfCAwXG4gIHRoaXMuX2hsID0gKHRoaXMuX2hsICsgaGwpIHwgMFxuXG4gIHRoaXMuX2FoID0gKHRoaXMuX2FoICsgYWggKyBnZXRDYXJyeSh0aGlzLl9hbCwgYWwpKSB8IDBcbiAgdGhpcy5fYmggPSAodGhpcy5fYmggKyBiaCArIGdldENhcnJ5KHRoaXMuX2JsLCBibCkpIHwgMFxuICB0aGlzLl9jaCA9ICh0aGlzLl9jaCArIGNoICsgZ2V0Q2FycnkodGhpcy5fY2wsIGNsKSkgfCAwXG4gIHRoaXMuX2RoID0gKHRoaXMuX2RoICsgZGggKyBnZXRDYXJyeSh0aGlzLl9kbCwgZGwpKSB8IDBcbiAgdGhpcy5fZWggPSAodGhpcy5fZWggKyBlaCArIGdldENhcnJ5KHRoaXMuX2VsLCBlbCkpIHwgMFxuICB0aGlzLl9maCA9ICh0aGlzLl9maCArIGZoICsgZ2V0Q2FycnkodGhpcy5fZmwsIGZsKSkgfCAwXG4gIHRoaXMuX2doID0gKHRoaXMuX2doICsgZ2ggKyBnZXRDYXJyeSh0aGlzLl9nbCwgZ2wpKSB8IDBcbiAgdGhpcy5faGggPSAodGhpcy5faGggKyBoaCArIGdldENhcnJ5KHRoaXMuX2hsLCBobCkpIHwgMFxufVxuXG5TaGE1MTIucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg2NClcblxuICBmdW5jdGlvbiB3cml0ZUludDY0QkUgKGgsIGwsIG9mZnNldCkge1xuICAgIEgud3JpdGVJbnQzMkJFKGgsIG9mZnNldClcbiAgICBILndyaXRlSW50MzJCRShsLCBvZmZzZXQgKyA0KVxuICB9XG5cbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2FoLCB0aGlzLl9hbCwgMClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2JoLCB0aGlzLl9ibCwgOClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2NoLCB0aGlzLl9jbCwgMTYpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9kaCwgdGhpcy5fZGwsIDI0KVxuICB3cml0ZUludDY0QkUodGhpcy5fZWgsIHRoaXMuX2VsLCAzMilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2ZoLCB0aGlzLl9mbCwgNDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9naCwgdGhpcy5fZ2wsIDQ4KVxuICB3cml0ZUludDY0QkUodGhpcy5faGgsIHRoaXMuX2hsLCA1NilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTUxMlxuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgICB7XG4gICAgIFwicGF5YWJsZVwiOiB0cnVlLFxuICAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcInBheWFibGVcIixcbiAgICAgXCJ0eXBlXCI6IFwiZmFsbGJhY2tcIlxuICAgIH0sXG4gICAge1xuICAgICBcImNvbnN0YW50XCI6IHRydWUsXG4gICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICBcIm5hbWVcIjogXCJ1c2VyXCIsXG4gICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgIFwibmFtZVwiOiBcInRva2VuXCIsXG4gICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgIF0sXG4gICAgIFwibmFtZVwiOiBcInRva2VuQmFsYW5jZVwiLFxuICAgICBcIm91dHB1dHNcIjogW1xuICAgICAge1xuICAgICAgIFwibmFtZVwiOiBcIlwiLFxuICAgICAgIFwidHlwZVwiOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgICBdLFxuICAgICBcInBheWFibGVcIjogZmFsc2UsXG4gICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwidmlld1wiLFxuICAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICB7XG4gICAgIFwiY29uc3RhbnRcIjogdHJ1ZSxcbiAgICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgIFwibmFtZVwiOiBcInVzZXJzXCIsXG4gICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1tdXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgXCJuYW1lXCI6IFwidG9rZW5zXCIsXG4gICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1tdXCJcbiAgICAgIH1cbiAgICAgXSxcbiAgICAgXCJuYW1lXCI6IFwiYmFsYW5jZXNcIixcbiAgICAgXCJvdXRwdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICBcIm5hbWVcIjogXCJcIixcbiAgICAgICBcInR5cGVcIjogXCJ1aW50MjU2W11cIlxuICAgICAgfVxuICAgICBdLFxuICAgICBcInBheWFibGVcIjogZmFsc2UsXG4gICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwidmlld1wiLFxuICAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gICAgfVxuICAgXVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgYWRkZWQgd2hlbiBlbmRpbmcgb24gYSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJztcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59IiwidmFyIGlzSGV4UHJlZml4ZWQgPSByZXF1aXJlKCdpcy1oZXgtcHJlZml4ZWQnKTtcblxuLyoqXG4gKiBSZW1vdmVzICcweCcgZnJvbSBhIGdpdmVuIGBTdHJpbmdgIGlzIHByZXNlbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfE9wdGlvbmFsfSBhIHN0cmluZyBieSBwYXNzIGlmIG5lY2Vzc2FyeVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0cmlwSGV4UHJlZml4KHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgcmV0dXJuIGlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ci5zbGljZSgyKSA6IHN0cjtcbn1cbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuU3VwZXJzdHJ1Y3QgPSB7fSkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIEEgYFN0cnVjdEZhaWx1cmVgIHJlcHJlc2VudHMgYSBzaW5nbGUgc3BlY2lmaWMgZmFpbHVyZSBpbiB2YWxpZGF0aW9uLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIGBTdHJ1Y3RFcnJvcmAgb2JqZWN0cyBhcmUgdGhyb3duIChvciByZXR1cm5lZCkgd2hlbiB2YWxpZGF0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogVmFsaWRhdGlvbiBsb2dpYyBpcyBkZXNpZ24gdG8gZXhpdCBlYXJseSBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZS4gVGhlIGVycm9yXG4gICAgICogcmVwcmVzZW50cyB0aGUgZmlyc3QgZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIHZhbGlkYXRpb24uIEZvciBtb3JlIGRldGFpbCxcbiAgICAgKiB0aGUgYGVycm9yLmZhaWx1cmVzYCBwcm9wZXJ0eSBpcyBhIGdlbmVyYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSBydW4gdG9cbiAgICAgKiBjb250aW51ZSB2YWxpZGF0aW9uIGFuZCByZWNlaXZlIGFsbCB0aGUgZmFpbHVyZXMgaW4gdGhlIGRhdGEuXG4gICAgICovXG4gICAgY2xhc3MgU3RydWN0RXJyb3IgZXh0ZW5kcyBUeXBlRXJyb3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcihmYWlsdXJlLCBmYWlsdXJlcykge1xuICAgICAgICAgICAgbGV0IGNhY2hlZDtcbiAgICAgICAgICAgIGNvbnN0IHsgbWVzc2FnZSwgZXhwbGFuYXRpb24sIC4uLnJlc3QgfSA9IGZhaWx1cmU7XG4gICAgICAgICAgICBjb25zdCB7IHBhdGggfSA9IGZhaWx1cmU7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBwYXRoLmxlbmd0aCA9PT0gMCA/IG1lc3NhZ2UgOiBgQXQgcGF0aDogJHtwYXRoLmpvaW4oJy4nKX0gLS0gJHttZXNzYWdlfWA7XG4gICAgICAgICAgICBzdXBlcihleHBsYW5hdGlvbiA/PyBtc2cpO1xuICAgICAgICAgICAgaWYgKGV4cGxhbmF0aW9uICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5jYXVzZSA9IG1zZztcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcmVzdCk7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgICAgICB0aGlzLmZhaWx1cmVzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoY2FjaGVkID8/IChjYWNoZWQgPSBbZmFpbHVyZSwgLi4uZmFpbHVyZXMoKV0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGl0ZXJhdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSXRlcmFibGUoeCkge1xuICAgICAgICByZXR1cm4gaXNPYmplY3QoeCkgJiYgdHlwZW9mIHhbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoeCkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih4KTtcbiAgICAgICAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHZhbHVlIGFzIGEgcHJpbnRhYmxlIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcmludCh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOiBgJHt2YWx1ZX1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaGlmdHMgKHJlbW92ZXMgYW5kIHJldHVybnMpIHRoZSBmaXJzdCB2YWx1ZSBmcm9tIHRoZSBgaW5wdXRgIGl0ZXJhdG9yLlxuICAgICAqIExpa2UgYEFycmF5LnByb3RvdHlwZS5zaGlmdCgpYCBidXQgZm9yIGFuIGBJdGVyYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hpZnRJdGVyYXRvcihpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBpbnB1dC5uZXh0KCk7XG4gICAgICAgIHJldHVybiBkb25lID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBzaW5nbGUgdmFsaWRhdGlvbiByZXN1bHQgdG8gYSBmYWlsdXJlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvRmFpbHVyZShyZXN1bHQsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7IG1lc3NhZ2U6IHJlc3VsdCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcGF0aCwgYnJhbmNoIH0gPSBjb250ZXh0O1xuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHN0cnVjdDtcbiAgICAgICAgY29uc3QgeyByZWZpbmVtZW50LCBtZXNzYWdlID0gYEV4cGVjdGVkIGEgdmFsdWUgb2YgdHlwZSBcXGAke3R5cGV9XFxgJHtyZWZpbmVtZW50ID8gYCB3aXRoIHJlZmluZW1lbnQgXFxgJHtyZWZpbmVtZW50fVxcYGAgOiAnJ30sIGJ1dCByZWNlaXZlZDogXFxgJHtwcmludCh2YWx1ZSl9XFxgYCwgfSA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHJlZmluZW1lbnQsXG4gICAgICAgICAgICBrZXk6IHBhdGhbcGF0aC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBicmFuY2gsXG4gICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgdmFsaWRhdGlvbiByZXN1bHQgdG8gYW4gaXRlcmFibGUgb2YgZmFpbHVyZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24qIHRvRmFpbHVyZXMocmVzdWx0LCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNJdGVyYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBbcmVzdWx0XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHIgb2YgcmVzdWx0KSB7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlID0gdG9GYWlsdXJlKHIsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBmYWlsdXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGEgdmFsdWUgYWdhaW5zdCBhIHN0cnVjdCwgdHJhdmVyc2luZyBkZWVwbHkgaW50byBuZXN0ZWQgdmFsdWVzLCBhbmRcbiAgICAgKiByZXR1cm5pbmcgYW4gaXRlcmF0b3Igb2YgZmFpbHVyZXMgb3Igc3VjY2Vzcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiogcnVuKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IHBhdGggPSBbXSwgYnJhbmNoID0gW3ZhbHVlXSwgY29lcmNlID0gZmFsc2UsIG1hc2sgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgY3R4ID0geyBwYXRoLCBicmFuY2ggfTtcbiAgICAgICAgaWYgKGNvZXJjZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIGlmIChtYXNrICYmXG4gICAgICAgICAgICAgICAgc3RydWN0LnR5cGUgIT09ICd0eXBlJyAmJlxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KHN0cnVjdC5zY2hlbWEpICYmXG4gICAgICAgICAgICAgICAgaXNPYmplY3QodmFsdWUpICYmXG4gICAgICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cnVjdC5zY2hlbWFba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdHVzID0gJ3ZhbGlkJztcbiAgICAgICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCkpIHtcbiAgICAgICAgICAgIGZhaWx1cmUuZXhwbGFuYXRpb24gPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgICAgICAgICBzdGF0dXMgPSAnbm90X3ZhbGlkJztcbiAgICAgICAgICAgIHlpZWxkIFtmYWlsdXJlLCB1bmRlZmluZWRdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IFtrLCB2LCBzXSBvZiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KSkge1xuICAgICAgICAgICAgY29uc3QgdHMgPSBydW4odiwgcywge1xuICAgICAgICAgICAgICAgIHBhdGg6IGsgPT09IHVuZGVmaW5lZCA/IHBhdGggOiBbLi4ucGF0aCwga10sXG4gICAgICAgICAgICAgICAgYnJhbmNoOiBrID09PSB1bmRlZmluZWQgPyBicmFuY2ggOiBbLi4uYnJhbmNoLCB2XSxcbiAgICAgICAgICAgICAgICBjb2VyY2UsXG4gICAgICAgICAgICAgICAgbWFzayxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLm1lc3NhZ2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdCBvZiB0cykge1xuICAgICAgICAgICAgICAgIGlmICh0WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IHRbMF0ucmVmaW5lbWVudCAhPSBudWxsID8gJ25vdF9yZWZpbmVkJyA6ICdub3RfdmFsaWQnO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbdFswXSwgdW5kZWZpbmVkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29lcmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSB0WzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNldChrLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuYWRkKHYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCB8fCBrIGluIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzICE9PSAnbm90X3ZhbGlkJykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpKSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZS5leHBsYW5hdGlvbiA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSAnbm90X3JlZmluZWQnO1xuICAgICAgICAgICAgICAgIHlpZWxkIFtmYWlsdXJlLCB1bmRlZmluZWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMgPT09ICd2YWxpZCcpIHtcbiAgICAgICAgICAgIHlpZWxkIFt1bmRlZmluZWQsIHZhbHVlXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGBTdHJ1Y3RgIG9iamVjdHMgZW5jYXBzdWxhdGUgdGhlIHZhbGlkYXRpb24gbG9naWMgZm9yIGEgc3BlY2lmaWMgdHlwZSBvZlxuICAgICAqIHZhbHVlcy4gT25jZSBjb25zdHJ1Y3RlZCwgeW91IHVzZSB0aGUgYGFzc2VydGAsIGBpc2Agb3IgYHZhbGlkYXRlYCBoZWxwZXJzIHRvXG4gICAgICogdmFsaWRhdGUgdW5rbm93biBpbnB1dCBkYXRhIGFnYWluc3QgdGhlIHN0cnVjdC5cbiAgICAgKi9cbiAgICBjbGFzcyBTdHJ1Y3Qge1xuICAgICAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICAgICAgY29uc3QgeyB0eXBlLCBzY2hlbWEsIHZhbGlkYXRvciwgcmVmaW5lciwgY29lcmNlciA9ICh2YWx1ZSkgPT4gdmFsdWUsIGVudHJpZXMgPSBmdW5jdGlvbiogKCkgeyB9LCB9ID0gcHJvcHM7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgICAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgICAgICAgICAgdGhpcy5jb2VyY2VyID0gY29lcmNlcjtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRvciA9ICh2YWx1ZSwgY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0b3IgPSAoKSA9PiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWZpbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZpbmVyID0gKHZhbHVlLCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZmluZXIodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZpbmVyID0gKCkgPT4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc2VydCB0aGF0IGEgdmFsdWUgcGFzc2VzIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uLCB0aHJvd2luZyBpZiBpdCBkb2Vzbid0LlxuICAgICAgICAgKi9cbiAgICAgICAgYXNzZXJ0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXNzZXJ0KHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgdmFsdWUgd2l0aCB0aGUgc3RydWN0J3MgY29lcmNpb24gbG9naWMsIHRoZW4gdmFsaWRhdGUgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGUodmFsdWUsIHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBhIHZhbHVlIHBhc3NlcyB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXModmFsdWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXNrIGEgdmFsdWUsIGNvZXJjaW5nIGFuZCB2YWxpZGF0aW5nIGl0LCBidXQgcmV0dXJuaW5nIG9ubHkgdGhlIHN1YnNldCBvZlxuICAgICAgICAgKiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgdGhlIHN0cnVjdCdzIHNjaGVtYS5cbiAgICAgICAgICovXG4gICAgICAgIG1hc2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXNrKHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdGUgYSB2YWx1ZSB3aXRoIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uIGxvZ2ljLCByZXR1cm5pbmcgYSB0dXBsZVxuICAgICAgICAgKiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogWW91IG1heSBvcHRpb25hbGx5IHBhc3MgYHRydWVgIGZvciB0aGUgYHdpdGhDb2VyY2lvbmAgYXJndW1lbnQgdG8gY29lcmNlXG4gICAgICAgICAqIHRoZSB2YWx1ZSBiZWZvcmUgYXR0ZW1wdGluZyB0byB2YWxpZGF0ZSBpdC4gSWYgeW91IGRvLCB0aGUgcmVzdWx0IHdpbGxcbiAgICAgICAgICogY29udGFpbiB0aGUgY29lcmNlZCByZXN1bHQgd2hlbiBzdWNjZXNzZnVsLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHZhbHVlLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyBhIHN0cnVjdCwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlcnQodmFsdWUsIHN0cnVjdCwgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7IG1lc3NhZ2UgfSk7XG4gICAgICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgICAgICAgIHRocm93IHJlc3VsdFswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB2YWx1ZSB3aXRoIHRoZSBjb2VyY2lvbiBsb2dpYyBvZiBzdHJ1Y3QgYW5kIHZhbGlkYXRlIGl0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSwgc3RydWN0LCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHsgY29lcmNlOiB0cnVlLCBtZXNzYWdlIH0pO1xuICAgICAgICBpZiAocmVzdWx0WzBdKSB7XG4gICAgICAgICAgICB0aHJvdyByZXN1bHRbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0WzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hc2sgYSB2YWx1ZSwgcmV0dXJuaW5nIG9ubHkgdGhlIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgYSBzdHJ1Y3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFzayh2YWx1ZSwgc3RydWN0LCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHsgY29lcmNlOiB0cnVlLCBtYXNrOiB0cnVlLCBtZXNzYWdlIH0pO1xuICAgICAgICBpZiAocmVzdWx0WzBdKSB7XG4gICAgICAgICAgICB0aHJvdyByZXN1bHRbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0WzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdmFsdWUgcGFzc2VzIGEgc3RydWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlLCBzdHJ1Y3QpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCk7XG4gICAgICAgIHJldHVybiAhcmVzdWx0WzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBhIHZhbHVlIGFnYWluc3QgYSBzdHJ1Y3QsIHJldHVybmluZyBhbiBlcnJvciBpZiBpbnZhbGlkLCBvciB0aGVcbiAgICAgKiB2YWx1ZSAod2l0aCBwb3RlbnRpYWwgY29lcmNpb24pIGlmIHZhbGlkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB0dXBsZXMgPSBydW4odmFsdWUsIHN0cnVjdCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHR1cGxlID0gc2hpZnRJdGVyYXRvcih0dXBsZXMpO1xuICAgICAgICBpZiAodHVwbGVbMF0pIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFN0cnVjdEVycm9yKHR1cGxlWzBdLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdCBvZiB0dXBsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBbZXJyb3IsIHVuZGVmaW5lZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdHVwbGVbMV07XG4gICAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3NpZ24oLi4uU3RydWN0cykge1xuICAgICAgICBjb25zdCBpc1R5cGUgPSBTdHJ1Y3RzWzBdLnR5cGUgPT09ICd0eXBlJztcbiAgICAgICAgY29uc3Qgc2NoZW1hcyA9IFN0cnVjdHMubWFwKChzKSA9PiBzLnNjaGVtYSk7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IE9iamVjdC5hc3NpZ24oe30sIC4uLnNjaGVtYXMpO1xuICAgICAgICByZXR1cm4gaXNUeXBlID8gdHlwZShzY2hlbWEpIDogb2JqZWN0KHNjaGVtYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZSBhIG5ldyBzdHJ1Y3QgdHlwZSB3aXRoIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmaW5lKG5hbWUsIHZhbGlkYXRvcikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdCh7IHR5cGU6IG5hbWUsIHNjaGVtYTogbnVsbCwgdmFsaWRhdG9yIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIHN0cnVjdCwgYnV0IHRoZSB2YWx1ZSBpcyBhbGxvd2VkIHRvXG4gICAgICogYmUgYHVuZGVmaW5lZGAuIGBsb2dgIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSB2YWx1ZSBpcyBub3QgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZChzdHJ1Y3QsIGxvZykge1xuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgICAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSxcbiAgICAgICAgICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2codmFsdWUsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzdHJ1Y3Qgd2l0aCBkeW5hbWljIHZhbGlkYXRpb24gbG9naWMuXG4gICAgICpcbiAgICAgKiBUaGUgY2FsbGJhY2sgd2lsbCByZWNlaXZlIHRoZSB2YWx1ZSBjdXJyZW50bHkgYmVpbmcgdmFsaWRhdGVkLCBhbmQgbXVzdFxuICAgICAqIHJldHVybiBhIHN0cnVjdCBvYmplY3QgdG8gdmFsaWRhdGUgaXQgd2l0aC4gVGhpcyBjYW4gYmUgdXNlZnVsIHRvIG1vZGVsXG4gICAgICogdmFsaWRhdGlvbiBsb2dpYyB0aGF0IGNoYW5nZXMgYmFzZWQgb24gaXRzIGlucHV0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGR5bmFtaWMoZm4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ2R5bmFtaWMnLFxuICAgICAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAgICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvZXJjZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgc3RydWN0IHdpdGggbGF6aWx5IGV2YWx1YXRlZCB2YWxpZGF0aW9uIGxvZ2ljLlxuICAgICAqXG4gICAgICogVGhlIGZpcnN0IHRpbWUgdmFsaWRhdGlvbiBpcyBydW4gd2l0aCB0aGUgc3RydWN0LCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcbiAgICAgKiBhbmQgbXVzdCByZXR1cm4gYSBzdHJ1Y3Qgb2JqZWN0IHRvIHVzZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGNhc2VzIHdoZXJlIHlvdVxuICAgICAqIHdhbnQgdG8gaGF2ZSBzZWxmLXJlZmVyZW50aWFsIHN0cnVjdHMgZm9yIG5lc3RlZCBkYXRhIHN0cnVjdHVyZXMgdG8gYXZvaWQgYVxuICAgICAqIGNpcmN1bGFyIGRlZmluaXRpb24gcHJvYmxlbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5KGZuKSB7XG4gICAgICAgIGxldCBzdHJ1Y3Q7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdsYXp5JyxcbiAgICAgICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgICAgICplbnRyaWVzKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgICAgICBzdHJ1Y3QgPz8gKHN0cnVjdCA9IGZuKCkpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgICAgIHN0cnVjdCA/PyAoc3RydWN0ID0gZm4oKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29lcmNlcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgZXhjbHVkaW5nXG4gICAgICogc3BlY2lmaWMgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIExpa2UgVHlwZVNjcmlwdCdzIGBPbWl0YCB1dGlsaXR5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9taXQoc3RydWN0LCBrZXlzKSB7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hIH0gPSBzdHJ1Y3Q7XG4gICAgICAgIGNvbnN0IHN1YnNjaGVtYSA9IHsgLi4uc2NoZW1hIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdWJzY2hlbWFba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHN0cnVjdC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZShzdWJzY2hlbWEpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0KHN1YnNjaGVtYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgd2l0aCBhbGwgb2YgaXRzXG4gICAgICogcHJvcGVydGllcyBhbGxvd2VkIHRvIGJlIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogTGlrZSBUeXBlU2NyaXB0J3MgYFBhcnRpYWxgIHV0aWxpdHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFydGlhbChzdHJ1Y3QpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gc3RydWN0IGluc3RhbmNlb2YgU3RydWN0ID8geyAuLi5zdHJ1Y3Quc2NoZW1hIH0gOiB7IC4uLnN0cnVjdCB9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgICAgIHNjaGVtYVtrZXldID0gb3B0aW9uYWwoc2NoZW1hW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Qoc2NoZW1hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgb25seSBpbmNsdWRpbmdcbiAgICAgKiBzcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogTGlrZSBUeXBlU2NyaXB0J3MgYFBpY2tgIHV0aWxpdHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGljayhzdHJ1Y3QsIGtleXMpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEgfSA9IHN0cnVjdDtcbiAgICAgICAgY29uc3Qgc3Vic2NoZW1hID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIHN1YnNjaGVtYVtrZXldID0gc2NoZW1hW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdChzdWJzY2hlbWEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgYSBuZXcgc3RydWN0IHR5cGUgd2l0aCBhIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiBoYXMgYmVlbiByZW5hbWVkIHRvIGBkZWZpbmVgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cnVjdChuYW1lLCB2YWxpZGF0b3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdzdXBlcnN0cnVjdEAwLjExIC0gVGhlIGBzdHJ1Y3RgIGhlbHBlciBoYXMgYmVlbiByZW5hbWVkIHRvIGBkZWZpbmVgLicpO1xuICAgICAgICByZXR1cm4gZGVmaW5lKG5hbWUsIHZhbGlkYXRvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYW55IHZhbHVlIHBhc3NlcyB2YWxpZGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFueSgpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSgnYW55JywgKCkgPT4gdHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFycmF5KEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICAgIHNjaGVtYTogRWxlbWVudCxcbiAgICAgICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKEVsZW1lbnQgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaSwgdl0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaSwgdiwgRWxlbWVudF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLnNsaWNlKCkgOiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhbiBhcnJheSB2YWx1ZSwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYmlnaW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpZ2ludCgpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSgnYmlnaW50JywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBib29sZWFuLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJvb2xlYW4oKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUoJ2Jvb2xlYW4nLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBgRGF0ZWAuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIGFsc28gZW5zdXJlcyB0aGF0IHRoZSB2YWx1ZSBpcyAqbm90KiBhbiBpbnZhbGlkIGBEYXRlYCBvYmplY3QsXG4gICAgICogd2hpY2ggY2FuIG9jY3VyIHdoZW4gcGFyc2luZyBhIGRhdGUgZmFpbHMgYnV0IHN0aWxsIHJldHVybnMgYSBgRGF0ZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSgnZGF0ZScsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICgodmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTih2YWx1ZS5nZXRUaW1lKCkpKSB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhIHZhbGlkIFxcYERhdGVcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW51bXModmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHt9O1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHZhbHVlcy5tYXAoKHYpID0+IHByaW50KHYpKS5qb2luKCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHZhbHVlcykge1xuICAgICAgICAgICAgc2NoZW1hW2tleV0gPSBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ2VudW1zJyxcbiAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWVzLmluY2x1ZGVzKHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgb25lIG9mIFxcYCR7ZGVzY3JpcHRpb259XFxgLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jKCkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKCdmdW5jJywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhIGZ1bmN0aW9uLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiBhIHNwZWNpZmljIGNsYXNzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc3RhbmNlKENsYXNzKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUoJ2luc3RhbmNlJywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgQ2xhc3MgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSBcXGAke0NsYXNzLm5hbWV9XFxgIGluc3RhbmNlLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVnZXIoKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUoJ2ludGVnZXInLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSAmJiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYW4gaW50ZWdlciwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgbWF0Y2hlcyBhbGwgb2YgYSBzZXQgb2YgdHlwZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0aW9uKFN0cnVjdHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ2ludGVyc2VjdGlvbicsXG4gICAgICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIFMuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKnZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIFMudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAqcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIFMucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGl0ZXJhbChjb25zdGFudCkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHByaW50KGNvbnN0YW50KTtcbiAgICAgICAgY29uc3QgdCA9IHR5cGVvZiBjb25zdGFudDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ2xpdGVyYWwnLFxuICAgICAgICAgICAgc2NoZW1hOiB0ID09PSAnc3RyaW5nJyB8fCB0ID09PSAnbnVtYmVyJyB8fCB0ID09PSAnYm9vbGVhbicgPyBjb25zdGFudCA6IG51bGwsXG4gICAgICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbHVlID09PSBjb25zdGFudCB8fFxuICAgICAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgdGhlIGxpdGVyYWwgXFxgJHtkZXNjcmlwdGlvbn1cXGAsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFwKEtleSwgVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ21hcCcsXG4gICAgICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChLZXkgJiYgVmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgaywgS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrLCB2LCBWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCA/IG5ldyBNYXAodmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fFxuICAgICAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSBcXGBNYXBcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IG5vIHZhbHVlIGV2ZXIgcGFzc2VzIHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmV2ZXIoKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUoJ25ldmVyJywgKCkgPT4gZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdWdtZW50IGFuIGV4aXN0aW5nIHN0cnVjdCB0byBhbGxvdyBgbnVsbGAgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG51bGxhYmxlKHN0cnVjdCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgICAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgICAgICAgICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSBudWxsIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudW1iZXIoKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUoJ251bWJlcicsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICgodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpKSB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhIG51bWJlciwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9iamVjdChzY2hlbWEpIHtcbiAgICAgICAgY29uc3Qga25vd25zID0gc2NoZW1hID8gT2JqZWN0LmtleXMoc2NoZW1hKSA6IFtdO1xuICAgICAgICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgc2NoZW1hOiBzY2hlbWEgPyBzY2hlbWEgOiBudWxsLFxuICAgICAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hICYmIGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1bmtub3ducyA9IG5ldyBTZXQoT2JqZWN0LmtleXModmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga25vd25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmtub3ducy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlW2tleV0sIHNjaGVtYVtrZXldXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1bmtub3ducykge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVba2V5XSwgTmV2ZXJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaXNPYmplY3QodmFsdWUpIHx8IGBFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB7IC4uLnZhbHVlIH0gOiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdWdtZW50IGEgc3RydWN0IHRvIGFsbG93IGB1bmRlZmluZWRgIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvcHRpb25hbChzdHJ1Y3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICAgICAgdmFsaWRhdG9yOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgICAgICAgICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGtleXMgYW5kIHZhbHVlcyBvZiBzcGVjaWZpYyB0eXBlcywgYnV0XG4gICAgICogd2l0aG91dCBlbnN1cmluZyBhbnkgc3BlY2lmaWMgc2hhcGUgb2YgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIExpa2UgVHlwZVNjcmlwdCdzIGBSZWNvcmRgIHV0aWxpdHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVjb3JkKEtleSwgVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ3JlY29yZCcsXG4gICAgICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgaywgS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrLCB2LCBWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpc09iamVjdCh2YWx1ZSkgfHwgYEV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYFJlZ0V4cGAuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIGRvZXMgbm90IHRlc3QgdGhlIHZhbHVlIGFnYWluc3QgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiEgRm9yIHRoYXRcbiAgICAgKiB5b3UgbmVlZCB0byB1c2UgdGhlIGBwYXR0ZXJuKClgIHJlZmluZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVnZXhwKCkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKCdyZWdleHAnLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldChFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdzZXQnLFxuICAgICAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoRWxlbWVudCAmJiB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFt2LCB2LCBFbGVtZW50XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2V0ID8gbmV3IFNldCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgU2V0IHx8XG4gICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhIFxcYFNldFxcYCBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUoJ3N0cmluZycsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgc3RyaW5nLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHR1cGxlIG9mIGEgc3BlY2lmaWMgbGVuZ3RoLCBhbmQgdGhhdCBlYWNoIG9mIGl0c1xuICAgICAqIGVsZW1lbnRzIGlzIG9mIGEgc3BlY2lmaWMgdHlwZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0dXBsZShTdHJ1Y3RzKSB7XG4gICAgICAgIGNvbnN0IE5ldmVyID0gbmV2ZXIoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ3R1cGxlJyxcbiAgICAgICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KFN0cnVjdHMubGVuZ3RoLCB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaSwgdmFsdWVbaV0sIFN0cnVjdHNbaV0gfHwgTmV2ZXJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgYEV4cGVjdGVkIGFuIGFycmF5LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaGFzIGEgc2V0IG9mIGtub3duIHByb3BlcnRpZXMgb2Ygc3BlY2lmaWMgdHlwZXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiBVbnJlY29nbml6ZWQgcHJvcGVydGllcyBhcmUgYWxsb3dlZCBhbmQgdW50b3VjaGVkLiBUaGlzIGlzIHNpbWlsYXIgdG9cbiAgICAgKiBob3cgVHlwZVNjcmlwdCdzIHN0cnVjdHVyYWwgdHlwaW5nIHdvcmtzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHR5cGUoc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEpO1xuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgICAgICB0eXBlOiAndHlwZScsXG4gICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIGtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrLCB2YWx1ZVtrXSwgc2NoZW1hW2tdXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGlzT2JqZWN0KHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8geyAuLi52YWx1ZSB9IDogdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBtYXRjaGVzIG9uZSBvZiBhIHNldCBvZiB0eXBlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlvbihTdHJ1Y3RzKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gU3RydWN0cy5tYXAoKHMpID0+IHMudHlwZSkuam9pbignIHwgJyk7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgICAgIHR5cGU6ICd1bmlvbicsXG4gICAgICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2Vycm9yLCBjb2VyY2VkXSA9IFMudmFsaWRhdGUodmFsdWUsIHsgY29lcmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29lcmNlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFsuLi50dXBsZXNdID0gcnVuKHZhbHVlLCBTLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbZmlyc3RdID0gdHVwbGVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpcnN0WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtmYWlsdXJlXSBvZiB0dXBsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlcy5wdXNoKGZhaWx1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgdGhlIHZhbHVlIHRvIHNhdGlzZnkgYSB1bmlvbiBvZiBcXGAke2Rlc2NyaXB0aW9ufVxcYCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gLFxuICAgICAgICAgICAgICAgICAgICAuLi5mYWlsdXJlcyxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGFueSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbiwgd2l0aG91dCB3aWRlbmluZyBpdHMgdHlwZSB0byBgYW55YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmtub3duKCkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKCd1bmtub3duJywgKCkgPT4gdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXVnbWVudCBhIGBTdHJ1Y3RgIHRvIGFkZCBhbiBhZGRpdGlvbmFsIGNvZXJjaW9uIHN0ZXAgdG8gaXRzIGlucHV0LlxuICAgICAqXG4gICAgICogVGhpcyBhbGxvd3MgeW91IHRvIHRyYW5zZm9ybSBpbnB1dCBkYXRhIGJlZm9yZSB2YWxpZGF0aW5nIGl0LCB0byBpbmNyZWFzZSB0aGVcbiAgICAgKiBsaWtlbGlob29kIHRoYXQgaXQgcGFzc2VzIHZhbGlkYXRpb27igJRmb3IgZXhhbXBsZSBmb3IgZGVmYXVsdCB2YWx1ZXMsIHBhcnNpbmdcbiAgICAgKiBkaWZmZXJlbnQgZm9ybWF0cywgZXRjLlxuICAgICAqXG4gICAgICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICAgICAqIHRha2UgZWZmZWN0ISBVc2luZyBzaW1wbHkgYGFzc2VydCgpYCBvciBgaXMoKWAgd2lsbCBub3QgdXNlIGNvZXJjaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvZXJjZShzdHJ1Y3QsIGNvbmRpdGlvbiwgY29lcmNlcikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgICAgICBjb2VyY2VyOiAodmFsdWUsIGN0eCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpcyh2YWx1ZSwgY29uZGl0aW9uKVxuICAgICAgICAgICAgICAgICAgICA/IHN0cnVjdC5jb2VyY2VyKGNvZXJjZXIodmFsdWUsIGN0eCksIGN0eClcbiAgICAgICAgICAgICAgICAgICAgOiBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdWdtZW50IGEgc3RydWN0IHRvIHJlcGxhY2UgYHVuZGVmaW5lZGAgdmFsdWVzIHdpdGggYSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICAgICAqIHRha2UgZWZmZWN0ISBVc2luZyBzaW1wbHkgYGFzc2VydCgpYCBvciBgaXMoKWAgd2lsbCBub3QgdXNlIGNvZXJjaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRlZChzdHJ1Y3QsIGZhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGNvZXJjZShzdHJ1Y3QsIHVua25vd24oKSwgKHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0eXBlb2YgZmFsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBmYWxsYmFjaygpIDogZmFsbGJhY2s7XG4gICAgICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc3RyaWN0ICYmIGlzUGxhaW5PYmplY3QoeCkgJiYgaXNQbGFpbk9iamVjdChmKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IHsgLi4ueCB9O1xuICAgICAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0W2tleV0gPSBmW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXVnbWVudCBhIHN0cnVjdCB0byB0cmltIHN0cmluZyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gICAgICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbW1lZChzdHJ1Y3QpIHtcbiAgICAgICAgcmV0dXJuIGNvZXJjZShzdHJ1Y3QsIHN0cmluZygpLCAoeCkgPT4geC50cmltKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbWFwLCBvciBzZXQgaXMgZW1wdHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW1wdHkoc3RydWN0KSB7XG4gICAgICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAnZW1wdHknLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBnZXRTaXplKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiAoc2l6ZSA9PT0gMCB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhbiBlbXB0eSAke3N0cnVjdC50eXBlfSBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBzaXplIG9mIFxcYCR7c2l6ZX1cXGBgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNpemUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSBudW1iZXIgb3IgZGF0ZSBpcyBiZWxvdyBhIHRocmVzaG9sZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXgoc3RydWN0LCB0aHJlc2hvbGQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGV4Y2x1c2l2ZSB9ID0gb3B0aW9ucztcbiAgICAgICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdtYXgnLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBleGNsdXNpdmVcbiAgICAgICAgICAgICAgICA/IHZhbHVlIDwgdGhyZXNob2xkXG4gICAgICAgICAgICAgICAgOiB2YWx1ZSA8PSB0aHJlc2hvbGQgfHxcbiAgICAgICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX0gbGVzcyB0aGFuICR7ZXhjbHVzaXZlID8gJycgOiAnb3IgZXF1YWwgdG8gJ30ke3RocmVzaG9sZH0gYnV0IHJlY2VpdmVkIFxcYCR7dmFsdWV9XFxgYDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgbnVtYmVyIG9yIGRhdGUgaXMgYWJvdmUgYSB0aHJlc2hvbGQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKHN0cnVjdCwgdGhyZXNob2xkLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBleGNsdXNpdmUgfSA9IG9wdGlvbnM7XG4gICAgICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAnbWluJywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZXhjbHVzaXZlXG4gICAgICAgICAgICAgICAgPyB2YWx1ZSA+IHRocmVzaG9sZFxuICAgICAgICAgICAgICAgIDogdmFsdWUgPj0gdGhyZXNob2xkIHx8XG4gICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9IGdyZWF0ZXIgdGhhbiAke2V4Y2x1c2l2ZSA/ICcnIDogJ29yIGVxdWFsIHRvICd9JHt0aHJlc2hvbGR9IGJ1dCByZWNlaXZlZCBcXGAke3ZhbHVlfVxcYGA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG1hcCBvciBzZXQgaXMgbm90IGVtcHR5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vbmVtcHR5KHN0cnVjdCkge1xuICAgICAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ25vbmVtcHR5JywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gZ2V0U2l6ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gKHNpemUgPiAwIHx8IGBFeHBlY3RlZCBhIG5vbmVtcHR5ICR7c3RydWN0LnR5cGV9IGJ1dCByZWNlaXZlZCBhbiBlbXB0eSBvbmVgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nIG1hdGNoZXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGF0dGVybihzdHJ1Y3QsIHJlZ2V4cCkge1xuICAgICAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ3BhdHRlcm4nLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAocmVnZXhwLnRlc3QodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX0gbWF0Y2hpbmcgXFxgLyR7cmVnZXhwLnNvdXJjZX0vXFxgIGJ1dCByZWNlaXZlZCBcIiR7dmFsdWV9XCJgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbnVtYmVyLCBkYXRlLCBtYXAsIG9yIHNldCBoYXMgYSBzaXplIChvciBsZW5ndGgsIG9yIHRpbWUpIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpemUoc3RydWN0LCBtaW4sIG1heCA9IG1pbikge1xuICAgICAgICBjb25zdCBleHBlY3RlZCA9IGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9YDtcbiAgICAgICAgY29uc3Qgb2YgPSBtaW4gPT09IG1heCA/IGBvZiBcXGAke21pbn1cXGBgIDogYGJldHdlZW4gXFxgJHttaW59XFxgIGFuZCBcXGAke21heH1cXGBgO1xuICAgICAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ3NpemUnLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKG1pbiA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBtYXgpIHx8XG4gICAgICAgICAgICAgICAgICAgIGAke2V4cGVjdGVkfSAke29mfSBidXQgcmVjZWl2ZWQgXFxgJHt2YWx1ZX1cXGBgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzaXplIH0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChtaW4gPD0gc2l6ZSAmJiBzaXplIDw9IG1heCkgfHxcbiAgICAgICAgICAgICAgICAgICAgYCR7ZXhwZWN0ZWR9IHdpdGggYSBzaXplICR7b2Z9IGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIHNpemUgb2YgXFxgJHtzaXplfVxcYGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBsZW5ndGggfSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKG1pbiA8PSBsZW5ndGggJiYgbGVuZ3RoIDw9IG1heCkgfHxcbiAgICAgICAgICAgICAgICAgICAgYCR7ZXhwZWN0ZWR9IHdpdGggYSBsZW5ndGggJHtvZn0gYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgbGVuZ3RoIG9mIFxcYCR7bGVuZ3RofVxcYGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXVnbWVudCBhIGBTdHJ1Y3RgIHRvIGFkZCBhbiBhZGRpdGlvbmFsIHJlZmluZW1lbnQgdG8gdGhlIHZhbGlkYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGUgcmVmaW5lciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJlY2VpdmUgYSB2YWx1ZSBvZiB0aGUgc3RydWN0J3MgdHlwZSxcbiAgICAgKiBiZWNhdXNlIHRoZSBzdHJ1Y3QncyBleGlzdGluZyB2YWxpZGF0aW9uIHdpbGwgYWxyZWFkeSBoYXZlIHBhc3NlZC4gVGhpc1xuICAgICAqIGFsbG93cyB5b3UgdG8gbGF5ZXIgYWRkaXRpb25hbCB2YWxpZGF0aW9uIG9uIHRvcCBvZiBleGlzdGluZyBzdHJ1Y3RzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZmluZShzdHJ1Y3QsIG5hbWUsIHJlZmluZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICAgICAgKnJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgICAgIHlpZWxkKiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gdG9GYWlsdXJlcyhyZXN1bHQsIGN0eCwgc3RydWN0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIGZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHsgLi4uZmFpbHVyZSwgcmVmaW5lbWVudDogbmFtZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGV4cG9ydHMuU3RydWN0ID0gU3RydWN0O1xuICAgIGV4cG9ydHMuU3RydWN0RXJyb3IgPSBTdHJ1Y3RFcnJvcjtcbiAgICBleHBvcnRzLmFueSA9IGFueTtcbiAgICBleHBvcnRzLmFycmF5ID0gYXJyYXk7XG4gICAgZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG4gICAgZXhwb3J0cy5hc3NpZ24gPSBhc3NpZ247XG4gICAgZXhwb3J0cy5iaWdpbnQgPSBiaWdpbnQ7XG4gICAgZXhwb3J0cy5ib29sZWFuID0gYm9vbGVhbjtcbiAgICBleHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbiAgICBleHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBleHBvcnRzLmRhdGUgPSBkYXRlO1xuICAgIGV4cG9ydHMuZGVmYXVsdGVkID0gZGVmYXVsdGVkO1xuICAgIGV4cG9ydHMuZGVmaW5lID0gZGVmaW5lO1xuICAgIGV4cG9ydHMuZGVwcmVjYXRlZCA9IGRlcHJlY2F0ZWQ7XG4gICAgZXhwb3J0cy5keW5hbWljID0gZHluYW1pYztcbiAgICBleHBvcnRzLmVtcHR5ID0gZW1wdHk7XG4gICAgZXhwb3J0cy5lbnVtcyA9IGVudW1zO1xuICAgIGV4cG9ydHMuZnVuYyA9IGZ1bmM7XG4gICAgZXhwb3J0cy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIGV4cG9ydHMuaW50ZWdlciA9IGludGVnZXI7XG4gICAgZXhwb3J0cy5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgZXhwb3J0cy5pcyA9IGlzO1xuICAgIGV4cG9ydHMubGF6eSA9IGxhenk7XG4gICAgZXhwb3J0cy5saXRlcmFsID0gbGl0ZXJhbDtcbiAgICBleHBvcnRzLm1hcCA9IG1hcDtcbiAgICBleHBvcnRzLm1hc2sgPSBtYXNrO1xuICAgIGV4cG9ydHMubWF4ID0gbWF4O1xuICAgIGV4cG9ydHMubWluID0gbWluO1xuICAgIGV4cG9ydHMubmV2ZXIgPSBuZXZlcjtcbiAgICBleHBvcnRzLm5vbmVtcHR5ID0gbm9uZW1wdHk7XG4gICAgZXhwb3J0cy5udWxsYWJsZSA9IG51bGxhYmxlO1xuICAgIGV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuICAgIGV4cG9ydHMub2JqZWN0ID0gb2JqZWN0O1xuICAgIGV4cG9ydHMub21pdCA9IG9taXQ7XG4gICAgZXhwb3J0cy5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgIGV4cG9ydHMucGFydGlhbCA9IHBhcnRpYWw7XG4gICAgZXhwb3J0cy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICBleHBvcnRzLnBpY2sgPSBwaWNrO1xuICAgIGV4cG9ydHMucmVjb3JkID0gcmVjb3JkO1xuICAgIGV4cG9ydHMucmVmaW5lID0gcmVmaW5lO1xuICAgIGV4cG9ydHMucmVnZXhwID0gcmVnZXhwO1xuICAgIGV4cG9ydHMuc2V0ID0gc2V0O1xuICAgIGV4cG9ydHMuc2l6ZSA9IHNpemU7XG4gICAgZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgZXhwb3J0cy5zdHJ1Y3QgPSBzdHJ1Y3Q7XG4gICAgZXhwb3J0cy50cmltbWVkID0gdHJpbW1lZDtcbiAgICBleHBvcnRzLnR1cGxlID0gdHVwbGU7XG4gICAgZXhwb3J0cy50eXBlID0gdHlwZTtcbiAgICBleHBvcnRzLnVuaW9uID0gdW5pb247XG4gICAgZXhwb3J0cy51bmtub3duID0gdW5rbm93bjtcbiAgICBleHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmNqcy5tYXBcbiIsInZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59OyIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgZ2xvYmFsLCBkZWZpbmUsIFN5c3RlbSwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG52YXIgX19leHRlbmRzO1xyXG52YXIgX19hc3NpZ247XHJcbnZhciBfX3Jlc3Q7XHJcbnZhciBfX2RlY29yYXRlO1xyXG52YXIgX19wYXJhbTtcclxudmFyIF9fZXNEZWNvcmF0ZTtcclxudmFyIF9fcnVuSW5pdGlhbGl6ZXJzO1xyXG52YXIgX19wcm9wS2V5O1xyXG52YXIgX19zZXRGdW5jdGlvbk5hbWU7XHJcbnZhciBfX21ldGFkYXRhO1xyXG52YXIgX19hd2FpdGVyO1xyXG52YXIgX19nZW5lcmF0b3I7XHJcbnZhciBfX2V4cG9ydFN0YXI7XHJcbnZhciBfX3ZhbHVlcztcclxudmFyIF9fcmVhZDtcclxudmFyIF9fc3ByZWFkO1xyXG52YXIgX19zcHJlYWRBcnJheXM7XHJcbnZhciBfX3NwcmVhZEFycmF5O1xyXG52YXIgX19hd2FpdDtcclxudmFyIF9fYXN5bmNHZW5lcmF0b3I7XHJcbnZhciBfX2FzeW5jRGVsZWdhdG9yO1xyXG52YXIgX19hc3luY1ZhbHVlcztcclxudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0O1xyXG52YXIgX19pbXBvcnRTdGFyO1xyXG52YXIgX19pbXBvcnREZWZhdWx0O1xyXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldDtcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQ7XHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkSW47XHJcbnZhciBfX2NyZWF0ZUJpbmRpbmc7XHJcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgdmFyIHJvb3QgPSB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdHlwZW9mIHRoaXMgPT09IFwib2JqZWN0XCIgPyB0aGlzIDoge307XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoXCJ0c2xpYlwiLCBbXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAoZXhwb3J0cykgeyBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMpKSk7IH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKG1vZHVsZS5leHBvcnRzKSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVFeHBvcnRlcihleHBvcnRzLCBwcmV2aW91cykge1xyXG4gICAgICAgIGlmIChleHBvcnRzICE9PSByb290KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoaWQsIHYpIHsgcmV0dXJuIGV4cG9ydHNbaWRdID0gcHJldmlvdXMgPyBwcmV2aW91cyhpZCwgdikgOiB2OyB9O1xyXG4gICAgfVxyXG59KVxyXG4oZnVuY3Rpb24gKGV4cG9ydGVyKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cclxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVzdCA9IGZ1bmN0aW9uIChzLCBlKSB7XHJcbiAgICAgICAgdmFyIHQgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgX19kZWNvcmF0ZSA9IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgICAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcGFyYW0gPSBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZXNEZWNvcmF0ZSA9IGZ1bmN0aW9uIChjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xyXG4gICAgICAgIGZ1bmN0aW9uIGFjY2VwdChmKSB7IGlmIChmICE9PSB2b2lkIDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpOyByZXR1cm4gZjsgfVxyXG4gICAgICAgIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XHJcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9ySW4gfHwgKHRhcmdldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSkgOiB7fSk7XHJcbiAgICAgICAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XHJcbiAgICAgICAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoZikgeyBpZiAoZG9uZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgaW5pdGlhbGl6ZXJzIGFmdGVyIGRlY29yYXRpb24gaGFzIGNvbXBsZXRlZFwiKTsgZXh0cmFJbml0aWFsaXplcnMucHVzaChhY2NlcHQoZiB8fCBudWxsKSk7IH07XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcclxuICAgICAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5zZXQpKSBkZXNjcmlwdG9yLnNldCA9IF87XHJcbiAgICAgICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy5wdXNoKF8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKF8gPSBhY2NlcHQocmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnB1c2goXyk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xyXG4gICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3J1bkluaXRpYWxpemVycyA9IGZ1bmN0aW9uICh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcclxuICAgIH07XHJcblxyXG4gICAgX19wcm9wS2V5ID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09IFwic3ltYm9sXCIgPyB4IDogXCJcIi5jb25jYXQoeCk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fc2V0RnVuY3Rpb25OYW1lID0gZnVuY3Rpb24gKGYsIG5hbWUsIHByZWZpeCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIikgbmFtZSA9IG5hbWUuZGVzY3JpcHRpb24gPyBcIltcIi5jb25jYXQobmFtZS5kZXNjcmlwdGlvbiwgXCJdXCIpIDogXCJcIjtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwibmFtZVwiLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHByZWZpeCA/IFwiXCIuY29uY2F0KHByZWZpeCwgXCIgXCIsIG5hbWUpIDogbmFtZSB9KTtcclxuICAgIH07XHJcblxyXG4gICAgX19tZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXRlciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgICAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgX19leHBvcnRTdGFyID0gZnVuY3Rpb24obSwgbykge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcclxuICAgIH07XHJcblxyXG4gICAgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xyXG4gICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XHJcbiAgICAgICAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XHJcbiAgICB9KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICAgICAgb1trMl0gPSBtW2tdO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX192YWx1ZXMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICAgICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICAgICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVhZCA9IGZ1bmN0aW9uIChvLCBuKSB7XHJcbiAgICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICAgICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqIEBkZXByZWNhdGVkICovXHJcbiAgICBfX3NwcmVhZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqIEBkZXByZWNhdGVkICovXHJcbiAgICBfX3NwcmVhZEFycmF5cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fc3ByZWFkQXJyYXkgPSBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcclxuICAgICAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2F3YWl0ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY0dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICAgICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7ICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNEZWxlZ2F0b3IgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBpLCBwO1xyXG4gICAgICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogZmFsc2UgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY1ZhbHVlcyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX21ha2VUZW1wbGF0ZU9iamVjdCA9IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICAgICAgcmV0dXJuIGNvb2tlZDtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxuICAgIH0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxuICAgIH07XHJcblxyXG4gICAgX19pbXBvcnRTdGFyID0gZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9faW1wb3J0RGVmYXVsdCA9IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgICAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxuICAgIH07XHJcblxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgICAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICAgICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxuICAgIH07XHJcblxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICAgICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgICAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4gPSBmdW5jdGlvbiAoc3RhdGUsIHJlY2VpdmVyKSB7XHJcbiAgICAgICAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgPT09IHN0YXRlIDogc3RhdGUuaGFzKHJlY2VpdmVyKTtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0ZXIoXCJfX2V4dGVuZHNcIiwgX19leHRlbmRzKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3NpZ25cIiwgX19hc3NpZ24pO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3Jlc3RcIiwgX19yZXN0KTtcclxuICAgIGV4cG9ydGVyKFwiX19kZWNvcmF0ZVwiLCBfX2RlY29yYXRlKTtcclxuICAgIGV4cG9ydGVyKFwiX19wYXJhbVwiLCBfX3BhcmFtKTtcclxuICAgIGV4cG9ydGVyKFwiX19lc0RlY29yYXRlXCIsIF9fZXNEZWNvcmF0ZSk7XHJcbiAgICBleHBvcnRlcihcIl9fcnVuSW5pdGlhbGl6ZXJzXCIsIF9fcnVuSW5pdGlhbGl6ZXJzKTtcclxuICAgIGV4cG9ydGVyKFwiX19wcm9wS2V5XCIsIF9fcHJvcEtleSk7XHJcbiAgICBleHBvcnRlcihcIl9fc2V0RnVuY3Rpb25OYW1lXCIsIF9fc2V0RnVuY3Rpb25OYW1lKTtcclxuICAgIGV4cG9ydGVyKFwiX19tZXRhZGF0YVwiLCBfX21ldGFkYXRhKTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdGVyXCIsIF9fYXdhaXRlcik7XHJcbiAgICBleHBvcnRlcihcIl9fZ2VuZXJhdG9yXCIsIF9fZ2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19leHBvcnRTdGFyXCIsIF9fZXhwb3J0U3Rhcik7XHJcbiAgICBleHBvcnRlcihcIl9fY3JlYXRlQmluZGluZ1wiLCBfX2NyZWF0ZUJpbmRpbmcpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3ZhbHVlc1wiLCBfX3ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fcmVhZFwiLCBfX3JlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZFwiLCBfX3NwcmVhZCk7XHJcbiAgICBleHBvcnRlcihcIl9fc3ByZWFkQXJyYXlzXCIsIF9fc3ByZWFkQXJyYXlzKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRBcnJheVwiLCBfX3NwcmVhZEFycmF5KTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdFwiLCBfX2F3YWl0KTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0dlbmVyYXRvclwiLCBfX2FzeW5jR2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0RlbGVnYXRvclwiLCBfX2FzeW5jRGVsZWdhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY1ZhbHVlc1wiLCBfX2FzeW5jVmFsdWVzKTtcclxuICAgIGV4cG9ydGVyKFwiX19tYWtlVGVtcGxhdGVPYmplY3RcIiwgX19tYWtlVGVtcGxhdGVPYmplY3QpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2ltcG9ydFN0YXJcIiwgX19pbXBvcnRTdGFyKTtcclxuICAgIGV4cG9ydGVyKFwiX19pbXBvcnREZWZhdWx0XCIsIF9faW1wb3J0RGVmYXVsdCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRHZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRTZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZFNldCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRJblwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4pO1xyXG59KTtcclxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3V0ZjhqcyB2My4wLjAgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG5cdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdO1xuXHRcdHZhciBjb3VudGVyID0gMDtcblx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuXHRcdFx0dGhyb3cgRXJyb3IoXG5cdFx0XHRcdCdMb25lIHN1cnJvZ2F0ZSBVKycgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgK1xuXHRcdFx0XHQnIGlzIG5vdCBhIHNjYWxhciB2YWx1ZSdcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuXHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gc2hpZnQpICYgMHgzRikgfCAweDgwKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpIHtcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkZGODApID09IDApIHsgLy8gMS1ieXRlIHNlcXVlbmNlXG5cdFx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHZhciBzeW1ib2wgPSAnJztcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkY4MDApID09IDApIHsgLy8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gNikgJiAweDFGKSB8IDB4QzApO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KTtcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZFMDAwMDApID09IDApIHsgLy8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0XHRyZXR1cm4gc3ltYm9sO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcpIHtcblx0XHR2YXIgY29kZVBvaW50cyA9IHVjczJkZWNvZGUoc3RyaW5nKTtcblx0XHR2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIGNvZGVQb2ludDtcblx0XHR2YXIgYnl0ZVN0cmluZyA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRjb2RlUG9pbnQgPSBjb2RlUG9pbnRzW2luZGV4XTtcblx0XHRcdGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHJldHVybiBieXRlU3RyaW5nO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdFx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHR2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRcdHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlY29kZVN5bWJvbCgpIHtcblx0XHR2YXIgYnl0ZTE7XG5cdFx0dmFyIGJ5dGUyO1xuXHRcdHZhciBieXRlMztcblx0XHR2YXIgYnl0ZTQ7XG5cdFx0dmFyIGNvZGVQb2ludDtcblxuXHRcdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRcdGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4ODApID09IDApIHtcblx0XHRcdHJldHVybiBieXRlMTtcblx0XHR9XG5cblx0XHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MUYpIDw8IDYpIHwgYnl0ZTI7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4ODApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gMy1ieXRlIHNlcXVlbmNlIChtYXkgaW5jbHVkZSB1bnBhaXJlZCBzdXJyb2dhdGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDgwMCkge1xuXHRcdFx0XHRjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCk7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEY4KSA9PSAweEYwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlNCA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuXHRcdFx0XHQoYnl0ZTMgPDwgMHgwNikgfCBieXRlNDtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgVVRGLTggZGV0ZWN0ZWQnKTtcblx0fVxuXG5cdHZhciBieXRlQXJyYXk7XG5cdHZhciBieXRlQ291bnQ7XG5cdHZhciBieXRlSW5kZXg7XG5cdGZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnl0ZVN0cmluZykge1xuXHRcdGJ5dGVBcnJheSA9IHVjczJkZWNvZGUoYnl0ZVN0cmluZyk7XG5cdFx0Ynl0ZUNvdW50ID0gYnl0ZUFycmF5Lmxlbmd0aDtcblx0XHRieXRlSW5kZXggPSAwO1xuXHRcdHZhciBjb2RlUG9pbnRzID0gW107XG5cdFx0dmFyIHRtcDtcblx0XHR3aGlsZSAoKHRtcCA9IGRlY29kZVN5bWJvbCgpKSAhPT0gZmFsc2UpIHtcblx0XHRcdGNvZGVQb2ludHMucHVzaCh0bXApO1xuXHRcdH1cblx0XHRyZXR1cm4gdWNzMmVuY29kZShjb2RlUG9pbnRzKTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHJvb3QudmVyc2lvbiA9ICczLjAuMCc7XG5cdHJvb3QuZW5jb2RlID0gdXRmOGVuY29kZTtcblx0cm9vdC5kZWNvZGUgPSB1dGY4ZGVjb2RlO1xuXG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/IHRoaXMudXRmOCA9IHt9IDogZXhwb3J0cykpO1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2MVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInYzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92Mi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInY0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92My5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInY1XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92NC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5JTFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfbmlsLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmVyc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdmVyc2lvbi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZhbGlkYXRlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92YWxpZGF0ZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3BhcnNlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX3YgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3YxLmpzXCIpKTtcblxudmFyIF92MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdjMuanNcIikpO1xuXG52YXIgX3YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92NC5qc1wiKSk7XG5cbnZhciBfdjQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Y1LmpzXCIpKTtcblxudmFyIF9uaWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL25pbC5qc1wiKSk7XG5cbnZhciBfdmVyc2lvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmVyc2lvbi5qc1wiKSk7XG5cbnZhciBfdmFsaWRhdGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRlLmpzXCIpKTtcblxudmFyIF9zdHJpbmdpZnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKSk7XG5cbnZhciBfcGFyc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuLypcbiAqIEJyb3dzZXItY29tcGF0aWJsZSBKYXZhU2NyaXB0IE1ENVxuICpcbiAqIE1vZGlmaWNhdGlvbiBvZiBKYXZhU2NyaXB0IE1ENVxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1NRDVcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSwgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKlxuICogQmFzZWQgb25cbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUlNBIERhdGEgU2VjdXJpdHksIEluYy4gTUQ1IE1lc3NhZ2VcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXG4gKiBWZXJzaW9uIDIuMiBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDlcbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cbiAqL1xuZnVuY3Rpb24gbWQ1KGJ5dGVzKSB7XG4gIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgbXNnID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGJ5dGVzKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KG1zZy5sZW5ndGgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzW2ldID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kNVRvSGV4RW5jb2RlZEFycmF5KHdvcmRzVG9NZDUoYnl0ZXNUb1dvcmRzKGJ5dGVzKSwgYnl0ZXMubGVuZ3RoICogOCkpO1xufVxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcyB0byBhbiBhcnJheSBvZiBieXRlc1xuICovXG5cblxuZnVuY3Rpb24gbWQ1VG9IZXhFbmNvZGVkQXJyYXkoaW5wdXQpIHtcbiAgY29uc3Qgb3V0cHV0ID0gW107XG4gIGNvbnN0IGxlbmd0aDMyID0gaW5wdXQubGVuZ3RoICogMzI7XG4gIGNvbnN0IGhleFRhYiA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDMyOyBpICs9IDgpIHtcbiAgICBjb25zdCB4ID0gaW5wdXRbaSA+PiA1XSA+Pj4gaSAlIDMyICYgMHhmZjtcbiAgICBjb25zdCBoZXggPSBwYXJzZUludChoZXhUYWIuY2hhckF0KHggPj4+IDQgJiAweDBmKSArIGhleFRhYi5jaGFyQXQoeCAmIDB4MGYpLCAxNik7XG4gICAgb3V0cHV0LnB1c2goaGV4KTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBvdXRwdXQgbGVuZ3RoIHdpdGggcGFkZGluZyBhbmQgYml0IGxlbmd0aFxuICovXG5cblxuZnVuY3Rpb24gZ2V0T3V0cHV0TGVuZ3RoKGlucHV0TGVuZ3RoOCkge1xuICByZXR1cm4gKGlucHV0TGVuZ3RoOCArIDY0ID4+PiA5IDw8IDQpICsgMTQgKyAxO1xufVxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGguXG4gKi9cblxuXG5mdW5jdGlvbiB3b3Jkc1RvTWQ1KHgsIGxlbikge1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8IGxlbiAlIDMyO1xuICB4W2dldE91dHB1dExlbmd0aChsZW4pIC0gMV0gPSBsZW47XG4gIGxldCBhID0gMTczMjU4NDE5MztcbiAgbGV0IGIgPSAtMjcxNzMzODc5O1xuICBsZXQgYyA9IC0xNzMyNTg0MTk0O1xuICBsZXQgZCA9IDI3MTczMzg3ODtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgY29uc3Qgb2xkYSA9IGE7XG4gICAgY29uc3Qgb2xkYiA9IGI7XG4gICAgY29uc3Qgb2xkYyA9IGM7XG4gICAgY29uc3Qgb2xkZCA9IGQ7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaV0sIDcsIC02ODA4NzY5MzYpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTcsIDYwNjEwNTgxOSk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNywgLTE3NjQxODg5Nyk7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDVdLCAxMiwgMTIwMDA4MDQyNik7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA3LCAxNzcwMDM1NDE2KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTcsIC00MjA2Myk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA3LCAxODA0NjAzNjgyKTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxNV0sIDIyLCAxMjM2NTM1MzI5KTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMV0sIDUsIC0xNjU3OTY1MTApO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyA2XSwgOSwgLTEwNjk1MDE2MzIpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE0LCA2NDM3MTc3MTMpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2ldLCAyMCwgLTM3Mzg5NzMwMik7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA1LCAtNzAxNTU4NjkxKTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTBdLCA5LCAzODAxNjA4Myk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTQsIC02NjA0NzgzMzUpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNSwgNTY4NDQ2NDM4KTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTRdLCA5LCAtMTAxOTgwMzY5MCk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDhdLCAyMCwgMTE2MzUzMTUwMSk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNSwgLTE0NDQ2ODE0NjcpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAyXSwgOSwgLTUxNDAzNzg0KTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgN10sIDE0LCAxNzM1MzI4NDczKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyA1XSwgNCwgLTM3ODU1OCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE2LCAxODM5MDMwNTYyKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTRdLCAyMywgLTM1MzA5NTU2KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMV0sIDQsIC0xNTMwOTkyMDYwKTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgNF0sIDExLCAxMjcyODkzMzUzKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgN10sIDE2LCAtMTU1NDk3NjMyKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyAxM10sIDQsIDY4MTI3OTE3NCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaV0sIDExLCAtMzU4NTM3MjIyKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgM10sIDE2LCAtNzIyNTIxOTc5KTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgNl0sIDIzLCA3NjAyOTE4OSk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDldLCA0LCAtNjQwMzY0NDg3KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTYsIDUzMDc0MjUyMCk7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDJdLCAyMywgLTk5NTMzODY1MSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaV0sIDYsIC0xOTg2MzA4NDQpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyA3XSwgMTAsIDExMjY4OTE0MTUpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA2LCAxNzAwNDg1NTcxKTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA2LCAxODczMzEzMzU5KTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTVdLCAxMCwgLTMwNjExNzQ0KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDEzXSwgMjEsIDEzMDkxNTE2NDkpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNiwgLTE0NTUyMzA3MCk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE1LCA3MTg3ODcyNTkpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuICAgIGEgPSBzYWZlQWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlQWRkKGIsIG9sZGIpO1xuICAgIGMgPSBzYWZlQWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlQWRkKGQsIG9sZGQpO1xuICB9XG5cbiAgcmV0dXJuIFthLCBiLCBjLCBkXTtcbn1cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IGJ5dGVzIHRvIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHNcbiAqIENoYXJhY3RlcnMgPjI1NSBoYXZlIHRoZWlyIGhpZ2gtYnl0ZSBzaWxlbnRseSBpZ25vcmVkLlxuICovXG5cblxuZnVuY3Rpb24gYnl0ZXNUb1dvcmRzKGlucHV0KSB7XG4gIGlmIChpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBsZW5ndGg4ID0gaW5wdXQubGVuZ3RoICogODtcbiAgY29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQzMkFycmF5KGdldE91dHB1dExlbmd0aChsZW5ndGg4KSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg4OyBpICs9IDgpIHtcbiAgICBvdXRwdXRbaSA+PiA1XSB8PSAoaW5wdXRbaSAvIDhdICYgMHhmZikgPDwgaSAlIDMyO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5cblxuZnVuY3Rpb24gc2FmZUFkZCh4LCB5KSB7XG4gIGNvbnN0IGxzdyA9ICh4ICYgMHhmZmZmKSArICh5ICYgMHhmZmZmKTtcbiAgY29uc3QgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiBtc3cgPDwgMTYgfCBsc3cgJiAweGZmZmY7XG59XG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5cblxuZnVuY3Rpb24gYml0Um90YXRlTGVmdChudW0sIGNudCkge1xuICByZXR1cm4gbnVtIDw8IGNudCB8IG51bSA+Pj4gMzIgLSBjbnQ7XG59XG4vKlxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1kNWNtbihxLCBhLCBiLCB4LCBzLCB0KSB7XG4gIHJldHVybiBzYWZlQWRkKGJpdFJvdGF0ZUxlZnQoc2FmZUFkZChzYWZlQWRkKGEsIHEpLCBzYWZlQWRkKHgsIHQpKSwgcyksIGIpO1xufVxuXG5mdW5jdGlvbiBtZDVmZihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiAmIGMgfCB+YiAmIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVnZyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiAmIGQgfCBjICYgfmQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVoaChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1aWkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGMgXiAoYiB8IH5kKSwgYSwgYiwgeCwgcywgdCk7XG59XG5cbnZhciBfZGVmYXVsdCA9IG1kNTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9kZWZhdWx0ID0gJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCc7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF92YWxpZGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdGUuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBwYXJzZSh1dWlkKSB7XG4gIGlmICghKDAsIF92YWxpZGF0ZS5kZWZhdWx0KSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICBsZXQgdjtcbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBQYXJzZSAjIyMjIyMjIy0uLi4uLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMCwgOCksIDE2KSkgPj4+IDI0O1xuICBhcnJbMV0gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsyXSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbM10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tIyMjIy0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzRdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDksIDEzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzVdID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tIyMjIy0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFycls2XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxNCwgMTgpLCAxNikpID4+PiA4O1xuICBhcnJbN10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLSMjIyMtLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzhdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE5LCAyMyksIDE2KSkgPj4+IDg7XG4gIGFycls5XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tLi4uLi0jIyMjIyMjIyMjIyNcbiAgLy8gKFVzZSBcIi9cIiB0byBhdm9pZCAzMi1iaXQgdHJ1bmNhdGlvbiB3aGVuIGJpdC1zaGlmdGluZyBoaWdoLW9yZGVyIGJ5dGVzKVxuXG4gIGFyclsxMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMjQsIDM2KSwgMTYpKSAvIDB4MTAwMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTFdID0gdiAvIDB4MTAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzEyXSA9IHYgPj4+IDI0ICYgMHhmZjtcbiAgYXJyWzEzXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzE0XSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbMTVdID0gdiAmIDB4ZmY7XG4gIHJldHVybiBhcnI7XG59XG5cbnZhciBfZGVmYXVsdCA9IHBhcnNlO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2RlZmF1bHQgPSAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJuZztcbi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuIEluIHRoZSBicm93c2VyIHdlIHRoZXJlZm9yZVxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4vLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxubGV0IGdldFJhbmRvbVZhbHVlcztcbmNvbnN0IHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuXG5mdW5jdGlvbiBybmcoKSB7XG4gIC8vIGxhenkgbG9hZCBzbyB0aGF0IGVudmlyb25tZW50cyB0aGF0IG5lZWQgdG8gcG9seWZpbGwgaGF2ZSBhIGNoYW5jZSB0byBkbyBzb1xuICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0byBpbXBsZW1lbnRhdGlvbi4gQWxzbyxcbiAgICAvLyBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gKG1zQ3J5cHRvKSBvbiBJRTExLlxuICAgIGdldFJhbmRvbVZhbHVlcyA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykgfHwgdHlwZW9mIG1zQ3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKTtcblxuICAgIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbi8vIEFkYXB0ZWQgZnJvbSBDaHJpcyBWZW5lc3MnIFNIQTEgY29kZSBhdFxuLy8gaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9zaGExLmh0bWxcbmZ1bmN0aW9uIGYocywgeCwgeSwgeikge1xuICBzd2l0Y2ggKHMpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4geCAmIHkgXiB+eCAmIHo7XG5cbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4geCBeIHkgXiB6O1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHggJiB5IF4geCAmIHogXiB5ICYgejtcblxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiB4IF4geSBeIHo7XG4gIH1cbn1cblxuZnVuY3Rpb24gUk9UTCh4LCBuKSB7XG4gIHJldHVybiB4IDw8IG4gfCB4ID4+PiAzMiAtIG47XG59XG5cbmZ1bmN0aW9uIHNoYTEoYnl0ZXMpIHtcbiAgY29uc3QgSyA9IFsweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjLCAweGNhNjJjMWQ2XTtcbiAgY29uc3QgSCA9IFsweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwXTtcblxuICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IG1zZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChieXRlcykpOyAvLyBVVEY4IGVzY2FwZVxuXG4gICAgYnl0ZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgKytpKSB7XG4gICAgICBieXRlcy5wdXNoKG1zZy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoYnl0ZXMpKSB7XG4gICAgLy8gQ29udmVydCBBcnJheS1saWtlIHRvIEFycmF5XG4gICAgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChieXRlcyk7XG4gIH1cblxuICBieXRlcy5wdXNoKDB4ODApO1xuICBjb25zdCBsID0gYnl0ZXMubGVuZ3RoIC8gNCArIDI7XG4gIGNvbnN0IE4gPSBNYXRoLmNlaWwobCAvIDE2KTtcbiAgY29uc3QgTSA9IG5ldyBBcnJheShOKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50MzJBcnJheSgxNik7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIGFycltqXSA9IGJ5dGVzW2kgKiA2NCArIGogKiA0XSA8PCAyNCB8IGJ5dGVzW2kgKiA2NCArIGogKiA0ICsgMV0gPDwgMTYgfCBieXRlc1tpICogNjQgKyBqICogNCArIDJdIDw8IDggfCBieXRlc1tpICogNjQgKyBqICogNCArIDNdO1xuICAgIH1cblxuICAgIE1baV0gPSBhcnI7XG4gIH1cblxuICBNW04gLSAxXVsxNF0gPSAoYnl0ZXMubGVuZ3RoIC0gMSkgKiA4IC8gTWF0aC5wb3coMiwgMzIpO1xuICBNW04gLSAxXVsxNF0gPSBNYXRoLmZsb29yKE1bTiAtIDFdWzE0XSk7XG4gIE1bTiAtIDFdWzE1XSA9IChieXRlcy5sZW5ndGggLSAxKSAqIDggJiAweGZmZmZmZmZmO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgY29uc3QgVyA9IG5ldyBVaW50MzJBcnJheSg4MCk7XG5cbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDE2OyArK3QpIHtcbiAgICAgIFdbdF0gPSBNW2ldW3RdO1xuICAgIH1cblxuICAgIGZvciAobGV0IHQgPSAxNjsgdCA8IDgwOyArK3QpIHtcbiAgICAgIFdbdF0gPSBST1RMKFdbdCAtIDNdIF4gV1t0IC0gOF0gXiBXW3QgLSAxNF0gXiBXW3QgLSAxNl0sIDEpO1xuICAgIH1cblxuICAgIGxldCBhID0gSFswXTtcbiAgICBsZXQgYiA9IEhbMV07XG4gICAgbGV0IGMgPSBIWzJdO1xuICAgIGxldCBkID0gSFszXTtcbiAgICBsZXQgZSA9IEhbNF07XG5cbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDgwOyArK3QpIHtcbiAgICAgIGNvbnN0IHMgPSBNYXRoLmZsb29yKHQgLyAyMCk7XG4gICAgICBjb25zdCBUID0gUk9UTChhLCA1KSArIGYocywgYiwgYywgZCkgKyBlICsgS1tzXSArIFdbdF0gPj4+IDA7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IFJPVEwoYiwgMzApID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gVDtcbiAgICB9XG5cbiAgICBIWzBdID0gSFswXSArIGEgPj4+IDA7XG4gICAgSFsxXSA9IEhbMV0gKyBiID4+PiAwO1xuICAgIEhbMl0gPSBIWzJdICsgYyA+Pj4gMDtcbiAgICBIWzNdID0gSFszXSArIGQgPj4+IDA7XG4gICAgSFs0XSA9IEhbNF0gKyBlID4+PiAwO1xuICB9XG5cbiAgcmV0dXJuIFtIWzBdID4+IDI0ICYgMHhmZiwgSFswXSA+PiAxNiAmIDB4ZmYsIEhbMF0gPj4gOCAmIDB4ZmYsIEhbMF0gJiAweGZmLCBIWzFdID4+IDI0ICYgMHhmZiwgSFsxXSA+PiAxNiAmIDB4ZmYsIEhbMV0gPj4gOCAmIDB4ZmYsIEhbMV0gJiAweGZmLCBIWzJdID4+IDI0ICYgMHhmZiwgSFsyXSA+PiAxNiAmIDB4ZmYsIEhbMl0gPj4gOCAmIDB4ZmYsIEhbMl0gJiAweGZmLCBIWzNdID4+IDI0ICYgMHhmZiwgSFszXSA+PiAxNiAmIDB4ZmYsIEhbM10gPj4gOCAmIDB4ZmYsIEhbM10gJiAweGZmLCBIWzRdID4+IDI0ICYgMHhmZiwgSFs0XSA+PiAxNiAmIDB4ZmYsIEhbNF0gPj4gOCAmIDB4ZmYsIEhbNF0gJiAweGZmXTtcbn1cblxudmFyIF9kZWZhdWx0ID0gc2hhMTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3ZhbGlkYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0ZS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xuY29uc3QgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIGNvbnN0IHV1aWQgPSAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7IC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcblxuICBpZiAoISgwLCBfdmFsaWRhdGUuZGVmYXVsdCkodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbnZhciBfZGVmYXVsdCA9IHN0cmluZ2lmeTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JuZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm5nLmpzXCIpKTtcblxudmFyIF9zdHJpbmdpZnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcbmxldCBfbm9kZUlkO1xuXG5sZXQgX2Nsb2Nrc2VxOyAvLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcblxuXG5sZXQgX2xhc3RNU2VjcyA9IDA7XG5sZXQgX2xhc3ROU2VjcyA9IDA7IC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXG5cbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGxldCBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICBjb25zdCBiID0gYnVmIHx8IG5ldyBBcnJheSgxNik7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICBsZXQgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxOyAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcblxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICBjb25zdCBzZWVkQnl0ZXMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgX3JuZy5kZWZhdWx0KSgpO1xuXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtzZWVkQnl0ZXNbMF0gfCAweDAxLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG4gICAgfVxuXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9IC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuXG5cbiAgbGV0IG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IERhdGUubm93KCk7IC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcblxuICBsZXQgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7IC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcblxuICBjb25zdCBkdCA9IG1zZWNzIC0gX2xhc3RNU2VjcyArIChuc2VjcyAtIF9sYXN0TlNlY3MpIC8gMTAwMDA7IC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9IC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcblxuXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9IC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcblxuXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInV1aWQudjEoKTogQ2FuJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjXCIpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxOyAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcblxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDsgLy8gYHRpbWVfbG93YFxuXG4gIGNvbnN0IHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjsgLy8gYHRpbWVfbWlkYFxuXG4gIGNvbnN0IHRtaCA9IG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjsgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcblxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG5cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7IC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDsgLy8gYGNsb2NrX3NlcV9sb3dgXG5cbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmOyAvLyBgbm9kZWBcblxuICBmb3IgKGxldCBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgfHwgKDAsIF9zdHJpbmdpZnkuZGVmYXVsdCkoYik7XG59XG5cbnZhciBfZGVmYXVsdCA9IHYxO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfdiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdjM1LmpzXCIpKTtcblxudmFyIF9tZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbWQ1LmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3QgdjMgPSAoMCwgX3YuZGVmYXVsdCkoJ3YzJywgMHgzMCwgX21kLmRlZmF1bHQpO1xudmFyIF9kZWZhdWx0ID0gdjM7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuZXhwb3J0cy5VUkwgPSBleHBvcnRzLkROUyA9IHZvaWQgMDtcblxudmFyIF9zdHJpbmdpZnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKSk7XG5cbnZhciBfcGFyc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgc3RyID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpOyAvLyBVVEY4IGVzY2FwZVxuXG4gIGNvbnN0IGJ5dGVzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBieXRlcy5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn1cblxuY29uc3QgRE5TID0gJzZiYTdiODEwLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnRzLkROUyA9IEROUztcbmNvbnN0IFVSTCA9ICc2YmE3YjgxMS05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0cy5VUkwgPSBVUkw7XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KG5hbWUsIHZlcnNpb24sIGhhc2hmdW5jKSB7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCh2YWx1ZSwgbmFtZXNwYWNlLCBidWYsIG9mZnNldCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZXNwYWNlID0gKDAsIF9wYXJzZS5kZWZhdWx0KShuYW1lc3BhY2UpO1xuICAgIH1cblxuICAgIGlmIChuYW1lc3BhY2UubGVuZ3RoICE9PSAxNikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdOYW1lc3BhY2UgbXVzdCBiZSBhcnJheS1saWtlICgxNiBpdGVyYWJsZSBpbnRlZ2VyIHZhbHVlcywgMC0yNTUpJyk7XG4gICAgfSAvLyBDb21wdXRlIGhhc2ggb2YgbmFtZXNwYWNlIGFuZCB2YWx1ZSwgUGVyIDQuM1xuICAgIC8vIEZ1dHVyZTogVXNlIHNwcmVhZCBzeW50YXggd2hlbiBzdXBwb3J0ZWQgb24gYWxsIHBsYXRmb3JtcywgZS5nLiBgYnl0ZXMgPVxuICAgIC8vIGhhc2hmdW5jKFsuLi5uYW1lc3BhY2UsIC4uLiB2YWx1ZV0pYFxuXG5cbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNiArIHZhbHVlLmxlbmd0aCk7XG4gICAgYnl0ZXMuc2V0KG5hbWVzcGFjZSk7XG4gICAgYnl0ZXMuc2V0KHZhbHVlLCBuYW1lc3BhY2UubGVuZ3RoKTtcbiAgICBieXRlcyA9IGhhc2hmdW5jKGJ5dGVzKTtcbiAgICBieXRlc1s2XSA9IGJ5dGVzWzZdICYgMHgwZiB8IHZlcnNpb247XG4gICAgYnl0ZXNbOF0gPSBieXRlc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gICAgaWYgKGJ1Zikge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlc1tpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF9zdHJpbmdpZnkuZGVmYXVsdCkoYnl0ZXMpO1xuICB9IC8vIEZ1bmN0aW9uI25hbWUgaXMgbm90IHNldHRhYmxlIG9uIHNvbWUgcGxhdGZvcm1zICgjMjcwKVxuXG5cbiAgdHJ5IHtcbiAgICBnZW5lcmF0ZVVVSUQubmFtZSA9IG5hbWU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICB9IGNhdGNoIChlcnIpIHt9IC8vIEZvciBDb21tb25KUyBkZWZhdWx0IGV4cG9ydCBzdXBwb3J0XG5cblxuICBnZW5lcmF0ZVVVSUQuRE5TID0gRE5TO1xuICBnZW5lcmF0ZVVVSUQuVVJMID0gVVJMO1xuICByZXR1cm4gZ2VuZXJhdGVVVUlEO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JuZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm5nLmpzXCIpKTtcblxudmFyIF9zdHJpbmdpZnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgX3JuZy5kZWZhdWx0KSgpOyAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG5cblxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwOyAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcblxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIHJldHVybiAoMCwgX3N0cmluZ2lmeS5kZWZhdWx0KShybmRzKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gdjQ7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF92ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92MzUuanNcIikpO1xuXG52YXIgX3NoYSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc2hhMS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IHY1ID0gKDAsIF92LmRlZmF1bHQpKCd2NScsIDB4NTAsIF9zaGEuZGVmYXVsdCk7XG52YXIgX2RlZmF1bHQgPSB2NTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JlZ2V4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yZWdleC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHV1aWQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyAmJiBfcmVnZXguZGVmYXVsdC50ZXN0KHV1aWQpO1xufVxuXG52YXIgX2RlZmF1bHQgPSB2YWxpZGF0ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3ZhbGlkYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0ZS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHZlcnNpb24odXVpZCkge1xuICBpZiAoISgwLCBfdmFsaWRhdGUuZGVmYXVsdCkodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlSW50KHV1aWQuc3Vic3RyKDE0LCAxKSwgMTYpO1xufVxuXG52YXIgX2RlZmF1bHQgPSB2ZXJzaW9uO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiKGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIG1vZHVsZS5leHBvcnRzLmlzX3VyaSA9IGlzX2lyaTtcbiAgICBtb2R1bGUuZXhwb3J0cy5pc19odHRwX3VyaSA9IGlzX2h0dHBfaXJpO1xuICAgIG1vZHVsZS5leHBvcnRzLmlzX2h0dHBzX3VyaSA9IGlzX2h0dHBzX2lyaTtcbiAgICBtb2R1bGUuZXhwb3J0cy5pc193ZWJfdXJpID0gaXNfd2ViX2lyaTtcbiAgICAvLyBDcmVhdGUgYWxpYXNlc1xuICAgIG1vZHVsZS5leHBvcnRzLmlzVXJpID0gaXNfaXJpO1xuICAgIG1vZHVsZS5leHBvcnRzLmlzSHR0cFVyaSA9IGlzX2h0dHBfaXJpO1xuICAgIG1vZHVsZS5leHBvcnRzLmlzSHR0cHNVcmkgPSBpc19odHRwc19pcmk7XG4gICAgbW9kdWxlLmV4cG9ydHMuaXNXZWJVcmkgPSBpc193ZWJfaXJpO1xuXG5cbiAgICAvLyBwcml2YXRlIGZ1bmN0aW9uXG4gICAgLy8gaW50ZXJuYWwgVVJJIHNwaXR0ZXIgbWV0aG9kIC0gZGlyZWN0IGZyb20gUkZDIDM5ODZcbiAgICB2YXIgc3BsaXRVcmkgPSBmdW5jdGlvbih1cmkpIHtcbiAgICAgICAgdmFyIHNwbGl0dGVkID0gdXJpLm1hdGNoKC8oPzooW146XFwvPyNdKyk6KT8oPzpcXC9cXC8oW15cXC8/I10qKSk/KFtePyNdKikoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/Lyk7XG4gICAgICAgIHJldHVybiBzcGxpdHRlZDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNfaXJpKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGZvciBpbGxlZ2FsIGNoYXJhY3RlcnNcbiAgICAgICAgaWYgKC9bXmEtejAtOVxcOlxcL1xcP1xcI1xcW1xcXVxcQFxcIVxcJFxcJlxcJ1xcKFxcKVxcKlxcK1xcLFxcO1xcPVxcLlxcLVxcX1xcflxcJV0vaS50ZXN0KHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciBoZXggZXNjYXBlcyB0aGF0IGFyZW4ndCBjb21wbGV0ZVxuICAgICAgICBpZiAoLyVbXjAtOWEtZl0vaS50ZXN0KHZhbHVlKSkgcmV0dXJuO1xuICAgICAgICBpZiAoLyVbMC05YS1mXSg6P1teMC05YS1mXXwkKS9pLnRlc3QodmFsdWUpKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHNwbGl0dGVkID0gW107XG4gICAgICAgIHZhciBzY2hlbWUgPSAnJztcbiAgICAgICAgdmFyIGF1dGhvcml0eSA9ICcnO1xuICAgICAgICB2YXIgcGF0aCA9ICcnO1xuICAgICAgICB2YXIgcXVlcnkgPSAnJztcbiAgICAgICAgdmFyIGZyYWdtZW50ID0gJyc7XG4gICAgICAgIHZhciBvdXQgPSAnJztcblxuICAgICAgICAvLyBmcm9tIFJGQyAzOTg2XG4gICAgICAgIHNwbGl0dGVkID0gc3BsaXRVcmkodmFsdWUpO1xuICAgICAgICBzY2hlbWUgPSBzcGxpdHRlZFsxXTsgXG4gICAgICAgIGF1dGhvcml0eSA9IHNwbGl0dGVkWzJdO1xuICAgICAgICBwYXRoID0gc3BsaXR0ZWRbM107XG4gICAgICAgIHF1ZXJ5ID0gc3BsaXR0ZWRbNF07XG4gICAgICAgIGZyYWdtZW50ID0gc3BsaXR0ZWRbNV07XG5cbiAgICAgICAgLy8gc2NoZW1lIGFuZCBwYXRoIGFyZSByZXF1aXJlZCwgdGhvdWdoIHRoZSBwYXRoIGNhbiBiZSBlbXB0eVxuICAgICAgICBpZiAoIShzY2hlbWUgJiYgc2NoZW1lLmxlbmd0aCAmJiBwYXRoLmxlbmd0aCA+PSAwKSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGlmIGF1dGhvcml0eSBpcyBwcmVzZW50LCB0aGUgcGF0aCBtdXN0IGJlIGVtcHR5IG9yIGJlZ2luIHdpdGggYSAvXG4gICAgICAgIGlmIChhdXRob3JpdHkgJiYgYXV0aG9yaXR5Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocGF0aC5sZW5ndGggPT09IDAgfHwgL15cXC8vLnRlc3QocGF0aCkpKSByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBhdXRob3JpdHkgaXMgbm90IHByZXNlbnQsIHRoZSBwYXRoIG11c3Qgbm90IHN0YXJ0IHdpdGggLy9cbiAgICAgICAgICAgIGlmICgvXlxcL1xcLy8udGVzdChwYXRoKSkgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2NoZW1lIG11c3QgYmVnaW4gd2l0aCBhIGxldHRlciwgdGhlbiBjb25zaXN0IG9mIGxldHRlcnMsIGRpZ2l0cywgKywgLiwgb3IgLVxuICAgICAgICBpZiAoIS9eW2Etel1bYS16MC05XFwrXFwtXFwuXSokLy50ZXN0KHNjaGVtZS50b0xvd2VyQ2FzZSgpKSkgIHJldHVybjtcblxuICAgICAgICAvLyByZS1hc3NlbWJsZSB0aGUgVVJMIHBlciBzZWN0aW9uIDUuMyBpbiBSRkMgMzk4NlxuICAgICAgICBvdXQgKz0gc2NoZW1lICsgJzonO1xuICAgICAgICBpZiAoYXV0aG9yaXR5ICYmIGF1dGhvcml0eS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG91dCArPSAnLy8nICsgYXV0aG9yaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0ICs9IHBhdGg7XG5cbiAgICAgICAgaWYgKHF1ZXJ5ICYmIHF1ZXJ5Lmxlbmd0aCkge1xuICAgICAgICAgICAgb3V0ICs9ICc/JyArIHF1ZXJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyYWdtZW50ICYmIGZyYWdtZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgb3V0ICs9ICcjJyArIGZyYWdtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc19odHRwX2lyaSh2YWx1ZSwgYWxsb3dIdHRwcykge1xuICAgICAgICBpZiAoIWlzX2lyaSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzcGxpdHRlZCA9IFtdO1xuICAgICAgICB2YXIgc2NoZW1lID0gJyc7XG4gICAgICAgIHZhciBhdXRob3JpdHkgPSAnJztcbiAgICAgICAgdmFyIHBhdGggPSAnJztcbiAgICAgICAgdmFyIHBvcnQgPSAnJztcbiAgICAgICAgdmFyIHF1ZXJ5ID0gJyc7XG4gICAgICAgIHZhciBmcmFnbWVudCA9ICcnO1xuICAgICAgICB2YXIgb3V0ID0gJyc7XG5cbiAgICAgICAgLy8gZnJvbSBSRkMgMzk4NlxuICAgICAgICBzcGxpdHRlZCA9IHNwbGl0VXJpKHZhbHVlKTtcbiAgICAgICAgc2NoZW1lID0gc3BsaXR0ZWRbMV07IFxuICAgICAgICBhdXRob3JpdHkgPSBzcGxpdHRlZFsyXTtcbiAgICAgICAgcGF0aCA9IHNwbGl0dGVkWzNdO1xuICAgICAgICBxdWVyeSA9IHNwbGl0dGVkWzRdO1xuICAgICAgICBmcmFnbWVudCA9IHNwbGl0dGVkWzVdO1xuXG4gICAgICAgIGlmICghc2NoZW1lKSAgcmV0dXJuO1xuXG4gICAgICAgIGlmKGFsbG93SHR0cHMpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWUudG9Mb3dlckNhc2UoKSAhPSAnaHR0cHMnKSByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1lLnRvTG93ZXJDYXNlKCkgIT0gJ2h0dHAnKSByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmdWxseS1xdWFsaWZpZWQgVVJJcyBtdXN0IGhhdmUgYW4gYXV0aG9yaXR5IHNlY3Rpb24gdGhhdCBpc1xuICAgICAgICAvLyBhIHZhbGlkIGhvc3RcbiAgICAgICAgaWYgKCFhdXRob3JpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuYWJsZSBwb3J0IGNvbXBvbmVudFxuICAgICAgICBpZiAoLzooXFxkKykkLy50ZXN0KGF1dGhvcml0eSkpIHtcbiAgICAgICAgICAgIHBvcnQgPSBhdXRob3JpdHkubWF0Y2goLzooXFxkKykkLylbMF07XG4gICAgICAgICAgICBhdXRob3JpdHkgPSBhdXRob3JpdHkucmVwbGFjZSgvOlxcZCskLywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0ICs9IHNjaGVtZSArICc6JztcbiAgICAgICAgb3V0ICs9ICcvLycgKyBhdXRob3JpdHk7XG4gICAgICAgIFxuICAgICAgICBpZiAocG9ydCkge1xuICAgICAgICAgICAgb3V0ICs9IHBvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIG91dCArPSBwYXRoO1xuICAgICAgICBcbiAgICAgICAgaWYocXVlcnkgJiYgcXVlcnkubGVuZ3RoKXtcbiAgICAgICAgICAgIG91dCArPSAnPycgKyBxdWVyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGZyYWdtZW50ICYmIGZyYWdtZW50Lmxlbmd0aCl7XG4gICAgICAgICAgICBvdXQgKz0gJyMnICsgZnJhZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNfaHR0cHNfaXJpKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc19odHRwX2lyaSh2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNfd2ViX2lyaSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKGlzX2h0dHBfaXJpKHZhbHVlKSB8fCBpc19odHRwc19pcmkodmFsdWUpKTtcbiAgICB9XG5cbn0pKG1vZHVsZSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlYWRcblxudmFyIE1TQiA9IDB4ODBcbiAgLCBSRVNUID0gMHg3RlxuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciByZXMgICAgPSAwXG4gICAgLCBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICAgICwgc2hpZnQgID0gMFxuICAgICwgY291bnRlciA9IG9mZnNldFxuICAgICwgYlxuICAgICwgbCA9IGJ1Zi5sZW5ndGhcblxuICBkbyB7XG4gICAgaWYgKGNvdW50ZXIgPj0gbCkge1xuICAgICAgcmVhZC5ieXRlcyA9IDBcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdDb3VsZCBub3QgZGVjb2RlIHZhcmludCcpXG4gICAgfVxuICAgIGIgPSBidWZbY291bnRlcisrXVxuICAgIHJlcyArPSBzaGlmdCA8IDI4XG4gICAgICA/IChiICYgUkVTVCkgPDwgc2hpZnRcbiAgICAgIDogKGIgJiBSRVNUKSAqIE1hdGgucG93KDIsIHNoaWZ0KVxuICAgIHNoaWZ0ICs9IDdcbiAgfSB3aGlsZSAoYiA+PSBNU0IpXG5cbiAgcmVhZC5ieXRlcyA9IGNvdW50ZXIgLSBvZmZzZXRcblxuICByZXR1cm4gcmVzXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGVuY29kZVxuXG52YXIgTVNCID0gMHg4MFxuICAsIFJFU1QgPSAweDdGXG4gICwgTVNCQUxMID0gflJFU1RcbiAgLCBJTlQgPSBNYXRoLnBvdygyLCAzMSlcblxuZnVuY3Rpb24gZW5jb2RlKG51bSwgb3V0LCBvZmZzZXQpIHtcbiAgb3V0ID0gb3V0IHx8IFtdXG4gIG9mZnNldCA9IG9mZnNldCB8fCAwXG4gIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcblxuICB3aGlsZShudW0gPj0gSU5UKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IChudW0gJiAweEZGKSB8IE1TQlxuICAgIG51bSAvPSAxMjhcbiAgfVxuICB3aGlsZShudW0gJiBNU0JBTEwpIHtcbiAgICBvdXRbb2Zmc2V0KytdID0gKG51bSAmIDB4RkYpIHwgTVNCXG4gICAgbnVtID4+Pj0gN1xuICB9XG4gIG91dFtvZmZzZXRdID0gbnVtIHwgMFxuICBcbiAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0ICsgMVxuICBcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZW5jb2RlOiByZXF1aXJlKCcuL2VuY29kZS5qcycpXG4gICwgZGVjb2RlOiByZXF1aXJlKCcuL2RlY29kZS5qcycpXG4gICwgZW5jb2RpbmdMZW5ndGg6IHJlcXVpcmUoJy4vbGVuZ3RoLmpzJylcbn1cbiIsIlxudmFyIE4xID0gTWF0aC5wb3coMiwgIDcpXG52YXIgTjIgPSBNYXRoLnBvdygyLCAxNClcbnZhciBOMyA9IE1hdGgucG93KDIsIDIxKVxudmFyIE40ID0gTWF0aC5wb3coMiwgMjgpXG52YXIgTjUgPSBNYXRoLnBvdygyLCAzNSlcbnZhciBONiA9IE1hdGgucG93KDIsIDQyKVxudmFyIE43ID0gTWF0aC5wb3coMiwgNDkpXG52YXIgTjggPSBNYXRoLnBvdygyLCA1NilcbnZhciBOOSA9IE1hdGgucG93KDIsIDYzKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlIDwgTjEgPyAxXG4gIDogdmFsdWUgPCBOMiA/IDJcbiAgOiB2YWx1ZSA8IE4zID8gM1xuICA6IHZhbHVlIDwgTjQgPyA0XG4gIDogdmFsdWUgPCBONSA/IDVcbiAgOiB2YWx1ZSA8IE42ID8gNlxuICA6IHZhbHVlIDwgTjcgPyA3XG4gIDogdmFsdWUgPCBOOCA/IDhcbiAgOiB2YWx1ZSA8IE45ID8gOVxuICA6ICAgICAgICAgICAgICAxMFxuICApXG59XG4iLCJ2YXIgaW5kZXhPZiA9IGZ1bmN0aW9uICh4cywgaXRlbSkge1xuICAgIGlmICh4cy5pbmRleE9mKSByZXR1cm4geHMuaW5kZXhPZihpdGVtKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHhzW2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcbnZhciBPYmplY3Rfa2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoT2JqZWN0LmtleXMpIHJldHVybiBPYmplY3Qua2V5cyhvYmopXG4gICAgZWxzZSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikgcmVzLnB1c2goa2V5KVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoID0gZnVuY3Rpb24gKHhzLCBmbikge1xuICAgIGlmICh4cy5mb3JFYWNoKSByZXR1cm4geHMuZm9yRWFjaChmbilcbiAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm4oeHNbaV0sIGksIHhzKTtcbiAgICB9XG59O1xuXG52YXIgZGVmaW5lUHJvcCA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdfJywge30pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBvYmpbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG59KCkpO1xuXG52YXIgZ2xvYmFscyA9IFsnQXJyYXknLCAnQm9vbGVhbicsICdEYXRlJywgJ0Vycm9yJywgJ0V2YWxFcnJvcicsICdGdW5jdGlvbicsXG4nSW5maW5pdHknLCAnSlNPTicsICdNYXRoJywgJ05hTicsICdOdW1iZXInLCAnT2JqZWN0JywgJ1JhbmdlRXJyb3InLFxuJ1JlZmVyZW5jZUVycm9yJywgJ1JlZ0V4cCcsICdTdHJpbmcnLCAnU3ludGF4RXJyb3InLCAnVHlwZUVycm9yJywgJ1VSSUVycm9yJyxcbidkZWNvZGVVUkknLCAnZGVjb2RlVVJJQ29tcG9uZW50JywgJ2VuY29kZVVSSScsICdlbmNvZGVVUklDb21wb25lbnQnLCAnZXNjYXBlJyxcbidldmFsJywgJ2lzRmluaXRlJywgJ2lzTmFOJywgJ3BhcnNlRmxvYXQnLCAncGFyc2VJbnQnLCAndW5kZWZpbmVkJywgJ3VuZXNjYXBlJ107XG5cbmZ1bmN0aW9uIENvbnRleHQoKSB7fVxuQ29udGV4dC5wcm90b3R5cGUgPSB7fTtcblxudmFyIFNjcmlwdCA9IGV4cG9ydHMuU2NyaXB0ID0gZnVuY3Rpb24gTm9kZVNjcmlwdCAoY29kZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTY3JpcHQpKSByZXR1cm4gbmV3IFNjcmlwdChjb2RlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5JbkNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGlmICghKGNvbnRleHQgaW5zdGFuY2VvZiBDb250ZXh0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibmVlZHMgYSAnY29udGV4dCcgYXJndW1lbnQuXCIpO1xuICAgIH1cbiAgICBcbiAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWYgKCFpZnJhbWUuc3R5bGUpIGlmcmFtZS5zdHlsZSA9IHt9O1xuICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIFxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBcbiAgICB2YXIgd2luID0gaWZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gICAgdmFyIHdFdmFsID0gd2luLmV2YWwsIHdFeGVjU2NyaXB0ID0gd2luLmV4ZWNTY3JpcHQ7XG5cbiAgICBpZiAoIXdFdmFsICYmIHdFeGVjU2NyaXB0KSB7XG4gICAgICAgIC8vIHdpbi4oMCxldmFsKSgpIG1hZ2ljYWxseSBhcHBlYXJzIHdoZW4gdGhpcyBpcyBjYWxsZWQgaW4gSUU6XG4gICAgICAgIHdFeGVjU2NyaXB0LmNhbGwod2luLCAnbnVsbCcpO1xuICAgICAgICB3RXZhbCA9IHdpbi5ldmFsO1xuICAgIH1cbiAgICBcbiAgICBmb3JFYWNoKE9iamVjdF9rZXlzKGNvbnRleHQpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHdpbltrZXldID0gY29udGV4dFtrZXldO1xuICAgIH0pO1xuICAgIGZvckVhY2goZ2xvYmFscywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoY29udGV4dFtrZXldKSB7XG4gICAgICAgICAgICB3aW5ba2V5XSA9IGNvbnRleHRba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHZhciB3aW5LZXlzID0gT2JqZWN0X2tleXMod2luKTtcblxuICAgIHZhciByZXMgPSB3RXZhbC5jYWxsKHdpbiwgdGhpcy5jb2RlKTtcbiAgICBcbiAgICBmb3JFYWNoKE9iamVjdF9rZXlzKHdpbiksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLy8gQXZvaWQgY29weWluZyBjaXJjdWxhciBvYmplY3RzIGxpa2UgYHRvcGAgYW5kIGB3aW5kb3dgIGJ5IG9ubHlcbiAgICAgICAgLy8gdXBkYXRpbmcgZXhpc3RpbmcgY29udGV4dCBwcm9wZXJ0aWVzIG9yIG5ldyBwcm9wZXJ0aWVzIGluIHRoZSBgd2luYFxuICAgICAgICAvLyB0aGF0IHdhcyBvbmx5IGludHJvZHVjZWQgYWZ0ZXIgdGhlIGV2YWwuXG4gICAgICAgIGlmIChrZXkgaW4gY29udGV4dCB8fCBpbmRleE9mKHdpbktleXMsIGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICBjb250ZXh0W2tleV0gPSB3aW5ba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZm9yRWFjaChnbG9iYWxzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiBjb250ZXh0KSkge1xuICAgICAgICAgICAgZGVmaW5lUHJvcChjb250ZXh0LCBrZXksIHdpbltrZXldKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICBcbiAgICByZXR1cm4gcmVzO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5JblRoaXNDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoMCxldmFsKSh0aGlzLmNvZGUpOyAvLyBtYXliZS4uLlxufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5Jbk5ld0NvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBjdHggPSBTY3JpcHQuY3JlYXRlQ29udGV4dChjb250ZXh0KTtcbiAgICB2YXIgcmVzID0gdGhpcy5ydW5JbkNvbnRleHQoY3R4KTtcblxuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIGZvckVhY2goT2JqZWN0X2tleXMoY3R4KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29udGV4dFtrZXldID0gY3R4W2tleV07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59O1xuXG5mb3JFYWNoKE9iamVjdF9rZXlzKFNjcmlwdC5wcm90b3R5cGUpLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIGV4cG9ydHNbbmFtZV0gPSBTY3JpcHRbbmFtZV0gPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICB2YXIgcyA9IFNjcmlwdChjb2RlKTtcbiAgICAgICAgcmV0dXJuIHNbbmFtZV0uYXBwbHkocywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICB9O1xufSk7XG5cbmV4cG9ydHMuaXNDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gY29udGV4dCBpbnN0YW5jZW9mIENvbnRleHQ7XG59O1xuXG5leHBvcnRzLmNyZWF0ZVNjcmlwdCA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuU2NyaXB0KGNvZGUpO1xufTtcblxuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gU2NyaXB0LmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBjb3B5ID0gbmV3IENvbnRleHQoKTtcbiAgICBpZih0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yRWFjaChPYmplY3Rfa2V5cyhjb250ZXh0KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29weVtrZXldID0gY29udGV4dFtrZXldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFwid2ViZXh0ZW5zaW9uLXBvbHlmaWxsXCIsIFtcIm1vZHVsZVwiXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBmYWN0b3J5KG1vZHVsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1vZCA9IHtcbiAgICAgIGV4cG9ydHM6IHt9XG4gICAgfTtcbiAgICBmYWN0b3J5KG1vZCk7XG4gICAgZ2xvYmFsLmJyb3dzZXIgPSBtb2QuZXhwb3J0cztcbiAgfVxufSkodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24gKG1vZHVsZSkge1xuICAvKiB3ZWJleHRlbnNpb24tcG9seWZpbGwgLSB2MC44LjAgLSBUdWUgQXByIDIwIDIwMjEgMTE6Mjc6MzggKi9cblxuICAvKiAtKi0gTW9kZTogaW5kZW50LXRhYnMtbW9kZTogbmlsOyBqcy1pbmRlbnQtbGV2ZWw6IDIgLSotICovXG5cbiAgLyogdmltOiBzZXQgc3RzPTIgc3c9MiBldCB0dz04MDogKi9cblxuICAvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gICAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAgICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy4gKi9cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgaWYgKHR5cGVvZiBicm93c2VyID09PSBcInVuZGVmaW5lZFwiIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihicm93c2VyKSAhPT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgIGNvbnN0IENIUk9NRV9TRU5EX01FU1NBR0VfQ0FMTEJBQ0tfTk9fUkVTUE9OU0VfTUVTU0FHRSA9IFwiVGhlIG1lc3NhZ2UgcG9ydCBjbG9zZWQgYmVmb3JlIGEgcmVzcG9uc2Ugd2FzIHJlY2VpdmVkLlwiO1xuICAgIGNvbnN0IFNFTkRfUkVTUE9OU0VfREVQUkVDQVRJT05fV0FSTklORyA9IFwiUmV0dXJuaW5nIGEgUHJvbWlzZSBpcyB0aGUgcHJlZmVycmVkIHdheSB0byBzZW5kIGEgcmVwbHkgZnJvbSBhbiBvbk1lc3NhZ2Uvb25NZXNzYWdlRXh0ZXJuYWwgbGlzdGVuZXIsIGFzIHRoZSBzZW5kUmVzcG9uc2Ugd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIHNwZWNzIChTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9Nb3ppbGxhL0FkZC1vbnMvV2ViRXh0ZW5zaW9ucy9BUEkvcnVudGltZS9vbk1lc3NhZ2UpXCI7IC8vIFdyYXBwaW5nIHRoZSBidWxrIG9mIHRoaXMgcG9seWZpbGwgaW4gYSBvbmUtdGltZS11c2UgZnVuY3Rpb24gaXMgYSBtaW5vclxuICAgIC8vIG9wdGltaXphdGlvbiBmb3IgRmlyZWZveC4gU2luY2UgU3BpZGVybW9ua2V5IGRvZXMgbm90IGZ1bGx5IHBhcnNlIHRoZVxuICAgIC8vIGNvbnRlbnRzIG9mIGEgZnVuY3Rpb24gdW50aWwgdGhlIGZpcnN0IHRpbWUgaXQncyBjYWxsZWQsIGFuZCBzaW5jZSBpdCB3aWxsXG4gICAgLy8gbmV2ZXIgYWN0dWFsbHkgbmVlZCB0byBiZSBjYWxsZWQsIHRoaXMgYWxsb3dzIHRoZSBwb2x5ZmlsbCB0byBiZSBpbmNsdWRlZFxuICAgIC8vIGluIEZpcmVmb3ggbmVhcmx5IGZvciBmcmVlLlxuXG4gICAgY29uc3Qgd3JhcEFQSXMgPSBleHRlbnNpb25BUElzID0+IHtcbiAgICAgIC8vIE5PVEU6IGFwaU1ldGFkYXRhIGlzIGFzc29jaWF0ZWQgdG8gdGhlIGNvbnRlbnQgb2YgdGhlIGFwaS1tZXRhZGF0YS5qc29uIGZpbGVcbiAgICAgIC8vIGF0IGJ1aWxkIHRpbWUgYnkgcmVwbGFjaW5nIHRoZSBmb2xsb3dpbmcgXCJpbmNsdWRlXCIgd2l0aCB0aGUgY29udGVudCBvZiB0aGVcbiAgICAgIC8vIEpTT04gZmlsZS5cbiAgICAgIGNvbnN0IGFwaU1ldGFkYXRhID0ge1xuICAgICAgICBcImFsYXJtc1wiOiB7XG4gICAgICAgICAgXCJjbGVhclwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImNsZWFyQWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiYm9va21hcmtzXCI6IHtcbiAgICAgICAgICBcImNyZWF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldENoaWxkcmVuXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0UmVjZW50XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0U3ViVHJlZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFRyZWVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlVHJlZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNlYXJjaFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInVwZGF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImJyb3dzZXJBY3Rpb25cIjoge1xuICAgICAgICAgIFwiZGlzYWJsZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImVuYWJsZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEJhZGdlQmFja2dyb3VuZENvbG9yXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QmFkZ2VUZXh0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0UG9wdXBcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRUaXRsZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm9wZW5Qb3B1cFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldEJhZGdlQmFja2dyb3VuZENvbG9yXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0QmFkZ2VUZXh0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0SWNvblwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFBvcHVwXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0VGl0bGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJicm93c2luZ0RhdGFcIjoge1xuICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlQ2FjaGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVDb29raWVzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlRG93bmxvYWRzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlRm9ybURhdGFcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVIaXN0b3J5XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlTG9jYWxTdG9yYWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlUGFzc3dvcmRzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlUGx1Z2luRGF0YVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldHRpbmdzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiY29tbWFuZHNcIjoge1xuICAgICAgICAgIFwiZ2V0QWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiY29udGV4dE1lbnVzXCI6IHtcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInVwZGF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImNvb2tpZXNcIjoge1xuICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QWxsQ29va2llU3RvcmVzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiZGV2dG9vbHNcIjoge1xuICAgICAgICAgIFwiaW5zcGVjdGVkV2luZG93XCI6IHtcbiAgICAgICAgICAgIFwiZXZhbFwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMixcbiAgICAgICAgICAgICAgXCJzaW5nbGVDYWxsYmFja0FyZ1wiOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwYW5lbHNcIjoge1xuICAgICAgICAgICAgXCJjcmVhdGVcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMyxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDMsXG4gICAgICAgICAgICAgIFwic2luZ2xlQ2FsbGJhY2tBcmdcIjogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZWxlbWVudHNcIjoge1xuICAgICAgICAgICAgICBcImNyZWF0ZVNpZGViYXJQYW5lXCI6IHtcbiAgICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImRvd25sb2Fkc1wiOiB7XG4gICAgICAgICAgXCJjYW5jZWxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkb3dubG9hZFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImVyYXNlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0RmlsZUljb25cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJvcGVuXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicGF1c2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVGaWxlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVzdW1lXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2VhcmNoXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2hvd1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImV4dGVuc2lvblwiOiB7XG4gICAgICAgICAgXCJpc0FsbG93ZWRGaWxlU2NoZW1lQWNjZXNzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiaXNBbGxvd2VkSW5jb2duaXRvQWNjZXNzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiaGlzdG9yeVwiOiB7XG4gICAgICAgICAgXCJhZGRVcmxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkZWxldGVBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkZWxldGVSYW5nZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRlbGV0ZVVybFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFZpc2l0c1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNlYXJjaFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImkxOG5cIjoge1xuICAgICAgICAgIFwiZGV0ZWN0TGFuZ3VhZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBY2NlcHRMYW5ndWFnZXNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJpZGVudGl0eVwiOiB7XG4gICAgICAgICAgXCJsYXVuY2hXZWJBdXRoRmxvd1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImlkbGVcIjoge1xuICAgICAgICAgIFwicXVlcnlTdGF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIm1hbmFnZW1lbnRcIjoge1xuICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0U2VsZlwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldEVuYWJsZWRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1bmluc3RhbGxTZWxmXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwibm90aWZpY2F0aW9uc1wiOiB7XG4gICAgICAgICAgXCJjbGVhclwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImNyZWF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFBlcm1pc3Npb25MZXZlbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInVwZGF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBhZ2VBY3Rpb25cIjoge1xuICAgICAgICAgIFwiZ2V0UG9wdXBcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRUaXRsZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImhpZGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRJY29uXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0UG9wdXBcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRUaXRsZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNob3dcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwZXJtaXNzaW9uc1wiOiB7XG4gICAgICAgICAgXCJjb250YWluc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlcXVlc3RcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJydW50aW1lXCI6IHtcbiAgICAgICAgICBcImdldEJhY2tncm91bmRQYWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0UGxhdGZvcm1JbmZvXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwib3Blbk9wdGlvbnNQYWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVxdWVzdFVwZGF0ZUNoZWNrXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2VuZE1lc3NhZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogM1xuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZW5kTmF0aXZlTWVzc2FnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFVuaW5zdGFsbFVSTFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInNlc3Npb25zXCI6IHtcbiAgICAgICAgICBcImdldERldmljZXNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRSZWNlbnRseUNsb3NlZFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlc3RvcmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzdG9yYWdlXCI6IHtcbiAgICAgICAgICBcImxvY2FsXCI6IHtcbiAgICAgICAgICAgIFwiY2xlYXJcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2V0Qnl0ZXNJblVzZVwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzZXRcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwibWFuYWdlZFwiOiB7XG4gICAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2V0Qnl0ZXNJblVzZVwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzeW5jXCI6IHtcbiAgICAgICAgICAgIFwiY2xlYXJcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2V0Qnl0ZXNJblVzZVwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzZXRcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwidGFic1wiOiB7XG4gICAgICAgICAgXCJjYXB0dXJlVmlzaWJsZVRhYlwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImNyZWF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRldGVjdExhbmd1YWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZGlzY2FyZFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImR1cGxpY2F0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImV4ZWN1dGVTY3JpcHRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRDdXJyZW50XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0Wm9vbVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFpvb21TZXR0aW5nc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdvQmFja1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdvRm9yd2FyZFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImhpZ2hsaWdodFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImluc2VydENTU1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJxdWVyeVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbG9hZFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUNTU1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNlbmRNZXNzYWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDNcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0Wm9vbVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFpvb21TZXR0aW5nc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInVwZGF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInRvcFNpdGVzXCI6IHtcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIndlYk5hdmlnYXRpb25cIjoge1xuICAgICAgICAgIFwiZ2V0QWxsRnJhbWVzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0RnJhbWVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ3ZWJSZXF1ZXN0XCI6IHtcbiAgICAgICAgICBcImhhbmRsZXJCZWhhdmlvckNoYW5nZWRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ3aW5kb3dzXCI6IHtcbiAgICAgICAgICBcImNyZWF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEN1cnJlbnRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRMYXN0Rm9jdXNlZFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInVwZGF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoT2JqZWN0LmtleXMoYXBpTWV0YWRhdGEpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcGktbWV0YWRhdGEuanNvbiBoYXMgbm90IGJlZW4gaW5jbHVkZWQgaW4gYnJvd3Nlci1wb2x5ZmlsbFwiKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQSBXZWFrTWFwIHN1YmNsYXNzIHdoaWNoIGNyZWF0ZXMgYW5kIHN0b3JlcyBhIHZhbHVlIGZvciBhbnkga2V5IHdoaWNoIGRvZXNcbiAgICAgICAqIG5vdCBleGlzdCB3aGVuIGFjY2Vzc2VkLCBidXQgYmVoYXZlcyBleGFjdGx5IGFzIGFuIG9yZGluYXJ5IFdlYWtNYXBcbiAgICAgICAqIG90aGVyd2lzZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjcmVhdGVJdGVtXG4gICAgICAgKiAgICAgICAgQSBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCBpbiBvcmRlciB0byBjcmVhdGUgdGhlIHZhbHVlIGZvciBhbnlcbiAgICAgICAqICAgICAgICBrZXkgd2hpY2ggZG9lcyBub3QgZXhpc3QsIHRoZSBmaXJzdCB0aW1lIGl0IGlzIGFjY2Vzc2VkLiBUaGVcbiAgICAgICAqICAgICAgICBmdW5jdGlvbiByZWNlaXZlcywgYXMgaXRzIG9ubHkgYXJndW1lbnQsIHRoZSBrZXkgYmVpbmcgY3JlYXRlZC5cbiAgICAgICAqL1xuXG5cbiAgICAgIGNsYXNzIERlZmF1bHRXZWFrTWFwIGV4dGVuZHMgV2Vha01hcCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGNyZWF0ZUl0ZW0sIGl0ZW1zID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc3VwZXIoaXRlbXMpO1xuICAgICAgICAgIHRoaXMuY3JlYXRlSXRlbSA9IGNyZWF0ZUl0ZW07XG4gICAgICAgIH1cblxuICAgICAgICBnZXQoa2V5KSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLnNldChrZXksIHRoaXMuY3JlYXRlSXRlbShrZXkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3VwZXIuZ2V0KGtleSk7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhbiBvYmplY3Qgd2l0aCBhIGB0aGVuYCBtZXRob2QsIGFuZCBjYW5cbiAgICAgICAqIHRoZXJlZm9yZSBiZSBhc3N1bWVkIHRvIGJlaGF2ZSBhcyBhIFByb21pc2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB0aGVuYWJsZS5cbiAgICAgICAqL1xuXG5cbiAgICAgIGNvbnN0IGlzVGhlbmFibGUgPSB2YWx1ZSA9PiB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCwgd2hlbiBjYWxsZWQsIHdpbGwgcmVzb2x2ZSBvciByZWplY3RcbiAgICAgICAqIHRoZSBnaXZlbiBwcm9taXNlIGJhc2VkIG9uIGhvdyBpdCBpcyBjYWxsZWQ6XG4gICAgICAgKlxuICAgICAgICogLSBJZiwgd2hlbiBjYWxsZWQsIGBjaHJvbWUucnVudGltZS5sYXN0RXJyb3JgIGNvbnRhaW5zIGEgbm9uLW51bGwgb2JqZWN0LFxuICAgICAgICogICB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCB3aXRoIHRoYXQgdmFsdWUuXG4gICAgICAgKiAtIElmIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBleGFjdGx5IG9uZSBhcmd1bWVudCwgdGhlIHByb21pc2UgaXNcbiAgICAgICAqICAgcmVzb2x2ZWQgdG8gdGhhdCB2YWx1ZS5cbiAgICAgICAqIC0gT3RoZXJ3aXNlLCB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZCB0byBhbiBhcnJheSBjb250YWluaW5nIGFsbCBvZiB0aGVcbiAgICAgICAqICAgZnVuY3Rpb24ncyBhcmd1bWVudHMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IHByb21pc2VcbiAgICAgICAqICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVzb2x1dGlvbiBhbmQgcmVqZWN0aW9uIGZ1bmN0aW9ucyBvZiBhXG4gICAgICAgKiAgICAgICAgcHJvbWlzZS5cbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByb21pc2UucmVzb2x2ZVxuICAgICAgICogICAgICAgIFRoZSBwcm9taXNlJ3MgcmVzb2x1dGlvbiBmdW5jdGlvbi5cbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByb21pc2UucmVqZWN0XG4gICAgICAgKiAgICAgICAgVGhlIHByb21pc2UncyByZWplY3Rpb24gZnVuY3Rpb24uXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gbWV0YWRhdGFcbiAgICAgICAqICAgICAgICBNZXRhZGF0YSBhYm91dCB0aGUgd3JhcHBlZCBtZXRob2Qgd2hpY2ggaGFzIGNyZWF0ZWQgdGhlIGNhbGxiYWNrLlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBtZXRhZGF0YS5zaW5nbGVDYWxsYmFja0FyZ1xuICAgICAgICogICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggb25seSB0aGUgZmlyc3RcbiAgICAgICAqICAgICAgICBhcmd1bWVudCBvZiB0aGUgY2FsbGJhY2ssIGFsdGVybmF0aXZlbHkgYW4gYXJyYXkgb2YgYWxsIHRoZVxuICAgICAgICogICAgICAgIGNhbGxiYWNrIGFyZ3VtZW50cyBpcyByZXNvbHZlZC4gQnkgZGVmYXVsdCwgaWYgdGhlIGNhbGxiYWNrXG4gICAgICAgKiAgICAgICAgZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIG9ubHkgYSBzaW5nbGUgYXJndW1lbnQsIHRoYXQgd2lsbCBiZVxuICAgICAgICogICAgICAgIHJlc29sdmVkIHRvIHRoZSBwcm9taXNlLCB3aGlsZSBhbGwgYXJndW1lbnRzIHdpbGwgYmUgcmVzb2x2ZWQgYXNcbiAgICAgICAqICAgICAgICBhbiBhcnJheSBpZiBtdWx0aXBsZSBhcmUgZ2l2ZW4uXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge2Z1bmN0aW9ufVxuICAgICAgICogICAgICAgIFRoZSBnZW5lcmF0ZWQgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICAgKi9cblxuXG4gICAgICBjb25zdCBtYWtlQ2FsbGJhY2sgPSAocHJvbWlzZSwgbWV0YWRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuICguLi5jYWxsYmFja0FyZ3MpID0+IHtcbiAgICAgICAgICBpZiAoZXh0ZW5zaW9uQVBJcy5ydW50aW1lLmxhc3RFcnJvcikge1xuICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGV4dGVuc2lvbkFQSXMucnVudGltZS5sYXN0RXJyb3IubWVzc2FnZSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWV0YWRhdGEuc2luZ2xlQ2FsbGJhY2tBcmcgfHwgY2FsbGJhY2tBcmdzLmxlbmd0aCA8PSAxICYmIG1ldGFkYXRhLnNpbmdsZUNhbGxiYWNrQXJnICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKGNhbGxiYWNrQXJnc1swXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZShjYWxsYmFja0FyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHBsdXJhbGl6ZUFyZ3VtZW50cyA9IG51bUFyZ3MgPT4gbnVtQXJncyA9PSAxID8gXCJhcmd1bWVudFwiIDogXCJhcmd1bWVudHNcIjtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIHdyYXBwZXIgZnVuY3Rpb24gZm9yIGEgbWV0aG9kIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIG1ldGFkYXRhLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICAgKiAgICAgICAgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB3aGljaCBpcyBiZWluZyB3cmFwcGVkLlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IG1ldGFkYXRhXG4gICAgICAgKiAgICAgICAgTWV0YWRhdGEgYWJvdXQgdGhlIG1ldGhvZCBiZWluZyB3cmFwcGVkLlxuICAgICAgICogQHBhcmFtIHtpbnRlZ2VyfSBtZXRhZGF0YS5taW5BcmdzXG4gICAgICAgKiAgICAgICAgVGhlIG1pbmltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cyB3aGljaCBtdXN0IGJlIHBhc3NlZCB0byB0aGVcbiAgICAgICAqICAgICAgICBmdW5jdGlvbi4gSWYgY2FsbGVkIHdpdGggZmV3ZXIgdGhhbiB0aGlzIG51bWJlciBvZiBhcmd1bWVudHMsIHRoZVxuICAgICAgICogICAgICAgIHdyYXBwZXIgd2lsbCByYWlzZSBhbiBleGNlcHRpb24uXG4gICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IG1ldGFkYXRhLm1heEFyZ3NcbiAgICAgICAqICAgICAgICBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXJndW1lbnRzIHdoaWNoIG1heSBiZSBwYXNzZWQgdG8gdGhlXG4gICAgICAgKiAgICAgICAgZnVuY3Rpb24uIElmIGNhbGxlZCB3aXRoIG1vcmUgdGhhbiB0aGlzIG51bWJlciBvZiBhcmd1bWVudHMsIHRoZVxuICAgICAgICogICAgICAgIHdyYXBwZXIgd2lsbCByYWlzZSBhbiBleGNlcHRpb24uXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG1ldGFkYXRhLnNpbmdsZUNhbGxiYWNrQXJnXG4gICAgICAgKiAgICAgICAgV2hldGhlciBvciBub3QgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCBvbmx5IHRoZSBmaXJzdFxuICAgICAgICogICAgICAgIGFyZ3VtZW50IG9mIHRoZSBjYWxsYmFjaywgYWx0ZXJuYXRpdmVseSBhbiBhcnJheSBvZiBhbGwgdGhlXG4gICAgICAgKiAgICAgICAgY2FsbGJhY2sgYXJndW1lbnRzIGlzIHJlc29sdmVkLiBCeSBkZWZhdWx0LCBpZiB0aGUgY2FsbGJhY2tcbiAgICAgICAqICAgICAgICBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGggb25seSBhIHNpbmdsZSBhcmd1bWVudCwgdGhhdCB3aWxsIGJlXG4gICAgICAgKiAgICAgICAgcmVzb2x2ZWQgdG8gdGhlIHByb21pc2UsIHdoaWxlIGFsbCBhcmd1bWVudHMgd2lsbCBiZSByZXNvbHZlZCBhc1xuICAgICAgICogICAgICAgIGFuIGFycmF5IGlmIG11bHRpcGxlIGFyZSBnaXZlbi5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24ob2JqZWN0LCAuLi4qKX1cbiAgICAgICAqICAgICAgIFRoZSBnZW5lcmF0ZWQgd3JhcHBlciBmdW5jdGlvbi5cbiAgICAgICAqL1xuXG5cbiAgICAgIGNvbnN0IHdyYXBBc3luY0Z1bmN0aW9uID0gKG5hbWUsIG1ldGFkYXRhKSA9PiB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhc3luY0Z1bmN0aW9uV3JhcHBlcih0YXJnZXQsIC4uLmFyZ3MpIHtcbiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCBtZXRhZGF0YS5taW5BcmdzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGF0IGxlYXN0ICR7bWV0YWRhdGEubWluQXJnc30gJHtwbHVyYWxpemVBcmd1bWVudHMobWV0YWRhdGEubWluQXJncyl9IGZvciAke25hbWV9KCksIGdvdCAke2FyZ3MubGVuZ3RofWApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IG1ldGFkYXRhLm1heEFyZ3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYXQgbW9zdCAke21ldGFkYXRhLm1heEFyZ3N9ICR7cGx1cmFsaXplQXJndW1lbnRzKG1ldGFkYXRhLm1heEFyZ3MpfSBmb3IgJHtuYW1lfSgpLCBnb3QgJHthcmdzLmxlbmd0aH1gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhLmZhbGxiYWNrVG9Ob0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgQVBJIG1ldGhvZCBoYXMgY3VycmVudGx5IG5vIGNhbGxiYWNrIG9uIENocm9tZSwgYnV0IGl0IHJldHVybiBhIHByb21pc2Ugb24gRmlyZWZveCxcbiAgICAgICAgICAgICAgLy8gYW5kIHNvIHRoZSBwb2x5ZmlsbCB3aWxsIHRyeSB0byBjYWxsIGl0IHdpdGggYSBjYWxsYmFjayBmaXJzdCwgYW5kIGl0IHdpbGwgZmFsbGJhY2tcbiAgICAgICAgICAgICAgLy8gdG8gbm90IHBhc3NpbmcgdGhlIGNhbGxiYWNrIGlmIHRoZSBmaXJzdCBjYWxsIGZhaWxzLlxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSguLi5hcmdzLCBtYWtlQ2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgICAgIH0sIG1ldGFkYXRhKSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGNiRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7bmFtZX0gQVBJIG1ldGhvZCBkb2Vzbid0IHNlZW0gdG8gc3VwcG9ydCB0aGUgY2FsbGJhY2sgcGFyYW1ldGVyLCBgICsgXCJmYWxsaW5nIGJhY2sgdG8gY2FsbCBpdCB3aXRob3V0IGEgY2FsbGJhY2s6IFwiLCBjYkVycm9yKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0oLi4uYXJncyk7IC8vIFVwZGF0ZSB0aGUgQVBJIG1ldGhvZCBtZXRhZGF0YSwgc28gdGhhdCB0aGUgbmV4dCBBUEkgY2FsbHMgd2lsbCBub3QgdHJ5IHRvXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSB1bnN1cHBvcnRlZCBjYWxsYmFjayBhbnltb3JlLlxuXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEuZmFsbGJhY2tUb05vQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5ub0NhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWV0YWRhdGEubm9DYWxsYmFjaykge1xuICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0oLi4uYXJncyk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRhcmdldFtuYW1lXSguLi5hcmdzLCBtYWtlQ2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgICAgICAgIH0sIG1ldGFkYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwcyBhbiBleGlzdGluZyBtZXRob2Qgb2YgdGhlIHRhcmdldCBvYmplY3QsIHNvIHRoYXQgY2FsbHMgdG8gaXQgYXJlXG4gICAgICAgKiBpbnRlcmNlcHRlZCBieSB0aGUgZ2l2ZW4gd3JhcHBlciBmdW5jdGlvbi4gVGhlIHdyYXBwZXIgZnVuY3Rpb24gcmVjZWl2ZXMsXG4gICAgICAgKiBhcyBpdHMgZmlyc3QgYXJndW1lbnQsIHRoZSBvcmlnaW5hbCBgdGFyZ2V0YCBvYmplY3QsIGZvbGxvd2VkIGJ5IGVhY2ggb2ZcbiAgICAgICAqIHRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBvcmlnaW5hbCBtZXRob2QuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IHRhcmdldFxuICAgICAgICogICAgICAgIFRoZSBvcmlnaW5hbCB0YXJnZXQgb2JqZWN0IHRoYXQgdGhlIHdyYXBwZWQgbWV0aG9kIGJlbG9uZ3MgdG8uXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2RcbiAgICAgICAqICAgICAgICBUaGUgbWV0aG9kIGJlaW5nIHdyYXBwZWQuIFRoaXMgaXMgdXNlZCBhcyB0aGUgdGFyZ2V0IG9mIHRoZSBQcm94eVxuICAgICAgICogICAgICAgIG9iamVjdCB3aGljaCBpcyBjcmVhdGVkIHRvIHdyYXAgdGhlIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHdyYXBwZXJcbiAgICAgICAqICAgICAgICBUaGUgd3JhcHBlciBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgaW4gcGxhY2Ugb2YgYSBkaXJlY3QgaW52b2NhdGlvblxuICAgICAgICogICAgICAgIG9mIHRoZSB3cmFwcGVkIG1ldGhvZC5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7UHJveHk8ZnVuY3Rpb24+fVxuICAgICAgICogICAgICAgIEEgUHJveHkgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gbWV0aG9kLCB3aGljaCBpbnZva2VzIHRoZSBnaXZlbiB3cmFwcGVyXG4gICAgICAgKiAgICAgICAgbWV0aG9kIGluIGl0cyBwbGFjZS5cbiAgICAgICAqL1xuXG5cbiAgICAgIGNvbnN0IHdyYXBNZXRob2QgPSAodGFyZ2V0LCBtZXRob2QsIHdyYXBwZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShtZXRob2QsIHtcbiAgICAgICAgICBhcHBseSh0YXJnZXRNZXRob2QsIHRoaXNPYmosIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLmNhbGwodGhpc09iaiwgdGFyZ2V0LCAuLi5hcmdzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBsZXQgaGFzT3duUHJvcGVydHkgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4gICAgICAvKipcbiAgICAgICAqIFdyYXBzIGFuIG9iamVjdCBpbiBhIFByb3h5IHdoaWNoIGludGVyY2VwdHMgYW5kIHdyYXBzIGNlcnRhaW4gbWV0aG9kc1xuICAgICAgICogYmFzZWQgb24gdGhlIGdpdmVuIGB3cmFwcGVyc2AgYW5kIGBtZXRhZGF0YWAgb2JqZWN0cy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0XG4gICAgICAgKiAgICAgICAgVGhlIHRhcmdldCBvYmplY3QgdG8gd3JhcC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gW3dyYXBwZXJzID0ge31dXG4gICAgICAgKiAgICAgICAgQW4gb2JqZWN0IHRyZWUgY29udGFpbmluZyB3cmFwcGVyIGZ1bmN0aW9ucyBmb3Igc3BlY2lhbCBjYXNlcy4gQW55XG4gICAgICAgKiAgICAgICAgZnVuY3Rpb24gcHJlc2VudCBpbiB0aGlzIG9iamVjdCB0cmVlIGlzIGNhbGxlZCBpbiBwbGFjZSBvZiB0aGVcbiAgICAgICAqICAgICAgICBtZXRob2QgaW4gdGhlIHNhbWUgbG9jYXRpb24gaW4gdGhlIGB0YXJnZXRgIG9iamVjdCB0cmVlLiBUaGVzZVxuICAgICAgICogICAgICAgIHdyYXBwZXIgbWV0aG9kcyBhcmUgaW52b2tlZCBhcyBkZXNjcmliZWQgaW4ge0BzZWUgd3JhcE1ldGhvZH0uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IFttZXRhZGF0YSA9IHt9XVxuICAgICAgICogICAgICAgIEFuIG9iamVjdCB0cmVlIGNvbnRhaW5pbmcgbWV0YWRhdGEgdXNlZCB0byBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlXG4gICAgICAgKiAgICAgICAgUHJvbWlzZS1iYXNlZCB3cmFwcGVyIGZ1bmN0aW9ucyBmb3IgYXN5bmNocm9ub3VzLiBBbnkgZnVuY3Rpb24gaW5cbiAgICAgICAqICAgICAgICB0aGUgYHRhcmdldGAgb2JqZWN0IHRyZWUgd2hpY2ggaGFzIGEgY29ycmVzcG9uZGluZyBtZXRhZGF0YSBvYmplY3RcbiAgICAgICAqICAgICAgICBpbiB0aGUgc2FtZSBsb2NhdGlvbiBpbiB0aGUgYG1ldGFkYXRhYCB0cmVlIGlzIHJlcGxhY2VkIHdpdGggYW5cbiAgICAgICAqICAgICAgICBhdXRvbWF0aWNhbGx5LWdlbmVyYXRlZCB3cmFwcGVyIGZ1bmN0aW9uLCBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAqICAgICAgICB7QHNlZSB3cmFwQXN5bmNGdW5jdGlvbn1cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7UHJveHk8b2JqZWN0Pn1cbiAgICAgICAqL1xuXG4gICAgICBjb25zdCB3cmFwT2JqZWN0ID0gKHRhcmdldCwgd3JhcHBlcnMgPSB7fSwgbWV0YWRhdGEgPSB7fSkgPT4ge1xuICAgICAgICBsZXQgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgaGFuZGxlcnMgPSB7XG4gICAgICAgICAgaGFzKHByb3h5VGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcCBpbiB0YXJnZXQgfHwgcHJvcCBpbiBjYWNoZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZ2V0KHByb3h5VGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgaWYgKHByb3AgaW4gY2FjaGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlW3Byb3BdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIShwcm9wIGluIHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG1ldGhvZCBvbiB0aGUgdW5kZXJseWluZyBvYmplY3QuIENoZWNrIGlmIHdlIG5lZWQgdG8gZG9cbiAgICAgICAgICAgICAgLy8gYW55IHdyYXBwaW5nLlxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHdyYXBwZXJzW3Byb3BdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgc3BlY2lhbC1jYXNlIHdyYXBwZXIgZm9yIHRoaXMgbWV0aG9kLlxuICAgICAgICAgICAgICAgIHZhbHVlID0gd3JhcE1ldGhvZCh0YXJnZXQsIHRhcmdldFtwcm9wXSwgd3JhcHBlcnNbcHJvcF0pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KG1ldGFkYXRhLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gYXN5bmMgbWV0aG9kIHRoYXQgd2UgaGF2ZSBtZXRhZGF0YSBmb3IuIENyZWF0ZSBhXG4gICAgICAgICAgICAgICAgLy8gUHJvbWlzZSB3cmFwcGVyIGZvciBpdC5cbiAgICAgICAgICAgICAgICBsZXQgd3JhcHBlciA9IHdyYXBBc3luY0Z1bmN0aW9uKHByb3AsIG1ldGFkYXRhW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHdyYXBNZXRob2QodGFyZ2V0LCB0YXJnZXRbcHJvcF0sIHdyYXBwZXIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBtZXRob2QgdGhhdCB3ZSBkb24ndCBrbm93IG9yIGNhcmUgYWJvdXQuIFJldHVybiB0aGVcbiAgICAgICAgICAgICAgICAvLyBvcmlnaW5hbCBtZXRob2QsIGJvdW5kIHRvIHRoZSB1bmRlcmx5aW5nIG9iamVjdC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmJpbmQodGFyZ2V0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgKGhhc093blByb3BlcnR5KHdyYXBwZXJzLCBwcm9wKSB8fCBoYXNPd25Qcm9wZXJ0eShtZXRhZGF0YSwgcHJvcCkpKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gb2JqZWN0IHRoYXQgd2UgbmVlZCB0byBkbyBzb21lIHdyYXBwaW5nIGZvciB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgICAgLy8gb2YuIENyZWF0ZSBhIHN1Yi1vYmplY3Qgd3JhcHBlciBmb3IgaXQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgY2hpbGRcbiAgICAgICAgICAgICAgLy8gbWV0YWRhdGEuXG4gICAgICAgICAgICAgIHZhbHVlID0gd3JhcE9iamVjdCh2YWx1ZSwgd3JhcHBlcnNbcHJvcF0sIG1ldGFkYXRhW3Byb3BdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzT3duUHJvcGVydHkobWV0YWRhdGEsIFwiKlwiKSkge1xuICAgICAgICAgICAgICAvLyBXcmFwIGFsbCBwcm9wZXJ0aWVzIGluICogbmFtZXNwYWNlLlxuICAgICAgICAgICAgICB2YWx1ZSA9IHdyYXBPYmplY3QodmFsdWUsIHdyYXBwZXJzW3Byb3BdLCBtZXRhZGF0YVtcIipcIl0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBkbyBhbnkgd3JhcHBpbmcgZm9yIHRoaXMgcHJvcGVydHksXG4gICAgICAgICAgICAgIC8vIHNvIGp1c3QgZm9yd2FyZCBhbGwgYWNjZXNzIHRvIHRoZSB1bmRlcmx5aW5nIG9iamVjdC5cbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNhY2hlLCBwcm9wLCB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWNoZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBzZXQocHJveHlUYXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICAgICAgaWYgKHByb3AgaW4gY2FjaGUpIHtcbiAgICAgICAgICAgICAgY2FjaGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkocHJveHlUYXJnZXQsIHByb3AsIGRlc2MpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmRlZmluZVByb3BlcnR5KGNhY2hlLCBwcm9wLCBkZXNjKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZGVsZXRlUHJvcGVydHkocHJveHlUYXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KGNhY2hlLCBwcm9wKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfTsgLy8gUGVyIGNvbnRyYWN0IG9mIHRoZSBQcm94eSBBUEksIHRoZSBcImdldFwiIHByb3h5IGhhbmRsZXIgbXVzdCByZXR1cm4gdGhlXG4gICAgICAgIC8vIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSB0YXJnZXQgaWYgdGhhdCB2YWx1ZSBpcyBkZWNsYXJlZCByZWFkLW9ubHkgYW5kXG4gICAgICAgIC8vIG5vbi1jb25maWd1cmFibGUuIEZvciB0aGlzIHJlYXNvbiwgd2UgY3JlYXRlIGFuIG9iamVjdCB3aXRoIHRoZVxuICAgICAgICAvLyBwcm90b3R5cGUgc2V0IHRvIGB0YXJnZXRgIGluc3RlYWQgb2YgdXNpbmcgYHRhcmdldGAgZGlyZWN0bHkuXG4gICAgICAgIC8vIE90aGVyd2lzZSB3ZSBjYW5ub3QgcmV0dXJuIGEgY3VzdG9tIG9iamVjdCBmb3IgQVBJcyB0aGF0XG4gICAgICAgIC8vIGFyZSBkZWNsYXJlZCByZWFkLW9ubHkgYW5kIG5vbi1jb25maWd1cmFibGUsIHN1Y2ggYXMgYGNocm9tZS5kZXZ0b29sc2AuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBwcm94eSBoYW5kbGVycyB0aGVtc2VsdmVzIHdpbGwgc3RpbGwgdXNlIHRoZSBvcmlnaW5hbCBgdGFyZ2V0YFxuICAgICAgICAvLyBpbnN0ZWFkIG9mIHRoZSBgcHJveHlUYXJnZXRgLCBzbyB0aGF0IHRoZSBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIGFyZVxuICAgICAgICAvLyBkZXJlZmVyZW5jZWQgdmlhIHRoZSBvcmlnaW5hbCB0YXJnZXRzLlxuXG4gICAgICAgIGxldCBwcm94eVRhcmdldCA9IE9iamVjdC5jcmVhdGUodGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShwcm94eVRhcmdldCwgaGFuZGxlcnMpO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIHNldCBvZiB3cmFwcGVyIGZ1bmN0aW9ucyBmb3IgYW4gZXZlbnQgb2JqZWN0LCB3aGljaCBoYW5kbGVzXG4gICAgICAgKiB3cmFwcGluZyBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdGhhdCB0aG9zZSBtZXNzYWdlcyBhcmUgcGFzc2VkLlxuICAgICAgICpcbiAgICAgICAqIEEgc2luZ2xlIHdyYXBwZXIgaXMgY3JlYXRlZCBmb3IgZWFjaCBsaXN0ZW5lciBmdW5jdGlvbiwgYW5kIHN0b3JlZCBpbiBhXG4gICAgICAgKiBtYXAuIFN1YnNlcXVlbnQgY2FsbHMgdG8gYGFkZExpc3RlbmVyYCwgYGhhc0xpc3RlbmVyYCwgb3IgYHJlbW92ZUxpc3RlbmVyYFxuICAgICAgICogcmV0cmlldmUgdGhlIG9yaWdpbmFsIHdyYXBwZXIsIHNvIHRoYXQgIGF0dGVtcHRzIHRvIHJlbW92ZSBhXG4gICAgICAgKiBwcmV2aW91c2x5LWFkZGVkIGxpc3RlbmVyIHdvcmsgYXMgZXhwZWN0ZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtEZWZhdWx0V2Vha01hcDxmdW5jdGlvbiwgZnVuY3Rpb24+fSB3cmFwcGVyTWFwXG4gICAgICAgKiAgICAgICAgQSBEZWZhdWx0V2Vha01hcCBvYmplY3Qgd2hpY2ggd2lsbCBjcmVhdGUgdGhlIGFwcHJvcHJpYXRlIHdyYXBwZXJcbiAgICAgICAqICAgICAgICBmb3IgYSBnaXZlbiBsaXN0ZW5lciBmdW5jdGlvbiB3aGVuIG9uZSBkb2VzIG5vdCBleGlzdCwgYW5kIHJldHJpZXZlXG4gICAgICAgKiAgICAgICAgYW4gZXhpc3Rpbmcgb25lIHdoZW4gaXQgZG9lcy5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAgICovXG5cblxuICAgICAgY29uc3Qgd3JhcEV2ZW50ID0gd3JhcHBlck1hcCA9PiAoe1xuICAgICAgICBhZGRMaXN0ZW5lcih0YXJnZXQsIGxpc3RlbmVyLCAuLi5hcmdzKSB7XG4gICAgICAgICAgdGFyZ2V0LmFkZExpc3RlbmVyKHdyYXBwZXJNYXAuZ2V0KGxpc3RlbmVyKSwgLi4uYXJncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzTGlzdGVuZXIodGFyZ2V0LCBsaXN0ZW5lcikge1xuICAgICAgICAgIHJldHVybiB0YXJnZXQuaGFzTGlzdGVuZXIod3JhcHBlck1hcC5nZXQobGlzdGVuZXIpKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVMaXN0ZW5lcih0YXJnZXQsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHdyYXBwZXJNYXAuZ2V0KGxpc3RlbmVyKSk7XG4gICAgICAgIH1cblxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG9uUmVxdWVzdEZpbmlzaGVkV3JhcHBlcnMgPSBuZXcgRGVmYXVsdFdlYWtNYXAobGlzdGVuZXIgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyYXBzIGFuIG9uUmVxdWVzdEZpbmlzaGVkIGxpc3RlbmVyIGZ1bmN0aW9uIHNvIHRoYXQgaXQgd2lsbCByZXR1cm4gYVxuICAgICAgICAgKiBgZ2V0Q29udGVudCgpYCBwcm9wZXJ0eSB3aGljaCByZXR1cm5zIGEgYFByb21pc2VgIHJhdGhlciB0aGFuIHVzaW5nIGFcbiAgICAgICAgICogY2FsbGJhY2sgQVBJLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVxXG4gICAgICAgICAqICAgICAgICBUaGUgSEFSIGVudHJ5IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG5ldHdvcmsgcmVxdWVzdC5cbiAgICAgICAgICovXG5cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gb25SZXF1ZXN0RmluaXNoZWQocmVxKSB7XG4gICAgICAgICAgY29uc3Qgd3JhcHBlZFJlcSA9IHdyYXBPYmplY3QocmVxLCB7fVxuICAgICAgICAgIC8qIHdyYXBwZXJzICovXG4gICAgICAgICAgLCB7XG4gICAgICAgICAgICBnZXRDb250ZW50OiB7XG4gICAgICAgICAgICAgIG1pbkFyZ3M6IDAsXG4gICAgICAgICAgICAgIG1heEFyZ3M6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsaXN0ZW5lcih3cmFwcGVkUmVxKTtcbiAgICAgICAgfTtcbiAgICAgIH0pOyAvLyBLZWVwIHRyYWNrIGlmIHRoZSBkZXByZWNhdGlvbiB3YXJuaW5nIGhhcyBiZWVuIGxvZ2dlZCBhdCBsZWFzdCBvbmNlLlxuXG4gICAgICBsZXQgbG9nZ2VkU2VuZFJlc3BvbnNlRGVwcmVjYXRpb25XYXJuaW5nID0gZmFsc2U7XG4gICAgICBjb25zdCBvbk1lc3NhZ2VXcmFwcGVycyA9IG5ldyBEZWZhdWx0V2Vha01hcChsaXN0ZW5lciA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybiBsaXN0ZW5lcjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV3JhcHMgYSBtZXNzYWdlIGxpc3RlbmVyIGZ1bmN0aW9uIHNvIHRoYXQgaXQgbWF5IHNlbmQgcmVzcG9uc2VzIGJhc2VkIG9uXG4gICAgICAgICAqIGl0cyByZXR1cm4gdmFsdWUsIHJhdGhlciB0aGFuIGJ5IHJldHVybmluZyBhIHNlbnRpbmVsIHZhbHVlIGFuZCBjYWxsaW5nIGFcbiAgICAgICAgICogY2FsbGJhY2suIElmIHRoZSBsaXN0ZW5lciBmdW5jdGlvbiByZXR1cm5zIGEgUHJvbWlzZSwgdGhlIHJlc3BvbnNlIGlzXG4gICAgICAgICAqIHNlbnQgd2hlbiB0aGUgcHJvbWlzZSBlaXRoZXIgcmVzb2x2ZXMgb3IgcmVqZWN0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHsqfSBtZXNzYWdlXG4gICAgICAgICAqICAgICAgICBUaGUgbWVzc2FnZSBzZW50IGJ5IHRoZSBvdGhlciBlbmQgb2YgdGhlIGNoYW5uZWwuXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZW5kZXJcbiAgICAgICAgICogICAgICAgIERldGFpbHMgYWJvdXQgdGhlIHNlbmRlciBvZiB0aGUgbWVzc2FnZS5cbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbigqKX0gc2VuZFJlc3BvbnNlXG4gICAgICAgICAqICAgICAgICBBIGNhbGxiYWNrIHdoaWNoLCB3aGVuIGNhbGxlZCB3aXRoIGFuIGFyYml0cmFyeSBhcmd1bWVudCwgc2VuZHNcbiAgICAgICAgICogICAgICAgIHRoYXQgdmFsdWUgYXMgYSByZXNwb25zZS5cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqICAgICAgICBUcnVlIGlmIHRoZSB3cmFwcGVkIGxpc3RlbmVyIHJldHVybmVkIGEgUHJvbWlzZSwgd2hpY2ggd2lsbCBsYXRlclxuICAgICAgICAgKiAgICAgICAgeWllbGQgYSByZXNwb25zZS4gRmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cblxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBvbk1lc3NhZ2UobWVzc2FnZSwgc2VuZGVyLCBzZW5kUmVzcG9uc2UpIHtcbiAgICAgICAgICBsZXQgZGlkQ2FsbFNlbmRSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgIGxldCB3cmFwcGVkU2VuZFJlc3BvbnNlO1xuICAgICAgICAgIGxldCBzZW5kUmVzcG9uc2VQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICB3cmFwcGVkU2VuZFJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIGlmICghbG9nZ2VkU2VuZFJlc3BvbnNlRGVwcmVjYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFNFTkRfUkVTUE9OU0VfREVQUkVDQVRJT05fV0FSTklORywgbmV3IEVycm9yKCkuc3RhY2spO1xuICAgICAgICAgICAgICAgIGxvZ2dlZFNlbmRSZXNwb25zZURlcHJlY2F0aW9uV2FybmluZyA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkaWRDYWxsU2VuZFJlc3BvbnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbGlzdGVuZXIobWVzc2FnZSwgc2VuZGVyLCB3cmFwcGVkU2VuZFJlc3BvbnNlKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaXNSZXN1bHRUaGVuYWJsZSA9IHJlc3VsdCAhPT0gdHJ1ZSAmJiBpc1RoZW5hYmxlKHJlc3VsdCk7IC8vIElmIHRoZSBsaXN0ZW5lciBkaWRuJ3QgcmV0dXJuZWQgdHJ1ZSBvciBhIFByb21pc2UsIG9yIGNhbGxlZFxuICAgICAgICAgIC8vIHdyYXBwZWRTZW5kUmVzcG9uc2Ugc3luY2hyb25vdXNseSwgd2UgY2FuIGV4aXQgZWFybGllclxuICAgICAgICAgIC8vIGJlY2F1c2UgdGhlcmUgd2lsbCBiZSBubyByZXNwb25zZSBzZW50IGZyb20gdGhpcyBsaXN0ZW5lci5cblxuICAgICAgICAgIGlmIChyZXN1bHQgIT09IHRydWUgJiYgIWlzUmVzdWx0VGhlbmFibGUgJiYgIWRpZENhbGxTZW5kUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IC8vIEEgc21hbGwgaGVscGVyIHRvIHNlbmQgdGhlIG1lc3NhZ2UgaWYgdGhlIHByb21pc2UgcmVzb2x2ZXNcbiAgICAgICAgICAvLyBhbmQgYW4gZXJyb3IgaWYgdGhlIHByb21pc2UgcmVqZWN0cyAoYSB3cmFwcGVkIHNlbmRNZXNzYWdlIGhhc1xuICAgICAgICAgIC8vIHRvIHRyYW5zbGF0ZSB0aGUgbWVzc2FnZSBpbnRvIGEgcmVzb2x2ZWQgcHJvbWlzZSBvciBhIHJlamVjdGVkXG4gICAgICAgICAgLy8gcHJvbWlzZSkuXG5cblxuICAgICAgICAgIGNvbnN0IHNlbmRQcm9taXNlZFJlc3VsdCA9IHByb21pc2UgPT4ge1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKG1zZyA9PiB7XG4gICAgICAgICAgICAgIC8vIHNlbmQgdGhlIG1lc3NhZ2UgdmFsdWUuXG4gICAgICAgICAgICAgIHNlbmRSZXNwb25zZShtc2cpO1xuICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAvLyBTZW5kIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgZXJyb3IgaWYgdGhlIHJlamVjdGVkIHZhbHVlXG4gICAgICAgICAgICAgIC8vIGlzIGFuIGluc3RhbmNlIG9mIGVycm9yLCBvciB0aGUgb2JqZWN0IGl0c2VsZiBvdGhlcndpc2UuXG4gICAgICAgICAgICAgIGxldCBtZXNzYWdlO1xuXG4gICAgICAgICAgICAgIGlmIChlcnJvciAmJiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkXCI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzZW5kUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIF9fbW96V2ViRXh0ZW5zaW9uUG9seWZpbGxSZWplY3RfXzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgLy8gUHJpbnQgYW4gZXJyb3Igb24gdGhlIGNvbnNvbGUgaWYgdW5hYmxlIHRvIHNlbmQgdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHNlbmQgb25NZXNzYWdlIHJlamVjdGVkIHJlcGx5XCIsIGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9OyAvLyBJZiB0aGUgbGlzdGVuZXIgcmV0dXJuZWQgYSBQcm9taXNlLCBzZW5kIHRoZSByZXNvbHZlZCB2YWx1ZSBhcyBhXG4gICAgICAgICAgLy8gcmVzdWx0LCBvdGhlcndpc2Ugd2FpdCB0aGUgcHJvbWlzZSByZWxhdGVkIHRvIHRoZSB3cmFwcGVkU2VuZFJlc3BvbnNlXG4gICAgICAgICAgLy8gY2FsbGJhY2sgdG8gcmVzb2x2ZSBhbmQgc2VuZCBpdCBhcyBhIHJlc3BvbnNlLlxuXG5cbiAgICAgICAgICBpZiAoaXNSZXN1bHRUaGVuYWJsZSkge1xuICAgICAgICAgICAgc2VuZFByb21pc2VkUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbmRQcm9taXNlZFJlc3VsdChzZW5kUmVzcG9uc2VQcm9taXNlKTtcbiAgICAgICAgICB9IC8vIExldCBDaHJvbWUga25vdyB0aGF0IHRoZSBsaXN0ZW5lciBpcyByZXBseWluZy5cblxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgd3JhcHBlZFNlbmRNZXNzYWdlQ2FsbGJhY2sgPSAoe1xuICAgICAgICByZWplY3QsXG4gICAgICAgIHJlc29sdmVcbiAgICAgIH0sIHJlcGx5KSA9PiB7XG4gICAgICAgIGlmIChleHRlbnNpb25BUElzLnJ1bnRpbWUubGFzdEVycm9yKSB7XG4gICAgICAgICAgLy8gRGV0ZWN0IHdoZW4gbm9uZSBvZiB0aGUgbGlzdGVuZXJzIHJlcGxpZWQgdG8gdGhlIHNlbmRNZXNzYWdlIGNhbGwgYW5kIHJlc29sdmVcbiAgICAgICAgICAvLyB0aGUgcHJvbWlzZSB0byB1bmRlZmluZWQgYXMgaW4gRmlyZWZveC5cbiAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvd2ViZXh0ZW5zaW9uLXBvbHlmaWxsL2lzc3Vlcy8xMzBcbiAgICAgICAgICBpZiAoZXh0ZW5zaW9uQVBJcy5ydW50aW1lLmxhc3RFcnJvci5tZXNzYWdlID09PSBDSFJPTUVfU0VORF9NRVNTQUdFX0NBTExCQUNLX05PX1JFU1BPTlNFX01FU1NBR0UpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihleHRlbnNpb25BUElzLnJ1bnRpbWUubGFzdEVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVwbHkgJiYgcmVwbHkuX19tb3pXZWJFeHRlbnNpb25Qb2x5ZmlsbFJlamVjdF9fKSB7XG4gICAgICAgICAgLy8gQ29udmVydCBiYWNrIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlcnJvciBpbnRvXG4gICAgICAgICAgLy8gYW4gRXJyb3IgaW5zdGFuY2UuXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihyZXBseS5tZXNzYWdlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXBseSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHdyYXBwZWRTZW5kTWVzc2FnZSA9IChuYW1lLCBtZXRhZGF0YSwgYXBpTmFtZXNwYWNlT2JqLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IG1ldGFkYXRhLm1pbkFyZ3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGF0IGxlYXN0ICR7bWV0YWRhdGEubWluQXJnc30gJHtwbHVyYWxpemVBcmd1bWVudHMobWV0YWRhdGEubWluQXJncyl9IGZvciAke25hbWV9KCksIGdvdCAke2FyZ3MubGVuZ3RofWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gbWV0YWRhdGEubWF4QXJncykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYXQgbW9zdCAke21ldGFkYXRhLm1heEFyZ3N9ICR7cGx1cmFsaXplQXJndW1lbnRzKG1ldGFkYXRhLm1heEFyZ3MpfSBmb3IgJHtuYW1lfSgpLCBnb3QgJHthcmdzLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY29uc3Qgd3JhcHBlZENiID0gd3JhcHBlZFNlbmRNZXNzYWdlQ2FsbGJhY2suYmluZChudWxsLCB7XG4gICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXJncy5wdXNoKHdyYXBwZWRDYik7XG4gICAgICAgICAgYXBpTmFtZXNwYWNlT2JqLnNlbmRNZXNzYWdlKC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHN0YXRpY1dyYXBwZXJzID0ge1xuICAgICAgICBkZXZ0b29sczoge1xuICAgICAgICAgIG5ldHdvcms6IHtcbiAgICAgICAgICAgIG9uUmVxdWVzdEZpbmlzaGVkOiB3cmFwRXZlbnQob25SZXF1ZXN0RmluaXNoZWRXcmFwcGVycylcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJ1bnRpbWU6IHtcbiAgICAgICAgICBvbk1lc3NhZ2U6IHdyYXBFdmVudChvbk1lc3NhZ2VXcmFwcGVycyksXG4gICAgICAgICAgb25NZXNzYWdlRXh0ZXJuYWw6IHdyYXBFdmVudChvbk1lc3NhZ2VXcmFwcGVycyksXG4gICAgICAgICAgc2VuZE1lc3NhZ2U6IHdyYXBwZWRTZW5kTWVzc2FnZS5iaW5kKG51bGwsIFwic2VuZE1lc3NhZ2VcIiwge1xuICAgICAgICAgICAgbWluQXJnczogMSxcbiAgICAgICAgICAgIG1heEFyZ3M6IDNcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICB0YWJzOiB7XG4gICAgICAgICAgc2VuZE1lc3NhZ2U6IHdyYXBwZWRTZW5kTWVzc2FnZS5iaW5kKG51bGwsIFwic2VuZE1lc3NhZ2VcIiwge1xuICAgICAgICAgICAgbWluQXJnczogMixcbiAgICAgICAgICAgIG1heEFyZ3M6IDNcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2V0dGluZ01ldGFkYXRhID0ge1xuICAgICAgICBjbGVhcjoge1xuICAgICAgICAgIG1pbkFyZ3M6IDEsXG4gICAgICAgICAgbWF4QXJnczogMVxuICAgICAgICB9LFxuICAgICAgICBnZXQ6IHtcbiAgICAgICAgICBtaW5BcmdzOiAxLFxuICAgICAgICAgIG1heEFyZ3M6IDFcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiB7XG4gICAgICAgICAgbWluQXJnczogMSxcbiAgICAgICAgICBtYXhBcmdzOiAxXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBhcGlNZXRhZGF0YS5wcml2YWN5ID0ge1xuICAgICAgICBuZXR3b3JrOiB7XG4gICAgICAgICAgXCIqXCI6IHNldHRpbmdNZXRhZGF0YVxuICAgICAgICB9LFxuICAgICAgICBzZXJ2aWNlczoge1xuICAgICAgICAgIFwiKlwiOiBzZXR0aW5nTWV0YWRhdGFcbiAgICAgICAgfSxcbiAgICAgICAgd2Vic2l0ZXM6IHtcbiAgICAgICAgICBcIipcIjogc2V0dGluZ01ldGFkYXRhXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gd3JhcE9iamVjdChleHRlbnNpb25BUElzLCBzdGF0aWNXcmFwcGVycywgYXBpTWV0YWRhdGEpO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIGNocm9tZSAhPSBcIm9iamVjdFwiIHx8ICFjaHJvbWUgfHwgIWNocm9tZS5ydW50aW1lIHx8ICFjaHJvbWUucnVudGltZS5pZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBzY3JpcHQgc2hvdWxkIG9ubHkgYmUgbG9hZGVkIGluIGEgYnJvd3NlciBleHRlbnNpb24uXCIpO1xuICAgIH0gLy8gVGhlIGJ1aWxkIHByb2Nlc3MgYWRkcyBhIFVNRCB3cmFwcGVyIGFyb3VuZCB0aGlzIGZpbGUsIHdoaWNoIG1ha2VzIHRoZVxuICAgIC8vIGBtb2R1bGVgIHZhcmlhYmxlIGF2YWlsYWJsZS5cblxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB3cmFwQVBJcyhjaHJvbWUpO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gYnJvd3NlcjtcbiAgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm93c2VyLXBvbHlmaWxsLmpzLm1hcFxuIiwiLy8gUmV0dXJucyBhIHdyYXBwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgd3JhcHBlZCBjYWxsYmFja1xuLy8gVGhlIHdyYXBwZXIgZnVuY3Rpb24gc2hvdWxkIGRvIHNvbWUgc3R1ZmYsIGFuZCByZXR1cm4gYVxuLy8gcHJlc3VtYWJseSBkaWZmZXJlbnQgY2FsbGJhY2sgZnVuY3Rpb24uXG4vLyBUaGlzIG1ha2VzIHN1cmUgdGhhdCBvd24gcHJvcGVydGllcyBhcmUgcmV0YWluZWQsIHNvIHRoYXRcbi8vIGRlY29yYXRpb25zIGFuZCBzdWNoIGFyZSBub3QgbG9zdCBhbG9uZyB0aGUgd2F5LlxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcHlcbmZ1bmN0aW9uIHdyYXBweSAoZm4sIGNiKSB7XG4gIGlmIChmbiAmJiBjYikgcmV0dXJuIHdyYXBweShmbikoY2IpXG5cbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCduZWVkIHdyYXBwZXIgZnVuY3Rpb24nKVxuXG4gIE9iamVjdC5rZXlzKGZuKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgd3JhcHBlcltrXSA9IGZuW2tdXG4gIH0pXG5cbiAgcmV0dXJuIHdyYXBwZXJcblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldXG4gICAgfVxuICAgIHZhciByZXQgPSBmbi5hcHBseSh0aGlzLCBhcmdzKVxuICAgIHZhciBjYiA9IGFyZ3NbYXJncy5sZW5ndGgtMV1cbiAgICBpZiAodHlwZW9mIHJldCA9PT0gJ2Z1bmN0aW9uJyAmJiByZXQgIT09IGNiKSB7XG4gICAgICBPYmplY3Qua2V5cyhjYikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICByZXRba10gPSBjYltrXVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChZYWxsaXN0KSB7XG4gIFlhbGxpc3QucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiogKCkge1xuICAgIGZvciAobGV0IHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyOyB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgICAgeWllbGQgd2Fsa2VyLnZhbHVlXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcbm1vZHVsZS5leHBvcnRzID0gWWFsbGlzdFxuXG5ZYWxsaXN0Lk5vZGUgPSBOb2RlXG5ZYWxsaXN0LmNyZWF0ZSA9IFlhbGxpc3RcblxuZnVuY3Rpb24gWWFsbGlzdCAobGlzdCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIFlhbGxpc3QpKSB7XG4gICAgc2VsZiA9IG5ldyBZYWxsaXN0KClcbiAgfVxuXG4gIHNlbGYudGFpbCA9IG51bGxcbiAgc2VsZi5oZWFkID0gbnVsbFxuICBzZWxmLmxlbmd0aCA9IDBcblxuICBpZiAobGlzdCAmJiB0eXBlb2YgbGlzdC5mb3JFYWNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBzZWxmLnB1c2goaXRlbSlcbiAgICB9KVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzZWxmLnB1c2goYXJndW1lbnRzW2ldKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZS5saXN0ICE9PSB0aGlzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmluZyBub2RlIHdoaWNoIGRvZXMgbm90IGJlbG9uZyB0byB0aGlzIGxpc3QnKVxuICB9XG5cbiAgdmFyIG5leHQgPSBub2RlLm5leHRcbiAgdmFyIHByZXYgPSBub2RlLnByZXZcblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHByZXZcbiAgfVxuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gbmV4dFxuICB9XG5cbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5leHRcbiAgfVxuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gcHJldlxuICB9XG5cbiAgbm9kZS5saXN0Lmxlbmd0aC0tXG4gIG5vZGUubmV4dCA9IG51bGxcbiAgbm9kZS5wcmV2ID0gbnVsbFxuICBub2RlLmxpc3QgPSBudWxsXG5cbiAgcmV0dXJuIG5leHRcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciBoZWFkID0gdGhpcy5oZWFkXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5uZXh0ID0gaGVhZFxuICBpZiAoaGVhZCkge1xuICAgIGhlYWQucHJldiA9IG5vZGVcbiAgfVxuXG4gIHRoaXMuaGVhZCA9IG5vZGVcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChub2RlLmxpc3QpIHtcbiAgICBub2RlLmxpc3QucmVtb3ZlTm9kZShub2RlKVxuICB9XG5cbiAgdmFyIHRhaWwgPSB0aGlzLnRhaWxcbiAgbm9kZS5saXN0ID0gdGhpc1xuICBub2RlLnByZXYgPSB0YWlsXG4gIGlmICh0YWlsKSB7XG4gICAgdGFpbC5uZXh0ID0gbm9kZVxuICB9XG5cbiAgdGhpcy50YWlsID0gbm9kZVxuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5vZGVcbiAgfVxuICB0aGlzLmxlbmd0aCsrXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHB1c2godGhpcywgYXJndW1lbnRzW2ldKVxuICB9XG4gIHJldHVybiB0aGlzLmxlbmd0aFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB1bnNoaWZ0KHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudGFpbCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLnRhaWwudmFsdWVcbiAgdGhpcy50YWlsID0gdGhpcy50YWlsLnByZXZcbiAgaWYgKHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbC5uZXh0ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMuaGVhZCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgdmFyIHJlcyA9IHRoaXMuaGVhZC52YWx1ZVxuICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dFxuICBpZiAodGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkLnByZXYgPSBudWxsXG4gIH0gZWxzZSB7XG4gICAgdGhpcy50YWlsID0gbnVsbFxuICB9XG4gIHRoaXMubGVuZ3RoLS1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy5oZWFkLCBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMudGFpbCwgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLmdldFJldmVyc2UgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIHZhciByZXMgPSBuZXcgWWFsbGlzdCgpXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHJlcy5wdXNoKGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgdGhpcykpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWwpIHtcbiAgdmFyIGFjY1xuICB2YXIgd2Fsa2VyID0gdGhpcy5oZWFkXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIGFjYyA9IGluaXRpYWxcbiAgfSBlbHNlIGlmICh0aGlzLmhlYWQpIHtcbiAgICB3YWxrZXIgPSB0aGlzLmhlYWQubmV4dFxuICAgIGFjYyA9IHRoaXMuaGVhZC52YWx1ZVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBsaXN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2VSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMudGFpbFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy50YWlsKSB7XG4gICAgd2Fsa2VyID0gdGhpcy50YWlsLnByZXZcbiAgICBhY2MgPSB0aGlzLnRhaWwudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFycltpXSA9IHdhbGtlci52YWx1ZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIGFyclxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5UmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgZnJvbTsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICBmb3IgKDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCB0bzsgaSsrLCB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICB0byA9IHRvIHx8IHRoaXMubGVuZ3RoXG4gIGlmICh0byA8IDApIHtcbiAgICB0byArPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZyb20gPSBmcm9tIHx8IDBcbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSArPSB0aGlzLmxlbmd0aFxuICB9XG4gIHZhciByZXQgPSBuZXcgWWFsbGlzdCgpXG4gIGlmICh0byA8IGZyb20gfHwgdG8gPCAwKSB7XG4gICAgcmV0dXJuIHJldFxuICB9XG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gPSAwXG4gIH1cbiAgaWYgKHRvID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0byA9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gdG87IGktLSkge1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gZnJvbTsgaS0tLCB3YWxrZXIgPSB3YWxrZXIucHJldikge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZGVsZXRlQ291bnQsIC4uLm5vZGVzKSB7XG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aCAtIDFcbiAgfVxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aCArIHN0YXJ0O1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBzdGFydDsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuXG4gIHZhciByZXQgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgd2Fsa2VyICYmIGkgPCBkZWxldGVDb3VudDsgaSsrKSB7XG4gICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKVxuICAgIHdhbGtlciA9IHRoaXMucmVtb3ZlTm9kZSh3YWxrZXIpXG4gIH1cbiAgaWYgKHdhbGtlciA9PT0gbnVsbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbFxuICB9XG5cbiAgaWYgKHdhbGtlciAhPT0gdGhpcy5oZWFkICYmIHdhbGtlciAhPT0gdGhpcy50YWlsKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB3YWxrZXIgPSBpbnNlcnQodGhpcywgd2Fsa2VyLCBub2Rlc1tpXSlcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICB2YXIgdGFpbCA9IHRoaXMudGFpbFxuICBmb3IgKHZhciB3YWxrZXIgPSBoZWFkOyB3YWxrZXIgIT09IG51bGw7IHdhbGtlciA9IHdhbGtlci5wcmV2KSB7XG4gICAgdmFyIHAgPSB3YWxrZXIucHJldlxuICAgIHdhbGtlci5wcmV2ID0gd2Fsa2VyLm5leHRcbiAgICB3YWxrZXIubmV4dCA9IHBcbiAgfVxuICB0aGlzLmhlYWQgPSB0YWlsXG4gIHRoaXMudGFpbCA9IGhlYWRcbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gaW5zZXJ0IChzZWxmLCBub2RlLCB2YWx1ZSkge1xuICB2YXIgaW5zZXJ0ZWQgPSBub2RlID09PSBzZWxmLmhlYWQgP1xuICAgIG5ldyBOb2RlKHZhbHVlLCBudWxsLCBub2RlLCBzZWxmKSA6XG4gICAgbmV3IE5vZGUodmFsdWUsIG5vZGUsIG5vZGUubmV4dCwgc2VsZilcblxuICBpZiAoaW5zZXJ0ZWQubmV4dCA9PT0gbnVsbCkge1xuICAgIHNlbGYudGFpbCA9IGluc2VydGVkXG4gIH1cbiAgaWYgKGluc2VydGVkLnByZXYgPT09IG51bGwpIHtcbiAgICBzZWxmLmhlYWQgPSBpbnNlcnRlZFxuICB9XG5cbiAgc2VsZi5sZW5ndGgrK1xuXG4gIHJldHVybiBpbnNlcnRlZFxufVxuXG5mdW5jdGlvbiBwdXNoIChzZWxmLCBpdGVtKSB7XG4gIHNlbGYudGFpbCA9IG5ldyBOb2RlKGl0ZW0sIHNlbGYudGFpbCwgbnVsbCwgc2VsZilcbiAgaWYgKCFzZWxmLmhlYWQpIHtcbiAgICBzZWxmLmhlYWQgPSBzZWxmLnRhaWxcbiAgfVxuICBzZWxmLmxlbmd0aCsrXG59XG5cbmZ1bmN0aW9uIHVuc2hpZnQgKHNlbGYsIGl0ZW0pIHtcbiAgc2VsZi5oZWFkID0gbmV3IE5vZGUoaXRlbSwgbnVsbCwgc2VsZi5oZWFkLCBzZWxmKVxuICBpZiAoIXNlbGYudGFpbCkge1xuICAgIHNlbGYudGFpbCA9IHNlbGYuaGVhZFxuICB9XG4gIHNlbGYubGVuZ3RoKytcbn1cblxuZnVuY3Rpb24gTm9kZSAodmFsdWUsIHByZXYsIG5leHQsIGxpc3QpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5vZGUpKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KVxuICB9XG5cbiAgdGhpcy5saXN0ID0gbGlzdFxuICB0aGlzLnZhbHVlID0gdmFsdWVcblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IHRoaXNcbiAgICB0aGlzLnByZXYgPSBwcmV2XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmV2ID0gbnVsbFxuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSB0aGlzXG4gICAgdGhpcy5uZXh0ID0gbmV4dFxuICB9IGVsc2Uge1xuICAgIHRoaXMubmV4dCA9IG51bGxcbiAgfVxufVxuXG50cnkge1xuICAvLyBhZGQgaWYgc3VwcG9ydCBmb3IgU3ltYm9sLml0ZXJhdG9yIGlzIHByZXNlbnRcbiAgcmVxdWlyZSgnLi9pdGVyYXRvci5qcycpKFlhbGxpc3QpXG59IGNhdGNoIChlcikge31cbiIsImV4cG9ydCBlbnVtIEFsZXJ0VHlwZXMge1xuICB1bmNvbm5lY3RlZEFjY291bnQgPSAndW5jb25uZWN0ZWRBY2NvdW50JyxcbiAgd2ViM1NoaW1Vc2FnZSA9ICd3ZWIzU2hpbVVzYWdlJyxcbiAgaW52YWxpZEN1c3RvbU5ldHdvcmsgPSAnaW52YWxpZEN1c3RvbU5ldHdvcmsnLFxufVxuXG4vKipcbiAqIEFsZXJ0cyB0aGF0IGNhbiBiZSBlbmFibGVkIG9yIGRpc2FibGVkIGJ5IHRoZSB1c2VyLlxuICovXG5leHBvcnQgY29uc3QgVE9HR0xFQUJMRV9BTEVSVF9UWVBFUyA9IFtcbiAgQWxlcnRUeXBlcy51bmNvbm5lY3RlZEFjY291bnQsXG4gIEFsZXJ0VHlwZXMud2ViM1NoaW1Vc2FnZSxcbl07XG5cbmV4cG9ydCBlbnVtIFdlYjNTaGltVXNhZ2VBbGVydFN0YXRlcyB7XG4gIHJlY29yZGVkID0gMSxcbiAgZGlzbWlzc2VkID0gMixcbn1cbiIsImltcG9ydCB7IFJlc3RyaWN0ZWRNZXRob2RzIH0gZnJvbSAnLi9wZXJtaXNzaW9ucyc7XG5cbi8qKlxuICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB0eXBlIG9mIGVudmlyb25tZW50IHRoZSBhcHBsaWNhdGlvbiBpcyBjdXJyZW50bHkgcnVubmluZyBpblxuICogcG9wdXAgLSBXaGVuIHRoZSB1c2VyIGNsaWNrJ3MgdGhlIGljb24gaW4gdGhlaXIgYnJvd3NlcidzIGV4dGVuc2lvbiBiYXI7IHRoZSBkZWZhdWx0IHZpZXdcbiAqIG5vdGlmaWNhdGlvbiAtIFdoZW4gdGhlIGV4dGVuc2lvbiBvcGVucyBkdWUgdG8gaW50ZXJhY3Rpb24gd2l0aCBhIFdlYjMgZW5hYmxlZCB3ZWJzaXRlXG4gKiBmdWxsc2NyZWVuIC0gV2hlbiB0aGUgdXNlciBjbGlja3MgJ2V4cGFuZCB2aWV3JyB0byBvcGVuIHRoZSBleHRlbnNpb24gaW4gYSBuZXcgdGFiXG4gKiBiYWNrZ3JvdW5kIC0gVGhlIGJhY2tncm91bmQgcHJvY2VzcyB0aGF0IHBvd2VycyB0aGUgZXh0ZW5zaW9uXG4gKi9cbmV4cG9ydCB0eXBlIEVudmlyb25tZW50VHlwZSA9XG4gIHwgJ3BvcHVwJ1xuICB8ICdub3RpZmljYXRpb24nXG4gIHwgJ2Z1bGxzY3JlZW4nXG4gIHwgJ2JhY2tncm91bmQnO1xuZXhwb3J0IGNvbnN0IEVOVklST05NRU5UX1RZUEVfUE9QVVAgPSAncG9wdXAnO1xuZXhwb3J0IGNvbnN0IEVOVklST05NRU5UX1RZUEVfTk9USUZJQ0FUSU9OID0gJ25vdGlmaWNhdGlvbic7XG5leHBvcnQgY29uc3QgRU5WSVJPTk1FTlRfVFlQRV9GVUxMU0NSRUVOID0gJ2Z1bGxzY3JlZW4nO1xuZXhwb3J0IGNvbnN0IEVOVklST05NRU5UX1RZUEVfQkFDS0dST1VORCA9ICdiYWNrZ3JvdW5kJztcblxuZXhwb3J0IGNvbnN0IFBMQVRGT1JNX0JSQVZFID0gJ0JyYXZlJztcbmV4cG9ydCBjb25zdCBQTEFURk9STV9DSFJPTUUgPSAnQ2hyb21lJztcbmV4cG9ydCBjb25zdCBQTEFURk9STV9FREdFID0gJ0VkZ2UnO1xuZXhwb3J0IGNvbnN0IFBMQVRGT1JNX0ZJUkVGT1ggPSAnRmlyZWZveCc7XG5leHBvcnQgY29uc3QgUExBVEZPUk1fT1BFUkEgPSAnT3BlcmEnO1xuXG5leHBvcnQgY29uc3QgTUVTU0FHRV9UWVBFID0ge1xuICBBRERfRVRIRVJFVU1fQ0hBSU46ICd3YWxsZXRfYWRkRXRoZXJldW1DaGFpbicsXG4gIEVUSF9BQ0NPVU5UUzogUmVzdHJpY3RlZE1ldGhvZHMuZXRoX2FjY291bnRzLFxuICBFVEhfREVDUllQVDogJ2V0aF9kZWNyeXB0JyxcbiAgRVRIX0dFVF9FTkNSWVBUSU9OX1BVQkxJQ19LRVk6ICdldGhfZ2V0RW5jcnlwdGlvblB1YmxpY0tleScsXG4gIEVUSF9SRVFVRVNUX0FDQ09VTlRTOiAnZXRoX3JlcXVlc3RBY2NvdW50cycsXG4gIEVUSF9TSUdOOiAnZXRoX3NpZ24nLFxuICBFVEhfU0lHTl9UWVBFRF9EQVRBOiAnZXRoX3NpZ25UeXBlZERhdGEnLFxuICBFVEhfU0lHTl9UWVBFRF9EQVRBX1YzOiAnZXRoX3NpZ25UeXBlZERhdGFfdjMnLFxuICBFVEhfU0lHTl9UWVBFRF9EQVRBX1Y0OiAnZXRoX3NpZ25UeXBlZERhdGFfdjQnLFxuICBHRVRfUFJPVklERVJfU1RBVEU6ICdtZXRhbWFza19nZXRQcm92aWRlclN0YXRlJyxcbiAgTE9HX1dFQjNfU0hJTV9VU0FHRTogJ21ldGFtYXNrX2xvZ1dlYjNTaGltVXNhZ2UnLFxuICBQRVJTT05BTF9TSUdOOiAncGVyc29uYWxfc2lnbicsXG4gIFNFTkRfTUVUQURBVEE6ICdtZXRhbWFza19zZW5kRG9tYWluTWV0YWRhdGEnLFxuICBTV0lUQ0hfRVRIRVJFVU1fQ0hBSU46ICd3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpbicsXG4gIFRSQU5TQUNUSU9OOiAndHJhbnNhY3Rpb24nLFxuICBXQUxMRVRfUkVRVUVTVF9QRVJNSVNTSU9OUzogJ3dhbGxldF9yZXF1ZXN0UGVybWlzc2lvbnMnLFxuICBXQVRDSF9BU1NFVDogJ3dhbGxldF93YXRjaEFzc2V0JyxcbiAgV0FUQ0hfQVNTRVRfTEVHQUNZOiAnbWV0YW1hc2tfd2F0Y2hBc3NldCcsXG59IGFzIGNvbnN0O1xuXG5cbi8qKlxuICogQ3VzdG9tIG1lc3NhZ2VzIHRvIHNlbmQgYW5kIGJlIHJlY2VpdmVkIGJ5IHRoZSBleHRlbnNpb25cbiAqL1xuZXhwb3J0IGNvbnN0IEVYVEVOU0lPTl9NRVNTQUdFUyA9IHtcbiAgQ09OTkVDVElPTl9SRUFEWTogJ0NPTk5FQ1RJT05fUkVBRFknLFxuICBSRUFEWTogJ01FVEFNQVNLX0VYVEVOU0lPTl9SRUFEWScsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgUE9MTElOR19UT0tFTl9FTlZJUk9OTUVOVF9UWVBFUyA9IHtcbiAgW0VOVklST05NRU5UX1RZUEVfUE9QVVBdOiAncG9wdXBHYXNQb2xsVG9rZW5zJyxcbiAgW0VOVklST05NRU5UX1RZUEVfTk9USUZJQ0FUSU9OXTogJ25vdGlmaWNhdGlvbkdhc1BvbGxUb2tlbnMnLFxuICBbRU5WSVJPTk1FTlRfVFlQRV9GVUxMU0NSRUVOXTogJ2Z1bGxTY3JlZW5HYXNQb2xsVG9rZW5zJyxcbiAgW0VOVklST05NRU5UX1RZUEVfQkFDS0dST1VORF06ICdub25lJyxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBPUklHSU5fTUVUQU1BU0sgPSAnbWV0YW1hc2snO1xuXG5leHBvcnQgY29uc3QgTUVUQU1BU0tfQkVUQV9DSFJPTUVfSUQgPSAncGJia2FtZmdtYWVkY2NuZmttamNvZmNlY2poZmdsZG4nO1xuZXhwb3J0IGNvbnN0IE1FVEFNQVNLX1BST0RfQ0hST01FX0lEID0gJ25rYmloZmJlb2dhZWFvZWhsZWZua29kYmVmZ3Bna25uJztcbmV4cG9ydCBjb25zdCBNRVRBTUFTS19GTEFTS19DSFJPTUVfSUQgPSAnbGpmb2VpbmpwYWVkamZlY2JtZ2dqZ29kYmdrbWpramsnO1xuXG5leHBvcnQgY29uc3QgTUVUQU1BU0tfTU1JX0JFVEFfQ0hST01FX0lEID0gJ2ttYmhiY2JhZG9oaGhnZGdpaGVqY2ljYmdjZWhvYWVnJztcbmV4cG9ydCBjb25zdCBNRVRBTUFTS19NTUlfUFJPRF9DSFJPTUVfSUQgPSAnaWtraWhqYW1kaGZpb2pwZGJuZmxscGppZ3BuZWlwYmMnO1xuXG5leHBvcnQgY29uc3QgQ0hST01FX0JVSUxEX0lEUyA9IFtcbiAgTUVUQU1BU0tfQkVUQV9DSFJPTUVfSUQsXG4gIE1FVEFNQVNLX1BST0RfQ0hST01FX0lELFxuICBNRVRBTUFTS19GTEFTS19DSFJPTUVfSUQsXG4gIE1FVEFNQVNLX01NSV9CRVRBX0NIUk9NRV9JRCxcbiAgTUVUQU1BU0tfTU1JX1BST0RfQ0hST01FX0lELFxuXSBhcyBjb25zdDtcblxuY29uc3QgTUVUQU1BU0tfQkVUQV9GSVJFRk9YX0lEID0gJ3dlYmV4dGVuc2lvbi1iZXRhQG1ldGFtYXNrLmlvJztcbmNvbnN0IE1FVEFNQVNLX1BST0RfRklSRUZPWF9JRCA9ICd3ZWJleHRlbnNpb25AbWV0YW1hc2suaW8nO1xuY29uc3QgTUVUQU1BU0tfRkxBU0tfRklSRUZPWF9JRCA9ICd3ZWJleHRlbnNpb24tZmxhc2tAbWV0YW1hc2suaW8nO1xuXG5leHBvcnQgY29uc3QgRklSRUZPWF9CVUlMRF9JRFMgPSBbXG4gIE1FVEFNQVNLX0JFVEFfRklSRUZPWF9JRCxcbiAgTUVUQU1BU0tfUFJPRF9GSVJFRk9YX0lELFxuICBNRVRBTUFTS19GTEFTS19GSVJFRk9YX0lELFxuXSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IFVOS05PV05fVElDS0VSX1NZTUJPTCA9ICdVTktOT1dOJztcbiIsImV4cG9ydCBlbnVtIEV0aGVyRGVub21pbmF0aW9uIHtcbiAgRVRIID0gJ0VUSCcsXG4gIEdXRUkgPSAnR1dFSScsXG4gIFdFSSA9ICdXRUknLFxufVxuIiwiaW1wb3J0IHsgYWRkSGV4UHJlZml4IH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcblxuY29uc3QgT05FX0hVTkRSRURfVEhPVVNBTkQgPSAxMDAwMDA7XG5jb25zdCBNSU5fR0FTX0xJTUlUX0RFQyA9ICcyMTAwMCc7XG5cbmV4cG9ydCBjb25zdCBNSU5fR0FTX0xJTUlUX0hFWCA9IHBhcnNlSW50KE1JTl9HQVNfTElNSVRfREVDLCAxMCkudG9TdHJpbmcoMTYpO1xuXG5leHBvcnQgY29uc3QgR0FTX0xJTUlUUyA9IHtcbiAgLy8gbWF4aW11bSBnYXNMaW1pdCBvZiBhIHNpbXBsZSBzZW5kXG4gIFNJTVBMRTogYWRkSGV4UHJlZml4KE1JTl9HQVNfTElNSVRfSEVYKSxcbiAgLy8gYSBiYXNlIGVzdGltYXRlIGZvciB0b2tlbiB0cmFuc2ZlcnMuXG4gIEJBU0VfVE9LRU5fRVNUSU1BVEU6IGFkZEhleFByZWZpeChPTkVfSFVORFJFRF9USE9VU0FORC50b1N0cmluZygxNikpLFxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBHYXNFc3RpbWF0ZVR5cGVzXG4gKiBAcHJvcGVydHkgeydmZWUtbWFya2V0J30gRkVFX01BUktFVCAtIEEgZ2FzIGVzdGltYXRlIGZvciBhIGZlZSBtYXJrZXQgdHJhbnNhY3Rpb24gZ2VuZXJhdGVkIGJ5IG91ciBnYXMgZXN0aW1hdGlvbiBBUEkuXG4gKiBAcHJvcGVydHkgeydsZWdhY3knfSBMRUdBQ1kgLSBBIGdhcyBlc3RpbWF0ZSBmb3IgYSBsZWdhY3kgVHJhbnNhY3Rpb24gZ2VuZXJhdGVkIGJ5IG91ciBnYXMgZXN0aW1hdGlvbiBBUEkuXG4gKiBAcHJvcGVydHkgeydldGhfZ2FzUHJpY2UnfSBFVEhfR0FTX1BSSUNFIC0gQSBnYXMgZXN0aW1hdGUgcHJvdmlkZWQgYnkgdGhlIEV0aGVyZXVtIG5vZGUgdmlhIGV0aF9nYXNQcmljZS5cbiAqIEBwcm9wZXJ0eSB7J25vbmUnfSBOT05FIC0gTm8gZ2FzIGVzdGltYXRlIGF2YWlsYWJsZS5cbiAqL1xuXG4vKipcbiAqIFRoZXNlIGFyZSBhbHJlYWR5IGRlY2xhcmVkIGluIEBtZXRhbWFzay9jb250cm9sbGVycyBidXQgaW1wb3J0aW5nIHRoZW0gZnJvbVxuICogdGhhdCBtb2R1bGUgYW5kIHJlLWV4cG9ydGluZyBjYXVzZXMgdGhlIFVJIGJ1bmRsZSBzaXplIHRvIGV4cGFuZCBiZXlvbmQgNE1CXG4gKlxuICogKFRPRE86IFRoaXMgY29tbWVudCB3YXMgYWRkZWQgYmVmb3JlIEBtZXRhbWFzay9jb250cm9sbGVycyB3YXMgc3BsaXQgdXAg4oCUXG4gKiByZXZpc2l0IG5vdyB0aGF0IEBtZXRhbWFzay9nYXMtZmVlLWNvbnRyb2xsZXIgaXMgYXZhaWxhYmxlKVxuICpcbiAqIEB0eXBlIHtHYXNFc3RpbWF0ZVR5cGVzfVxuICovXG5leHBvcnQgZW51bSBHYXNFc3RpbWF0ZVR5cGVzIHtcbiAgZmVlTWFya2V0ID0gJ2ZlZS1tYXJrZXQnLFxuICBsZWdhY3kgPSAnbGVnYWN5JyxcbiAgZXRoR2FzUHJpY2UgPSAnZXRoX2dhc1ByaWNlJyxcbiAgbm9uZSA9ICdub25lJyxcbn1cblxuLyoqXG4gKiBUaGVzZSByZXByZXNlbnQgZ2FzIHJlY29tbWVuZGF0aW9uIGxldmVscyBwcmVzZW50ZWQgaW4gdGhlIFVJXG4gKi9cbmV4cG9ydCBlbnVtIEdhc1JlY29tbWVuZGF0aW9ucyB7XG4gIGxvdyA9ICdsb3cnLFxuICBtZWRpdW0gPSAnbWVkaXVtJyxcbiAgaGlnaCA9ICdoaWdoJyxcbn1cblxuLyoqXG4gKiBUaGVzZSByZXByZXNlbnQgdHlwZXMgb2YgZ2FzIGVzdGltYXRpb25cbiAqL1xuZXhwb3J0IGVudW0gUHJpb3JpdHlMZXZlbHMge1xuICB0ZW5QZXJjZW50SW5jcmVhc2VkID0gJ3RlblBlcmNlbnRJbmNyZWFzZWQnLFxuICBsb3cgPSAnbG93JyxcbiAgbWVkaXVtID0gJ21lZGl1bScsXG4gIGhpZ2ggPSAnaGlnaCcsXG4gIGN1c3RvbSA9ICdjdXN0b20nLFxuICBkQXBwU3VnZ2VzdGVkID0gJ2RhcHBTdWdnZXN0ZWQnLFxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHVzZXIgY3VzdG9taXppbmcgdGhlaXIgZ2FzIHByZWZlcmVuY2VcbiAqL1xuZXhwb3J0IGNvbnN0IENVU1RPTV9HQVNfRVNUSU1BVEUgPSAnY3VzdG9tJztcblxuLyoqXG4gKiBUaGVzZSByZXByZXNlbnQgdGhlIGRpZmZlcmVudCBlZGl0IG1vZGVzIHByZXNlbnRlZCBpbiB0aGUgVUlcbiAqL1xuZXhwb3J0IGVudW0gRWRpdEdhc01vZGVzIHtcbiAgc3BlZWRVcCA9ICdzcGVlZC11cCcsXG4gIGNhbmNlbCA9ICdjYW5jZWwnLFxuICBtb2RpZnlJblBsYWNlID0gJ21vZGlmeS1pbi1wbGFjZScsXG4gIHN3YXBzID0gJ3N3YXBzJyxcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGxldmVscyBmb3IgYG5ldHdvcmtDb25nZXN0aW9uYCAoY2FsY3VsYXRlZCBhbG9uZyB3aXRoIGdhcyBmZWVcbiAqIGVzdGltYXRlczsgcmVwcmVzZW50cyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEpIHRoYXQgd2UgdXNlIHRvIHJlbmRlciB0aGVcbiAqIG5ldHdvcmsgc3RhdHVzIHNsaWRlciBvbiB0aGUgc2VuZCB0cmFuc2FjdGlvbiBzY3JlZW4gYW5kIGluZm9ybSB1c2VycyB3aGVuXG4gKiBnYXMgZmVlcyBhcmUgaGlnaFxuICovXG5leHBvcnQgZW51bSBOZXR3b3JrQ29uZ2VzdGlvblRocmVzaG9sZHMge1xuICBub3RCdXN5ID0gMCxcbiAgc3RhYmxlID0gMC4zMyxcbiAgYnVzeSA9IDAuNjYsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHhHYXNGZWVzIHtcbiAgLyoqIE1heG1pbXVtIG51bWJlciBvZiB1bml0cyBvZiBnYXMgdG8gdXNlIGZvciB0aGlzIHRyYW5zYWN0aW9uLiAqL1xuICBnYXNMaW1pdDogc3RyaW5nO1xuICAvKiogUHJpY2UgcGVyIGdhcyBmb3IgbGVnYWN5IHR4cyAqL1xuICBnYXNQcmljZTogc3RyaW5nO1xuICAvKipcbiAgICogTWF4aW11bSBhbW91bnQgcGVyIGdhcyB0byBwYXkgZm9yIHRoZSB0cmFuc2FjdGlvbiwgaW5jbHVkaW5nIHRoZSBwcmlvcml0eVxuICAgKiBmZWUuXG4gICAqL1xuICBtYXhGZWVQZXJHYXM6IHN0cmluZztcbiAgLyoqIE1heGltdW0gYW1vdW50IHBlciBnYXMgdG8gZ2l2ZSB0byB2YWxpZGF0b3IgYXMgaW5jZW50aXZlLiAqL1xuICBtYXhQcmlvcml0eUZlZVBlckdhczogc3RyaW5nO1xuICAvKiogV2hpY2ggZXN0aW1hdGUgbGV2ZWwgd2FzIHVzZWQgKi9cbiAgZXN0aW1hdGVVc2VkOiBzdHJpbmc7XG4gIC8qKiBXaGljaCBlc3RpbWF0ZSBsZXZlbCB0aGF0IHRoZSBBUEkgc3VnZ2VzdGVkLiAqL1xuICBlc3RpbWF0ZVN1Z2dlc3RlZDogc3RyaW5nO1xuICAvKiogVGhlIGRlZmF1bHQgZXN0aW1hdGUgZm9yIGdhcy4gKi9cbiAgZGVmYXVsdEdhc0VzdGltYXRlczogc3RyaW5nO1xuICAvKiogc2FtZSBhcyBnYXNMaW1pdD8gKi9cbiAgZ2FzOiBzdHJpbmc7XG4gIC8qKiBPcmlnaW5hbCBlc3RpbWF0ZSBmb3IgZ2FzLiAqL1xuICBvcmlnaW5hbEdhc0VzdGltYXRlOiBzdHJpbmc7XG4gIC8qKiBUaGUgZ2FzIGxpbWl0IHN1cHBsaWVkIGJ5IHVzZXIuICovXG4gIHVzZXJFZGl0ZWRHYXNMaW1pdDogc3RyaW5nO1xuICAvKiogRXN0aW1hdGUgbGV2ZWwgdXNlciBzZWxlY3RlZC4gKi9cbiAgdXNlckZlZUxldmVsOiBzdHJpbmc7XG59XG4iLCIvKipcbiAqIEhhcmR3YXJlIHdhbGxldHMgc3VwcG9ydGVkIGJ5IE1ldGFNYXNrLlxuICovXG5leHBvcnQgZW51bSBIYXJkd2FyZUtleXJpbmdUeXBlIHtcbiAgbGVkZ2VyID0gJ0xlZGdlciBIYXJkd2FyZScsXG4gIHRyZXpvciA9ICdUcmV6b3IgSGFyZHdhcmUnLFxuICBsYXR0aWNlID0gJ0xhdHRpY2UgSGFyZHdhcmUnLFxuICBxciA9ICdRUiBIYXJkd2FyZSBXYWxsZXQgRGV2aWNlJyxcbn1cblxuZXhwb3J0IGVudW0gSGFyZHdhcmVLZXlyaW5nTmFtZXMge1xuICBsZWRnZXIgPSAnTGVkZ2VyJyxcbiAgdHJlem9yID0gJ1RyZXpvcicsXG4gIGxhdHRpY2UgPSAnTGF0dGljZTEnLFxuICBxciA9ICdRUicsXG59XG5cbmV4cG9ydCBlbnVtIEhhcmR3YXJlRGV2aWNlTmFtZXMge1xuICBsZWRnZXIgPSAnbGVkZ2VyJyxcbiAgdHJlem9yID0gJ3RyZXpvcicsXG4gIGxhdHRpY2UgPSAnbGF0dGljZScsXG4gIHFyID0gJ1FSIEhhcmR3YXJlJyxcbn1cblxuZXhwb3J0IGVudW0gSGFyZHdhcmVUcmFuc3BvcnRTdGF0ZXMge1xuICBub25lID0gJ05PTkUnLFxuICB2ZXJpZmllZCA9ICdWRVJJRklFRCcsXG4gIGRldmljZU9wZW5GYWlsdXJlID0gJ0RFVklDRV9PUEVOX0ZBSUxVUkUnLFxuICB1bmtub3duRmFpbHVyZSA9ICdVTktOT1dOX0ZBSUxVUkUnLFxufVxuXG5leHBvcnQgZW51bSBIYXJkd2FyZUFmZmlsaWF0ZUxpbmtzIHtcbiAgbGVkZ2VyID0gJ2h0dHBzOi8vc2hvcC5sZWRnZXIuY29tLz9yPTE3YzQ5OTFhMDNmYScsXG4gIGdyaWRwbHVzID0gJ2h0dHBzOi8vZ3JpZHBsdXMuaW8vP2FmbWM9N3AnLFxuICB0cmV6b3IgPSAnaHR0cHM6Ly9zaG9wLnRyZXpvci5pby9wcm9kdWN0L3RyZXpvci1vbmUtYmxhY2s/b2ZmZXJfaWQ9MzUmYWZmX2lkPTExMDA5JyxcbiAga2V5c3RvbmUgPSAnaHR0cHM6Ly9rZXlzdC5vbmUvbWV0YW1hc2s/cmZzbj02MDg4MjU3LjY1NmIzZTkmdXRtX3NvdXJjZT1yZWZlcnNpb24mdXRtX21lZGl1bT1hZmZpbGlhdGUmdXRtX2NhbXBhaWduPTYwODgyNTcuNjU2YjNlOScsXG4gIGFpcmdhcCA9ICdodHRwczovL2FpcmdhcC5pdC8nLFxuICBjb29sd2FsbGV0ID0gJ2h0dHBzOi8vd3d3LmNvb2x3YWxsZXQuaW8vJyxcbiAgZGNlbnQgPSAnaHR0cHM6Ly9kY2VudHdhbGxldC5jb20vJyxcbn1cblxuZXhwb3J0IGVudW0gSGFyZHdhcmVBZmZpbGlhdGVUdXRvcmlhbExpbmtzIHtcbiAgbGVkZ2VyID0gJ2h0dHBzOi8vc3VwcG9ydC5sZWRnZXIuY29tL2hjL2VuLXVzL2FydGljbGVzLzQ0MDQzNjY4NjQ2NTctU2V0LXVwLWFuZC11c2UtTWV0YU1hc2stdG8tYWNjZXNzLXlvdXItTGVkZ2VyLUV0aGVyZXVtLUVUSC1hY2NvdW50P2RvY3M9dHJ1ZScsXG4gIGdyaWRwbHVzID0gJ2h0dHBzOi8vZG9jcy5ncmlkcGx1cy5pby9zZXR1cC9tZXRhbWFzaycsXG4gIHRyZXpvciA9ICdodHRwczovL3dpa2kudHJlem9yLmlvL0FwcHM6TWV0YU1hc2snLFxuICBrZXlzdG9uZSA9ICdodHRwczovL3N1cHBvcnQua2V5c3Qub25lLzNyZC1wYXJ0eS13YWxsZXRzL2V0aC1hbmQtd2ViMy13YWxsZXRzLWtleXN0b25lL2JpbmQtbWV0YW1hc2std2l0aC1rZXlzdG9uZScsXG4gIGFpcmdhcCA9ICdodHRwczovL3N1cHBvcnQuYWlyZ2FwLml0L2d1aWRlcy9tZXRhbWFzay8nLFxuICBjb29sd2FsbGV0ID0gJ2h0dHBzOi8vd3d3LmNvb2x3YWxsZXQuaW8vbWV0YW1hc2stc3RlcC1ieS1zdGVwLWd1aWRlcy8nLFxuICBkY2VudCA9ICdodHRwczovL21lZGl1bS5jb20vZGNlbnR3YWxsZXQvZGNlbnQtd2FsbGV0LW5vdy1zdXBwb3J0cy1xci1iYXNlZC1wcm90b2NvbC10by1saW5rLXdpdGgtbWV0YW1hc2stNTc1NTVmMDI2MDNmJyxcbn1cblxuLyoqXG4gKiBVc2VkIGZvciBzZXR0aW5nIHRoZSB1c2VycyBwcmVmZXJlbmNlIGZvciBsZWRnZXIgdHJhbnNwb3J0IHR5cGVcbiAqL1xuZXhwb3J0IGVudW0gTGVkZ2VyVHJhbnNwb3J0VHlwZXMge1xuICBsaXZlID0gJ2xlZGdlckxpdmUnLFxuICB3ZWJoaWQgPSAnd2ViaGlkJyxcbiAgdTJmID0gJ3UyZicsXG59XG5cbmV4cG9ydCBlbnVtIFdlYkhJRENvbm5lY3RlZFN0YXR1c2VzIHtcbiAgY29ubmVjdGVkID0gJ2Nvbm5lY3RlZCcsXG4gIG5vdENvbm5lY3RlZCA9ICdub3RDb25uZWN0ZWQnLFxuICB1bmtub3duID0gJ3Vua25vd24nLFxufVxuXG5leHBvcnQgY29uc3QgTEVER0VSX1VTQl9WRU5ET1JfSUQgPSAnMHgyYzk3JztcbiIsImltcG9ydCB7IEhhcmR3YXJlS2V5cmluZ1R5cGUgfSBmcm9tICcuL2hhcmR3YXJlLXdhbGxldHMnO1xuXG4vKipcbiAqIFRoZXNlIGFyZSB0aGUga2V5cmluZ3MgdGhhdCBhcmUgbWFuYWdlZCBlbnRpcmVseSBieSBNZXRhTWFzay5cbiAqL1xuZXhwb3J0IGVudW0gSW50ZXJuYWxLZXlyaW5nVHlwZSB7XG4gIGhkS2V5VHJlZSA9ICdIRCBLZXkgVHJlZScsXG4gIGltcG9ydGVkID0gJ1NpbXBsZSBLZXkgUGFpcicsXG59XG5cbi8qKlxuICogQWxsIGtleXJpbmdzIHN1cHBvcnRlZCBieSBNZXRhTWFzay5cbiAqL1xuZXhwb3J0IGNvbnN0IEtleXJpbmdUeXBlID0ge1xuICAuLi5IYXJkd2FyZUtleXJpbmdUeXBlLFxuICAuLi5JbnRlcm5hbEtleXJpbmdUeXBlLFxufTtcbiIsIi8vIFRoZSBjaGFyYWN0ZXIgbGltaXQgb24gRU5TIG5hbWVzLCBuaWNrbmFtZXMgYW5kIGFkZHJlc3NlcyBiZWZvcmUgd2UgdHJ1bmNhdGVcbmV4cG9ydCBjb25zdCBUUlVOQ0FURURfTkFNRV9DSEFSX0xJTUlUID0gMTE7XG5cbi8vIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBzbGljZSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgYW4gYWRkcmVzcyBmb3IgdHJ1bmNhdGVkIGZvcm1hdDpcbi8vIGAke1RSVU5DQVRFRF9BRERSRVNTX1NUQVJUX0NIQVJTfS4uLiR7VFJVTkNBVEVEX0FERFJFU1NfRU5EX0NIQVJTfWBcbmV4cG9ydCBjb25zdCBUUlVOQ0FURURfQUREUkVTU19TVEFSVF9DSEFSUyA9IDU7XG5cbi8vIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBzbGljZSBmcm9tIHRoZSBlbmQgb2YgYW4gYWRkcmVzcyBmb3IgdHJ1bmNhdGVkIGZvcm1hdDpcbi8vIGAke1RSVU5DQVRFRF9BRERSRVNTX1NUQVJUX0NIQVJTfS4uLiR7VFJVTkNBVEVEX0FERFJFU1NfRU5EX0NIQVJTfWBcbmV4cG9ydCBjb25zdCBUUlVOQ0FURURfQUREUkVTU19FTkRfQ0hBUlMgPSA0O1xuIiwiaW1wb3J0IHR5cGUgeyBFbnZpcm9ubWVudFR5cGUgfSBmcm9tICcuL2FwcCc7XG5pbXBvcnQgeyBMZWRnZXJUcmFuc3BvcnRUeXBlcyB9IGZyb20gJy4vaGFyZHdhcmUtd2FsbGV0cyc7XG5cbi8qKlxuICogVXNlZCB0byBhdHRhY2ggY29udGV4dCBvZiB3aGVyZSB0aGUgdXNlciB3YXMgYXQgaW4gdGhlIGFwcGxpY2F0aW9uIHdoZW4gdGhlXG4gKiBldmVudCB3YXMgdHJpZ2dlcmVkLiBBbHNvIGluY2x1ZGVkIGFzIGZ1bGwgZGV0YWlscyBvZiB0aGUgY3VycmVudCBwYWdlIGluXG4gKiBwYWdlIGV2ZW50cy5cbiAqL1xuZXhwb3J0IHR5cGUgTWV0YU1ldHJpY3NQYWdlT2JqZWN0ID0ge1xuICAvKipcbiAgICogVGhlIHBhdGggb2YgdGhlIGN1cnJlbnQgcGFnZSAoZS5nLiBcIi9ob21lXCIpLlxuICAgKi9cbiAgcGF0aD86IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSB0aXRsZSBvZiB0aGUgY3VycmVudCBwYWdlIChlLmcuIFwiaG9tZVwiKS5cbiAgICovXG4gIHRpdGxlPzogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIGZ1bGx5IHF1YWxpZmllZCBVUkwgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAgICovXG4gIHVybD86IHN0cmluZztcbn07XG5cbi8qKlxuICogVGhlIGRhcHAgdGhhdCB0cmlnZ2VyZWQgYW4gaW50ZXJhY3Rpb24gKE1ldGFNYXNrIG9ubHkpLlxuICovXG5leHBvcnQgdHlwZSBNZXRhTWV0cmljc1JlZmVycmVyT2JqZWN0ID0ge1xuICAvKipcbiAgICogVGhlIG9yaWdpbiBvZiB0aGUgZGFwcCBpc3N1aW5nIHRoZSBub3RpZmljYXRpb24uXG4gICAqL1xuICB1cmw/OiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIFdlIGF0dGFjaCBjb250ZXh0IHRvIGV2ZXJ5IG1ldGEgbWV0cmljcyBldmVudCB0aGF0IGhlbHAgdG8gcXVhbGlmeSBvdXJcbiAqIGFuYWx5dGljcy4gVGhpcyB0eXBlIGhhcyBhbGwgb3B0aW9uYWwgdmFsdWVzIGJlY2F1c2UgaXQgcmVwcmVzZW50cyBhXG4gKiByZXR1cm5lZCBvYmplY3QgZnJvbSBhIG1ldGhvZCBjYWxsLiBJZGVhbGx5IGFwcCBhbmQgdXNlckFnZW50IGFyZVxuICogZGVmaW5lZCBvbiBldmVyeSBldmVudC4gVGhpcyBpcyBjb25maXJtZWQgaW4gdGhlIGdldFRyYWNrTWV0YU1ldHJpY3NFdmVudFxuICogZnVuY3Rpb24sIGJ1dCBzdGlsbCBwcm92aWRlcyB0aGUgY29uc3VtZXIgYSB3YXkgdG8gb3ZlcnJpZGUgdGhlc2UgdmFsdWVzIGlmXG4gKiBuZWNlc3NhcnkuXG4gKi9cbnR5cGUgTWV0YU1ldHJpY3NDb250ZXh0ID0ge1xuICAvKipcbiAgICogQXBwbGljYXRpb24gbWV0YWRhdGEuXG4gICAqL1xuICBhcHA6IHtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgYXBwbGljYXRpb24gdHJhY2tpbmcgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgYXBwbGljYXRpb24uXG4gICAgICovXG4gICAgdmVyc2lvbjogc3RyaW5nO1xuICB9O1xuICAvKipcbiAgICogVGhlIHVzZXIgYWdlbnQgb2YgdGhlIGFwcGxpY2F0aW9uLlxuICAgKi9cbiAgdXNlckFnZW50OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIGRldGFpbHMgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAgICovXG4gIHBhZ2U/OiBNZXRhTWV0cmljc1BhZ2VPYmplY3Q7XG4gIC8qKlxuICAgKiBUaGUgZGFwcCB0aGF0IHRyaWdnZXJlZCBhbiBpbnRlcmFjdGlvbiAoTWV0YU1hc2sgb25seSkuXG4gICAqL1xuICByZWZlcnJlcj86IE1ldGFNZXRyaWNzUmVmZXJyZXJPYmplY3Q7XG59O1xuXG5leHBvcnQgdHlwZSBNZXRhTWV0cmljc0V2ZW50UGF5bG9hZCA9IHtcbiAgLyoqXG4gICAqIFRoZSBldmVudCBuYW1lIHRvIHRyYWNrLlxuICAgKi9cbiAgZXZlbnQ6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBjYXRlZ29yeSB0byBhc3NvY2lhdGUgdGhlIGV2ZW50IHRvLlxuICAgKi9cbiAgY2F0ZWdvcnk6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBhY3Rpb24gSUQgdG8gZGVkdXBsaWNhdGUgZXZlbnQgcmVxdWVzdHMgZnJvbSB0aGUgVUkuXG4gICAqL1xuICBhY3Rpb25JZD86IG51bWJlcjtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGVudmlyb25tZW50IHRoaXMgZXZlbnQgb2NjdXJyZWQgaW4uIERlZmF1bHRzIHRvIHRoZSBiYWNrZ3JvdW5kXG4gICAqIHByb2Nlc3MgdHlwZS5cbiAgICovXG4gIGVudmlyb25tZW50VHlwZT86IHN0cmluZztcbiAgLyoqXG4gICAqIEN1c3RvbSB2YWx1ZXMgdG8gdHJhY2suIEtleXMgaW4gdGhpcyBvYmplY3QgbXVzdCBiZSBgc25ha2VfY2FzZWAuXG4gICAqL1xuICBwcm9wZXJ0aWVzPzogb2JqZWN0O1xuICAvKipcbiAgICogU2Vuc2l0aXZlIHZhbHVlcyB0byB0cmFjay4gVGhlc2UgcHJvcGVydGllcyB3aWxsIGJlIHNlbnQgaW4gYW4gYWRkaXRpb25hbFxuICAgKiBldmVudCB0aGF0IGV4Y2x1ZGVzIHRoZSB1c2VyJ3MgYG1ldGFNZXRyaWNzSWRgLiBLZXlzIGluIHRoaXMgb2JqZWN0IG11c3QgYmVcbiAgICogaW4gYHNuYWtlX2Nhc2VgLlxuICAgKi9cbiAgc2Vuc2l0aXZlUHJvcGVydGllcz86IG9iamVjdDtcbiAgLyoqXG4gICAqIEFtb3VudCBvZiBjdXJyZW5jeSB0aGF0IHRoZSBldmVudCBjcmVhdGVzIGluIHJldmVudWUgZm9yIE1ldGFNYXNrLlxuICAgKi9cbiAgcmV2ZW51ZT86IG51bWJlcjtcbiAgLyoqXG4gICAqIElTTy00MTI3LWZvcm1hdHRlZCBjdXJyZW5jeSBmb3IgZXZlbnRzIHdpdGggcmV2ZW51ZS4gRGVmYXVsdHMgdG8gVVNcbiAgICogZG9sbGFycy5cbiAgICovXG4gIGN1cnJlbmN5Pzogc3RyaW5nO1xuICAvKipcbiAgICogQWJzdHJhY3QgYnVzaW5lc3MgXCJ2YWx1ZVwiIGF0dHJpYnV0YWJsZSB0byBjdXN0b21lcnMgd2hvIHRyaWdnZXIgdGhpcyBldmVudC5cbiAgICovXG4gIHZhbHVlPzogbnVtYmVyO1xuICAvKipcbiAgICogVGhlIHBhZ2Uvcm91dGUgdGhhdCB0aGUgZXZlbnQgb2NjdXJyZWQgb24uXG4gICAqL1xuICBwYWdlPzogTWV0YU1ldHJpY3NQYWdlT2JqZWN0O1xuICAvKipcbiAgICogVGhlIG9yaWdpbiBvZiB0aGUgZGFwcCB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50LlxuICAgKi9cbiAgcmVmZXJyZXI/OiBNZXRhTWV0cmljc1JlZmVycmVyT2JqZWN0O1xufTtcblxuZXhwb3J0IHR5cGUgTWV0YU1ldHJpY3NFdmVudE9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgZXZlbnQgaGFwcGVuZWQgZHVyaW5nIHRoZSBvcHQtaW4gd29ya2Zsb3cuXG4gICAqL1xuICBpc09wdEluPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHNlZ21lbnQgcXVldWUgc2hvdWxkIGJlIGZsdXNoZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuICAgKiBSZWNvbW1lbmRlZCBpZiB0aGUgcmVzdWx0IG9mIHRyYWNraW5nIHRoZSBldmVudCBtdXN0IGJlIGtub3duIGJlZm9yZSBVSVxuICAgKiB0cmFuc2l0aW9uIG9yIHVwZGF0ZS5cbiAgICovXG4gIGZsdXNoSW1tZWRpYXRlbHk/OiBib29sZWFuO1xuICAvKipcbiAgICogV2hldGhlciB0byBleGNsdWRlIHRoZSB1c2VyJ3MgYG1ldGFNZXRyaWNzSWRgIGZvciBhbm9ueW1pdHkuXG4gICAqL1xuICBleGNsdWRlTWV0YU1ldHJpY3NJZD86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBBbiBvdmVycmlkZSBmb3IgdGhlIGBtZXRhTWV0cmljc0lkYCBpbiB0aGUgZXZlbnQgKG5vIHB1biBpbnRlbmRlZCkgb25lIGlzXG4gICAqIGNyZWF0ZWQgYXMgYSBwYXJ0IG9mIGFuIGFzeW5jaHJvbm91cyB3b3JrZmxvdywgc3VjaCBhcyBhd2FpdGluZyB0aGUgcmVzdWx0XG4gICAqIG9mIHRoZSBNZXRhTWV0cmljcyBvcHQtaW4gZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgdGhlIHVzZXInc1xuICAgKiBgbWV0YU1ldHJpY3NJZGAuXG4gICAqL1xuICBtZXRhTWV0cmljc0lkPzogc3RyaW5nO1xuICAvKipcbiAgICogSXMgdGhpcyBldmVudCBhIGhvbGRvdmVyIGZyb20gTWF0b21vIHRoYXQgbmVlZHMgZnVydGhlciBtaWdyYXRpb24/IFdoZW5cbiAgICogdHJ1ZSwgc2VuZHMgdGhlIGRhdGEgdG8gYSBzcGVjaWFsIFNlZ21lbnQgc291cmNlIHRoYXQgbWFya3MgdGhlIGV2ZW50IGRhdGFcbiAgICogYXMgbm90IGNvbmZvcm1pbmcgdG8gb3VyIHNjaGVtYS5cbiAgICovXG4gIG1hdG9tb0V2ZW50PzogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCB0eXBlIE1ldGFNZXRyaWNzRXZlbnRGcmFnbWVudCA9IHtcbiAgLyoqXG4gICAqIFRoZSBldmVudCBuYW1lIHRvIGZpcmUgd2hlbiB0aGUgZnJhZ21lbnQgaXMgY2xvc2VkIGluIGFuIGFmZmlybWF0aXZlIGFjdGlvbi5cbiAgICovXG4gIHN1Y2Nlc3NFdmVudDogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIGV2ZW50IG5hbWUgdG8gZmlyZSB3aGVuIHRoZSBmcmFnbWVudCBpcyBjbG9zZWQgd2l0aCBhIHJlamVjdGlvbi5cbiAgICovXG4gIGZhaWx1cmVFdmVudD86IHN0cmluZztcbiAgLyoqXG4gICAqIEFuIGV2ZW50IG5hbWUgdG8gZmlyZSBpbW1lZGlhdGVseSB1cG9uIGZyYWdtZW50IGNyZWF0aW9uLiBUaGlzIGlzIHVzZWZ1bFxuICAgKiBmb3IgYnVpbGRpbmcgZnVubmVscyBpbiBtaXhwYW5lbCBhbmQgZm9yIHJlZHVjdGlvbiBvZiBjb2RlIGR1cGxpY2F0aW9uLlxuICAgKi9cbiAgaW5pdGlhbEV2ZW50Pzogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIGV2ZW50IGNhdGVnb3J5IHRvIHVzZSBmb3IgYm90aCB0aGUgc3VjY2VzcyBhbmQgZmFpbHVyZSBldmVudHMuXG4gICAqL1xuICBjYXRlZ29yeTogc3RyaW5nO1xuICAvKipcbiAgICogU2hvdWxkIHRoaXMgZnJhZ21lbnQgYmUgcGVyc2lzdGVkIGluIHN0YXRlIGFuZCBwcm9ncmVzc2VkIGFmdGVyIHRoZVxuICAgKiBleHRlbnNpb24gaXMgbG9ja2VkIGFuZCB1bmxvY2tlZC5cbiAgICovXG4gIHBlcnNpc3Q/OiBib29sZWFuO1xuICAvKipcbiAgICogVGltZSBpbiBzZWNvbmRzIHRoZSBldmVudCBzaG91bGQgYmUgcGVyc2lzdGVkIGZvci4gQWZ0ZXIgdGhlIHRpbWVvdXQgdGhlXG4gICAqIGZyYWdtZW50IHdpbGwgYmUgY2xvc2VkIGFzIGFiYW5kb25lZC4gSWYgbm90IHN1cHBsaWVkIHRoZSBmcmFnbWVudCBpc1xuICAgKiBzdG9yZWQgaW5kZWZpbml0ZWx5LlxuICAgKi9cbiAgdGltZW91dD86IG51bWJlcjtcbiAgLyoqXG4gICAqIGBEYXRlLm5vdygpYCB3aGVuIHRoZSBmcmFnbWVudCB3YXMgbGFzdCB1cGRhdGVkLiBVc2VkIHRvIGRldGVybWluZSBpZiB0aGVcbiAgICogdGltZW91dCBoYXMgZXhwaXJlZCBhbmQgdGhlIGZyYWdtZW50IHNob3VsZCBiZSBjbG9zZWQuXG4gICAqL1xuICBsYXN0VXBkYXRlZD86IG51bWJlcjtcbiAgLyoqXG4gICAqIEN1c3RvbSB2YWx1ZXMgdG8gdHJhY2suIEtleXMgaW4gdGhpcyBvYmplY3QgbXVzdCBiZSBgc25ha2VfY2FzZWAuXG4gICAqL1xuICBwcm9wZXJ0aWVzPzogb2JqZWN0O1xuICAvKipcbiAgICogU2Vuc2l0aXZlIHZhbHVlcyB0byB0cmFjay4gVGhlc2UgcHJvcGVydGllcyB3aWxsIGJlIHNlbnQgaW4gYW4gYWRkaXRpb25hbFxuICAgKiBldmVudCB0aGF0IGV4Y2x1ZGVzIHRoZSB1c2VyJ3MgYG1ldGFNZXRyaWNzSWRgLiBLZXlzIGluIHRoaXMgb2JqZWN0IG11c3QgYmVcbiAgICogaW4gYHNuYWtlX2Nhc2VgLlxuICAgKi9cbiAgc2Vuc2l0aXZlUHJvcGVydGllcz86IG9iamVjdDtcbiAgLyoqXG4gICAqIEFtb3VudCBvZiBjdXJyZW5jeSB0aGF0IHRoZSBldmVudCBjcmVhdGVzIGluIHJldmVudWUgZm9yIE1ldGFNYXNrLlxuICAgKi9cbiAgcmV2ZW51ZT86IG51bWJlcjtcbiAgLyoqXG4gICAqIElTTy00MTI3LWZvcm1hdHRlZCBjdXJyZW5jeSBmb3IgZXZlbnRzIHdpdGggcmV2ZW51ZS4gRGVmYXVsdHMgdG8gVVNcbiAgICogZG9sbGFycy5cbiAgICovXG4gIGN1cnJlbmN5Pzogc3RyaW5nO1xuICAvKipcbiAgICogQWJzdHJhY3QgYnVzaW5lc3MgXCJ2YWx1ZVwiIGF0dHJpYnV0YWJsZSB0byBjdXN0b21lcnMgd2hvIHRyaWdnZXIgdGhpcyBldmVudC5cbiAgICovXG4gIHZhbHVlPzogbnVtYmVyO1xuICAvKipcbiAgICogVGhlIHBhZ2Uvcm91dGUgdGhhdCB0aGUgZXZlbnQgb2NjdXJyZWQgb24uXG4gICAqL1xuICBwYWdlPzogTWV0YU1ldHJpY3NQYWdlT2JqZWN0O1xuICAvKipcbiAgICogVGhlIG9yaWdpbiBvZiB0aGUgZGFwcCB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50LlxuICAgKi9cbiAgcmVmZXJyZXI/OiBNZXRhTWV0cmljc1JlZmVycmVyT2JqZWN0O1xuICAvKipcbiAgICogT3ZlcnJpZGVzIHRoZSBhdXRvbWF0aWMgZ2VuZXJhdGlvbiBvZiBVVUlEIGZvciB0aGUgZXZlbnQgZnJhZ21lbnQuIFRoaXMgaXNcbiAgICogdXNlZnVsIHdoZW4gdHJhY2tpbmcgZXZlbnRzIGZvciBzdWJzeXN0ZW1zIHRoYXQgYWxyZWFkeSBnZW5lcmF0ZSBVVUlEcyBzb1xuICAgKiB0byBhdm9pZCB1bm5lY2Vzc2FyeSBsb29rdXBzIGFuZCByZWR1Y2UgYWNjaWRlbnRhbCBkdXBsaWNhdGlvbi5cbiAgICovXG4gIHVuaXF1ZUlkZW50aWZpZXI/OiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIERhdGEgc2VudCB0byB0aGUgYHNlZ21lbnQudHJhY2tgIG1ldGhvZC5cbiAqL1xuZXhwb3J0IHR5cGUgU2VnbWVudEV2ZW50UGF5bG9hZCA9IHtcbiAgLyoqXG4gICAqIFRoZSBNZXRhTWV0cmljcyBpZCBmb3IgdGhlIHVzZXIuXG4gICAqL1xuICB1c2VySWQ/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBbiBhbm9ueW1vdXMgSUQgdGhhdCBpcyB1c2VkIHRvIHRyYWNrIHNlbnNpdGl2ZSBkYXRhIHdoaWxlIHByZXNlcnZpbmdcbiAgICogYW5vbnltaXR5LlxuICAgKi9cbiAgYW5vbnltb3VzSWQ/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gdHJhY2suXG4gICAqL1xuICBldmVudDogc3RyaW5nO1xuICAvKipcbiAgICogUHJvcGVydGllcyB0byBhdHRhY2ggdG8gdGhlIGV2ZW50LlxuICAgKi9cbiAgcHJvcGVydGllczogb2JqZWN0O1xuICAvKipcbiAgICogVGhlIGNvbnRleHQgdGhlIGV2ZW50IG9jY3VycmVkIGluLlxuICAgKi9cbiAgY29udGV4dDogTWV0YU1ldHJpY3NDb250ZXh0O1xufTtcblxuLyoqXG4gKiBEYXRhIHNlbnQgdG8gTWV0YU1ldHJpY3MgZm9yIHBhZ2Ugdmlld3MuXG4gKi9cbmV4cG9ydCB0eXBlIE1ldGFNZXRyaWNzUGFnZVBheWxvYWQgPSB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgcGFnZSB0aGF0IHdhcyB2aWV3ZWQuXG4gICAqL1xuICBuYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgdmFyaWFkaWMgcGFydHMgb2YgdGhlIHBhZ2UgVVJMLlxuICAgKlxuICAgKiBFeGFtcGxlOiBJZiB0aGUgcm91dGUgaXMgYC9hc3NldC86YXNzZXRgIGFuZCB0aGUgcGF0aCBpcyBgL2Fzc2V0L0VUSGAsXG4gICAqIHRoZSBgcGFyYW1zYCBwcm9wZXJ0eSB3b3VsZCBiZSBgeyBhc3NldDogJ0VUSCcgfWAuXG4gICAqL1xuICBwYXJhbXM/OiBvYmplY3Q7XG4gIC8qKlxuICAgKiBUaGUgZW52aXJvbm1lbnQgdHlwZSB0aGF0IHRoZSBwYWdlIHdhcyB2aWV3ZWQgaW4uXG4gICAqL1xuICBlbnZpcm9ubWVudFR5cGU6IEVudmlyb25tZW50VHlwZTtcbiAgLyoqXG4gICAqIFRoZSBkZXRhaWxzIG9mIHRoZSBwYWdlLlxuICAgKi9cbiAgcGFnZT86IE1ldGFNZXRyaWNzUGFnZU9iamVjdDtcbiAgLyoqXG4gICAqIFRoZSBkYXBwIHRoYXQgdHJpZ2dlcmVkIHRoZSBwYWdlIHZpZXcuXG4gICAqL1xuICByZWZlcnJlcj86IE1ldGFNZXRyaWNzUmVmZXJyZXJPYmplY3Q7XG59O1xuXG5leHBvcnQgdHlwZSBNZXRhTWV0cmljc1BhZ2VPcHRpb25zID0ge1xuICAvKipcbiAgICogSXMgdGhlIGN1cnJlbnQgcGF0aCBvbmUgb2YgdGhlIHBhZ2VzIGluIHRoZSBvbmJvYXJkaW5nIHdvcmtmbG93PyAoSWYgdGhpc1xuICAgKiBpcyB0cnVlIGFuZCBwYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3MgaXMgbnVsbCwgdGhlbiB0aGUgcGFnZSB2aWV3IHdpbGwgYmVcbiAgICogdHJhY2tlZC4pXG4gICAqL1xuICBpc09wdEluUGF0aD86IGJvb2xlYW47XG59O1xuXG4vKipcbiAqIERhdGEgc2VudCB0byBNZXRhTWV0cmljcyBmb3IgdXNlciB0cmFpdHMuXG4gKi9cbmV4cG9ydCB0eXBlIE1ldGFNZXRyaWNzVXNlclRyYWl0cyA9IHtcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgdXNlcidzIGFkZHJlc3MgYm9vay5cbiAgICovXG4gIGFkZHJlc3NfYm9va19lbnRyaWVzPzogbnVtYmVyO1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgbGVkZ2VyIGNvbm5lY3Rpb24gc2V0IGJ5IHVzZXIgcHJlZmVyZW5jZS5cbiAgICovXG4gIGxlZGdlcl9jb25uZWN0aW9uX3R5cGU/OiBMZWRnZXJUcmFuc3BvcnRUeXBlcztcbiAgLyoqXG4gICAqIEFuIGFycmF5IGNvbnNpc3Rpbmcgb2YgY2hhaW4gSURzIHRoYXQgcmVwcmVzZW50IHRoZSBuZXR3b3JrcyBhZGRlZCBieSB0aGVcbiAgICogdXNlci5cbiAgICovXG4gIG5ldHdvcmtzX2FkZGVkPzogc3RyaW5nW107XG4gIC8qKlxuICAgKiBBbiBhcnJheSBjb25zaXN0aW5nIG9mIGNoYWluIElEcyB0aGF0IHJlcHJlc2VudCB0aGUgbmV0d29ya3MgYWRkZWQgYnkgdGhlXG4gICAqIHVzZXIgdGhhdCBkbyBub3QgaGF2ZSBhIHRpY2tlci5cbiAgICovXG4gIG5ldHdvcmtzX3dpdGhvdXRfdGlja2VyPzogc3RyaW5nW107XG4gIC8qKlxuICAgKiBEb2VzIHRoZSB1c2VyIGhhdmUgdGhlIEF1dG9kZXRlY3QgTkZUcyBmZWF0dXJlIGVuYWJsZWQ/XG4gICAqL1xuICBuZnRfYXV0b2RldGVjdGlvbl9lbmFibGVkPzogbnVtYmVyO1xuICAvKipcbiAgICogQSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgb2YgaWRlbnRpdGllcyAoYWNjb3VudHMpIGFkZGVkIHRvIHRoZVxuICAgKiB1c2VyJ3Mgd2FsbGV0LlxuICAgKi9cbiAgbnVtYmVyX29mX2FjY291bnRzPzogbnVtYmVyO1xuICAvKipcbiAgICogQSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBhbW91bnQgb2YgTkZUIGNvbGxlY3Rpb25zIGZyb20gd2hpY2ggdGhlIHVzZXJcbiAgICogcG9zc2Vzc2VzIE5GVHMuXG4gICAqL1xuICBudW1iZXJfb2ZfbmZ0X2NvbGxlY3Rpb25zPzogbnVtYmVyO1xuICAvKipcbiAgICogQSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBhbW91bnQgb2YgYWxsIE5GVHMgdGhlIHVzZXIgcG9zc2Vzc2VzIGFjcm9zcyBhbGxcbiAgICogbmV0d29ya3MgYW5kIGFjY291bnRzLlxuICAgKi9cbiAgbnVtYmVyX29mX25mdHM/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBUaGUgdG90YWwgbnVtYmVyIG9mIHRva2VuIGNvbnRyYWN0cyB0aGUgdXNlciBoYXMgYWNyb3NzIGFsbCBuZXR3b3JrcyBhbmRcbiAgICogYWNjb3VudHMuXG4gICAqL1xuICBudW1iZXJfb2ZfdG9rZW5zPzogbnVtYmVyO1xuICAvKipcbiAgICogRG9lcyB0aGUgdXNlciBoYXZlIHRoZSBPcGVuU2VhIEFQSSBlbmFibGVkP1xuICAgKi9cbiAgb3BlbnNlYV9hcGlfZW5hYmxlZD86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBEb2VzIHRoZSB1c2VyIGhhdmUgM0JveCBzeW5jIGVuYWJsZWQ/XG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICB0aHJlZV9ib3hfZW5hYmxlZD86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBXaGljaCB0aGVtZSB0aGUgdXNlciBoYXMgc2VsZWN0ZWQuXG4gICAqL1xuICB0aGVtZT86IHN0cmluZztcbiAgLyoqXG4gICAqIERvZXMgdGhlIHVzZXIgaGF2ZSB0b2tlbiBkZXRlY3Rpb24gZW5hYmxlZD9cbiAgICovXG4gIHRva2VuX2RldGVjdGlvbl9lbmFibGVkPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIERvZXMgdGhlIHVzZXIgaGF2ZSBkZXNrdG9wIGVuYWJsZWQ/XG4gICAqL1xuICBkZXNrdG9wX2VuYWJsZWQ/OiBib29sZWFuO1xuICAvKipcbiAgICogV2hldGhlciB0aGUgc2VjdXJpdHkgcHJvdmlkZXIgZmVhdHVyZSBoYXMgYmVlbiBlbmFibGVkLlxuICAgKi9cbiAgc2VjdXJpdHlfcHJvdmlkZXJzPzogc3RyaW5nW107XG59O1xuXG5leHBvcnQgZW51bSBNZXRhTWV0cmljc1VzZXJUcmFpdCB7XG4gIC8qKlxuICAgKiBJZGVudGlmaWVkIHdoZW4gdGhlIHVzZXIgYWRkcyBvciBtb2RpZmllcyBhZGRyZXNzZXMgaW4gdGhlIGFkZHJlc3MgYm9vay5cbiAgICovXG4gIEFkZHJlc3NCb29rRW50cmllcyA9ICdhZGRyZXNzX2Jvb2tfZW50cmllcycsXG4gIC8qKlxuICAgKiBJZGVudGlmaWVkIHdoZW4gdGhlIHVzZXIgaW5zdGFsbGVkIHRoZSBleHRlbnNpb24uXG4gICAqL1xuICBJbnN0YWxsRGF0ZUV4dCA9ICdpbnN0YWxsX2RhdGVfZXh0JyxcbiAgLyoqXG4gICAqIElkZW50aWZpZWQgd2hlbiB0aGUgTGVkZ2VyIExpdmUgY29ubmVjdGlvbiB0eXBlIGlzIGNoYW5nZWQuXG4gICAqL1xuICBMZWRnZXJDb25uZWN0aW9uVHlwZSA9ICdsZWRnZXJfY29ubmVjdGlvbl90eXBlJyxcbiAgLyoqXG4gICAqIElkZW50aWZpZWQgd2hlbiB0aGUgdXNlciBtb2RpZmllcyBuZXR3b3Jrcy5cbiAgICovXG4gIE5ldHdvcmtzQWRkZWQgPSAnbmV0d29ya3NfYWRkZWQnLFxuICAvKipcbiAgICogSWRlbnRpZmllZCB3aGVuIHRoZSB1c2VyIG1vZGlmaWVzIG5ldHdvcmtzIHRoYXQgbGFjayBhIHRpY2tlci5cbiAgICovXG4gIE5ldHdvcmtzV2l0aG91dFRpY2tlciA9ICduZXR3b3Jrc193aXRob3V0X3RpY2tlcicsXG4gIC8qKlxuICAgKiBJZGVudGlmaWVkIHdoZW4gdGhlIFwiQXV0b2RldGVjdCBORlRzXCIgZmVhdHVyZSBpcyB0b2dnbGVkLlxuICAgKi9cbiAgTmZ0QXV0b2RldGVjdGlvbkVuYWJsZWQgPSAnbmZ0X2F1dG9kZXRlY3Rpb25fZW5hYmxlZCcsXG4gIC8qKlxuICAgKiBJZGVudGlmaWVkIHdoZW4gaWRlbnRpdGllcyBjaGFuZ2UuXG4gICAqL1xuICBOdW1iZXJPZkFjY291bnRzID0gJ251bWJlcl9vZl9hY2NvdW50cycsXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIHVuaXF1ZSBORlQgYWRkcmVzc2VzLlxuICAgKi9cbiAgTnVtYmVyT2ZOZnRDb2xsZWN0aW9ucyA9ICdudW1iZXJfb2ZfbmZ0X2NvbGxlY3Rpb25zJyxcbiAgLyoqXG4gICAqIElkZW50aWZpZWQgd2hlbiB0aGUgbnVtYmVyIG9mIE5GVHMgb3duZWQgYnkgdGhlIHVzZXIgY2hhbmdlcy5cbiAgICovXG4gIE51bWJlck9mTmZ0cyA9ICdudW1iZXJfb2ZfbmZ0cycsXG4gIC8qKlxuICAgKiBJZGVudGlmaWVkIHdoZW4gdGhlIG51bWJlciBvZiB0b2tlbnMgY2hhbmdlLlxuICAgKi9cbiAgTnVtYmVyT2ZUb2tlbnMgPSAnbnVtYmVyX29mX3Rva2VucycsXG4gIC8qKlxuICAgKiBJZGVudGlmaWVkIHdoZW4gdGhlIE9wZW5TZWEgQVBJIGlzIGVuYWJsZWQuXG4gICAqL1xuICBPcGVuU2VhQXBpRW5hYmxlZCA9ICdvcGVuc2VhX2FwaV9lbmFibGVkJyxcbiAgLyoqXG4gICAqIElkZW50aWZpZWQgd2hlbiB0aGUgdXNlcidzIHRoZW1lIGNoYW5nZXMuXG4gICAqL1xuICBUaGVtZSA9ICd0aGVtZScsXG4gIC8qKlxuICAgKiBJZGVudGlmaWVkIHdoZW4gdGhlIDNCb3ggZmVhdHVyZSBpcyB0b2dnbGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgVGhyZWVCb3hFbmFibGVkID0gJ3RocmVlX2JveF9lbmFibGVkJyxcbiAgLyoqXG4gICAqIElkZW50aWZpZWQgd2hlbiB0aGUgdG9rZW4gZGV0ZWN0aW9uIGZlYXR1cmUgaXMgdG9nZ2xlZC5cbiAgICovXG4gIFRva2VuRGV0ZWN0aW9uRW5hYmxlZCA9ICd0b2tlbl9kZXRlY3Rpb25fZW5hYmxlZCcsXG4gIC8qKlxuICAgKiBJZGVudGlmaWVkIHdoZW4gdGhlIHVzZXIgZW5hYmxlcyBkZXNrdG9wLlxuICAgKi9cbiAgRGVza3RvcEVuYWJsZWQgPSAnZGVza3RvcF9lbmFibGVkJyxcbiAgLyoqXG4gICAqIElkZW50aWZpZWQgd2hlbiB0aGUgc2VjdXJpdHkgcHJvdmlkZXIgZmVhdHVyZSBpcyBlbmFibGVkLlxuICAgKi9cbiAgU2VjdXJpdHlQcm92aWRlcnMgPSAnc2VjdXJpdHlfcHJvdmlkZXJzJyxcbn1cblxuLyoqXG4gKiBNaXhwYW5lbCBjb252ZXJ0cyB0aGUgemVybyBhZGRyZXNzIHZhbHVlIHRvIGEgdHJ1bHkgYW5vbnltb3VzIGV2ZW50LCB3aGljaFxuICogc3BlZWRzIHVwIHJlcG9ydGluZ1xuICovXG5leHBvcnQgY29uc3QgTUVUQU1FVFJJQ1NfQU5PTllNT1VTX0lEID0gJzB4MDAwMDAwMDAwMDAwMDAwMCc7XG5cbi8qKlxuICogVXNlZCB0byBpZGVudGlmeSBldmVudHMgdGhhdCBhcmUgdHJpZ2dlcmVkIGJ5IHRoZSBiYWNrZ3JvdW5kIHByb2Nlc3MuXG4gKi9cbmV4cG9ydCBjb25zdCBNRVRBTUVUUklDU19CQUNLR1JPVU5EX1BBR0VfT0JKRUNUOiBNZXRhTWV0cmljc1BhZ2VPYmplY3QgPSB7XG4gIHBhdGg6ICcvYmFja2dyb3VuZC1wcm9jZXNzJyxcbiAgdGl0bGU6ICdCYWNrZ3JvdW5kIFByb2Nlc3MnLFxuICB1cmw6ICcvYmFja2dyb3VuZC1wcm9jZXNzJyxcbn07XG5cbmV4cG9ydCBjb25zdCBSRUpFQ1RfTk9USUZJQ0FUSU9OX0NMT1NFID0gJ0NhbmNlbCBWaWEgTm90aWZpY2F0aW9uIENsb3NlJztcblxuZXhwb3J0IGNvbnN0IFJFSkVDVF9OT1RJRklDQVRJT05fQ0xPU0VfU0lHID1cbiAgJ0NhbmNlbCBTaWcgUmVxdWVzdCBWaWEgTm90aWZpY2F0aW9uIENsb3NlJztcblxuZXhwb3J0IGVudW0gTWV0YU1ldHJpY3NFdmVudE5hbWUge1xuICBBY2NvdW50QWRkZWQgPSAnQWNjb3VudCBBZGRlZCcsXG4gIEFjY291bnRBZGRTZWxlY3RlZCA9ICdBY2NvdW50IEFkZCBTZWxlY3RlZCcsXG4gIEFjY291bnRBZGRGYWlsZWQgPSAnQWNjb3VudCBBZGQgRmFpbGVkJyxcbiAgQWNjb3VudFBhc3N3b3JkQ3JlYXRlZCA9ICdBY2NvdW50IFBhc3N3b3JkIENyZWF0ZWQnLFxuICBBY2NvdW50UmVzZXQgPSAnQWNjb3VudCBSZXNldCcsXG4gIEFjY291bnRSZW5hbWVkID0gJ0FjY291bnQgUmVuYW1lZCcsXG4gIEFwcEluc3RhbGxlZCA9ICdBcHAgSW5zdGFsbGVkJyxcbiAgQXBwVW5sb2NrZWQgPSAnQXBwIFVubG9ja2VkJyxcbiAgQXBwVW5sb2NrZWRGYWlsZWQgPSAnQXBwIFVubG9ja2VkIEZhaWxlZCcsXG4gIEFwcExvY2tlZCA9ICdBcHAgTG9ja2VkJyxcbiAgQXBwV2luZG93RXhwYW5kZWQgPSAnQXBwIFdpbmRvdyBFeHBhbmRlZCcsXG4gIEJyaWRnZUxpbmtDbGlja2VkID0gJ0JyaWRnZSBMaW5rIENsaWNrZWQnLFxuICBEZWNyeXB0aW9uQXBwcm92ZWQgPSAnRGVjcnlwdGlvbiBBcHByb3ZlZCcsXG4gIERlY3J5cHRpb25SZWplY3RlZCA9ICdEZWNyeXB0aW9uIFJlamVjdGVkJyxcbiAgRGVjcnlwdGlvblJlcXVlc3RlZCA9ICdEZWNyeXB0aW9uIFJlcXVlc3RlZCcsXG4gIEVuY3J5cHRpb25QdWJsaWNLZXlBcHByb3ZlZCA9ICdFbmNyeXB0aW9uIEFwcHJvdmVkJyxcbiAgRW5jcnlwdGlvblB1YmxpY0tleVJlamVjdGVkID0gJ0VuY3J5cHRpb24gUmVqZWN0ZWQnLFxuICBFbmNyeXB0aW9uUHVibGljS2V5UmVxdWVzdGVkID0gJ0VuY3J5cHRpb24gUmVxdWVzdGVkJyxcbiAgRXh0ZXJuYWxMaW5rQ2xpY2tlZCA9ICdFeHRlcm5hbCBMaW5rIENsaWNrZWQnLFxuICBLZXlFeHBvcnRTZWxlY3RlZCA9ICdLZXkgRXhwb3J0IFNlbGVjdGVkJyxcbiAgS2V5RXhwb3J0UmVxdWVzdGVkID0gJ0tleSBFeHBvcnQgUmVxdWVzdGVkJyxcbiAgS2V5RXhwb3J0RmFpbGVkID0gJ0tleSBFeHBvcnQgRmFpbGVkJyxcbiAgS2V5RXhwb3J0Q2FuY2VsZWQgPSAnS2V5IEV4cG9ydCBDYW5jZWxlZCcsXG4gIEtleUV4cG9ydFJldmVhbGVkID0gJ0tleSBNYXRlcmlhbCBSZXZlYWxlZCcsXG4gIEtleUV4cG9ydENvcGllZCA9ICdLZXkgTWF0ZXJpYWwgQ29waWVkJyxcbiAgS2V5VG9rZW5EZXRlY3Rpb25TZWxlY3RlZCA9ICdLZXkgVG9rZW4gRGV0ZWN0aW9uIFNlbGVjdGVkJyxcbiAgS2V5R2xvYmFsU2VjdXJpdHlUb2dnbGVTZWxlY3RlZCA9ICdLZXkgR2xvYmFsIFNlY3VyaXR5L1ByaXZhY3kgU2V0dGluZ3MnLFxuICBLZXlCYWxhbmNlVG9rZW5QcmljZUNoZWNrZXIgPSAnS2V5IFNob3cgQmFsYW5jZSBhbmQgVG9rZW4gUHJpY2UgQ2hlY2tlciBTZXR0aW5ncycsXG4gIEtleUdhc0ZlZUVzdGltYXRpb25CdXlTd2FwVG9rZW5zID0gJ0tleSBTaG93IEdhcyBGZWUgRXN0aW1hdGlvbiwgQnV5IENyeXB0byBhbmQgU3dhcCBUb2tlbnMnLFxuICBLZXlBdXRvRGV0ZWN0VG9rZW5zID0gJ0tleSBBdXRvZGV0ZWN0IHRva2VucycsXG4gIEtleUJhdGNoQWNjb3VudEJhbGFuY2VSZXF1ZXN0cyA9ICdLZXkgQmF0Y2ggYWNjb3VudCBiYWxhbmNlIHJlcXVlc3RzJyxcbiAgTWV0cmljc09wdEluID0gJ01ldHJpY3MgT3B0IEluJyxcbiAgTWV0cmljc09wdE91dCA9ICdNZXRyaWNzIE9wdCBPdXQnLFxuICBOYXZBY2NvdW50TWVudU9wZW5lZCA9ICdBY2NvdW50IE1lbnUgT3BlbmVkJyxcbiAgTmF2QWNjb3VudERldGFpbHNPcGVuZWQgPSAnQWNjb3VudCBEZXRhaWxzIE9wZW5lZCcsXG4gIE5hdkNvbm5lY3RlZFNpdGVzT3BlbmVkID0gJ0Nvbm5lY3RlZCBTaXRlcyBPcGVuZWQnLFxuICBOYXZNYWluTWVudU9wZW5lZCA9ICdNYWluIE1lbnUgT3BlbmVkJyxcbiAgTmF2TmV0d29ya01lbnVPcGVuZWQgPSAnTmV0d29yayBNZW51IE9wZW5lZCcsXG4gIE5hdlNldHRpbmdzT3BlbmVkID0gJ1NldHRpbmdzIE9wZW5lZCcsXG4gIE5hdkFjY291bnRTd2l0Y2hlZCA9ICdBY2NvdW50IFN3aXRjaGVkJyxcbiAgTmF2TmV0d29ya1N3aXRjaGVkID0gJ05ldHdvcmsgU3dpdGNoZWQnLFxuICBOYXZCdXlCdXR0b25DbGlja2VkID0gJ0J1eSBCdXR0b24gQ2xpY2tlZCcsXG4gIE5hdlNlbmRCdXR0b25DbGlja2VkID0gJ1NlbmQgQnV0dG9uIENsaWNrZWQnLFxuICBOYXZTd2FwQnV0dG9uQ2xpY2tlZCA9ICdTd2FwIEJ1dHRvbiBDbGlja2VkJyxcbiAgTmZ0QWRkZWQgPSAnTkZUIEFkZGVkJyxcbiAgT25ib2FyZGluZ1dlbGNvbWUgPSAnQXBwIEluc3RhbGxlZCcsXG4gIE9uYm9hcmRpbmdXYWxsZXRDcmVhdGlvblN0YXJ0ZWQgPSAnV2FsbGV0IFNldHVwIFNlbGVjdGVkJyxcbiAgT25ib2FyZGluZ1dhbGxldEltcG9ydFN0YXJ0ZWQgPSAnV2FsbGV0IEltcG9ydCBTdGFydGVkJyxcbiAgT25ib2FyZGluZ1dhbGxldENyZWF0aW9uQXR0ZW1wdGVkID0gJ1dhbGxldCBQYXNzd29yZCBDcmVhdGVkJyxcbiAgT25ib2FyZGluZ1dhbGxldFNlY3VyaXR5U3RhcnRlZCA9ICdTUlAgQmFja3VwIFNlbGVjdGVkJyxcbiAgT25ib2FyZGluZ1dhbGxldFNlY3VyaXR5U2tpcEluaXRpYXRlZCA9ICdTUlAgU2tpcCBCYWNrdXAgU2VsZWN0ZWQnLFxuICBPbmJvYXJkaW5nV2FsbGV0U2VjdXJpdHlTa2lwQ29uZmlybWVkID0gJ1NSUCBCYWNrdXAgU2tpcHBlZCcsXG4gIE9uYm9hcmRpbmdXYWxsZXRTZWN1cml0eVNraXBDYW5jZWxlZCA9ICdTUlAgU2tpcCBCYWNrdXAgQ2FuY2VsZWQnLFxuICBPbmJvYXJkaW5nV2FsbGV0U2VjdXJpdHlQaHJhc2VSZXZlYWxlZCA9ICdTUlAgUmV2ZWFsZWQnLFxuICBPbmJvYXJkaW5nV2FsbGV0U2VjdXJpdHlQaHJhc2VXcml0dGVuRG93biA9ICdTUlAgQmFja3VwIENvbmZpcm0gRGlzcGxheScsXG4gIE9uYm9hcmRpbmdXYWxsZXRTZWN1cml0eVBocmFzZUNvbmZpcm1lZCA9ICdTUlAgQmFja3VwIENvbmZpcm1lZCcsXG4gIE9uYm9hcmRpbmdXYWxsZXRDcmVhdGlvbkNvbXBsZXRlID0gJ1dhbGxldCBDcmVhdGVkJyxcbiAgT25ib2FyZGluZ1dhbGxldFNldHVwQ29tcGxldGUgPSAnQXBwbGljYXRpb24gT3BlbmVkJyxcbiAgT25ib2FyZGluZ1dhbGxldEFkdmFuY2VkU2V0dGluZ3MgPSAnU2V0dGluZ3MgVXBkYXRlZCcsXG4gIE9uYm9hcmRpbmdXYWxsZXRJbXBvcnRBdHRlbXB0ZWQgPSAnV2FsbGV0IEltcG9ydCBBdHRlbXB0ZWQnLFxuICBPbmJvYXJkaW5nV2FsbGV0VmlkZW9QbGF5ID0gJ1NSUCBJbnRybyBWaWRlbyBQbGF5ZWQnLFxuICBPbmJvYXJkaW5nVHdpdHRlckNsaWNrID0gJ0V4dGVybmFsIExpbmsgQ2xpY2tlZCcsXG4gIE9ucmFtcFByb3ZpZGVyU2VsZWN0ZWQgPSAnT24tcmFtcCBQcm92aWRlciBTZWxlY3RlZCcsXG4gIFBlcm1pc3Npb25zQXBwcm92ZWQgPSAnUGVybWlzc2lvbnMgQXBwcm92ZWQnLFxuICBQZXJtaXNzaW9uc1JlamVjdGVkID0gJ1Blcm1pc3Npb25zIFJlamVjdGVkJyxcbiAgUGVybWlzc2lvbnNSZXF1ZXN0ZWQgPSAnUGVybWlzc2lvbnMgUmVxdWVzdGVkJyxcbiAgUGhpc2hpbmdQYWdlRGlzcGxheWVkID0gJ1BoaXNoaW5nIFBhZ2UgRGlzcGxheWVkJyxcbiAgUG9ydGZvbGlvTGlua0NsaWNrZWQgPSAnUG9ydGZvbGlvIExpbmsgQ2xpY2tlZCcsXG4gIFByb3ZpZGVyTWV0aG9kQ2FsbGVkID0gJ1Byb3ZpZGVyIE1ldGhvZCBDYWxsZWQnLFxuICBQdWJsaWNBZGRyZXNzQ29waWVkID0gJ1B1YmxpYyBBZGRyZXNzIENvcGllZCcsXG4gIFNlcnZpY2VXb3JrZXJSZXN0YXJ0ZWQgPSAnU2VydmljZSBXb3JrZXIgUmVzdGFydGVkJyxcbiAgU2lnbmF0dXJlQXBwcm92ZWQgPSAnU2lnbmF0dXJlIEFwcHJvdmVkJyxcbiAgU2lnbmF0dXJlRmFpbGVkID0gJ1NpZ25hdHVyZSBGYWlsZWQnLFxuICBTaWduYXR1cmVSZWplY3RlZCA9ICdTaWduYXR1cmUgUmVqZWN0ZWQnLFxuICBTaWduYXR1cmVSZXF1ZXN0ZWQgPSAnU2lnbmF0dXJlIFJlcXVlc3RlZCcsXG4gIFNycFJldmVhbFN0YXJ0ZWQgPSAnUmV2ZWFsIFNSUCBJbml0aWF0ZWQnLFxuICBTcnBSZXZlYWxDbGlja2VkID0gJ0NsaWNrZWQgUmV2ZWFsIFNlY3JldCBSZWNvdmVyeScsXG4gIFNycFJldmVhbFZpZXdlZCA9ICdWaWV3cyBSZXZlYWwgU2VjcmV0IFJlY292ZXJ5JyxcbiAgU3JwUmV2ZWFsQmFja0J1dHRvbkNsaWNrZWQgPSAnQ2xpY2tlZCBCYWNrIG9uIFJldmVhbCBTUlAgUGFzc3dvcmQgUGFnZScsXG4gIFNycFJldmVhbENhbmNlbGxlZCA9ICdSZXZlYWwgU1JQIENhbmNlbGxlZCcsXG4gIFNycFJldmVhbENhbmNlbEJ1dHRvbkNsaWNrZWQgPSAnQ2xpY2tzIENhbmNlbCBvbiBSZXZlYWwgU2VjcmV0IFJlY292ZXJ5IFBocmFzZSBQYWdlJyxcbiAgU3JwUmV2ZWFsQ2xvc2VDbGlja2VkID0gJ0NsaWNrcyBDTE9TRSB3aXRoIFNSUCcsXG4gIFNycFJldmVhbE5leHRDbGlja2VkID0gJ0NsaWNrcyBOZXh0IG9uIFJldmVhbCBTZWNyZXQgUmVjb3ZlcnkgUGhyYXNlJyxcbiAgU3JwSG9sZFRvUmV2ZWFsQ2xpY2tTdGFydGVkID0gJ1JldmVhbCBTUlAgQ2xpY2sgU3RhcnRlZCcsXG4gIFNycEhvbGRUb1JldmVhbENsb3NlQ2xpY2tlZCA9ICdDbG9zZXMgSG9sZCBUbyBSZXZlYWwgU1JQJyxcbiAgU3JwSG9sZFRvUmV2ZWFsQ29tcGxldGVkID0gJ1JldmVhbCBTUlAgQ29tcGxldGVkJyxcbiAgU3JwVmlld3NTcnBRUiA9ICdWaWV3cyBTUlAgUVIgQ29kZScsXG4gIFNycFZpZXdTcnBUZXh0ID0gJ1ZpZXdzIFNSUCcsXG4gIFNycENvcGllZFRvQ2xpcGJvYXJkID0gJ0NvcGllcyBTUlAgdG8gY2xpcGJvYXJkJyxcbiAgU3JwVG9Db25maXJtQmFja3VwID0gJ1NSUCBCYWNrdXAgQ29uZmlybSBEaXNwbGF5ZWQnLFxuICBTdXBwb3J0TGlua0NsaWNrZWQgPSAnU3VwcG9ydCBMaW5rIENsaWNrZWQnLFxuICBUZXJtc09mVXNlU2hvd24gPSAnVGVybXMgb2YgVXNlIFNob3duJyxcbiAgVGVybXNPZlVzZUFjY2VwdGVkID0gJ1Rlcm1zIG9mIFVzZSBBY2NlcHRlZCcsXG4gIFRva2VuSW1wb3J0QnV0dG9uQ2xpY2tlZCA9ICdJbXBvcnQgVG9rZW4gQnV0dG9uIENsaWNrZWQnLFxuICBUb2tlblNjcmVlbk9wZW5lZCA9ICdUb2tlbiBTY3JlZW4gT3BlbmVkJyxcbiAgVG9rZW5BZGRlZCA9ICdUb2tlbiBBZGRlZCcsXG4gIFRva2VuRGV0ZWN0ZWQgPSAnVG9rZW4gRGV0ZWN0ZWQnLFxuICBUb2tlbkhpZGRlbiA9ICdUb2tlbiBIaWRkZW4nLFxuICBUb2tlbkltcG9ydENhbmNlbGVkID0gJ1Rva2VuIEltcG9ydCBDYW5jZWxlZCcsXG4gIFRva2VuSW1wb3J0Q2xpY2tlZCA9ICdUb2tlbiBJbXBvcnQgQ2xpY2tlZCcsXG4gIFdhbGxldFNldHVwU3RhcnRlZCA9ICdXYWxsZXQgU2V0dXAgU2VsZWN0ZWQnLFxuICBXYWxsZXRTZXR1cENhbmNlbGVkID0gJ1dhbGxldCBTZXR1cCBDYW5jZWxlZCcsXG4gIFdhbGxldFNldHVwRmFpbGVkID0gJ1dhbGxldCBTZXR1cCBGYWlsZWQnLFxuICBXYWxsZXRDcmVhdGVkID0gJ1dhbGxldCBDcmVhdGVkJyxcbiAgQWNjb3VudERldGFpbE1lbnVPcGVuZWQgPSAnQWNjb3VudCBEZXRhaWxzIE1lbnUgT3BlbmVkJyxcbiAgQmxvY2tFeHBsb3JlckxpbmtDbGlja2VkID0gJ0Jsb2NrIEV4cGxvcmVyIENsaWNrZWQnLFxuICBBY2NvdW50UmVtb3ZlZCA9ICdBY2NvdW50IFJlbW92ZWQnLFxuICBUZXN0TmV0d29ya3NEaXNwbGF5ZWQgPSAnVGVzdCBOZXR3b3JrcyBEaXNwbGF5ZWQnLFxuICBBZGROZXR3b3JrQnV0dG9uQ2xpY2sgPSAnQWRkIE5ldHdvcmsgQnV0dG9uIENsaWNrZWQnLFxuICBDdXN0b21OZXR3b3JrQWRkZWQgPSAnQ3VzdG9tIE5ldHdvcmsgQWRkZWQnLFxuICBUb2tlbkRldGFpbHNPcGVuZWQgPSAnVG9rZW4gRGV0YWlscyBPcGVuZWQnLFxuICBOZnRTY3JlZW5PcGVuZWQgPSAnTkZUIFNjcmVlbiBPcGVuZWQnLFxuICBBY3Rpdml0eVNjcmVlbk9wZW5lZCA9ICdBY3Rpdml0eSBTY3JlZW4gT3BlbmVkJyxcbiAgV2hhdHNOZXdWaWV3ZWQgPSBgV2hhdCdzIE5ldyBWaWV3ZWRgLFxuICBXaGF0c05ld0NsaWNrZWQgPSBgV2hhdCdzIE5ldyBMaW5rIENsaWNrZWRgLFxufVxuXG5leHBvcnQgZW51bSBNZXRhTWV0cmljc0V2ZW50QWNjb3VudFR5cGUge1xuICBEZWZhdWx0ID0gJ21ldGFtYXNrJyxcbiAgSGFyZHdhcmUgPSAnaGFyZHdhcmUnLFxuICBJbXBvcnRlZCA9ICdpbXBvcnRlZCcsXG59XG5cbmV4cG9ydCBlbnVtIE1ldGFNZXRyaWNzRXZlbnRBY2NvdW50SW1wb3J0VHlwZSB7XG4gIEpzb24gPSAnanNvbicsXG4gIFByaXZhdGVLZXkgPSAncHJpdmF0ZV9rZXknLFxuICBTcnAgPSAnc3JwJyxcbn1cblxuZXhwb3J0IGVudW0gTWV0YU1ldHJpY3NFdmVudENhdGVnb3J5IHtcbiAgQWNjb3VudHMgPSAnQWNjb3VudHMnLFxuICBBcHAgPSAnQXBwJyxcbiAgQXV0aCA9ICdBdXRoJyxcbiAgQmFja2dyb3VuZCA9ICdCYWNrZ3JvdW5kJyxcbiAgRGVza3RvcCA9ICdEZXNrdG9wJyxcbiAgLy8gVGhlIFR5cGVTY3JpcHQgRVNMaW50IHJ1bGUgaXMgaW5jb3JyZWN0bHkgbWFya2luZyB0aGlzIGxpbmUuXG4gIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93ICovXG4gIEVycm9yID0gJ0Vycm9yJyxcbiAgRm9vdGVyID0gJ0Zvb3RlcicsXG4gIEhvbWUgPSAnSG9tZScsXG4gIElucGFnZVByb3ZpZGVyID0gJ2lucGFnZV9wcm92aWRlcicsXG4gIEtleXMgPSAnS2V5cycsXG4gIE1lc3NhZ2VzID0gJ01lc3NhZ2VzJyxcbiAgTmF2aWdhdGlvbiA9ICdOYXZpZ2F0aW9uJyxcbiAgTmV0d29yayA9ICdOZXR3b3JrJyxcbiAgT25ib2FyZGluZyA9ICdPbmJvYXJkaW5nJyxcbiAgUGhpc2hpbmcgPSAnUGhpc2hpbmcnLFxuICBSZXRlbnRpb24gPSAnUmV0ZW50aW9uJyxcbiAgU2VydmljZVdvcmtlcnMgPSAnc2VydmljZV93b3JrZXJzJyxcbiAgU2V0dGluZ3MgPSAnU2V0dGluZ3MnLFxuICBTbmFwcyA9ICdTbmFwcycsXG4gIFN3YXBzID0gJ1N3YXBzJyxcbiAgVHJhbnNhY3Rpb25zID0gJ1RyYW5zYWN0aW9ucycsXG4gIFdhbGxldCA9ICdXYWxsZXQnLFxuICBUb2tlbnMgPSAnVG9rZW5zJyxcbn1cblxuZXhwb3J0IGVudW0gTWV0YU1ldHJpY3NFdmVudExpbmtUeXBlIHtcbiAgQWNjb3VudFRyYWNrZXIgPSAnQWNjb3VudCBUcmFja2VyJyxcbiAgQmxvY2tFeHBsb3JlciA9ICdCbG9jayBFeHBsb3JlcicsXG4gIFRva2VuVHJhY2tlciA9ICdUb2tlbiBUcmFja2VyJyxcbiAgVHJhbnNhY3Rpb25CbG9ja0V4cGxvcmVyID0gJ1RyYW5zYWN0aW9uIEJsb2NrIEV4cGxvcmVyJyxcbn1cblxuZXhwb3J0IGVudW0gTWV0YU1ldHJpY3NFdmVudEtleVR5cGUge1xuICBQa2V5ID0gJ3ByaXZhdGVfa2V5JyxcbiAgU3JwID0gJ3NycCcsXG59XG5cbi8vIE5PVEU6IFRoaXMgZG9lc24ndCBzZWVtIHRvIGJlIHVzZWQgYXQgYWxsXG5leHBvcnQgZW51bSBNZXRhTWV0cmljc0V2ZW50T25yYW1wUHJvdmlkZXJUeXBlIHtcbiAgQ29pbmJhc2UgPSAnY29pbmJhc2UnLFxuICBNb29ucGF5ID0gJ21vb25wYXknLFxuICBTZWxmRGVwb3NpdCA9ICdkaXJlY3RfZGVwb3NpdCcsXG4gIFRyYW5zYWsgPSAndHJhbnNhaycsXG4gIFd5cmUgPSAnd3lyZScsXG59XG5cbmV4cG9ydCBlbnVtIE1ldGFNZXRyaWNzTmV0d29ya0V2ZW50U291cmNlIHtcbiAgQ3VzdG9tTmV0d29ya0Zvcm0gPSAnY3VzdG9tX25ldHdvcmtfZm9ybScsXG4gIFBvcHVsYXJOZXR3b3JrTGlzdCA9ICdwb3B1bGFyX25ldHdvcmtfbGlzdCcsXG4gIERhcHAgPSAnZGFwcCcsXG59XG5cbmV4cG9ydCBlbnVtIE1ldGFNZXRyaWNzU3dhcHNFdmVudFNvdXJjZSB7XG4gIE1haW5WaWV3ID0gJ01haW4gVmlldycsXG4gIFRva2VuVmlldyA9ICdUb2tlbiBWaWV3Jyxcbn1cblxuZXhwb3J0IGVudW0gTWV0YU1ldHJpY3NUb2tlbkV2ZW50U291cmNlIHtcbiAgQ3VzdG9tID0gJ2N1c3RvbScsXG4gIERhcHAgPSAnZGFwcCcsXG4gIERldGVjdGVkID0gJ2RldGVjdGVkJyxcbiAgTGlzdCA9ICdsaXN0Jyxcbn1cblxuZXhwb3J0IGVudW0gTWV0YU1ldHJpY3NUcmFuc2FjdGlvbkV2ZW50U291cmNlIHtcbiAgRGFwcCA9ICdkYXBwJyxcbiAgVXNlciA9ICd1c2VyJyxcbn1cblxuZXhwb3J0IGVudW0gTWV0YU1ldHJpY3NFdmVudExvY2F0aW9uIHtcbiAgVG9rZW5EZXRhaWxzID0gJ3Rva2VuX2RldGFpbHMnLFxuICBUb2tlbkRldGVjdGlvbiA9ICd0b2tlbl9kZXRlY3Rpb24nLFxuICBUb2tlbk1lbnUgPSAndG9rZW5fbWVudScsXG59XG5cbmV4cG9ydCBlbnVtIE1ldGFNZXRyaWNzRXZlbnRVaUN1c3RvbWl6YXRpb24ge1xuICBGbGFnZ2VkQXNNYWxpY2lvdXMgPSAnZmxhZ2dlZF9hc19tYWxpY2lvdXMnLFxuICBGbGFnZ2VkQXNTYWZldHlVbmtub3duID0gJ2ZsYWdnZWRfYXNfc2FmZXR5X3Vua25vd24nLFxuICBTaXdlID0gJ3NpZ25faW5fd2l0aF9ldGhlcmV1bScsXG59XG5cbi8qKlxuICogVmFsdWVzIHRoYXQgY2FuIHVzZWQgaW4gdGhlIFwicHJvcGVydGllc1wiIHRyYWNraW5nIG9iamVjdCBhcyBrZXlzLCBlLmcuIGB7XG4gKiBsb2NhdGlvbjogJ0hvbWUnIH1gLlxuICovXG5leHBvcnQgZW51bSBNZXRhTWV0cmljc0NvbnRleHRQcm9wIHtcbiAgUGFnZVRpdGxlID0gJ2xvY2F0aW9uJyxcbn1cbiIsImltcG9ydCB7IGNhcGl0YWxpemUsIHBpY2sgfSBmcm9tICdsb2Rhc2gnO1xuLyoqXG4gKiBBIHR5cGUgcmVwcmVzZW50aW5nIGFueSB2YWxpZCB2YWx1ZSBmb3IgJ3R5cGUnIGZvciBzZXRQcm92aWRlclR5cGUgYW5kIG90aGVyXG4gKiBtZXRob2RzIHRoYXQgYWRkIG9yIG1hbmlwdWxhdGUgbmV0d29ya3MgaW4gTWV0YU1hc2sgc3RhdGUuXG4gKi9cbmV4cG9ydCB0eXBlIE5ldHdvcmtUeXBlID0gKHR5cGVvZiBORVRXT1JLX1RZUEVTKVtrZXlvZiB0eXBlb2YgTkVUV09SS19UWVBFU107XG5cbi8qKlxuICogQSB1bmlvbiB0eXBlIG9mIGFsbCBwb3NzaWJsZSBoYXJkLWNvZGVkIGNoYWluIGlkcy4gVGhpcyB0eXBlIGlzIG5vdFxuICogZXhoYXVzdGl2ZSBhbmQgY2Fubm90IGJlIHVzZWQgZm9yIHR5cGluZyBjaGFpbklkIGluIGFyZWFzIHdoZXJlIHRoZSB1c2VyIG9yXG4gKiBkYXBwIG1heSBzcGVjaWZ5IGFueSBjaGFpbklkLlxuICovXG5leHBvcnQgdHlwZSBDaGFpbklkID0gKHR5cGVvZiBDSEFJTl9JRFMpW2tleW9mIHR5cGVvZiBDSEFJTl9JRFNdO1xuXG4vKipcbiAqIEEgdHlwZSB0aGF0IGlzIGEgdW5pb24gdHlwZSBvZiBhbGwgcG9zc2libGUgaGFyZGNvZGVkIGN1cnJlbmN5IHN5bWJvbHMuXG4gKiBUaGlzIHR5cGUgaXMgbm9uLWV4aGF1c3RpdmUsIGFuZCBjYW5ub3QgYmUgdXNlZCBmb3IgYXJlYXMgd2hlcmUgdGhlIHVzZXJcbiAqIG9yIGRhcHAgbWF5IHN1cHBseSB0aGVpciBvd24gc3ltYm9sLlxuICovXG5leHBvcnQgdHlwZSBDdXJyZW5jeVN5bWJvbCA9XG4gICh0eXBlb2YgQ1VSUkVOQ1lfU1lNQk9MUylba2V5b2YgdHlwZW9mIENVUlJFTkNZX1NZTUJPTFNdO1xuLyoqXG4gKiBUZXN0IG5ldHdvcmtzIGhhdmUgc3BlY2lhbCBzeW1ib2xzIHRoYXQgY29tYmluZSB0aGUgbmV0d29yayBuYW1lIGFuZCAnRVRIJ1xuICogc28gdGhhdCB0aGV5IGFyZSBkaXN0aW5jdCBmcm9tIG1haW5uZXQgYW5kIG90aGVyIG5ldHdvcmtzIHRoYXQgdXNlICdFVEgnLlxuICovXG5leHBvcnQgdHlwZSBUZXN0TmV0d29ya0N1cnJlbmN5U3ltYm9sID1cbiAgKHR5cGVvZiBURVNUX05FVFdPUktfVElDS0VSX01BUClba2V5b2YgdHlwZW9mIFRFU1RfTkVUV09SS19USUNLRVJfTUFQXTtcblxuLyoqXG4gKiBBbiBvYmplY3QgY29udGFpbmluZyBwcmVmZXJlbmNlcyBmb3IgYW4gUlBDIGRlZmluaXRpb25cbiAqL1xudHlwZSBSUENQcmVmZXJlbmNlcyA9IHtcbiAgLyoqXG4gICAqIEEgVVJMIGZvciB0aGUgYmxvY2sgZXhwbG9yZXIgZm9yIHRoZSBSUEMncyBuZXR3b3JrXG4gICAqL1xuICBibG9ja0V4cGxvcmVyVXJsOiBgaHR0cHM6Ly8ke3N0cmluZ31gO1xuICAvKipcbiAgICogQSBpbWFnZSByZWZsZWN0aW5nIHRoZSBhc3NldCBzeW1ib2wgZm9yIHRoZSBuZXR3b3JrXG4gICAqL1xuICBpbWFnZVVybDogc3RyaW5nO1xufTtcblxuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBkZXNjcmliZXMgYSBuZXR3b3JrIHRvIGJlIHVzZWQgaW5zaWRlIG9mIE1ldGFNYXNrXG4gKi9cbmV4cG9ydCB0eXBlIFJQQ0RlZmluaXRpb24gPSB7XG4gIC8qKlxuICAgKiBUaGUgaGV4IGVuY29kZWQgQ2hhaW5JZCBmb3IgdGhlIG5ldHdvcmtcbiAgICovXG4gIGNoYWluSWQ6IENoYWluSWQ7XG4gIC8qKlxuICAgKiBUaGUgbmlja25hbWUgZm9yIHRoZSBuZXR3b3JrXG4gICAqL1xuICBuaWNrbmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIFVSTCBmb3IgdGhlIGNsaWVudCB0byBzZW5kIG5ldHdvcmsgcmVxdWVzdHMgdG9cbiAgICovXG4gIHJwY1VybDogYGh0dHBzOi8vJHtzdHJpbmd9YDtcbiAgLyoqXG4gICAqIFRoZSBDdXJyZW5jeSBTeW1ib2wgZm9yIHRoZSBuZXR3b3JrXG4gICAqL1xuICB0aWNrZXI6IHN0cmluZztcbiAgLyoqXG4gICAqIEFkZGl0aW9uYWwgcHJlZmVyZW5jZXMgZm9yIHRoZSBuZXR3b3JrLCBzdWNoIGFzIGJsb2NrRXhwbG9yZXJVcmxcbiAgICovXG4gIHJwY1ByZWZzOiBSUENQcmVmZXJlbmNlcztcbn07XG5cbi8qKlxuICogRm9yIGVhY2ggY2hhaW4gdGhhdCB3ZSBzdXBwb3J0IGZpYXQgb25yYW1wcyBmb3IsIHdlIHByb3ZpZGUgYSBzZXQgb2ZcbiAqIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0aGF0IGhlbHAgZm9yIGluaXRpYWxpemluZyB0aGUgY29ubmVjdGlvbmcgdG8gdGhlXG4gKiBvbnJhbXAgcHJvdmlkZXJzLlxuICovXG50eXBlIEJ1eWFibGVDaGFpblNldHRpbmdzID0ge1xuICAvKipcbiAgICogVGhlIG5hdGl2ZSBjdXJyZW5jeSBmb3IgdGhlIGdpdmVuIGNoYWluXG4gICAqL1xuICBuYXRpdmVDdXJyZW5jeTogQ3VycmVuY3lTeW1ib2wgfCBUZXN0TmV0d29ya0N1cnJlbmN5U3ltYm9sO1xuICAvKipcbiAgICogVGhlIG5ldHdvcmsgbmFtZSBvciBpZGVudGlmaWVyXG4gICAqL1xuICBuZXR3b3JrOiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIFRocm91Z2hvdXQgdGhlIGV4dGVuc2lvbiB3ZSBzZXQgdGhlIGN1cnJlbnQgcHJvdmlkZXIgYnkgcmVmZXJlbmNpbmcgaXRzXG4gKiBcInR5cGVcIiwgd2hpY2ggY2FuIGJlIGFueSBvZiB0aGUgdmFsdWVzIGluIHRoZSBiZWxvdyBvYmplY3QuIFRoZXNlIHZhbHVlc1xuICogcmVwcmVzZW50IHRoZSBidWlsdC1pbiBuZXR3b3JrcyBvZiBNZXRhTWFzaywgaW5jbHVkaW5nIHRlc3QgbmV0cywgYXMgd2VsbFxuICogYXMgXCJycGNcIiB3aGljaCBpcyB0aGUgXCJ0eXBlXCIgb2YgYSBjdXN0b20gbmV0d29yayBhZGRlZCBieSB0aGUgdXNlciBvciB2aWFcbiAqIHdhbGxldF9hZGRFdGhlcmV1bUNoYWluLlxuICovXG5leHBvcnQgY29uc3QgTkVUV09SS19UWVBFUyA9IHtcbiAgR09FUkxJOiAnZ29lcmxpJyxcbiAgTE9DQUxIT1NUOiAnbG9jYWxob3N0JyxcbiAgTUFJTk5FVDogJ21haW5uZXQnLFxuICBSUEM6ICdycGMnLFxuICBTRVBPTElBOiAnc2Vwb2xpYScsXG4gIExJTkVBX1RFU1RORVQ6ICdsaW5lYXRlc3RuZXQnLFxufSBhcyBjb25zdDtcblxuLyoqXG4gKiBBbiBvYmplY3QgY29udGFpbmluZyBzaG9ydGN1dCBuYW1lcyBmb3IgYW55IG5vbi1idWlsdGluIG5ldHdvcmsuIFdlIG5lZWRcbiAqIHRoaXMgdG8gYmUgYWJsZSB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gbmV0d29ya3MgdGhhdCByZXF1aXJlIGN1c3RvbVxuICogc2VjdGlvbnMgb2YgY29kZSBmb3Igb3VyIHZhcmlvdXMgZmVhdHVyZXMsIHN1Y2ggYXMgc3dhcHMgb3IgdG9rZW4gbGlzdHMuXG4gKi9cbmV4cG9ydCBjb25zdCBORVRXT1JLX05BTUVTID0ge1xuICBIT01FU1RFQUQ6ICdob21lc3RlYWQnLFxufTtcblxuLyoqXG4gKiBUaGUgTmV0d29yayBJRCBmb3Igb3VyIGJ1aWx0aW4gbmV0d29ya3MuIFRoaXMgaXMgdGhlIGRlY2ltYWwgZXF1aXZhbGVudCBvZlxuICogdGhlIGNoYWluIGlkIGZvciB0aGUgbmV0d29yaywgYnV0IGlzIGV4cHJlc3NzZWQgYXMgYSBzdHJpbmcuIE1hbnkgbW9vbnMgYWdvXG4gKiB0aGUgZGVjaXNpb24gd2FzIG1hZGUgb24gdGhlIGV4dGVuc2lvbiB0ZWFtIHRvIGV4cHJlc3NseSB1c2UgY2hhaW5JZCB3aXRoXG4gKiBoZXggZW5jb2Rpbmcgb3ZlciBuZXR3b3JrIGlkLiBDb25zaWRlciB0aGF0IHdoZW4gYWNjZXNzaW5nIHRoaXMgb2JqZWN0LiBOb3RlXG4gKiBmb3IgY3Jvc3MgcHJvZHVjdCBwdXJwb3NlczogYWxpZ25tZW50IHdpdGggbW9iaWxlIG9uIHRoaXMgbWF0dGVyIGhhcyBub3RcbiAqIGJlZW4gZnVsbHkgYWNoaWV2ZWQsIHRodXMgaXQgaXMgcG9zc2libGUgZm9yIHNvbWUgZGVwZW5kZW5jaWVzIHRvIHN0aWxsXG4gKiBhc2sgZm9yIG9yIHJlcXVpcmUgbmV0d29yayBpZC5cbiAqL1xuZXhwb3J0IGNvbnN0IE5FVFdPUktfSURTID0ge1xuICBNQUlOTkVUOiAnMScsXG4gIEdPRVJMSTogJzUnLFxuICBMT0NBTEhPU1Q6ICcxMzM3JyxcbiAgU0VQT0xJQTogJzExMTU1MTExJyxcbiAgTElORUFfVEVTVE5FVDogJzU5MTQwJyxcbn0gYXMgY29uc3Q7XG5cbi8qKlxuICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBjaGFpbiBpZHMgZm9yIG5ldHdvcmtzIGJvdGggYnVpbHQgaW4gYW5kXG4gKiB0aG9zZSB0aGF0IHdlIGhhdmUgYWRkZWQgY3VzdG9tIGNvZGUgdG8gc3VwcG9ydCBvdXIgZmVhdHVyZSBzZXQuXG4gKi9cbmV4cG9ydCBjb25zdCBDSEFJTl9JRFMgPSB7XG4gIE1BSU5ORVQ6ICcweDEnLFxuICBHT0VSTEk6ICcweDUnLFxuICBMT0NBTEhPU1Q6ICcweDUzOScsXG4gIEJTQzogJzB4MzgnLFxuICBCU0NfVEVTVE5FVDogJzB4NjEnLFxuICBPUFRJTUlTTTogJzB4YScsXG4gIE9QVElNSVNNX1RFU1RORVQ6ICcweDFhNCcsXG4gIFBPTFlHT046ICcweDg5JyxcbiAgUE9MWUdPTl9URVNUTkVUOiAnMHgxMzg4MScsXG4gIEFWQUxBTkNIRTogJzB4YTg2YScsXG4gIEFWQUxBTkNIRV9URVNUTkVUOiAnMHhhODY5JyxcbiAgRkFOVE9NOiAnMHhmYScsXG4gIEZBTlRPTV9URVNUTkVUOiAnMHhmYTInLFxuICBDRUxPOiAnMHhhNGVjJyxcbiAgQVJCSVRSVU06ICcweGE0YjEnLFxuICBIQVJNT05ZOiAnMHg2MzU2NGM0MCcsXG4gIFBBTE06ICcweDJhMTVjMzA4ZCcsXG4gIFNFUE9MSUE6ICcweGFhMzZhNycsXG4gIExJTkVBX1RFU1RORVQ6ICcweGU3MDQnLFxuICBBVVJPUkE6ICcweDRlNDU0MTUyJyxcbiAgTU9PTkJFQU06ICcweDUwNCcsXG4gIE1PT05CRUFNX1RFU1RORVQ6ICcweDUwNycsXG4gIE1PT05SSVZFUjogJzB4NTA1Jyxcbn0gYXMgY29uc3Q7XG5cbi8qKlxuICogVGhlIGxhcmdlc3QgcG9zc2libGUgY2hhaW4gSUQgd2UgY2FuIGhhbmRsZS5cbiAqIEV4cGxhbmF0aW9uOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9yZWttYXJrcy9hNDdiZDVmMjUyNTkzNmM0YjhlZWUzMWExNjM0NTU1M1xuICovXG5leHBvcnQgY29uc3QgTUFYX1NBRkVfQ0hBSU5fSUQgPSA0NTAzNTk5NjI3MzcwNDc2O1xuXG5leHBvcnQgY29uc3QgTUFJTk5FVF9ESVNQTEFZX05BTUUgPSAnRXRoZXJldW0gTWFpbm5ldCc7XG5leHBvcnQgY29uc3QgR09FUkxJX0RJU1BMQVlfTkFNRSA9ICdHb2VybGknO1xuZXhwb3J0IGNvbnN0IFNFUE9MSUFfRElTUExBWV9OQU1FID0gJ1NlcG9saWEnO1xuZXhwb3J0IGNvbnN0IExJTkVBX1RFU1RORVRfRElTUExBWV9OQU1FID0gJ0xpbmVhIEdvZXJsaSB0ZXN0IG5ldHdvcmsnO1xuZXhwb3J0IGNvbnN0IExPQ0FMSE9TVF9ESVNQTEFZX05BTUUgPSAnTG9jYWxob3N0IDg1NDUnO1xuZXhwb3J0IGNvbnN0IEJTQ19ESVNQTEFZX05BTUUgPSAnQmluYW5jZSBTbWFydCBDaGFpbic7XG5leHBvcnQgY29uc3QgUE9MWUdPTl9ESVNQTEFZX05BTUUgPSAnUG9seWdvbic7XG5leHBvcnQgY29uc3QgQVZBTEFOQ0hFX0RJU1BMQVlfTkFNRSA9ICdBdmFsYW5jaGUgTmV0d29yayBDLUNoYWluJztcbmV4cG9ydCBjb25zdCBBUkJJVFJVTV9ESVNQTEFZX05BTUUgPSAnQXJiaXRydW0gT25lJztcbmV4cG9ydCBjb25zdCBCTkJfRElTUExBWV9OQU1FID1cbiAgJ0JOQiBTbWFydCBDaGFpbiAocHJldmlvdXNseSBCaW5hbmNlIFNtYXJ0IENoYWluIE1haW5uZXQpJztcbmV4cG9ydCBjb25zdCBPUFRJTUlTTV9ESVNQTEFZX05BTUUgPSAnT3B0aW1pc20nO1xuZXhwb3J0IGNvbnN0IEZBTlRPTV9ESVNQTEFZX05BTUUgPSAnRmFudG9tIE9wZXJhJztcbmV4cG9ydCBjb25zdCBIQVJNT05ZX0RJU1BMQVlfTkFNRSA9ICdIYXJtb255IE1haW5uZXQgU2hhcmQgMCc7XG5leHBvcnQgY29uc3QgUEFMTV9ESVNQTEFZX05BTUUgPSAnUGFsbSc7XG5leHBvcnQgY29uc3QgQVVST1JBX0RJU1BMQVlfTkFNRSA9ICdBdXJvcmEgTWFpbm5ldCc7XG5leHBvcnQgY29uc3QgQ0VMT19ESVNQTEFZX05BTUUgPSAnQ2VsbyBNYWlubmV0JztcblxuZXhwb3J0IGNvbnN0IGluZnVyYVByb2plY3RJZCA9IHByb2Nlc3MuZW52LklORlVSQV9QUk9KRUNUX0lEO1xuZXhwb3J0IGNvbnN0IGdldFJwY1VybCA9ICh7XG4gIG5ldHdvcmssXG4gIGV4Y2x1ZGVQcm9qZWN0SWQgPSBmYWxzZSxcbn06IHtcbiAgbmV0d29yazogTmV0d29ya1R5cGU7XG4gIGV4Y2x1ZGVQcm9qZWN0SWQ/OiBib29sZWFuO1xufSkgPT5cbiAgYGh0dHBzOi8vJHtuZXR3b3JrfS5pbmZ1cmEuaW8vdjMvJHtleGNsdWRlUHJvamVjdElkID8gJycgOiBpbmZ1cmFQcm9qZWN0SWR9YDtcblxuZXhwb3J0IGNvbnN0IE1BSU5ORVRfUlBDX1VSTCA9IGdldFJwY1VybCh7XG4gIG5ldHdvcms6IE5FVFdPUktfVFlQRVMuTUFJTk5FVCxcbn0pO1xuZXhwb3J0IGNvbnN0IEdPRVJMSV9SUENfVVJMID0gZ2V0UnBjVXJsKHsgbmV0d29yazogTkVUV09SS19UWVBFUy5HT0VSTEkgfSk7XG5leHBvcnQgY29uc3QgU0VQT0xJQV9SUENfVVJMID0gZ2V0UnBjVXJsKHsgbmV0d29yazogTkVUV09SS19UWVBFUy5TRVBPTElBIH0pO1xuZXhwb3J0IGNvbnN0IExJTkVBX1RFU1RORVRfUlBDX1VSTCA9ICdodHRwczovL3JwYy5nb2VybGkubGluZWEuYnVpbGQnO1xuZXhwb3J0IGNvbnN0IExPQ0FMSE9TVF9SUENfVVJMID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6ODU0NSc7XG5cbi8qKlxuICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHRva2VuIHN5bWJvbHMgZm9yIHZhcmlvdXMgdG9rZW5zIHRoYXQgYXJlIGVpdGhlclxuICogbmF0aXZlIGN1cnJlbmNpZXMgb3IgdGhvc2UgdGhhdCBoYXZlIGJlZW4gc3BlY2lhbCBjYXNlZCBieSB0aGUgZXh0ZW5zaW9uXG4gKiBmb3Igc3VwcG9ydGluZyBvdXIgZmVhdHVyZSBzZXQuXG4gKi9cbmV4cG9ydCBjb25zdCBDVVJSRU5DWV9TWU1CT0xTID0ge1xuICBBUkJJVFJVTTogJ0VUSCcsXG4gIEFVUk9SQV9FVEg6ICdBVVJPUkEgRVRIJyxcbiAgQVZBTEFOQ0hFOiAnQVZBWCcsXG4gIEJOQjogJ0JOQicsXG4gIEJVU0Q6ICdCVVNEJyxcbiAgQ0VMTzogJ0NFTE8nLFxuICBEQUk6ICdEQUknLFxuICBFVEg6ICdFVEgnLFxuICBGQU5UT006ICdGVE0nLFxuICBIQVJNT05ZOiAnT05FJyxcbiAgUEFMTTogJ1BBTE0nLFxuICBNQVRJQzogJ01BVElDJyxcbiAgVEVTVF9FVEg6ICdURVNURVRIJyxcbiAgVVNEQzogJ1VTREMnLFxuICBVU0RUOiAnVVNEVCcsXG4gIFdFVEg6ICdXRVRIJyxcbiAgT1BUSU1JU006ICdPUCcsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgRVRIX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9ldGhfbG9nby5wbmcnO1xuZXhwb3J0IGNvbnN0IFRFU1RfRVRIX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9ibGFjay1ldGgtbG9nby5zdmcnO1xuZXhwb3J0IGNvbnN0IEJOQl9UT0tFTl9JTUFHRV9VUkwgPSAnLi9pbWFnZXMvYm5iLnBuZyc7XG5leHBvcnQgY29uc3QgTUFUSUNfVE9LRU5fSU1BR0VfVVJMID0gJy4vaW1hZ2VzL21hdGljLXRva2VuLnBuZyc7XG5leHBvcnQgY29uc3QgQVZBWF9UT0tFTl9JTUFHRV9VUkwgPSAnLi9pbWFnZXMvYXZheC10b2tlbi5wbmcnO1xuZXhwb3J0IGNvbnN0IEFFVEhfVE9LRU5fSU1BR0VfVVJMID0gJy4vaW1hZ2VzL2FyYml0cnVtLnN2Zyc7XG5leHBvcnQgY29uc3QgRlRNX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9mYW50b20tb3BlcmEuc3ZnJztcbmV4cG9ydCBjb25zdCBIQVJNT05ZX09ORV9UT0tFTl9JTUFHRV9VUkwgPSAnLi9pbWFnZXMvaGFybW9ueS1vbmUuc3ZnJztcbmV4cG9ydCBjb25zdCBPUFRJTUlTTV9UT0tFTl9JTUFHRV9VUkwgPSAnLi9pbWFnZXMvb3B0aW1pc20uc3ZnJztcbmV4cG9ydCBjb25zdCBQQUxNX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9wYWxtLnN2Zyc7XG5leHBvcnQgY29uc3QgQVVST1JBX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9hdXJvcmEucG5nJztcbmV4cG9ydCBjb25zdCBDRUxPX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9jZWxvLnN2Zyc7XG5cbmV4cG9ydCBjb25zdCBJTkZVUkFfUFJPVklERVJfVFlQRVMgPSBbXG4gIE5FVFdPUktfVFlQRVMuTUFJTk5FVCxcbiAgTkVUV09SS19UWVBFUy5HT0VSTEksXG4gIE5FVFdPUktfVFlQRVMuU0VQT0xJQSxcbl0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBURVNUX0NIQUlOUyA9IFtcbiAgQ0hBSU5fSURTLkdPRVJMSSxcbiAgQ0hBSU5fSURTLlNFUE9MSUEsXG4gIENIQUlOX0lEUy5MSU5FQV9URVNUTkVULFxuICBDSEFJTl9JRFMuTE9DQUxIT1NULFxuXTtcblxuY29uc3QgdHlwZWRDYXBpdGFsaXplID0gPEsgZXh0ZW5kcyBzdHJpbmc+KGs6IEspOiBDYXBpdGFsaXplPEs+ID0+XG4gIGNhcGl0YWxpemUoaykgYXMgQ2FwaXRhbGl6ZTx0eXBlb2Ygaz47XG5cbmV4cG9ydCBjb25zdCBURVNUX05FVFdPUktfVElDS0VSX01BUDoge1xuICBbSyBpbiBFeGNsdWRlPFxuICAgIE5ldHdvcmtUeXBlLFxuICAgICdsb2NhbGhvc3QnIHwgJ21haW5uZXQnIHwgJ3JwYydcbiAgPl06IGAke0NhcGl0YWxpemU8Sz59JHt0eXBlb2YgQ1VSUkVOQ1lfU1lNQk9MUy5FVEh9YDtcbn0gPSB7XG4gIFtORVRXT1JLX1RZUEVTLkdPRVJMSV06IGAke3R5cGVkQ2FwaXRhbGl6ZShORVRXT1JLX1RZUEVTLkdPRVJMSSl9JHtcbiAgICBDVVJSRU5DWV9TWU1CT0xTLkVUSFxuICB9YCxcbiAgW05FVFdPUktfVFlQRVMuU0VQT0xJQV06IGAke3R5cGVkQ2FwaXRhbGl6ZShORVRXT1JLX1RZUEVTLlNFUE9MSUEpfSR7XG4gICAgQ1VSUkVOQ1lfU1lNQk9MUy5FVEhcbiAgfWAsXG4gIFtORVRXT1JLX1RZUEVTLkxJTkVBX1RFU1RORVRdOlxuICAgIGBMaW5lYSR7Q1VSUkVOQ1lfU1lNQk9MUy5FVEh9YCBhcyBgJHtDYXBpdGFsaXplPFxuICAgICAgdHlwZW9mIE5FVFdPUktfVFlQRVMuTElORUFfVEVTVE5FVFxuICAgID59JHt0eXBlb2YgQ1VSUkVOQ1lfU1lNQk9MUy5FVEh9YCxcbn07XG5cbi8qKlxuICogTWFwIG9mIGFsbCBidWlsZC1pbiBJbmZ1cmEgbmV0d29ya3MgdG8gdGhlaXIgbmV0d29yaywgdGlja2VyIGFuZCBjaGFpbiBJRHMuXG4gKi9cbmV4cG9ydCBjb25zdCBCVUlMVF9JTl9ORVRXT1JLUyA9IHtcbiAgW05FVFdPUktfVFlQRVMuR09FUkxJXToge1xuICAgIG5ldHdvcmtJZDogTkVUV09SS19JRFMuR09FUkxJLFxuICAgIGNoYWluSWQ6IENIQUlOX0lEUy5HT0VSTEksXG4gICAgdGlja2VyOiBURVNUX05FVFdPUktfVElDS0VSX01BUFtORVRXT1JLX1RZUEVTLkdPRVJMSV0sXG4gICAgYmxvY2tFeHBsb3JlclVybDogYGh0dHBzOi8vJHtORVRXT1JLX1RZUEVTLkdPRVJMSX0uZXRoZXJzY2FuLmlvYCxcbiAgfSxcbiAgW05FVFdPUktfVFlQRVMuU0VQT0xJQV06IHtcbiAgICBuZXR3b3JrSWQ6IE5FVFdPUktfSURTLlNFUE9MSUEsXG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLlNFUE9MSUEsXG4gICAgdGlja2VyOiBURVNUX05FVFdPUktfVElDS0VSX01BUFtORVRXT1JLX1RZUEVTLlNFUE9MSUFdLFxuICAgIGJsb2NrRXhwbG9yZXJVcmw6IGBodHRwczovLyR7TkVUV09SS19UWVBFUy5TRVBPTElBfS5ldGhlcnNjYW4uaW9gLFxuICB9LFxuICBbTkVUV09SS19UWVBFUy5MSU5FQV9URVNUTkVUXToge1xuICAgIG5ldHdvcmtJZDogTkVUV09SS19JRFMuTElORUFfVEVTVE5FVCxcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuTElORUFfVEVTVE5FVCxcbiAgICB0aWNrZXI6IFRFU1RfTkVUV09SS19USUNLRVJfTUFQW05FVFdPUktfVFlQRVMuTElORUFfVEVTVE5FVF0sXG4gICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vZXhwbG9yZXIuZ29lcmxpLmxpbmVhLmJ1aWxkJyxcbiAgfSxcbiAgW05FVFdPUktfVFlQRVMuTUFJTk5FVF06IHtcbiAgICBuZXR3b3JrSWQ6IE5FVFdPUktfSURTLk1BSU5ORVQsXG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLk1BSU5ORVQsXG4gICAgYmxvY2tFeHBsb3JlclVybDogYGh0dHBzOi8vZXRoZXJzY2FuLmlvYCxcbiAgfSxcbiAgW05FVFdPUktfVFlQRVMuTE9DQUxIT1NUXToge1xuICAgIG5ldHdvcmtJZDogTkVUV09SS19JRFMuTE9DQUxIT1NULFxuICAgIGNoYWluSWQ6IENIQUlOX0lEUy5MT0NBTEhPU1QsXG4gIH0sXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgQlVJTFRfSU5fSU5GVVJBX05FVFdPUktTID0gcGljayhcbiAgQlVJTFRfSU5fTkVUV09SS1MsXG4gIElORlVSQV9QUk9WSURFUl9UWVBFUyxcbik7XG5cbmV4cG9ydCB0eXBlIEJ1aWx0SW5JbmZ1cmFOZXR3b3JrID0ga2V5b2YgdHlwZW9mIEJVSUxUX0lOX0lORlVSQV9ORVRXT1JLUztcblxuZXhwb3J0IGNvbnN0IE5FVFdPUktfVE9fTkFNRV9NQVAgPSB7XG4gIFtORVRXT1JLX1RZUEVTLk1BSU5ORVRdOiBNQUlOTkVUX0RJU1BMQVlfTkFNRSxcbiAgW05FVFdPUktfVFlQRVMuR09FUkxJXTogR09FUkxJX0RJU1BMQVlfTkFNRSxcbiAgW05FVFdPUktfVFlQRVMuU0VQT0xJQV06IFNFUE9MSUFfRElTUExBWV9OQU1FLFxuICBbTkVUV09SS19UWVBFUy5MSU5FQV9URVNUTkVUXTogTElORUFfVEVTVE5FVF9ESVNQTEFZX05BTUUsXG4gIFtORVRXT1JLX1RZUEVTLkxPQ0FMSE9TVF06IExPQ0FMSE9TVF9ESVNQTEFZX05BTUUsXG5cbiAgW05FVFdPUktfSURTLkdPRVJMSV06IEdPRVJMSV9ESVNQTEFZX05BTUUsXG4gIFtORVRXT1JLX0lEUy5TRVBPTElBXTogU0VQT0xJQV9ESVNQTEFZX05BTUUsXG4gIFtORVRXT1JLX0lEUy5MSU5FQV9URVNUTkVUXTogTElORUFfVEVTVE5FVF9ESVNQTEFZX05BTUUsXG4gIFtORVRXT1JLX0lEUy5NQUlOTkVUXTogTUFJTk5FVF9ESVNQTEFZX05BTUUsXG4gIFtORVRXT1JLX0lEUy5MT0NBTEhPU1RdOiBMT0NBTEhPU1RfRElTUExBWV9OQU1FLFxuXG4gIFtDSEFJTl9JRFMuR09FUkxJXTogR09FUkxJX0RJU1BMQVlfTkFNRSxcbiAgW0NIQUlOX0lEUy5TRVBPTElBXTogU0VQT0xJQV9ESVNQTEFZX05BTUUsXG4gIFtDSEFJTl9JRFMuTElORUFfVEVTVE5FVF06IExJTkVBX1RFU1RORVRfRElTUExBWV9OQU1FLFxuICBbQ0hBSU5fSURTLk1BSU5ORVRdOiBNQUlOTkVUX0RJU1BMQVlfTkFNRSxcbiAgW0NIQUlOX0lEUy5MT0NBTEhPU1RdOiBMT0NBTEhPU1RfRElTUExBWV9OQU1FLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IENIQUlOX0lEX1RPX1RZUEVfTUFQID0ge1xuICBbQ0hBSU5fSURTLk1BSU5ORVRdOiBORVRXT1JLX1RZUEVTLk1BSU5ORVQsXG4gIFtDSEFJTl9JRFMuR09FUkxJXTogTkVUV09SS19UWVBFUy5HT0VSTEksXG4gIFtDSEFJTl9JRFMuU0VQT0xJQV06IE5FVFdPUktfVFlQRVMuU0VQT0xJQSxcbiAgW0NIQUlOX0lEUy5MSU5FQV9URVNUTkVUXTogTkVUV09SS19UWVBFUy5MSU5FQV9URVNUTkVULFxuICBbQ0hBSU5fSURTLkxPQ0FMSE9TVF06IE5FVFdPUktfVFlQRVMuTE9DQUxIT1NULFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IENIQUlOX0lEX1RPX1JQQ19VUkxfTUFQID0ge1xuICBbQ0hBSU5fSURTLkdPRVJMSV06IEdPRVJMSV9SUENfVVJMLFxuICBbQ0hBSU5fSURTLlNFUE9MSUFdOiBTRVBPTElBX1JQQ19VUkwsXG4gIFtDSEFJTl9JRFMuTElORUFfVEVTVE5FVF06IExJTkVBX1RFU1RORVRfUlBDX1VSTCxcbiAgW0NIQUlOX0lEUy5NQUlOTkVUXTogTUFJTk5FVF9SUENfVVJMLFxuICBbQ0hBSU5fSURTLkxPQ0FMSE9TVF06IExPQ0FMSE9TVF9SUENfVVJMLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IENIQUlOX0lEX1RPX05FVFdPUktfSU1BR0VfVVJMX01BUCA9IHtcbiAgW0NIQUlOX0lEUy5NQUlOTkVUXTogRVRIX1RPS0VOX0lNQUdFX1VSTCxcbiAgW0NIQUlOX0lEUy5BVkFMQU5DSEVdOiBBVkFYX1RPS0VOX0lNQUdFX1VSTCxcbiAgW0NIQUlOX0lEUy5CU0NdOiBCTkJfVE9LRU5fSU1BR0VfVVJMLFxuICBbQ0hBSU5fSURTLlBPTFlHT05dOiBNQVRJQ19UT0tFTl9JTUFHRV9VUkwsXG4gIFtDSEFJTl9JRFMuQVJCSVRSVU1dOiBBRVRIX1RPS0VOX0lNQUdFX1VSTCxcbiAgW0NIQUlOX0lEUy5GQU5UT01dOiBGVE1fVE9LRU5fSU1BR0VfVVJMLFxuICBbQ0hBSU5fSURTLkhBUk1PTlldOiBIQVJNT05ZX09ORV9UT0tFTl9JTUFHRV9VUkwsXG4gIFtDSEFJTl9JRFMuT1BUSU1JU01dOiBPUFRJTUlTTV9UT0tFTl9JTUFHRV9VUkwsXG4gIFtDSEFJTl9JRFMuUEFMTV06IFBBTE1fVE9LRU5fSU1BR0VfVVJMLFxuICBbQ0hBSU5fSURTLkFVUk9SQV06IEFVUk9SQV9UT0tFTl9JTUFHRV9VUkwsXG4gIFtDSEFJTl9JRFMuQ0VMT106IENFTE9fVE9LRU5fSU1BR0VfVVJMLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IE5FVFdPUktfSURfVE9fRVRIRVJTX05FVFdPUktfTkFNRV9NQVAgPSB7XG4gIFtORVRXT1JLX0lEUy5HT0VSTEldOiBORVRXT1JLX1RZUEVTLkdPRVJMSSxcbiAgW05FVFdPUktfSURTLlNFUE9MSUFdOiBORVRXT1JLX1RZUEVTLlNFUE9MSUEsXG4gIFtORVRXT1JLX0lEUy5MSU5FQV9URVNUTkVUXTogTkVUV09SS19UWVBFUy5MSU5FQV9URVNUTkVULFxuICBbTkVUV09SS19JRFMuTUFJTk5FVF06IE5FVFdPUktfTkFNRVMuSE9NRVNURUFELFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IENIQUlOX0lEX1RPX05FVFdPUktfSURfTUFQID0ge1xuICBbQ0hBSU5fSURTLk1BSU5ORVRdOiBORVRXT1JLX0lEUy5NQUlOTkVULFxuICBbQ0hBSU5fSURTLkdPRVJMSV06IE5FVFdPUktfSURTLkdPRVJMSSxcbiAgW0NIQUlOX0lEUy5TRVBPTElBXTogTkVUV09SS19JRFMuU0VQT0xJQSxcbiAgW0NIQUlOX0lEUy5MSU5FQV9URVNUTkVUXTogTkVUV09SS19JRFMuTElORUFfVEVTVE5FVCxcbiAgW0NIQUlOX0lEUy5MT0NBTEhPU1RdOiBORVRXT1JLX0lEUy5MT0NBTEhPU1QsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgTkFUSVZFX0NVUlJFTkNZX1RPS0VOX0lNQUdFX01BUCA9IHtcbiAgW0NVUlJFTkNZX1NZTUJPTFMuRVRIXTogRVRIX1RPS0VOX0lNQUdFX1VSTCxcbiAgW0NVUlJFTkNZX1NZTUJPTFMuVEVTVF9FVEhdOiBURVNUX0VUSF9UT0tFTl9JTUFHRV9VUkwsXG4gIFtDVVJSRU5DWV9TWU1CT0xTLkJOQl06IEJOQl9UT0tFTl9JTUFHRV9VUkwsXG4gIFtDVVJSRU5DWV9TWU1CT0xTLk1BVElDXTogTUFUSUNfVE9LRU5fSU1BR0VfVVJMLFxuICBbQ1VSUkVOQ1lfU1lNQk9MUy5BVkFMQU5DSEVdOiBBVkFYX1RPS0VOX0lNQUdFX1VSTCxcbiAgW0NVUlJFTkNZX1NZTUJPTFMuT1BUSU1JU01dOiBPUFRJTUlTTV9UT0tFTl9JTUFHRV9VUkwsXG4gIFtDVVJSRU5DWV9TWU1CT0xTLkNFTE9dOiBDRUxPX1RPS0VOX0lNQUdFX1VSTCxcbiAgW0NVUlJFTkNZX1NZTUJPTFMuQVVST1JBX0VUSF06IEVUSF9UT0tFTl9JTUFHRV9VUkwsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgSU5GVVJBX0JMT0NLRURfS0VZID0gJ2NvdW50cnlCbG9ja2VkJztcblxuY29uc3QgZGVmYXVsdEV0aGVyc2NhbkRvbWFpbiA9ICdldGhlcnNjYW4uaW8nO1xuY29uc3QgZGVmYXVsdEV0aGVyc2NhblN1YmRvbWFpblByZWZpeCA9ICdhcGknO1xuLyoqXG4gKiBNYXAgb2YgYWxsIEV0aGVyc2NhbiBzdXBwb3J0ZWQgbmV0d29ya3MuXG4gKi9cbmV4cG9ydCBjb25zdCBFVEhFUlNDQU5fU1VQUE9SVEVEX05FVFdPUktTID0ge1xuICBbQ0hBSU5fSURTLkdPRVJMSV06IHtcbiAgICBkb21haW46IGRlZmF1bHRFdGhlcnNjYW5Eb21haW4sXG4gICAgc3ViZG9tYWluOiBgJHtkZWZhdWx0RXRoZXJzY2FuU3ViZG9tYWluUHJlZml4fS0ke1xuICAgICAgQ0hBSU5fSURfVE9fVFlQRV9NQVBbQ0hBSU5fSURTLkdPRVJMSV1cbiAgICB9YCxcbiAgICBuZXR3b3JrSWQ6IENIQUlOX0lEX1RPX05FVFdPUktfSURfTUFQW0NIQUlOX0lEUy5HT0VSTEldLFxuICB9LFxuICBbQ0hBSU5fSURTLk1BSU5ORVRdOiB7XG4gICAgZG9tYWluOiBkZWZhdWx0RXRoZXJzY2FuRG9tYWluLFxuICAgIHN1YmRvbWFpbjogZGVmYXVsdEV0aGVyc2NhblN1YmRvbWFpblByZWZpeCxcbiAgICBuZXR3b3JrSWQ6IENIQUlOX0lEX1RPX05FVFdPUktfSURfTUFQW0NIQUlOX0lEUy5NQUlOTkVUXSxcbiAgfSxcbiAgW0NIQUlOX0lEUy5TRVBPTElBXToge1xuICAgIGRvbWFpbjogZGVmYXVsdEV0aGVyc2NhbkRvbWFpbixcbiAgICBzdWJkb21haW46IGAke2RlZmF1bHRFdGhlcnNjYW5TdWJkb21haW5QcmVmaXh9LSR7XG4gICAgICBDSEFJTl9JRF9UT19UWVBFX01BUFtDSEFJTl9JRFMuU0VQT0xJQV1cbiAgICB9YCxcbiAgICBuZXR3b3JrSWQ6IENIQUlOX0lEX1RPX05FVFdPUktfSURfTUFQW0NIQUlOX0lEUy5TRVBPTElBXSxcbiAgfSxcbiAgW0NIQUlOX0lEUy5MSU5FQV9URVNUTkVUXToge1xuICAgIGRvbWFpbjogJ2xpbmVhLmJ1aWxkJyxcbiAgICBzdWJkb21haW46ICdleHBsb3Jlci5nb2VybGknLFxuICAgIG5ldHdvcmtJZDogQ0hBSU5fSURfVE9fTkVUV09SS19JRF9NQVBbQ0hBSU5fSURTLkxJTkVBX1RFU1RORVRdLFxuICB9LFxuICBbQ0hBSU5fSURTLkJTQ106IHtcbiAgICBkb21haW46ICdic2NzY2FuLmNvbScsXG4gICAgc3ViZG9tYWluOiBkZWZhdWx0RXRoZXJzY2FuU3ViZG9tYWluUHJlZml4LFxuICAgIG5ldHdvcmtJZDogcGFyc2VJbnQoQ0hBSU5fSURTLkJTQywgMTYpLnRvU3RyaW5nKCksXG4gIH0sXG4gIFtDSEFJTl9JRFMuQlNDX1RFU1RORVRdOiB7XG4gICAgZG9tYWluOiAnYnNjc2Nhbi5jb20nLFxuICAgIHN1YmRvbWFpbjogYCR7ZGVmYXVsdEV0aGVyc2NhblN1YmRvbWFpblByZWZpeH0tdGVzdG5ldGAsXG4gICAgbmV0d29ya0lkOiBwYXJzZUludChDSEFJTl9JRFMuQlNDX1RFU1RORVQsIDE2KS50b1N0cmluZygpLFxuICB9LFxuICBbQ0hBSU5fSURTLk9QVElNSVNNXToge1xuICAgIGRvbWFpbjogZGVmYXVsdEV0aGVyc2NhbkRvbWFpbixcbiAgICBzdWJkb21haW46IGAke2RlZmF1bHRFdGhlcnNjYW5TdWJkb21haW5QcmVmaXh9LW9wdGltaXN0aWNgLFxuICAgIG5ldHdvcmtJZDogcGFyc2VJbnQoQ0hBSU5fSURTLk9QVElNSVNNLCAxNikudG9TdHJpbmcoKSxcbiAgfSxcbiAgW0NIQUlOX0lEUy5PUFRJTUlTTV9URVNUTkVUXToge1xuICAgIGRvbWFpbjogZGVmYXVsdEV0aGVyc2NhbkRvbWFpbixcbiAgICBzdWJkb21haW46IGAke2RlZmF1bHRFdGhlcnNjYW5TdWJkb21haW5QcmVmaXh9LWdvZXJsaS1vcHRpbWlzdGljYCxcbiAgICBuZXR3b3JrSWQ6IHBhcnNlSW50KENIQUlOX0lEUy5PUFRJTUlTTV9URVNUTkVULCAxNikudG9TdHJpbmcoKSxcbiAgfSxcbiAgW0NIQUlOX0lEUy5QT0xZR09OXToge1xuICAgIGRvbWFpbjogJ3BvbHlnb25zY2FuLmNvbScsXG4gICAgc3ViZG9tYWluOiBkZWZhdWx0RXRoZXJzY2FuU3ViZG9tYWluUHJlZml4LFxuICAgIG5ldHdvcmtJZDogcGFyc2VJbnQoQ0hBSU5fSURTLlBPTFlHT04sIDE2KS50b1N0cmluZygpLFxuICB9LFxuICBbQ0hBSU5fSURTLlBPTFlHT05fVEVTVE5FVF06IHtcbiAgICBkb21haW46ICdwb2x5Z29uc2Nhbi5jb20nLFxuICAgIHN1YmRvbWFpbjogYCR7ZGVmYXVsdEV0aGVyc2NhblN1YmRvbWFpblByZWZpeH0tbXVtYmFpYCxcbiAgICBuZXR3b3JrSWQ6IHBhcnNlSW50KENIQUlOX0lEUy5QT0xZR09OX1RFU1RORVQsIDE2KS50b1N0cmluZygpLFxuICB9LFxuICBbQ0hBSU5fSURTLkFWQUxBTkNIRV06IHtcbiAgICBkb21haW46ICdzbm93dHJhY2UuaW8nLFxuICAgIHN1YmRvbWFpbjogZGVmYXVsdEV0aGVyc2NhblN1YmRvbWFpblByZWZpeCxcbiAgICBuZXR3b3JrSWQ6IHBhcnNlSW50KENIQUlOX0lEUy5BVkFMQU5DSEUsIDE2KS50b1N0cmluZygpLFxuICB9LFxuICBbQ0hBSU5fSURTLkFWQUxBTkNIRV9URVNUTkVUXToge1xuICAgIGRvbWFpbjogJ3Nub3d0cmFjZS5pbycsXG4gICAgc3ViZG9tYWluOiBgJHtkZWZhdWx0RXRoZXJzY2FuU3ViZG9tYWluUHJlZml4fS10ZXN0bmV0YCxcbiAgICBuZXR3b3JrSWQ6IHBhcnNlSW50KENIQUlOX0lEUy5BVkFMQU5DSEVfVEVTVE5FVCwgMTYpLnRvU3RyaW5nKCksXG4gIH0sXG4gIFtDSEFJTl9JRFMuRkFOVE9NXToge1xuICAgIGRvbWFpbjogJ2Z0bXNjYW4uY29tJyxcbiAgICBzdWJkb21haW46IGRlZmF1bHRFdGhlcnNjYW5TdWJkb21haW5QcmVmaXgsXG4gICAgbmV0d29ya0lkOiBwYXJzZUludChDSEFJTl9JRFMuRkFOVE9NLCAxNikudG9TdHJpbmcoKSxcbiAgfSxcbiAgW0NIQUlOX0lEUy5GQU5UT01fVEVTVE5FVF06IHtcbiAgICBkb21haW46ICdmdG1zY2FuLmNvbScsXG4gICAgc3ViZG9tYWluOiBgJHtkZWZhdWx0RXRoZXJzY2FuU3ViZG9tYWluUHJlZml4fS10ZXN0bmV0YCxcbiAgICBuZXR3b3JrSWQ6IHBhcnNlSW50KENIQUlOX0lEUy5GQU5UT01fVEVTVE5FVCwgMTYpLnRvU3RyaW5nKCksXG4gIH0sXG4gIFtDSEFJTl9JRFMuTU9PTkJFQU1dOiB7XG4gICAgZG9tYWluOiAnbW9vbnNjYW4uaW8nLFxuICAgIHN1YmRvbWFpbjogYCR7ZGVmYXVsdEV0aGVyc2NhblN1YmRvbWFpblByZWZpeH0tbW9vbmJlYW1gLFxuICAgIG5ldHdvcmtJZDogcGFyc2VJbnQoQ0hBSU5fSURTLk1PT05CRUFNLCAxNikudG9TdHJpbmcoKSxcbiAgfSxcbiAgW0NIQUlOX0lEUy5NT09OQkVBTV9URVNUTkVUXToge1xuICAgIGRvbWFpbjogJ21vb25zY2FuLmlvJyxcbiAgICBzdWJkb21haW46IGAke2RlZmF1bHRFdGhlcnNjYW5TdWJkb21haW5QcmVmaXh9LW1vb25iYXNlYCxcbiAgICBuZXR3b3JrSWQ6IHBhcnNlSW50KENIQUlOX0lEUy5NT09OQkVBTV9URVNUTkVULCAxNikudG9TdHJpbmcoKSxcbiAgfSxcbiAgW0NIQUlOX0lEUy5NT09OUklWRVJdOiB7XG4gICAgZG9tYWluOiAnbW9vbnNjYW4uaW8nLFxuICAgIHN1YmRvbWFpbjogYCR7ZGVmYXVsdEV0aGVyc2NhblN1YmRvbWFpblByZWZpeH0tbW9vbnJpdmVyYCxcbiAgICBuZXR3b3JrSWQ6IHBhcnNlSW50KENIQUlOX0lEUy5NT09OUklWRVIsIDE2KS50b1N0cmluZygpLFxuICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IENIQUlOX0lEX1RPX0dBU19MSU1JVF9CVUZGRVJfTUFQID0ge1xuICBbQ0hBSU5fSURTLk9QVElNSVNNXTogMSxcbiAgW0NIQUlOX0lEUy5PUFRJTUlTTV9URVNUTkVUXTogMSxcbn07XG5cbi8qKlxuICogRXRoZXJldW0gSlNPTi1SUEMgbWV0aG9kcyB0aGF0IGFyZSBrbm93biB0byBleGlzdCBidXQgdGhhdCB3ZSBpbnRlbnRpb25hbGx5XG4gKiBkbyBub3Qgc3VwcG9ydC5cbiAqL1xuZXhwb3J0IGNvbnN0IFVOU1VQUE9SVEVEX1JQQ19NRVRIT0RTID0gbmV3IFNldChbXG4gIC8vIFRoaXMgaXMgaW1wbGVtZW50ZWQgbGF0ZXIgaW4gb3VyIG1pZGRsZXdhcmUgc3RhY2sg4oCTIHNwZWNpZmljYWxseSwgaW5cbiAgLy8gZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUg4oCTIGJ1dCBvdXIgVUkgZG9lcyBub3Qgc3VwcG9ydCBpdC5cbiAgJ2V0aF9zaWduVHJhbnNhY3Rpb24nIGFzIGNvbnN0LFxuXSk7XG5cbmV4cG9ydCBjb25zdCBJUEZTX0RFRkFVTFRfR0FURVdBWV9VUkwgPSAnZHdlYi5saW5rJztcblxuLy8gVGhlIGZpcnN0IGl0ZW0gaW4gdHJhbnNha0N1cnJlbmNpZXMgbXVzdCBiZSB0aGVcbi8vIGRlZmF1bHQgY3J5cHRvIGN1cnJlbmN5IGZvciB0aGUgbmV0d29ya1xuY29uc3QgQlVZQUJMRV9DSEFJTl9FVEhFUkVVTV9ORVRXT1JLX05BTUUgPSAnZXRoZXJldW0nO1xuXG5leHBvcnQgY29uc3QgQlVZQUJMRV9DSEFJTlNfTUFQOiB7XG4gIFtLIGluIEV4Y2x1ZGU8XG4gICAgQ2hhaW5JZCxcbiAgICB8IHR5cGVvZiBDSEFJTl9JRFMuTE9DQUxIT1NUXG4gICAgfCB0eXBlb2YgQ0hBSU5fSURTLlBBTE1cbiAgICB8IHR5cGVvZiBDSEFJTl9JRFMuSEFSTU9OWVxuICAgIHwgdHlwZW9mIENIQUlOX0lEUy5PUFRJTUlTTV9URVNUTkVUXG4gICAgfCB0eXBlb2YgQ0hBSU5fSURTLkJTQ19URVNUTkVUXG4gICAgfCB0eXBlb2YgQ0hBSU5fSURTLlBPTFlHT05fVEVTVE5FVFxuICAgIHwgdHlwZW9mIENIQUlOX0lEUy5BVkFMQU5DSEVfVEVTVE5FVFxuICAgIHwgdHlwZW9mIENIQUlOX0lEUy5GQU5UT01fVEVTVE5FVFxuICAgIHwgdHlwZW9mIENIQUlOX0lEUy5NT09OQkVBTVxuICAgIHwgdHlwZW9mIENIQUlOX0lEUy5NT09OQkVBTV9URVNUTkVUXG4gICAgfCB0eXBlb2YgQ0hBSU5fSURTLk1PT05SSVZFUlxuICAgIHwgdHlwZW9mIENIQUlOX0lEUy5BVVJPUkFcbiAgICB8IHR5cGVvZiBDSEFJTl9JRFMuTElORUFfVEVTVE5FVFxuICAgIHwgdHlwZW9mIENIQUlOX0lEUy5HT0VSTElcbiAgPl06IEJ1eWFibGVDaGFpblNldHRpbmdzO1xufSA9IHtcbiAgW0NIQUlOX0lEUy5NQUlOTkVUXToge1xuICAgIG5hdGl2ZUN1cnJlbmN5OiBDVVJSRU5DWV9TWU1CT0xTLkVUSCxcbiAgICBuZXR3b3JrOiBCVVlBQkxFX0NIQUlOX0VUSEVSRVVNX05FVFdPUktfTkFNRSxcbiAgfSxcbiAgW0NIQUlOX0lEUy5TRVBPTElBXToge1xuICAgIG5hdGl2ZUN1cnJlbmN5OiBURVNUX05FVFdPUktfVElDS0VSX01BUFtORVRXT1JLX1RZUEVTLlNFUE9MSUFdLFxuICAgIG5ldHdvcms6IEJVWUFCTEVfQ0hBSU5fRVRIRVJFVU1fTkVUV09SS19OQU1FLFxuICB9LFxuICBbQ0hBSU5fSURTLkJTQ106IHtcbiAgICBuYXRpdmVDdXJyZW5jeTogQ1VSUkVOQ1lfU1lNQk9MUy5CTkIsXG4gICAgbmV0d29yazogJ2JzYycsXG4gIH0sXG4gIFtDSEFJTl9JRFMuUE9MWUdPTl06IHtcbiAgICBuYXRpdmVDdXJyZW5jeTogQ1VSUkVOQ1lfU1lNQk9MUy5NQVRJQyxcbiAgICBuZXR3b3JrOiAncG9seWdvbicsXG4gIH0sXG4gIFtDSEFJTl9JRFMuQVZBTEFOQ0hFXToge1xuICAgIG5hdGl2ZUN1cnJlbmN5OiBDVVJSRU5DWV9TWU1CT0xTLkFWQUxBTkNIRSxcbiAgICBuZXR3b3JrOiAnYXZheGNjaGFpbicsXG4gIH0sXG4gIFtDSEFJTl9JRFMuRkFOVE9NXToge1xuICAgIG5hdGl2ZUN1cnJlbmN5OiBDVVJSRU5DWV9TWU1CT0xTLkZBTlRPTSxcbiAgICBuZXR3b3JrOiAnZmFudG9tJyxcbiAgfSxcbiAgW0NIQUlOX0lEUy5DRUxPXToge1xuICAgIG5hdGl2ZUN1cnJlbmN5OiBDVVJSRU5DWV9TWU1CT0xTLkNFTE8sXG4gICAgbmV0d29yazogJ2NlbG8nLFxuICB9LFxuICBbQ0hBSU5fSURTLk9QVElNSVNNXToge1xuICAgIG5hdGl2ZUN1cnJlbmN5OiBDVVJSRU5DWV9TWU1CT0xTLkVUSCxcbiAgICBuZXR3b3JrOiAnb3B0aW1pc20nLFxuICB9LFxuICBbQ0hBSU5fSURTLkFSQklUUlVNXToge1xuICAgIG5hdGl2ZUN1cnJlbmN5OiBDVVJSRU5DWV9TWU1CT0xTLkFSQklUUlVNLFxuICAgIG5ldHdvcms6ICdhcmJpdHJ1bScsXG4gIH0sXG59O1xuXG5leHBvcnQgY29uc3QgRkVBVFVSRURfUlBDUzogUlBDRGVmaW5pdGlvbltdID0gW1xuICB7XG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLkFSQklUUlVNLFxuICAgIG5pY2tuYW1lOiBBUkJJVFJVTV9ESVNQTEFZX05BTUUsXG4gICAgcnBjVXJsOiBgaHR0cHM6Ly9hcmJpdHJ1bS1tYWlubmV0LmluZnVyYS5pby92My8ke2luZnVyYVByb2plY3RJZH1gLFxuICAgIHRpY2tlcjogQ1VSUkVOQ1lfU1lNQk9MUy5BUkJJVFJVTSxcbiAgICBycGNQcmVmczoge1xuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vZXhwbG9yZXIuYXJiaXRydW0uaW8nLFxuICAgICAgaW1hZ2VVcmw6IEFFVEhfVE9LRU5fSU1BR0VfVVJMLFxuICAgIH0sXG4gIH0sXG4gIHtcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuQVVST1JBLFxuICAgIG5pY2tuYW1lOiBBVVJPUkFfRElTUExBWV9OQU1FLFxuICAgIHJwY1VybDogYGh0dHBzOi8vYXVyb3JhLW1haW5uZXQuaW5mdXJhLmlvL3YzLyR7aW5mdXJhUHJvamVjdElkfWAsXG4gICAgdGlja2VyOiBDVVJSRU5DWV9TWU1CT0xTLkFVUk9SQV9FVEgsXG4gICAgcnBjUHJlZnM6IHtcbiAgICAgIGJsb2NrRXhwbG9yZXJVcmw6ICdodHRwczovL2F1cm9yYXNjYW4uZGV2LycsXG4gICAgICBpbWFnZVVybDogQVVST1JBX1RPS0VOX0lNQUdFX1VSTCxcbiAgICB9LFxuICB9LFxuICB7XG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLkFWQUxBTkNIRSxcbiAgICBuaWNrbmFtZTogQVZBTEFOQ0hFX0RJU1BMQVlfTkFNRSxcbiAgICBycGNVcmw6IGBodHRwczovL2F2YWxhbmNoZS1tYWlubmV0LmluZnVyYS5pby92My8ke2luZnVyYVByb2plY3RJZH1gLFxuICAgIHRpY2tlcjogQ1VSUkVOQ1lfU1lNQk9MUy5BVkFMQU5DSEUsXG4gICAgcnBjUHJlZnM6IHtcbiAgICAgIGJsb2NrRXhwbG9yZXJVcmw6ICdodHRwczovL3Nub3d0cmFjZS5pby8nLFxuICAgICAgaW1hZ2VVcmw6IEFWQVhfVE9LRU5fSU1BR0VfVVJMLFxuICAgIH0sXG4gIH0sXG4gIHtcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuQlNDLFxuICAgIG5pY2tuYW1lOiBCTkJfRElTUExBWV9OQU1FLFxuICAgIHJwY1VybDogJ2h0dHBzOi8vYnNjLWRhdGFzZWVkLmJpbmFuY2Uub3JnLycsXG4gICAgdGlja2VyOiBDVVJSRU5DWV9TWU1CT0xTLkJOQixcbiAgICBycGNQcmVmczoge1xuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vYnNjc2Nhbi5jb20vJyxcbiAgICAgIGltYWdlVXJsOiBCTkJfVE9LRU5fSU1BR0VfVVJMLFxuICAgIH0sXG4gIH0sXG4gIHtcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuRkFOVE9NLFxuICAgIG5pY2tuYW1lOiBGQU5UT01fRElTUExBWV9OQU1FLFxuICAgIHJwY1VybDogJ2h0dHBzOi8vcnBjLmZ0bS50b29scy8nLFxuICAgIHRpY2tlcjogQ1VSUkVOQ1lfU1lNQk9MUy5GQU5UT00sXG4gICAgcnBjUHJlZnM6IHtcbiAgICAgIGJsb2NrRXhwbG9yZXJVcmw6ICdodHRwczovL2Z0bXNjYW4uY29tLycsXG4gICAgICBpbWFnZVVybDogRlRNX1RPS0VOX0lNQUdFX1VSTCxcbiAgICB9LFxuICB9LFxuICB7XG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLkhBUk1PTlksXG4gICAgbmlja25hbWU6IEhBUk1PTllfRElTUExBWV9OQU1FLFxuICAgIHJwY1VybDogJ2h0dHBzOi8vYXBpLmhhcm1vbnkub25lLycsXG4gICAgdGlja2VyOiBDVVJSRU5DWV9TWU1CT0xTLkhBUk1PTlksXG4gICAgcnBjUHJlZnM6IHtcbiAgICAgIGJsb2NrRXhwbG9yZXJVcmw6ICdodHRwczovL2V4cGxvcmVyLmhhcm1vbnkub25lLycsXG4gICAgICBpbWFnZVVybDogSEFSTU9OWV9PTkVfVE9LRU5fSU1BR0VfVVJMLFxuICAgIH0sXG4gIH0sXG4gIHtcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuT1BUSU1JU00sXG4gICAgbmlja25hbWU6IE9QVElNSVNNX0RJU1BMQVlfTkFNRSxcbiAgICBycGNVcmw6IGBodHRwczovL29wdGltaXNtLW1haW5uZXQuaW5mdXJhLmlvL3YzLyR7aW5mdXJhUHJvamVjdElkfWAsXG4gICAgdGlja2VyOiBDVVJSRU5DWV9TWU1CT0xTLkVUSCxcbiAgICBycGNQcmVmczoge1xuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vb3B0aW1pc3RpYy5ldGhlcnNjYW4uaW8vJyxcbiAgICAgIGltYWdlVXJsOiBPUFRJTUlTTV9UT0tFTl9JTUFHRV9VUkwsXG4gICAgfSxcbiAgfSxcbiAge1xuICAgIGNoYWluSWQ6IENIQUlOX0lEUy5QQUxNLFxuICAgIG5pY2tuYW1lOiBQQUxNX0RJU1BMQVlfTkFNRSxcbiAgICBycGNVcmw6IGBodHRwczovL3BhbG0tbWFpbm5ldC5pbmZ1cmEuaW8vdjMvJHtpbmZ1cmFQcm9qZWN0SWR9YCxcbiAgICB0aWNrZXI6IENVUlJFTkNZX1NZTUJPTFMuUEFMTSxcbiAgICBycGNQcmVmczoge1xuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vZXhwbG9yZXIucGFsbS5pby8nLFxuICAgICAgaW1hZ2VVcmw6IFBBTE1fVE9LRU5fSU1BR0VfVVJMLFxuICAgIH0sXG4gIH0sXG4gIHtcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuUE9MWUdPTixcbiAgICBuaWNrbmFtZTogYCR7UE9MWUdPTl9ESVNQTEFZX05BTUV9ICR7Y2FwaXRhbGl6ZShORVRXT1JLX1RZUEVTLk1BSU5ORVQpfWAsXG4gICAgcnBjVXJsOiBgaHR0cHM6Ly9wb2x5Z29uLW1haW5uZXQuaW5mdXJhLmlvL3YzLyR7aW5mdXJhUHJvamVjdElkfWAsXG4gICAgdGlja2VyOiBDVVJSRU5DWV9TWU1CT0xTLk1BVElDLFxuICAgIHJwY1ByZWZzOiB7XG4gICAgICBibG9ja0V4cGxvcmVyVXJsOiAnaHR0cHM6Ly9wb2x5Z29uc2Nhbi5jb20vJyxcbiAgICAgIGltYWdlVXJsOiBNQVRJQ19UT0tFTl9JTUFHRV9VUkwsXG4gICAgfSxcbiAgfSxcbiAge1xuICAgIGNoYWluSWQ6IENIQUlOX0lEUy5DRUxPLFxuICAgIG5pY2tuYW1lOiBDRUxPX0RJU1BMQVlfTkFNRSxcbiAgICBycGNVcmw6IGBodHRwczovL2NlbG8tbWFpbm5ldC5pbmZ1cmEuaW8vdjMvJHtpbmZ1cmFQcm9qZWN0SWR9YCxcbiAgICB0aWNrZXI6IENVUlJFTkNZX1NZTUJPTFMuQ0VMTyxcbiAgICBycGNQcmVmczoge1xuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vY2Vsb3NjYW4uaW8nLFxuICAgICAgaW1hZ2VVcmw6IENFTE9fVE9LRU5fSU1BR0VfVVJMLFxuICAgIH0sXG4gIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgU0hPVUxEX1NIT1dfTElORUFfVEVTVE5FVF9ORVRXT1JLID1cbiAgbmV3IERhdGUoKS5nZXRUaW1lKCkgPiBEYXRlLlVUQygyMDIzLCAyLCAyOCwgOCk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgYXZhaWxhYmlsaXR5IHN0YXRlIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbmV0d29yay5cbiAqL1xuZXhwb3J0IGVudW0gTmV0d29ya1N0YXR1cyB7XG4gIC8qKlxuICAgKiBUaGUgbmV0d29yayBtYXkgb3IgbWF5IG5vdCBiZSBhYmxlIHRvIHJlY2VpdmUgcmVxdWVzdHMsIGJ1dCBlaXRoZXIgbm9cbiAgICogYXR0ZW1wdCBoYXMgYmVlbiBtYWRlIHRvIGRldGVybWluZSB0aGlzLCBvciBhbiBhdHRlbXB0IHdhcyBtYWRlIGJ1dCB3YXNcbiAgICogdW5zdWNjZXNzZnVsLlxuICAgKi9cbiAgVW5rbm93biA9ICd1bmtub3duJyxcbiAgLyoqXG4gICAqIFRoZSBuZXR3b3JrIGlzIGFibGUgdG8gcmVjZWl2ZSBhbmQgcmVzcG9uZCB0byByZXF1ZXN0cy5cbiAgICovXG4gIEF2YWlsYWJsZSA9ICdhdmFpbGFibGUnLFxuICAvKipcbiAgICogVGhlIG5ldHdvcmsgaXMgdW5hYmxlIHRvIHJlY2VpdmUgYW5kIHJlc3BvbmQgdG8gcmVxdWVzdHMgZm9yIHVua25vd25cbiAgICogcmVhc29ucy5cbiAgICovXG4gIFVuYXZhaWxhYmxlID0gJ3VuYXZhaWxhYmxlJyxcbiAgLyoqXG4gICAqIFRoZSBuZXR3b3JrIGlzIG5vdCBvbmx5IHVuYXZhaWxhYmxlLCBidXQgaXMgYWxzbyBpbmFjY2Vzc2libGUgZm9yIHRoZSB1c2VyXG4gICAqIHNwZWNpZmljYWxseSBiYXNlZCBvbiB0aGVpciBsb2NhdGlvbi4gVGhpcyBzdGF0ZSBvbmx5IGFwcGxpZXMgdG8gSW5mdXJhXG4gICAqIG5ldHdvcmtzLlxuICAgKi9cbiAgQmxvY2tlZCA9ICdibG9ja2VkJyxcbn1cbiIsImV4cG9ydCBjb25zdCBDYXZlYXRUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuICByZXN0cmljdFJldHVybmVkQWNjb3VudHM6ICdyZXN0cmljdFJldHVybmVkQWNjb3VudHMnIGFzIGNvbnN0LFxufSk7XG5cbmV4cG9ydCBjb25zdCBSZXN0cmljdGVkTWV0aG9kcyA9IE9iamVjdC5mcmVlemUoe1xuICBldGhfYWNjb3VudHM6ICdldGhfYWNjb3VudHMnLFxufSBhcyBjb25zdCk7XG5cbiIsImV4cG9ydCBlbnVtIFRoZW1lVHlwZSB7XG4gIGxpZ2h0ID0gJ2xpZ2h0JyxcbiAgZGFyayA9ICdkYXJrJyxcbiAgb3MgPSAnb3MnLFxufVxuIiwiaW1wb3J0IHtcbiAgRVRIX1RPS0VOX0lNQUdFX1VSTCxcbiAgVEVTVF9FVEhfVE9LRU5fSU1BR0VfVVJMLFxuICBCTkJfVE9LRU5fSU1BR0VfVVJMLFxuICBNQVRJQ19UT0tFTl9JTUFHRV9VUkwsXG4gIEFWQVhfVE9LRU5fSU1BR0VfVVJMLFxuICBDVVJSRU5DWV9TWU1CT0xTLFxuICBDSEFJTl9JRFMsXG59IGZyb20gJy4vbmV0d29yayc7XG5cbmV4cG9ydCBjb25zdCBRVU9URVNfRVhQSVJFRF9FUlJPUiA9ICdxdW90ZXMtZXhwaXJlZCc7XG5leHBvcnQgY29uc3QgU1dBUF9GQUlMRURfRVJST1IgPSAnc3dhcC1mYWlsZWQtZXJyb3InO1xuZXhwb3J0IGNvbnN0IEVSUk9SX0ZFVENISU5HX1FVT1RFUyA9ICdlcnJvci1mZXRjaGluZy1xdW90ZXMnO1xuZXhwb3J0IGNvbnN0IFFVT1RFU19OT1RfQVZBSUxBQkxFX0VSUk9SID0gJ3F1b3Rlcy1ub3QtYXZpbGFibGUnO1xuZXhwb3J0IGNvbnN0IENPTlRSQUNUX0RBVEFfRElTQUJMRURfRVJST1IgPSAnY29udHJhY3QtZGF0YS1kaXNhYmxlZCc7XG5leHBvcnQgY29uc3QgT0ZGTElORV9GT1JfTUFJTlRFTkFOQ0UgPSAnb2ZmbGluZS1mb3ItbWFpbnRlbmFuY2UnO1xuZXhwb3J0IGNvbnN0IFNXQVBTX0ZFVENIX09SREVSX0NPTkZMSUNUID0gJ3N3YXBzLWZldGNoLW9yZGVyLWNvbmZsaWN0JztcblxuLy8gQW4gYWRkcmVzcyB0aGF0IHRoZSBtZXRhc3dhcC1hcGkgcmVjb2duaXplcyBhcyB0aGUgZGVmYXVsdCB0b2tlbiBmb3IgdGhlIGN1cnJlbnQgbmV0d29yayxcbi8vIGluIHBsYWNlIG9mIHRoZSB0b2tlbiBhZGRyZXNzIHRoYXQgRVJDLTIwIHRva2VucyBoYXZlXG5jb25zdCBERUZBVUxUX1RPS0VOX0FERFJFU1MgPSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJztcblxuZXhwb3J0IGludGVyZmFjZSBTd2Fwc1Rva2VuT2JqZWN0IHtcbiAgLyoqXG4gICAqIFRoZSBzeW1ib2wgb2YgdG9rZW4gb2JqZWN0XG4gICAqL1xuICBzeW1ib2w6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBuYW1lIGZvciB0aGUgbmV0d29ya1xuICAgKi9cbiAgbmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogQW4gYWRkcmVzcyB0aGF0IHRoZSBtZXRhc3dhcC1hcGkgcmVjb2duaXplcyBhcyB0aGUgZGVmYXVsdCB0b2tlblxuICAgKi9cbiAgYWRkcmVzczogc3RyaW5nO1xuICAvKipcbiAgICogTnVtYmVyIG9mIGRpZ2l0cyBhZnRlciBkZWNpbWFsIHBvaW50XG4gICAqL1xuICBkZWNpbWFsczogbnVtYmVyO1xuICAvKipcbiAgICogVVJMIGZvciB0b2tlbiBpY29uXG4gICAqL1xuICBpY29uVXJsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBFVEhfU1dBUFNfVE9LRU5fT0JKRUNUOiBTd2Fwc1Rva2VuT2JqZWN0ID0ge1xuICBzeW1ib2w6IENVUlJFTkNZX1NZTUJPTFMuRVRILFxuICBuYW1lOiAnRXRoZXInLFxuICBhZGRyZXNzOiBERUZBVUxUX1RPS0VOX0FERFJFU1MsXG4gIGRlY2ltYWxzOiAxOCxcbiAgaWNvblVybDogRVRIX1RPS0VOX0lNQUdFX1VSTCxcbn07XG5cbmV4cG9ydCBjb25zdCBCTkJfU1dBUFNfVE9LRU5fT0JKRUNUOiBTd2Fwc1Rva2VuT2JqZWN0ID0ge1xuICBzeW1ib2w6IENVUlJFTkNZX1NZTUJPTFMuQk5CLFxuICBuYW1lOiAnQmluYW5jZSBDb2luJyxcbiAgYWRkcmVzczogREVGQVVMVF9UT0tFTl9BRERSRVNTLFxuICBkZWNpbWFsczogMTgsXG4gIGljb25Vcmw6IEJOQl9UT0tFTl9JTUFHRV9VUkwsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgTUFUSUNfU1dBUFNfVE9LRU5fT0JKRUNUOiBTd2Fwc1Rva2VuT2JqZWN0ID0ge1xuICBzeW1ib2w6IENVUlJFTkNZX1NZTUJPTFMuTUFUSUMsXG4gIG5hbWU6ICdNYXRpYycsXG4gIGFkZHJlc3M6IERFRkFVTFRfVE9LRU5fQUREUkVTUyxcbiAgZGVjaW1hbHM6IDE4LFxuICBpY29uVXJsOiBNQVRJQ19UT0tFTl9JTUFHRV9VUkwsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgQVZBWF9TV0FQU19UT0tFTl9PQkpFQ1Q6IFN3YXBzVG9rZW5PYmplY3QgPSB7XG4gIHN5bWJvbDogQ1VSUkVOQ1lfU1lNQk9MUy5BVkFMQU5DSEUsXG4gIG5hbWU6ICdBdmFsYW5jaGUnLFxuICBhZGRyZXNzOiBERUZBVUxUX1RPS0VOX0FERFJFU1MsXG4gIGRlY2ltYWxzOiAxOCxcbiAgaWNvblVybDogQVZBWF9UT0tFTl9JTUFHRV9VUkwsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgVEVTVF9FVEhfU1dBUFNfVE9LRU5fT0JKRUNUOiBTd2Fwc1Rva2VuT2JqZWN0ID0ge1xuICBzeW1ib2w6IENVUlJFTkNZX1NZTUJPTFMuVEVTVF9FVEgsXG4gIG5hbWU6ICdUZXN0IEV0aGVyJyxcbiAgYWRkcmVzczogREVGQVVMVF9UT0tFTl9BRERSRVNTLFxuICBkZWNpbWFsczogMTgsXG4gIGljb25Vcmw6IFRFU1RfRVRIX1RPS0VOX0lNQUdFX1VSTCxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBHT0VSTElfU1dBUFNfVE9LRU5fT0JKRUNUOiBTd2Fwc1Rva2VuT2JqZWN0ID0ge1xuICBzeW1ib2w6IENVUlJFTkNZX1NZTUJPTFMuRVRILFxuICBuYW1lOiAnRXRoZXInLFxuICBhZGRyZXNzOiBERUZBVUxUX1RPS0VOX0FERFJFU1MsXG4gIGRlY2ltYWxzOiAxOCxcbiAgaWNvblVybDogVEVTVF9FVEhfVE9LRU5fSU1BR0VfVVJMLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IEFSQklUUlVNX1NXQVBTX1RPS0VOX09CSkVDVDogU3dhcHNUb2tlbk9iamVjdCA9IHtcbiAgLi4uRVRIX1NXQVBTX1RPS0VOX09CSkVDVCxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBPUFRJTUlTTV9TV0FQU19UT0tFTl9PQkpFQ1Q6IFN3YXBzVG9rZW5PYmplY3QgPSB7XG4gIC4uLkVUSF9TV0FQU19UT0tFTl9PQkpFQ1QsXG59IGFzIGNvbnN0O1xuXG4vLyBBIGdhcyB2YWx1ZSBmb3IgRVJDMjAgYXBwcm92ZSBjYWxscyB0aGF0IHNob3VsZCBiZSBzdWZmaWNpZW50IGZvciBhbGwgRVJDMjAgYXBwcm92ZSBpbXBsZW1lbnRhdGlvbnNcbmV4cG9ydCBjb25zdCBERUZBVUxUX0VSQzIwX0FQUFJPVkVfR0FTID0gJzB4MWQ0YzAnO1xuXG4vLyBDb250cmFjdCBhZGRyZXNzZXMgYmVsb3cgc2hvdWxkIGJlIGluIGxvd2VyY2FzZS5cbmNvbnN0IE1BSU5ORVRfQ09OVFJBQ1RfQUREUkVTUyA9ICcweDg4MWQ0MDIzNzY1OWMyNTE4MTFjZWM5YzM2NGVmOTFkYzA4ZDMwMGMnO1xuY29uc3QgVEVTVE5FVF9DT05UUkFDVF9BRERSRVNTID0gJzB4ODgxZDQwMjM3NjU5YzI1MTgxMWNlYzljMzY0ZWY5MWRjMDhkMzAwYyc7XG5jb25zdCBCU0NfQ09OVFJBQ1RfQUREUkVTUyA9ICcweDFhMWVjMjVkYzA4ZTk4ZTVlOTNmMTEwNGI1ZTVjZGQyOTg3MDdkMzEnO1xuY29uc3QgUE9MWUdPTl9DT05UUkFDVF9BRERSRVNTID0gJzB4MWExZWMyNWRjMDhlOThlNWU5M2YxMTA0YjVlNWNkZDI5ODcwN2QzMSc7XG5jb25zdCBBVkFMQU5DSEVfQ09OVFJBQ1RfQUREUkVTUyA9ICcweDFhMWVjMjVkYzA4ZTk4ZTVlOTNmMTEwNGI1ZTVjZGQyOTg3MDdkMzEnO1xuY29uc3QgT1BUSU1JU01fQ09OVFJBQ1RfQUREUkVTUyA9ICcweDlkZGE2ZWYzZDkxOWM5YmM4ODg1ZDU1NjA5OTlhMzY0MDQzMWU4ZTYnO1xuY29uc3QgQVJCSVRSVU1fQ09OVFJBQ1RfQUREUkVTUyA9ICcweDlkZGE2ZWYzZDkxOWM5YmM4ODg1ZDU1NjA5OTlhMzY0MDQzMWU4ZTYnO1xuXG5leHBvcnQgY29uc3QgV0VUSF9DT05UUkFDVF9BRERSRVNTID1cbiAgJzB4YzAyYWFhMzliMjIzZmU4ZDBhMGU1YzRmMjdlYWQ5MDgzYzc1NmNjMic7XG5leHBvcnQgY29uc3QgV0VUSF9HT0VSTElfQ09OVFJBQ1RfQUREUkVTUyA9XG4gICcweEI0RkJGMjcxMTQzRjRGQmY3QjkxQTVkZWQzMTgwNWU0MmIyMjA4ZDYnO1xuZXhwb3J0IGNvbnN0IFdCTkJfQ09OVFJBQ1RfQUREUkVTUyA9XG4gICcweGJiNGNkYjljYmQzNmIwMWJkMWNiYWViZjJkZTA4ZDkxNzNiYzA5NWMnO1xuZXhwb3J0IGNvbnN0IFdNQVRJQ19DT05UUkFDVF9BRERSRVNTID1cbiAgJzB4MGQ1MDBiMWQ4ZThlZjMxZTIxYzk5ZDFkYjlhNjQ0NGQzYWRmMTI3MCc7XG5leHBvcnQgY29uc3QgV0FWQVhfQ09OVFJBQ1RfQUREUkVTUyA9XG4gICcweGIzMWY2NmFhM2MxZTc4NTM2M2YwODc1YTFiNzRlMjdiODVmZDY2YzcnO1xuXG5leHBvcnQgY29uc3QgV0VUSF9PUFRJTUlTTV9DT05UUkFDVF9BRERSRVNTID1cbiAgJzB4NDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNic7XG5leHBvcnQgY29uc3QgV0VUSF9BUkJJVFJVTV9DT05UUkFDVF9BRERSRVNTID1cbiAgJzB4ODJhZjQ5NDQ3ZDhhMDdlM2JkOTViZDBkNTZmMzUyNDE1MjNmYmFiMSc7XG5cbmNvbnN0IFNXQVBTX1RFU1RORVRfQ0hBSU5fSUQgPSAnMHg1MzknO1xuXG5leHBvcnQgY29uc3QgU1dBUFNfQVBJX1YyX0JBU0VfVVJMID0gJ2h0dHBzOi8vc3dhcC5tZXRhc3dhcC5jb2RlZmkubmV0d29yayc7XG5leHBvcnQgY29uc3QgU1dBUFNfREVWX0FQSV9WMl9CQVNFX1VSTCA9ICdodHRwczovL3N3YXAuZGV2LWFwaS5jeC5tZXRhbWFzay5pbyc7XG5leHBvcnQgY29uc3QgR0FTX0FQSV9CQVNFX1VSTCA9ICdodHRwczovL2dhcy1hcGkubWV0YXN3YXAuY29kZWZpLm5ldHdvcmsnO1xuZXhwb3J0IGNvbnN0IEdBU19ERVZfQVBJX0JBU0VfVVJMID1cbiAgJ2h0dHBzOi8vZ2FzLWFwaS5tZXRhc3dhcC1kZXYuY29kZWZpLm5ldHdvcmsnO1xuXG5jb25zdCBCU0NfREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwgPSAnaHR0cHM6Ly9ic2NzY2FuLmNvbS8nO1xuY29uc3QgTUFJTk5FVF9ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTCA9ICdodHRwczovL2V0aGVyc2Nhbi5pby8nO1xuY29uc3QgR09FUkxJX0RFRkFVTFRfQkxPQ0tfRVhQTE9SRVJfVVJMID0gJ2h0dHBzOi8vZ29lcmxpLmV0aGVyc2Nhbi5pby8nO1xuY29uc3QgUE9MWUdPTl9ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTCA9ICdodHRwczovL3BvbHlnb25zY2FuLmNvbS8nO1xuY29uc3QgQVZBTEFOQ0hFX0RFRkFVTFRfQkxPQ0tfRVhQTE9SRVJfVVJMID0gJ2h0dHBzOi8vc25vd3RyYWNlLmlvLyc7XG5jb25zdCBPUFRJTUlTTV9ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTCA9ICdodHRwczovL29wdGltaXN0aWMuZXRoZXJzY2FuLmlvLyc7XG5jb25zdCBBUkJJVFJVTV9ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTCA9ICdodHRwczovL2FyYmlzY2FuLmlvLyc7XG5cbmV4cG9ydCBjb25zdCBBTExPV0VEX1BST0RfU1dBUFNfQ0hBSU5fSURTID0gW1xuICBDSEFJTl9JRFMuTUFJTk5FVCxcbiAgU1dBUFNfVEVTVE5FVF9DSEFJTl9JRCxcbiAgQ0hBSU5fSURTLkJTQyxcbiAgQ0hBSU5fSURTLlBPTFlHT04sXG4gIENIQUlOX0lEUy5BVkFMQU5DSEUsXG4gIENIQUlOX0lEUy5PUFRJTUlTTSxcbiAgQ0hBSU5fSURTLkFSQklUUlVNLFxuXSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IEFMTE9XRURfREVWX1NXQVBTX0NIQUlOX0lEUyA9IFtcbiAgLi4uQUxMT1dFRF9QUk9EX1NXQVBTX0NIQUlOX0lEUyxcbiAgQ0hBSU5fSURTLkdPRVJMSSxcbl0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBBTExPV0VEX1NNQVJUX1RSQU5TQUNUSU9OU19DSEFJTl9JRFMgPSBbXG4gIENIQUlOX0lEUy5NQUlOTkVULFxuICBDSEFJTl9JRFMuR09FUkxJLFxuXSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IFNXQVBTX0NIQUlOSURfQ09OVFJBQ1RfQUREUkVTU19NQVAgPSB7XG4gIFtDSEFJTl9JRFMuTUFJTk5FVF06IE1BSU5ORVRfQ09OVFJBQ1RfQUREUkVTUyxcbiAgW1NXQVBTX1RFU1RORVRfQ0hBSU5fSURdOiBURVNUTkVUX0NPTlRSQUNUX0FERFJFU1MsXG4gIFtDSEFJTl9JRFMuQlNDXTogQlNDX0NPTlRSQUNUX0FERFJFU1MsXG4gIFtDSEFJTl9JRFMuUE9MWUdPTl06IFBPTFlHT05fQ09OVFJBQ1RfQUREUkVTUyxcbiAgW0NIQUlOX0lEUy5HT0VSTEldOiBURVNUTkVUX0NPTlRSQUNUX0FERFJFU1MsXG4gIFtDSEFJTl9JRFMuQVZBTEFOQ0hFXTogQVZBTEFOQ0hFX0NPTlRSQUNUX0FERFJFU1MsXG4gIFtDSEFJTl9JRFMuT1BUSU1JU01dOiBPUFRJTUlTTV9DT05UUkFDVF9BRERSRVNTLFxuICBbQ0hBSU5fSURTLkFSQklUUlVNXTogQVJCSVRSVU1fQ09OVFJBQ1RfQUREUkVTUyxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVMgPSB7XG4gIFtDSEFJTl9JRFMuTUFJTk5FVF06IFdFVEhfQ09OVFJBQ1RfQUREUkVTUyxcbiAgW1NXQVBTX1RFU1RORVRfQ0hBSU5fSURdOiBXRVRIX0NPTlRSQUNUX0FERFJFU1MsXG4gIFtDSEFJTl9JRFMuQlNDXTogV0JOQl9DT05UUkFDVF9BRERSRVNTLFxuICBbQ0hBSU5fSURTLlBPTFlHT05dOiBXTUFUSUNfQ09OVFJBQ1RfQUREUkVTUyxcbiAgW0NIQUlOX0lEUy5HT0VSTEldOiBXRVRIX0dPRVJMSV9DT05UUkFDVF9BRERSRVNTLFxuICBbQ0hBSU5fSURTLkFWQUxBTkNIRV06IFdBVkFYX0NPTlRSQUNUX0FERFJFU1MsXG4gIFtDSEFJTl9JRFMuT1BUSU1JU01dOiBXRVRIX09QVElNSVNNX0NPTlRSQUNUX0FERFJFU1MsXG4gIFtDSEFJTl9JRFMuQVJCSVRSVU1dOiBXRVRIX0FSQklUUlVNX0NPTlRSQUNUX0FERFJFU1MsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgQUxMT1dFRF9DT05UUkFDVF9BRERSRVNTRVMgPSB7XG4gIFtDSEFJTl9JRFMuTUFJTk5FVF06IFtcbiAgICBTV0FQU19DSEFJTklEX0NPTlRSQUNUX0FERFJFU1NfTUFQW0NIQUlOX0lEUy5NQUlOTkVUXSxcbiAgICBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVNbQ0hBSU5fSURTLk1BSU5ORVRdLFxuICBdLFxuICBbU1dBUFNfVEVTVE5FVF9DSEFJTl9JRF06IFtcbiAgICBTV0FQU19DSEFJTklEX0NPTlRSQUNUX0FERFJFU1NfTUFQW1NXQVBTX1RFU1RORVRfQ0hBSU5fSURdLFxuICAgIFNXQVBTX1dSQVBQRURfVE9LRU5TX0FERFJFU1NFU1tTV0FQU19URVNUTkVUX0NIQUlOX0lEXSxcbiAgXSxcbiAgW0NIQUlOX0lEUy5HT0VSTEldOiBbXG4gICAgU1dBUFNfQ0hBSU5JRF9DT05UUkFDVF9BRERSRVNTX01BUFtDSEFJTl9JRFMuR09FUkxJXSxcbiAgICBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVNbQ0hBSU5fSURTLkdPRVJMSV0sXG4gIF0sXG4gIFtDSEFJTl9JRFMuQlNDXTogW1xuICAgIFNXQVBTX0NIQUlOSURfQ09OVFJBQ1RfQUREUkVTU19NQVBbQ0hBSU5fSURTLkJTQ10sXG4gICAgU1dBUFNfV1JBUFBFRF9UT0tFTlNfQUREUkVTU0VTW0NIQUlOX0lEUy5CU0NdLFxuICBdLFxuICBbQ0hBSU5fSURTLlBPTFlHT05dOiBbXG4gICAgU1dBUFNfQ0hBSU5JRF9DT05UUkFDVF9BRERSRVNTX01BUFtDSEFJTl9JRFMuUE9MWUdPTl0sXG4gICAgU1dBUFNfV1JBUFBFRF9UT0tFTlNfQUREUkVTU0VTW0NIQUlOX0lEUy5QT0xZR09OXSxcbiAgXSxcbiAgW0NIQUlOX0lEUy5BVkFMQU5DSEVdOiBbXG4gICAgU1dBUFNfQ0hBSU5JRF9DT05UUkFDVF9BRERSRVNTX01BUFtDSEFJTl9JRFMuQVZBTEFOQ0hFXSxcbiAgICBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVNbQ0hBSU5fSURTLkFWQUxBTkNIRV0sXG4gIF0sXG4gIFtDSEFJTl9JRFMuT1BUSU1JU01dOiBbXG4gICAgU1dBUFNfQ0hBSU5JRF9DT05UUkFDVF9BRERSRVNTX01BUFtDSEFJTl9JRFMuT1BUSU1JU01dLFxuICAgIFNXQVBTX1dSQVBQRURfVE9LRU5TX0FERFJFU1NFU1tDSEFJTl9JRFMuT1BUSU1JU01dLFxuICBdLFxuICBbQ0hBSU5fSURTLkFSQklUUlVNXTogW1xuICAgIFNXQVBTX0NIQUlOSURfQ09OVFJBQ1RfQUREUkVTU19NQVBbQ0hBSU5fSURTLkFSQklUUlVNXSxcbiAgICBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVNbQ0hBSU5fSURTLkFSQklUUlVNXSxcbiAgXSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBTV0FQU19DSEFJTklEX0RFRkFVTFRfVE9LRU5fTUFQID0ge1xuICBbQ0hBSU5fSURTLk1BSU5ORVRdOiBFVEhfU1dBUFNfVE9LRU5fT0JKRUNULFxuICBbU1dBUFNfVEVTVE5FVF9DSEFJTl9JRF06IFRFU1RfRVRIX1NXQVBTX1RPS0VOX09CSkVDVCxcbiAgW0NIQUlOX0lEUy5CU0NdOiBCTkJfU1dBUFNfVE9LRU5fT0JKRUNULFxuICBbQ0hBSU5fSURTLlBPTFlHT05dOiBNQVRJQ19TV0FQU19UT0tFTl9PQkpFQ1QsXG4gIFtDSEFJTl9JRFMuR09FUkxJXTogR09FUkxJX1NXQVBTX1RPS0VOX09CSkVDVCxcbiAgW0NIQUlOX0lEUy5BVkFMQU5DSEVdOiBBVkFYX1NXQVBTX1RPS0VOX09CSkVDVCxcbiAgW0NIQUlOX0lEUy5PUFRJTUlTTV06IE9QVElNSVNNX1NXQVBTX1RPS0VOX09CSkVDVCxcbiAgW0NIQUlOX0lEUy5BUkJJVFJVTV06IEFSQklUUlVNX1NXQVBTX1RPS0VOX09CSkVDVCxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBTV0FQU19DSEFJTklEX0RFRkFVTFRfQkxPQ0tfRVhQTE9SRVJfVVJMX01BUCA9IHtcbiAgW0NIQUlOX0lEUy5CU0NdOiBCU0NfREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwsXG4gIFtDSEFJTl9JRFMuTUFJTk5FVF06IE1BSU5ORVRfREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwsXG4gIFtDSEFJTl9JRFMuUE9MWUdPTl06IFBPTFlHT05fREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwsXG4gIFtDSEFJTl9JRFMuR09FUkxJXTogR09FUkxJX0RFRkFVTFRfQkxPQ0tfRVhQTE9SRVJfVVJMLFxuICBbQ0hBSU5fSURTLkFWQUxBTkNIRV06IEFWQUxBTkNIRV9ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTCxcbiAgW0NIQUlOX0lEUy5PUFRJTUlTTV06IE9QVElNSVNNX0RFRkFVTFRfQkxPQ0tfRVhQTE9SRVJfVVJMLFxuICBbQ0hBSU5fSURTLkFSQklUUlVNXTogQVJCSVRSVU1fREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgRVRIRVJFVU0gPSAnZXRoZXJldW0nO1xuZXhwb3J0IGNvbnN0IFBPTFlHT04gPSAncG9seWdvbic7XG5leHBvcnQgY29uc3QgQlNDID0gJ2JzYyc7XG5leHBvcnQgY29uc3QgR09FUkxJID0gJ2dvZXJsaSc7XG5leHBvcnQgY29uc3QgQVZBTEFOQ0hFID0gJ2F2YWxhbmNoZSc7XG5leHBvcnQgY29uc3QgT1BUSU1JU00gPSAnb3B0aW1pc20nO1xuZXhwb3J0IGNvbnN0IEFSQklUUlVNID0gJ2FyYml0cnVtJztcblxuZXhwb3J0IGNvbnN0IFNXQVBTX0NMSUVOVF9JRCA9ICdleHRlbnNpb24nO1xuXG5leHBvcnQgZW51bSBUb2tlbkJ1Y2tldFByaW9yaXR5IHtcbiAgb3duZWQgPSAnb3duZWQnLFxuICB0b3AgPSAndG9wJyxcbn1cblxuZXhwb3J0IGVudW0gU2xpcHBhZ2Uge1xuICBkZWZhdWx0ID0gMixcbiAgaGlnaCA9IDMsXG59XG4iLCJleHBvcnQgY29uc3QgTUlMTElTRUNPTkQgPSAxO1xuZXhwb3J0IGNvbnN0IFNFQ09ORCA9IE1JTExJU0VDT05EICogMTAwMDtcbmV4cG9ydCBjb25zdCBNSU5VVEUgPSBTRUNPTkQgKiA2MDtcbmV4cG9ydCBjb25zdCBIT1VSID0gTUlOVVRFICogNjA7XG5leHBvcnQgY29uc3QgREFZID0gSE9VUiAqIDI0O1xuIiwiaW1wb3J0IGNvbnRyYWN0TWFwIGZyb20gJ0BtZXRhbWFzay9jb250cmFjdC1tZXRhZGF0YSc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5cbi8qKlxuICogQSBub3JtYWxpemVkIGxpc3Qgb2YgYWRkcmVzc2VzIGV4cG9ydGVkIGFzIHBhcnQgb2YgdGhlIGNvbnRyYWN0TWFwIGluXG4gKiBgQG1ldGFtYXNrL2NvbnRyYWN0LW1ldGFkYXRhYC4gVXNlZCBwcmltYXJpbHkgdG8gdmFsaWRhdGUgaWYgbWFudWFsbHkgZW50ZXJlZFxuICogY29udHJhY3QgYWRkcmVzc2VzIGRvIG5vdCBtYXRjaCBvbmUgb2Ygb3VyIGxpc3RlZCB0b2tlbnNcbiAqL1xuZXhwb3J0IGNvbnN0IExJU1RFRF9DT05UUkFDVF9BRERSRVNTRVMgPSBPYmplY3Qua2V5cyhjb250cmFjdE1hcCkubWFwKFxuICAoYWRkcmVzcykgPT4gYWRkcmVzcy50b0xvd2VyQ2FzZSgpLFxuKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUb2tlbkRldGFpbHNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIHNlbGVjdGVkICdUT0tFTicgb3JcbiAqICAnTkZUJyBjb250cmFjdC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3ltYm9sXSAtIFRoZSBzeW1ib2wgb2YgdGhlIHRva2VuLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkZWNpbWFsc10gLSBUaGUgbnVtYmVyIG9mIGRlY2ltYWxzIG9mIHRoZSBzZWxlY3RlZFxuICogICdFUkMyMCcgYXNzZXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3Rva2VuSWRdIC0gVGhlIGlkIG9mIHRoZSBzZWxlY3RlZCAnTkZUJyBhc3NldC5cbiAqIEBwcm9wZXJ0eSB7VG9rZW5TdGFuZGFyZFN0cmluZ3N9IFtzdGFuZGFyZF0gLSBUaGUgc3RhbmRhcmQgb2YgdGhlIHNlbGVjdGVkXG4gKiAgYXNzZXQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpc0VSQzcyMV0gLSBUcnVlIHdoZW4gdGhlIGFzc2V0IGlzIGEgRVJDNzIxIHRva2VuLlxuICovXG5leHBvcnQgY29uc3QgU1RBVElDX01BSU5ORVRfVE9LRU5fTElTVCA9IE9iamVjdC5rZXlzKGNvbnRyYWN0TWFwKS5yZWR1Y2UoXG4gIChhY2MsIGJhc2UpID0+IHtcbiAgICBjb25zdCB7IGxvZ28sIC4uLnRva2VuTWV0YWRhdGEgfSA9IGNvbnRyYWN0TWFwW2Jhc2VdO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5hY2MsXG4gICAgICBbYmFzZS50b0xvd2VyQ2FzZSgpXToge1xuICAgICAgICAuLi50b2tlbk1ldGFkYXRhLFxuICAgICAgICBhZGRyZXNzOiBiYXNlLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIGljb25Vcmw6IGBpbWFnZXMvY29udHJhY3QvJHtsb2dvfWAsXG4gICAgICAgIGFnZ3JlZ2F0b3JzOiBbXSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbiAge30sXG4pO1xuXG5leHBvcnQgY29uc3QgVE9LRU5fQVBJX01FVEFTV0FQX0NPREVGSV9VUkwgPVxuICAnaHR0cHM6Ly90b2tlbi1hcGkubWV0YXN3YXAuY29kZWZpLm5ldHdvcmsvdG9rZW5zLyc7XG5leHBvcnQgY29uc3QgTUFYX1RPS0VOX0FMTE9XQU5DRV9BTU9VTlQgPSBuZXcgQmlnTnVtYmVyKDIpXG4gIC5wb3coMjU2KVxuICAubWludXMoMSlcbiAgLnRvU3RyaW5nKDEwKTtcbi8vIG51bWJlciB3aXRoIG9wdGlvbmFsIGRlY2ltYWwgcG9pbnQgdXNpbmcgYSBjb21tYSBvciBkb3RcbmV4cG9ydCBjb25zdCBOVU1fV19PUFRfREVDSU1BTF9DT01NQV9PUl9ET1RfUkVHRVggPVxuICAvXlswLTldezEsfShbLC5dWzAtOV17MSx9KT8kL3U7XG5leHBvcnQgY29uc3QgREVDSU1BTF9SRUdFWCA9IC9cXC4oXFxkKikvdTtcbiIsImltcG9ydCB7IEFjY2Vzc0xpc3QgfSBmcm9tICdAZXRoZXJldW1qcy90eCc7XG5cbmV4cG9ydCBlbnVtIFRyYW5zYWN0aW9uVHlwZSB7XG4gIC8qKlxuICAgKiBBIHRyYW5zYWN0aW9uIHN1Ym1pdHRlZCB3aXRoIHRoZSBzYW1lIG5vbmNlIGFzIGEgcHJldmlvdXMgdHJhbnNhY3Rpb24sIGFcbiAgICogaGlnaGVyIGdhcyBwcmljZSBhbmQgYSB6ZXJvZWQgb3V0IHNlbmQgYW1vdW50LiBVc2VmdWwgZm9yIHVzZXJzIHdob1xuICAgKiBhY2NpZGVudGFsbHkgc2VuZCB0byBlcnJvbmVvdXMgYWRkcmVzc2VzIG9yIGlmIHRoZXkgc2VuZCB0b28gbXVjaC5cbiAgICovXG4gIGNhbmNlbCA9ICdjYW5jZWwnLFxuICAvKipcbiAgICogQSB0cmFuc2FjdGlvbiB0aGF0IGlzIGludGVyYWN0aW5nIHdpdGggYSBzbWFydCBjb250cmFjdCdzIG1ldGhvZHMgdGhhdCB3ZVxuICAgKiBoYXZlIG5vdCB0cmVhdGVkIGFzIGEgc3BlY2lhbCBjYXNlLCBzdWNoIGFzIGFwcHJvdmUsIHRyYW5zZmVyLCBhbmRcbiAgICogdHJhbnNmZXJmcm9tXG4gICAqL1xuICBjb250cmFjdEludGVyYWN0aW9uID0gJ2NvbnRyYWN0SW50ZXJhY3Rpb24nLFxuICAvKipcbiAgICogQSB0cmFuc2FjdGlvbiB0aGF0IGRlcGxveWVkIGEgc21hcnQgY29udHJhY3RcbiAgICovXG4gIGRlcGxveUNvbnRyYWN0ID0gJ2NvbnRyYWN0RGVwbG95bWVudCcsXG4gIGV0aERlY3J5cHQgPSAnZXRoX2RlY3J5cHQnLFxuICBldGhHZXRFbmNyeXB0aW9uUHVibGljS2V5ID0gJ2V0aF9nZXRFbmNyeXB0aW9uUHVibGljS2V5JyxcbiAgLyoqXG4gICAqIEFuIGluY29taW5nIChkZXBvc2l0KSB0cmFuc2FjdGlvblxuICAgKi9cbiAgaW5jb21pbmcgPSAnaW5jb21pbmcnLFxuICBwZXJzb25hbFNpZ24gPSAncGVyc29uYWxfc2lnbicsXG4gIC8qKlxuICAgKiBXaGVuIGEgdHJhbnNhY3Rpb24gaXMgZmFpbGVkIGl0IGNhbiBiZSByZXRyaWVkIGJ5XG4gICAqIHJlc3VibWl0dGluZyB0aGUgc2FtZSB0cmFuc2FjdGlvbiB3aXRoIGEgaGlnaGVyIGdhcyBmZWUuIFRoaXMgdHlwZSBpcyBhbHNvIHVzZWRcbiAgICogdG8gc3BlZWQgdXAgcGVuZGluZyB0cmFuc2FjdGlvbnMuIFRoaXMgaXMgYWNjb21wbGlzaGVkIGJ5IGNyZWF0aW5nIGEgbmV3IHR4IHdpdGhcbiAgICogdGhlIHNhbWUgbm9uY2UgYW5kIGhpZ2hlciBnYXMgZmVlcy5cbiAgICovXG4gIHJldHJ5ID0gJ3JldHJ5JyxcbiAgc2lnbiA9ICdldGhfc2lnbicsXG4gIHNpZ25UeXBlZERhdGEgPSAnZXRoX3NpZ25UeXBlZERhdGEnLFxuICAvKiogQSB0cmFuc2FjdGlvbiBzZW5kaW5nIGEgbmV0d29yaydzIG5hdGl2ZSBhc3NldCB0byBhIHJlY2lwaWVudCAqL1xuICBzaW1wbGVTZW5kID0gJ3NpbXBsZVNlbmQnLFxuICBzbWFydCA9ICdzbWFydCcsXG4gIC8qKlxuICAgKiBBIHRyYW5zYWN0aW9uIHN3YXBwaW5nIG9uZSB0b2tlbiBmb3IgYW5vdGhlciB0aHJvdWdoIE1ldGFNYXNrIFN3YXBzXG4gICAqL1xuICBzd2FwID0gJ3N3YXAnLFxuICAvKipcbiAgICogU2ltaWxhciB0byB0aGUgYXBwcm92ZSB0eXBlLCBhIHN3YXAgYXBwcm92YWwgaXMgYSBzcGVjaWFsIGNhc2Ugb2YgRVJDMjBcbiAgICogYXBwcm92ZSBtZXRob2QgdGhhdCByZXF1ZXN0cyBhbiBhbGxvd2FuY2Ugb2YgdGhlIHRva2VuIHRvIHNwZW5kIG9uIGJlaGFsZlxuICAgKiBvZiB0aGUgdXNlciBmb3IgdGhlIE1ldGFNYXNrIFN3YXBzIGNvbnRyYWN0LiBUaGUgZmlyc3Qgc3dhcCBmb3IgYW55IHRva2VuXG4gICAqIHdpbGwgaGF2ZSBhbiBhY2NvbXBhbnlpbmcgc3dhcEFwcHJvdmFsIHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgc3dhcEFwcHJvdmFsID0gJ3N3YXBBcHByb3ZhbCcsXG4gIC8qKlxuICAgKiBBIHRva2VuIHRyYW5zYWN0aW9uIHJlcXVlc3RpbmcgYW4gYWxsb3dhbmNlIG9mIHRoZSB0b2tlbiB0byBzcGVuZCBvblxuICAgKiBiZWhhbGYgb2YgdGhlIHVzZXJcbiAgICovXG4gIHRva2VuTWV0aG9kQXBwcm92ZSA9ICdhcHByb3ZlJyxcbiAgLyoqXG4gICAqIEEgdG9rZW4gdHJhbnNhY3Rpb24gdHJhbnNmZXJyaW5nIHRva2VucyBmcm9tIGFuIGFjY291bnQgdGhhdCB0aGUgc2VuZGVyXG4gICAqIGhhcyBhbiBhbGxvd2FuY2Ugb2YuIFRoZSBtZXRob2QgaXMgcHJlZml4ZWQgd2l0aCBzYWZlIGJlY2F1c2Ugd2hlbiBjYWxsaW5nXG4gICAqIHRoaXMgbWV0aG9kIHRoZSBjb250cmFjdCBjaGVja3MgdG8gZW5zdXJlIHRoYXQgdGhlIHJlY2VpdmVyIGlzIGFuIGFkZHJlc3NcbiAgICogY2FwYWJsZSBvZiBoYW5kbGluZyB3aXRoIHRoZSB0b2tlbiBiZWluZyBzZW50LlxuICAgKi9cbiAgdG9rZW5NZXRob2RTYWZlVHJhbnNmZXJGcm9tID0gJ3NhZmV0cmFuc2ZlcmZyb20nLFxuICAvKipcbiAgICogQSB0b2tlbiB0cmFuc2FjdGlvbiB3aGVyZSB0aGUgdXNlciBpcyBzZW5kaW5nIHRva2VucyB0aGF0IHRoZXkgb3duIHRvXG4gICAqIGFub3RoZXIgYWRkcmVzc1xuICAgKi9cbiAgdG9rZW5NZXRob2RUcmFuc2ZlciA9ICd0cmFuc2ZlcicsXG4gIC8qKlxuICAgKiBBIHRva2VuIHRyYW5zYWN0aW9uIHRyYW5zZmVycmluZyB0b2tlbnMgZnJvbSBhbiBhY2NvdW50IHRoYXQgdGhlIHNlbmRlclxuICAgKiBoYXMgYW4gYWxsb3dhbmNlIG9mLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBhbGxvd2FuY2VzLCBzZWUgdGhlIGFwcHJvdmVcbiAgICogdHlwZS5cbiAgICovXG4gIHRva2VuTWV0aG9kVHJhbnNmZXJGcm9tID0gJ3RyYW5zZmVyZnJvbScsXG4gIC8qKlxuICAgKiBBIHRva2VuIHRyYW5zYWN0aW9uIHJlcXVlc3RpbmcgYW4gYWxsb3dhbmNlIG9mIGFsbCBvZiBhIHVzZXIncyB0b2tlbiB0b1xuICAgKiBzcGVuZCBvbiBiZWhhbGYgb2YgdGhlIHVzZXJcbiAgICovXG4gIHRva2VuTWV0aG9kU2V0QXBwcm92YWxGb3JBbGwgPSAnc2V0YXBwcm92YWxmb3JhbGwnLFxufVxuXG4vKipcbiAqIEluIEVJUC0yNzE4IHR5cGVkIHRyYW5zYWN0aW9uIGVudmVsb3BlcyB3ZXJlIHNwZWNpZmllZCwgd2l0aCB0aGUgdmVyeSBmaXJzdFxuICogdHlwZWQgZW52ZWxvcGUgYmVpbmcgJ2xlZ2FjeScgYW5kIGRlc2NyaWJpbmcgdGhlIHNoYXBlIG9mIHRoZSBiYXNlXG4gKiB0cmFuc2FjdGlvbiBwYXJhbXMgdGhhdCB3ZXJlIGhpdGhlcnRvIHRoZSBvbmx5IHRyYW5zYWN0aW9uIHR5cGUgc2VudCBvblxuICogRXRoZXJldW0uXG4gKi9cbmV4cG9ydCBlbnVtIFRyYW5zYWN0aW9uRW52ZWxvcGVUeXBlIHtcbiAgLyoqXG4gICAqIEEgbGVnYWN5IHRyYW5zYWN0aW9uLCB0aGUgdmVyeSBmaXJzdCB0eXBlLlxuICAgKi9cbiAgbGVnYWN5ID0gJzB4MCcsXG4gIC8qKlxuICAgKiBFSVAtMjkzMCBkZWZpbmVkIHRoZSBhY2Nlc3MgbGlzdCB0cmFuc2FjdGlvbiB0eXBlIHRoYXQgYWxsb3dlZCBmb3JcbiAgICogc3BlY2lmeWluZyB0aGUgc3RhdGUgdGhhdCBhIHRyYW5zYWN0aW9uIHdvdWxkIGFjdCB1cG9uIGluIGFkdmFuY2UgYW5kXG4gICAqIHRoZW9yZXRpY2FsbHkgc2F2ZSBvbiBnYXMgZmVlcy5cbiAgICovXG4gIGFjY2Vzc0xpc3QgPSAnMHgxJyxcbiAgLyoqXG4gICAqIFRoZSB0eXBlIGludHJvZHVjZWQgY29tZXMgZnJvbSBFSVAtMTU1OSwgRmVlIE1hcmtldCBkZXNjcmliZXMgdGhlIGFkZGl0aW9uXG4gICAqIG9mIGEgYmFzZUZlZSB0byBibG9ja3MgdGhhdCB3aWxsIGJlIGJ1cm5lZCBpbnN0ZWFkIG9mIGRpc3RyaWJ1dGVkIHRvXG4gICAqIG1pbmVycy4gVHJhbnNhY3Rpb25zIG9mIHRoaXMgdHlwZSBoYXZlIGJvdGggYSBtYXhGZWVQZXJHYXMgKG1heGltdW0gdG90YWxcbiAgICogYW1vdW50IGluIGd3ZWkgcGVyIGdhcyB0byBzcGVuZCBvbiB0aGUgdHJhbnNhY3Rpb24pIHdoaWNoIGlzIGluY2x1c2l2ZSBvZlxuICAgKiB0aGUgbWF4UHJpb3JpdHlGZWVQZXJHYXMgKG1heGltdW0gYW1vdW50IG9mIGd3ZWkgcGVyIGdhcyBmcm9tIHRoZVxuICAgKiB0cmFuc2FjdGlvbiBmZWUgdG8gZGlzdHJpYnV0ZSB0byBtaW5lcikuXG4gICAqL1xuICBmZWVNYXJrZXQgPSAnMHgyJyxcbn1cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBTdGF0dXMgaXMgYSBtaXggb2YgRXRoZXJldW0gYW5kIE1ldGFNYXNrIHRlcm1pbm9sb2d5LCB1c2VkIGludGVybmFsbHlcbiAqIGZvciB0cmFuc2FjdGlvbiBwcm9jZXNzaW5nLlxuICovXG5leHBvcnQgZW51bSBUcmFuc2FjdGlvblN0YXR1cyB7XG4gIC8qKlxuICAgKiBBIG5ldyB0cmFuc2FjdGlvbiB0aGF0IHRoZSB1c2VyIGhhcyBub3QgYXBwcm92ZWQgb3IgcmVqZWN0ZWRcbiAgICovXG4gIHVuYXBwcm92ZWQgPSAndW5hcHByb3ZlZCcsXG4gIC8qKlxuICAgKiBUaGUgdXNlciBoYXMgYXBwcm92ZWQgdGhlIHRyYW5zYWN0aW9uIGluIHRoZSBNZXRhTWFzayBVSVxuICAgKi9cbiAgYXBwcm92ZWQgPSAnYXBwcm92ZWQnLFxuICAvKipcbiAgICogVGhlIHVzZXIgaGFzIHJlamVjdGVkIHRoZSB0cmFuc2FjdGlvbiBpbiB0aGUgTWV0YU1hc2sgVUlcbiAgICovXG4gIHJlamVjdGVkID0gJ3JlamVjdGVkJyxcbiAgLyoqXG4gICAqIFRoZSB0cmFuc2FjdGlvbiBoYXMgYmVlbiBzaWduZWRcbiAgICovXG4gIHNpZ25lZCA9ICdzaWduZWQnLFxuICAvKipcbiAgICogVGhlIHRyYW5zYWN0aW9uIGhhcyBiZWVuIHN1Ym1pdHRlZCB0byBuZXR3b3JrXG4gICAqL1xuICBzdWJtaXR0ZWQgPSAnc3VibWl0dGVkJyxcbiAgLyoqXG4gICAqIFRoZSB0cmFuc2FjdGlvbiBoYXMgZmFpbGVkIGZvciBzb21lIHJlYXNvblxuICAgKi9cbiAgZmFpbGVkID0gJ2ZhaWxlZCcsXG4gIC8qKlxuICAgKiBUaGUgdHJhbnNhY3Rpb24gd2FzIGRyb3BwZWQgZHVlIHRvIGEgdHggd2l0aCBzYW1lIG5vbmNlIGJlaW5nIGFjY2VwdGVkXG4gICAqL1xuICBkcm9wcGVkID0gJ2Ryb3BwZWQnLFxuICAvKipcbiAgICogVGhlIHRyYW5zYWN0aW9uIHdhcyBjb25maXJtZWQgYnkgdGhlIG5ldHdvcmtcbiAgICovXG4gIGNvbmZpcm1lZCA9ICdjb25maXJtZWQnLFxuICAvKipcbiAgICogVGhlIHRyYW5zYWN0aW9uIGhhcyBiZWVuIHNpZ25lZCBhbmQgaXMgd2FpdGluZyB0byBlaXRoZXIgYmUgY29uZmlybWVkLFxuICAgKiBkcm9wcGVkIG9yIGZhaWxlZC4gVGhpcyBpcyBhIFwiZmFrZVwiIHN0YXR1cyB0aGF0IHdlIHVzZSB0byBncm91cCBzdGF0dXNlc1xuICAgKiB0aGF0IGFyZSB2ZXJ5IHNpbWlsYXIgZnJvbSB0aGUgdXNlcidzIHBlcnNwZWN0aXZlIChhcHByb3ZlZCxcbiAgICogc2lnbmVkLCBzdWJtaXR0ZWQpLiBUaGUgb25seSBub3RhYmxlIGNhc2Ugd2hlcmUgYXBwcm92ZSBhbmQgc2lnbmVkIGFyZVxuICAgKiBkaWZmZXJlbnQgZnJvbSB1c2VyIHBlcnNwZWN0aXZlIGlzIGluIGhhcmR3YXJlIHdhbGxldHMgd2hlcmUgdGhlXG4gICAqIHRyYW5zYWN0aW9uIGlzIHNpZ25lZCBvbiBhbiBleHRlcm5hbCBkZXZpY2UuIE90aGVyd2lzZSBzaWduaW5nIGhhcHBlbnNcbiAgICogdHJhbnNwYXJlbnRseSB0byB1c2Vycy5cbiAgICovXG4gIHBlbmRpbmcgPSAncGVuZGluZycsXG59XG5cbi8qKlxuICogV2l0aCB0aGlzIGxpc3Qgd2UgY2FuIGRldGVjdCBpZiBhIHRyYW5zYWN0aW9uIGlzIHN0aWxsIGluIHByb2dyZXNzLlxuICovXG5leHBvcnQgY29uc3QgSU5fUFJPR1JFU1NfVFJBTlNBQ1RJT05fU1RBVFVTRVMgPSBbXG4gIFRyYW5zYWN0aW9uU3RhdHVzLnVuYXBwcm92ZWQsXG4gIFRyYW5zYWN0aW9uU3RhdHVzLmFwcHJvdmVkLFxuICBUcmFuc2FjdGlvblN0YXR1cy5zaWduZWQsXG4gIFRyYW5zYWN0aW9uU3RhdHVzLnN1Ym1pdHRlZCxcbiAgVHJhbnNhY3Rpb25TdGF0dXMucGVuZGluZyxcbl07XG5cbi8qKlxuICogVHJhbnNhY3Rpb24gR3JvdXAgU3RhdHVzIGlzIGEgTWV0YU1hc2sgY29uc3RydWN0IHRvIHRyYWNrIHRoZSBzdGF0dXMgb2YgZ3JvdXBzXG4gKiBvZiB0cmFuc2FjdGlvbnMuXG4gKi9cbmV4cG9ydCBlbnVtIFRyYW5zYWN0aW9uR3JvdXBTdGF0dXMge1xuICAvKipcbiAgICogQSBjYW5jZWwgdHlwZSB0cmFuc2FjdGlvbiBpbiB0aGUgZ3JvdXAgd2FzIGNvbmZpcm1lZFxuICAgKi9cbiAgY2FuY2VsbGVkID0gJ2NhbmNlbGxlZCcsXG4gIC8qKlxuICAgKiBUaGUgcHJpbWFyeVRyYW5zYWN0aW9uIG9mIHRoZSBncm91cCBoYXMgYSBzdGF0dXMgdGhhdCBpcyBvbmUgb2ZcbiAgICogVHJhbnNhY3Rpb25TdGF0dXMuYXBwcm92ZWQsIFRyYW5zYWN0aW9uU3RhdHVzLnVuYXBwcm92ZWQgb3JcbiAgICogVHJhbnNhY3Rpb25TdGF0dXMuc3VibWl0dGVkXG4gICAqL1xuICBwZW5kaW5nID0gJ3BlbmRpbmcnLFxufVxuXG4vKipcbiAqIFN0YXR1c2VzIHRoYXQgYXJlIHNwZWNpZmljIHRvIFNtYXJ0IFRyYW5zYWN0aW9ucy5cbiAqL1xuZXhwb3J0IGVudW0gU21hcnRUcmFuc2FjdGlvblN0YXR1cyB7XG4gIC8qKiBJdCBjYW4gYmUgY2FuY2VsbGVkIGZvciB2YXJpb3VzIHJlYXNvbnMuICovXG4gIGNhbmNlbGxlZCA9ICdjYW5jZWxsZWQnLFxuICAvKiogU21hcnQgdHJhbnNhY3Rpb24gaXMgYmVpbmcgcHJvY2Vzc2VkLiAqL1xuICBwZW5kaW5nID0gJ3BlbmRpbmcnLFxuICAvKiogU21hcnQgdHJhbnNhY3Rpb24gd2FzIHN1Y2Nlc3NmdWxseSBtaW5lZC4gKi9cbiAgc3VjY2VzcyA9ICdzdWNjZXNzJyxcbn1cblxuLyoqXG4gKiBUeXBlcyB0aGF0IGFyZSBzcGVjaWZpYyB0byB0aGUgdHJhbnNhY3Rpb24gYXBwcm92YWwgYW1vdW50LlxuICovXG5leHBvcnQgZW51bSBUcmFuc2FjdGlvbkFwcHJvdmFsQW1vdW50VHlwZSB7XG4gIC8qKiBUaGUgdXNlciBoYXMgZWRpdGVkIHRoZSB0b2tlbiBhbW91bnQuICovXG4gIGN1c3RvbSA9ICdjdXN0b20nLFxuICAvKiogVGhlIHNlbGVjdGVkIGFtb3VudCAoZWl0aGVyIGN1c3RvbSBvciBkYXBwUHJvcG9zZWQpIGlzIDAuICovXG4gIHJldm9rZSA9ICdyZXZva2UnLFxuICAvKiogVGhlIGRhcHAgcHJvcG9zZWQgdG9rZW4gYW1vdW50LiAqL1xuICBkYXBwUHJvcG9zZWQgPSAnZGFwcF9wcm9wb3NlZCcsXG59XG5cbi8qKlxuICogVHJhbnNhY3Rpb24gR3JvdXAgQ2F0ZWdvcnkgaXMgYSBNZXRhTWFzayBjb25zdHJ1Y3QgdG8gY2F0ZWdvcml6ZSB0aGUgaW50ZW50XG4gKiBvZiBhIGdyb3VwIG9mIHRyYW5zYWN0aW9ucyBmb3IgcHVycG9zZXMgb2YgZGlzcGxheWluZyBpbiB0aGUgVUlcbiAqL1xuZXhwb3J0IGVudW0gVHJhbnNhY3Rpb25Hcm91cENhdGVnb3J5IHtcbiAgLyoqXG4gICAqIFRyYW5zYWN0aW9uIGdyb3VwIHJlcHJlc2VudGluZyBhIHJlcXVlc3QgZm9yIGFuIGFsbG93YW5jZSBvZiBhIHRva2VuIHRvXG4gICAqIHNwZW5kIG9uIHRoZSB1c2VyJ3MgYmVoYWxmLlxuICAgKi9cbiAgYXBwcm92YWwgPSAnYXBwcm92YWwnLFxuICAvKipcbiAgICogVHJhbnNhY3Rpb24gZ3JvdXAgcmVwcmVzZW50aW5nIGFuIGludGVyYWN0aW9uIHdpdGggYSBzbWFydCBjb250cmFjdCdzIG1ldGhvZHMuXG4gICAqL1xuICBpbnRlcmFjdGlvbiA9ICdpbnRlcmFjdGlvbicsXG4gIC8qKlxuICAgKiBUcmFuc2FjdGlvbiBncm91cCByZXByZXNlbnRpbmcgYSBkZXBvc2l0L2luY29taW5nIHRyYW5zYWN0aW9uLiBUaGlzXG4gICAqIGNhdGVnb3J5IG1hcHMgMToxIHdpdGggVHJhbnNhY3Rpb25UeXBlLmluY29taW5nLlxuICAgKi9cbiAgcmVjZWl2ZSA9ICdyZWNlaXZlJyxcbiAgLyoqXG4gICAqIFRyYW5zYWN0aW9uIGdyb3VwIHJlcHJlc2VudGluZyB0aGUgbmV0d29yayBuYXRpdmUgY3VycmVuY3kgYmVpbmcgc2VudCBmcm9tXG4gICAqIHRoZSB1c2VyLlxuICAgKi9cbiAgc2VuZCA9ICdzZW5kJyxcbiAgLyoqXG4gICAqIFRyYW5zYWN0aW9uIGdyb3VwIHJlcHJlc2VudGluZyBhIHNpZ25hdHVyZSByZXF1ZXN0IFRoaXMgY3VycmVudGx5IG9ubHlcbiAgICogc2hvd3MgdXAgaW4gdGhlIFVJIHdoZW4gaXRzIHBlbmRpbmcgdXNlciBhcHByb3ZhbCBpbiB0aGUgVUkuIE9uY2UgdGhlIHVzZXJcbiAgICogYXBwcm92ZXMgb3IgcmVqZWN0cyBpdCB3aWxsIG5vIGxvbmdlciBzaG93IGluIGFjdGl2aXR5LlxuICAgKi9cbiAgc2lnbmF0dXJlUmVxdWVzdCA9ICdzaWduYXR1cmUtcmVxdWVzdCcsXG4gIC8qKlxuICAgKiBUcmFuc2FjdGlvbiBncm91cCByZXByZXNlbnRpbmcgYSB0b2tlbiBzd2FwIHRocm91Z2ggTWV0YU1hc2sgU3dhcHMuIFRoaXNcbiAgICogdHJhbnNhY3Rpb24gZ3JvdXAncyBwcmltYXJ5IGN1cnJlbmN5IGNoYW5nZXMgZGVwZW5kaW5nIG9uIGNvbnRleHQuIElmIHRoZVxuICAgKiB1c2VyIGlzIHZpZXdpbmcgYW4gYXNzZXQgcGFnZSBmb3IgYSB0b2tlbiByZWNlaXZlZCBmcm9tIGEgc3dhcCwgdGhlXG4gICAqIHByaW1hcnkgY3VycmVuY3kgd2lsbCBiZSB0aGUgcmVjZWl2ZWQgdG9rZW4uIE90aGVyd2lzZSB0aGUgdG9rZW4gZXhjaGFuZ2VkXG4gICAqIHdpbGwgYmUgc2hvd24uXG4gICAqL1xuICBzd2FwID0gJ3N3YXAnLFxufVxuXG4vKipcbiAqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgcGFyYW1ldGVycyBvZiBhIHRyYW5zYWN0aW9uIHRvIHN1Ym1pdCB0byB0aGUgbmV0d29ya1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFR4UGFyYW1zIHtcbiAgLyoqIFRoZSBhZGRyZXNzIHRoZSB0cmFuc2FjdGlvbiBpcyBzZW50IGZyb20gKi9cbiAgZnJvbTogc3RyaW5nO1xuICAvKiogVGhlIGFkZHJlc3MgdGhlIHRyYW5zYWN0aW9uIGlzIHNlbnQgdG8gKi9cbiAgdG86IHN0cmluZztcbiAgLyoqIFRoZSBhbW91bnQgb2Ygd2VpLCBpbiBoZXhhZGVjaW1hbCwgdG8gc2VuZCAqL1xuICB2YWx1ZTogc3RyaW5nO1xuICAvKiogVGhlIHRyYW5zYWN0aW9uIGNvdW50IGZvciB0aGUgY3VycmVudCBhY2NvdW50L25ldHdvcmsgKi9cbiAgbm9uY2U6IG51bWJlcjtcbiAgLyoqIFRoZSBhbW91bnQgb2YgZ3dlaSwgaW4gaGV4YWRlY2ltYWwsIHBlciB1bml0IG9mIGdhcyAqL1xuICBnYXNQcmljZT86IHN0cmluZztcbiAgLyoqIFRoZSBtYXggYW1vdW50IG9mIGd3ZWksIGluIGhleGFkZWNpbWFsLCB0aGUgdXNlciBpcyB3aWxsaW5nIHRvIHBheSAqL1xuICBnYXM6IHN0cmluZztcbiAgLyoqIEhleGFkZWNpbWFsIGVuY29kZWQgc3RyaW5nIHJlcHJlc2VudGluZyBjYWxscyB0byB0aGUgRVZNJ3MgQUJJICovXG4gIGRhdGE/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBFSVAtMjkzMCBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTI5MzAgYWRkZWQgdGhlIGFiaWxpdHkgZm9yXG4gICAqIHRyYW5zYWN0aW9ucyB0byBzcGVjaWZ5IHdoaWNoIGFkZHJlc3NlcyB0aGV5IHdpbGwgaW50ZXJhY3Qgd2l0aCBhbmQgYWxsb3dzXG4gICAqIGZvciBsb3dlciBnYXMgZmVlcyBvbiBzcGVjaWZpYyBvcGNvZGVzLiBTZWUgdGhlIEVJUCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgYWNjZXNzTGlzdD86IEFjY2Vzc0xpc3Q7XG4gIG1heEZlZVBlckdhcz86IHN0cmluZztcbiAgbWF4UHJpb3JpdHlGZWVQZXJHYXM/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHhSZWNlaXB0IHtcbiAgYmxvY2tIYXNoPzogc3RyaW5nO1xuICBibG9ja051bWJlcj86IHN0cmluZztcbiAgdHJhbnNhY3Rpb25JbmRleD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUeEVycm9yIHtcbiAgLyoqIFRoZSBtZXNzYWdlIGZyb20gdGhlIGVuY291bnRlcmVkIGVycm9yLiAqL1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIC8qKiBUaGUgXCJ2YWx1ZVwiIG9mIHRoZSBlcnJvci4gKi9cbiAgcnBjOiBhbnk7XG4gIC8qKiB0aGUgc3RhY2sgdHJhY2UgZnJvbSB0aGUgZXJyb3IsIGlmIGF2YWlsYWJsZS4gKi9cbiAgc3RhY2s/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogV2UgYXR0YWNoIGFuIG9iamVjdCB0byB0cmFuc2FjdGlvbnMgcHJvcG9zZWQgYnkgZGFwcHMgdG8gc2hvdyB0aGUgdmFsdWVzXG4gKiB0aGF0IHRoZSBkYXBwIHN1Z2dlc3RlZCBmb3IgZ2FzIGZlZXMuIFRoaXMgaXMgdXNlZCB0byBjb21wYXJlIHRvIHdoYXQgb3VyXG4gKiBpbnRlcm5hbCBnYXMgcHJpY2UgbG9naWMgd291bGQgaGF2ZSB0aGUgdHJhbnNhY3Rpb24gcHJpY2VkIGF0IGZvciBtZXRyaWNzXG4gKiB3aXRoIHRoZSBhaW0gb2YgaW1wcm92aW5nIG91ciBzdWdnZXN0aW9ucyBhcyB3ZWxsIGFzIGdpdmluZyB0aGUgdXNlciB0aGVcbiAqIG9wdGlvbiB0byByZXR1cm4gdG8gdGhlIGRlZmF1bHRzIHN1Z2dlc3RlZCBieSB0aGUgZGFwcCBpZiB0aGV5IGhhdmUgZWRpdGVkXG4gKiB0aGUgZ2FzIGZlZXMgb24gdGhlIGNvbmZpcm1hdGlvbiBzY3JlZW4uXG4gKi9cbmludGVyZmFjZSBEYXBwU3VnZ2VzdGVkR2FzRmVlcyB7XG4gIGdhc1ByaWNlPzogc3RyaW5nO1xuICBtYXhGZWVQZXJHYXM/OiBzdHJpbmc7XG4gIG1heFByaW9yaXR5RmVlUGVyR2FzPzogc3RyaW5nO1xuICBnYXM/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIHRyYW5zYWN0aW9uLCBpbiB3aGF0ZXZlciBzdGF0ZSBpdCBpcyBpbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvbk1ldGEge1xuICAvKipcbiAgICogVGhlIGJsb2NrIG51bWJlciB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi4gQ3VycmVudGx5IG9ubHkgcHJlc2VudFxuICAgKiBvbiBpbmNvbWluZyB0cmFuc2FjdGlvbnMhXG4gICAqL1xuICBibG9ja051bWJlcj86IHN0cmluZztcbiAgLyoqIEFuIGludGVybmFsbHkgdW5pcXVlIHR4IGlkZW50aWZpZXIuICovXG4gIGlkOiBudW1iZXI7XG4gIC8qKiBUaW1lIHRoZSB0cmFuc2FjdGlvbiB3YXMgZmlyc3Qgc3VnZ2VzdGVkLCBpbiB1bml4IGVwb2NoIHRpbWUgKG1zKS4gKi9cbiAgdGltZTogbnVtYmVyO1xuICAvKiogQSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgbmFtZSBvZiB0cmFuc2FjdGlvbiBjb250cmFjdCBtZXRob2QuICovXG4gIGNvbnRyYWN0TWV0aG9kTmFtZTogc3RyaW5nO1xuICAvKiogVGhlIGN1c3RvbSB0b2tlbiBhbW91bnQgaXMgdGhlIGFtb3VudCBzZXQgYnkgdGhlIHVzZXIgKi9cbiAgY3VzdG9tVG9rZW5BbW91bnQ6IHN0cmluZztcbiAgLyoqIFRoZSBkYXBwIHByb3Bvc2VkIHRva2VuIGFtb3VudCAqL1xuICBkYXBwUHJvcG9zZWRUb2tlbkFtb3VudDogc3RyaW5nO1xuICAvKiogVGhlIG9yaWdpbmFsIGdhcyBmZWVzIHN1Z2dlc3RlZCBieSB0aGUgZGFwcCB0aGF0IHByb3Bvc2VkIHRoaXMgdHJhbnNhY3Rpb24gKi9cbiAgZGFwcFN1Z2dlc3RlZEdhc0ZlZXM/OiBEYXBwU3VnZ2VzdGVkR2FzRmVlcztcbiAgLyoqIFRoZSBiYWxhbmNlIG9mIHRoZSB0b2tlbiB0aGF0IGlzIGJlaW5nIHNlbnQgKi9cbiAgY3VycmVudFRva2VuQmFsYW5jZTogc3RyaW5nO1xuICAvKiogVGhlIG9yaWdpbmFsIGRhcHAgcHJvcG9zZWQgdG9rZW4gYXBwcm92YWwgYW1vdW50IGJlZm9yZSBlZGl0IGJ5IHVzZXIgKi9cbiAgb3JpZ2luYWxBcHByb3ZhbEFtb3VudDogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIGNob3NlbiBhbW91bnQgd2hpY2ggd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgb3JpZ2luYWxseSBwcm9wb3NlZCB0b2tlblxuICAgKiBhbW91bnQgaWYgdGhlIHVzZXIgZG9lcyBub3QgZWRpdCB0aGUgIGFtb3VudCBvciB3aWxsIGJlIGEgY3VzdG9tIHRva2VuXG4gICAqIGFtb3VudCBzZXQgYnkgdGhlIHVzZXJcbiAgICovXG4gIGZpbmFsQXBwcm92YWxBbW91bnQ6IHN0cmluZztcbiAgLyoqIFRoZSB0eXBlIG9mIHRyYW5zYWN0aW9uIHRoaXMgdHhNZXRhIHJlcHJlc2VudHMuICovXG4gIHR5cGU6IFRyYW5zYWN0aW9uVHlwZTtcbiAgLyoqXG4gICAqIFdoZW4gd2Ugc3BlZWQgdXAgYSB0cmFuc2FjdGlvbiwgd2Ugc2V0IHRoZSB0eXBlIGFzIFJldHJ5IGFuZCB3ZSBsb3NlXG4gICAqIGluZm9ybWF0aW9uIGFib3V0IHR5cGUgb2YgdHJhbnNhY3Rpb24gdGhhdCBpcyBiZWluZyBzZXQgdXAsIHNvIHdlIHVzZVxuICAgKiBvcmlnaW5hbCB0eXBlIHRvIHRyYWNrIHRoYXQgaW5mb3JtYXRpb24uXG4gICAqL1xuICBvcmlnaW5hbFR5cGU6IFRyYW5zYWN0aW9uVHlwZTtcbiAgLyoqIFRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgdHJhbnNhY3Rpb24uICovXG4gIHN0YXR1czogVHJhbnNhY3Rpb25TdGF0dXM7XG4gIC8qKiBUaGUgdHJhbnNhY3Rpb24ncyBuZXR3b3JrIElELCB1c2VkIGZvciBFSVAtMTU1IGNvbXBsaWFuY2UuICovXG4gIG1ldGFtYXNrTmV0d29ya0lkOiBzdHJpbmc7XG4gIC8qKiBUT0RPOiBGaW5kIG91dCB3aGF0IHRoaXMgaXMgYW5kIGRvY3VtZW50IGl0ICovXG4gIGxvYWRpbmdEZWZhdWx0czogYm9vbGVhbjtcbiAgLyoqIFRoZSB0cmFuc2FjdGlvbiBwYXJhbXMgYXMgcGFzc2VkIHRvIHRoZSBuZXR3b3JrIHByb3ZpZGVyLiAqL1xuICB0eFBhcmFtczogVHhQYXJhbXM7XG4gIHR4UmVjZWlwdDogVHhSZWNlaXB0O1xuICAvKiogQSBoaXN0b3J5IG9mIG11dGF0aW9ucyB0byB0aGlzIFRyYW5zYWN0aW9uTWV0YSBvYmplY3QuICovXG4gIGhpc3Rvcnk6IFJlY29yZDxzdHJpbmcsIGFueT5bXTtcbiAgLyoqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgaW50ZXJmYWNlIHRoYXQgc3VnZ2VzdGVkIHRoZSB0cmFuc2FjdGlvbi4gKi9cbiAgb3JpZ2luOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG9yaWdpbmFsIGdhcyBlc3RpbWF0aW9uIG9uIHRoZSB0cmFuc2FjdGlvblxuICAgKiBtZXRhZGF0YS5cbiAgICovXG4gIG9yaWdpbmFsR2FzRXN0aW1hdGU6IHN0cmluZztcbiAgLyoqIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hlbiB0aGUgdXNlciBtYW51YWxseSBlZGl0ZWQgdGhlIGdhcyBsaW1pdC4gKi9cbiAgdXNlckVkaXRlZEdhc0xpbWl0OiBib29sZWFuO1xuICAvKipcbiAgICogQSBtZXRhZGF0YSBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiB1c2VkIHRvIGRlcml2ZSB0aGUgc3VnZ2VzdGVkXG4gICAqIG5vbmNlLCB1c2VmdWwgZm9yIGRlYnVnZ2luZyBub25jZSBpc3N1ZXMuXG4gICAqL1xuICBub25jZURldGFpbHM6IFJlY29yZDxzdHJpbmcsIGFueT47XG4gIC8qKlxuICAgKiBBIGhleCBzdHJpbmcgb2YgdGhlIGZpbmFsIHNpZ25lZCB0cmFuc2FjdGlvbiwgcmVhZHkgdG8gc3VibWl0IHRvIHRoZVxuICAgKiBuZXR3b3JrLlxuICAgKi9cbiAgcmF3VHg6IHN0cmluZztcbiAgLyoqXG4gICAqIEEgaGV4IHN0cmluZyBvZiB0aGUgdHJhbnNhY3Rpb24gaGFzaCwgdXNlZCB0byBpZGVudGlmeSB0aGUgdHJhbnNhY3Rpb25cbiAgICogb24gdGhlIG5ldHdvcmsuXG4gICAqL1xuICBoYXNoOiBzdHJpbmc7XG4gIHY/OiBzdHJpbmc7XG4gIHI/OiBzdHJpbmc7XG4gIHM/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgdGltZSB0aGUgdHJhbnNhY3Rpb24gd2FzIHN1Ym1pdHRlZCB0byB0aGUgbmV0d29yaywgaW4gVW5peCBlcG9jaCB0aW1lXG4gICAqIChtcykuXG4gICAqL1xuICBzdWJtaXR0ZWRUaW1lPzogbnVtYmVyO1xuICAvKiogVGhlIGVycm9yIGVuY291bnRlcmVkIGR1cmluZyB0aGUgdHJhbnNhY3Rpb24gKi9cbiAgdHhFcnI/OiBUeEVycm9yO1xufVxuXG4vKipcbiAqIERlZmluZXMgdGhlIHBvc3NpYmxlIHR5cGVzXG4gKi9cbmV4cG9ydCBlbnVtIFRyYW5zYWN0aW9uTWV0YU1ldHJpY3NFdmVudCB7XG4gIC8qKlxuICAgKiBBbGwgdHJhbnNhY3Rpb25zLCBleGNlcHQgaW5jb21pbmcgb25lcywgYXJlIGFkZGVkIHRvIHRoZSBjb250cm9sbGVyIHN0YXRlXG4gICAqIGluIGFuIHVuYXBwcm92ZWQgc3RhdHVzLiBXaGVuIHRoaXMgaGFwcGVucyB3ZSBmaXJlIHRoZSBUcmFuc2FjdGlvbiBBZGRlZFxuICAgKiBldmVudCB0byBzaG93IHRoYXQgdGhlIHRyYW5zYWN0aW9uIGhhcyBiZWVuIGFkZGVkIHRvIHRoZSB1c2VyJ3MgTWV0YU1hc2suXG4gICAqL1xuICBhZGRlZCA9ICdUcmFuc2FjdGlvbiBBZGRlZCcsXG4gIC8qKlxuICAgKiBXaGVuIGFuIHVuYXBwcm92ZWQgdHJhbnNhY3Rpb24gaXMgaW4gdGhlIGNvbnRyb2xsZXIgc3RhdGUsIE1ldGFNYXNrIHdpbGxcbiAgICogcmVuZGVyIGEgY29uZmlybWF0aW9uIHNjcmVlbiBmb3IgdGhhdCB0cmFuc2FjdGlvbi4gSWYgdGhlIHVzZXIgYXBwcm92ZXNcbiAgICogdGhlIHRyYW5zYWN0aW9uIHdlIGZpcmUgdGhpcyBldmVudCB0byBpbmRpY2F0ZSB0aGF0IHRoZSB1c2VyIGhhcyBhcHByb3ZlZFxuICAgKiB0aGUgdHJhbnNhY3Rpb24gZm9yIHN1Ym1pc3Npb24gdG8gdGhlIG5ldHdvcmsuXG4gICAqL1xuICBhcHByb3ZlZCA9ICdUcmFuc2FjdGlvbiBBcHByb3ZlZCcsXG4gIC8qKlxuICAgKiBBbGwgdHJhbnNhY3Rpb25zIHRoYXQgYXJlIHN1Ym1pdHRlZCB3aWxsIGZpbmFsaXplZCAoZXZlbnR1YWxseSkgYnkgZWl0aGVyXG4gICAqIGJlaW5nIGRyb3BwZWQsIGZhaWxpbmcgb3IgYmVpbmcgY29uZmlybWVkLiBXaGVuIHRoaXMgaGFwcGVucyB3ZSB0cmFjayB0aGlzXG4gICAqIGV2ZW50LCBhbG9uZyB3aXRoIHRoZSBzdGF0dXMuXG4gICAqL1xuICBmaW5hbGl6ZWQgPSAnVHJhbnNhY3Rpb24gRmluYWxpemVkJyxcbiAgLyoqXG4gICAqIFdoZW4gYW4gdW5hcHByb3ZlZCB0cmFuc2FjdGlvbiBpcyBpbiB0aGUgY29udHJvbGxlciBzdGF0ZSwgTWV0YU1hc2sgd2lsbFxuICAgKiByZW5kZXIgYSBjb25maXJtYXRpb24gc2NyZWVuIGZvciB0aGF0IHRyYW5zYWN0aW9uLiBJZiB0aGUgdXNlciByZWplY3RzIHRoZVxuICAgKiB0cmFuc2FjdGlvbiB3ZSBmaXJlIHRoaXMgZXZlbnQgdG8gaW5kaWNhdGUgdGhhdCB0aGUgdXNlciBoYXMgcmVqZWN0ZWQgdGhlXG4gICAqIHRyYW5zYWN0aW9uLiBJdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSBzdGF0ZSBhcyBhIHJlc3VsdC5cbiAgICovXG4gIHJlamVjdGVkID0gJ1RyYW5zYWN0aW9uIFJlamVjdGVkJyxcbiAgLyoqXG4gICAqIEFmdGVyIGEgdHJhbnNhY3Rpb24gaXMgYXBwcm92ZWQgYnkgdGhlIHVzZXIsIGl0IGlzIHRoZW4gc3VibWl0dGVkIHRvIHRoZVxuICAgKiBuZXR3b3JrIGZvciBpbmNsdXNpb24gaW4gYSBibG9jay4gV2hlbiB0aGlzIGhhcHBlbnMgd2UgZmlyZSB0aGVcbiAgICogVHJhbnNhY3Rpb24gU3VibWl0dGVkIGV2ZW50IHRvIGluZGljYXRlIHRoYXQgTWV0YU1hc2sgaXMgc3VibWl0dGluZyBhXG4gICAqIHRyYW5zYWN0aW9uIGF0IHRoZSB1c2VyJ3MgcmVxdWVzdC5cbiAgICovXG4gIHN1Ym1pdHRlZCA9ICdUcmFuc2FjdGlvbiBTdWJtaXR0ZWQnLFxufVxuXG4vKipcbiAqIFRoZSB0eXBlcyBvZiBhc3NldHMgdGhhdCBhIHVzZXIgY2FuIHNlbmRcbiAqXG4gKiBAdHlwZSB7QXNzZXRUeXBlc31cbiAqL1xuZXhwb3J0IGVudW0gQXNzZXRUeXBlIHtcbiAgLyoqIFRoZSBuYXRpdmUgYXNzZXQgZm9yIHRoZSBjdXJyZW50IG5ldHdvcmssIHN1Y2ggYXMgRVRIICovXG4gIG5hdGl2ZSA9ICdOQVRJVkUnLFxuICAvKiogQW4gRVJDMjAgdG9rZW4gKi9cbiAgdG9rZW4gPSAnVE9LRU4nLFxuICAvKiogQW4gRVJDNzIxIG9yIEVSQzExNTUgdG9rZW4uICovXG4gIE5GVCA9ICdORlQnLFxuICAvKipcbiAgICogQSB0cmFuc2FjdGlvbiBpbnRlcmFjdGluZyB3aXRoIGEgY29udHJhY3QgdGhhdCBpc24ndCBhIHRva2VuIG1ldGhvZFxuICAgKiBpbnRlcmFjdGlvbiB3aWxsIGJlIG1hcmtlZCBhcyBkZWFsaW5nIHdpdGggYW4gdW5rbm93biBhc3NldCB0eXBlLlxuICAgKi9cbiAgdW5rbm93biA9ICdVTktOT1dOJyxcbn1cblxuLyoqXG4gKiBEZXNjcmliZXMgdGhlIHN0YW5kYXJkIHdoaWNoIGEgdG9rZW4gY29uZm9ybXMgdG8uXG4gKi9cbmV4cG9ydCBlbnVtIFRva2VuU3RhbmRhcmQge1xuICAvKiogQSB0b2tlbiB0aGF0IGNvbmZvcm1zIHRvIHRoZSBFUkMyMCBzdGFuZGFyZC4gKi9cbiAgRVJDMjAgPSAnRVJDMjAnLFxuICAvKiogQSB0b2tlbiB0aGF0IGNvbmZvcm1zIHRvIHRoZSBFUkM3MjEgc3RhbmRhcmQuICovXG4gIEVSQzcyMSA9ICdFUkM3MjEnLFxuICAvKiogQSB0b2tlbiB0aGF0IGNvbmZvcm1zIHRvIHRoZSBFUkMxMTU1IHN0YW5kYXJkLiAqL1xuICBFUkMxMTU1ID0gJ0VSQzExNTUnLFxuICAvKiogTm90IGEgdG9rZW4sIGJ1dCByYXRoZXIgdGhlIGJhc2UgYXNzZXQgb2YgdGhlIHNlbGVjdGVkIGNoYWluLiAqL1xuICBub25lID0gJ05PTkUnLFxufVxuIiwiaW1wb3J0IHsgTUlOVVRFLCBTRUNPTkQgfSBmcm9tICcuLi9jb25zdGFudHMvdGltZSc7XG5pbXBvcnQgZ2V0RmV0Y2hXaXRoVGltZW91dCBmcm9tICcuLi9tb2R1bGVzL2ZldGNoLXdpdGgtdGltZW91dCc7XG5pbXBvcnQgeyBnZXRTdG9yYWdlSXRlbSwgc2V0U3RvcmFnZUl0ZW0gfSBmcm9tICcuL3N0b3JhZ2UtaGVscGVycyc7XG5cbmNvbnN0IGZldGNoV2l0aENhY2hlID0gYXN5bmMgKFxuICB1cmwsXG4gIGZldGNoT3B0aW9ucyA9IHt9LFxuICB7IGNhY2hlUmVmcmVzaFRpbWUgPSBNSU5VVEUgKiA2LCB0aW1lb3V0ID0gU0VDT05EICogMzAgfSA9IHt9LFxuKSA9PiB7XG4gIGlmIChcbiAgICBmZXRjaE9wdGlvbnMuYm9keSB8fFxuICAgIChmZXRjaE9wdGlvbnMubWV0aG9kICYmIGZldGNoT3B0aW9ucy5tZXRob2QgIT09ICdHRVQnKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZldGNoV2l0aENhY2hlIG9ubHkgc3VwcG9ydHMgR0VUIHJlcXVlc3RzJyk7XG4gIH1cbiAgaWYgKCEoZmV0Y2hPcHRpb25zLmhlYWRlcnMgaW5zdGFuY2VvZiB3aW5kb3cuSGVhZGVycykpIHtcbiAgICBmZXRjaE9wdGlvbnMuaGVhZGVycyA9IG5ldyB3aW5kb3cuSGVhZGVycyhmZXRjaE9wdGlvbnMuaGVhZGVycyk7XG4gIH1cbiAgaWYgKFxuICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJykgJiZcbiAgICBmZXRjaE9wdGlvbnMuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpICE9PSAnYXBwbGljYXRpb24vanNvbidcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmZXRjaFdpdGhDYWNoZSBvbmx5IHN1cHBvcnRzIEpTT04gcmVzcG9uc2VzJyk7XG4gIH1cblxuICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gIGNvbnN0IGNhY2hlS2V5ID0gYGNhY2hlZEZldGNoOiR7dXJsfWA7XG4gIGNvbnN0IHsgY2FjaGVkUmVzcG9uc2UsIGNhY2hlZFRpbWUgfSA9IChhd2FpdCBnZXRTdG9yYWdlSXRlbShjYWNoZUtleSkpIHx8IHt9O1xuICBpZiAoY2FjaGVkUmVzcG9uc2UgJiYgY3VycmVudFRpbWUgLSBjYWNoZWRUaW1lIDwgY2FjaGVSZWZyZXNoVGltZSkge1xuICAgIHJldHVybiBjYWNoZWRSZXNwb25zZTtcbiAgfVxuICBmZXRjaE9wdGlvbnMuaGVhZGVycy5zZXQoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gIGNvbnN0IGZldGNoV2l0aFRpbWVvdXQgPSBnZXRGZXRjaFdpdGhUaW1lb3V0KHRpbWVvdXQpO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFRpbWVvdXQodXJsLCB7XG4gICAgcmVmZXJyZXJQb2xpY3k6ICduby1yZWZlcnJlci13aGVuLWRvd25ncmFkZScsXG4gICAgYm9keTogbnVsbCxcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIG1vZGU6ICdjb3JzJyxcbiAgICAuLi5mZXRjaE9wdGlvbnMsXG4gIH0pO1xuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEZldGNoIGZhaWxlZCB3aXRoIHN0YXR1cyAnJHtyZXNwb25zZS5zdGF0dXN9JzogJyR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0nYCxcbiAgICApO1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlSnNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgY29uc3QgY2FjaGVFbnRyeSA9IHtcbiAgICBjYWNoZWRSZXNwb25zZTogcmVzcG9uc2VKc29uLFxuICAgIGNhY2hlZFRpbWU6IGN1cnJlbnRUaW1lLFxuICB9O1xuXG4gIGF3YWl0IHNldFN0b3JhZ2VJdGVtKGNhY2hlS2V5LCBjYWNoZUVudHJ5KTtcbiAgcmV0dXJuIHJlc3BvbnNlSnNvbjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZldGNoV2l0aENhY2hlO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGdldFRva2VuVmFsdWVQYXJhbSh0b2tlbkRhdGEgPSB7fSkge1xuICByZXR1cm4gdG9rZW5EYXRhPy5hcmdzPy5fdmFsdWU/LnRvU3RyaW5nKCk7XG59XG4iLCJpbXBvcnQgbG9jYWxmb3JhZ2UgZnJvbSAnbG9jYWxmb3JhZ2UnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U3RvcmFnZUl0ZW0oa2V5KSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZERhdGEgPSBhd2FpdCBsb2NhbGZvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgaWYgKHNlcmlhbGl6ZWREYXRhID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBKU09OLnBhcnNlKHNlcmlhbGl6ZWREYXRhKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0U3RvcmFnZUl0ZW0oa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWREYXRhID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIGF3YWl0IGxvY2FsZm9yYWdlLnNldEl0ZW0oa2V5LCBzZXJpYWxpemVkRGF0YSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUud2FybihlcnIpO1xuICB9XG59XG4iLCJpbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCB7IENIQUlOX0lEUyB9IGZyb20gJy4uL2NvbnN0YW50cy9uZXR3b3JrJztcbmltcG9ydCB7XG4gIEdBU19BUElfQkFTRV9VUkwsXG4gIEdBU19ERVZfQVBJX0JBU0VfVVJMLFxuICBTV0FQU19BUElfVjJfQkFTRV9VUkwsXG4gIFNXQVBTX0NIQUlOSURfREVGQVVMVF9UT0tFTl9NQVAsXG4gIFNXQVBTX0NMSUVOVF9JRCxcbiAgU1dBUFNfREVWX0FQSV9WMl9CQVNFX1VSTCxcbiAgU1dBUFNfV1JBUFBFRF9UT0tFTlNfQUREUkVTU0VTLFxufSBmcm9tICcuLi9jb25zdGFudHMvc3dhcHMnO1xuaW1wb3J0IHsgU0VDT05EIH0gZnJvbSAnLi4vY29uc3RhbnRzL3RpbWUnO1xuaW1wb3J0IHsgaXNWYWxpZEhleEFkZHJlc3MgfSBmcm9tICcuLi9tb2R1bGVzL2hleHN0cmluZy11dGlscyc7XG5pbXBvcnQgeyBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlIH0gZnJvbSAnLi4vbW9kdWxlcy9zdHJpbmctdXRpbHMnO1xuaW1wb3J0IHsgYWRkSGV4UHJlZml4IH0gZnJvbSAnLi4vLi4vYXBwL3NjcmlwdHMvbGliL3V0aWwnO1xuaW1wb3J0IHsgZGVjaW1hbFRvSGV4IH0gZnJvbSAnLi4vbW9kdWxlcy9jb252ZXJzaW9uLnV0aWxzJztcbmltcG9ydCBmZXRjaFdpdGhDYWNoZSBmcm9tICcuL2ZldGNoLXdpdGgtY2FjaGUnO1xuXG5jb25zdCBURVNUX0NIQUlOX0lEUyA9IFtDSEFJTl9JRFMuR09FUkxJLCBDSEFJTl9JRFMuTE9DQUxIT1NUXTtcblxuY29uc3QgY2xpZW50SWRIZWFkZXIgPSB7ICdYLUNsaWVudC1JZCc6IFNXQVBTX0NMSUVOVF9JRCB9O1xuXG5leHBvcnQgY29uc3QgdmFsaWRIZXggPSAoc3RyaW5nKSA9PiBCb29sZWFuKHN0cmluZz8ubWF0Y2goL14weFthLWYwLTldKyQvdSkpO1xuZXhwb3J0IGNvbnN0IHRydXRoeVN0cmluZyA9IChzdHJpbmcpID0+IEJvb2xlYW4oc3RyaW5nPy5sZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHRydXRoeURpZ2l0U3RyaW5nID0gKHN0cmluZykgPT5cbiAgdHJ1dGh5U3RyaW5nKHN0cmluZykgJiYgQm9vbGVhbihzdHJpbmcubWF0Y2goL15cXGQrJC91KSk7XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZURhdGEodmFsaWRhdG9ycywgb2JqZWN0LCB1cmxVc2VkLCBsb2dFcnJvciA9IHRydWUpIHtcbiAgcmV0dXJuIHZhbGlkYXRvcnMuZXZlcnkoKHsgcHJvcGVydHksIHR5cGUsIHZhbGlkYXRvciB9KSA9PiB7XG4gICAgY29uc3QgdHlwZXMgPSB0eXBlLnNwbGl0KCd8Jyk7XG5cbiAgICBjb25zdCB2YWxpZCA9XG4gICAgICB0eXBlcy5zb21lKChfdHlwZSkgPT4gdHlwZW9mIG9iamVjdFtwcm9wZXJ0eV0gPT09IF90eXBlKSAmJlxuICAgICAgKCF2YWxpZGF0b3IgfHwgdmFsaWRhdG9yKG9iamVjdFtwcm9wZXJ0eV0pKTtcbiAgICBpZiAoIXZhbGlkICYmIGxvZ0Vycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoXG4gICAgICAgIGByZXNwb25zZSB0byBHRVQgJHt1cmxVc2VkfSBpbnZhbGlkIGZvciBwcm9wZXJ0eSAke3Byb3BlcnR5fTsgdmFsdWUgd2FzOmAsXG4gICAgICAgIG9iamVjdFtwcm9wZXJ0eV0sXG4gICAgICAgICd8IHR5cGUgd2FzOiAnLFxuICAgICAgICB0eXBlb2Ygb2JqZWN0W3Byb3BlcnR5XSxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZDtcbiAgfSk7XG59XG5cbmV4cG9ydCBjb25zdCBRVU9URV9WQUxJREFUT1JTID0gW1xuICB7XG4gICAgcHJvcGVydHk6ICd0cmFkZScsXG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgdmFsaWRhdG9yOiAodHJhZGUpID0+XG4gICAgICB0cmFkZSAmJlxuICAgICAgdmFsaWRIZXgodHJhZGUuZGF0YSkgJiZcbiAgICAgIGlzVmFsaWRIZXhBZGRyZXNzKHRyYWRlLnRvLCB7IGFsbG93Tm9uUHJlZml4ZWQ6IGZhbHNlIH0pICYmXG4gICAgICBpc1ZhbGlkSGV4QWRkcmVzcyh0cmFkZS5mcm9tLCB7IGFsbG93Tm9uUHJlZml4ZWQ6IGZhbHNlIH0pICYmXG4gICAgICB0cnV0aHlTdHJpbmcodHJhZGUudmFsdWUpLFxuICB9LFxuICB7XG4gICAgcHJvcGVydHk6ICdhcHByb3ZhbE5lZWRlZCcsXG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgdmFsaWRhdG9yOiAoYXBwcm92YWxUeCkgPT5cbiAgICAgIGFwcHJvdmFsVHggPT09IG51bGwgfHxcbiAgICAgIChhcHByb3ZhbFR4ICYmXG4gICAgICAgIHZhbGlkSGV4KGFwcHJvdmFsVHguZGF0YSkgJiZcbiAgICAgICAgaXNWYWxpZEhleEFkZHJlc3MoYXBwcm92YWxUeC50bywgeyBhbGxvd05vblByZWZpeGVkOiBmYWxzZSB9KSAmJlxuICAgICAgICBpc1ZhbGlkSGV4QWRkcmVzcyhhcHByb3ZhbFR4LmZyb20sIHsgYWxsb3dOb25QcmVmaXhlZDogZmFsc2UgfSkpLFxuICB9LFxuICB7XG4gICAgcHJvcGVydHk6ICdzb3VyY2VBbW91bnQnLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIHZhbGlkYXRvcjogdHJ1dGh5RGlnaXRTdHJpbmcsXG4gIH0sXG4gIHtcbiAgICBwcm9wZXJ0eTogJ2Rlc3RpbmF0aW9uQW1vdW50JyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICB2YWxpZGF0b3I6IHRydXRoeURpZ2l0U3RyaW5nLFxuICB9LFxuICB7XG4gICAgcHJvcGVydHk6ICdzb3VyY2VUb2tlbicsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgdmFsaWRhdG9yOiAoaW5wdXQpID0+IGlzVmFsaWRIZXhBZGRyZXNzKGlucHV0LCB7IGFsbG93Tm9uUHJlZml4ZWQ6IGZhbHNlIH0pLFxuICB9LFxuICB7XG4gICAgcHJvcGVydHk6ICdkZXN0aW5hdGlvblRva2VuJyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICB2YWxpZGF0b3I6IChpbnB1dCkgPT4gaXNWYWxpZEhleEFkZHJlc3MoaW5wdXQsIHsgYWxsb3dOb25QcmVmaXhlZDogZmFsc2UgfSksXG4gIH0sXG4gIHtcbiAgICBwcm9wZXJ0eTogJ2FnZ3JlZ2F0b3InLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIHZhbGlkYXRvcjogdHJ1dGh5U3RyaW5nLFxuICB9LFxuICB7XG4gICAgcHJvcGVydHk6ICdhZ2dUeXBlJyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICB2YWxpZGF0b3I6IHRydXRoeVN0cmluZyxcbiAgfSxcbiAge1xuICAgIHByb3BlcnR5OiAnZXJyb3InLFxuICAgIHR5cGU6ICdvYmplY3QnLFxuICAgIHZhbGlkYXRvcjogKGVycm9yKSA9PiBlcnJvciA9PT0gbnVsbCB8fCB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnLFxuICB9LFxuICB7XG4gICAgcHJvcGVydHk6ICdhdmVyYWdlR2FzJyxcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgfSxcbiAge1xuICAgIHByb3BlcnR5OiAnbWF4R2FzJyxcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgfSxcbiAge1xuICAgIHByb3BlcnR5OiAnZ2FzRXN0aW1hdGUnLFxuICAgIHR5cGU6ICdudW1iZXJ8dW5kZWZpbmVkJyxcbiAgICB2YWxpZGF0b3I6IChnYXNFc3RpbWF0ZSkgPT4gZ2FzRXN0aW1hdGUgPT09IHVuZGVmaW5lZCB8fCBnYXNFc3RpbWF0ZSA+IDAsXG4gIH0sXG4gIHtcbiAgICBwcm9wZXJ0eTogJ2ZlZScsXG4gICAgdHlwZTogJ251bWJlcicsXG4gIH0sXG5dO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVHlwZSBvZiBhbiBBUEkgY2FsbCwgZS5nLiBcInRva2Vuc1wiXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhaW5JZFxuICogQHJldHVybnMgc3RyaW5nXG4gKi9cbmNvbnN0IGdldEJhc2VVcmxGb3JOZXdTd2Fwc0FwaSA9ICh0eXBlLCBjaGFpbklkKSA9PiB7XG4gIGNvbnN0IHVzZURldkFwaXMgPSBwcm9jZXNzLmVudi5TV0FQU19VU0VfREVWX0FQSVM7XG4gIGNvbnN0IHYyQXBpQmFzZVVybCA9IHVzZURldkFwaXNcbiAgICA/IFNXQVBTX0RFVl9BUElfVjJfQkFTRV9VUkxcbiAgICA6IFNXQVBTX0FQSV9WMl9CQVNFX1VSTDtcbiAgY29uc3QgZ2FzQXBpQmFzZVVybCA9IHVzZURldkFwaXMgPyBHQVNfREVWX0FQSV9CQVNFX1VSTCA6IEdBU19BUElfQkFTRV9VUkw7XG4gIGNvbnN0IG5vTmV0d29ya1NwZWNpZmljVHlwZXMgPSBbJ3JlZnJlc2hUaW1lJ107IC8vIFRoZXNlIHR5cGVzIGRvbid0IG5lZWQgbmV0d29yayBpbmZvIGluIHRoZSBVUkwuXG4gIGlmIChub05ldHdvcmtTcGVjaWZpY1R5cGVzLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgcmV0dXJuIHYyQXBpQmFzZVVybDtcbiAgfVxuICBjb25zdCBjaGFpbklkRGVjaW1hbCA9IGNoYWluSWQgJiYgcGFyc2VJbnQoY2hhaW5JZCwgMTYpO1xuICBjb25zdCBnYXNBcGlUeXBlcyA9IFsnZ2FzUHJpY2VzJ107XG4gIGlmIChnYXNBcGlUeXBlcy5pbmNsdWRlcyh0eXBlKSkge1xuICAgIHJldHVybiBgJHtnYXNBcGlCYXNlVXJsfS9uZXR3b3Jrcy8ke2NoYWluSWREZWNpbWFsfWA7IC8vIEdhcyBjYWxjdWxhdGlvbnMgYXJlIGluIGl0cyBvd24gcmVwby5cbiAgfVxuICByZXR1cm4gYCR7djJBcGlCYXNlVXJsfS9uZXR3b3Jrcy8ke2NoYWluSWREZWNpbWFsfWA7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0QmFzZUFwaSA9IGZ1bmN0aW9uICh0eXBlLCBjaGFpbklkKSB7XG4gIGNvbnN0IF9jaGFpbklkID0gVEVTVF9DSEFJTl9JRFMuaW5jbHVkZXMoY2hhaW5JZClcbiAgICA/IENIQUlOX0lEUy5NQUlOTkVUXG4gICAgOiBjaGFpbklkO1xuICBjb25zdCBiYXNlVXJsID0gZ2V0QmFzZVVybEZvck5ld1N3YXBzQXBpKHR5cGUsIF9jaGFpbklkKTtcbiAgaWYgKCFiYXNlVXJsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTd2FwcyBBUEkgY2FsbHMgYXJlIGRpc2FibGVkIGZvciBjaGFpbklkOiAke19jaGFpbklkfWApO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3RyYWRlJzpcbiAgICAgIHJldHVybiBgJHtiYXNlVXJsfS90cmFkZXM/YDtcbiAgICBjYXNlICd0b2tlbnMnOlxuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L3Rva2Vuc2A7XG4gICAgY2FzZSAndG9rZW4nOlxuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L3Rva2VuYDtcbiAgICBjYXNlICd0b3BBc3NldHMnOlxuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L3RvcEFzc2V0c2A7XG4gICAgY2FzZSAnYWdncmVnYXRvck1ldGFkYXRhJzpcbiAgICAgIHJldHVybiBgJHtiYXNlVXJsfS9hZ2dyZWdhdG9yTWV0YWRhdGFgO1xuICAgIGNhc2UgJ2dhc1ByaWNlcyc6XG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vZ2FzUHJpY2VzYDtcbiAgICBjYXNlICduZXR3b3JrJzpcbiAgICAgIHJldHVybiBiYXNlVXJsO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldEJhc2VBcGkgcmVxdWlyZXMgYW4gYXBpIGNhbGwgdHlwZScpO1xuICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY2FsY1Rva2VuVmFsdWUodmFsdWUsIGRlY2ltYWxzKSB7XG4gIGNvbnN0IG11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgTnVtYmVyKGRlY2ltYWxzIHx8IDApKTtcbiAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoU3RyaW5nKHZhbHVlKSkudGltZXMobXVsdGlwbGllcik7XG59XG5cbmV4cG9ydCBjb25zdCBzaG91bGRFbmFibGVEaXJlY3RXcmFwcGluZyA9IChcbiAgY2hhaW5JZCxcbiAgc291cmNlVG9rZW4sXG4gIGRlc3RpbmF0aW9uVG9rZW4sXG4pID0+IHtcbiAgaWYgKCFzb3VyY2VUb2tlbiB8fCAhZGVzdGluYXRpb25Ub2tlbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB3cmFwcGVkVG9rZW4gPSBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVNbY2hhaW5JZF07XG4gIGNvbnN0IG5hdGl2ZVRva2VuID0gU1dBUFNfQ0hBSU5JRF9ERUZBVUxUX1RPS0VOX01BUFtjaGFpbklkXT8uYWRkcmVzcztcbiAgcmV0dXJuIChcbiAgICAoaXNFcXVhbENhc2VJbnNlbnNpdGl2ZShzb3VyY2VUb2tlbiwgd3JhcHBlZFRva2VuKSAmJlxuICAgICAgaXNFcXVhbENhc2VJbnNlbnNpdGl2ZShkZXN0aW5hdGlvblRva2VuLCBuYXRpdmVUb2tlbikpIHx8XG4gICAgKGlzRXF1YWxDYXNlSW5zZW5zaXRpdmUoc291cmNlVG9rZW4sIG5hdGl2ZVRva2VuKSAmJlxuICAgICAgaXNFcXVhbENhc2VJbnNlbnNpdGl2ZShkZXN0aW5hdGlvblRva2VuLCB3cmFwcGVkVG9rZW4pKVxuICApO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhbmQgb2JqZWN0IHdoZXJlIGFsbCB2YWx1ZXMgYXJlIHN0cmluZ3MsIHJldHVybnMgdGhlIHNhbWUgb2JqZWN0IHdpdGggYWxsIHZhbHVlc1xuICogbm93IHByZWZpeGVkIHdpdGggJzB4J1xuICpcbiAqIEBwYXJhbSBvYmpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEhleFByZWZpeFRvT2JqZWN0VmFsdWVzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoKG5ld09iaiwga2V5KSA9PiB7XG4gICAgcmV0dXJuIHsgLi4ubmV3T2JqLCBba2V5XTogYWRkSGV4UHJlZml4KG9ialtrZXldKSB9O1xuICB9LCB7fSk7XG59XG5cbi8qKlxuICogR2l2ZW4gdGhlIHN0YW5kYXJkIHNldCBvZiBpbmZvcm1hdGlvbiBhYm91dCBhIHRyYW5zYWN0aW9uLCByZXR1cm5zIGEgdHJhbnNhY3Rpb24gcHJvcGVybHkgZm9ybWF0dGVkIGZvclxuICogcHVibGlzaGluZyB2aWEgSlNPTiBSUEMgYW5kIHdlYjNcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZW5kVG9rZW5dIC0gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSB0cmFuc2FjaXRvbiBpcyBhIHRva2VuIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5kYXRhIC0gQSBoZXggc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGRhdGEgdG8gaW5jbHVkZSBpbiB0aGUgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvIC0gQSBoZXggYWRkcmVzcyBvZiB0aGUgdHggcmVjaXBpZW50IGFkZHJlc3NcbiAqIEBwYXJhbSBvcHRpb25zLmFtb3VudFxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZnJvbSAtIEEgaGV4IGFkZHJlc3Mgb2YgdGhlIHR4IHNlbmRlciBhZGRyZXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5nYXMgLSBBIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2FzIHZhbHVlIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmdhc1ByaWNlIC0gQSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGdhcyBwcmljZSBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBBbiBvYmplY3QgcmVhZHkgZm9yIHN1Ym1pc3Npb24gdG8gdGhlIGJsb2NrY2hhaW4sIHdpdGggYWxsIHZhbHVlcyBhcHByb3ByaWF0ZWx5IGhleCBwcmVmaXhlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uc3RydWN0VHhQYXJhbXMoe1xuICBzZW5kVG9rZW4sXG4gIGRhdGEsXG4gIHRvLFxuICBhbW91bnQsXG4gIGZyb20sXG4gIGdhcyxcbiAgZ2FzUHJpY2UsXG59KSB7XG4gIGNvbnN0IHR4UGFyYW1zID0ge1xuICAgIGRhdGEsXG4gICAgZnJvbSxcbiAgICB2YWx1ZTogJzAnLFxuICAgIGdhcyxcbiAgICBnYXNQcmljZSxcbiAgfTtcblxuICBpZiAoIXNlbmRUb2tlbikge1xuICAgIHR4UGFyYW1zLnZhbHVlID0gYW1vdW50O1xuICAgIHR4UGFyYW1zLnRvID0gdG87XG4gIH1cbiAgcmV0dXJuIGFkZEhleFByZWZpeFRvT2JqZWN0VmFsdWVzKHR4UGFyYW1zKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoVHJhZGVzSW5mbyhcbiAge1xuICAgIHNsaXBwYWdlLFxuICAgIHNvdXJjZVRva2VuLFxuICAgIHNvdXJjZURlY2ltYWxzLFxuICAgIGRlc3RpbmF0aW9uVG9rZW4sXG4gICAgdmFsdWUsXG4gICAgZnJvbUFkZHJlc3MsXG4gICAgZXhjaGFuZ2VMaXN0LFxuICB9LFxuICB7IGNoYWluSWQgfSxcbikge1xuICBjb25zdCB1cmxQYXJhbXMgPSB7XG4gICAgZGVzdGluYXRpb25Ub2tlbixcbiAgICBzb3VyY2VUb2tlbixcbiAgICBzb3VyY2VBbW91bnQ6IGNhbGNUb2tlblZhbHVlKHZhbHVlLCBzb3VyY2VEZWNpbWFscykudG9TdHJpbmcoMTApLFxuICAgIHNsaXBwYWdlLFxuICAgIHRpbWVvdXQ6IFNFQ09ORCAqIDEwLFxuICAgIHdhbGxldEFkZHJlc3M6IGZyb21BZGRyZXNzLFxuICB9O1xuXG4gIGlmIChleGNoYW5nZUxpc3QpIHtcbiAgICB1cmxQYXJhbXMuZXhjaGFuZ2VMaXN0ID0gZXhjaGFuZ2VMaXN0O1xuICB9XG4gIGlmIChzaG91bGRFbmFibGVEaXJlY3RXcmFwcGluZyhjaGFpbklkLCBzb3VyY2VUb2tlbiwgZGVzdGluYXRpb25Ub2tlbikpIHtcbiAgICB1cmxQYXJhbXMuZW5hYmxlRGlyZWN0V3JhcHBpbmcgPSB0cnVlO1xuICB9XG5cbiAgY29uc3QgcXVlcnlTdHJpbmcgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHVybFBhcmFtcykudG9TdHJpbmcoKTtcbiAgY29uc3QgdHJhZGVVUkwgPSBgJHtnZXRCYXNlQXBpKCd0cmFkZScsIGNoYWluSWQpfSR7cXVlcnlTdHJpbmd9YDtcbiAgY29uc3QgdHJhZGVzUmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhDYWNoZShcbiAgICB0cmFkZVVSTCxcbiAgICB7IG1ldGhvZDogJ0dFVCcsIGhlYWRlcnM6IGNsaWVudElkSGVhZGVyIH0sXG4gICAgeyBjYWNoZVJlZnJlc2hUaW1lOiAwLCB0aW1lb3V0OiBTRUNPTkQgKiAxNSB9LFxuICApO1xuICBjb25zdCBuZXdRdW90ZXMgPSB0cmFkZXNSZXNwb25zZS5yZWR1Y2UoKGFnZ0lkVHJhZGVNYXAsIHF1b3RlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgcXVvdGUudHJhZGUgJiZcbiAgICAgICFxdW90ZS5lcnJvciAmJlxuICAgICAgdmFsaWRhdGVEYXRhKFFVT1RFX1ZBTElEQVRPUlMsIHF1b3RlLCB0cmFkZVVSTClcbiAgICApIHtcbiAgICAgIGNvbnN0IGNvbnN0cnVjdGVkVHJhZGUgPSBjb25zdHJ1Y3RUeFBhcmFtcyh7XG4gICAgICAgIHRvOiBxdW90ZS50cmFkZS50byxcbiAgICAgICAgZnJvbTogcXVvdGUudHJhZGUuZnJvbSxcbiAgICAgICAgZGF0YTogcXVvdGUudHJhZGUuZGF0YSxcbiAgICAgICAgYW1vdW50OiBkZWNpbWFsVG9IZXgocXVvdGUudHJhZGUudmFsdWUpLFxuICAgICAgICBnYXM6IGRlY2ltYWxUb0hleChxdW90ZS5tYXhHYXMpLFxuICAgICAgfSk7XG5cbiAgICAgIGxldCB7IGFwcHJvdmFsTmVlZGVkIH0gPSBxdW90ZTtcblxuICAgICAgaWYgKGFwcHJvdmFsTmVlZGVkKSB7XG4gICAgICAgIGFwcHJvdmFsTmVlZGVkID0gY29uc3RydWN0VHhQYXJhbXMoe1xuICAgICAgICAgIC4uLmFwcHJvdmFsTmVlZGVkLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYWdnSWRUcmFkZU1hcCxcbiAgICAgICAgW3F1b3RlLmFnZ3JlZ2F0b3JdOiB7XG4gICAgICAgICAgLi4ucXVvdGUsXG4gICAgICAgICAgc2xpcHBhZ2UsXG4gICAgICAgICAgdHJhZGU6IGNvbnN0cnVjdGVkVHJhZGUsXG4gICAgICAgICAgYXBwcm92YWxOZWVkZWQsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYWdnSWRUcmFkZU1hcDtcbiAgfSwge30pO1xuXG4gIHJldHVybiBuZXdRdW90ZXM7XG59XG4iLCJpbXBvcnQgeyBhYmlFUkMyMCB9IGZyb20gJ0BtZXRhbWFzay9tZXRhbWFzay1ldGgtYWJpcyc7XG5pbXBvcnQgeyBDb250cmFjdCB9IGZyb20gJ0BldGhlcnNwcm9qZWN0L2NvbnRyYWN0cyc7XG5pbXBvcnQgeyBXZWIzUHJvdmlkZXIgfSBmcm9tICdAZXRoZXJzcHJvamVjdC9wcm92aWRlcnMnO1xuXG4vKipcbiAqIEdldHMgdGhlICdfdmFsdWUnIHBhcmFtZXRlciBvZiB0aGUgZ2l2ZW4gdG9rZW4gdHJhbnNhY3Rpb24gZGF0YVxuICogKGkuZSBmdW5jdGlvbiBjYWxsKSBwZXIgdGhlIEh1bWFuIFN0YW5kYXJkIFRva2VuIEFCSSwgaWYgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdG9rZW5EYXRhIC0gZXRoZXJzIEludGVyZmFjZSB0b2tlbiBkYXRhLlxuICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gQSBkZWNpbWFsIHN0cmluZyB2YWx1ZS5cbiAqL1xuLyoqXG4gKiBHZXRzIGVpdGhlciB0aGUgJ190b2tlbklkJyBwYXJhbWV0ZXIgb3IgdGhlICdpZCcgcGFyYW0gb2YgdGhlIHBhc3NlZCB0b2tlbiB0cmFuc2FjdGlvbiBkYXRhLixcbiAqIFRoZXNlIGFyZSB0aGUgcGFyc2VkIHRva2VuSWQgdmFsdWVzIHJldHVybmVkIGJ5IGBwYXJzZVN0YW5kYXJkVG9rZW5UcmFuc2FjdGlvbkRhdGFgIGFzIGRlZmluZWRcbiAqIGluIHRoZSBFUkM3MjEgYW5kIEVSQzExNTUgQUJJcyBmcm9tIG1ldGFtYXNrLWV0aC1hYmlzIChodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svbWV0YW1hc2stZXRoLWFiaXMvdHJlZS9tYWluL3NyYy9hYmlzKVxuICpcbiAqIEBwYXJhbSB0b2tlbkRhdGEgLSBldGhlcnMgSW50ZXJmYWNlIHRva2VuIGRhdGEuXG4gKiBAcmV0dXJucyBBIGRlY2ltYWwgc3RyaW5nIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9rZW5JZFBhcmFtKHRva2VuRGF0YTogYW55ID0ge30pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICByZXR1cm4gKFxuICAgIHRva2VuRGF0YT8uYXJncz8uX3Rva2VuSWQ/LnRvU3RyaW5nKCkgPz8gdG9rZW5EYXRhPy5hcmdzPy5pZD8udG9TdHJpbmcoKVxuICApO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hUb2tlbkJhbGFuY2UoXG4gIGFkZHJlc3M6IHN0cmluZyxcbiAgdXNlckFkZHJlc3M6IHN0cmluZyxcbiAgcHJvdmlkZXI6IGFueSxcbik6IFByb21pc2U8YW55PiB7XG4gIGNvbnN0IGV0aGVyc1Byb3ZpZGVyID0gbmV3IFdlYjNQcm92aWRlcihwcm92aWRlcik7XG4gIGNvbnN0IHRva2VuQ29udHJhY3QgPSBuZXcgQ29udHJhY3QoYWRkcmVzcywgYWJpRVJDMjAsIGV0aGVyc1Byb3ZpZGVyKTtcbiAgY29uc3QgdG9rZW5CYWxhbmNlUHJvbWlzZSA9IHRva2VuQ29udHJhY3RcbiAgICA/IHRva2VuQ29udHJhY3QuYmFsYW5jZU9mKHVzZXJBZGRyZXNzKVxuICAgIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHJldHVybiBhd2FpdCB0b2tlbkJhbGFuY2VQcm9taXNlO1xufVxuIiwiaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgRXRoZXJEZW5vbWluYXRpb24gfSBmcm9tICcuLi9jb25zdGFudHMvY29tbW9uJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVUeXBlIH0gZnJvbSAnLi4vY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IE51bWVyaWMgfSBmcm9tICcuLi9tb2R1bGVzL051bWVyaWMnO1xuaW1wb3J0IHsgaXNTd2Fwc0RlZmF1bHRUb2tlblN5bWJvbCB9IGZyb20gJy4uL21vZHVsZXMvc3dhcHMudXRpbHMnO1xuXG5leHBvcnQgY29uc3QgVE9LRU5fVFJBTlNGRVJfTE9HX1RPUElDX0hBU0ggPVxuICAnMHhkZGYyNTJhZDFiZTJjODliNjljMmIwNjhmYzM3OGRhYTk1MmJhN2YxNjNjNGExMTYyOGY1NWE0ZGY1MjNiM2VmJztcblxuZXhwb3J0IGNvbnN0IFRSQU5TQUNUSU9OX05PX0NPTlRSQUNUX0VSUk9SX0tFWSA9ICd0cmFuc2FjdGlvbkVycm9yTm9Db250cmFjdCc7XG5cbmV4cG9ydCBjb25zdCBURU5fU0VDT05EU19JTl9NSUxMSVNFQ09ORFMgPSAxMF8wMDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjR2FzVG90YWwoZ2FzTGltaXQgPSAnMCcsIGdhc1ByaWNlID0gJzAnKSB7XG4gIHJldHVybiBuZXcgTnVtZXJpYyhnYXNMaW1pdCwgMTYpLnRpbWVzKG5ldyBOdW1lcmljKGdhc1ByaWNlLCAxNikpLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBudW1iZXIgYW5kIHNwZWNpZmllZCBwcmVjaXNpb24sIHJldHVybnMgdGhhdCBudW1iZXIgaW4gYmFzZSAxMCB3aXRoIGEgbWF4aW11bSBvZiBwcmVjaXNpb25cbiAqIHNpZ25pZmljYW50IGRpZ2l0cywgYnV0IHdpdGhvdXQgYW55IHRyYWlsaW5nIHplcm9zIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50IFRvIGJlIHVzZWQgd2hlbiB3aXNoaW5nXG4gKiB0byBkaXNwbGF5IG9ubHkgYXMgbXVjaCBkaWdpdHMgdG8gdGhlIHVzZXIgYXMgbmVjZXNzYXJ5XG4gKlxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBCaWdOdW1iZXJ9IG4gLSBUaGUgbnVtYmVyIHRvIGZvcm1hdFxuICogQHBhcmFtIHtudW1iZXJ9IHByZWNpc2lvbiAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgaW4gdGhlIHJldHVybiB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ30gVGhlIG51bWJlciBpbiBkZWNpbWFsIGZvcm0sIHdpdGggPD0gcHJlY2lzaW9uIHNpZ25pZmljYW50IGRpZ2l0cyBhbmQgbm8gZGVjaW1hbCB0cmFpbGluZyB6ZXJvc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdG9QcmVjaXNpb25XaXRob3V0VHJhaWxpbmdaZXJvcyhuLCBwcmVjaXNpb24pIHtcbiAgcmV0dXJuIG5ldyBCaWdOdW1iZXIobilcbiAgICAudG9QcmVjaXNpb24ocHJlY2lzaW9uKVxuICAgIC5yZXBsYWNlKC8oXFwuWzAtOV0qWzEtOV0pMCp8KFxcLjAqKS91LCAnJDEnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGNUb2tlbkFtb3VudCh2YWx1ZSwgZGVjaW1hbHMpIHtcbiAgY29uc3QgbXVsdGlwbGllciA9IE1hdGgucG93KDEwLCBOdW1iZXIoZGVjaW1hbHMgfHwgMCkpO1xuICByZXR1cm4gbmV3IEJpZ051bWJlcihTdHJpbmcodmFsdWUpKS5kaXYobXVsdGlwbGllcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTd2Fwc1Rva2Vuc1JlY2VpdmVkRnJvbVR4TWV0YShcbiAgdG9rZW5TeW1ib2wsXG4gIHR4TWV0YSxcbiAgdG9rZW5BZGRyZXNzLFxuICBhY2NvdW50QWRkcmVzcyxcbiAgdG9rZW5EZWNpbWFscyxcbiAgYXBwcm92YWxUeE1ldGEsXG4gIGNoYWluSWQsXG4pIHtcbiAgY29uc3QgdHhSZWNlaXB0ID0gdHhNZXRhPy50eFJlY2VpcHQ7XG4gIGNvbnN0IG5ldHdvcmtBbmRBY2NvdW50U3VwcG9ydHMxNTU5ID1cbiAgICB0eE1ldGE/LnR4UmVjZWlwdD8udHlwZSA9PT0gVHJhbnNhY3Rpb25FbnZlbG9wZVR5cGUuZmVlTWFya2V0O1xuICBpZiAoaXNTd2Fwc0RlZmF1bHRUb2tlblN5bWJvbCh0b2tlblN5bWJvbCwgY2hhaW5JZCkpIHtcbiAgICBpZiAoXG4gICAgICAhdHhSZWNlaXB0IHx8XG4gICAgICAhdHhNZXRhIHx8XG4gICAgICAhdHhNZXRhLnBvc3RUeEJhbGFuY2UgfHxcbiAgICAgICF0eE1ldGEucHJlVHhCYWxhbmNlXG4gICAgKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodHhNZXRhLnN3YXBNZXRhRGF0YSAmJiB0eE1ldGEucHJlVHhCYWxhbmNlID09PSB0eE1ldGEucG9zdFR4QmFsYW5jZSkge1xuICAgICAgLy8gSWYgcHJlVHhCYWxhbmNlIGFuZCBwb3N0VHhCYWxhbmNlIGFyZSBlcXVhbCwgcG9zdFR4QmFsYW5jZSBoYXNuJ3QgYmVlbiB1cGRhdGVkIG9uIHRpbWVcbiAgICAgIC8vIGJlY2F1c2Ugb2YgdGhlIFJQQyBwcm92aWRlciBkZWxheSwgc28gd2UgcmV0dXJuIGFuIGVzdGltYXRlZCByZWNlaXZpbmcgYW1vdW50IGluc3RlYWQuXG4gICAgICByZXR1cm4gdHhNZXRhLnN3YXBNZXRhRGF0YS50b2tlbl90b19hbW91bnQ7XG4gICAgfVxuXG4gICAgbGV0IGFwcHJvdmFsVHhHYXNDb3N0ID0gbmV3IE51bWVyaWMoJzB4MCcsIDE2KTtcbiAgICBpZiAoYXBwcm92YWxUeE1ldGEgJiYgYXBwcm92YWxUeE1ldGEudHhSZWNlaXB0KSB7XG4gICAgICBhcHByb3ZhbFR4R2FzQ29zdCA9IG5ldyBOdW1lcmljKFxuICAgICAgICBjYWxjR2FzVG90YWwoXG4gICAgICAgICAgYXBwcm92YWxUeE1ldGEudHhSZWNlaXB0Lmdhc1VzZWQsXG4gICAgICAgICAgbmV0d29ya0FuZEFjY291bnRTdXBwb3J0czE1NTlcbiAgICAgICAgICAgID8gYXBwcm92YWxUeE1ldGEudHhSZWNlaXB0LmVmZmVjdGl2ZUdhc1ByaWNlIC8vIEJhc2UgZmVlICsgcHJpb3JpdHkgZmVlLlxuICAgICAgICAgICAgOiBhcHByb3ZhbFR4TWV0YS50eFBhcmFtcy5nYXNQcmljZSxcbiAgICAgICAgKSxcbiAgICAgICAgMTYsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGdhc0Nvc3QgPSBjYWxjR2FzVG90YWwoXG4gICAgICB0eFJlY2VpcHQuZ2FzVXNlZCxcbiAgICAgIG5ldHdvcmtBbmRBY2NvdW50U3VwcG9ydHMxNTU5XG4gICAgICAgID8gdHhSZWNlaXB0LmVmZmVjdGl2ZUdhc1ByaWNlXG4gICAgICAgIDogdHhNZXRhLnR4UGFyYW1zLmdhc1ByaWNlLFxuICAgICk7XG4gICAgY29uc3QgdG90YWxHYXNDb3N0ID0gbmV3IE51bWVyaWMoZ2FzQ29zdCwgMTYpLmFkZChhcHByb3ZhbFR4R2FzQ29zdCk7XG5cbiAgICBjb25zdCBwcmVUeEJhbGFuY2VMZXNzR2FzQ29zdCA9IG5ldyBOdW1lcmljKHR4TWV0YS5wcmVUeEJhbGFuY2UsIDE2KS5taW51cyhcbiAgICAgIHRvdGFsR2FzQ29zdCxcbiAgICApO1xuXG4gICAgY29uc3QgZXRoUmVjZWl2ZWQgPSBuZXcgTnVtZXJpYyhcbiAgICAgIHR4TWV0YS5wb3N0VHhCYWxhbmNlLFxuICAgICAgMTYsXG4gICAgICBFdGhlckRlbm9taW5hdGlvbi5XRUksXG4gICAgKVxuICAgICAgLm1pbnVzKHByZVR4QmFsYW5jZUxlc3NHYXNDb3N0KVxuICAgICAgLnRvRGVub21pbmF0aW9uKEV0aGVyRGVub21pbmF0aW9uLkVUSClcbiAgICAgIC50b0Jhc2UoMTApXG4gICAgICAucm91bmQoNik7XG4gICAgcmV0dXJuIGV0aFJlY2VpdmVkLnRvU3RyaW5nKCk7XG4gIH1cbiAgY29uc3QgdHhSZWNlaXB0TG9ncyA9IHR4UmVjZWlwdD8ubG9ncztcbiAgaWYgKHR4UmVjZWlwdExvZ3MgJiYgdHhSZWNlaXB0Py5zdGF0dXMgIT09ICcweDAnKSB7XG4gICAgY29uc3QgdG9rZW5UcmFuc2ZlckxvZyA9IHR4UmVjZWlwdExvZ3MuZmluZCgodHhSZWNlaXB0TG9nKSA9PiB7XG4gICAgICBjb25zdCBpc1Rva2VuVHJhbnNmZXIgPVxuICAgICAgICB0eFJlY2VpcHRMb2cudG9waWNzICYmXG4gICAgICAgIHR4UmVjZWlwdExvZy50b3BpY3NbMF0gPT09IFRPS0VOX1RSQU5TRkVSX0xPR19UT1BJQ19IQVNIO1xuICAgICAgY29uc3QgaXNUcmFuc2ZlckZyb21HaXZlblRva2VuID0gdHhSZWNlaXB0TG9nLmFkZHJlc3MgPT09IHRva2VuQWRkcmVzcztcbiAgICAgIGNvbnN0IGlzVHJhbnNmZXJGcm9tR2l2ZW5BZGRyZXNzID1cbiAgICAgICAgdHhSZWNlaXB0TG9nLnRvcGljcyAmJlxuICAgICAgICB0eFJlY2VpcHRMb2cudG9waWNzWzJdICYmXG4gICAgICAgIHR4UmVjZWlwdExvZy50b3BpY3NbMl0ubWF0Y2goYWNjb3VudEFkZHJlc3Muc2xpY2UoMikpO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgaXNUb2tlblRyYW5zZmVyICYmXG4gICAgICAgIGlzVHJhbnNmZXJGcm9tR2l2ZW5Ub2tlbiAmJlxuICAgICAgICBpc1RyYW5zZmVyRnJvbUdpdmVuQWRkcmVzc1xuICAgICAgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG9rZW5UcmFuc2ZlckxvZ1xuICAgICAgPyB0b1ByZWNpc2lvbldpdGhvdXRUcmFpbGluZ1plcm9zKFxuICAgICAgICAgIGNhbGNUb2tlbkFtb3VudCh0b2tlblRyYW5zZmVyTG9nLmRhdGEsIHRva2VuRGVjaW1hbHMpLnRvU3RyaW5nKDEwKSxcbiAgICAgICAgICA2LFxuICAgICAgICApXG4gICAgICA6ICcnO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgY29uc3QgVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRV9OQU1FUyA9IHtcbiAgRkVFX01BUktFVDogJ2ZlZS1tYXJrZXQnLFxuICBMRUdBQ1k6ICdsZWdhY3knLFxufTtcbiIsImltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgQk4gZnJvbSAnYm4uanMnO1xuaW1wb3J0IHsgaXNIZXhTdHJpbmcsIGlzTnVsbE9yVW5kZWZpbmVkIH0gZnJvbSAnQG1ldGFtYXNrL3V0aWxzJztcbmltcG9ydCB7IGFkZEhleFByZWZpeCB9IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XG5pbXBvcnQgeyBFdGhlckRlbm9taW5hdGlvbiB9IGZyb20gJy4uL2NvbnN0YW50cy9jb21tb24nO1xuaW1wb3J0IHsgc3RyaXBIZXhQcmVmaXggfSBmcm9tICcuL2hleHN0cmluZy11dGlscyc7XG5cbmV4cG9ydCB0eXBlIE51bWVyaWNWYWx1ZSA9IHN0cmluZyB8IG51bWJlciB8IEJOIHwgQmlnTnVtYmVyO1xuZXhwb3J0IHR5cGUgTnVtZXJpY0Jhc2UgPSAxMCB8IDE2O1xuXG4vKipcbiAqIEFsbCB2YXJpYXRpb25zIG9mIGlzSGV4U3RyaW5nIGZyb20gb3VyIG93biB1dGlsaXRpZXMgYW5kIGV0aGVydW1qcy11dGlsc1xuICogcmV0dXJuIGZhbHNlIGZvciBhICctJyBwcmVmaXhlZCBoZXggc3RyaW5nLiBUaGlzIHV0aWxpdHkgbWV0aG9kIHN0cmlwcyB0aGVcbiAqIHBvc3NpYmxlICctJyBmcm9tIHRoZSBzdHJpbmcgYmVmb3JlIHRlc3RpbmcgaXRzIHZhbGlkaXR5IHNvIHRoYXQgbmVnYXRpdmVcbiAqIGhleCB2YWx1ZXMgY2FuIGJlIHByb3Blcmx5IGhhbmRsZWQuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyB0byBjaGVja1xuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChuZWdhdGl2ZSBvciBvdGhlcndpc2UpXG4gKi9cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nT3JOZWdhdGVkSGV4U3RyaW5nKHZhbHVlOiBzdHJpbmcpOiB2YWx1ZSBpcyBzdHJpbmcge1xuICByZXR1cm4gaXNIZXhTdHJpbmcodmFsdWUucmVwbGFjZSgnLScsICcnKSkgfHwgaXNIZXhTdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIEJpZ051bWJlciBzdXBwb3J0cyBoZXggc3RyaW5ncyB3aXRoICcuJyAoYWthIGRlY2ltYWxzKSBpbiB0aGUgc3RyaW5nLlxuICogTm8gdmVyc2lvbiBvZiBpc0hleFN0cmluZyByZXR1cnMgdHJ1ZSBpZiB0aGUgc3RyaW5nIGNvbnRhaW5zIGEgZGVjaW1hbCBzb1xuICogdGhpcyBtZXRob2QgaXMgdXNlZCB0byBjaGVjayBpZiBib3RoIHBhcnRzIG9mIHRoZSBzdHJpbmcgc3BsaXQgYnkgdGhlXG4gKiBkZWNpbWFsIGFyZSBoZXggc3RyaW5ncy4gSWYgc28gd2UgY2FuIGZlZWQgdGhpcyB2YWx1ZSBpbnRvIEJpZ051bWJlciB0byBnZXRcbiAqIGEgdmFsaWQgTnVtZXJpYy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBzdHJpbmcgaXMgYSBoZXhhZGVjaW1hbCBzcGxpdCBieSAnLidcbiAqL1xuZnVuY3Rpb24gaXNEZWNpbWFsSGV4KHZhbHVlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgcGFydHMgPSB2YWx1ZS5zcGxpdCgnLicpO1xuICBpZiAocGFydHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBwYXJ0cy5ldmVyeSgocGFydCkgPT4gaXNIZXhTdHJpbmdPck5lZ2F0ZWRIZXhTdHJpbmcocGFydCkpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgaGV4YWRlY2ltYWwgaW4gc3RyaW5nIG9yIG51bWJlciBmb3JtYXQgdG8gYSBCaWdOdW1iZXIuXG4gKiBOb3RlIHRoYXQgaW4gbWFueSBwbGFjZXMgaW4gb3VyIGNvZGViYXNlIHdlIGNhbGwgJ2FkZEhleFByZWZpeCcgb24gYSBuZWdhdGVkXG4gKiBoZXhhZGVjaW1hbCBzdHJpbmcgcmVzdWx0aW5nIGluICcweC1hJyB3aGljaCB3aWxsIGZhaWwgY2hlY2tzIGZvclxuICogaXNIZXhTdHJpbmcuIFNvbWV0aW1lcyB3ZSBETyBub3QgYWRkIHRoZSAweCBzbyB3ZSBoYXZlIHRvIGNoZWNrIGZvciAnLWEnXG4gKiBhcyB3ZWxsLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIGhleGFkZWNpbWFsIHZhbHVlIGluIHN0cmluZyBvciBudW1iZXIgZm9ybWF0LlxuICogQHJldHVybnMgQSBCaWdOdW1iZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGhleGFkZWNpbWFsVG9CaWdOdW1iZXIodmFsdWU6IHN0cmluZyB8IG51bWJlcik6IEJpZ051bWJlciB7XG4gIGNvbnN0IHN0cmluZ2lmaWVkID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IGAke3ZhbHVlfWAgOiB2YWx1ZTtcbiAgY29uc3QgaXNOZWdhdGl2ZSA9IHN0cmlwSGV4UHJlZml4KHN0cmluZ2lmaWVkKVswXSA9PT0gJy0nO1xuICBjb25zdCB2YWx1ZVdpdGhvdXROZWdhdGlvbiA9IHN0cmluZ2lmaWVkLnJlcGxhY2UoJy0nLCAnJyk7XG5cbiAgY29uc3QgdmFsdWVBc0JpZ051bWJlciA9IG5ldyBCaWdOdW1iZXIoXG4gICAgc3RyaXBIZXhQcmVmaXgodmFsdWVXaXRob3V0TmVnYXRpb24pLFxuICAgIDE2LFxuICApO1xuXG4gIHJldHVybiBpc05lZ2F0aXZlID8gdmFsdWVBc0JpZ051bWJlci5uZWdhdGVkKCkgOiB2YWx1ZUFzQmlnTnVtYmVyO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgZGVjaW1hbCBpbiBzdHJpbmcgb3IgbnVtYmVyIGZvcm1hdCB0byBhIEJpZ051bWJlci5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBkZWNpbWFsIHZhbHVlIGluIHN0cmluZyBvciBudW1iZXIgZm9ybWF0LlxuICogQHJldHVybnMgQSBCaWdOdW1iZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGRlY2ltYWxUb0JpZ051bWJlcih2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKSB7XG4gIHJldHVybiBuZXcgQmlnTnVtYmVyKFN0cmluZyh2YWx1ZSksIDEwKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHNhZmVseSBjb252ZXJ0IGEgc3RyaW5nIHR5cGUgdmFsdWUgdG8gYSBCaWdOdW1iZXIuXG4gKiBUaGUgb25seSB2YWxpZCBzdHJpbmdzIGZvciB0aGlzIG1ldGhvZCBhcmUgdGhvc2UgdGhhdCBhcmUgZWl0aGVyIGhleGFkZWNpbWFsXG4gKiBudW1lcmljIHZhbHVlcyBPUiBudW1lcmljIHN0cmluZ3MgdGhhdCBjYW4gYmUgY29udmVydGVkIHRvIEJpZ051bWJlcnMuIEl0IGlzXG4gKiBpbXBvc3NpYmxlIHRvIHRlbGwgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBhIGhleCB2YWx1ZSBvZiAxMDAwMDAgdnMgYSBkZWNpbWFsXG4gKiB2YWx1ZSBvZiAxMDAwMDAgc28gYSBzZWNvbmQgcGFyYW1ldGVyIGluZGljYXRpbmcgdGhlIG51bWVyaWMgYmFzZSBvZiB0aGVcbiAqIHN0cmluZyB2YWx1ZSBtdXN0IGJlIHByb3ZpZGVkLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIEEgaGV4YWRlY2ltYWwgb3IgZGVjaW1hbCBzdHJpbmdcbiAqIEBwYXJhbSBudW1lcmljQmFzZSAtIEVpdGhlciAxNiBmb3IgYSBoZXhhZGVjaWFtbCBvciAxMCBmb3IgYSBkZWNpbWFsXG4gKiBAcmV0dXJucyBBIEJpZ051bWJlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmFsdWVcbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9CaWdOdW1iZXIodmFsdWU6IHN0cmluZywgbnVtZXJpY0Jhc2U6IE51bWVyaWNCYXNlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgdmFsdWV9IHBhc3NlZCB0byBzdHJpbmdUb0JpZ051bWJlcmAsXG4gICAgKTtcbiAgfVxuICBpZiAoXG4gICAgbnVtZXJpY0Jhc2UgPT09IDE2ICYmXG4gICAgKGlzSGV4U3RyaW5nT3JOZWdhdGVkSGV4U3RyaW5nKHZhbHVlKSB8fCBpc0RlY2ltYWxIZXgodmFsdWUpKVxuICApIHtcbiAgICByZXR1cm4gaGV4YWRlY2ltYWxUb0JpZ051bWJlcih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoXG4gICAgbnVtZXJpY0Jhc2UgPT09IDEwICYmXG4gICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSBhIGZpbml0ZSBpbnRlZ2VyIG9yIGZsb2F0XG4gICAgKGlzRmluaXRlKHBhcnNlSW50KHZhbHVlLCAxMCkpIHx8IGlzRmluaXRlKHBhcnNlRmxvYXQodmFsdWUpKSlcbiAgKSB7XG4gICAgcmV0dXJuIGRlY2ltYWxUb0JpZ051bWJlcih2YWx1ZSk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBTdHJpbmcgcHJvdmlkZWQgdG8gc3RyaW5nVG9CaWdOdW1iZXIgaXMgbm90IGEgaGV4YWRlY2ltYWwgb3IgZGVjaW1hbCBzdHJpbmc6ICR7dmFsdWV9LCAke251bWVyaWNCYXNlfWAsXG4gICk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2Qgd2lsbCBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgb3IgZGVjaWFtbCBudW1iZXIgaW50byBhIEJpZ051bWJlci5cbiAqIFRoZSBzZWNvbmQgcGFyYW1ldGVyIG11c3QgYmUgc3VwcGxpZWQgYW5kIGRldGVybWluZXMgd2hldGhlciB0byB0cmVhdCB0aGVcbiAqIHZhbHVlIGFzIGEgaGV4YWRlY2ltYWwgb3IgZGVjaW1hbCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBoZXhhZGVjaW1hbCBvciBkZWNpbWFsIG51bWJlcltdXG4gKiBAcGFyYW0gbnVtZXJpY0Jhc2UgLSAxMCBmb3IgZGVjaW1hbCwgMTYgZm9yIGhleGFkZWNpbWFsXG4gKiBAcmV0dXJucyBCaWdOdW1iZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIG51bWJlclRvQmlnTnVtYmVyKHZhbHVlOiBudW1iZXIsIG51bWVyaWNCYXNlOiBOdW1lcmljQmFzZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBWYWx1ZSBvZiB0eXBlICR7dHlwZW9mIHZhbHVlfSBwYXNzZWQgdG8gbnVtYmVyVG9CaWdOdW1iZXJgLFxuICAgICk7XG4gIH1cbiAgaWYgKG51bWVyaWNCYXNlID09PSAxNiAmJiBpc0hleFN0cmluZyhgJHt2YWx1ZX1gKSkge1xuICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKGAke3ZhbHVlfWAsIDE2KTtcbiAgfVxuICByZXR1cm4gbmV3IEJpZ051bWJlcih2YWx1ZSwgMTApO1xufVxuXG4vKipcbiAqIE1ldGhvZCB0byBjb252ZXJ0IGEgQk4gdG8gYSBCaWdOdW1iZXJcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBBIEJOIHJlcHJlc2VudGF0aW9uIG9mIGEgdmFsdWVcbiAqIEByZXR1cm5zIEEgQmlnTnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBCTidzIHVuZGVybHlpbmcgdmFsdWVcbiAqL1xuZnVuY3Rpb24gYm5Ub0JpZ051bWJlcih2YWx1ZTogQk4pIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQk4gPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYHZhbHVlIHBhc3NlZCB0byBiblRvQmlnTnVtYmVyIGlzIG5vdCBhIEJOLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIHZhbHVlfWAsXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbmV3IEJpZ051bWJlcih2YWx1ZS50b1N0cmluZygxNiksIDE2KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHZhbHVlIG9mIHRoZSBzdXBwb3J0ZWQgdHlwZXMgKHN0cmluZywgbnVtYmVyLCBCTikgdG8gYSBCaWdOdW1iZXIuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBCaWdOdW1iZXJcbiAqIEBwYXJhbSBudW1lcmljQmFzZSAtIFRoZSBudW1lcmljIGJhc2Ugb2YgdGhlIHVuZGVybHlpbmcgdmFsdWVcbiAqIEByZXR1cm5zIEEgQmlnTnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZVxuICovXG5mdW5jdGlvbiB2YWx1ZVRvQmlnTnVtYmVyKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIsIG51bWVyaWNCYXNlOiBOdW1lcmljQmFzZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdHJpbmdUb0JpZ051bWJlcih2YWx1ZSwgbnVtZXJpY0Jhc2UpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBudW1iZXJUb0JpZ051bWJlcih2YWx1ZSwgbnVtZXJpY0Jhc2UpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBWYWx1ZTogJHt2YWx1ZX0gaXMgbm90IGEgc3RyaW5nLCBudW1iZXIsIEJpZ051bWJlciBvciBCTi4gVHlwZSBpczogJHt0eXBlb2YgdmFsdWV9LmAsXG4gICk7XG59XG5cbi8vIEJpZyBOdW1iZXIgQ29uc3RhbnRzXG5jb25zdCBCSUdfTlVNQkVSX1dFSV9NVUxUSVBMSUVSID0gbmV3IEJpZ051bWJlcignMTAwMDAwMDAwMDAwMDAwMDAwMCcpO1xuY29uc3QgQklHX05VTUJFUl9HV0VJX01VTFRJUExJRVIgPSBuZXcgQmlnTnVtYmVyKCcxMDAwMDAwMDAwJyk7XG5jb25zdCBCSUdfTlVNQkVSX0VUSF9NVUxUSVBMSUVSID0gbmV3IEJpZ051bWJlcignMScpO1xuXG5jb25zdCB0b05vcm1hbGl6ZWREZW5vbWluYXRpb24gPSB7XG4gIFdFSTogKGJpZ051bWJlcjogQmlnTnVtYmVyKSA9PiBiaWdOdW1iZXIuZGl2KEJJR19OVU1CRVJfV0VJX01VTFRJUExJRVIpLFxuICBHV0VJOiAoYmlnTnVtYmVyOiBCaWdOdW1iZXIpID0+IGJpZ051bWJlci5kaXYoQklHX05VTUJFUl9HV0VJX01VTFRJUExJRVIpLFxuICBFVEg6IChiaWdOdW1iZXI6IEJpZ051bWJlcikgPT4gYmlnTnVtYmVyLmRpdihCSUdfTlVNQkVSX0VUSF9NVUxUSVBMSUVSKSxcbn07XG5jb25zdCB0b1NwZWNpZmllZERlbm9taW5hdGlvbiA9IHtcbiAgV0VJOiAoYmlnTnVtYmVyOiBCaWdOdW1iZXIpID0+XG4gICAgYmlnTnVtYmVyLnRpbWVzKEJJR19OVU1CRVJfV0VJX01VTFRJUExJRVIpLnJvdW5kKCksXG4gIEdXRUk6IChiaWdOdW1iZXI6IEJpZ051bWJlcikgPT5cbiAgICBiaWdOdW1iZXIudGltZXMoQklHX05VTUJFUl9HV0VJX01VTFRJUExJRVIpLnJvdW5kKDkpLFxuICBFVEg6IChiaWdOdW1iZXI6IEJpZ051bWJlcikgPT5cbiAgICBiaWdOdW1iZXIudGltZXMoQklHX05VTUJFUl9FVEhfTVVMVElQTElFUikucm91bmQoOSksXG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGluIEVUSCBvZiB0aGUgbnVtZXJpYyBzdXBwbGllZCwgdXNlZCBpbiB0aGlzIGZpbGUgb25seSB0b1xuICogY29udmVydCB0byBFVEggcHJpb3IgdG8gY29udmVydGluZyB0byBhbm90aGVyIGRlbm9taW5hdGlvbi4gVGhlIGZvbGxvd2luZ1xuICogcXVpcmtzIHdlcmUgcHJvZ3JhbW1lZCBpbnRvIHRoaXMgbWV0aG9kIHRvIHJlcGxpY2F0ZSBiZWhhdmlvciBvZiB0aGVcbiAqIHByZWRlY2Vzc29yIHRvIE51bWVyaWMsIHdoaWNoIHdhcyAnY29udmVyc2lvblV0aWwnLiBJZiBhIGRlbm9taW5hdGlvbiBpc1xuICogbm90IHN1cHBsaWVkLCBhbmQgdG9EZW5vbWluYXRpb24gaXMgY2FsbGVkLCB0aGVuIHdlIGFzc3VtZSB0aGUgZGVub21pbmF0aW9uXG4gKiB3YXMgb3JpZ2luYWxseSBFVEgsIG90aGVyd2lzZSB3ZSBjb252ZXJ0IGl0IHRvIEVUSC5cbiAqXG4gKiBAcGFyYW0gbnVtZXJpY1xuICogQHJldHVybnMgdmFsdWUgaW4gRVRIXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlSW5FVEgobnVtZXJpYzogTnVtZXJpYykge1xuICBpZiAoXG4gICAgbnVtZXJpYy5kZW5vbWluYXRpb24gPT09IEV0aGVyRGVub21pbmF0aW9uLkVUSCB8fFxuICAgIHR5cGVvZiBudW1lcmljLmRlbm9taW5hdGlvbiA9PT0gJ3VuZGVmaW5lZCdcbiAgKSB7XG4gICAgcmV0dXJuIG51bWVyaWMudmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRvTm9ybWFsaXplZERlbm9taW5hdGlvbltudW1lcmljLmRlbm9taW5hdGlvbl0obnVtZXJpYy52YWx1ZSk7XG59XG5cbi8qKlxuICogV2hlbiBhcHBseWluZyBvcGVyYW5kcyB0byBOdW1lcmljcyB0aGF0IGhhdmUgYSBzcGVjaWZpZWQgRGVub21pbmF0aW9uIHRoZW5cbiAqIHdlIHNob3VsZCBmaXJzdCBjb252ZXJ0IHRoZSBwcm92aWRlZCBpbnB1dE51bWVyaWMgdG8gdGhlIHNhbWUgRGVub21pbmF0aW9uXG4gKiBhcyB0aGUgYmFzZU51bWVyaWMuIFRoZXJlIGFyZSBjYXNlcyB3aGVyZSB0aGlzIGRvZXNuJ3QgYXBwbHk6XG4gKlxuICogMS4gSWYgdGhlIGRlbm9taW5hdGlvbnMgYXJlIGFscmVhZHkgdGhlIHNhbWUuIE5vIGNvbnZlcnNpb24gaXMgbmVjZXNzYXJ5LlxuICogMi4gSWYgdGhlIGlucHV0TnVtZXJpYyBkb2VzIG5vdCBoYXZlIGEgZGVub21pbmF0aW9uIHNldC4gV2UgYXNzdW1lIGluIHRoaXNcbiAqIGNhc2UgdGhhdCB0aGUgdmFsdWUgaXMgYWxyZWFkeSBpbiB0aGUgYXBwcm9wcmlhdGUgZGVub21pbmF0aW9uLlxuICpcbiAqIEBwYXJhbSBiYXNlTnVtZXJpY1xuICogQHBhcmFtIGlucHV0TnVtZXJpY1xuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gYWxpZ25PcGVyYW5kRGVub21pbmF0aW9ucyhcbiAgYmFzZU51bWVyaWM6IE51bWVyaWMsXG4gIGlucHV0TnVtZXJpYzogTnVtZXJpYyxcbikge1xuICBpZiAoXG4gICAgdHlwZW9mIGlucHV0TnVtZXJpYy5kZW5vbWluYXRpb24gIT09ICd1bmRlZmluZWQnICYmXG4gICAgYmFzZU51bWVyaWMuZGVub21pbmF0aW9uICE9PSBpbnB1dE51bWVyaWMuZGVub21pbmF0aW9uXG4gICkge1xuICAgIHJldHVybiBpbnB1dE51bWVyaWMudG9EZW5vbWluYXRpb24oYmFzZU51bWVyaWMuZGVub21pbmF0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBpbnB1dE51bWVyaWM7XG59XG5cbi8qKlxuICogTnVtZXJpYyBpcyBhIGNsYXNzIHdob3NlIG1ldGhvZHMgd2lsbCBhbHdheXMgcmV0dXJuIGEgbmV3LCBub3QgbXV0YXRlZCxcbiAqIHZhbHVlLiBUaGlzIGFsbG93cyBmb3IgY2hhaW5pbmcgb2Ygbm9uLXRlcm1pbmF0aW5nIG1ldGhvZHMuIFByZXZpb3VzbHkgd2VcbiAqIGhhZCBuZWFyIGEgaHVuZHJlZCBoZWxwZXIgbWV0aG9kcyB0aGF0IGNvbXBvc2VkIG9uZS1hbm90aGVyLCBtYWtpbmcgdHJhY2tpbmdcbiAqIHRocm91Z2ggdGhlIGNoYWluIG5lYXIgaW1wb3NzaWJsZS4gVGhpcyBBUEkgaXMgZGVzaWduZWQgc3VjaCB0aGF0IG5vIGhlbHBlclxuICogbWV0aG9kcyBzaG91bGQgYmUgbmVlZGVkLiBUYWtlIHRoZSBjYXNlIG9mIGhleFdFSVRvRGVjR1dFSSwgYSBoZWxwZXIgbWV0aG9kXG4gKiBmb3IgdGFraW5nIGEgaGV4IHN0cmluZyByZXByZXNlbnRpbmcgYSB2YWx1ZSBpbiBXRUkgYW5kIGNvbnZlcnRpbmcgdGhhdCB0byBhXG4gKiBkZWNpbWFsIG9mIEdXRUkuIFByaW9yIHRvIHRoaXMgY2xhc3MgdGhlIG1ldGhvZCB3b3VsZCBjYWxsIGludG8gb3VyIHJvb3RcbiAqIGxldmVsICdjb252ZXJzaW9uVXRpbCcgd2hpY2ggd2FzIHRoZSBwcm92ZXJiaWFsIGtpdGNoZW4gc2luayBkb2luZ1xuICogZXZlcnl0aGluZyBmcm9tIGRlbm9taW5hdGlvbiBjb252ZXJzaW9uLCBjdXJyZW5jeSBjb252ZXJzaW9uICh3aXRoIHByb3ZpZGVkXG4gKiBjb252ZXJzaW9uUmF0ZSBwcm9wKSBhbmQgbW9yZS4gVGhlIHNhbWUgb3BlYXJ0aW9uIGNhbiBub3cgYmUgZXhwcmVzc2VkIGFzOlxuICogbmV3IE51bWVyaWMoaGV4U3RyaW5nLCAxNiwgRXRoZXJEZW5vbWluYXRpb24uV0VJKVxuICogLnRvRGVub21pbmF0aW9uKEV0aGVyRGVub21pbmF0aW9uLkdXRUkpXG4gKiAudG9CYXNlKDEwKVxuICogLnRvU3RyaW5nKCk7XG4gKiBUaGlzIGhhcyB0aGUgYmVuZWZpdCBvZiBiZWluZyBmYWlybHkgdHJhbnNwYXJlbnQgYXMgeW91IGNhbiByZWFkIGVhY2ggc3RlcFxuICogaW4gdGhlIGNoYWluIGFuZCBoYXZlIGEgZ29vZCBzZW5zZSBvZiB3aGF0IGlzIGJlaW5nIGRvbmUuIEl0IGFsc28gaXMgaGlnaGx5XG4gKiBjb21wb3NhYmxlIHNvIHRoYXQgd2Ugc2hvdWxkbid0IG5lZWQgdG9ucyBvZiBoZWxwZXIgbWV0aG9kcyBmb3Igc2hvcnRjdXRzLlxuICovXG5leHBvcnQgY2xhc3MgTnVtZXJpYyB7XG4gIC8qKlxuICAgKiBUaGUgdW5kZXJseWluZyB2YWx1ZSBvZiB0aGUgTnVtZXJpYywgYWx3YXlzIGluIEJpZ051bWJlciBmb3JtXG4gICAqL1xuICB2YWx1ZTogQmlnTnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbnVtZXJpYyBiYXNlIGZvciB0aGlzIE51bWVyaWMsIGVpdGhlciAxMCBmb3IgZGVjaW1hbCBvciAxNiBmb3IgSGV4XG4gICAqL1xuICBiYXNlPzogTnVtZXJpY0Jhc2U7XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGRlbm9taW5hdGlvbiwgaWYgYW55LiBUaGUgb25seSBzdXBwb3J0ZWQgZGVub21pbmF0aW9ucyBhcmVcbiAgICogRVRILCBHV0VJLCBXRUkuXG4gICAqL1xuICBkZW5vbWluYXRpb24/OiBFdGhlckRlbm9taW5hdGlvbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICB2YWx1ZTogTnVtZXJpY1ZhbHVlLFxuICAgIGJhc2U/OiBOdW1lcmljQmFzZSxcbiAgICBkZW5vbWluYXRpb24/OiBFdGhlckRlbm9taW5hdGlvbixcbiAgKSB7XG4gICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICB0aGlzLmRlbm9taW5hdGlvbiA9IGRlbm9taW5hdGlvbjtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQk4pIHtcbiAgICAgIHRoaXMudmFsdWUgPSBiblRvQmlnTnVtYmVyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHx8XG4gICAgICAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHx8XG4gICAgICAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZSA9PT0gJycpXG4gICAgKSB7XG4gICAgICAvLyBUaGVyZSBhcmUgcGFydHMgb2YgdGhlIGNvZGViYXNlIHRoYXQgY2FsbCB0aGlzIG1ldGhvZCB3aXRob3V0IGEgdmFsdWUsXG4gICAgICAvLyBvciB3aXRoIGEgJ05hTicgKHdoaWNoIGlzIHByb2JhYmx5IGEgYnVnIHNvbWV3aGVyZSBpbiBvdXIgdGVzdHM/KS5cbiAgICAgIC8vIE92ZXIgdGltZSBvZiBjb252ZXJ0aW5nIHRvIFR5cGVTY3JpcHQgd2Ugd2lsbCBlcmFkaWNhdGUgdGhvc2UsIGJ1dCB0aGVcbiAgICAgIC8vIGhlbHBlciBtZXRob2RzIHRoYXQgdGhvc2UgaW5zdGFuY2VzIGVtcGxveSB3b3VsZCBkZWZhdWx0IHRoZSB2YWx1ZSB0b1xuICAgICAgLy8gMC4gVGhpcyBibG9jayBrZWVwcyB0aGF0IGludGFjdC5cbiAgICAgIHRoaXMudmFsdWUgPSBuZXcgQmlnTnVtYmVyKCcwJywgMTApO1xuICAgICAgdGhpcy5iYXNlID0gMTA7XG4gICAgfSBlbHNlIGlmIChiYXNlKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWVUb0JpZ051bWJlcih2YWx1ZSwgYmFzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFlvdSBtdXN0IHNwZWNpZnkgdGhlIGJhc2Ugb2YgdGhlIHByb3ZpZGVkIG51bWJlciBpZiB0aGUgdmFsdWUgaXMgbm90IGFscmVhZHkgYSBCaWdOdW1iZXJgLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhIHRvb2wgdXNlZCBpbnRlcm5hbGx5IHRvIGNoZWNrIGlmIGEgdmFsdWUgaXMgYWxyZWFkeSBhIE51bWVyaWNcbiAgICogYW5kIHJldHVybiBpdCBpZiBpdCBpcywgb3RoZXJ3aXNlIGl0IHVzZXMgdGhlIG90aGVyIHByb3ZpZGVkIGFyZ3VtZW50cyB0b1xuICAgKiBjcmVhdGUgYSBuZXcgTnVtZXJpYy5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBOdW1lcmljXG4gICAqIEBwYXJhbSBiYXNlIC0gRWl0aGVyIHVuZGVmaW5lZCwgMTAgZm9yIGRlY2ltYWwgb3IgMTYgZm9yIGhleGFkZWNpbWFsXG4gICAqIEBwYXJhbSBkZW5vbWluYXRpb24gLSBUaGUgRXRoZXIgZGVub21pbmF0aW9uIHRvIHNldCwgaWYgYW55XG4gICAqL1xuICBzdGF0aWMgZnJvbShcbiAgICB2YWx1ZTogTnVtZXJpYyB8IE51bWVyaWNWYWx1ZSxcbiAgICBiYXNlPzogTnVtZXJpY0Jhc2UsXG4gICAgZGVub21pbmF0aW9uPzogRXRoZXJEZW5vbWluYXRpb24sXG4gICkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE51bWVyaWMpIHtcbiAgICAgIGlmIChiYXNlIHx8IGRlbm9taW5hdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYE51bWVyaWMuZnJvbSB3YXMgY2FsbGVkIHdpdGggYSB2YWx1ZSAoJHt2YWx1ZS50b1N0cmluZygpfSkgdGhhdCBpcyBhbHJlYWR5IGEgTnVtZXJpYyBidXQgYSBiYXNlIGFuZC9vciBkZW5vbWluYXRpb24gd2FzIHByb3ZpZGVkLiBPbmx5IHN1cHBseSBiYXNlIG9yIGRlbm9taW5hdGlvbiB3aGVuIGNyZWF0aW5nIGEgbmV3IE51bWVyaWNgLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE51bWVyaWModmFsdWUsIGJhc2UsIGRlbm9taW5hdGlvbik7XG4gIH1cblxuICAvKiogQ29udmVyc2lvbnMgKi9cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBOdW1lcmljIHdpdGggdGhlIGJhc2UgdmFsdWUgY2hhbmdlZCB0byB0aGUgcHJvdmlkZWQgYmFzZSxcbiAgICogb3IgdGhlIG9yaWdpbmFsIE51bWVyaWMgaWYgdGhlIGJhc2UgcHJvdmlkZWQgaXMgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnRcbiAgICogYmFzZS4gTm8gY29tcHV0YXRpb24gb3IgY29udmVyc2lvbiBoYXBwZW5zIGhlcmUgYnV0IHJhdGhlciB0aGUgcmVzdWx0IG9mXG4gICAqIHRvU3RyaW5nIHdpbGwgYmUgY2hhbmdlZCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlIG9mIHRoaXMuYmFzZSB3aGVuIHRoYXRcbiAgICogbWV0aG9kIGlzIGludm9rZWQuXG4gICAqXG4gICAqIEBwYXJhbSBiYXNlIC0gVGhlIG51bWVyaWMgYmFzZSB0byBjaGFuZ2UgdGhlIE51bWVyaWMgdG8sIGVpdGhlciAxMCBvciAxNlxuICAgKiBAcmV0dXJucyBBIG5ldyBOdW1lcmljIHdpdGggdGhlIGJhc2UgdXBkYXRlZFxuICAgKi9cbiAgdG9CYXNlKGJhc2U6IE51bWVyaWNCYXNlKSB7XG4gICAgaWYgKHRoaXMuYmFzZSAhPT0gYmFzZSkge1xuICAgICAgcmV0dXJuIG5ldyBOdW1lcmljKHRoaXMudmFsdWUsIGJhc2UsIHRoaXMuZGVub21pbmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHZhbHVlIHRvIHRoZSBzcGVjaWZpZWQgZGVub21pbmF0aW9uLiBUaGUgZm9sbG93aW5nIHF1aXJrcyBvZlxuICAgKiB0aGUgcHJlZGVjZXNzb3IgdG8gTnVtZXJpYywgJ2NvbnZlcnNpb25VdGlsJywgd2VyZSBwcm9ncmFtbWVkIGludG8gdGhpc1xuICAgKiBtZXRob2Q6XG4gICAqIDEuIFlvdSBtYXkgc3VwcGx5IGEgZGVub21pbmF0aW9uIHRoYXQgaXMgdW5kZWZpbmVkLCB3aGljaCB3aWxsIHJlc3VsdCBpblxuICAgKiBub3RoaW5nIGhhcHBlbmluZy4gQ29pbmNpZGVudGx5IHRoaXMgaXMgYWxzbyB1c2VmdWwgZHVlIHRvIHRoZSBuYXR1cmUgb2ZcbiAgICogY2hhaW5pbmcgb3BlcmF0aW9ucyBvbiBOdW1lcmljLiBZb3UgbWF5IHBhc3MgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoaXNcbiAgICogbWV0aG9kIHdpdGhvdXQgYnJlYWtpbmcgdGhlIGNoYWluIHRvIGNvbmRpdGlvbmFsbHkgYXBwbHkgYSBvcGVyYXRvci5cbiAgICogMi4gSWYgdGhlIG51bWVyaWMgdGhhdCAudG9EZW5vbWluYXRpb24gaXMgY2FsbGVkIG9uIGRvZXMgbm90IGhhdmUgYVxuICAgKiBkZW5vbWluYXRpb24gc2V0LCB0aGF0IGlzIGl0IHdhcyBjb25zdHJ1Y3RlZCB3aXRob3V0IHRoZSB0aGlyZCBwYXJhbWV0ZXIsXG4gICAqIHRoZW4gaXQgaXMgYXNzdW1lZCB0byBiZSBpbiBFVEguIE90aGVyd2lzZSB3ZSBjb252ZXJ0IGl0IHRvIEVUSCBwcmlvciB0b1xuICAgKiBhdHRlbXB0aW5nIHRvIGNvbnZlcnQgaXQgdG8gYW5vdGhlciBkZW5vbWluYXRpb24gYmVjYXVzZSBhbGwgb2YgdGhlXG4gICAqIHRvU3BlY2lmaWVkRGVub21pbmF0aW9uIG1ldGhvZHMgYXNzdW1lIGEgdmFsdWUgaW4gRVRIIGlzIHBhc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIGRlbm9taW5hdGlvbiAtIFRoZSBkZW5vbWluYXRpb24gdG8gY29udmVydCB0b1xuICAgKiBAcmV0dXJucyBBIG5ldyBudW1lcmljIHdpdGggdGhlIHNhbWUgYmFzZSBhcyB0aGUgcHJldmlvdXMsIGJ1dCB0aGVcbiAgICogdmFsdWUgYW5kIGRlbm9taW5hdGlvbiBjaGFuZ2VkIGFjY29yZGluZ2x5XG4gICAqL1xuICB0b0Rlbm9taW5hdGlvbihkZW5vbWluYXRpb24/OiBFdGhlckRlbm9taW5hdGlvbikge1xuICAgIGlmIChkZW5vbWluYXRpb24gJiYgdGhpcy5kZW5vbWluYXRpb24gIT09IGRlbm9taW5hdGlvbikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE51bWVyaWMoXG4gICAgICAgIHRvU3BlY2lmaWVkRGVub21pbmF0aW9uW2Rlbm9taW5hdGlvbl0oZ2V0VmFsdWVJbkVUSCh0aGlzKSksXG4gICAgICAgIHRoaXMuYmFzZSxcbiAgICAgICAgZGVub21pbmF0aW9uLFxuICAgICAgKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxpY2F0ZXMgYSBtZXRob2Qgb2YgQmlnTnVtYmVyIHRoYXQgaXMgbm90IGluIHRoZSB2ZXJzaW9uIG9mIEJpZ051bWJlclxuICAgKiB0aGF0IHdlIHVzZSBjdXJyZW50bHkuIEVzc2VudGlhbGx5IHNoaWZ0aW5nIHRoZSBkZWNpbWFsIHBvaW50IGJhY2t3YXJkcyBieVxuICAgKiBhbiBhbW91bnQgZXF1YWwgdG8gdGhlIHBvc2l0aXZlIG51bWJlciBzdXBwbGllZCB0byB0aGUgZGVjaW1hbHMgb3BlcmF0b3IuXG4gICAqIEZvciBleGFtcGxlLCBjYWxsaW5nIHNoaWZ0ZWRCeSgxMCkgb24gdGhlIHZhbHVlIDEwMDAwMDAwMDAwIHdpbGwgcmVzdWx0IGluXG4gICAqIGEgdmFsdWUgb2YgMS4wMDAwMDAwMDAwLiBJZiBwYXNzaW5nIGEgbmVnYXRpdmUgbnVtYmVyLCB0aGVuIHRoZSBkZWNpbWFsXG4gICAqIHBvc2l0aW9uIHdpbGwgbW92ZSBmb3J3YXJkLiAxLjAwMDAwMDAwMDAgc2hpZnRlZEJ5KC0xMCkgeWllbGRzIDEwMDAwMDAwMDAwXG4gICAqXG4gICAqIEBwYXJhbSBkZWNpbWFscyAtIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdG8gbW92ZS4gUG9zaXRpdmUgbW92ZXNcbiAgICogZGVjaW1hbCBiYWNrd2FyZHMsIGNyZWF0aW5nIGEgc21hbGxlciBudW1iZXIuIE5lZ2F0aXZlIHZhbHVlcyBtb3ZlIHRoZVxuICAgKiBkZWNpbWFsIGZvcndhcmRzLCBjcmVhdGluZyBhIGxhcmdlciBudW1iZXIuXG4gICAqIEByZXR1cm5zIEEgbmV3IG51bWVyaWMgd2l0aCB0aGUgc2FtZSBiYXNlIGFuZCBkZW5vbWluYXRpb24gYXMgdGhlIGN1cnJlbnRcbiAgICogYnV0IHdpdGggYSBuZXcgdmFsdWUuXG4gICAqL1xuICBzaGlmdGVkQnkoZGVjaW1hbHM6IG51bWJlcikge1xuICAgIGNvbnN0IHBvd2VyT2YgPSBuZXcgTnVtZXJpYyhNYXRoLnBvdygxMCwgZGVjaW1hbHMpLCAxMCk7XG4gICAgcmV0dXJuIHRoaXMuZGl2aWRlKHBvd2VyT2YpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSBjb252ZXJzaW9uIHJhdGUgdG8gdGhlIE51bWVyaWMuIElmIHJhdGUgaXMgdW5kZWZpbmVkIHJldHVybnMgdGhlXG4gICAqIHNhbWUgaW5zdGFuY2UgdGhhdCB3YXMgb3BlcmF0ZWQgb24uIEFsbG93aW5nIGFuIHVuZGVmaW5lZCB2YWx1ZSBtYWtlc1xuICAgKiBjaGFpbmluZyB0aGlzIG9wZXJhdG9yIGZlYXNpYmxlIHdpdGggdW5kZWZpbmVkIHZhbHVlcyBmcm9tIHRoZSB1c2VyIG9yXG4gICAqIHN0YXRlIHdpdGhvdXQgbWFuaXB1bGF0aW5nIHRoZSBudW1iZXIuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiBuZXcgTnVtZXJpYyg1LCAxMClcbiAgICogLmFwcGx5Q29udmVyc2lvblJhdGUocG9zc2libHlVbmRlZmluZWRSYXRlKVxuICAgKiAudG9CYXNlKDE2KVxuICAgKiAudG9TdHJpbmcoKTtcbiAgICpcbiAgICogV2lsbCByZXR1cm4gYSB2YWxpZCByZXN1bHQgYXMgbG9uZyBhcyBwb3NzaWJseVVuZGVmaW5lZFJhdGUgaXMgdW5kZWZpbmVkLFxuICAgKiBhIEJpZ051bWJlciBvciBhIG51bWJlci4gSW4gc29tZSBhcmVhcyBvZiB0aGUgY29kZWJhc2Ugd2UgY2hlY2sgdG8gc2VlIGlmXG4gICAqIHRoZSB0YXJnZXQgY3VycmVuY3kgaXMgZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgY3VycmVuY3kgYmVmb3JlIGFwcGx5aW5nXG4gICAqIGEgY29udmVyc2lvblJhdGUuIFRoaXMgZnVuY3Rpb25hbGl0eSBpcyBub3QgYnVpbHQgaW50byBOdW1lcmljIGFuZCB3aWxsXG4gICAqIHJlcXVpcmUgYnJlYWtpbmcgdGhlIGNoYWluIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kOlxuICAgKiBsZXQgdmFsdWUgPSBuZXcgTnVtZXJpYyg1LCAxMCk7XG4gICAqXG4gICAqIGlmIChmcm9tQ3VycmVuY3kgIT09IHRvQ3VycmVuY3kpIHtcbiAgICogdmFsdWUgPSB2YWx1ZS5hcHBseUNvbnZlcnNpb25SYXRlKHBvc3NpYmx5VW5kZWZpbmVkUmF0ZSk7XG4gICAqIH1cbiAgICpcbiAgICogcmV0dXJuIHZhbHVlLnRvQmFzZSgxNikudG9TdHJpbmcoKTtcbiAgICpcbiAgICogQHBhcmFtIHJhdGUgLSBUaGUgbXVsdGlwbGllciB0byBhcHBseVxuICAgKiBAcGFyYW0gaW52ZXJ0IC0gaWYgdHJ1ZSwgaW52ZXJ0cyB0aGUgcmF0ZVxuICAgKiBAcmV0dXJucyBOZXcgTnVtZXJpYyB2YWx1ZSB3aXRoIGNvbnZlcnNpb24gcmF0ZSBhcHBsaWVkLlxuICAgKi9cbiAgYXBwbHlDb252ZXJzaW9uUmF0ZShyYXRlPzogbnVtYmVyIHwgQmlnTnVtYmVyLCBpbnZlcnQ/OiBib29sZWFuKSB7XG4gICAgaWYgKHR5cGVvZiByYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbGV0IGNvbnZlcnNpb25SYXRlID0gbmV3IE51bWVyaWMocmF0ZSwgMTApO1xuICAgIGlmIChpbnZlcnQpIHtcbiAgICAgIGNvbnZlcnNpb25SYXRlID0gbmV3IE51bWVyaWMobmV3IEJpZ051bWJlcigxLjApKS5kaXZpZGUoY29udmVyc2lvblJhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50aW1lcyhjb252ZXJzaW9uUmF0ZSk7XG4gIH1cblxuICByb3VuZChcbiAgICBudW1iZXJPZkRlY2ltYWxzPzogbnVtYmVyLFxuICAgIHJvdW5kaW5nTW9kZTogbnVtYmVyID0gQmlnTnVtYmVyLlJPVU5EX0hBTEZfRE9XTixcbiAgKSB7XG4gICAgaWYgKHR5cGVvZiBudW1iZXJPZkRlY2ltYWxzID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIG5ldyBOdW1lcmljKFxuICAgICAgICB0aGlzLnZhbHVlLnJvdW5kKG51bWJlck9mRGVjaW1hbHMsIHJvdW5kaW5nTW9kZSksXG4gICAgICAgIHRoaXMuYmFzZSxcbiAgICAgICAgdGhpcy5kZW5vbWluYXRpb24sXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUT0RPOiBtYWtlIGl0IHBvc3NpYmxlIHRvIGFkZCBFVEggKyBHV0VJIHZhbHVlLiBTbyBpZiB5b3UgaGF2ZVxuICAgKiBOdW1lcmljIDEgd2l0aCBkZW5vbWluYXRpb24gRVRIIGFuZCBOdW1lcmljIDIgd2l0aCBEZW5vbWluYXRpb24gV0VJLFxuICAgKiBmaXJzdCBjb252ZXJ0IE51bWVyaWMgMiB0byBFVEggdGhlbiBhZGQgdGhlIGFtb3VudCB0byBOdW1lcmljIDEuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKiBAcGFyYW0gYmFzZVxuICAgKiBAcGFyYW0gZGVub21pbmF0aW9uXG4gICAqL1xuICBhZGQoXG4gICAgdmFsdWU6IE51bWVyaWMgfCBOdW1lcmljVmFsdWUsXG4gICAgYmFzZT86IE51bWVyaWNCYXNlLFxuICAgIGRlbm9taW5hdGlvbj86IEV0aGVyRGVub21pbmF0aW9uLFxuICApIHtcbiAgICBjb25zdCBudW1lcmljID0gTnVtZXJpYy5mcm9tKHZhbHVlLCBiYXNlLCBkZW5vbWluYXRpb24pO1xuICAgIHJldHVybiBuZXcgTnVtZXJpYyhcbiAgICAgIHRoaXMudmFsdWUuYWRkKGFsaWduT3BlcmFuZERlbm9taW5hdGlvbnModGhpcywgbnVtZXJpYykudmFsdWUpLFxuICAgICAgdGhpcy5iYXNlLFxuICAgICAgdGhpcy5kZW5vbWluYXRpb24sXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUT0RPOiBtYWtlIGl0IHBvc3NpYmxlIHRvIHN1YnRyYWN0IEVUSCAtIEdXRUkgdmFsdWUuIFNvIGlmIHlvdSBoYXZlXG4gICAqIE51bWVyaWMgMSB3aXRoIGRlbm9taW5hdGlvbiBFVEggYW5kIE51bWVyaWMgMiB3aXRoIERlbm9taW5hdGlvbiBXRUksXG4gICAqIGZpcnN0IGNvbnZlcnQgTnVtZXJpYyAyIHRvIEVUSCB0aGVuIHN1YnRyYWN0IHRoZSBhbW91bnQgZnJvbSBOdW1lcmljIDEuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKiBAcGFyYW0gYmFzZVxuICAgKiBAcGFyYW0gZGVub21pbmF0aW9uXG4gICAqL1xuICBtaW51cyhcbiAgICB2YWx1ZTogTnVtZXJpYyB8IE51bWVyaWNWYWx1ZSxcbiAgICBiYXNlPzogTnVtZXJpY0Jhc2UsXG4gICAgZGVub21pbmF0aW9uPzogRXRoZXJEZW5vbWluYXRpb24sXG4gICkge1xuICAgIGNvbnN0IG51bWVyaWMgPSBOdW1lcmljLmZyb20odmFsdWUsIGJhc2UsIGRlbm9taW5hdGlvbik7XG5cbiAgICByZXR1cm4gbmV3IE51bWVyaWMoXG4gICAgICB0aGlzLnZhbHVlLm1pbnVzKGFsaWduT3BlcmFuZERlbm9taW5hdGlvbnModGhpcywgbnVtZXJpYykudmFsdWUpLFxuICAgICAgdGhpcy5iYXNlLFxuICAgICAgdGhpcy5kZW5vbWluYXRpb24sXG4gICAgKTtcbiAgfVxuXG4gIHRpbWVzKFxuICAgIG11bHRpcGxpZXI6IE51bWVyaWMgfCBOdW1lcmljVmFsdWUsXG4gICAgYmFzZT86IE51bWVyaWNCYXNlLFxuICAgIGRlbm9taW5hdGlvbj86IEV0aGVyRGVub21pbmF0aW9uLFxuICApIHtcbiAgICBjb25zdCBtdWx0aXBsaWVyTnVtZXJpYyA9IE51bWVyaWMuZnJvbShtdWx0aXBsaWVyLCBiYXNlLCBkZW5vbWluYXRpb24pO1xuICAgIHJldHVybiBuZXcgTnVtZXJpYyhcbiAgICAgIHRoaXMudmFsdWUudGltZXMoXG4gICAgICAgIGFsaWduT3BlcmFuZERlbm9taW5hdGlvbnModGhpcywgbXVsdGlwbGllck51bWVyaWMpLnZhbHVlLFxuICAgICAgKSxcbiAgICAgIHRoaXMuYmFzZSxcbiAgICAgIHRoaXMuZGVub21pbmF0aW9uLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRGl2aWRlcyB0aGUgTnVtZXJpYyBieSBhbm90aGVyIHN1cHBsaWVkIE51bWVyaWMsIGNhcnJ5aW5nIG92ZXIgdGhlIGJhc2VcbiAgICogYW5kIGRlbm9taW5hdGlvbiBmcm9tIHRoZSBjdXJyZW50IE51bWVyaWMuXG4gICAqXG4gICAqIEBwYXJhbSBkaXZpc29yIC0gVGhlIE51bWVyaWMgdG8gZGl2aWRlIHRoaXMgTnVtZXJpYyBieVxuICAgKiBAcGFyYW0gYmFzZVxuICAgKiBAcGFyYW0gZGVub21pbmF0aW9uXG4gICAqIEByZXR1cm5zIEEgbmV3IE51bWVyaWMgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBkaXZpc2lvblxuICAgKi9cbiAgZGl2aWRlKFxuICAgIGRpdmlzb3I6IE51bWVyaWMgfCBOdW1lcmljVmFsdWUsXG4gICAgYmFzZT86IE51bWVyaWNCYXNlLFxuICAgIGRlbm9taW5hdGlvbj86IEV0aGVyRGVub21pbmF0aW9uLFxuICApIHtcbiAgICByZXR1cm4gbmV3IE51bWVyaWMoXG4gICAgICB0aGlzLnZhbHVlLmRpdihcbiAgICAgICAgYWxpZ25PcGVyYW5kRGVub21pbmF0aW9ucyhcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIE51bWVyaWMuZnJvbShkaXZpc29yLCBiYXNlLCBkZW5vbWluYXRpb24pLFxuICAgICAgICApLnZhbHVlLFxuICAgICAgKSxcbiAgICAgIHRoaXMuYmFzZSxcbiAgICAgIHRoaXMuZGVub21pbmF0aW9uLFxuICAgICk7XG4gIH1cblxuICBncmVhdGVyVGhhbihcbiAgICBjb21wYXJhdG9yOiBOdW1lcmljIHwgTnVtZXJpY1ZhbHVlLFxuICAgIGJhc2U/OiBOdW1lcmljQmFzZSxcbiAgICBkZW5vbWluYXRpb24/OiBFdGhlckRlbm9taW5hdGlvbixcbiAgKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuZ3JlYXRlclRoYW4oXG4gICAgICBOdW1lcmljLmZyb20oY29tcGFyYXRvciwgYmFzZSwgZGVub21pbmF0aW9uKS52YWx1ZSxcbiAgICApO1xuICB9XG5cbiAgZ3JlYXRlclRoYW5PckVxdWFsVG8oXG4gICAgY29tcGFyYXRvcjogTnVtZXJpYyB8IE51bWVyaWNWYWx1ZSxcbiAgICBiYXNlPzogTnVtZXJpY0Jhc2UsXG4gICAgZGVub21pbmF0aW9uPzogRXRoZXJEZW5vbWluYXRpb24sXG4gICkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLmdyZWF0ZXJUaGFuT3JFcXVhbFRvKFxuICAgICAgTnVtZXJpYy5mcm9tKGNvbXBhcmF0b3IsIGJhc2UsIGRlbm9taW5hdGlvbikudmFsdWUsXG4gICAgKTtcbiAgfVxuXG4gIGxlc3NUaGFuKFxuICAgIGNvbXBhcmF0b3I6IE51bWVyaWMgfCBOdW1lcmljVmFsdWUsXG4gICAgYmFzZT86IE51bWVyaWNCYXNlLFxuICAgIGRlbm9taW5hdGlvbj86IEV0aGVyRGVub21pbmF0aW9uLFxuICApIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5sZXNzVGhhbihcbiAgICAgIE51bWVyaWMuZnJvbShjb21wYXJhdG9yLCBiYXNlLCBkZW5vbWluYXRpb24pLnZhbHVlLFxuICAgICk7XG4gIH1cblxuICBsZXNzVGhhbk9yRXF1YWxUbyhcbiAgICBjb21wYXJhdG9yOiBOdW1lcmljIHwgTnVtZXJpY1ZhbHVlLFxuICAgIGJhc2U/OiBOdW1lcmljQmFzZSxcbiAgICBkZW5vbWluYXRpb24/OiBFdGhlckRlbm9taW5hdGlvbixcbiAgKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUubGVzc1RoYW5PckVxdWFsVG8oXG4gICAgICBOdW1lcmljLmZyb20oY29tcGFyYXRvciwgYmFzZSwgZGVub21pbmF0aW9uKS52YWx1ZSxcbiAgICApO1xuICB9XG5cbiAgaXNOZWdhdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5pc05lZ2F0aXZlKCk7XG4gIH1cblxuICBpc1Bvc2l0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmlzTmVnYXRpdmUoKSA9PT0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgYmFzZSAxNiBoZXhhZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIE51bWVyaWMgdGhhdCBpc1xuICAgKiAweCBwcmVmaXhlZC4gVGhpcyBvcGVyYXRpb24gYnlwYXNzZXMgdGhlIGN1cnJlbnRseSBzZXQgYmFzZSBvZiB0aGVcbiAgICogTnVtZXJpYy5cbiAgICpcbiAgICogQHJldHVybnMgMHggcHJlZml4ZWQgaGV4c3RyaW5nLlxuICAgKi9cbiAgdG9QcmVmaXhlZEhleFN0cmluZygpIHtcbiAgICByZXR1cm4gYWRkSGV4UHJlZml4KHRoaXMudmFsdWUudG9TdHJpbmcoMTYpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIE51bWVyaWMsIHVzaW5nIHRoZSBjdXJyZW50IHZhbHVlIG9mXG4gICAqIHRoaXMuYmFzZSB0byBkZXRlcm1pbmUgaWYgaXQgc2hvdWxkIGJlIGEgZGVjaW1hbCBvciBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIE51bWVyaWNcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnRvU3RyaW5nKHRoaXMuYmFzZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGZpeGVkLXBvaW50IGRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBOdW1lcmljXG4gICAqXG4gICAqIEBwYXJhbSBkZWNpbWFscyAtIHRoZSBhbW91bnQgb2YgZGVjaW1hbCBwcmVjaXNpb24gdG8gdXNlIHdoZW4gcm91bmRpbmdcbiAgICogQHJldHVybnMgQSBmaXhlZCBwb2ludCBkZWNpbWFsIHN0cmluZyByZXByZXNlbmF0aW9uIG9mIHRoZSBOdW1lcmljXG4gICAqL1xuICB0b0ZpeGVkKGRlY2ltYWxzOiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS50b0ZpeGVkKGRlY2ltYWxzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IE51bWJlciwgd2l0aCBhbGwgb2YgdGhlIGluYWNjdXJhY3kgdGhhdFxuICAgKiBjb3VsZCBjb21lIHdpdGggdGhhdC5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIHZhbHVlIGFzIGEgSlMgTnVtYmVyXG4gICAqL1xuICB0b051bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS50b051bWJlcigpO1xuICB9XG59XG4iLCIvKipcbiAqIFV0aWxpdHkgRnVuY3Rpb25zIHRvIHN1cHBvcnQgYnJvd3Nlci5ydW50aW1lIEphdmFTY3JpcHQgQVBJXG4gKi9cblxuaW1wb3J0IGJyb3dzZXIgZnJvbSAnd2ViZXh0ZW5zaW9uLXBvbHlmaWxsJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG4vKipcbiAqIFJldHVybnMgYW4gRXJyb3IgaWYgZXh0ZW5zaW9uLnJ1bnRpbWUubGFzdEVycm9yIGlzIHByZXNlbnRcbiAqIHRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciB0aGUgbm9uLXN0YW5kYXJkIGVycm9yIG9iamVjdCB0aGF0J3MgdXNlZFxuICpcbiAqIEFjY29yZGluZyB0byB0aGUgZG9jcywgd2UgYXJlIGV4cGVjdGVkIHRvIGNoZWNrIGxhc3RFcnJvciBpbiBydW50aW1lIEFQSSBjYWxsYmFja3M6XG4gKiBcIlxuICogSWYgeW91IGNhbGwgYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgbWF5IHNldCBsYXN0RXJyb3IsIHlvdSBhcmUgZXhwZWN0ZWQgdG9cbiAqIGNoZWNrIGZvciB0aGUgZXJyb3Igd2hlbiB5b3UgaGFuZGxlIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uLiBJZiBsYXN0RXJyb3IgaGFzIGJlZW5cbiAqIHNldCBhbmQgeW91IGRvbid0IGNoZWNrIGl0IHdpdGhpbiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24sIHRoZW4gYW4gZXJyb3Igd2lsbCBiZSByYWlzZWQuXG4gKiBcIlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvTW96aWxsYS9BZGQtb25zL1dlYkV4dGVuc2lvbnMvQVBJL3J1bnRpbWUvbGFzdEVycm9yfVxuICogQHJldHVybnMge0Vycm9yfHVuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrRm9yTGFzdEVycm9yKCkge1xuICBjb25zdCB7IGxhc3RFcnJvciB9ID0gYnJvd3Nlci5ydW50aW1lO1xuICBpZiAoIWxhc3RFcnJvcikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgLy8gaWYgaXQgcXVhY2tzIGxpa2UgYW4gRXJyb3IsIGl0cyBhbiBFcnJvclxuICBpZiAobGFzdEVycm9yLnN0YWNrICYmIGxhc3RFcnJvci5tZXNzYWdlKSB7XG4gICAgcmV0dXJuIGxhc3RFcnJvcjtcbiAgfVxuICAvLyByZXBhaXIgaW5jb21wbGV0ZSBlcnJvciBvYmplY3QgKGVnIGNocm9taXVtIHY3NylcbiAgcmV0dXJuIG5ldyBFcnJvcihsYXN0RXJyb3IubWVzc2FnZSk7XG59XG5cbi8qKiBAcmV0dXJucyB7RXJyb3J8dW5kZWZpbmVkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrRm9yTGFzdEVycm9yQW5kTG9nKCkge1xuICBjb25zdCBlcnJvciA9IGNoZWNrRm9yTGFzdEVycm9yKCk7XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgbG9nLmVycm9yKGVycm9yKTtcbiAgfVxuXG4gIHJldHVybiBlcnJvcjtcbn1cblxuLyoqIEByZXR1cm5zIHtFcnJvcnx1bmRlZmluZWR9ICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tGb3JMYXN0RXJyb3JBbmRXYXJuKCkge1xuICBjb25zdCBlcnJvciA9IGNoZWNrRm9yTGFzdEVycm9yKCk7XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS53YXJuKGVycm9yKTtcbiAgfVxuXG4gIHJldHVybiBlcnJvcjtcbn1cbiIsInR5cGUgY29udHJhY3QgPSB7XG4gIGNvbnRyYWN0Q29kZTogc3RyaW5nIHwgbnVsbDtcbiAgaXNDb250cmFjdEFkZHJlc3M6IGJvb2xlYW47XG59O1xuXG5leHBvcnQgY29uc3QgcmVhZEFkZHJlc3NBc0NvbnRyYWN0ID0gYXN5bmMgKFxuICBldGhRdWVyeToge1xuICAgIGdldENvZGU6IChhZGRyZXNzOiBzdHJpbmcpID0+IHN0cmluZztcbiAgfSxcbiAgYWRkcmVzczogc3RyaW5nLFxuKTogUHJvbWlzZTxjb250cmFjdD4gPT4ge1xuICBsZXQgY29udHJhY3RDb2RlO1xuICB0cnkge1xuICAgIGNvbnRyYWN0Q29kZSA9IGF3YWl0IGV0aFF1ZXJ5LmdldENvZGUoYWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb250cmFjdENvZGUgPSBudWxsO1xuICB9XG5cbiAgY29uc3QgaXNDb250cmFjdEFkZHJlc3MgPSBjb250cmFjdENvZGVcbiAgICA/IGNvbnRyYWN0Q29kZSAhPT0gJzB4JyAmJiBjb250cmFjdENvZGUgIT09ICcweDAnXG4gICAgOiBmYWxzZTtcbiAgcmV0dXJuIHsgY29udHJhY3RDb2RlLCBpc0NvbnRyYWN0QWRkcmVzcyB9O1xufTtcbiIsImltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ2JpZ251bWJlci5qcyc7XG5cbmltcG9ydCB7IGFkZEhleFByZWZpeCwgQk4gfSBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xuaW1wb3J0IHsgRXRoZXJEZW5vbWluYXRpb24gfSBmcm9tICcuLi9jb25zdGFudHMvY29tbW9uJztcbmltcG9ydCB7IE51bWVyaWMsIE51bWVyaWNWYWx1ZSB9IGZyb20gJy4vTnVtZXJpYyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNHV0VJVG9IZXhXRUkoZGVjR1dFSTogbnVtYmVyKSB7XG4gIHJldHVybiBuZXcgTnVtZXJpYyhkZWNHV0VJLCAxMCwgRXRoZXJEZW5vbWluYXRpb24uR1dFSSlcbiAgICAudG9CYXNlKDE2KVxuICAgIC50b0Rlbm9taW5hdGlvbihFdGhlckRlbm9taW5hdGlvbi5XRUkpXG4gICAgLnRvU3RyaW5nKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdEhleGVzKGFIZXhXRUk6IHN0cmluZywgYkhleFdFSTogc3RyaW5nKSB7XG4gIHJldHVybiBuZXcgTnVtZXJpYyhhSGV4V0VJLCAxNilcbiAgICAubWludXMobmV3IE51bWVyaWMoYkhleFdFSSwgMTYpKVxuICAgIC5yb3VuZCg2LCBCaWdOdW1iZXIuUk9VTkRfSEFMRl9ET1dOKVxuICAgIC50b1N0cmluZygpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkSGV4ZXMoYUhleFdFSTogc3RyaW5nLCBiSGV4V0VJOiBzdHJpbmcpIHtcbiAgcmV0dXJuIG5ldyBOdW1lcmljKGFIZXhXRUksIDE2KVxuICAgIC5hZGQobmV3IE51bWVyaWMoYkhleFdFSSwgMTYpKVxuICAgIC5yb3VuZCg2LCBCaWdOdW1iZXIuUk9VTkRfSEFMRl9ET1dOKVxuICAgIC50b1N0cmluZygpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjV0VJVG9EZWNFVEgoZGVjV0VJOiBzdHJpbmcpIHtcbiAgcmV0dXJuIG5ldyBOdW1lcmljKGRlY1dFSSwgMTAsIEV0aGVyRGVub21pbmF0aW9uLldFSSlcbiAgICAudG9EZW5vbWluYXRpb24oRXRoZXJEZW5vbWluYXRpb24uRVRIKVxuICAgIC50b1N0cmluZygpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGV4V0VJVG9EZWNFVEgoaGV4V0VJOiBzdHJpbmcpIHtcbiAgcmV0dXJuIG5ldyBOdW1lcmljKGhleFdFSSwgMTYsIEV0aGVyRGVub21pbmF0aW9uLldFSSlcbiAgICAudG9EZW5vbWluYXRpb24oRXRoZXJEZW5vbWluYXRpb24uRVRIKVxuICAgIC50b0Jhc2UoMTApXG4gICAgLnRvU3RyaW5nKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNFdGhUb0NvbnZlcnRlZEN1cnJlbmN5KFxuICBldGhUb3RhbDogTnVtZXJpY1ZhbHVlLFxuICBjb252ZXJ0ZWRDdXJyZW5jeT86IHN0cmluZyxcbiAgY29udmVyc2lvblJhdGU/OiBudW1iZXIsXG4pIHtcbiAgbGV0IG51bWVyaWMgPSBuZXcgTnVtZXJpYyhldGhUb3RhbCwgMTAsIEV0aGVyRGVub21pbmF0aW9uLkVUSCk7XG5cbiAgaWYgKGNvbnZlcnRlZEN1cnJlbmN5ICE9PSBFdGhlckRlbm9taW5hdGlvbi5FVEgpIHtcbiAgICBudW1lcmljID0gbnVtZXJpYy5hcHBseUNvbnZlcnNpb25SYXRlKGNvbnZlcnNpb25SYXRlKTtcbiAgfVxuXG4gIHJldHVybiBudW1lcmljLnJvdW5kKDIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2VpSGV4RnJvbURlY2ltYWxWYWx1ZSh7XG4gIHZhbHVlLFxuICBjb252ZXJzaW9uUmF0ZSA9IDEsXG4gIGZyb21EZW5vbWluYXRpb24sXG4gIGZyb21DdXJyZW5jeSxcbiAgaW52ZXJ0Q29udmVyc2lvblJhdGUgPSBmYWxzZSxcbn06IHtcbiAgdmFsdWU6IE51bWVyaWNWYWx1ZTtcbiAgY29udmVyc2lvblJhdGU/OiBudW1iZXI7XG4gIGZyb21EZW5vbWluYXRpb24/OiBFdGhlckRlbm9taW5hdGlvbjtcbiAgZnJvbUN1cnJlbmN5Pzogc3RyaW5nO1xuICBpbnZlcnRDb252ZXJzaW9uUmF0ZT86IGJvb2xlYW47XG59KSB7XG4gIGxldCBudW1lcmljID0gbmV3IE51bWVyaWModmFsdWUsIDEwLCBmcm9tRGVub21pbmF0aW9uKTtcbiAgaWYgKGZyb21DdXJyZW5jeSAhPT0gRXRoZXJEZW5vbWluYXRpb24uRVRIKSB7XG4gICAgbnVtZXJpYyA9IG51bWVyaWMuYXBwbHlDb252ZXJzaW9uUmF0ZShjb252ZXJzaW9uUmF0ZSwgaW52ZXJ0Q29udmVyc2lvblJhdGUpO1xuICB9XG4gIHJldHVybiBudW1lcmljLnRvQmFzZSgxNikudG9EZW5vbWluYXRpb24oRXRoZXJEZW5vbWluYXRpb24uV0VJKS50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgQk4gb2JqZWN0IHRvIGEgaGV4IHN0cmluZyB3aXRoIGEgJzB4JyBwcmVmaXhcbiAqXG4gKiBAcGFyYW0gaW5wdXRCbiAtIFRoZSBCTiB0byBjb252ZXJ0IHRvIGEgaGV4IHN0cmluZ1xuICogQHJldHVybnMgQSAnMHgnIHByZWZpeGVkIGhleCBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJuVG9IZXgoaW5wdXRCbjogQk4pIHtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChpbnB1dEJuLnRvU3RyaW5nKDE2KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFdGhDb252ZXJzaW9uRnJvbVdlaUhleCh7XG4gIHZhbHVlLFxuICBmcm9tQ3VycmVuY3kgPSBFdGhlckRlbm9taW5hdGlvbi5FVEgsXG4gIGNvbnZlcnNpb25SYXRlLFxuICBudW1iZXJPZkRlY2ltYWxzID0gNixcbn06IHtcbiAgdmFsdWU6IE51bWVyaWNWYWx1ZTtcbiAgY29udmVyc2lvblJhdGU/OiBudW1iZXI7XG4gIGZyb21DdXJyZW5jeT86IEV0aGVyRGVub21pbmF0aW9uIHwgc3RyaW5nO1xuICBudW1iZXJPZkRlY2ltYWxzPzogbnVtYmVyO1xufSkge1xuICBjb25zdCBkZW5vbWluYXRpb25zID0gW1xuICAgIEV0aGVyRGVub21pbmF0aW9uLkVUSCxcbiAgICBFdGhlckRlbm9taW5hdGlvbi5HV0VJLFxuICAgIEV0aGVyRGVub21pbmF0aW9uLldFSSxcbiAgXTtcblxuICBsZXQgbm9uWmVyb0Rlbm9taW5hdGlvbjtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbm9taW5hdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb252ZXJ0ZWRWYWx1ZSA9IGdldFZhbHVlRnJvbVdlaUhleCh7XG4gICAgICB2YWx1ZSxcbiAgICAgIGNvbnZlcnNpb25SYXRlLFxuICAgICAgZnJvbUN1cnJlbmN5LFxuICAgICAgdG9DdXJyZW5jeTogZnJvbUN1cnJlbmN5LFxuICAgICAgbnVtYmVyT2ZEZWNpbWFscyxcbiAgICAgIHRvRGVub21pbmF0aW9uOiBkZW5vbWluYXRpb25zW2ldLFxuICAgIH0pO1xuXG4gICAgaWYgKGNvbnZlcnRlZFZhbHVlICE9PSAnMCcgfHwgaSA9PT0gZGVub21pbmF0aW9ucy5sZW5ndGggLSAxKSB7XG4gICAgICBub25aZXJvRGVub21pbmF0aW9uID0gYCR7Y29udmVydGVkVmFsdWV9ICR7ZGVub21pbmF0aW9uc1tpXX1gO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vblplcm9EZW5vbWluYXRpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZUZyb21XZWlIZXgoe1xuICB2YWx1ZSxcbiAgZnJvbUN1cnJlbmN5ID0gRXRoZXJEZW5vbWluYXRpb24uRVRILFxuICB0b0N1cnJlbmN5LFxuICBjb252ZXJzaW9uUmF0ZSxcbiAgbnVtYmVyT2ZEZWNpbWFscyxcbiAgdG9EZW5vbWluYXRpb24gPSBFdGhlckRlbm9taW5hdGlvbi5FVEgsXG59OiB7XG4gIHZhbHVlOiBOdW1lcmljVmFsdWU7XG4gIGZyb21DdXJyZW5jeT86IEV0aGVyRGVub21pbmF0aW9uIHwgc3RyaW5nO1xuICB0b0N1cnJlbmN5PzogRXRoZXJEZW5vbWluYXRpb24gfCBzdHJpbmc7XG4gIGNvbnZlcnNpb25SYXRlPzogbnVtYmVyO1xuICBudW1iZXJPZkRlY2ltYWxzPzogbnVtYmVyO1xuICB0b0Rlbm9taW5hdGlvbj86IEV0aGVyRGVub21pbmF0aW9uO1xufSkge1xuICBsZXQgbnVtZXJpYyA9IG5ldyBOdW1lcmljKHZhbHVlLCAxNiwgRXRoZXJEZW5vbWluYXRpb24uV0VJKTtcbiAgaWYgKGZyb21DdXJyZW5jeSAhPT0gdG9DdXJyZW5jeSkge1xuICAgIG51bWVyaWMgPSBudW1lcmljLmFwcGx5Q29udmVyc2lvblJhdGUoY29udmVyc2lvblJhdGUpO1xuICB9XG4gIHJldHVybiBudW1lcmljXG4gICAgLnRvQmFzZSgxMClcbiAgICAudG9EZW5vbWluYXRpb24odG9EZW5vbWluYXRpb24pXG4gICAgLnJvdW5kKG51bWJlck9mRGVjaW1hbHMsIEJpZ051bWJlci5ST1VORF9IQUxGX0RPV04pXG4gICAgLnRvU3RyaW5nKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdW1IZXhlcyhmaXJzdDogc3RyaW5nLCAuLi5hcmdzOiBzdHJpbmdbXSkge1xuICBjb25zdCBmaXJzdFZhbHVlID0gbmV3IE51bWVyaWMoZmlyc3QsIDE2KTtcbiAgY29uc3QgdG90YWwgPSBhcmdzLnJlZHVjZShcbiAgICAoYWNjLCBoZXhBbW91bnQpID0+IGFjYy5hZGQobmV3IE51bWVyaWMoaGV4QW1vdW50LCAxNikpLFxuICAgIGZpcnN0VmFsdWUsXG4gICk7XG5cbiAgcmV0dXJuIHRvdGFsLnRvUHJlZml4ZWRIZXhTdHJpbmcoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhleFdFSVRvRGVjR1dFSSh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nIHwgQmlnTnVtYmVyIHwgQk4pIHtcbiAgcmV0dXJuIG5ldyBOdW1lcmljKHZhbHVlLCAxNiwgRXRoZXJEZW5vbWluYXRpb24uV0VJKVxuICAgIC50b0Jhc2UoMTApXG4gICAgLnRvRGVub21pbmF0aW9uKEV0aGVyRGVub21pbmF0aW9uLkdXRUkpXG4gICAgLnRvU3RyaW5nKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNpbWFsVG9IZXgoZGVjaW1hbDogbnVtYmVyIHwgc3RyaW5nIHwgQmlnTnVtYmVyIHwgQk4pIHtcbiAgcmV0dXJuIG5ldyBOdW1lcmljKGRlY2ltYWwsIDEwKS50b0Jhc2UoMTYpLnRvU3RyaW5nKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0RlY2ltYWwoaGV4VmFsdWU6IG51bWJlciB8IHN0cmluZyB8IEJpZ051bWJlciB8IEJOKSB7XG4gIHJldHVybiBuZXcgTnVtZXJpYyhoZXhWYWx1ZSwgMTYpLnRvQmFzZSgxMCkudG9TdHJpbmcoKTtcbn1cbiIsImltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG4vKipcbiAqIFR5cGUgZ3VhcmQgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGVycm9yIG9iamVjdCB3aXRoIGFcbiAqIGBtZXNzYWdlYCBwcm9wZXJ0eSwgc3VjaCBhcyBhbiBpbnN0YW5jZSBvZiBFcnJvci5cbiAqXG4gKiBUT0RPOiBSZW1vdmUgb25jZSB0aGlzIGJlY29tZXMgYXZhaWxhYmxlIGF0IEBtZXRhbWFzay91dGlsc1xuICpcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBUcnVlIG9yIGZhbHNlLCBkZXBlbmRpbmcgb24gdGhlIHJlc3VsdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXJyb3JXaXRoTWVzc2FnZShcbiAgZXJyb3I6IHVua25vd24sXG4pOiBlcnJvciBpcyB7IG1lc3NhZ2U6IHN0cmluZyB9IHtcbiAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ21lc3NhZ2UnIGluIGVycm9yO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9nRXJyb3JXaXRoTWVzc2FnZShlcnJvcjogdW5rbm93bikge1xuICBpZiAoaXNFcnJvcldpdGhNZXNzYWdlKGVycm9yKSkge1xuICAgIGxvZy5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgfSBlbHNlIHtcbiAgICBsb2cuZXJyb3IoZXJyb3IpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBtZW1vaXplIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFNFQ09ORCB9IGZyb20gJy4uL2NvbnN0YW50cy90aW1lJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBtYWtlIGFuIEhUVFAgcmVxdWVzdCBidXQgdGltaW5nIG91dFxuICogYXV0b21hdGljYWxseSBhZnRlciBhIGRlc2lyZWQgYW1vdW50IG9mIHRpbWUuXG4gKlxuICogQHBhcmFtIHRpbWVvdXQgLSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IHVudGlsIHRoZSByZXF1ZXN0IHRpbWVzXG4gKiBvdXQuXG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGVpdGhlciByZXNvbHZlc1xuICogdG8gdGhlIEhUVFAgcmVzcG9uc2Ugb2JqZWN0IG9yIGlzIHJlamVjdGVkIGlmIGEgbmV0d29yayBlcnJvciBpcyBlbmNvdW50ZXJlZFxuICogb3IgdGhlIHJlcXVlc3QgdGltZXMgb3V0LlxuICovXG5jb25zdCBnZXRGZXRjaFdpdGhUaW1lb3V0ID0gbWVtb2l6ZSgodGltZW91dCA9IFNFQ09ORCAqIDMwKSA9PiB7XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcih0aW1lb3V0KSB8fCB0aW1lb3V0IDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzcGVjaWZ5IHBvc2l0aXZlIGludGVnZXIgdGltZW91dC4nKTtcbiAgfVxuXG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiBmZXRjaFdpdGhUaW1lb3V0KFxuICAgIHVybDogUmVxdWVzdEluZm8sXG4gICAgb3B0cz86IFJlcXVlc3RJbml0LFxuICApOiBQcm9taXNlPFJlc3BvbnNlPiB7XG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IHdpbmRvdy5BYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCB7IHNpZ25hbCB9ID0gYWJvcnRDb250cm9sbGVyO1xuICAgIGNvbnN0IGYgPSB3aW5kb3cuZmV0Y2godXJsLCB7XG4gICAgICAuLi5vcHRzLFxuICAgICAgc2lnbmFsLFxuICAgIH0pO1xuXG4gICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IGFib3J0Q29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgZjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB9XG4gIH07XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0RmV0Y2hXaXRoVGltZW91dDtcbiIsImltcG9ydCB7XG4gIGlzSGV4U3RyaW5nLFxuICBpc1ZhbGlkQWRkcmVzcyxcbiAgaXNWYWxpZENoZWNrc3VtQWRkcmVzcyxcbiAgYWRkSGV4UHJlZml4LFxuICB0b0NoZWNrc3VtQWRkcmVzcyxcbiAgemVyb0FkZHJlc3MsXG4gIGlzSGV4UHJlZml4ZWQsXG59IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XG5cbmV4cG9ydCBjb25zdCBCVVJOX0FERFJFU1MgPSB6ZXJvQWRkcmVzcygpO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNCdXJuQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGFkZHJlc3MgPT09IEJVUk5fQUREUkVTUztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHlIZXhTdHJpbmcodmFsdWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gW1xuICAgIHVuZGVmaW5lZCxcbiAgICBudWxsLFxuICAgICcweCcsXG4gICAgJzB4MCcsXG4gICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gIF0uaW5jbHVkZXModmFsdWUpO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyB0aGF0IHRoZSBpbnB1dCBpcyBhIGhleCBhZGRyZXNzLiBUaGlzIHV0aWxpdHkgbWV0aG9kIGlzIGEgdGhpblxuICogd3JhcHBlciBhcm91bmQgZXRoZXJldW1qcy11dGlsLmlzVmFsaWRBZGRyZXNzLCB3aXRoIHRoZSBleGNlcHRpb24gdGhhdCBpdFxuICogZG9lcyBub3QgdGhyb3cgYW4gZXJyb3Igd2hlbiBwcm92aWRlZCB2YWx1ZXMgdGhhdCBhcmUgbm90IGhleCBzdHJpbmdzLiBJblxuICogYWRkaXRpb24sIGFuZCBieSBkZWZhdWx0LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiB0cnVlIGZvciBoZXggc3RyaW5ncyB0aGF0XG4gKiBtZWV0IHRoZSBsZW5ndGggcmVxdWlyZW1lbnQgb2YgYSBoZXggYWRkcmVzcywgYnV0IGFyZSBub3QgcHJlZml4ZWQgd2l0aCBgMHhgXG4gKiBGaW5hbGx5LCBpZiB0aGUgbWl4ZWRDYXNlVXNlQ2hlY2tzdW0gZmxhZyBpcyB0cnVlIGFuZCBhIG1peGVkIGNhc2Ugc3RyaW5nIGlzXG4gKiBwcm92aWRlZCB0aGlzIG1ldGhvZCB3aWxsIHZhbGlkYXRlIGl0IGhhcyB0aGUgcHJvcGVyIGNoZWNrc3VtIGZvcm1hdHRpbmcuXG4gKlxuICogQHBhcmFtIHBvc3NpYmxlQWRkcmVzcyAtIElucHV0IHBhcmFtZXRlciB0byBjaGVjayBhZ2FpbnN0XG4gKiBAcGFyYW0gW29wdGlvbnNdIC0gb3B0aW9ucyBiYWdcbiAqIEBwYXJhbSBbb3B0aW9ucy5hbGxvd05vblByZWZpeGVkXSAtIElmIHRydWUgd2lsbCBmaXJzdCBlbnN1cmUgJzB4J1xuICogaXMgcHJlcGVuZGVkIHRvIHRoZSBzdHJpbmdcbiAqIEBwYXJhbSBbb3B0aW9ucy5taXhlZENhc2VVc2VDaGVja3N1bV0gLSBJZiB0cnVlIHdpbGwgdHJlYXQgbWl4ZWRcbiAqIGNhc2UgYWRkcmVzc2VzIGFzIGNoZWNrc3VtIGFkZHJlc3NlcyBhbmQgdmFsaWRhdGUgdGhhdCBwcm9wZXIgY2hlY2tzdW1cbiAqIGZvcm1hdCBpcyB1c2VkXG4gKiBAcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgaW5wdXQgaXMgYSB2YWxpZCBoZXggYWRkcmVzc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEhleEFkZHJlc3MoXG4gIHBvc3NpYmxlQWRkcmVzczogc3RyaW5nLFxuICB7IGFsbG93Tm9uUHJlZml4ZWQgPSB0cnVlLCBtaXhlZENhc2VVc2VDaGVja3N1bSA9IGZhbHNlIH0gPSB7fSxcbikge1xuICBjb25zdCBhZGRyZXNzVG9DaGVjayA9IGFsbG93Tm9uUHJlZml4ZWRcbiAgICA/IGFkZEhleFByZWZpeChwb3NzaWJsZUFkZHJlc3MpXG4gICAgOiBwb3NzaWJsZUFkZHJlc3M7XG4gIGlmICghaXNIZXhTdHJpbmcoYWRkcmVzc1RvQ2hlY2spKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG1peGVkQ2FzZVVzZUNoZWNrc3VtKSB7XG4gICAgY29uc3QgcHJlZml4UmVtb3ZlZCA9IGFkZHJlc3NUb0NoZWNrLnNsaWNlKDIpO1xuICAgIGNvbnN0IGxvd2VyID0gcHJlZml4UmVtb3ZlZC50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHVwcGVyID0gcHJlZml4UmVtb3ZlZC50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IGFsbE9uZUNhc2UgPSBwcmVmaXhSZW1vdmVkID09PSBsb3dlciB8fCBwcmVmaXhSZW1vdmVkID09PSB1cHBlcjtcbiAgICBpZiAoIWFsbE9uZUNhc2UpIHtcbiAgICAgIHJldHVybiBpc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3NUb0NoZWNrKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNWYWxpZEFkZHJlc3MoYWRkcmVzc1RvQ2hlY2spO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKSB7XG4gIGlmICghYWRkcmVzcykge1xuICAgIC8vIG91ciBpbnRlcm5hbCBjaGVja3N1bUFkZHJlc3MgZnVuY3Rpb24gdGhhdCB0aGlzIG1ldGhvZCByZXBsYWNlcyB3b3VsZFxuICAgIC8vIHJldHVybiBhbiBlbXB0eSBzdHJpbmcgZm9yIG51bGxpc2ggaW5wdXQuIElmIGFueSBkaXJlY3QgdXNhZ2VzIG9mXG4gICAgLy8gZXRoZXJldW1qcy11dGlsLnRvQ2hlY2tzdW1BZGRyZXNzIHdlcmUgY2FsbGVkIHdpdGggbnVsbGlzaCBpbnB1dCBpdFxuICAgIC8vIHdvdWxkIGhhdmUgcmVzdWx0ZWQgaW4gYW4gZXJyb3Igb24gdmVyc2lvbiA1LjEuXG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGNvbnN0IGhleFByZWZpeGVkID0gYWRkSGV4UHJlZml4KGFkZHJlc3MpO1xuICBpZiAoIWlzSGV4U3RyaW5nKGhleFByZWZpeGVkKSkge1xuICAgIC8vIFZlcnNpb24gNS4xIG9mIGV0aGVyZXVtanMtdXRpbHMgd291bGQgaGF2ZSByZXR1cm5lZCAnMHhZJyBmb3IgaW5wdXQgJ3knXG4gICAgLy8gYnV0IHdlIHNob3VsZG4ndCB3YXN0ZSBlZmZvcnQgdHJ5aW5nIHRvIGNoYW5nZSBjYXNlIG9uIGEgY2xlYXJseSBpbnZhbGlkXG4gICAgLy8gc3RyaW5nLiBJbnN0ZWFkIGp1c3QgcmV0dXJuIHRoZSBoZXggcHJlZml4ZWQgb3JpZ2luYWwgc3RyaW5nIHdoaWNoIG1vc3RcbiAgICAvLyBjbG9zZWx5IG1pbWljcyB0aGUgb3JpZ2luYWwgYmVoYXZpb3IuXG4gICAgcmV0dXJuIGhleFByZWZpeGVkO1xuICB9XG4gIHJldHVybiB0b0NoZWNrc3VtQWRkcmVzcyhoZXhQcmVmaXhlZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcEhleFByZWZpeChzdHI6IHN0cmluZykge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIHJldHVybiBpc0hleFByZWZpeGVkKHN0cikgPyBzdHIuc2xpY2UoMikgOiBzdHI7XG59XG4iLCJpbXBvcnQgYnJvd3NlciBmcm9tICd3ZWJleHRlbnNpb24tcG9seWZpbGwnO1xuXG5leHBvcnQgY29uc3QgaXNNYW5pZmVzdFYzID1cbiAgYnJvd3Nlci5ydW50aW1lLmdldE1hbmlmZXN0KCkubWFuaWZlc3RfdmVyc2lvbiA9PT0gMztcbiIsImltcG9ydCB7IENIQUlOX0lEUywgTUFYX1NBRkVfQ0hBSU5fSUQgfSBmcm9tICcuLi9jb25zdGFudHMvbmV0d29yayc7XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIG51bWJlciBwcmltaXRpdmUgY2hhaW4gSUQgaXMgc2FmZS5cbiAqIEJlY2F1c2Ugc29tZSBjcnlwdG9ncmFwaGljIGxpYnJhcmllcyB3ZSB1c2UgZXhwZWN0IHRoZSBjaGFpbiBJRCB0byBiZSBhXG4gKiBudW1iZXIgcHJpbWl0aXZlLCBpdCBtdXN0IG5vdCBleGNlZWQgYSBjZXJ0YWluIHNpemUuXG4gKlxuICogQHBhcmFtIGNoYWluSWQgLSBUaGUgY2hhaW4gSUQgdG8gY2hlY2sgZm9yIHNhZmV0eS5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIGNoYWluIElEIGlzIHNhZmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NhZmVDaGFpbklkKGNoYWluSWQ6IHVua25vd24pOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzU2FmZUludGVnZXIoY2hhaW5JZCkgJiYgY2hhaW5JZCA+IDAgJiYgY2hhaW5JZCA8PSBNQVhfU0FGRV9DSEFJTl9JRDtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSAweC1wcmVmaXhlZCwgbm9uLXplcm8sIG5vbi16ZXJvLXBhZGRlZCxcbiAqIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBhIGNvcnJlY3RseSBmb3JtYXR0ZWQgaGV4IHN0cmluZyxcbiAqIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUHJlZml4ZWRGb3JtYXR0ZWRIZXhTdHJpbmcodmFsdWU6IHVua25vd24pIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIC9eMHhbMS05YS1mXStbMC05YS1mXSokL2l1LnRlc3QodmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRva2VuIGRldGVjdGlvbiBpcyBlbmFibGVkIGZvciBjZXJ0YWluIG5ldHdvcmtzXG4gKlxuICogQHBhcmFtIGNoYWluSWQgLSBDaGFpbklEIG9mIG5ldHdvcmtcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGN1cnJlbnQgbmV0d29yayBzdXBwb3J0cyB0b2tlbiBkZXRlY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVG9rZW5EZXRlY3Rpb25FbmFibGVkRm9yTmV0d29yayhjaGFpbklkOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgc3dpdGNoIChjaGFpbklkKSB7XG4gICAgY2FzZSBDSEFJTl9JRFMuTUFJTk5FVDpcbiAgICBjYXNlIENIQUlOX0lEUy5CU0M6XG4gICAgY2FzZSBDSEFJTl9JRFMuUE9MWUdPTjpcbiAgICBjYXNlIENIQUlOX0lEUy5BVkFMQU5DSEU6XG4gICAgY2FzZSBDSEFJTl9JRFMuQVVST1JBOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIExpa2Uge0BsaW5rIE51bWJlci5pc1NhZmVJbnRlZ2VyfSwgYnV0IHR5cGVzIHRoZSBpbnB1dCBhcyBhIGBudW1iZXJgIGlmIGl0IGlzXG4gKiBpbmRlZWQgYSBzYWZlIGludGVnZXIuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBzYWZlIGludGVnZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNTYWZlSW50ZWdlcih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIG51bWJlciB7XG4gIHJldHVybiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSk7XG59XG4iLCIvKipcbiAqIFJldHVybiBhIFwibWFza2VkXCIgY29weSBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIFRoZSByZXR1cm5lZCBvYmplY3QgaW5jbHVkZXMgb25seSB0aGUgcHJvcGVydGllcyBwcmVzZW50IGluIHRoZSBtYXNrLiBUaGVcbiAqIG1hc2sgaXMgYW4gb2JqZWN0IHRoYXQgbWlycm9ycyB0aGUgc3RydWN0dXJlIG9mIHRoZSBnaXZlbiBvYmplY3QsIGV4Y2VwdFxuICogdGhlIG9ubHkgdmFsdWVzIGFyZSBgdHJ1ZWAgb3IgYSBzdWItbWFzay4gYHRydWVgIGltcGxpZXMgdGhlIHByb3BlcnR5XG4gKiBzaG91bGQgYmUgaW5jbHVkZWQsIGFuZCBhIHN1Yi1tYXNrIGltcGxpZXMgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBmdXJ0aGVyXG4gKiBtYXNrZWQgYWNjb3JkaW5nIHRvIHRoYXQgc3ViLW1hc2suXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFza1xuICogQHBhcmFtIHtPYmplY3Q8b2JqZWN0IHwgYm9vbGVhbj59IG1hc2sgLSBUaGUgbWFzayB0byBhcHBseSB0byB0aGUgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXNrT2JqZWN0KG9iamVjdCwgbWFzaykge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqZWN0KS5yZWR1Y2UoKHN0YXRlLCBrZXkpID0+IHtcbiAgICBpZiAobWFza1trZXldID09PSB0cnVlKSB7XG4gICAgICBzdGF0ZVtrZXldID0gb2JqZWN0W2tleV07XG4gICAgfSBlbHNlIGlmIChtYXNrW2tleV0pIHtcbiAgICAgIHN0YXRlW2tleV0gPSBtYXNrT2JqZWN0KG9iamVjdFtrZXldLCBtYXNrW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG4gIH0sIHt9KTtcbn1cbiIsImNvbnN0IE1BWCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuXG5sZXQgaWRDb3VudGVyID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogTUFYKTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVJhbmRvbUlkKCkge1xuICBpZENvdW50ZXIgJT0gTUFYO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGx1c3BsdXNcbiAgcmV0dXJuIGlkQ291bnRlcisrO1xufVxuIiwiLyoqXG4gKiBDb21wYXJlIDIgZ2l2ZW4gc3RyaW5ncyBhbmQgcmV0dXJuIGJvb2xlYW5cbiAqIGVnOiBcImZvb1wiIGFuZCBcIkZPT1wiID0+IHRydWVcbiAqIGVnOiBcImZvb1wiIGFuZCBcImJhclwiID0+IGZhbHNlXG4gKiBlZzogXCJmb29cIiBhbmQgMTIzID0+IGZhbHNlXG4gKlxuICogQHBhcmFtIHZhbHVlMSAtIGZpcnN0IHN0cmluZyB0byBjb21wYXJlXG4gKiBAcGFyYW0gdmFsdWUyIC0gZmlyc3Qgc3RyaW5nIHRvIGNvbXBhcmVcbiAqIEByZXR1cm5zIHRydWUgaWYgMiBzdHJpbmdzIGFyZSBpZGVudGljYWwgd2hlbiB0aGV5IGFyZSBsb3dlcmNhc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXF1YWxDYXNlSW5zZW5zaXRpdmUoXG4gIHZhbHVlMTogc3RyaW5nLFxuICB2YWx1ZTI6IHN0cmluZyxcbik6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIHZhbHVlMSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlMiAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlMS50b0xvd2VyQ2FzZSgpID09PSB2YWx1ZTIudG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIG51bWJlciB3aXRoIG1heCBsZW5ndGggdW50aWwgdGhlIHJlc3VsdGluZyBzdHJpbmcgcmVhY2hlcyB0aGUgZ2l2ZW4gbGVuZ3RoXG4gKlxuICogQHBhcmFtIG51bVxuICogQHBhcmFtIG1heExlbmd0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJlcGVuZFplcm8obnVtOiBudW1iZXIsIG1heExlbmd0aDogbnVtYmVyKTogc3RyaW5nIHtcbiAgcmV0dXJuIG51bS50b1N0cmluZygpLnBhZFN0YXJ0KG1heExlbmd0aCwgJzAnKTtcbn1cbiIsImltcG9ydCB7IFNXQVBTX0NIQUlOSURfREVGQVVMVF9UT0tFTl9NQVAgfSBmcm9tICcuLi9jb25zdGFudHMvc3dhcHMnO1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBhZGRyZXNzIGlzIHN0cmljdGx5IGVxdWFsIHRvIHRoZSBhZGRyZXNzIGZvclxuICogdGhlIGRlZmF1bHQgc3dhcHMgdG9rZW4gb2YgdGhlIHByb3ZpZGVkIGNoYWluLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIHN0cmluZyB0byBjb21wYXJlIHRvIHRoZSBkZWZhdWx0IHRva2VuIGFkZHJlc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFpbklkIC0gVGhlIGhleCBlbmNvZGVkIGNoYWluIElEIG9mIHRoZSBkZWZhdWx0IHN3YXBzIHRva2VuIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgYWRkcmVzcyBpcyB0aGUgcHJvdmlkZWQgY2hhaW4ncyBkZWZhdWx0IHRva2VuIGFkZHJlc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3dhcHNEZWZhdWx0VG9rZW5BZGRyZXNzKGFkZHJlc3MsIGNoYWluSWQpIHtcbiAgaWYgKCFhZGRyZXNzIHx8ICFjaGFpbklkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGFkZHJlc3MgPT09IFNXQVBTX0NIQUlOSURfREVGQVVMVF9UT0tFTl9NQVBbY2hhaW5JZF0/LmFkZHJlc3M7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHN5bWJvbCBpcyBzdHJpY3RseSBlcXVhbCB0byB0aGUgc3ltYm9sIGZvclxuICogdGhlIGRlZmF1bHQgc3dhcHMgdG9rZW4gb2YgdGhlIHByb3ZpZGVkIGNoYWluLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgLSBUaGUgc3RyaW5nIHRvIGNvbXBhcmUgdG8gdGhlIGRlZmF1bHQgdG9rZW4gc3ltYm9sXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhaW5JZCAtIFRoZSBoZXggZW5jb2RlZCBjaGFpbiBJRCBvZiB0aGUgZGVmYXVsdCBzd2FwcyB0b2tlbiB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHN5bWJsIGlzIHRoZSBwcm92aWRlZCBjaGFpbidzIGRlZmF1bHQgdG9rZW4gc3ltYm9sXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N3YXBzRGVmYXVsdFRva2VuU3ltYm9sKHN5bWJvbCwgY2hhaW5JZCkge1xuICBpZiAoIXN5bWJvbCB8fCAhY2hhaW5JZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzeW1ib2wgPT09IFNXQVBTX0NIQUlOSURfREVGQVVMVF9UT0tFTl9NQVBbY2hhaW5JZF0/LnN5bWJvbDtcbn1cbiIsImltcG9ydCB7IGlzSGV4U3RyaW5nIH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcbmltcG9ydCB7IEludGVyZmFjZSB9IGZyb20gJ0BldGhlcnNwcm9qZWN0L2FiaSc7XG5pbXBvcnQgeyBhYmlFUkM3MjEsIGFiaUVSQzIwLCBhYmlFUkMxMTU1IH0gZnJvbSAnQG1ldGFtYXNrL21ldGFtYXNrLWV0aC1hYmlzJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHtcbiAgQXNzZXRUeXBlLFxuICBUb2tlblN0YW5kYXJkLFxuICBUcmFuc2FjdGlvblR5cGUsXG59IGZyb20gJy4uL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyByZWFkQWRkcmVzc0FzQ29udHJhY3QgfSBmcm9tICcuL2NvbnRyYWN0LXV0aWxzJztcbmltcG9ydCB7IGlzRXF1YWxDYXNlSW5zZW5zaXRpdmUgfSBmcm9tICcuL3N0cmluZy11dGlscyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyAndHJhbnNmZXInIHwgJ2FwcHJvdmUnIHwgJ3NldGFwcHJvdmFsZm9yYWxsJyB8ICd0cmFuc2ZlcmZyb20nIHwgJ2NvbnRyYWN0SW50ZXJhY3Rpb24nfCAnc2ltcGxlU2VuZCcgfSBJbmZlcnJhYmxlVHJhbnNhY3Rpb25UeXBlc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gSW5mZXJUcmFuc2FjdGlvblR5cGVSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7SW5mZXJyYWJsZVRyYW5zYWN0aW9uVHlwZXN9IHR5cGUgLSBUaGUgdHlwZSBvZiB0cmFuc2FjdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IGdldENvZGVSZXNwb25zZSAtIFRoZSBjb250cmFjdCBjb2RlLCBpbiBoZXggZm9ybWF0IGlmXG4gKiAgaXQgZXhpc3RzLiAnMHgwJyBvciAnMHgnIGFyZSBhbHNvIGluZGljYXRvcnMgb2Ygbm9uLWV4aXN0ZW50IGNvbnRyYWN0XG4gKiAgY29kZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgRXRoZXJzQ29udHJhY3RDYWxsXG4gKiBAdHlwZSBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7YW55W119IGFyZ3MgLSBUaGUgYXJncy9wYXJhbXMgdG8gdGhlIGZ1bmN0aW9uIGNhbGwuXG4gKiBBbiBhcnJheS1saWtlIG9iamVjdCB3aXRoIG51bWVyaWNhbCBhbmQgc3RyaW5nIGluZGljZXMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzaWduYXR1cmUgLSBUaGUgZnVuY3Rpb24gc2lnbmF0dXJlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNpZ2hhc2ggLSBUaGUgZnVuY3Rpb24gc2lnbmF0dXJlIGhhc2guXG4gKiBAcHJvcGVydHkge0V0aGVyc0JpZ051bWJlcn0gdmFsdWUgLSBUaGUgRVRIIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2FsbC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb25GcmFnbWVudH0gZnVuY3Rpb25GcmFnbWVudCAtIFRoZSBFdGhlcnMgZnVuY3Rpb24gZnJhZ21lbnRcbiAqIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBmdW5jdGlvbi5cbiAqL1xuXG5jb25zdCBlcmMyMEludGVyZmFjZSA9IG5ldyBJbnRlcmZhY2UoYWJpRVJDMjApO1xuY29uc3QgZXJjNzIxSW50ZXJmYWNlID0gbmV3IEludGVyZmFjZShhYmlFUkM3MjEpO1xuY29uc3QgZXJjMTE1NUludGVyZmFjZSA9IG5ldyBJbnRlcmZhY2UoYWJpRVJDMTE1NSk7XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2FjdGlvbk1hdGNoZXNOZXR3b3JrKHRyYW5zYWN0aW9uLCBjaGFpbklkLCBuZXR3b3JrSWQpIHtcbiAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbi5jaGFpbklkICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5jaGFpbklkID09PSBjaGFpbklkO1xuICB9XG4gIHJldHVybiB0cmFuc2FjdGlvbi5tZXRhbWFza05ldHdvcmtJZCA9PT0gbmV0d29ya0lkO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIG1heEZlZVBlckdhcyBhbmQgbWF4UHJpb3JpdHlGZWVQZXJHYXMgZmllbGRzIGFyZSBzdXBwbGllZFxuICogYW5kIHZhbGlkIGlucHV0cy4gVGhpcyB3aWxsIHJldHVybiBmYWxzZSBmb3Igbm9uIGhleCBzdHJpbmcgaW5wdXRzLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29uc3RhbnRzL3RyYW5zYWN0aW9uXCIpLlRyYW5zYWN0aW9uTWV0YX0gdHJhbnNhY3Rpb24gLVxuICogIHRoZSB0cmFuc2FjdGlvbiB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdHJhbnNhY3Rpb24gdXNlcyB2YWxpZCBFSVAxNTU5IGZpZWxkc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFSVAxNTU5VHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgcmV0dXJuIChcbiAgICBpc0hleFN0cmluZyh0cmFuc2FjdGlvbj8udHhQYXJhbXM/Lm1heEZlZVBlckdhcykgJiZcbiAgICBpc0hleFN0cmluZyh0cmFuc2FjdGlvbj8udHhQYXJhbXM/Lm1heFByaW9yaXR5RmVlUGVyR2FzKVxuICApO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgbWF4RmVlUGVyR2FzIGFuZCBtYXhQcmlvcml0eUZlZVBlckdhcyBmaWVsZHMgYXJlIG5vdFxuICogc3VwcGxpZWQgYW5kIHRoYXQgdGhlIGdhc1ByaWNlIGZpZWxkIGlzIHZhbGlkIGlmIGl0IGlzIHByb3ZpZGVkLiBUaGlzIHdpbGxcbiAqIHJldHVybiBmYWxzZSBpZiBnYXNQcmljZSBpcyBhIG5vbiBoZXggc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29uc3RhbnRzL3RyYW5zYWN0aW9uXCIpLlRyYW5zYWN0aW9uTWV0YX0gdHJhbnNhY3Rpb24gLVxuICogIHRoZSB0cmFuc2FjdGlvbiB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdHJhbnNhY3Rpb24gdXNlcyB2YWxpZCBMZWdhY3kgZmllbGRzIE9SIGxhY2tzXG4gKiAgRUlQMTU1OSBmaWVsZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTGVnYWN5VHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdHJhbnNhY3Rpb24udHhQYXJhbXMubWF4RmVlUGVyR2FzID09PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB0cmFuc2FjdGlvbi50eFBhcmFtcy5tYXhQcmlvcml0eUZlZVBlckdhcyA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAodHlwZW9mIHRyYW5zYWN0aW9uLnR4UGFyYW1zLmdhc1ByaWNlID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgaXNIZXhTdHJpbmcodHJhbnNhY3Rpb24udHhQYXJhbXMuZ2FzUHJpY2UpKVxuICApO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHRyYW5zYWN0aW9ucyBnYXMgZmVlcyBpbiB0eFBhcmFtcyBtYXRjaCB0aG9zZSBpbiBpdHMgZGFwcFN1Z2dlc3RlZEdhc0ZlZXMgcHJvcGVydHlcbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbnN0YW50cy90cmFuc2FjdGlvblwiKS5UcmFuc2FjdGlvbk1ldGF9IHRyYW5zYWN0aW9uIC1cbiAqICB0aGUgdHJhbnNhY3Rpb24gdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGJvdGggdGhlIHR4UGFyYW1zIGFuZCBkYXBwU3VnZ2VzdGVkR2FzRmVlcyBhcmUgb2JqZWN0cyB3aXRoIHRydXRoeSBnYXMgZmVlIHByb3BlcnRpZXMsXG4gKiAgIGFuZCB0aG9zZSBwcm9wZXJ0aWVzIGFyZSBzdHJpY3RseSBlcXVhbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHhQYXJhbXNBcmVEYXBwU3VnZ2VzdGVkKHRyYW5zYWN0aW9uKSB7XG4gIGNvbnN0IHsgZ2FzUHJpY2UsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBtYXhGZWVQZXJHYXMgfSA9XG4gICAgdHJhbnNhY3Rpb24/LnR4UGFyYW1zIHx8IHt9O1xuICByZXR1cm4gKFxuICAgIChnYXNQcmljZSAmJiBnYXNQcmljZSA9PT0gdHJhbnNhY3Rpb24/LmRhcHBTdWdnZXN0ZWRHYXNGZWVzPy5nYXNQcmljZSkgfHxcbiAgICAobWF4UHJpb3JpdHlGZWVQZXJHYXMgJiZcbiAgICAgIG1heEZlZVBlckdhcyAmJlxuICAgICAgdHJhbnNhY3Rpb24/LmRhcHBTdWdnZXN0ZWRHYXNGZWVzPy5tYXhQcmlvcml0eUZlZVBlckdhcyA9PT1cbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgJiZcbiAgICAgIHRyYW5zYWN0aW9uPy5kYXBwU3VnZ2VzdGVkR2FzRmVlcz8ubWF4RmVlUGVyR2FzID09PSBtYXhGZWVQZXJHYXMpXG4gICk7XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZGVjb2RlIHRyYW5zYWN0aW9uIGRhdGEgdXNpbmcgQUJJcyBmb3IgdGhyZWUgZGlmZmVyZW50IHRva2VuIHN0YW5kYXJkczogRVJDMjAsIEVSQzcyMSwgRVJDMTE1NS5cbiAqIFRoZSBkYXRhIHdpbGwgZGVjb2RlIGNvcnJlY3RseSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYW4gaW50ZXJhY3Rpb24gd2l0aCBhIGNvbnRyYWN0IHRoYXQgbWF0Y2hlcyBvbmUgb2YgdGhlc2VcbiAqIGNvbnRyYWN0IHN0YW5kYXJkc1xuICpcbiAqIEBwYXJhbSBkYXRhIC0gZW5jb2RlZCB0cmFuc2FjdGlvbiBkYXRhXG4gKiBAcmV0dXJucyB7RXRoZXJzQ29udHJhY3RDYWxsIHwgdW5kZWZpbmVkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTdGFuZGFyZFRva2VuVHJhbnNhY3Rpb25EYXRhKGRhdGEpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZXJjMjBJbnRlcmZhY2UucGFyc2VUcmFuc2FjdGlvbih7IGRhdGEgfSk7XG4gIH0gY2F0Y2gge1xuICAgIC8vIGlnbm9yZSBhbmQgbmV4dCB0cnkgdG8gcGFyc2Ugd2l0aCBlcmM3MjEgQUJJXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBlcmM3MjFJbnRlcmZhY2UucGFyc2VUcmFuc2FjdGlvbih7IGRhdGEgfSk7XG4gIH0gY2F0Y2gge1xuICAgIC8vIGlnbm9yZSBhbmQgbmV4dCB0cnkgdG8gcGFyc2Ugd2l0aCBlcmMxMTU1IEFCSVxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZXJjMTE1NUludGVyZmFjZS5wYXJzZVRyYW5zYWN0aW9uKHsgZGF0YSB9KTtcbiAgfSBjYXRjaCB7XG4gICAgLy8gaWdub3JlIGFuZCByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGNvbnRyYWN0Q29kZSBvZiB0aGUgdHJhbnNhY3Rpb24gYnkgYW5hbHl6aW5nIHRoZSB0eFBhcmFtcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHhQYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7RXRoUXVlcnl9IHF1ZXJ5IC0gRXRoUXVlcnkgaW5zdGFuY2VcbiAqIEByZXR1cm5zIHtJbmZlclRyYW5zYWN0aW9uVHlwZVJlc3VsdH1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRldGVybWluZVRyYW5zYWN0aW9uQ29udHJhY3RDb2RlKHR4UGFyYW1zLCBxdWVyeSkge1xuICBjb25zdCB7IHRvIH0gPSB0eFBhcmFtcztcbiAgY29uc3QgeyBjb250cmFjdENvZGUgfSA9IGF3YWl0IHJlYWRBZGRyZXNzQXNDb250cmFjdChxdWVyeSwgdG8pO1xuICByZXR1cm4gY29udHJhY3RDb2RlO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgdGhlIHR5cGUgb2YgdGhlIHRyYW5zYWN0aW9uIGJ5IGFuYWx5emluZyB0aGUgdHhQYXJhbXMuXG4gKiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBvbmUgb2YgdGhlIHR5cGVzIGRlZmluZWQgaW4gc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbnNcbiAqIEl0IHdpbGwgbmV2ZXIgcmV0dXJuIFRSQU5TQUNUSU9OX1RZUEVfQ0FOQ0VMIG9yIFRSQU5TQUNUSU9OX1RZUEVfUkVUUlkgYXMgdGhlc2VcbiAqIHJlcHJlc2VudCBzcGVjaWZpYyBldmVudHMgdGhhdCB3ZSBjb250cm9sIGZyb20gdGhlIGV4dGVuc2lvbiBhbmQgYXJlIGFkZGVkIG1hbnVhbGx5XG4gKiBhdCB0cmFuc2FjdGlvbiBjcmVhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHhQYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7RXRoUXVlcnl9IHF1ZXJ5IC0gRXRoUXVlcnkgaW5zdGFuY2VcbiAqIEByZXR1cm5zIHtJbmZlclRyYW5zYWN0aW9uVHlwZVJlc3VsdH1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRldGVybWluZVRyYW5zYWN0aW9uVHlwZSh0eFBhcmFtcywgcXVlcnkpIHtcbiAgY29uc3QgeyBkYXRhLCB0byB9ID0gdHhQYXJhbXM7XG4gIGxldCBuYW1lO1xuICB0cnkge1xuICAgICh7IG5hbWUgfSA9IGRhdGEgJiYgcGFyc2VTdGFuZGFyZFRva2VuVHJhbnNhY3Rpb25EYXRhKGRhdGEpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2cuZGVidWcoJ0ZhaWxlZCB0byBwYXJzZSB0cmFuc2FjdGlvbiBkYXRhLicsIGVycm9yLCBkYXRhKTtcbiAgfVxuXG4gIGxldCByZXN1bHQ7XG4gIGxldCBjb250cmFjdENvZGU7XG5cbiAgaWYgKGRhdGEgJiYgIXRvKSB7XG4gICAgcmVzdWx0ID0gVHJhbnNhY3Rpb25UeXBlLmRlcGxveUNvbnRyYWN0O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHsgY29udHJhY3RDb2RlOiByZXN1bHRDb2RlLCBpc0NvbnRyYWN0QWRkcmVzcyB9ID1cbiAgICAgIGF3YWl0IHJlYWRBZGRyZXNzQXNDb250cmFjdChxdWVyeSwgdG8pO1xuXG4gICAgY29udHJhY3RDb2RlID0gcmVzdWx0Q29kZTtcblxuICAgIGlmIChpc0NvbnRyYWN0QWRkcmVzcykge1xuICAgICAgY29uc3QgaGFzVmFsdWUgPSB0eFBhcmFtcy52YWx1ZSAmJiB0eFBhcmFtcy52YWx1ZSAhPT0gJzB4MCc7XG5cbiAgICAgIGNvbnN0IHRva2VuTWV0aG9kTmFtZSA9IFtcbiAgICAgICAgVHJhbnNhY3Rpb25UeXBlLnRva2VuTWV0aG9kQXBwcm92ZSxcbiAgICAgICAgVHJhbnNhY3Rpb25UeXBlLnRva2VuTWV0aG9kU2V0QXBwcm92YWxGb3JBbGwsXG4gICAgICAgIFRyYW5zYWN0aW9uVHlwZS50b2tlbk1ldGhvZFRyYW5zZmVyLFxuICAgICAgICBUcmFuc2FjdGlvblR5cGUudG9rZW5NZXRob2RUcmFuc2ZlckZyb20sXG4gICAgICAgIFRyYW5zYWN0aW9uVHlwZS50b2tlbk1ldGhvZFNhZmVUcmFuc2ZlckZyb20sXG4gICAgICBdLmZpbmQoKG1ldGhvZE5hbWUpID0+IGlzRXF1YWxDYXNlSW5zZW5zaXRpdmUobWV0aG9kTmFtZSwgbmFtZSkpO1xuXG4gICAgICByZXN1bHQgPVxuICAgICAgICBkYXRhICYmIHRva2VuTWV0aG9kTmFtZSAmJiAhaGFzVmFsdWVcbiAgICAgICAgICA/IHRva2VuTWV0aG9kTmFtZVxuICAgICAgICAgIDogVHJhbnNhY3Rpb25UeXBlLmNvbnRyYWN0SW50ZXJhY3Rpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFRyYW5zYWN0aW9uVHlwZS5zaW1wbGVTZW5kO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHJlc3VsdCwgZ2V0Q29kZVJlc3BvbnNlOiBjb250cmFjdENvZGUgfTtcbn1cblxuY29uc3QgSU5GRVJSQUJMRV9UUkFOU0FDVElPTl9UWVBFUyA9IFtcbiAgVHJhbnNhY3Rpb25UeXBlLnRva2VuTWV0aG9kQXBwcm92ZSxcbiAgVHJhbnNhY3Rpb25UeXBlLnRva2VuTWV0aG9kU2V0QXBwcm92YWxGb3JBbGwsXG4gIFRyYW5zYWN0aW9uVHlwZS50b2tlbk1ldGhvZFRyYW5zZmVyLFxuICBUcmFuc2FjdGlvblR5cGUudG9rZW5NZXRob2RUcmFuc2ZlckZyb20sXG4gIFRyYW5zYWN0aW9uVHlwZS5jb250cmFjdEludGVyYWN0aW9uLFxuICBUcmFuc2FjdGlvblR5cGUuc2ltcGxlU2VuZCxcbl07XG5cbi8qKlxuICogR2l2ZW4gYSB0cmFuc2FjdGlvbiBtZXRhIG9iamVjdCwgZGV0ZXJtaW5lIHRoZSBhc3NldCB0eXBlIHRoYXQgdGhlXG4gKiB0cmFuc2FjdGlvbiBpcyBkZWFsaW5nIHdpdGgsIGFzIHdlbGwgYXMgdGhlIHN0YW5kYXJkIGZvciB0aGUgdG9rZW4gaWYgaXRcbiAqIGlzIGEgdG9rZW4gdHJhbnNhY3Rpb24uXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2NvbnN0YW50cy90cmFuc2FjdGlvbicpLlRyYW5zYWN0aW9uTWV0YX0gdHhNZXRhIC1cbiAqICB0cmFuc2FjdGlvbiBtZXRhIG9iamVjdFxuICogQHBhcmFtIHtFdGhRdWVyeX0gcXVlcnkgLSBFdGhRdWVyeSBpbnN0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0VG9rZW5TdGFuZGFyZEFuZERldGFpbHMgLSBmdW5jdGlvbiB0byBnZXQgdG9rZW5cbiAqICBzdGFuZGFyZHMgYW5kIGRldGFpbHMuXG4gKiBAcmV0dXJucyB7eyBhc3NldFR5cGU6IHN0cmluZywgdG9rZW5TdGFuZGFyZDogc3RyaW5nfX1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRldGVybWluZVRyYW5zYWN0aW9uQXNzZXRUeXBlKFxuICB0eE1ldGEsXG4gIHF1ZXJ5LFxuICBnZXRUb2tlblN0YW5kYXJkQW5kRGV0YWlscyxcbikge1xuICAvLyBJZiB0aGUgdHJhbnNhY3Rpb24gdHlwZSBpcyBhbHJlYWR5IG9uZSBvZiB0aGUgaW5mZXJyYWJsZSB0eXBlcywgdGhlbiB3ZSBkb1xuICAvLyBub3QgbmVlZCB0byByZS1lc3RhYmxpc2ggdGhlIHR5cGUuXG4gIGxldCBpbmZlcnJhYmxlVHlwZSA9IHR4TWV0YS50eXBlO1xuICBpZiAoSU5GRVJSQUJMRV9UUkFOU0FDVElPTl9UWVBFUy5pbmNsdWRlcyh0eE1ldGEudHlwZSkgPT09IGZhbHNlKSB7XG4gICAgLy8gQmVjYXVzZSB3ZSB3aWxsIGRlYWwgd2l0aCBhbGwgdHlwZXMgb2YgdHJhbnNhY3Rpb25zIChpbmNsdWRpbmcgc3dhcHMpXG4gICAgLy8gd2Ugd2FudCB0byBnZXQgYW4gaW5mZXJyYWJsZSB0eXBlIG9mIHRyYW5zYWN0aW9uIHRoYXQgaXNuJ3Qgc3BlY2lhbCBjYXNlZFxuICAgIC8vIHRoYXQgd2F5IHdlIGNhbiBuYXJyb3cgdGhlIG51bWJlciBvZiBsb2dpYyBnYXRlcyByZXF1aXJlZC5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkZXRlcm1pbmVUcmFuc2FjdGlvblR5cGUodHhNZXRhLnR4UGFyYW1zLCBxdWVyeSk7XG4gICAgaW5mZXJyYWJsZVR5cGUgPSByZXN1bHQudHlwZTtcbiAgfVxuXG4gIC8vIElmIHRoZSBpbmZlcnJlZCB0eXBlIG9mIHRoZSB0cmFuc2FjdGlvbiBpcyBvbmUgb2YgdGhvc2UgdGhhdCBhcmUgcGFydCBvZlxuICAvLyB0aGUgdG9rZW4gY29udHJhY3Qgc3RhbmRhcmRzLCB3ZSBjYW4gdXNlIHRoZSBnZXRUb2tlblN0YW5kYXJkQW5kRGV0YWlsc1xuICAvLyBtZXRob2QgdG8gZ2V0IHRoZSBhc3NldCB0eXBlLlxuICBjb25zdCBpc1Rva2VuTWV0aG9kID0gW1xuICAgIFRyYW5zYWN0aW9uVHlwZS50b2tlbk1ldGhvZEFwcHJvdmUsXG4gICAgVHJhbnNhY3Rpb25UeXBlLnRva2VuTWV0aG9kU2V0QXBwcm92YWxGb3JBbGwsXG4gICAgVHJhbnNhY3Rpb25UeXBlLnRva2VuTWV0aG9kVHJhbnNmZXIsXG4gICAgVHJhbnNhY3Rpb25UeXBlLnRva2VuTWV0aG9kVHJhbnNmZXJGcm9tLFxuICBdLmZpbmQoKG1ldGhvZE5hbWUpID0+IG1ldGhvZE5hbWUgPT09IGluZmVycmFibGVUeXBlKTtcblxuICBpZiAoXG4gICAgaXNUb2tlbk1ldGhvZCB8fFxuICAgIC8vIFdlIGNhbiBhbHNvIGNoZWNrIGFueSBjb250cmFjdCBpbnRlcmFjdGlvbiB0eXBlIHRvIHNlZSBpZiB0aGUgdG8gYWRkcmVzc1xuICAgIC8vIGlzIGEgdG9rZW4gY29udHJhY3QuIElmIGl0IGlzbid0LCB0aGVuIHRoZSBtZXRob2Qgd2lsbCB0aHJvdyBhbmQgd2UgY2FuXG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBvdGhlciBjaGVja3MuXG4gICAgaW5mZXJyYWJsZVR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5jb250cmFjdEludGVyYWN0aW9uXG4gICkge1xuICAgIHRyeSB7XG4gICAgICAvLyBXZSBkb24ndCBuZWVkIGEgYmFsYW5jZSBjaGVjaywgc28gdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG9cbiAgICAgIC8vIGdldFRva2VuU3RhbmRhcmRBbmREZXRhaWxzIGlzIG9taXR0ZWQuXG4gICAgICBjb25zdCBkZXRhaWxzID0gYXdhaXQgZ2V0VG9rZW5TdGFuZGFyZEFuZERldGFpbHModHhNZXRhLnR4UGFyYW1zLnRvKTtcbiAgICAgIGlmIChkZXRhaWxzLnN0YW5kYXJkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXNzZXRUeXBlOlxuICAgICAgICAgICAgZGV0YWlscy5zdGFuZGFyZCA9PT0gVG9rZW5TdGFuZGFyZC5FUkMyMFxuICAgICAgICAgICAgICA/IEFzc2V0VHlwZS50b2tlblxuICAgICAgICAgICAgICA6IEFzc2V0VHlwZS5ORlQsXG4gICAgICAgICAgdG9rZW5TdGFuZGFyZDogZGV0YWlscy5zdGFuZGFyZCxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIG5vb3AsIFdlIGV4cGVjdCBlcnJvcnMgaGVyZSBidXQgd2UgZG9uJ3QgbmVlZCB0byByZXBvcnQgdGhlbSBvciBkb1xuICAgICAgLy8gYW55dGhpbmcgaW4gcmVzcG9uc2UuXG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlIHRyYW5zYWN0aW9uIGlzIGludGVyYWN0aW5nIHdpdGggYSBjb250cmFjdCBidXQgaXNuJ3QgYSB0b2tlbiBtZXRob2RcbiAgLy8gd2UgdXNlIHRoZSAnVU5LTk9XTicgdmFsdWUgdG8gc2hvdyB0aGF0IGl0IGlzbid0IGEgdHJhbnNhY3Rpb24gc2VuZGluZyBhbnlcbiAgLy8gcGFydGljdWxhciBhc3NldC5cbiAgaWYgKGluZmVycmFibGVUeXBlID09PSBUcmFuc2FjdGlvblR5cGUuY29udHJhY3RJbnRlcmFjdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICBhc3NldFR5cGU6IEFzc2V0VHlwZS51bmtub3duLFxuICAgICAgdG9rZW5TdGFuZGFyZDogVG9rZW5TdGFuZGFyZC5ub25lLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHsgYXNzZXRUeXBlOiBBc3NldFR5cGUubmF0aXZlLCB0b2tlblN0YW5kYXJkOiBUb2tlblN0YW5kYXJkLm5vbmUgfTtcbn1cbiIsIi8vIE1lc3NhZ2VzIGFuZCBkZXNjcmlwdGlvbnMgZm9yIHRoZXNlIGxvY2FsZSBrZXlzIGFyZSBpbiBhcHAvX2xvY2FsZXMvZW4vbWVzc2FnZXMuanNvblxuZXhwb3J0IGNvbnN0IFVJX05PVElGSUNBVElPTlMgPSB7XG4gIDE6IHtcbiAgICBpZDogMSxcbiAgICBkYXRlOiAnMjAyMS0wMy0xNycsXG4gICAgaW1hZ2U6IHtcbiAgICAgIHNyYzogJ2ltYWdlcy9tb2JpbGUtbGluay1xci5zdmcnLFxuICAgICAgaGVpZ2h0OiAnMjMwcHgnLFxuICAgICAgd2lkdGg6ICcyMzBweCcsXG4gICAgICBwbGFjZUltYWdlQmVsb3dEZXNjcmlwdGlvbjogdHJ1ZSxcbiAgICB9LFxuICB9LFxuICAzOiB7XG4gICAgaWQ6IDMsXG4gICAgZGF0ZTogJzIwMjEtMDMtMDgnLFxuICB9LFxuICA0OiB7XG4gICAgaWQ6IDQsXG4gICAgZGF0ZTogJzIwMjEtMDUtMTEnLFxuICAgIGltYWdlOiB7XG4gICAgICBzcmM6ICdpbWFnZXMvc291cmNlLWxvZ29zLWJzYy5zdmcnLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICB9LFxuICB9LFxuICA1OiB7XG4gICAgaWQ6IDUsXG4gICAgZGF0ZTogJzIwMjEtMDYtMDknLFxuICB9LFxuICA2OiB7XG4gICAgaWQ6IDYsXG4gICAgZGF0ZTogJzIwMjEtMDUtMjYnLFxuICB9LFxuICA3OiB7XG4gICAgaWQ6IDcsXG4gICAgZGF0ZTogJzIwMjEtMDktMTcnLFxuICB9LFxuICA4OiB7XG4gICAgaWQ6IDgsXG4gICAgZGF0ZTogJzIwMjEtMTEtMDEnLFxuICB9LFxuICA5OiB7XG4gICAgaWQ6IDksXG4gICAgZGF0ZTogJzIwMjEtMTItMDcnLFxuICAgIGltYWdlOiB7XG4gICAgICBzcmM6ICdpbWFnZXMvdHhpbnNpZ2h0cy5wbmcnLFxuICAgICAgd2lkdGg6ICc4MCUnLFxuICAgIH0sXG4gIH0sXG4gIDEwOiB7XG4gICAgaWQ6IDEwLFxuICAgIGRhdGU6ICcyMDIyLTA5LTE1JyxcbiAgICBpbWFnZToge1xuICAgICAgc3JjOiAnaW1hZ2VzL3Rva2VuLWRldGVjdGlvbi5zdmcnLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICB9LFxuICB9LFxuICAxMToge1xuICAgIGlkOiAxMSxcbiAgICBkYXRlOiAnMjAyMi0wOS0xNScsXG4gIH0sXG4gIDEyOiB7XG4gICAgaWQ6IDEyLFxuICAgIGRhdGU6ICcyMDIyLTA1LTE4JyxcbiAgICBpbWFnZToge1xuICAgICAgc3JjOiAnaW1hZ2VzL2Rhcmttb2RlLWJhbm5lci5wbmcnLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICB9LFxuICB9LFxuICAxMzoge1xuICAgIGlkOiAxMyxcbiAgICBkYXRlOiAnMjAyMi0wOS0xNScsXG4gIH0sXG4gIDE0OiB7XG4gICAgaWQ6IDE0LFxuICAgIGRhdGU6ICcyMDIyLTA5LTE1JyxcbiAgfSxcbiAgMTU6IHtcbiAgICBpZDogMTUsXG4gICAgZGF0ZTogJzIwMjItMDktMTUnLFxuICB9LFxuICAxNjoge1xuICAgIGlkOiAxNixcbiAgICBkYXRlOiBudWxsLFxuICB9LFxuICAxNzoge1xuICAgIGlkOiAxNyxcbiAgICBkYXRlOiBudWxsLFxuICB9LFxuICAxODoge1xuICAgIGlkOiAxOCxcbiAgICBkYXRlOiBudWxsLFxuICAgIGltYWdlOiB7XG4gICAgICBzcmM6ICdpbWFnZXMvb3Blbi1zZWEtc2VjdXJpdHktcHJvdmlkZXIuc3ZnJyxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgfSxcbiAgfSxcbiAgMTk6IHtcbiAgICBpZDogMTksXG4gICAgZGF0ZTogbnVsbCxcbiAgICBpbWFnZToge1xuICAgICAgc3JjOiAnaW1hZ2VzL25mdHMuc3ZnJyxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgfSxcbiAgfSxcbiAgMjA6IHtcbiAgICBpZDogMjAsXG4gICAgZGF0ZTogbnVsbCxcbiAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRUcmFuc2xhdGVkVUlOb3RpZmljYXRpb25zID0gKHQsIGxvY2FsZSkgPT4ge1xuICBjb25zdCBmb3JtYXR0ZWRMb2NhbGUgPSBsb2NhbGUucmVwbGFjZSgnXycsICctJyk7XG4gIHJldHVybiB7XG4gICAgMToge1xuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1sxXSxcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zMVRpdGxlJyksXG4gICAgICBkZXNjcmlwdGlvbjogdCgnbm90aWZpY2F0aW9uczFEZXNjcmlwdGlvbicpLFxuICAgICAgZGF0ZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXG4gICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbMV0uZGF0ZSksXG4gICAgICApLFxuICAgIH0sXG4gICAgMzoge1xuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1szXSxcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zM1RpdGxlJyksXG4gICAgICBkZXNjcmlwdGlvbjogdCgnbm90aWZpY2F0aW9uczNEZXNjcmlwdGlvbicpLFxuICAgICAgYWN0aW9uVGV4dDogdCgnbm90aWZpY2F0aW9uczNBY3Rpb25UZXh0JyksXG4gICAgICBkYXRlOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcbiAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1szXS5kYXRlKSxcbiAgICAgICksXG4gICAgfSxcbiAgICA0OiB7XG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzRdLFxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnM0VGl0bGUnKSxcbiAgICAgIGRlc2NyaXB0aW9uOiB0KCdub3RpZmljYXRpb25zNERlc2NyaXB0aW9uJyksXG4gICAgICBhY3Rpb25UZXh0OiB0KCdub3RpZmljYXRpb25zNEFjdGlvblRleHQnKSxcbiAgICAgIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxuICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzRdLmRhdGUpLFxuICAgICAgKSxcbiAgICB9LFxuICAgIDU6IHtcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbNV0sXG4gICAgICB0aXRsZTogdCgnc2VjcmV0UmVjb3ZlcnlQaHJhc2UnKSxcbiAgICAgIGRlc2NyaXB0aW9uOiB0KCdub3RpZmljYXRpb25zNURlc2NyaXB0aW9uJyksXG4gICAgICBhY3Rpb25UZXh0OiB0KCdub3RpZmljYXRpb25zM0FjdGlvblRleHQnKSxcbiAgICAgIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxuICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzVdLmRhdGUpLFxuICAgICAgKSxcbiAgICB9LFxuICAgIDY6IHtcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbNl0sXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczZUaXRsZScpLFxuICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczZEZXNjcmlwdGlvbk9uZScpLFxuICAgICAgICB0KCdub3RpZmljYXRpb25zNkRlc2NyaXB0aW9uVHdvJyksXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnM2RGVzY3JpcHRpb25UaHJlZScpLFxuICAgICAgXSxcbiAgICAgIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxuICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzZdLmRhdGUpLFxuICAgICAgKSxcbiAgICB9LFxuICAgIDc6IHtcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbN10sXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczdUaXRsZScpLFxuICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczdEZXNjcmlwdGlvbk9uZScpLFxuICAgICAgICB0KCdub3RpZmljYXRpb25zN0Rlc2NyaXB0aW9uVHdvJyksXG4gICAgICBdLFxuICAgICAgZGF0ZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXG4gICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbN10uZGF0ZSksXG4gICAgICApLFxuICAgIH0sXG4gICAgODoge1xuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1s4XSxcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zOFRpdGxlJyksXG4gICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICB0KCdub3RpZmljYXRpb25zOERlc2NyaXB0aW9uT25lJyksXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnM4RGVzY3JpcHRpb25Ud28nKSxcbiAgICAgIF0sXG4gICAgICBkYXRlOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcbiAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1s4XS5kYXRlKSxcbiAgICAgICksXG4gICAgICBhY3Rpb25UZXh0OiB0KCdub3RpZmljYXRpb25zOEFjdGlvblRleHQnKSxcbiAgICB9LFxuICAgIDk6IHtcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbOV0sXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczlUaXRsZScpLFxuICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczlEZXNjcmlwdGlvbk9uZScpLFxuICAgICAgICB0KCdub3RpZmljYXRpb25zOURlc2NyaXB0aW9uVHdvJyksXG4gICAgICBdLFxuICAgICAgZGF0ZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXG4gICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbOV0uZGF0ZSksXG4gICAgICApLFxuICAgIH0sXG4gICAgMTA6IHtcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbMTBdLFxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnMxMFRpdGxlJyksXG4gICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICB0KCdub3RpZmljYXRpb25zMTBEZXNjcmlwdGlvbk9uZScpLFxuICAgICAgICB0KCdub3RpZmljYXRpb25zMTBEZXNjcmlwdGlvblR3bycpLFxuICAgICAgICB0KCdub3RpZmljYXRpb25zMTBEZXNjcmlwdGlvblRocmVlJyksXG4gICAgICBdLFxuICAgICAgYWN0aW9uVGV4dDogdCgnbm90aWZpY2F0aW9uczEwQWN0aW9uVGV4dCcpLFxuICAgICAgZGF0ZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXG4gICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbMTBdLmRhdGUpLFxuICAgICAgKSxcbiAgICB9LFxuICAgIDExOiB7XG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzExXSxcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zMTFUaXRsZScpLFxuICAgICAgZGVzY3JpcHRpb246IHQoJ25vdGlmaWNhdGlvbnMxMURlc2NyaXB0aW9uJyksXG4gICAgICBkYXRlOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcbiAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1sxMV0uZGF0ZSksXG4gICAgICApLFxuICAgIH0sXG4gICAgMTI6IHtcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbMTJdLFxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnMxMlRpdGxlJyksXG4gICAgICBkZXNjcmlwdGlvbjogdCgnbm90aWZpY2F0aW9uczEyRGVzY3JpcHRpb24nKSxcbiAgICAgIGFjdGlvblRleHQ6IHQoJ25vdGlmaWNhdGlvbnMxMkFjdGlvblRleHQnKSxcbiAgICAgIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxuICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzEyXS5kYXRlKSxcbiAgICAgICksXG4gICAgfSxcbiAgICAxMzoge1xuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1sxM10sXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczEzVGl0bGUnKSxcbiAgICAgIGRlc2NyaXB0aW9uOiB0KCdub3RpZmljYXRpb25zMTNEZXNjcmlwdGlvbicpLFxuICAgICAgYWN0aW9uVGV4dDogdCgnbm90aWZpY2F0aW9uczEzQWN0aW9uVGV4dCcpLFxuICAgICAgZGF0ZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXG4gICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbMTNdLmRhdGUpLFxuICAgICAgKSxcbiAgICB9LFxuICAgIDE0OiB7XG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzE0XSxcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zMTRUaXRsZScpLFxuICAgICAgZGVzY3JpcHRpb246IHQoJ25vdGlmaWNhdGlvbnMxNERlc2NyaXB0aW9uJyksXG4gICAgICBhY3Rpb25UZXh0OiB0KCdub3RpZmljYXRpb25zMTRBY3Rpb25UZXh0JyksXG4gICAgICBkYXRlOiBVSV9OT1RJRklDQVRJT05TWzE0XS5kYXRlXG4gICAgICAgID8gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXG4gICAgICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzE0XS5kYXRlKSxcbiAgICAgICAgICApXG4gICAgICAgIDogJycsXG4gICAgfSxcbiAgICAxNToge1xuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1sxNV0sXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczE1VGl0bGUnKSxcbiAgICAgIGRlc2NyaXB0aW9uOiB0KCdub3RpZmljYXRpb25zMTVEZXNjcmlwdGlvbicpLFxuICAgICAgZGF0ZTogVUlfTk9USUZJQ0FUSU9OU1sxNV0uZGF0ZVxuICAgICAgICA/IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxuICAgICAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1sxNV0uZGF0ZSksXG4gICAgICAgICAgKVxuICAgICAgICA6ICcnLFxuICAgIH0sXG4gICAgMTg6IHtcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbMThdLFxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnMxOFRpdGxlJyksXG4gICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICB0KCdub3RpZmljYXRpb25zMThEZXNjcmlwdGlvbk9uZScpLFxuICAgICAgICB0KCdub3RpZmljYXRpb25zMThEZXNjcmlwdGlvblR3bycpLFxuICAgICAgICB0KCdub3RpZmljYXRpb25zMThEZXNjcmlwdGlvblRocmVlJyksXG4gICAgICBdLFxuICAgICAgYWN0aW9uVGV4dDogdCgnbm90aWZpY2F0aW9uczE4QWN0aW9uVGV4dCcpLFxuICAgICAgZGF0ZTogVUlfTk9USUZJQ0FUSU9OU1sxOF0uZGF0ZVxuICAgICAgICA/IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxuICAgICAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1sxOF0uZGF0ZSksXG4gICAgICAgICAgKVxuICAgICAgICA6ICcnLFxuICAgIH0sXG5cbiAgICAxOToge1xuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1sxOV0sXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczE5VGl0bGUnKSxcbiAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnMxOURlc2NyaXB0aW9uT25lJyksXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnMxOURlc2NyaXB0aW9uVHdvJyksXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnMxOURlc2NyaXB0aW9uVGhyZWUnKSxcbiAgICAgIF0sXG4gICAgICBhY3Rpb25UZXh0OiB0KCdub3RpZmljYXRpb25zMTlBY3Rpb25UZXh0JyksXG4gICAgICBkYXRlOiBVSV9OT1RJRklDQVRJT05TWzE5XS5kYXRlXG4gICAgICAgID8gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXG4gICAgICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzE5XS5kYXRlKSxcbiAgICAgICAgICApXG4gICAgICAgIDogJycsXG4gICAgfSxcbiAgICAyMDoge1xuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1syMF0sXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczIwVGl0bGUnKSxcbiAgICAgIGRlc2NyaXB0aW9uOiBbdCgnbm90aWZpY2F0aW9uczIwRGVzY3JpcHRpb24nKV0sXG4gICAgICBhY3Rpb25UZXh0OiB0KCdub3RpZmljYXRpb25zMjBBY3Rpb25UZXh0JyksXG4gICAgICBkYXRlOiBVSV9OT1RJRklDQVRJT05TWzIwXS5kYXRlXG4gICAgICAgID8gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXG4gICAgICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzIwXS5kYXRlKSxcbiAgICAgICAgICApXG4gICAgICAgIDogJycsXG4gICAgfSxcbiAgfTtcbn07XG4iLCJleHBvcnQgY29uc3QgUFJJTUFSWSA9ICdQUklNQVJZJztcbmV4cG9ydCBjb25zdCBTRUNPTkRBUlkgPSAnU0VDT05EQVJZJztcblxuY29uc3QgX2NvbnRyYWN0QWRkcmVzc0xpbmsgPVxuICAnaHR0cHM6Ly9tZXRhbWFzay56ZW5kZXNrLmNvbS9oYy9lbi11cy9hcnRpY2xlcy8zNjAwMjAwMjgwOTItV2hhdC1pcy10aGUta25vd24tY29udHJhY3QtYWRkcmVzcy13YXJuaW5nLSc7XG5cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG5leHBvcnQgY29uc3QgU1VQUE9SVF9SRVFVRVNUX0xJTksgPSBwcm9jZXNzLmVudi5TVVBQT1JUX1JFUVVFU1RfTElOSztcbmV4cG9ydCBjb25zdCBDT05UUkFDVF9BRERSRVNTX0xJTksgPSBfY29udHJhY3RBZGRyZXNzTGluaztcbmV4cG9ydCBjb25zdCBQQVNTV09SRF9NSU5fTEVOR1RIID0gODtcbmV4cG9ydCBjb25zdCBPVVREQVRFRF9CUk9XU0VSX1ZFUlNJT05TID0ge1xuICAvLyBDaHJvbWUgYW5kIEVkZ2Ugc2hvdWxkIG1hdGNoIHRoZSBsYXRlc3QgQ2hyb21lIHZlcnNpb24gcmVsZWFzZWQgfjIgeWVhcnMgYWdvXG4gIGNocm9tZTogJzw5MCcsXG4gIGVkZ2U6ICc8OTAnLFxuICAvLyBGaXJlZm94IHNob3VsZCBtYXRjaCB0aGUgbW9zdCByZWNlbnQgZW5kLW9mLWxpZmUgZXh0ZW5kZWQgc3VwcG9ydCByZWxlYXNlXG4gIGZpcmVmb3g6ICc8OTEnLFxuICAvLyBPcGVyYSBzaG91bGQgYmUgc2V0IHRvIHRoZSBlcXVpdmFsZW50IG9mIHRoZSBDaHJvbWUgdmVyc2lvbiBzZXRcbiAgLy8gU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hpc3Rvcnlfb2ZfdGhlX09wZXJhX3dlYl9icm93c2VyXG4gIG9wZXJhOiAnPDc2Jyxcbn07XG4iLCJcbmNvbnN0IGFzc2V0TGlzdCA9IHtcbiAgbWFpbjoge1xuICAgIC8vIFdpbGwgdXNlIGRlZmF1bHQgcHJvdmlkZWQgYnkgdGhlIEBtZXRhbWFzay9sb2dvIGxpYnJhcnlcbiAgICBmb3hNZXNoSnNvbjogdW5kZWZpbmVkLFxuICB9LFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQmV0YSgpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52Lk1FVEFNQVNLX0JVSUxEX1RZUEUgPT09ICdiZXRhJztcbn1cblxuLy8gUmV0dXJucyBhIHNwZWNpZmljIHZlcnNpb24gb2YgYW4gYXNzZXQgYmFzZWQgb25cbi8vIHRoZSBjdXJyZW50IG1ldGFtYXNrIHZlcnNpb24gKGkuZS4gbWFpbiwgYmV0YSwgZXRjLilcbmV4cG9ydCBmdW5jdGlvbiBnZXRCdWlsZFNwZWNpZmljQXNzZXQoYXNzZXROYW1lKSB7XG4gIGNvbnN0IGJ1aWxkVHlwZSA9IHByb2Nlc3MuZW52Lk1FVEFNQVNLX0JVSUxEX1RZUEU7XG4gIGlmIChcbiAgICAhYXNzZXRMaXN0W2J1aWxkVHlwZV0gfHxcbiAgICAhT2JqZWN0LmtleXMoYXNzZXRMaXN0W2J1aWxkVHlwZV0pLmluY2x1ZGVzKGFzc2V0TmFtZSlcbiAgKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIGBDYW5ub3QgZmluZCBhc3NldCBcIiR7YXNzZXROYW1lfVwiIGZvciBidWlsZCBcIiR7YnVpbGRUeXBlfVwiLCByZXR1cm5pbmcgbWFpbiBidWlsZCBhc3NldC5gLFxuICAgICk7XG4gICAgcmV0dXJuIGFzc2V0TGlzdC5tYWluW2Fzc2V0TmFtZV07XG4gIH1cbiAgcmV0dXJuIGFzc2V0TGlzdFtidWlsZFR5cGVdW2Fzc2V0TmFtZV07XG59XG4iLCJpbXBvcnQgeyBvbWl0IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IEJOIH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcbmltcG9ydCB7IENvbW1vbiwgSGFyZGZvcmsgfSBmcm9tICdAZXRoZXJldW1qcy9jb21tb24nO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25GYWN0b3J5IH0gZnJvbSAnQGV0aGVyZXVtanMvdHgnO1xuaW1wb3J0IHsgc3RyaXBIZXhQcmVmaXggfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9oZXhzdHJpbmctdXRpbHMnO1xuXG5mdW5jdGlvbiBidWlsZFR4UGFyYW1zKHR4TWV0YSkge1xuICByZXR1cm4ge1xuICAgIC4uLm9taXQodHhNZXRhLnR4UGFyYW1zLCAnZ2FzJyksXG4gICAgZ2FzTGltaXQ6IHR4TWV0YS50eFBhcmFtcy5nYXMsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVHJhbnNhY3Rpb25Db21tb24odHhNZXRhKSB7XG4gIC8vIFRoaXMgcHJvZHVjZXMgYSB0cmFuc2FjdGlvbiB3aG9zZSBpbmZvcm1hdGlvbiBkb2VzIG5vdCBjb21wbGV0ZWx5IG1hdGNoIGFuXG4gIC8vIE9wdGltaXNtIHRyYW5zYWN0aW9uIOKAlCBmb3IgaW5zdGFuY2UsIERFRkFVTFRfQ0hBSU4gaXMgc3RpbGwgJ21haW5uZXQnIGFuZFxuICAvLyBnZW5lc2lzIHBvaW50cyB0byB0aGUgbWFpbm5ldCBnZW5lc2lzLCBub3QgdGhlIE9wdGltaXNtIGdlbmVzaXMg4oCUIGJ1dFxuICAvLyBjb25zaWRlcmluZyB0aGF0IGFsbCB3ZSB3YW50IHRvIGRvIGlzIHNlcmlhbGl6ZSBhIHRyYW5zYWN0aW9uLCB0aGlzIHdvcmtzXG4gIC8vIGZpbmUgZm9yIG91ciB1c2UgY2FzZS5cbiAgcmV0dXJuIENvbW1vbi5jdXN0b20oe1xuICAgIGNoYWluSWQ6IG5ldyBCTihzdHJpcEhleFByZWZpeCh0eE1ldGEuY2hhaW5JZCksIDE2KSxcbiAgICBuZXR3b3JrSWQ6IG5ldyBCTih0eE1ldGEubWV0YW1hc2tOZXR3b3JrSWQsIDEwKSxcbiAgICAvLyBPcHRpbWlzbSBvbmx5IHN1cHBvcnRzIHR5cGUtMCB0cmFuc2FjdGlvbnM7IGl0IGRvZXMgbm90IHN1cHBvcnQgYW55IG9mXG4gICAgLy8gdGhlIG5ld2VyIEVJUHMgc2luY2UgRUlQLTE1NS4gU291cmNlOlxuICAgIC8vIDxodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0tb3B0aW1pc20vb3B0aW1pc20vYmxvYi9kZXZlbG9wL3NwZWNzL2wyZ2V0aC90cmFuc2FjdGlvbi10eXBlcy5tZD5cbiAgICBkZWZhdWx0SGFyZGZvcms6IEhhcmRmb3JrLlNwdXJpb3VzRHJhZ29uLFxuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRVbnNlcmlhbGl6ZWRUcmFuc2FjdGlvbih0eE1ldGEpIHtcbiAgY29uc3QgdHhQYXJhbXMgPSBidWlsZFR4UGFyYW1zKHR4TWV0YSk7XG4gIGNvbnN0IGNvbW1vbiA9IGJ1aWxkVHJhbnNhY3Rpb25Db21tb24odHhNZXRhKTtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uRmFjdG9yeS5mcm9tVHhEYXRhKHR4UGFyYW1zLCB7IGNvbW1vbiB9KTtcbn1cbiIsImltcG9ydCB7IENvbnRyYWN0IH0gZnJvbSAnQGV0aGVyc3Byb2plY3QvY29udHJhY3RzJztcbmltcG9ydCB7IFdlYjNQcm92aWRlciB9IGZyb20gJ0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycyc7XG5pbXBvcnQgYnVpbGRVbnNlcmlhbGl6ZWRUcmFuc2FjdGlvbiBmcm9tICcuL2J1aWxkVW5zZXJpYWxpemVkVHJhbnNhY3Rpb24nO1xuXG4vLyBTbmlwcGV0IG9mIHRoZSBBQkkgdGhhdCB3ZSBuZWVkXG4vLyBTaG91bGQgd2UgbmVlZCBtb3JlIG9mIGl0IGF0IHNvbWUgcG9pbnQsIHRoZSBmdWxsIEFCSSBjYW4gYmUgZm91bmQgaGVyZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS1vcHRpbWlzbS9vcHRpbWlzbS9ibG9iL2RldmVsb3AvZ2FzLW9yYWNsZS9hYmlzL09WTV9HYXNQcmljZU9yYWNsZS5qc29uXG5jb25zdCBPUFRJTUlTTV9HQVNfUFJJQ0VfT1JBQ0xFX0FCSSA9IFtcbiAge1xuICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiAnYnl0ZXMnLCBuYW1lOiAnX2RhdGEnLCB0eXBlOiAnYnl0ZXMnIH1dLFxuICAgIG5hbWU6ICdnZXRMMUZlZScsXG4gICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiAndWludDI1NicsIG5hbWU6ICcnLCB0eXBlOiAndWludDI1NicgfV0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgfSxcbl07XG5cbi8vIEJsb2NrRXhwbG9yZXIgbGluazogaHR0cHM6Ly9vcHRpbWlzdGljLmV0aGVyc2Nhbi5pby9hZGRyZXNzLzB4NDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZiNjb2RlXG5jb25zdCBPUFRJTUlTTV9HQVNfUFJJQ0VfT1JBQ0xFX0FERFJFU1MgPVxuICAnMHg0MjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBGJztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hFc3RpbWF0ZWRMMUZlZShcbiAgY2hhaW5JZCxcbiAgdHhNZXRhLFxuICBldGhlcnNQcm92aWRlcixcbikge1xuICBjb25zdCBuZXR3b3JrSWQgPSBOdW1iZXIoY2hhaW5JZCk7XG4gIGNvbnN0IHByb3ZpZGVyID0gZ2xvYmFsLmV0aGVyZXVtUHJvdmlkZXJcbiAgICA/IG5ldyBXZWIzUHJvdmlkZXIoZ2xvYmFsLmV0aGVyZXVtUHJvdmlkZXIsIG5ldHdvcmtJZClcbiAgICA6IGV0aGVyc1Byb3ZpZGVyO1xuXG4gIGlmIChwcm9jZXNzLmVudi5JTl9URVNUKSB7XG4gICAgcHJvdmlkZXIuZGV0ZWN0TmV0d29yayA9IGFzeW5jICgpID0+ICh7XG4gICAgICBuYW1lOiAnb3B0aW1pc20nLFxuICAgICAgY2hhaW5JZDogbmV0d29ya0lkLFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KFxuICAgIE9QVElNSVNNX0dBU19QUklDRV9PUkFDTEVfQUREUkVTUyxcbiAgICBPUFRJTUlTTV9HQVNfUFJJQ0VfT1JBQ0xFX0FCSSxcbiAgICBwcm92aWRlcixcbiAgKTtcbiAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uID1cbiAgICBidWlsZFVuc2VyaWFsaXplZFRyYW5zYWN0aW9uKHR4TWV0YSkuc2VyaWFsaXplKCk7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbnRyYWN0LmdldEwxRmVlKHNlcmlhbGl6ZWRUcmFuc2FjdGlvbik7XG4gIHJldHVybiByZXN1bHQ/LnRvSGV4U3RyaW5nKCk7XG59XG4iLCJpbXBvcnQgcHVueWNvZGUgZnJvbSAncHVueWNvZGUvcHVueWNvZGUnO1xuaW1wb3J0IGFiaSBmcm9tICdodW1hbi1zdGFuZGFyZC10b2tlbi1hYmknO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0ICogYXMgZXRoVXRpbCBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xuaW1wb3J0IHsgRGF0ZVRpbWUgfSBmcm9tICdsdXhvbic7XG5pbXBvcnQgeyBnZXRGb3JtYXR0ZWRJcGZzVXJsIH0gZnJvbSAnQG1ldGFtYXNrL2Fzc2V0cy1jb250cm9sbGVycyc7XG5pbXBvcnQgc2xpcDQ0IGZyb20gJ0BtZXRhbWFzay9zbGlwNDQnO1xuaW1wb3J0ICogYXMgbG9kYXNoIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgYm93c2VyIGZyb20gJ2Jvd3Nlcic7XG5pbXBvcnQgeyBDSEFJTl9JRFMsIE5FVFdPUktfVFlQRVMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xuaW1wb3J0IHtcbiAgdG9DaGVja3N1bUhleEFkZHJlc3MsXG4gIHN0cmlwSGV4UHJlZml4LFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9oZXhzdHJpbmctdXRpbHMnO1xuaW1wb3J0IHtcbiAgVFJVTkNBVEVEX0FERFJFU1NfU1RBUlRfQ0hBUlMsXG4gIFRSVU5DQVRFRF9OQU1FX0NIQVJfTElNSVQsXG4gIFRSVU5DQVRFRF9BRERSRVNTX0VORF9DSEFSUyxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9sYWJlbHMnO1xuaW1wb3J0IHsgTnVtZXJpYyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL051bWVyaWMnO1xuaW1wb3J0IHsgT1VUREFURURfQlJPV1NFUl9WRVJTSU9OUyB9IGZyb20gJy4uL2NvbnN0YW50cy9jb21tb24nO1xuXG4vLyBmb3JtYXREYXRhIDo6ICggZGF0ZTogPFVuaXggVGltZXN0YW1wPiApIC0+IFN0cmluZ1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0ID0gXCJNL2QveSAnYXQnIFRcIikge1xuICBpZiAoIWRhdGUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIERhdGVUaW1lLmZyb21NaWxsaXMoZGF0ZSkudG9Gb3JtYXQoZm9ybWF0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGVXaXRoWWVhckNvbnRleHQoXG4gIGRhdGUsXG4gIGZvcm1hdFRoaXNZZWFyID0gJ01NTSBkJyxcbiAgZmFsbGJhY2sgPSAnTU1NIGQsIHknLFxuKSB7XG4gIGlmICghZGF0ZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCBkYXRlVGltZSA9IERhdGVUaW1lLmZyb21NaWxsaXMoZGF0ZSk7XG4gIGNvbnN0IG5vdyA9IERhdGVUaW1lLmxvY2FsKCk7XG4gIHJldHVybiBkYXRlVGltZS50b0Zvcm1hdChcbiAgICBub3cueWVhciA9PT0gZGF0ZVRpbWUueWVhciA/IGZvcm1hdFRoaXNZZWFyIDogZmFsbGJhY2ssXG4gICk7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHByb3ZpZGVkIGNoYWluSWQgaXMgYSBkZWZhdWx0IE1ldGFNYXNrIGNoYWluXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNoYWluSWQgLSBjaGFpbklkIHRvIGNoZWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZmF1bHRNZXRhTWFza0NoYWluKGNoYWluSWQpIHtcbiAgaWYgKFxuICAgICFjaGFpbklkIHx8XG4gICAgY2hhaW5JZCA9PT0gQ0hBSU5fSURTLk1BSU5ORVQgfHxcbiAgICBjaGFpbklkID09PSBDSEFJTl9JRFMuR09FUkxJIHx8XG4gICAgY2hhaW5JZCA9PT0gQ0hBSU5fSURTLlNFUE9MSUEgfHxcbiAgICBjaGFpbklkID09PSBDSEFJTl9JRFMuTElORUFfVEVTVE5FVCB8fFxuICAgIGNoYWluSWQgPT09IENIQUlOX0lEUy5MT0NBTEhPU1RcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWx1ZXNGb3Iob2JqKSB7XG4gIGlmICghb2JqKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZHJlc3NTdW1tYXJ5KFxuICBhZGRyZXNzLFxuICBmaXJzdFNlZ0xlbmd0aCA9IDEwLFxuICBsYXN0U2VnTGVuZ3RoID0gNCxcbiAgaW5jbHVkZUhleCA9IHRydWUsXG4pIHtcbiAgaWYgKCFhZGRyZXNzKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGxldCBjaGVja2VkID0gdG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzcyk7XG4gIGlmICghaW5jbHVkZUhleCkge1xuICAgIGNoZWNrZWQgPSBzdHJpcEhleFByZWZpeChjaGVja2VkKTtcbiAgfVxuICByZXR1cm4gY2hlY2tlZFxuICAgID8gYCR7Y2hlY2tlZC5zbGljZSgwLCBmaXJzdFNlZ0xlbmd0aCl9Li4uJHtjaGVja2VkLnNsaWNlKFxuICAgICAgICBjaGVja2VkLmxlbmd0aCAtIGxhc3RTZWdMZW5ndGgsXG4gICAgICApfWBcbiAgICA6ICcuLi4nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZERvbWFpbk5hbWUoYWRkcmVzcykge1xuICBjb25zdCBtYXRjaCA9IHB1bnljb2RlXG4gICAgLnRvQVNDSUkoYWRkcmVzcylcbiAgICAudG9Mb3dlckNhc2UoKVxuICAgIC8vIENoZWNrcyB0aGF0IHRoZSBkb21haW4gY29uc2lzdHMgb2YgYXQgbGVhc3Qgb25lIHZhbGlkIGRvbWFpbiBwaWVjZXMgc2VwYXJhdGVkIGJ5IHBlcmlvZHMsIGZvbGxvd2VkIGJ5IGEgdGxkXG4gICAgLy8gRWFjaCBwaWVjZSBvZiBkb21haW4gbmFtZSBoYXMgb25seSB0aGUgY2hhcmFjdGVycyBhLXosIDAtOSwgYW5kIGEgaHlwaGVuIChidXQgbm90IGF0IHRoZSBzdGFydCBvciBlbmQgb2YgY2h1bmspXG4gICAgLy8gQSBjaHVuayBoYXMgbWluaW11bSBsZW5ndGggb2YgMSwgYnV0IG1pbmltdW0gdGxkIGlzIHNldCB0byAyIGZvciBub3cgKG5vIDEtY2hhcmFjdGVyIHRsZHMgZXhpc3QgeWV0KVxuICAgIC5tYXRjaChcbiAgICAgIC9eKD86W2EtejAtOV0oPzpbLWEtejAtOV0qW2EtejAtOV0pP1xcLikrW2EtejAtOV1bLWEtejAtOV0qW2EtejAtOV0kL3UsXG4gICAgKTtcbiAgcmV0dXJuIG1hdGNoICE9PSBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNPcmlnaW5Db250cmFjdEFkZHJlc3ModG8sIHNlbmRUb2tlbkFkZHJlc3MpIHtcbiAgaWYgKCF0byB8fCAhc2VuZFRva2VuQWRkcmVzcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdG8udG9Mb3dlckNhc2UoKSA9PT0gc2VuZFRva2VuQWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xufVxuXG4vLyBUYWtlcyB3ZWkgSGV4LCByZXR1cm5zIHdlaSBCTiwgZXZlbiBpZiBpbnB1dCBpcyBudWxsXG5leHBvcnQgZnVuY3Rpb24gbnVtZXJpY0JhbGFuY2UoYmFsYW5jZSkge1xuICBpZiAoIWJhbGFuY2UpIHtcbiAgICByZXR1cm4gbmV3IGV0aFV0aWwuQk4oMCwgMTYpO1xuICB9XG4gIGNvbnN0IHN0cmlwcGVkID0gc3RyaXBIZXhQcmVmaXgoYmFsYW5jZSk7XG4gIHJldHVybiBuZXcgZXRoVXRpbC5CTihzdHJpcHBlZCwgMTYpO1xufVxuXG4vLyBUYWtlcyAgaGV4LCByZXR1cm5zIFtiZWZvcmVEZWNpbWFsLCBhZnRlckRlY2ltYWxdXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VCYWxhbmNlKGJhbGFuY2UpIHtcbiAgbGV0IGFmdGVyRGVjaW1hbDtcbiAgY29uc3Qgd2VpID0gbnVtZXJpY0JhbGFuY2UoYmFsYW5jZSk7XG4gIGNvbnN0IHdlaVN0cmluZyA9IHdlaS50b1N0cmluZygpO1xuICBjb25zdCB0cmFpbGluZ1plcm9zID0gLzArJC91O1xuXG4gIGNvbnN0IGJlZm9yZURlY2ltYWwgPVxuICAgIHdlaVN0cmluZy5sZW5ndGggPiAxOCA/IHdlaVN0cmluZy5zbGljZSgwLCB3ZWlTdHJpbmcubGVuZ3RoIC0gMTgpIDogJzAnO1xuICBhZnRlckRlY2ltYWwgPSBgMDAwMDAwMDAwMDAwMDAwMDAwJHt3ZWl9YFxuICAgIC5zbGljZSgtMTgpXG4gICAgLnJlcGxhY2UodHJhaWxpbmdaZXJvcywgJycpO1xuICBpZiAoYWZ0ZXJEZWNpbWFsID09PSAnJykge1xuICAgIGFmdGVyRGVjaW1hbCA9ICcwJztcbiAgfVxuICByZXR1cm4gW2JlZm9yZURlY2ltYWwsIGFmdGVyRGVjaW1hbF07XG59XG5cbi8vIFRha2VzIHdlaSBoZXgsIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhyZWUgcHJvcGVydGllcy5cbi8vIEl0cyBcImZvcm1hdHRlZFwiIHByb3BlcnR5IGlzIHdoYXQgd2UgZ2VuZXJhbGx5IHVzZSB0byByZW5kZXIgdmFsdWVzLlxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEJhbGFuY2UoXG4gIGJhbGFuY2UsXG4gIGRlY2ltYWxzVG9LZWVwLFxuICBuZWVkc1BhcnNlID0gdHJ1ZSxcbiAgdGlja2VyID0gJ0VUSCcsXG4pIHtcbiAgY29uc3QgcGFyc2VkID0gbmVlZHNQYXJzZSA/IHBhcnNlQmFsYW5jZShiYWxhbmNlKSA6IGJhbGFuY2Uuc3BsaXQoJy4nKTtcbiAgY29uc3QgYmVmb3JlRGVjaW1hbCA9IHBhcnNlZFswXTtcbiAgbGV0IGFmdGVyRGVjaW1hbCA9IHBhcnNlZFsxXTtcbiAgbGV0IGZvcm1hdHRlZCA9ICdOb25lJztcbiAgaWYgKGRlY2ltYWxzVG9LZWVwID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoYmVmb3JlRGVjaW1hbCA9PT0gJzAnKSB7XG4gICAgICBpZiAoYWZ0ZXJEZWNpbWFsICE9PSAnMCcpIHtcbiAgICAgICAgY29uc3Qgc2lnRmlncyA9IGFmdGVyRGVjaW1hbC5tYXRjaCgvXjAqKC57Mn0pL3UpOyAvLyBkZWZhdWx0OiBncmFicyAyIG1vc3Qgc2lnbmlmaWNhbnQgZGlnaXRzXG4gICAgICAgIGlmIChzaWdGaWdzKSB7XG4gICAgICAgICAgYWZ0ZXJEZWNpbWFsID0gc2lnRmlnc1swXTtcbiAgICAgICAgfVxuICAgICAgICBmb3JtYXR0ZWQgPSBgMC4ke2FmdGVyRGVjaW1hbH0gJHt0aWNrZXJ9YDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9ybWF0dGVkID0gYCR7YmVmb3JlRGVjaW1hbH0uJHthZnRlckRlY2ltYWwuc2xpY2UoMCwgMyl9ICR7dGlja2VyfWA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFmdGVyRGVjaW1hbCArPSBBcnJheShkZWNpbWFsc1RvS2VlcCkuam9pbignMCcpO1xuICAgIGZvcm1hdHRlZCA9IGAke2JlZm9yZURlY2ltYWx9LiR7YWZ0ZXJEZWNpbWFsLnNsaWNlKFxuICAgICAgMCxcbiAgICAgIGRlY2ltYWxzVG9LZWVwLFxuICAgICl9ICR7dGlja2VyfWA7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdHRlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRyYWN0QXRBZGRyZXNzKHRva2VuQWRkcmVzcykge1xuICByZXR1cm4gZ2xvYmFsLmV0aC5jb250cmFjdChhYmkpLmF0KHRva2VuQWRkcmVzcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5kb21GaWxlTmFtZSgpIHtcbiAgbGV0IGZpbGVOYW1lID0gJyc7XG4gIGNvbnN0IGNoYXJCYW5rID0gW1xuICAgIC4uLidhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMDEyMzQ1Njc4OScsXG4gIF07XG4gIGNvbnN0IGZpbGVOYW1lTGVuZ3RoID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNyArIDYpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZU5hbWVMZW5ndGg7IGkrKykge1xuICAgIGZpbGVOYW1lICs9IGNoYXJCYW5rW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJCYW5rLmxlbmd0aCldO1xuICB9XG5cbiAgcmV0dXJuIGZpbGVOYW1lO1xufVxuXG4vKipcbiAqIFNob3J0ZW5zIGFuIEV0aGVyZXVtIGFkZHJlc3MgZm9yIGRpc3BsYXksIHByZXNlcnZpbmcgdGhlIGJlZ2lubmluZyBhbmQgZW5kLlxuICogUmV0dXJucyB0aGUgZ2l2ZW4gYWRkcmVzcyBpZiBpdCBpcyBubyBsb25nZXIgdGhhbiAxMCBjaGFyYWN0ZXJzLlxuICogU2hvcnRlbmVkIGFkZHJlc3NlcyBhcmUgMTMgY2hhcmFjdGVycyBsb25nLlxuICpcbiAqIEV4YW1wbGUgb3V0cHV0OiAweGFiY2QuLi4xMjM0XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgYWRkcmVzcyB0byBzaG9ydGVuLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHNob3J0ZW5lZCBhZGRyZXNzLCBvciB0aGUgb3JpZ2luYWwgaWYgaXQgd2FzIG5vIGxvbmdlclxuICogdGhhbiAxMCBjaGFyYWN0ZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hvcnRlbkFkZHJlc3MoYWRkcmVzcyA9ICcnKSB7XG4gIGlmIChhZGRyZXNzLmxlbmd0aCA8IFRSVU5DQVRFRF9OQU1FX0NIQVJfTElNSVQpIHtcbiAgICByZXR1cm4gYWRkcmVzcztcbiAgfVxuXG4gIHJldHVybiBgJHthZGRyZXNzLnNsaWNlKDAsIFRSVU5DQVRFRF9BRERSRVNTX1NUQVJUX0NIQVJTKX0uLi4ke2FkZHJlc3Muc2xpY2UoXG4gICAgLVRSVU5DQVRFRF9BRERSRVNTX0VORF9DSEFSUyxcbiAgKX1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWNjb3VudEJ5QWRkcmVzcyhhY2NvdW50cyA9IFtdLCB0YXJnZXRBZGRyZXNzKSB7XG4gIHJldHVybiBhY2NvdW50cy5maW5kKCh7IGFkZHJlc3MgfSkgPT4gYWRkcmVzcyA9PT0gdGFyZ2V0QWRkcmVzcyk7XG59XG5cbi8qKlxuICogU3RyaXBzIHRoZSBmb2xsb3dpbmcgc2NoZW1lcyBmcm9tIFVSTCBzdHJpbmdzOlxuICogLSBodHRwXG4gKiAtIGh0dHBzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFN0cmluZyAtIFRoZSBVUkwgc3RyaW5nIHRvIHN0cmlwIHRoZSBzY2hlbWUgZnJvbS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBVUkwgc3RyaW5nLCB3aXRob3V0IHRoZSBzY2hlbWUsIGlmIGl0IHdhcyBzdHJpcHBlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwSHR0cFNjaGVtZXModXJsU3RyaW5nKSB7XG4gIHJldHVybiB1cmxTdHJpbmcucmVwbGFjZSgvXmh0dHBzPzpcXC9cXC8vdSwgJycpO1xufVxuXG4vKipcbiAqIFN0cmlwcyB0aGUgZm9sbG93aW5nIHNjaGVtZXMgZnJvbSBVUkwgc3RyaW5nczpcbiAqIC0gaHR0cHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsU3RyaW5nIC0gVGhlIFVSTCBzdHJpbmcgdG8gc3RyaXAgdGhlIHNjaGVtZSBmcm9tLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIFVSTCBzdHJpbmcsIHdpdGhvdXQgdGhlIHNjaGVtZSwgaWYgaXQgd2FzIHN0cmlwcGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBIdHRwc1NjaGVtZSh1cmxTdHJpbmcpIHtcbiAgcmV0dXJuIHVybFN0cmluZy5yZXBsYWNlKC9eaHR0cHM6XFwvXFwvL3UsICcnKTtcbn1cblxuLyoqXG4gKiBTdHJpcHMgYGh0dHBzYCBzY2hlbWVzIGZyb20gVVJMIHN0cmluZ3MsIGlmIHRoZSBVUkwgZG9lcyBub3QgaGF2ZSBhIHBvcnQuXG4gKiBUaGlzIGlzIHVzZWZ1bFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxTdHJpbmcgLSBUaGUgVVJMIHN0cmluZyB0byBzdHJpcCB0aGUgc2NoZW1lIGZyb20uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgVVJMIHN0cmluZywgd2l0aG91dCB0aGUgc2NoZW1lLCBpZiBpdCB3YXMgc3RyaXBwZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcEh0dHBzU2NoZW1lV2l0aG91dFBvcnQodXJsU3RyaW5nKSB7XG4gIGlmIChnZXRVUkwodXJsU3RyaW5nKS5wb3J0KSB7XG4gICAgcmV0dXJuIHVybFN0cmluZztcbiAgfVxuXG4gIHJldHVybiBzdHJpcEh0dHBzU2NoZW1lKHVybFN0cmluZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBVUkwtbGlrZSB2YWx1ZSAob2JqZWN0IG9yIHN0cmluZykgaXMgYW4gZXh0ZW5zaW9uIFVSTC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZyB8IFVSTCB8IG9iamVjdH0gdXJsTGlrZSAtIFRoZSBVUkwtbGlrZSB2YWx1ZSB0byB0ZXN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIFVSTC1saWtlIHZhbHVlIGlzIGFuIGV4dGVuc2lvbiBVUkwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0V4dGVuc2lvblVybCh1cmxMaWtlKSB7XG4gIGNvbnN0IEVYVF9QUk9UT0NPTFMgPSBbJ2Nocm9tZS1leHRlbnNpb246JywgJ21vei1leHRlbnNpb246J107XG5cbiAgaWYgKHR5cGVvZiB1cmxMaWtlID09PSAnc3RyaW5nJykge1xuICAgIGZvciAoY29uc3QgcHJvdG9jb2wgb2YgRVhUX1BST1RPQ09MUykge1xuICAgICAgaWYgKHVybExpa2Uuc3RhcnRzV2l0aChwcm90b2NvbCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHVybExpa2U/LnByb3RvY29sKSB7XG4gICAgcmV0dXJuIEVYVF9QUk9UT0NPTFMuaW5jbHVkZXModXJsTGlrZS5wcm90b2NvbCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGFuIGFkZHJlc3MgaXMgaW4gYSBwYXNzZWQgbGlzdCBvZiBvYmplY3RzIHdpdGggYWRkcmVzcyBwcm9wZXJ0aWVzLiBUaGUgY2hlY2sgaXMgcGVyZm9ybWVkIG9uIHRoZVxuICogbG93ZXJjYXNlZCB2ZXJzaW9uIG9mIHRoZSBhZGRyZXNzZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgaGV4IGFkZHJlc3MgdG8gY2hlY2tcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgLSBUaGUgYXJyYXkgb2Ygb2JqZWN0cyB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBhZGRyZXNzIGlzIGluIHRoZSBsaXN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0V4aXN0aW5nQWRkcmVzc2VzKGFkZHJlc3MsIGxpc3QgPSBbXSkge1xuICBpZiAoIWFkZHJlc3MpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBtYXRjaGVzQWRkcmVzcyA9IChvYmopID0+IHtcbiAgICByZXR1cm4gb2JqLmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICB9O1xuXG4gIHJldHVybiBsaXN0LnNvbWUobWF0Y2hlc0FkZHJlc3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYm5HcmVhdGVyVGhhbihhLCBiKSB7XG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBuZXcgQmlnTnVtYmVyKGEsIDEwKS5ndChiLCAxMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBibkxlc3NUaGFuKGEsIGIpIHtcbiAgaWYgKGEgPT09IG51bGwgfHwgYSA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwgfHwgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoYSwgMTApLmx0KGIsIDEwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJuR3JlYXRlclRoYW5FcXVhbFRvKGEsIGIpIHtcbiAgaWYgKGEgPT09IG51bGwgfHwgYSA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwgfHwgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoYSwgMTApLmd0ZShiLCAxMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBibkxlc3NUaGFuRXF1YWxUbyhhLCBiKSB7XG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBuZXcgQmlnTnVtYmVyKGEsIDEwKS5sdGUoYiwgMTApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VVJMKHVybCkge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgVVJMKHVybCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SXNCcm93c2VyRGVwcmVjYXRlZChcbiAgYnJvd3NlciA9IGJvd3Nlci5nZXRQYXJzZXIod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpLFxuKSB7XG4gIHJldHVybiBicm93c2VyLnNhdGlzZmllcyhPVVREQVRFRF9CUk9XU0VSX1ZFUlNJT05TKSA/PyBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVSTEhvc3QodXJsKSB7XG4gIHJldHVybiBnZXRVUkwodXJsKT8uaG9zdCB8fCAnJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVSTEhvc3ROYW1lKHVybCkge1xuICByZXR1cm4gZ2V0VVJMKHVybCk/Lmhvc3RuYW1lIHx8ICcnO1xufVxuXG4vLyBPbmNlIHdlIHJlYWNoIHRoaXMgdGhyZXNob2xkLCB3ZSBzd2l0Y2ggdG8gaGlnaGVyIHVuaXRcbmNvbnN0IE1JTlVURV9DVVRPRkYgPSA5MCAqIDYwO1xuY29uc3QgU0VDT05EX0NVVE9GRiA9IDkwO1xuXG5leHBvcnQgY29uc3QgdG9IdW1hblJlYWRhYmxlVGltZSA9ICh0LCBtaWxsaXNlY29uZHMpID0+IHtcbiAgaWYgKG1pbGxpc2Vjb25kcyA9PT0gdW5kZWZpbmVkIHx8IG1pbGxpc2Vjb25kcyA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCBzZWNvbmRzID0gTWF0aC5jZWlsKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICBpZiAoc2Vjb25kcyA8PSBTRUNPTkRfQ1VUT0ZGKSB7XG4gICAgcmV0dXJuIHQoJ2dhc1RpbWluZ1NlY29uZHNTaG9ydCcsIFtzZWNvbmRzXSk7XG4gIH1cbiAgaWYgKHNlY29uZHMgPD0gTUlOVVRFX0NVVE9GRikge1xuICAgIHJldHVybiB0KCdnYXNUaW1pbmdNaW51dGVzU2hvcnQnLCBbTWF0aC5jZWlsKHNlY29uZHMgLyA2MCldKTtcbiAgfVxuICByZXR1cm4gdCgnZ2FzVGltaW5nSG91cnNTaG9ydCcsIFtNYXRoLmNlaWwoc2Vjb25kcyAvIDM2MDApXSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJDbGlwYm9hcmQoKSB7XG4gIHdpbmRvdy5uYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCgnJyk7XG59XG5cbmNvbnN0IHNvbGlkaXR5VHlwZXMgPSAoKSA9PiB7XG4gIGNvbnN0IHR5cGVzID0gW1xuICAgICdib29sJyxcbiAgICAnYWRkcmVzcycsXG4gICAgJ3N0cmluZycsXG4gICAgJ2J5dGVzJyxcbiAgICAnaW50JyxcbiAgICAndWludCcsXG4gICAgJ2ZpeGVkJyxcbiAgICAndWZpeGVkJyxcbiAgXTtcblxuICBjb25zdCBpbnRzID0gQXJyYXkuZnJvbShuZXcgQXJyYXkoMzIpKS5tYXAoXG4gICAgKF8sIGluZGV4KSA9PiBgaW50JHsoaW5kZXggKyAxKSAqIDh9YCxcbiAgKTtcbiAgY29uc3QgdWludHMgPSBBcnJheS5mcm9tKG5ldyBBcnJheSgzMikpLm1hcChcbiAgICAoXywgaW5kZXgpID0+IGB1aW50JHsoaW5kZXggKyAxKSAqIDh9YCxcbiAgKTtcbiAgY29uc3QgYnl0ZXMgPSBBcnJheS5mcm9tKG5ldyBBcnJheSgzMikpLm1hcChcbiAgICAoXywgaW5kZXgpID0+IGBieXRlcyR7aW5kZXggKyAxfWAsXG4gICk7XG5cbiAgLyoqXG4gICAqIGZpeGVkIGFuZCB1Zml4ZWRcbiAgICogVGhpcyB2YWx1ZSB0eXBlIGFsc28gY2FuIGJlIGRlY2xhcmVkIGtleXdvcmRzIHN1Y2ggYXMgdWZpeGVkTXhOIGFuZCBmaXhlZE14Ti5cbiAgICogVGhlIE0gcmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIGJpdHMgdGhhdCB0aGUgdHlwZSB0YWtlcyxcbiAgICogd2l0aCBOIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzIHRoYXQgYXJlIGF2YWlsYWJsZS5cbiAgICogIE0gaGFzIHRvIGJlIGRpdmlzaWJsZSBieSA4LCBhbmQgYSBudW1iZXIgZnJvbSA4IHRvIDI1Ni5cbiAgICogTiBoYXMgdG8gYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDgwLCBhbHNvIGJlaW5nIGluY2x1c2l2ZS5cbiAgICovXG4gIGNvbnN0IGZpeGVkTSA9IEFycmF5LmZyb20obmV3IEFycmF5KDMyKSkubWFwKFxuICAgIChfLCBpbmRleCkgPT4gYGZpeGVkJHsoaW5kZXggKyAxKSAqIDh9YCxcbiAgKTtcbiAgY29uc3QgdWZpeGVkTSA9IEFycmF5LmZyb20obmV3IEFycmF5KDMyKSkubWFwKFxuICAgIChfLCBpbmRleCkgPT4gYHVmaXhlZCR7KGluZGV4ICsgMSkgKiA4fWAsXG4gICk7XG4gIGNvbnN0IGZpeGVkID0gQXJyYXkuZnJvbShuZXcgQXJyYXkoODApKS5tYXAoKF8sIGluZGV4KSA9PlxuICAgIGZpeGVkTS5tYXAoKGFGaXhlZE0pID0+IGAke2FGaXhlZE19eCR7aW5kZXggKyAxfWApLFxuICApO1xuICBjb25zdCB1Zml4ZWQgPSBBcnJheS5mcm9tKG5ldyBBcnJheSg4MCkpLm1hcCgoXywgaW5kZXgpID0+XG4gICAgdWZpeGVkTS5tYXAoKGF1Rml4ZWRNKSA9PiBgJHthdUZpeGVkTX14JHtpbmRleCArIDF9YCksXG4gICk7XG5cbiAgcmV0dXJuIFtcbiAgICAuLi50eXBlcyxcbiAgICAuLi5pbnRzLFxuICAgIC4uLnVpbnRzLFxuICAgIC4uLmJ5dGVzLFxuICAgIC4uLmZpeGVkLmZsYXQoKSxcbiAgICAuLi51Zml4ZWQuZmxhdCgpLFxuICBdO1xufTtcblxuY29uc3QgU09MSURJVFlfVFlQRVMgPSBzb2xpZGl0eVR5cGVzKCk7XG5cbmNvbnN0IHN0cmlwQXJyYXlUeXBlID0gKHBvdGVudGlhbEFycmF5VHlwZSkgPT5cbiAgcG90ZW50aWFsQXJyYXlUeXBlLnJlcGxhY2UoL1xcW1tbMC05XSpcXF0qL2d1LCAnJyk7XG5cbmNvbnN0IHN0cmlwT25lTGF5ZXJvZk5lc3RpbmcgPSAocG90ZW50aWFsQXJyYXlUeXBlKSA9PlxuICBwb3RlbnRpYWxBcnJheVR5cGUucmVwbGFjZSgvXFxbW1swLTldKlxcXS91LCAnJyk7XG5cbmNvbnN0IGlzQXJyYXlUeXBlID0gKHBvdGVudGlhbEFycmF5VHlwZSkgPT5cbiAgcG90ZW50aWFsQXJyYXlUeXBlLm1hdGNoKC9cXFtbWzAtOV0qXFxdKi91KSAhPT0gbnVsbDtcblxuY29uc3QgaXNTb2xpZGl0eVR5cGUgPSAodHlwZSkgPT4gU09MSURJVFlfVFlQRVMuaW5jbHVkZXModHlwZSk7XG5cbmV4cG9ydCBjb25zdCBzYW5pdGl6ZU1lc3NhZ2UgPSAobXNnLCBwcmltYXJ5VHlwZSwgdHlwZXMpID0+IHtcbiAgaWYgKCF0eXBlcykge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0eXBlcyBkZWZpbml0aW9uYCk7XG4gIH1cblxuICAvLyBQcmltYXJ5IHR5cGUgY2FuIGJlIGFuIGFycmF5LlxuICBjb25zdCBpc0FycmF5ID0gcHJpbWFyeVR5cGUgJiYgaXNBcnJheVR5cGUocHJpbWFyeVR5cGUpO1xuICBpZiAoaXNBcnJheSkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogbXNnLm1hcCgodmFsdWUpID0+XG4gICAgICAgIHNhbml0aXplTWVzc2FnZSh2YWx1ZSwgc3RyaXBPbmVMYXllcm9mTmVzdGluZyhwcmltYXJ5VHlwZSksIHR5cGVzKSxcbiAgICAgICksXG4gICAgICB0eXBlOiBwcmltYXJ5VHlwZSxcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzU29saWRpdHlUeXBlKHByaW1hcnlUeXBlKSkge1xuICAgIHJldHVybiB7IHZhbHVlOiBtc2csIHR5cGU6IHByaW1hcnlUeXBlIH07XG4gIH1cblxuICAvLyBJZiBub3QsIGFzc3VtZSB0byBiZSBzdHJ1Y3RcbiAgY29uc3QgYmFzZVR5cGUgPSBpc0FycmF5ID8gc3RyaXBBcnJheVR5cGUocHJpbWFyeVR5cGUpIDogcHJpbWFyeVR5cGU7XG5cbiAgY29uc3QgYmFzZVR5cGVEZWZpbml0aW9ucyA9IHR5cGVzW2Jhc2VUeXBlXTtcbiAgaWYgKCFiYXNlVHlwZURlZmluaXRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByaW1hcnkgdHlwZSBkZWZpbml0aW9uYCk7XG4gIH1cblxuICBjb25zdCBzYW5pdGl6ZWRTdHJ1Y3QgPSB7fTtcbiAgY29uc3QgbXNnS2V5cyA9IE9iamVjdC5rZXlzKG1zZyk7XG4gIG1zZ0tleXMuZm9yRWFjaCgobXNnS2V5KSA9PiB7XG4gICAgY29uc3QgZGVmaW5lZFR5cGUgPSBPYmplY3QudmFsdWVzKGJhc2VUeXBlRGVmaW5pdGlvbnMpLmZpbmQoXG4gICAgICAoYmFzZVR5cGVEZWZpbml0aW9uKSA9PiBiYXNlVHlwZURlZmluaXRpb24ubmFtZSA9PT0gbXNnS2V5LFxuICAgICk7XG5cbiAgICBpZiAoIWRlZmluZWRUeXBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2FuaXRpemVkU3RydWN0W21zZ0tleV0gPSBzYW5pdGl6ZU1lc3NhZ2UoXG4gICAgICBtc2dbbXNnS2V5XSxcbiAgICAgIGRlZmluZWRUeXBlLnR5cGUsXG4gICAgICB0eXBlcyxcbiAgICApO1xuICB9KTtcbiAgcmV0dXJuIHsgdmFsdWU6IHNhbml0aXplZFN0cnVjdCwgdHlwZTogcHJpbWFyeVR5cGUgfTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBc3NldEltYWdlVVJMKGltYWdlLCBpcGZzR2F0ZXdheSkge1xuICBpZiAoIWltYWdlIHx8ICFpcGZzR2F0ZXdheSB8fCB0eXBlb2YgaW1hZ2UgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKGltYWdlLnN0YXJ0c1dpdGgoJ2lwZnM6Ly8nKSkge1xuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRJcGZzVXJsKGlwZnNHYXRld2F5LCBpbWFnZSwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIGltYWdlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcm91bmRUb0RlY2ltYWxQbGFjZXNSZW1vdmluZ0V4dHJhWmVyb2VzKFxuICBudW1iZXJpc2gsXG4gIG51bWJlck9mRGVjaW1hbFBsYWNlcyxcbikge1xuICBpZiAobnVtYmVyaXNoID09PSB1bmRlZmluZWQgfHwgbnVtYmVyaXNoID09PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBuZXcgTnVtZXJpYyhcbiAgICBuZXcgTnVtZXJpYyhudW1iZXJpc2gsIDEwKS50b0ZpeGVkKG51bWJlck9mRGVjaW1hbFBsYWNlcyksXG4gICAgMTAsXG4gICkudG9OdW1iZXIoKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYW1lIG9mIHRoZSBTTElQLTQ0IHByb3RvY29sIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHNwZWNpZmllZFxuICogYGNvaW5fdHlwZWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IGNvaW5UeXBlIC0gVGhlIFNMSVAtNDQgYGNvaW5fdHlwZWAgdmFsdWUgd2hvc2UgbmFtZVxuICogdG8gcmV0cmlldmUuXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSBUaGUgbmFtZSBvZiB0aGUgcHJvdG9jb2wgaWYgZm91bmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2luVHlwZVRvUHJvdG9jb2xOYW1lKGNvaW5UeXBlKSB7XG4gIGlmIChTdHJpbmcoY29pblR5cGUpID09PSAnMScpIHtcbiAgICByZXR1cm4gJ1Rlc3QgTmV0d29ya3MnO1xuICB9XG4gIHJldHVybiBzbGlwNDRbY29pblR5cGVdPy5uYW1lIHx8IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBUZXN0cyBcIm51bGxpc2huZXNzXCIuIFVzZWQgdG8gZ3VhcmQgYSBzZWN0aW9uIG9mIGEgY29tcG9uZW50IGZyb20gYmVpbmdcbiAqIHJlbmRlcmVkIGJhc2VkIG9uIGEgdmFsdWUuXG4gKlxuICogQHBhcmFtIHthbnl9IHZhbHVlIC0gQSB2YWx1ZSAobGl0ZXJhbGx5IGFueXRoaW5nKS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOdWxsaXNoKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5cbi8qKlxuICogVGhlIG1ldGhvZCBlc2NhcGUgUlRMIGNoYXJhY3RlciBpbiBzdHJpbmdcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJucyB7KHN0cmluZ3wqKX0gZXNjYXBlZCBzdHJpbmcgb3Igb3JpZ2luYWwgcGFyYW0gdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IHNhbml0aXplU3RyaW5nID0gKHZhbHVlKSA9PiB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKCFsb2Rhc2guaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGNvbnN0IHJlZ2V4ID0gL1xcdTIwMkUvZ2l1O1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZWdleCwgJ1xcXFx1MjAyRScpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjaGVja3MgY3VycmVudCBwcm92aWRlciB0eXBlIGFuZCByZXR1cm5zIGl0cyBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0geyp9IHByb3ZpZGVyXG4gKiBAcGFyYW0geyp9IHRcbiAqIEByZXR1cm5zXG4gKi9cblxuZXhwb3J0IGNvbnN0IGdldE5ldHdvcmtOYW1lRnJvbVByb3ZpZGVyVHlwZSA9IChwcm92aWRlck5hbWUpID0+IHtcbiAgaWYgKHByb3ZpZGVyTmFtZSA9PT0gTkVUV09SS19UWVBFUy5SUEMpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHByb3ZpZGVyTmFtZTtcbn07XG4iXSwicHJlRXhpc3RpbmdDb21tZW50IjoiLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguY2pzLm1hcCJ9
