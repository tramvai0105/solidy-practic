LavaPack.loadBundle([
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\ipV4Extended.js", {"./_internals/builders/StringifiedNatArbitraryBuilder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\StringifiedNatArbitraryBuilder.js","./oneof":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\oneof.js","./tuple":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\tuple.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CipV4Extended.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ipV4Extended = void 0;
const oneof_1 = require("./oneof");
const tuple_1 = require("./tuple");
const StringifiedNatArbitraryBuilder_1 = require("./_internals/builders/StringifiedNatArbitraryBuilder");
function dotJoinerMapper(data) {
    return data.join('.');
}
function dotJoinerUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Invalid type');
    }
    return value.split('.');
}
function ipV4Extended() {
    return (0, oneof_1.oneof)((0, tuple_1.tuple)((0, StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary)(255), (0, StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary)(255), (0, StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary)(255), (0, StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary)(255)).map(dotJoinerMapper, dotJoinerUnmapper), (0, tuple_1.tuple)((0, StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary)(255), (0, StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary)(255), (0, StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary)(65535)).map(dotJoinerMapper, dotJoinerUnmapper), (0, tuple_1.tuple)((0, StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary)(255), (0, StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary)(16777215)).map(dotJoinerMapper, dotJoinerUnmapper), (0, StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary)(4294967295));
}
exports.ipV4Extended = ipV4Extended;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\ipV4Extended.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\ipV6.js", {"./_internals/mappers/EntitiesToIPv6":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\mappers\\EntitiesToIPv6.js","./array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\array.js","./hexaString":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\hexaString.js","./ipV4":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\ipV4.js","./oneof":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\oneof.js","./tuple":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\tuple.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CipV6.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ipV6 = void 0;
const array_1 = require("./array");
const oneof_1 = require("./oneof");
const hexaString_1 = require("./hexaString");
const tuple_1 = require("./tuple");
const ipV4_1 = require("./ipV4");
const EntitiesToIPv6_1 = require("./_internals/mappers/EntitiesToIPv6");
function h16sTol32Mapper([a, b]) {
    return `${a}:${b}`;
}
function h16sTol32Unmapper(value) {
    if (typeof value !== 'string')
        throw new Error('Invalid type');
    if (!value.includes(':'))
        throw new Error('Invalid value');
    return value.split(':', 2);
}
function ipV6() {
    const h16Arb = (0, hexaString_1.hexaString)({ minLength: 1, maxLength: 4, size: 'max' });
    const ls32Arb = (0, oneof_1.oneof)((0, tuple_1.tuple)(h16Arb, h16Arb).map(h16sTol32Mapper, h16sTol32Unmapper), (0, ipV4_1.ipV4)());
    return (0, oneof_1.oneof)((0, tuple_1.tuple)((0, array_1.array)(h16Arb, { minLength: 6, maxLength: 6, size: 'max' }), ls32Arb).map(EntitiesToIPv6_1.fullySpecifiedMapper, EntitiesToIPv6_1.fullySpecifiedUnmapper), (0, tuple_1.tuple)((0, array_1.array)(h16Arb, { minLength: 5, maxLength: 5, size: 'max' }), ls32Arb).map(EntitiesToIPv6_1.onlyTrailingMapper, EntitiesToIPv6_1.onlyTrailingUnmapper), (0, tuple_1.tuple)((0, array_1.array)(h16Arb, { minLength: 0, maxLength: 1, size: 'max' }), (0, array_1.array)(h16Arb, { minLength: 4, maxLength: 4, size: 'max' }), ls32Arb).map(EntitiesToIPv6_1.multiTrailingMapper, EntitiesToIPv6_1.multiTrailingUnmapper), (0, tuple_1.tuple)((0, array_1.array)(h16Arb, { minLength: 0, maxLength: 2, size: 'max' }), (0, array_1.array)(h16Arb, { minLength: 3, maxLength: 3, size: 'max' }), ls32Arb).map(EntitiesToIPv6_1.multiTrailingMapper, EntitiesToIPv6_1.multiTrailingUnmapper), (0, tuple_1.tuple)((0, array_1.array)(h16Arb, { minLength: 0, maxLength: 3, size: 'max' }), (0, array_1.array)(h16Arb, { minLength: 2, maxLength: 2, size: 'max' }), ls32Arb).map(EntitiesToIPv6_1.multiTrailingMapper, EntitiesToIPv6_1.multiTrailingUnmapper), (0, tuple_1.tuple)((0, array_1.array)(h16Arb, { minLength: 0, maxLength: 4, size: 'max' }), h16Arb, ls32Arb).map(EntitiesToIPv6_1.multiTrailingMapperOne, EntitiesToIPv6_1.multiTrailingUnmapperOne), (0, tuple_1.tuple)((0, array_1.array)(h16Arb, { minLength: 0, maxLength: 5, size: 'max' }), ls32Arb).map(EntitiesToIPv6_1.singleTrailingMapper, EntitiesToIPv6_1.singleTrailingUnmapper), (0, tuple_1.tuple)((0, array_1.array)(h16Arb, { minLength: 0, maxLength: 6, size: 'max' }), h16Arb).map(EntitiesToIPv6_1.singleTrailingMapper, EntitiesToIPv6_1.singleTrailingUnmapper), (0, tuple_1.tuple)((0, array_1.array)(h16Arb, { minLength: 0, maxLength: 7, size: 'max' })).map(EntitiesToIPv6_1.noTrailingMapper, EntitiesToIPv6_1.noTrailingUnmapper));
}
exports.ipV6 = ipV6;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\ipV6.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\json.js", {"./jsonValue":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\jsonValue.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5Cjson.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.json = void 0;
const jsonValue_1 = require("./jsonValue");
function json(constraints = {}) {
    const arb = (0, jsonValue_1.jsonValue)(constraints);
    return arb.map(JSON.stringify);
}
exports.json = json;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\json.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\jsonValue.js", {"./_internals/helpers/JsonConstraintsBuilder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\JsonConstraintsBuilder.js","./anything":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\anything.js","./string":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\string.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CjsonValue.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.jsonValue = void 0;
const string_1 = require("./string");
const JsonConstraintsBuilder_1 = require("./_internals/helpers/JsonConstraintsBuilder");
const anything_1 = require("./anything");
function jsonValue(constraints = {}) {
    return (0, anything_1.anything)((0, JsonConstraintsBuilder_1.jsonConstraintsBuilder)((0, string_1.string)(), constraints));
}
exports.jsonValue = jsonValue;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\jsonValue.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\letrec.js", {"./_internals/LazyArbitrary":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\LazyArbitrary.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5Cletrec.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.letrec = void 0;
const LazyArbitrary_1 = require("./_internals/LazyArbitrary");
function letrec(builder) {
    const lazyArbs = Object.create(null);
    const tie = (key) => {
        if (!Object.prototype.hasOwnProperty.call(lazyArbs, key)) {
            lazyArbs[key] = new LazyArbitrary_1.LazyArbitrary(String(key));
        }
        return lazyArbs[key];
    };
    const strictArbs = builder(tie);
    for (const key in strictArbs) {
        if (!Object.prototype.hasOwnProperty.call(strictArbs, key)) {
            continue;
        }
        const lazyAtKey = lazyArbs[key];
        const lazyArb = lazyAtKey !== undefined ? lazyAtKey : new LazyArbitrary_1.LazyArbitrary(key);
        lazyArb.underlying = strictArbs[key];
        lazyArbs[key] = lazyArb;
    }
    return strictArbs;
}
exports.letrec = letrec;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\letrec.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\lorem.js", {"./_internals/mappers/WordsToLorem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\mappers\\WordsToLorem.js","./array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\array.js","./constant":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\constant.js","./oneof":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\oneof.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5Clorem.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.lorem = void 0;
const array_1 = require("./array");
const constant_1 = require("./constant");
const oneof_1 = require("./oneof");
const WordsToLorem_1 = require("./_internals/mappers/WordsToLorem");
const h = (v, w) => {
    return { arbitrary: (0, constant_1.constant)(v), weight: w };
};
function loremWord() {
    return (0, oneof_1.oneof)(h('non', 6), h('adipiscing', 5), h('ligula', 5), h('enim', 5), h('pellentesque', 5), h('in', 5), h('augue', 5), h('et', 5), h('nulla', 5), h('lorem', 4), h('sit', 4), h('sed', 4), h('diam', 4), h('fermentum', 4), h('ut', 4), h('eu', 4), h('aliquam', 4), h('mauris', 4), h('vitae', 4), h('felis', 4), h('ipsum', 3), h('dolor', 3), h('amet,', 3), h('elit', 3), h('euismod', 3), h('mi', 3), h('orci', 3), h('erat', 3), h('praesent', 3), h('egestas', 3), h('leo', 3), h('vel', 3), h('sapien', 3), h('integer', 3), h('curabitur', 3), h('convallis', 3), h('purus', 3), h('risus', 2), h('suspendisse', 2), h('lectus', 2), h('nec,', 2), h('ultricies', 2), h('sed,', 2), h('cras', 2), h('elementum', 2), h('ultrices', 2), h('maecenas', 2), h('massa,', 2), h('varius', 2), h('a,', 2), h('semper', 2), h('proin', 2), h('nec', 2), h('nisl', 2), h('amet', 2), h('duis', 2), h('congue', 2), h('libero', 2), h('vestibulum', 2), h('pede', 2), h('blandit', 2), h('sodales', 2), h('ante', 2), h('nibh', 2), h('ac', 2), h('aenean', 2), h('massa', 2), h('suscipit', 2), h('sollicitudin', 2), h('fusce', 2), h('tempus', 2), h('aliquam,', 2), h('nunc', 2), h('ullamcorper', 2), h('rhoncus', 2), h('metus', 2), h('faucibus,', 2), h('justo', 2), h('magna', 2), h('at', 2), h('tincidunt', 2), h('consectetur', 1), h('tortor,', 1), h('dignissim', 1), h('congue,', 1), h('non,', 1), h('porttitor,', 1), h('nonummy', 1), h('molestie,', 1), h('est', 1), h('eleifend', 1), h('mi,', 1), h('arcu', 1), h('scelerisque', 1), h('vitae,', 1), h('consequat', 1), h('in,', 1), h('pretium', 1), h('volutpat', 1), h('pharetra', 1), h('tempor', 1), h('bibendum', 1), h('odio', 1), h('dui', 1), h('primis', 1), h('faucibus', 1), h('luctus', 1), h('posuere', 1), h('cubilia', 1), h('curae,', 1), h('hendrerit', 1), h('velit', 1), h('mauris,', 1), h('gravida', 1), h('ornare', 1), h('ut,', 1), h('pulvinar', 1), h('varius,', 1), h('turpis', 1), h('nibh,', 1), h('eros', 1), h('id', 1), h('aliquet', 1), h('quis', 1), h('lobortis', 1), h('consectetuer', 1), h('morbi', 1), h('vehicula', 1), h('tortor', 1), h('tellus,', 1), h('id,', 1), h('eu,', 1), h('quam', 1), h('feugiat,', 1), h('posuere,', 1), h('iaculis', 1), h('lectus,', 1), h('tristique', 1), h('mollis,', 1), h('nisl,', 1), h('vulputate', 1), h('sem', 1), h('vivamus', 1), h('placerat', 1), h('imperdiet', 1), h('cursus', 1), h('rutrum', 1), h('iaculis,', 1), h('augue,', 1), h('lacus', 1));
}
function lorem(constraints = {}) {
    const { maxCount, mode = 'words', size } = constraints;
    if (maxCount !== undefined && maxCount < 1) {
        throw new Error(`lorem has to produce at least one word/sentence`);
    }
    const wordArbitrary = loremWord();
    if (mode === 'sentences') {
        const sentence = (0, array_1.array)(wordArbitrary, { minLength: 1, size: 'small' }).map(WordsToLorem_1.wordsToSentenceMapper, (0, WordsToLorem_1.wordsToSentenceUnmapperFor)(wordArbitrary));
        return (0, array_1.array)(sentence, { minLength: 1, maxLength: maxCount, size }).map(WordsToLorem_1.sentencesToParagraphMapper, WordsToLorem_1.sentencesToParagraphUnmapper);
    }
    else {
        return (0, array_1.array)(wordArbitrary, { minLength: 1, maxLength: maxCount, size }).map(WordsToLorem_1.wordsToJoinedStringMapper, (0, WordsToLorem_1.wordsToJoinedStringUnmapperFor)(wordArbitrary));
    }
}
exports.lorem = lorem;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\lorem.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\mapToConstant.js", {"./_internals/mappers/IndexToMappedConstant":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\mappers\\IndexToMappedConstant.js","./nat":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\nat.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CmapToConstant.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapToConstant = void 0;
const nat_1 = require("./nat");
const IndexToMappedConstant_1 = require("./_internals/mappers/IndexToMappedConstant");
function computeNumChoices(options) {
    if (options.length === 0)
        throw new Error(`fc.mapToConstant expects at least one option`);
    let numChoices = 0;
    for (let idx = 0; idx !== options.length; ++idx) {
        if (options[idx].num < 0)
            throw new Error(`fc.mapToConstant expects all options to have a number of entries greater or equal to zero`);
        numChoices += options[idx].num;
    }
    if (numChoices === 0)
        throw new Error(`fc.mapToConstant expects at least one choice among options`);
    return numChoices;
}
function mapToConstant(...entries) {
    const numChoices = computeNumChoices(entries);
    return (0, nat_1.nat)({ max: numChoices - 1 }).map((0, IndexToMappedConstant_1.indexToMappedConstantMapperFor)(entries), (0, IndexToMappedConstant_1.indexToMappedConstantUnmapperFor)(entries));
}
exports.mapToConstant = mapToConstant;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\mapToConstant.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\maxSafeInteger.js", {"./_internals/IntegerArbitrary":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\IntegerArbitrary.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CmaxSafeInteger.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.maxSafeInteger = void 0;
const IntegerArbitrary_1 = require("./_internals/IntegerArbitrary");
function maxSafeInteger() {
    return new IntegerArbitrary_1.IntegerArbitrary(Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
}
exports.maxSafeInteger = maxSafeInteger;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\maxSafeInteger.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\maxSafeNat.js", {"./_internals/IntegerArbitrary":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\IntegerArbitrary.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CmaxSafeNat.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.maxSafeNat = void 0;
const IntegerArbitrary_1 = require("./_internals/IntegerArbitrary");
function maxSafeNat() {
    return new IntegerArbitrary_1.IntegerArbitrary(0, Number.MAX_SAFE_INTEGER);
}
exports.maxSafeNat = maxSafeNat;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\maxSafeNat.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\memo.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5Cmemo.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.memo = void 0;
let contextRemainingDepth = 10;
function memo(builder) {
    const previous = {};
    return ((maxDepth) => {
        const n = maxDepth !== undefined ? maxDepth : contextRemainingDepth;
        if (!Object.prototype.hasOwnProperty.call(previous, n)) {
            const prev = contextRemainingDepth;
            contextRemainingDepth = n - 1;
            previous[n] = builder(n);
            contextRemainingDepth = prev;
        }
        return previous[n];
    });
}
exports.memo = memo;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\memo.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\mixedCase.js", {"./_internals/MixedCaseArbitrary":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\MixedCaseArbitrary.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CmixedCase.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mixedCase = void 0;
const MixedCaseArbitrary_1 = require("./_internals/MixedCaseArbitrary");
function defaultToggleCase(rawChar) {
    const upper = rawChar.toUpperCase();
    if (upper !== rawChar)
        return upper;
    return rawChar.toLowerCase();
}
function mixedCase(stringArb, constraints) {
    if (typeof BigInt === 'undefined') {
        throw new Error(`mixedCase requires BigInt support`);
    }
    const toggleCase = (constraints && constraints.toggleCase) || defaultToggleCase;
    const untoggleAll = constraints && constraints.untoggleAll;
    return new MixedCaseArbitrary_1.MixedCaseArbitrary(stringArb, toggleCase, untoggleAll);
}
exports.mixedCase = mixedCase;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\mixedCase.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\nat.js", {"./_internals/IntegerArbitrary":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\IntegerArbitrary.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5Cnat.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nat = void 0;
const IntegerArbitrary_1 = require("./_internals/IntegerArbitrary");
function nat(arg) {
    const max = typeof arg === 'number' ? arg : arg && arg.max !== undefined ? arg.max : 0x7fffffff;
    if (max < 0) {
        throw new Error('fc.nat value should be greater than or equal to 0');
    }
    if (!Number.isInteger(max)) {
        throw new Error('fc.nat maximum value should be an integer');
    }
    return new IntegerArbitrary_1.IntegerArbitrary(0, max);
}
exports.nat = nat;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\nat.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\object.js", {"./_internals/builders/AnyArbitraryBuilder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\AnyArbitraryBuilder.js","./_internals/helpers/QualifiedObjectConstraints":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\QualifiedObjectConstraints.js","./dictionary":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\dictionary.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5Cobject.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.object = void 0;
const dictionary_1 = require("./dictionary");
const AnyArbitraryBuilder_1 = require("./_internals/builders/AnyArbitraryBuilder");
const QualifiedObjectConstraints_1 = require("./_internals/helpers/QualifiedObjectConstraints");
function objectInternal(constraints) {
    return (0, dictionary_1.dictionary)(constraints.key, (0, AnyArbitraryBuilder_1.anyArbitraryBuilder)(constraints), {
        maxKeys: constraints.maxKeys,
        size: constraints.size,
    });
}
function object(constraints) {
    return objectInternal((0, QualifiedObjectConstraints_1.toQualifiedObjectConstraints)(constraints));
}
exports.object = object;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\object.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\oneof.js", {"../check/arbitrary/definition/Arbitrary":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\arbitrary\\definition\\Arbitrary.js","./_internals/FrequencyArbitrary":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\FrequencyArbitrary.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5Coneof.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.oneof = void 0;
const Arbitrary_1 = require("../check/arbitrary/definition/Arbitrary");
const FrequencyArbitrary_1 = require("./_internals/FrequencyArbitrary");
function isOneOfContraints(param) {
    return (param != null &&
        typeof param === 'object' &&
        !('generate' in param) &&
        !('arbitrary' in param) &&
        !('weight' in param));
}
function toWeightedArbitrary(maybeWeightedArbitrary) {
    if ((0, Arbitrary_1.isArbitrary)(maybeWeightedArbitrary)) {
        return { arbitrary: maybeWeightedArbitrary, weight: 1 };
    }
    return maybeWeightedArbitrary;
}
function oneof(...args) {
    const constraints = args[0];
    if (isOneOfContraints(constraints)) {
        const weightedArbs = args.slice(1).map(toWeightedArbitrary);
        return FrequencyArbitrary_1.FrequencyArbitrary.from(weightedArbs, constraints, 'fc.oneof');
    }
    const weightedArbs = args.map(toWeightedArbitrary);
    return FrequencyArbitrary_1.FrequencyArbitrary.from(weightedArbs, {}, 'fc.oneof');
}
exports.oneof = oneof;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\oneof.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\option.js", {"./_internals/FrequencyArbitrary":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\FrequencyArbitrary.js","./constant":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\constant.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5Coption.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.option = void 0;
const constant_1 = require("./constant");
const FrequencyArbitrary_1 = require("./_internals/FrequencyArbitrary");
function option(arb, constraints = {}) {
    const freq = constraints.freq == null ? 5 : constraints.freq;
    const nilValue = Object.prototype.hasOwnProperty.call(constraints, 'nil') ? constraints.nil : null;
    const nilArb = (0, constant_1.constant)(nilValue);
    const weightedArbs = [
        { arbitrary: nilArb, weight: 1, fallbackValue: { default: nilValue } },
        { arbitrary: arb, weight: freq },
    ];
    const frequencyConstraints = {
        withCrossShrink: true,
        depthSize: constraints.depthSize,
        maxDepth: constraints.maxDepth,
        depthIdentifier: constraints.depthIdentifier,
    };
    return FrequencyArbitrary_1.FrequencyArbitrary.from(weightedArbs, frequencyConstraints, 'fc.option');
}
exports.option = option;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\option.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\record.js", {"./_internals/builders/PartialRecordArbitraryBuilder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\PartialRecordArbitraryBuilder.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5Crecord.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.record = void 0;
const PartialRecordArbitraryBuilder_1 = require("./_internals/builders/PartialRecordArbitraryBuilder");
function record(recordModel, constraints) {
    if (constraints == null) {
        return (0, PartialRecordArbitraryBuilder_1.buildPartialRecordArbitrary)(recordModel, undefined);
    }
    if ('withDeletedKeys' in constraints && 'requiredKeys' in constraints) {
        throw new Error(`requiredKeys and withDeletedKeys cannot be used together in fc.record`);
    }
    const requireDeletedKeys = ('requiredKeys' in constraints && constraints.requiredKeys !== undefined) ||
        ('withDeletedKeys' in constraints && !!constraints.withDeletedKeys);
    if (!requireDeletedKeys) {
        return (0, PartialRecordArbitraryBuilder_1.buildPartialRecordArbitrary)(recordModel, undefined);
    }
    const requiredKeys = ('requiredKeys' in constraints ? constraints.requiredKeys : undefined) || [];
    for (let idx = 0; idx !== requiredKeys.length; ++idx) {
        const descriptor = Object.getOwnPropertyDescriptor(recordModel, requiredKeys[idx]);
        if (descriptor === undefined) {
            throw new Error(`requiredKeys cannot reference keys that have not been defined in recordModel`);
        }
        if (!descriptor.enumerable) {
            throw new Error(`requiredKeys cannot reference keys that have are enumerable in recordModel`);
        }
    }
    return (0, PartialRecordArbitraryBuilder_1.buildPartialRecordArbitrary)(recordModel, requiredKeys);
}
exports.record = record;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\record.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\scheduler.js", {"./_internals/SchedulerArbitrary":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\SchedulerArbitrary.js","./_internals/helpers/BuildSchedulerFor":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\BuildSchedulerFor.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5Cscheduler.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schedulerFor = exports.scheduler = void 0;
const BuildSchedulerFor_1 = require("./_internals/helpers/BuildSchedulerFor");
const SchedulerArbitrary_1 = require("./_internals/SchedulerArbitrary");
function scheduler(constraints) {
    const { act = (f) => f() } = constraints || {};
    return new SchedulerArbitrary_1.SchedulerArbitrary(act);
}
exports.scheduler = scheduler;
function schedulerFor(customOrderingOrConstraints, constraintsOrUndefined) {
    const { act = (f) => f() } = Array.isArray(customOrderingOrConstraints)
        ? constraintsOrUndefined || {}
        : customOrderingOrConstraints || {};
    if (Array.isArray(customOrderingOrConstraints)) {
        return (0, BuildSchedulerFor_1.buildSchedulerFor)(act, customOrderingOrConstraints);
    }
    return function (_strs, ...ordering) {
        return (0, BuildSchedulerFor_1.buildSchedulerFor)(act, ordering);
    };
}
exports.schedulerFor = schedulerFor;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\scheduler.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\shuffledSubarray.js", {"./_internals/SubarrayArbitrary":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\SubarrayArbitrary.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CshuffledSubarray.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shuffledSubarray = void 0;
const SubarrayArbitrary_1 = require("./_internals/SubarrayArbitrary");
function shuffledSubarray(originalArray, constraints = {}) {
    const { minLength = 0, maxLength = originalArray.length } = constraints;
    return new SubarrayArbitrary_1.SubarrayArbitrary(originalArray, false, minLength, maxLength);
}
exports.shuffledSubarray = shuffledSubarray;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\shuffledSubarray.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\sparseArray.js", {"./_internals/builders/RestrictedIntegerArbitraryBuilder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\RestrictedIntegerArbitraryBuilder.js","./_internals/helpers/MaxLengthFromMinLength":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\MaxLengthFromMinLength.js","./tuple":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\tuple.js","./uniqueArray":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\uniqueArray.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CsparseArray.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sparseArray = void 0;
const tuple_1 = require("./tuple");
const uniqueArray_1 = require("./uniqueArray");
const RestrictedIntegerArbitraryBuilder_1 = require("./_internals/builders/RestrictedIntegerArbitraryBuilder");
const MaxLengthFromMinLength_1 = require("./_internals/helpers/MaxLengthFromMinLength");
function extractMaxIndex(indexesAndValues) {
    let maxIndex = -1;
    for (let index = 0; index !== indexesAndValues.length; ++index) {
        maxIndex = Math.max(maxIndex, indexesAndValues[index][0]);
    }
    return maxIndex;
}
function arrayFromItems(length, indexesAndValues) {
    const array = Array(length);
    for (let index = 0; index !== indexesAndValues.length; ++index) {
        const it = indexesAndValues[index];
        if (it[0] < length)
            array[it[0]] = it[1];
    }
    return array;
}
function sparseArray(arb, constraints = {}) {
    const { size, minNumElements = 0, maxLength = MaxLengthFromMinLength_1.MaxLengthUpperBound, maxNumElements = maxLength, noTrailingHole, depthIdentifier, } = constraints;
    const maxGeneratedNumElements = (0, MaxLengthFromMinLength_1.maxGeneratedLengthFromSizeForArbitrary)(size, minNumElements, maxNumElements, constraints.maxNumElements !== undefined);
    const maxGeneratedLength = (0, MaxLengthFromMinLength_1.maxGeneratedLengthFromSizeForArbitrary)(size, maxGeneratedNumElements, maxLength, constraints.maxLength !== undefined);
    if (minNumElements > maxLength) {
        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);
    }
    if (minNumElements > maxNumElements) {
        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);
    }
    const resultedMaxNumElements = Math.min(maxNumElements, maxLength);
    const resultedSizeMaxNumElements = constraints.maxNumElements !== undefined || size !== undefined ? size : '=';
    const maxGeneratedIndexAuthorized = Math.max(maxGeneratedLength - 1, 0);
    const maxIndexAuthorized = Math.max(maxLength - 1, 0);
    const sparseArrayNoTrailingHole = (0, uniqueArray_1.uniqueArray)((0, tuple_1.tuple)((0, RestrictedIntegerArbitraryBuilder_1.restrictedIntegerArbitraryBuilder)(0, maxGeneratedIndexAuthorized, maxIndexAuthorized), arb), {
        size: resultedSizeMaxNumElements,
        minLength: minNumElements,
        maxLength: resultedMaxNumElements,
        selector: (item) => item[0],
        depthIdentifier,
    }).map((items) => {
        const lastIndex = extractMaxIndex(items);
        return arrayFromItems(lastIndex + 1, items);
    }, (value) => {
        if (!Array.isArray(value)) {
            throw new Error('Not supported entry type');
        }
        if (noTrailingHole && value.length !== 0 && !(value.length - 1 in value)) {
            throw new Error('No trailing hole');
        }
        return Object.entries(value).map((entry) => [Number(entry[0]), entry[1]]);
    });
    if (noTrailingHole || maxLength === minNumElements) {
        return sparseArrayNoTrailingHole;
    }
    return (0, tuple_1.tuple)(sparseArrayNoTrailingHole, (0, RestrictedIntegerArbitraryBuilder_1.restrictedIntegerArbitraryBuilder)(minNumElements, maxGeneratedLength, maxLength)).map((data) => {
        const sparse = data[0];
        const targetLength = data[1];
        if (sparse.length >= targetLength) {
            return sparse;
        }
        const longerSparse = sparse.slice();
        longerSparse.length = targetLength;
        return longerSparse;
    }, (value) => {
        if (!Array.isArray(value)) {
            throw new Error('Not supported entry type');
        }
        return [value, value.length];
    });
}
exports.sparseArray = sparseArray;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\sparseArray.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\string.js", {"./_internals/helpers/SlicesForStringBuilder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\SlicesForStringBuilder.js","./_internals/mappers/CodePointsToString":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\mappers\\CodePointsToString.js","./array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\array.js","./char":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\char.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5Cstring.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.string = void 0;
const array_1 = require("./array");
const char_1 = require("./char");
const CodePointsToString_1 = require("./_internals/mappers/CodePointsToString");
const SlicesForStringBuilder_1 = require("./_internals/helpers/SlicesForStringBuilder");
function string(constraints = {}) {
    const charArbitrary = (0, char_1.char)();
    const experimentalCustomSlices = (0, SlicesForStringBuilder_1.createSlicesForString)(charArbitrary, CodePointsToString_1.codePointsToStringUnmapper);
    const enrichedConstraints = Object.assign(Object.assign({}, constraints), { experimentalCustomSlices });
    return (0, array_1.array)(charArbitrary, enrichedConstraints).map(CodePointsToString_1.codePointsToStringMapper, CodePointsToString_1.codePointsToStringUnmapper);
}
exports.string = string;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\string.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\string16bits.js", {"./_internals/helpers/SlicesForStringBuilder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\SlicesForStringBuilder.js","./_internals/mappers/CharsToString":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\mappers\\CharsToString.js","./array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\array.js","./char16bits":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\char16bits.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5Cstring16bits.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.string16bits = void 0;
const array_1 = require("./array");
const char16bits_1 = require("./char16bits");
const CharsToString_1 = require("./_internals/mappers/CharsToString");
const SlicesForStringBuilder_1 = require("./_internals/helpers/SlicesForStringBuilder");
function string16bits(constraints = {}) {
    const charArbitrary = (0, char16bits_1.char16bits)();
    const experimentalCustomSlices = (0, SlicesForStringBuilder_1.createSlicesForString)(charArbitrary, CharsToString_1.charsToStringUnmapper);
    const enrichedConstraints = Object.assign(Object.assign({}, constraints), { experimentalCustomSlices });
    return (0, array_1.array)(charArbitrary, enrichedConstraints).map(CharsToString_1.charsToStringMapper, CharsToString_1.charsToStringUnmapper);
}
exports.string16bits = string16bits;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\string16bits.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\stringOf.js", {"./_internals/helpers/SlicesForStringBuilder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\SlicesForStringBuilder.js","./_internals/mappers/PatternsToString":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\mappers\\PatternsToString.js","./array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\array.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CstringOf.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringOf = void 0;
const array_1 = require("./array");
const PatternsToString_1 = require("./_internals/mappers/PatternsToString");
const SlicesForStringBuilder_1 = require("./_internals/helpers/SlicesForStringBuilder");
function stringOf(charArb, constraints = {}) {
    const unmapper = (0, PatternsToString_1.patternsToStringUnmapperFor)(charArb, constraints);
    const experimentalCustomSlices = (0, SlicesForStringBuilder_1.createSlicesForString)(charArb, unmapper);
    const enrichedConstraints = Object.assign(Object.assign({}, constraints), { experimentalCustomSlices });
    return (0, array_1.array)(charArb, enrichedConstraints).map(PatternsToString_1.patternsToStringMapper, unmapper);
}
exports.stringOf = stringOf;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\stringOf.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\subarray.js", {"./_internals/SubarrayArbitrary":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\SubarrayArbitrary.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5Csubarray.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.subarray = void 0;
const SubarrayArbitrary_1 = require("./_internals/SubarrayArbitrary");
function subarray(originalArray, constraints = {}) {
    const { minLength = 0, maxLength = originalArray.length } = constraints;
    return new SubarrayArbitrary_1.SubarrayArbitrary(originalArray, true, minLength, maxLength);
}
exports.subarray = subarray;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\subarray.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\tuple.js", {"./_internals/TupleArbitrary":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\TupleArbitrary.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5Ctuple.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tuple = void 0;
const TupleArbitrary_1 = require("./_internals/TupleArbitrary");
function tuple(...arbs) {
    return new TupleArbitrary_1.TupleArbitrary(arbs);
}
exports.tuple = tuple;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\tuple.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\uint16Array.js", {"./_internals/builders/TypedIntArrayArbitraryBuilder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\TypedIntArrayArbitraryBuilder.js","./integer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\integer.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5Cuint16Array.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uint16Array = void 0;
const integer_1 = require("./integer");
const TypedIntArrayArbitraryBuilder_1 = require("./_internals/builders/TypedIntArrayArbitraryBuilder");
function uint16Array(constraints = {}) {
    return (0, TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder)(constraints, 0, 65535, Uint16Array, integer_1.integer);
}
exports.uint16Array = uint16Array;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\uint16Array.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\uint32Array.js", {"./_internals/builders/TypedIntArrayArbitraryBuilder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\TypedIntArrayArbitraryBuilder.js","./integer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\integer.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5Cuint32Array.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uint32Array = void 0;
const integer_1 = require("./integer");
const TypedIntArrayArbitraryBuilder_1 = require("./_internals/builders/TypedIntArrayArbitraryBuilder");
function uint32Array(constraints = {}) {
    return (0, TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder)(constraints, 0, 0xffffffff, Uint32Array, integer_1.integer);
}
exports.uint32Array = uint32Array;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\uint32Array.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\uint8Array.js", {"./_internals/builders/TypedIntArrayArbitraryBuilder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\TypedIntArrayArbitraryBuilder.js","./integer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\integer.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5Cuint8Array.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uint8Array = void 0;
const integer_1 = require("./integer");
const TypedIntArrayArbitraryBuilder_1 = require("./_internals/builders/TypedIntArrayArbitraryBuilder");
function uint8Array(constraints = {}) {
    return (0, TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder)(constraints, 0, 255, Uint8Array, integer_1.integer);
}
exports.uint8Array = uint8Array;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\uint8Array.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\uint8ClampedArray.js", {"./_internals/builders/TypedIntArrayArbitraryBuilder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\TypedIntArrayArbitraryBuilder.js","./integer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\integer.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5Cuint8ClampedArray.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uint8ClampedArray = void 0;
const integer_1 = require("./integer");
const TypedIntArrayArbitraryBuilder_1 = require("./_internals/builders/TypedIntArrayArbitraryBuilder");
function uint8ClampedArray(constraints = {}) {
    return (0, TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder)(constraints, 0, 255, Uint8ClampedArray, integer_1.integer);
}
exports.uint8ClampedArray = uint8ClampedArray;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\uint8ClampedArray.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\unicode.js", {"./_internals/builders/CharacterArbitraryBuilder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\CharacterArbitraryBuilder.js","./_internals/mappers/IndexToPrintableIndex":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\mappers\\IndexToPrintableIndex.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5Cunicode.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unicode = void 0;
const CharacterArbitraryBuilder_1 = require("./_internals/builders/CharacterArbitraryBuilder");
const IndexToPrintableIndex_1 = require("./_internals/mappers/IndexToPrintableIndex");
const gapSize = 0xdfff + 1 - 0xd800;
function unicodeMapper(v) {
    if (v < 0xd800)
        return (0, IndexToPrintableIndex_1.indexToPrintableIndexMapper)(v);
    return v + gapSize;
}
function unicodeUnmapper(v) {
    if (v < 0xd800)
        return (0, IndexToPrintableIndex_1.indexToPrintableIndexUnmapper)(v);
    if (v <= 0xdfff)
        return -1;
    return v - gapSize;
}
function unicode() {
    return (0, CharacterArbitraryBuilder_1.buildCharacterArbitrary)(0x0000, 0xffff - gapSize, unicodeMapper, unicodeUnmapper);
}
exports.unicode = unicode;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\unicode.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\unicodeJson.js", {"./unicodeJsonValue":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\unicodeJsonValue.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CunicodeJson.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unicodeJson = void 0;
const unicodeJsonValue_1 = require("./unicodeJsonValue");
function unicodeJson(constraints = {}) {
    const arb = (0, unicodeJsonValue_1.unicodeJsonValue)(constraints);
    return arb.map(JSON.stringify);
}
exports.unicodeJson = unicodeJson;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\unicodeJson.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\unicodeJsonValue.js", {"./_internals/helpers/JsonConstraintsBuilder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\JsonConstraintsBuilder.js","./anything":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\anything.js","./unicodeString":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\unicodeString.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CunicodeJsonValue.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unicodeJsonValue = void 0;
const unicodeString_1 = require("./unicodeString");
const JsonConstraintsBuilder_1 = require("./_internals/helpers/JsonConstraintsBuilder");
const anything_1 = require("./anything");
function unicodeJsonValue(constraints = {}) {
    return (0, anything_1.anything)((0, JsonConstraintsBuilder_1.jsonConstraintsBuilder)((0, unicodeString_1.unicodeString)(), constraints));
}
exports.unicodeJsonValue = unicodeJsonValue;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\unicodeJsonValue.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\unicodeString.js", {"./_internals/helpers/SlicesForStringBuilder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\SlicesForStringBuilder.js","./_internals/mappers/CodePointsToString":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\mappers\\CodePointsToString.js","./array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\array.js","./unicode":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\unicode.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CunicodeString.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unicodeString = void 0;
const array_1 = require("./array");
const unicode_1 = require("./unicode");
const CodePointsToString_1 = require("./_internals/mappers/CodePointsToString");
const SlicesForStringBuilder_1 = require("./_internals/helpers/SlicesForStringBuilder");
function unicodeString(constraints = {}) {
    const charArbitrary = (0, unicode_1.unicode)();
    const experimentalCustomSlices = (0, SlicesForStringBuilder_1.createSlicesForString)(charArbitrary, CodePointsToString_1.codePointsToStringUnmapper);
    const enrichedConstraints = Object.assign(Object.assign({}, constraints), { experimentalCustomSlices });
    return (0, array_1.array)(charArbitrary, enrichedConstraints).map(CodePointsToString_1.codePointsToStringMapper, CodePointsToString_1.codePointsToStringUnmapper);
}
exports.unicodeString = unicodeString;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\unicodeString.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\uniqueArray.js", {"./_internals/ArrayArbitrary":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\ArrayArbitrary.js","./_internals/helpers/CustomEqualSet":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\CustomEqualSet.js","./_internals/helpers/MaxLengthFromMinLength":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\MaxLengthFromMinLength.js","./_internals/helpers/SameValueSet":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\SameValueSet.js","./_internals/helpers/SameValueZeroSet":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\SameValueZeroSet.js","./_internals/helpers/StrictlyEqualSet":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\StrictlyEqualSet.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CuniqueArray.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uniqueArray = void 0;
const ArrayArbitrary_1 = require("./_internals/ArrayArbitrary");
const MaxLengthFromMinLength_1 = require("./_internals/helpers/MaxLengthFromMinLength");
const CustomEqualSet_1 = require("./_internals/helpers/CustomEqualSet");
const StrictlyEqualSet_1 = require("./_internals/helpers/StrictlyEqualSet");
const SameValueSet_1 = require("./_internals/helpers/SameValueSet");
const SameValueZeroSet_1 = require("./_internals/helpers/SameValueZeroSet");
function buildUniqueArraySetBuilder(constraints) {
    if (typeof constraints.comparator === 'function') {
        if (constraints.selector === undefined) {
            const comparator = constraints.comparator;
            const isEqualForBuilder = (nextA, nextB) => comparator(nextA.value_, nextB.value_);
            return () => new CustomEqualSet_1.CustomEqualSet(isEqualForBuilder);
        }
        const comparator = constraints.comparator;
        const selector = constraints.selector;
        const refinedSelector = (next) => selector(next.value_);
        const isEqualForBuilder = (nextA, nextB) => comparator(refinedSelector(nextA), refinedSelector(nextB));
        return () => new CustomEqualSet_1.CustomEqualSet(isEqualForBuilder);
    }
    const selector = constraints.selector || ((v) => v);
    const refinedSelector = (next) => selector(next.value_);
    switch (constraints.comparator) {
        case 'IsStrictlyEqual':
            return () => new StrictlyEqualSet_1.StrictlyEqualSet(refinedSelector);
        case 'SameValueZero':
            return () => new SameValueZeroSet_1.SameValueZeroSet(refinedSelector);
        case 'SameValue':
        case undefined:
            return () => new SameValueSet_1.SameValueSet(refinedSelector);
    }
}
function uniqueArray(arb, constraints = {}) {
    const minLength = constraints.minLength !== undefined ? constraints.minLength : 0;
    const maxLength = constraints.maxLength !== undefined ? constraints.maxLength : MaxLengthFromMinLength_1.MaxLengthUpperBound;
    const maxGeneratedLength = (0, MaxLengthFromMinLength_1.maxGeneratedLengthFromSizeForArbitrary)(constraints.size, minLength, maxLength, constraints.maxLength !== undefined);
    const depthIdentifier = constraints.depthIdentifier;
    const setBuilder = buildUniqueArraySetBuilder(constraints);
    const arrayArb = new ArrayArbitrary_1.ArrayArbitrary(arb, minLength, maxGeneratedLength, maxLength, depthIdentifier, setBuilder, []);
    if (minLength === 0)
        return arrayArb;
    return arrayArb.filter((tab) => tab.length >= minLength);
}
exports.uniqueArray = uniqueArray;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\uniqueArray.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\uuid.js", {"./_internals/builders/PaddedNumberArbitraryBuilder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\PaddedNumberArbitraryBuilder.js","./_internals/mappers/PaddedEightsToUuid":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\mappers\\PaddedEightsToUuid.js","./tuple":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\tuple.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5Cuuid.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uuid = void 0;
const tuple_1 = require("./tuple");
const PaddedNumberArbitraryBuilder_1 = require("./_internals/builders/PaddedNumberArbitraryBuilder");
const PaddedEightsToUuid_1 = require("./_internals/mappers/PaddedEightsToUuid");
function uuid() {
    const padded = (0, PaddedNumberArbitraryBuilder_1.buildPaddedNumberArbitrary)(0, 0xffffffff);
    const secondPadded = (0, PaddedNumberArbitraryBuilder_1.buildPaddedNumberArbitrary)(0x10000000, 0x5fffffff);
    const thirdPadded = (0, PaddedNumberArbitraryBuilder_1.buildPaddedNumberArbitrary)(0x80000000, 0xbfffffff);
    return (0, tuple_1.tuple)(padded, secondPadded, thirdPadded, padded).map(PaddedEightsToUuid_1.paddedEightsToUuidMapper, PaddedEightsToUuid_1.paddedEightsToUuidUnmapper);
}
exports.uuid = uuid;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\uuid.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\uuidV.js", {"./_internals/builders/PaddedNumberArbitraryBuilder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\PaddedNumberArbitraryBuilder.js","./_internals/mappers/PaddedEightsToUuid":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\mappers\\PaddedEightsToUuid.js","./tuple":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\tuple.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CuuidV.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uuidV = void 0;
const tuple_1 = require("./tuple");
const PaddedNumberArbitraryBuilder_1 = require("./_internals/builders/PaddedNumberArbitraryBuilder");
const PaddedEightsToUuid_1 = require("./_internals/mappers/PaddedEightsToUuid");
function uuidV(versionNumber) {
    const padded = (0, PaddedNumberArbitraryBuilder_1.buildPaddedNumberArbitrary)(0, 0xffffffff);
    const offsetSecond = versionNumber * 0x10000000;
    const secondPadded = (0, PaddedNumberArbitraryBuilder_1.buildPaddedNumberArbitrary)(offsetSecond, offsetSecond + 0x0fffffff);
    const thirdPadded = (0, PaddedNumberArbitraryBuilder_1.buildPaddedNumberArbitrary)(0x80000000, 0xbfffffff);
    return (0, tuple_1.tuple)(padded, secondPadded, thirdPadded, padded).map(PaddedEightsToUuid_1.paddedEightsToUuidMapper, PaddedEightsToUuid_1.paddedEightsToUuidUnmapper);
}
exports.uuidV = uuidV;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\uuidV.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\webAuthority.js", {"./_internals/builders/CharacterRangeArbitraryBuilder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\CharacterRangeArbitraryBuilder.js","./constant":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\constant.js","./domain":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\domain.js","./ipV4":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\ipV4.js","./ipV4Extended":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\ipV4Extended.js","./ipV6":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\ipV6.js","./nat":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\nat.js","./oneof":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\oneof.js","./option":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\option.js","./stringOf":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\stringOf.js","./tuple":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\tuple.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CwebAuthority.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.webAuthority = void 0;
const CharacterRangeArbitraryBuilder_1 = require("./_internals/builders/CharacterRangeArbitraryBuilder");
const constant_1 = require("./constant");
const domain_1 = require("./domain");
const ipV4_1 = require("./ipV4");
const ipV4Extended_1 = require("./ipV4Extended");
const ipV6_1 = require("./ipV6");
const nat_1 = require("./nat");
const oneof_1 = require("./oneof");
const option_1 = require("./option");
const stringOf_1 = require("./stringOf");
const tuple_1 = require("./tuple");
function hostUserInfo(size) {
    const others = ['-', '.', '_', '~', '!', '$', '&', "'", '(', ')', '*', '+', ',', ';', '=', ':'];
    return (0, stringOf_1.stringOf)((0, CharacterRangeArbitraryBuilder_1.buildAlphaNumericPercentArbitrary)(others), { size });
}
function userHostPortMapper([u, h, p]) {
    return (u === null ? '' : `${u}@`) + h + (p === null ? '' : `:${p}`);
}
function userHostPortUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Unsupported');
    }
    const atPosition = value.indexOf('@');
    const user = atPosition !== -1 ? value.substring(0, atPosition) : null;
    const portRegex = /:(\d+)$/;
    const m = portRegex.exec(value);
    const port = m !== null ? Number(m[1]) : null;
    const host = m !== null ? value.substring(atPosition + 1, value.length - m[1].length - 1) : value.substring(atPosition + 1);
    return [user, host, port];
}
function bracketedMapper(s) {
    return `[${s}]`;
}
function bracketedUnmapper(value) {
    if (typeof value !== 'string' || value[0] !== '[' || value[value.length - 1] !== ']') {
        throw new Error('Unsupported');
    }
    return value.substring(1, value.length - 1);
}
function webAuthority(constraints) {
    const c = constraints || {};
    const size = c.size;
    const hostnameArbs = [(0, domain_1.domain)({ size })]
        .concat(c.withIPv4 === true ? [(0, ipV4_1.ipV4)()] : [])
        .concat(c.withIPv6 === true ? [(0, ipV6_1.ipV6)().map(bracketedMapper, bracketedUnmapper)] : [])
        .concat(c.withIPv4Extended === true ? [(0, ipV4Extended_1.ipV4Extended)()] : []);
    return (0, tuple_1.tuple)(c.withUserInfo === true ? (0, option_1.option)(hostUserInfo(size)) : (0, constant_1.constant)(null), (0, oneof_1.oneof)(...hostnameArbs), c.withPort === true ? (0, option_1.option)((0, nat_1.nat)(65535)) : (0, constant_1.constant)(null)).map(userHostPortMapper, userHostPortUnmapper);
}
exports.webAuthority = webAuthority;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\webAuthority.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\webFragments.js", {"./_internals/builders/UriQueryOrFragmentArbitraryBuilder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\UriQueryOrFragmentArbitraryBuilder.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CwebFragments.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.webFragments = void 0;
const UriQueryOrFragmentArbitraryBuilder_1 = require("./_internals/builders/UriQueryOrFragmentArbitraryBuilder");
function webFragments(constraints = {}) {
    return (0, UriQueryOrFragmentArbitraryBuilder_1.buildUriQueryOrFragmentArbitrary)(constraints.size);
}
exports.webFragments = webFragments;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\webFragments.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\webQueryParameters.js", {"./_internals/builders/UriQueryOrFragmentArbitraryBuilder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\UriQueryOrFragmentArbitraryBuilder.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CwebQueryParameters.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.webQueryParameters = void 0;
const UriQueryOrFragmentArbitraryBuilder_1 = require("./_internals/builders/UriQueryOrFragmentArbitraryBuilder");
function webQueryParameters(constraints = {}) {
    return (0, UriQueryOrFragmentArbitraryBuilder_1.buildUriQueryOrFragmentArbitrary)(constraints.size);
}
exports.webQueryParameters = webQueryParameters;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\webQueryParameters.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\webSegment.js", {"./_internals/builders/CharacterRangeArbitraryBuilder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\CharacterRangeArbitraryBuilder.js","./stringOf":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\stringOf.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CwebSegment.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.webSegment = void 0;
const CharacterRangeArbitraryBuilder_1 = require("./_internals/builders/CharacterRangeArbitraryBuilder");
const stringOf_1 = require("./stringOf");
function webSegment(constraints = {}) {
    const others = ['-', '.', '_', '~', '!', '$', '&', "'", '(', ')', '*', '+', ',', ';', '=', ':', '@'];
    return (0, stringOf_1.stringOf)((0, CharacterRangeArbitraryBuilder_1.buildAlphaNumericPercentArbitrary)(others), { size: constraints.size });
}
exports.webSegment = webSegment;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\webSegment.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\webUrl.js", {"./_internals/builders/UriPathArbitraryBuilder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\UriPathArbitraryBuilder.js","./_internals/helpers/MaxLengthFromMinLength":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\MaxLengthFromMinLength.js","./_internals/mappers/PartsToUrl":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\mappers\\PartsToUrl.js","./constant":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\constant.js","./constantFrom":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\constantFrom.js","./option":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\option.js","./tuple":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\tuple.js","./webAuthority":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\webAuthority.js","./webFragments":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\webFragments.js","./webQueryParameters":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\webQueryParameters.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CwebUrl.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.webUrl = void 0;
const constantFrom_1 = require("./constantFrom");
const constant_1 = require("./constant");
const option_1 = require("./option");
const tuple_1 = require("./tuple");
const webQueryParameters_1 = require("./webQueryParameters");
const webFragments_1 = require("./webFragments");
const webAuthority_1 = require("./webAuthority");
const PartsToUrl_1 = require("./_internals/mappers/PartsToUrl");
const MaxLengthFromMinLength_1 = require("./_internals/helpers/MaxLengthFromMinLength");
const UriPathArbitraryBuilder_1 = require("./_internals/builders/UriPathArbitraryBuilder");
function webUrl(constraints) {
    const c = constraints || {};
    const resolvedSize = (0, MaxLengthFromMinLength_1.resolveSize)(c.size);
    const resolvedAuthoritySettingsSize = c.authoritySettings !== undefined && c.authoritySettings.size !== undefined
        ? (0, MaxLengthFromMinLength_1.relativeSizeToSize)(c.authoritySettings.size, resolvedSize)
        : resolvedSize;
    const resolvedAuthoritySettings = Object.assign(Object.assign({}, c.authoritySettings), { size: resolvedAuthoritySettingsSize });
    const validSchemes = c.validSchemes || ['http', 'https'];
    const schemeArb = (0, constantFrom_1.constantFrom)(...validSchemes);
    const authorityArb = (0, webAuthority_1.webAuthority)(resolvedAuthoritySettings);
    const pathArb = (0, UriPathArbitraryBuilder_1.buildUriPathArbitrary)(resolvedSize);
    return (0, tuple_1.tuple)(schemeArb, authorityArb, pathArb, c.withQueryParameters === true ? (0, option_1.option)((0, webQueryParameters_1.webQueryParameters)({ size: resolvedSize })) : (0, constant_1.constant)(null), c.withFragments === true ? (0, option_1.option)((0, webFragments_1.webFragments)({ size: resolvedSize })) : (0, constant_1.constant)(null)).map(PartsToUrl_1.partsToUrlMapper, PartsToUrl_1.partsToUrlUnmapper);
}
exports.webUrl = webUrl;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\webUrl.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\arbitrary\\definition\\Arbitrary.js", {"../../../stream/Stream":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\stream\\Stream.js","../../symbols":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\symbols.js","./Value":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\arbitrary\\definition\\Value.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Carbitrary%5Cdefinition%5CArbitrary.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertIsArbitrary = exports.isArbitrary = exports.Arbitrary = void 0;
const Stream_1 = require("../../../stream/Stream");
const symbols_1 = require("../../symbols");
const Value_1 = require("./Value");
class Arbitrary {
    filter(refinement) {
        return new FilterArbitrary(this, refinement);
    }
    map(mapper, unmapper) {
        return new MapArbitrary(this, mapper, unmapper);
    }
    chain(chainer) {
        return new ChainArbitrary(this, chainer);
    }
    noShrink() {
        return new NoShrinkArbitrary(this);
    }
    noBias() {
        return new NoBiasArbitrary(this);
    }
}
exports.Arbitrary = Arbitrary;
class ChainArbitrary extends Arbitrary {
    constructor(arb, chainer) {
        super();
        this.arb = arb;
        this.chainer = chainer;
    }
    generate(mrng, biasFactor) {
        const clonedMrng = mrng.clone();
        const src = this.arb.generate(mrng, biasFactor);
        return this.valueChainer(src, mrng, clonedMrng, biasFactor);
    }
    canShrinkWithoutContext(value) {
        return false;
    }
    shrink(value, context) {
        if (this.isSafeContext(context)) {
            return (!context.stoppedForOriginal
                ? this.arb
                    .shrink(context.originalValue, context.originalContext)
                    .map((v) => this.valueChainer(v, context.clonedMrng.clone(), context.clonedMrng, context.originalBias))
                : Stream_1.Stream.nil()).join(context.chainedArbitrary.shrink(value, context.chainedContext).map((dst) => {
                const newContext = Object.assign(Object.assign({}, context), { chainedContext: dst.context, stoppedForOriginal: true });
                return new Value_1.Value(dst.value_, newContext);
            }));
        }
        return Stream_1.Stream.nil();
    }
    valueChainer(v, generateMrng, clonedMrng, biasFactor) {
        const chainedArbitrary = this.chainer(v.value_);
        const dst = chainedArbitrary.generate(generateMrng, biasFactor);
        const context = {
            originalBias: biasFactor,
            originalValue: v.value_,
            originalContext: v.context,
            stoppedForOriginal: false,
            chainedArbitrary,
            chainedContext: dst.context,
            clonedMrng,
        };
        return new Value_1.Value(dst.value_, context);
    }
    isSafeContext(context) {
        return (context != null &&
            typeof context === 'object' &&
            'originalBias' in context &&
            'originalValue' in context &&
            'originalContext' in context &&
            'stoppedForOriginal' in context &&
            'chainedArbitrary' in context &&
            'chainedContext' in context &&
            'clonedMrng' in context);
    }
}
class MapArbitrary extends Arbitrary {
    constructor(arb, mapper, unmapper) {
        super();
        this.arb = arb;
        this.mapper = mapper;
        this.unmapper = unmapper;
        this.bindValueMapper = this.valueMapper.bind(this);
    }
    generate(mrng, biasFactor) {
        const g = this.arb.generate(mrng, biasFactor);
        return this.valueMapper(g);
    }
    canShrinkWithoutContext(value) {
        if (this.unmapper !== undefined) {
            try {
                const unmapped = this.unmapper(value);
                return this.arb.canShrinkWithoutContext(unmapped);
            }
            catch (_err) {
                return false;
            }
        }
        return false;
    }
    shrink(value, context) {
        if (this.isSafeContext(context)) {
            return this.arb.shrink(context.originalValue, context.originalContext).map(this.bindValueMapper);
        }
        if (this.unmapper !== undefined) {
            const unmapped = this.unmapper(value);
            return this.arb.shrink(unmapped, undefined).map(this.bindValueMapper);
        }
        return Stream_1.Stream.nil();
    }
    mapperWithCloneIfNeeded(v) {
        const sourceValue = v.value;
        const mappedValue = this.mapper(sourceValue);
        if (v.hasToBeCloned &&
            ((typeof mappedValue === 'object' && mappedValue !== null) || typeof mappedValue === 'function') &&
            Object.isExtensible(mappedValue) &&
            !(0, symbols_1.hasCloneMethod)(mappedValue)) {
            Object.defineProperty(mappedValue, symbols_1.cloneMethod, { get: () => () => this.mapperWithCloneIfNeeded(v)[0] });
        }
        return [mappedValue, sourceValue];
    }
    valueMapper(v) {
        const [mappedValue, sourceValue] = this.mapperWithCloneIfNeeded(v);
        const context = { originalValue: sourceValue, originalContext: v.context };
        return new Value_1.Value(mappedValue, context);
    }
    isSafeContext(context) {
        return (context != null &&
            typeof context === 'object' &&
            'originalValue' in context &&
            'originalContext' in context);
    }
}
class FilterArbitrary extends Arbitrary {
    constructor(arb, refinement) {
        super();
        this.arb = arb;
        this.refinement = refinement;
        this.bindRefinementOnValue = this.refinementOnValue.bind(this);
    }
    generate(mrng, biasFactor) {
        while (true) {
            const g = this.arb.generate(mrng, biasFactor);
            if (this.refinementOnValue(g)) {
                return g;
            }
        }
    }
    canShrinkWithoutContext(value) {
        return this.arb.canShrinkWithoutContext(value) && this.refinement(value);
    }
    shrink(value, context) {
        return this.arb.shrink(value, context).filter(this.bindRefinementOnValue);
    }
    refinementOnValue(v) {
        return this.refinement(v.value);
    }
}
class NoShrinkArbitrary extends Arbitrary {
    constructor(arb) {
        super();
        this.arb = arb;
    }
    generate(mrng, biasFactor) {
        return this.arb.generate(mrng, biasFactor);
    }
    canShrinkWithoutContext(value) {
        return this.arb.canShrinkWithoutContext(value);
    }
    shrink(_value, _context) {
        return Stream_1.Stream.nil();
    }
    noShrink() {
        return this;
    }
}
class NoBiasArbitrary extends Arbitrary {
    constructor(arb) {
        super();
        this.arb = arb;
    }
    generate(mrng, _biasFactor) {
        return this.arb.generate(mrng, undefined);
    }
    canShrinkWithoutContext(value) {
        return this.arb.canShrinkWithoutContext(value);
    }
    shrink(value, context) {
        return this.arb.shrink(value, context);
    }
    noBias() {
        return this;
    }
}
function isArbitrary(instance) {
    return (typeof instance === 'object' &&
        instance !== null &&
        'generate' in instance &&
        'shrink' in instance &&
        'canShrinkWithoutContext' in instance);
}
exports.isArbitrary = isArbitrary;
function assertIsArbitrary(instance) {
    if (!isArbitrary(instance)) {
        throw new Error('Unexpected value received: not an instance of Arbitrary');
    }
}
exports.assertIsArbitrary = assertIsArbitrary;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\arbitrary\\definition\\Arbitrary.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\arbitrary\\definition\\Value.js", {"../../symbols":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\symbols.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Carbitrary%5Cdefinition%5CValue.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Value = void 0;
const symbols_1 = require("../../symbols");
class Value {
    constructor(value_, context, customGetValue = undefined) {
        this.value_ = value_;
        this.context = context;
        this.hasToBeCloned = customGetValue !== undefined || (0, symbols_1.hasCloneMethod)(value_);
        this.readOnce = false;
        if (this.hasToBeCloned) {
            Object.defineProperty(this, 'value', { get: customGetValue !== undefined ? customGetValue : this.getValue });
        }
        else {
            this.value = value_;
        }
    }
    getValue() {
        if (this.hasToBeCloned) {
            if (!this.readOnce) {
                this.readOnce = true;
                return this.value_;
            }
            return this.value_[symbols_1.cloneMethod]();
        }
        return this.value_;
    }
}
exports.Value = Value;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\arbitrary\\definition\\Value.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\model\\ModelRunner.js", {"./commands/ScheduledCommand":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\model\\commands\\ScheduledCommand.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cmodel%5CModelRunner.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.scheduledModelRun = exports.asyncModelRun = exports.modelRun = void 0;
const ScheduledCommand_1 = require("./commands/ScheduledCommand");
const genericModelRun = (s, cmds, initialValue, runCmd, then) => {
    return s.then((o) => {
        const { model, real } = o;
        let state = initialValue;
        for (const c of cmds) {
            state = then(state, () => {
                return runCmd(c, model, real);
            });
        }
        return state;
    });
};
const internalModelRun = (s, cmds) => {
    const then = (_p, c) => c();
    const setupProducer = {
        then: (fun) => {
            fun(s());
            return undefined;
        },
    };
    const runSync = (cmd, m, r) => {
        if (cmd.check(m))
            cmd.run(m, r);
        return undefined;
    };
    return genericModelRun(setupProducer, cmds, undefined, runSync, then);
};
const isAsyncSetup = (s) => {
    return typeof s.then === 'function';
};
const internalAsyncModelRun = async (s, cmds, defaultPromise = Promise.resolve()) => {
    const then = (p, c) => p.then(c);
    const setupProducer = {
        then: (fun) => {
            const out = s();
            if (isAsyncSetup(out))
                return out.then(fun);
            else
                return fun(out);
        },
    };
    const runAsync = async (cmd, m, r) => {
        if (await cmd.check(m))
            await cmd.run(m, r);
    };
    return await genericModelRun(setupProducer, cmds, defaultPromise, runAsync, then);
};
function modelRun(s, cmds) {
    internalModelRun(s, cmds);
}
exports.modelRun = modelRun;
async function asyncModelRun(s, cmds) {
    await internalAsyncModelRun(s, cmds);
}
exports.asyncModelRun = asyncModelRun;
async function scheduledModelRun(scheduler, s, cmds) {
    const scheduledCommands = (0, ScheduledCommand_1.scheduleCommands)(scheduler, cmds);
    const out = internalAsyncModelRun(s, scheduledCommands, scheduler.schedule(Promise.resolve(), 'startModel'));
    await scheduler.waitAll();
    await out;
}
exports.scheduledModelRun = scheduledModelRun;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\model\\ModelRunner.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\model\\ReplayPath.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cmodel%5CReplayPath.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReplayPath = void 0;
class ReplayPath {
    static parse(replayPathStr) {
        const [serializedCount, serializedChanges] = replayPathStr.split(':');
        const counts = this.parseCounts(serializedCount);
        const changes = this.parseChanges(serializedChanges);
        return this.parseOccurences(counts, changes);
    }
    static stringify(replayPath) {
        const occurences = this.countOccurences(replayPath);
        const serializedCount = this.stringifyCounts(occurences);
        const serializedChanges = this.stringifyChanges(occurences);
        return `${serializedCount}:${serializedChanges}`;
    }
    static intToB64(n) {
        if (n < 26)
            return String.fromCharCode(n + 65);
        if (n < 52)
            return String.fromCharCode(n + 97 - 26);
        if (n < 62)
            return String.fromCharCode(n + 48 - 52);
        return String.fromCharCode(n === 62 ? 43 : 47);
    }
    static b64ToInt(c) {
        if (c >= 'a')
            return c.charCodeAt(0) - 97 + 26;
        if (c >= 'A')
            return c.charCodeAt(0) - 65;
        if (c >= '0')
            return c.charCodeAt(0) - 48 + 52;
        return c === '+' ? 62 : 63;
    }
    static countOccurences(replayPath) {
        return replayPath.reduce((counts, cur) => {
            if (counts.length === 0 || counts[counts.length - 1].count === 64 || counts[counts.length - 1].value !== cur)
                counts.push({ value: cur, count: 1 });
            else
                counts[counts.length - 1].count += 1;
            return counts;
        }, []);
    }
    static parseOccurences(counts, changes) {
        const replayPath = [];
        for (let idx = 0; idx !== counts.length; ++idx) {
            const count = counts[idx];
            const value = changes[idx];
            for (let num = 0; num !== count; ++num)
                replayPath.push(value);
        }
        return replayPath;
    }
    static stringifyChanges(occurences) {
        let serializedChanges = '';
        for (let idx = 0; idx < occurences.length; idx += 6) {
            const changesInt = occurences
                .slice(idx, idx + 6)
                .reduceRight((prev, cur) => prev * 2 + (cur.value ? 1 : 0), 0);
            serializedChanges += this.intToB64(changesInt);
        }
        return serializedChanges;
    }
    static parseChanges(serializedChanges) {
        const changesInt = serializedChanges.split('').map((c) => this.b64ToInt(c));
        const changes = [];
        for (let idx = 0; idx !== changesInt.length; ++idx) {
            let current = changesInt[idx];
            for (let n = 0; n !== 6; ++n, current >>= 1) {
                changes.push(current % 2 === 1);
            }
        }
        return changes;
    }
    static stringifyCounts(occurences) {
        return occurences.map(({ count }) => this.intToB64(count - 1)).join('');
    }
    static parseCounts(serializedCount) {
        return serializedCount.split('').map((c) => this.b64ToInt(c) + 1);
    }
}
exports.ReplayPath = ReplayPath;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\model\\ReplayPath.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\model\\commands\\CommandWrapper.js", {"../../../utils/stringify":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\utils\\stringify.js","../../symbols":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\symbols.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cmodel%5Ccommands%5CCommandWrapper.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandWrapper = void 0;
const stringify_1 = require("../../../utils/stringify");
const symbols_1 = require("../../symbols");
class CommandWrapper {
    constructor(cmd) {
        this.cmd = cmd;
        this.hasRan = false;
        if ((0, stringify_1.hasToStringMethod)(cmd)) {
            const method = cmd[stringify_1.toStringMethod];
            this[stringify_1.toStringMethod] = function toStringMethod() {
                return method.call(cmd);
            };
        }
        if ((0, stringify_1.hasAsyncToStringMethod)(cmd)) {
            const method = cmd[stringify_1.asyncToStringMethod];
            this[stringify_1.asyncToStringMethod] = function asyncToStringMethod() {
                return method.call(cmd);
            };
        }
    }
    check(m) {
        return this.cmd.check(m);
    }
    run(m, r) {
        this.hasRan = true;
        return this.cmd.run(m, r);
    }
    clone() {
        if ((0, symbols_1.hasCloneMethod)(this.cmd))
            return new CommandWrapper(this.cmd[symbols_1.cloneMethod]());
        return new CommandWrapper(this.cmd);
    }
    toString() {
        return this.cmd.toString();
    }
}
exports.CommandWrapper = CommandWrapper;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\model\\commands\\CommandWrapper.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\model\\commands\\CommandsIterable.js", {"../../symbols":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\symbols.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cmodel%5Ccommands%5CCommandsIterable.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandsIterable = void 0;
const symbols_1 = require("../../symbols");
class CommandsIterable {
    constructor(commands, metadataForReplay) {
        this.commands = commands;
        this.metadataForReplay = metadataForReplay;
    }
    [Symbol.iterator]() {
        return this.commands[Symbol.iterator]();
    }
    [symbols_1.cloneMethod]() {
        return new CommandsIterable(this.commands.map((c) => c.clone()), this.metadataForReplay);
    }
    toString() {
        const serializedCommands = this.commands
            .filter((c) => c.hasRan)
            .map((c) => c.toString())
            .join(',');
        const metadata = this.metadataForReplay();
        return metadata.length !== 0 ? `${serializedCommands} /*${metadata}*/` : serializedCommands;
    }
}
exports.CommandsIterable = CommandsIterable;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\model\\commands\\CommandsIterable.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\model\\commands\\ScheduledCommand.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cmodel%5Ccommands%5CScheduledCommand.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.scheduleCommands = exports.ScheduledCommand = void 0;
class ScheduledCommand {
    constructor(s, cmd) {
        this.s = s;
        this.cmd = cmd;
    }
    async check(m) {
        let error = null;
        let checkPassed = false;
        const status = await this.s.scheduleSequence([
            {
                label: `check@${this.cmd.toString()}`,
                builder: async () => {
                    try {
                        checkPassed = await Promise.resolve(this.cmd.check(m));
                    }
                    catch (err) {
                        error = err;
                        throw err;
                    }
                },
            },
        ]).task;
        if (status.faulty) {
            throw error;
        }
        return checkPassed;
    }
    async run(m, r) {
        let error = null;
        const status = await this.s.scheduleSequence([
            {
                label: `run@${this.cmd.toString()}`,
                builder: async () => {
                    try {
                        await this.cmd.run(m, r);
                    }
                    catch (err) {
                        error = err;
                        throw err;
                    }
                },
            },
        ]).task;
        if (status.faulty) {
            throw error;
        }
    }
}
exports.ScheduledCommand = ScheduledCommand;
const scheduleCommands = function* (s, cmds) {
    for (const cmd of cmds) {
        yield new ScheduledCommand(s, cmd);
    }
};
exports.scheduleCommands = scheduleCommands;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\model\\commands\\ScheduledCommand.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\precondition\\Pre.js", {"./PreconditionFailure":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\precondition\\PreconditionFailure.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cprecondition%5CPre.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pre = void 0;
const PreconditionFailure_1 = require("./PreconditionFailure");
function pre(expectTruthy) {
    if (!expectTruthy) {
        throw new PreconditionFailure_1.PreconditionFailure();
    }
}
exports.pre = pre;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\precondition\\Pre.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\precondition\\PreconditionFailure.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cprecondition%5CPreconditionFailure.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PreconditionFailure = void 0;
class PreconditionFailure extends Error {
    constructor(interruptExecution = false) {
        super();
        this.interruptExecution = interruptExecution;
        this.footprint = PreconditionFailure.SharedFootPrint;
    }
    static isFailure(err) {
        return err != null && err.footprint === PreconditionFailure.SharedFootPrint;
    }
}
exports.PreconditionFailure = PreconditionFailure;
PreconditionFailure.SharedFootPrint = Symbol('fast-check/PreconditionFailure');

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\precondition\\PreconditionFailure.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\property\\AsyncProperty.generic.js", {"../../arbitrary/_internals/helpers/NoUndefinedAsContext":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\NoUndefinedAsContext.js","../../stream/Stream":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\stream\\Stream.js","../precondition/PreconditionFailure":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\precondition\\PreconditionFailure.js","../runner/configuration/GlobalParameters":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\GlobalParameters.js","./IRawProperty":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\property\\IRawProperty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cproperty%5CAsyncProperty.generic.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncProperty = void 0;
const PreconditionFailure_1 = require("../precondition/PreconditionFailure");
const IRawProperty_1 = require("./IRawProperty");
const GlobalParameters_1 = require("../runner/configuration/GlobalParameters");
const Stream_1 = require("../../stream/Stream");
const NoUndefinedAsContext_1 = require("../../arbitrary/_internals/helpers/NoUndefinedAsContext");
class AsyncProperty {
    constructor(arb, predicate) {
        this.arb = arb;
        this.predicate = predicate;
        const { asyncBeforeEach, asyncAfterEach, beforeEach, afterEach } = (0, GlobalParameters_1.readConfigureGlobal)() || {};
        if (asyncBeforeEach !== undefined && beforeEach !== undefined) {
            throw Error('Global "asyncBeforeEach" and "beforeEach" parameters can\'t be set at the same time when running async properties');
        }
        if (asyncAfterEach !== undefined && afterEach !== undefined) {
            throw Error('Global "asyncAfterEach" and "afterEach" parameters can\'t be set at the same time when running async properties');
        }
        this.beforeEachHook = asyncBeforeEach || beforeEach || AsyncProperty.dummyHook;
        this.afterEachHook = asyncAfterEach || afterEach || AsyncProperty.dummyHook;
    }
    isAsync() {
        return true;
    }
    generate(mrng, runId) {
        const value = this.arb.generate(mrng, runId != null ? (0, IRawProperty_1.runIdToFrequency)(runId) : undefined);
        return (0, NoUndefinedAsContext_1.noUndefinedAsContext)(value);
    }
    shrink(value) {
        if (value.context === undefined && !this.arb.canShrinkWithoutContext(value.value_)) {
            return Stream_1.Stream.nil();
        }
        const safeContext = value.context !== NoUndefinedAsContext_1.UndefinedContextPlaceholder ? value.context : undefined;
        return this.arb.shrink(value.value_, safeContext).map(NoUndefinedAsContext_1.noUndefinedAsContext);
    }
    async run(v) {
        await this.beforeEachHook();
        try {
            const output = await this.predicate(v);
            return output == null || output === true
                ? null
                : { error: undefined, errorMessage: 'Property failed by returning false' };
        }
        catch (err) {
            if (PreconditionFailure_1.PreconditionFailure.isFailure(err))
                return err;
            if (err instanceof Error && err.stack) {
                return { error: err, errorMessage: `${err}\n\nStack trace: ${err.stack}` };
            }
            return { error: err, errorMessage: String(err) };
        }
        finally {
            await this.afterEachHook();
        }
    }
    beforeEach(hookFunction) {
        const previousBeforeEachHook = this.beforeEachHook;
        this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
        return this;
    }
    afterEach(hookFunction) {
        const previousAfterEachHook = this.afterEachHook;
        this.afterEachHook = () => hookFunction(previousAfterEachHook);
        return this;
    }
}
exports.AsyncProperty = AsyncProperty;
AsyncProperty.dummyHook = () => { };

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\property\\AsyncProperty.generic.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\property\\AsyncProperty.js", {"../../arbitrary/_internals/AlwaysShrinkableArbitrary":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\AlwaysShrinkableArbitrary.js","../../arbitrary/tuple":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\tuple.js","../arbitrary/definition/Arbitrary":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\arbitrary\\definition\\Arbitrary.js","./AsyncProperty.generic":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\property\\AsyncProperty.generic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cproperty%5CAsyncProperty.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.asyncProperty = void 0;
const Arbitrary_1 = require("../arbitrary/definition/Arbitrary");
const tuple_1 = require("../../arbitrary/tuple");
const AsyncProperty_generic_1 = require("./AsyncProperty.generic");
const AlwaysShrinkableArbitrary_1 = require("../../arbitrary/_internals/AlwaysShrinkableArbitrary");
function asyncProperty(...args) {
    if (args.length < 2) {
        throw new Error('asyncProperty expects at least two parameters');
    }
    const arbs = args.slice(0, args.length - 1);
    const p = args[args.length - 1];
    arbs.forEach(Arbitrary_1.assertIsArbitrary);
    const mappedArbs = arbs.map((arb) => new AlwaysShrinkableArbitrary_1.AlwaysShrinkableArbitrary(arb));
    return new AsyncProperty_generic_1.AsyncProperty((0, tuple_1.tuple)(...mappedArbs), (t) => p(...t));
}
exports.asyncProperty = asyncProperty;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\property\\AsyncProperty.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\property\\IRawProperty.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cproperty%5CIRawProperty.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runIdToFrequency = void 0;
const runIdToFrequency = (runId) => 2 + Math.floor(Math.log(runId + 1) / Math.log(10));
exports.runIdToFrequency = runIdToFrequency;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\property\\IRawProperty.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\property\\IgnoreEqualValuesProperty.js", {"../../utils/stringify":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\utils\\stringify.js","../precondition/PreconditionFailure":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\precondition\\PreconditionFailure.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cproperty%5CIgnoreEqualValuesProperty.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IgnoreEqualValuesProperty = void 0;
const stringify_1 = require("../../utils/stringify");
const PreconditionFailure_1 = require("../precondition/PreconditionFailure");
function fromSyncCached(cachedValue) {
    return cachedValue === null ? new PreconditionFailure_1.PreconditionFailure() : cachedValue;
}
function fromCached(...data) {
    if (data[1])
        return data[0].then(fromSyncCached);
    return fromSyncCached(data[0]);
}
function fromCachedUnsafe(cachedValue, isAsync) {
    return fromCached(cachedValue, isAsync);
}
class IgnoreEqualValuesProperty {
    constructor(property, skipRuns) {
        this.property = property;
        this.skipRuns = skipRuns;
        this.coveredCases = new Map();
    }
    isAsync() {
        return this.property.isAsync();
    }
    generate(mrng, runId) {
        return this.property.generate(mrng, runId);
    }
    shrink(value) {
        return this.property.shrink(value);
    }
    run(v) {
        const stringifiedValue = (0, stringify_1.stringify)(v);
        if (this.coveredCases.has(stringifiedValue)) {
            const lastOutput = this.coveredCases.get(stringifiedValue);
            if (!this.skipRuns) {
                return lastOutput;
            }
            return fromCachedUnsafe(lastOutput, this.property.isAsync());
        }
        const out = this.property.run(v);
        this.coveredCases.set(stringifiedValue, out);
        return out;
    }
}
exports.IgnoreEqualValuesProperty = IgnoreEqualValuesProperty;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\property\\IgnoreEqualValuesProperty.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\property\\Property.generic.js", {"../../arbitrary/_internals/helpers/NoUndefinedAsContext":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\NoUndefinedAsContext.js","../../stream/Stream":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\stream\\Stream.js","../precondition/PreconditionFailure":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\precondition\\PreconditionFailure.js","../runner/configuration/GlobalParameters":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\GlobalParameters.js","./IRawProperty":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\property\\IRawProperty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cproperty%5CProperty.generic.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Property = void 0;
const PreconditionFailure_1 = require("../precondition/PreconditionFailure");
const IRawProperty_1 = require("./IRawProperty");
const GlobalParameters_1 = require("../runner/configuration/GlobalParameters");
const Stream_1 = require("../../stream/Stream");
const NoUndefinedAsContext_1 = require("../../arbitrary/_internals/helpers/NoUndefinedAsContext");
class Property {
    constructor(arb, predicate) {
        this.arb = arb;
        this.predicate = predicate;
        const { beforeEach = Property.dummyHook, afterEach = Property.dummyHook, asyncBeforeEach, asyncAfterEach, } = (0, GlobalParameters_1.readConfigureGlobal)() || {};
        if (asyncBeforeEach !== undefined) {
            throw Error('"asyncBeforeEach" can\'t be set when running synchronous properties');
        }
        if (asyncAfterEach !== undefined) {
            throw Error('"asyncAfterEach" can\'t be set when running synchronous properties');
        }
        this.beforeEachHook = beforeEach;
        this.afterEachHook = afterEach;
    }
    isAsync() {
        return false;
    }
    generate(mrng, runId) {
        const value = this.arb.generate(mrng, runId != null ? (0, IRawProperty_1.runIdToFrequency)(runId) : undefined);
        return (0, NoUndefinedAsContext_1.noUndefinedAsContext)(value);
    }
    shrink(value) {
        if (value.context === undefined && !this.arb.canShrinkWithoutContext(value.value_)) {
            return Stream_1.Stream.nil();
        }
        const safeContext = value.context !== NoUndefinedAsContext_1.UndefinedContextPlaceholder ? value.context : undefined;
        return this.arb.shrink(value.value_, safeContext).map(NoUndefinedAsContext_1.noUndefinedAsContext);
    }
    run(v) {
        this.beforeEachHook();
        try {
            const output = this.predicate(v);
            return output == null || output === true
                ? null
                : { error: undefined, errorMessage: 'Property failed by returning false' };
        }
        catch (err) {
            if (PreconditionFailure_1.PreconditionFailure.isFailure(err))
                return err;
            if (err instanceof Error && err.stack) {
                return { error: err, errorMessage: `${err}\n\nStack trace: ${err.stack}` };
            }
            return { error: err, errorMessage: String(err) };
        }
        finally {
            this.afterEachHook();
        }
    }
    beforeEach(hookFunction) {
        const previousBeforeEachHook = this.beforeEachHook;
        this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
        return this;
    }
    afterEach(hookFunction) {
        const previousAfterEachHook = this.afterEachHook;
        this.afterEachHook = () => hookFunction(previousAfterEachHook);
        return this;
    }
}
exports.Property = Property;
Property.dummyHook = () => { };

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\property\\Property.generic.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\property\\Property.js", {"../../arbitrary/_internals/AlwaysShrinkableArbitrary":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\AlwaysShrinkableArbitrary.js","../../arbitrary/tuple":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\tuple.js","../arbitrary/definition/Arbitrary":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\arbitrary\\definition\\Arbitrary.js","./Property.generic":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\property\\Property.generic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cproperty%5CProperty.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.property = void 0;
const Arbitrary_1 = require("../arbitrary/definition/Arbitrary");
const tuple_1 = require("../../arbitrary/tuple");
const Property_generic_1 = require("./Property.generic");
const AlwaysShrinkableArbitrary_1 = require("../../arbitrary/_internals/AlwaysShrinkableArbitrary");
function property(...args) {
    if (args.length < 2) {
        throw new Error('property expects at least two parameters');
    }
    const arbs = args.slice(0, args.length - 1);
    const p = args[args.length - 1];
    arbs.forEach(Arbitrary_1.assertIsArbitrary);
    const mappedArbs = arbs.map((arb) => new AlwaysShrinkableArbitrary_1.AlwaysShrinkableArbitrary(arb));
    return new Property_generic_1.Property((0, tuple_1.tuple)(...mappedArbs), (t) => p(...t));
}
exports.property = property;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\property\\Property.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\property\\SkipAfterProperty.js", {"../precondition/PreconditionFailure":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\precondition\\PreconditionFailure.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cproperty%5CSkipAfterProperty.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SkipAfterProperty = void 0;
const PreconditionFailure_1 = require("../precondition/PreconditionFailure");
class SkipAfterProperty {
    constructor(property, getTime, timeLimit, interruptExecution) {
        this.property = property;
        this.getTime = getTime;
        this.interruptExecution = interruptExecution;
        this.skipAfterTime = this.getTime() + timeLimit;
    }
    isAsync() {
        return this.property.isAsync();
    }
    generate(mrng, runId) {
        return this.property.generate(mrng, runId);
    }
    shrink(value) {
        return this.property.shrink(value);
    }
    run(v) {
        if (this.getTime() >= this.skipAfterTime) {
            const preconditionFailure = new PreconditionFailure_1.PreconditionFailure(this.interruptExecution);
            if (this.isAsync()) {
                return Promise.resolve(preconditionFailure);
            }
            else {
                return preconditionFailure;
            }
        }
        return this.property.run(v);
    }
}
exports.SkipAfterProperty = SkipAfterProperty;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\property\\SkipAfterProperty.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\property\\TimeoutProperty.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cproperty%5CTimeoutProperty.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeoutProperty = void 0;
const timeoutAfter = (timeMs) => {
    let timeoutHandle = null;
    const promise = new Promise((resolve) => {
        timeoutHandle = setTimeout(() => {
            resolve({ error: undefined, errorMessage: `Property timeout: exceeded limit of ${timeMs} milliseconds` });
        }, timeMs);
    });
    return {
        clear: () => clearTimeout(timeoutHandle),
        promise,
    };
};
class TimeoutProperty {
    constructor(property, timeMs) {
        this.property = property;
        this.timeMs = timeMs;
    }
    isAsync() {
        return true;
    }
    generate(mrng, runId) {
        return this.property.generate(mrng, runId);
    }
    shrink(value) {
        return this.property.shrink(value);
    }
    async run(v) {
        const t = timeoutAfter(this.timeMs);
        const propRun = Promise.race([this.property.run(v), t.promise]);
        propRun.then(t.clear, t.clear);
        return propRun;
    }
}
exports.TimeoutProperty = TimeoutProperty;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\property\\TimeoutProperty.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\property\\UnbiasedProperty.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cproperty%5CUnbiasedProperty.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnbiasedProperty = void 0;
class UnbiasedProperty {
    constructor(property) {
        this.property = property;
    }
    isAsync() {
        return this.property.isAsync();
    }
    generate(mrng, _runId) {
        return this.property.generate(mrng, undefined);
    }
    shrink(value) {
        return this.property.shrink(value);
    }
    run(v) {
        return this.property.run(v);
    }
}
exports.UnbiasedProperty = UnbiasedProperty;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\property\\UnbiasedProperty.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\DecorateProperty.js", {"../property/IgnoreEqualValuesProperty":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\property\\IgnoreEqualValuesProperty.js","../property/SkipAfterProperty":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\property\\SkipAfterProperty.js","../property/TimeoutProperty":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\property\\TimeoutProperty.js","../property/UnbiasedProperty":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\property\\UnbiasedProperty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5CDecorateProperty.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decorateProperty = void 0;
const SkipAfterProperty_1 = require("../property/SkipAfterProperty");
const TimeoutProperty_1 = require("../property/TimeoutProperty");
const UnbiasedProperty_1 = require("../property/UnbiasedProperty");
const IgnoreEqualValuesProperty_1 = require("../property/IgnoreEqualValuesProperty");
function decorateProperty(rawProperty, qParams) {
    let prop = rawProperty;
    if (rawProperty.isAsync() && qParams.timeout != null) {
        prop = new TimeoutProperty_1.TimeoutProperty(prop, qParams.timeout);
    }
    if (qParams.unbiased) {
        prop = new UnbiasedProperty_1.UnbiasedProperty(prop);
    }
    if (qParams.skipAllAfterTimeLimit != null) {
        prop = new SkipAfterProperty_1.SkipAfterProperty(prop, Date.now, qParams.skipAllAfterTimeLimit, false);
    }
    if (qParams.interruptAfterTimeLimit != null) {
        prop = new SkipAfterProperty_1.SkipAfterProperty(prop, Date.now, qParams.interruptAfterTimeLimit, true);
    }
    if (qParams.skipEqualValues) {
        prop = new IgnoreEqualValuesProperty_1.IgnoreEqualValuesProperty(prop, true);
    }
    if (qParams.ignoreEqualValues) {
        prop = new IgnoreEqualValuesProperty_1.IgnoreEqualValuesProperty(prop, false);
    }
    return prop;
}
exports.decorateProperty = decorateProperty;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\DecorateProperty.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\Runner.js", {"../../stream/Stream":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\stream\\Stream.js","./DecorateProperty":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\DecorateProperty.js","./RunnerIterator":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\RunnerIterator.js","./SourceValuesIterator":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\SourceValuesIterator.js","./Tosser":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\Tosser.js","./configuration/GlobalParameters":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\GlobalParameters.js","./configuration/QualifiedParameters":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\QualifiedParameters.js","./utils/PathWalker":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\utils\\PathWalker.js","./utils/RunDetailsFormatter":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\utils\\RunDetailsFormatter.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5CRunner.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assert = exports.check = void 0;
const Stream_1 = require("../../stream/Stream");
const GlobalParameters_1 = require("./configuration/GlobalParameters");
const QualifiedParameters_1 = require("./configuration/QualifiedParameters");
const DecorateProperty_1 = require("./DecorateProperty");
const RunnerIterator_1 = require("./RunnerIterator");
const SourceValuesIterator_1 = require("./SourceValuesIterator");
const Tosser_1 = require("./Tosser");
const PathWalker_1 = require("./utils/PathWalker");
const RunDetailsFormatter_1 = require("./utils/RunDetailsFormatter");
function runIt(property, shrink, sourceValues, verbose, interruptedAsFailure) {
    const runner = new RunnerIterator_1.RunnerIterator(sourceValues, shrink, verbose, interruptedAsFailure);
    for (const v of runner) {
        const out = property.run(v);
        runner.handleResult(out);
    }
    return runner.runExecution;
}
async function asyncRunIt(property, shrink, sourceValues, verbose, interruptedAsFailure) {
    const runner = new RunnerIterator_1.RunnerIterator(sourceValues, shrink, verbose, interruptedAsFailure);
    for (const v of runner) {
        const out = await property.run(v);
        runner.handleResult(out);
    }
    return runner.runExecution;
}
function runnerPathWalker(valueProducers, shrink, path) {
    const pathPoints = path.split(':');
    const pathStream = (0, Stream_1.stream)(valueProducers)
        .drop(pathPoints.length > 0 ? +pathPoints[0] : 0)
        .map((producer) => producer());
    const adaptedPath = ['0', ...pathPoints.slice(1)].join(':');
    return (0, Stream_1.stream)((0, PathWalker_1.pathWalk)(adaptedPath, pathStream, shrink)).map((v) => () => v);
}
function buildInitialValues(valueProducers, shrink, qParams) {
    if (qParams.path.length === 0) {
        return (0, Stream_1.stream)(valueProducers);
    }
    return runnerPathWalker(valueProducers, shrink, qParams.path);
}
function check(rawProperty, params) {
    if (rawProperty == null || rawProperty.generate == null)
        throw new Error('Invalid property encountered, please use a valid property');
    if (rawProperty.run == null)
        throw new Error('Invalid property encountered, please use a valid property not an arbitrary');
    const qParams = QualifiedParameters_1.QualifiedParameters.read(Object.assign(Object.assign({}, (0, GlobalParameters_1.readConfigureGlobal)()), params));
    if (qParams.reporter !== null && qParams.asyncReporter !== null)
        throw new Error('Invalid parameters encountered, reporter and asyncReporter cannot be specified together');
    if (qParams.asyncReporter !== null && !rawProperty.isAsync())
        throw new Error('Invalid parameters encountered, only asyncProperty can be used when asyncReporter specified');
    const property = (0, DecorateProperty_1.decorateProperty)(rawProperty, qParams);
    const generator = (0, Tosser_1.toss)(property, qParams.seed, qParams.randomType, qParams.examples);
    const maxInitialIterations = qParams.path.indexOf(':') === -1 ? qParams.numRuns : -1;
    const maxSkips = qParams.numRuns * qParams.maxSkipsPerRun;
    const shrink = property.shrink.bind(property);
    const initialValues = buildInitialValues(generator, shrink, qParams);
    const sourceValues = new SourceValuesIterator_1.SourceValuesIterator(initialValues, maxInitialIterations, maxSkips);
    const finalShrink = !qParams.endOnFailure ? shrink : Stream_1.Stream.nil;
    return property.isAsync()
        ? asyncRunIt(property, finalShrink, sourceValues, qParams.verbose, qParams.markInterruptAsFailure).then((e) => e.toRunDetails(qParams.seed, qParams.path, maxSkips, qParams))
        : runIt(property, finalShrink, sourceValues, qParams.verbose, qParams.markInterruptAsFailure).toRunDetails(qParams.seed, qParams.path, maxSkips, qParams);
}
exports.check = check;
function assert(property, params) {
    const out = check(property, params);
    if (property.isAsync())
        return out.then(RunDetailsFormatter_1.asyncReportRunDetails);
    else
        (0, RunDetailsFormatter_1.reportRunDetails)(out);
}
exports.assert = assert;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\Runner.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\RunnerIterator.js", {"../precondition/PreconditionFailure":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\precondition\\PreconditionFailure.js","./reporter/RunExecution":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\reporter\\RunExecution.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5CRunnerIterator.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RunnerIterator = void 0;
const PreconditionFailure_1 = require("../precondition/PreconditionFailure");
const RunExecution_1 = require("./reporter/RunExecution");
class RunnerIterator {
    constructor(sourceValues, shrink, verbose, interruptedAsFailure) {
        this.sourceValues = sourceValues;
        this.shrink = shrink;
        this.runExecution = new RunExecution_1.RunExecution(verbose, interruptedAsFailure);
        this.currentIdx = -1;
        this.nextValues = sourceValues;
    }
    [Symbol.iterator]() {
        return this;
    }
    next() {
        const nextValue = this.nextValues.next();
        if (nextValue.done || this.runExecution.interrupted) {
            return { done: true, value: undefined };
        }
        this.currentValue = nextValue.value;
        ++this.currentIdx;
        return { done: false, value: nextValue.value.value_ };
    }
    handleResult(result) {
        if (result != null && typeof result === 'object' && !PreconditionFailure_1.PreconditionFailure.isFailure(result)) {
            this.runExecution.fail(this.currentValue.value_, this.currentIdx, result);
            this.currentIdx = -1;
            this.nextValues = this.shrink(this.currentValue);
        }
        else if (result != null) {
            if (!result.interruptExecution) {
                this.runExecution.skip(this.currentValue.value_);
                this.sourceValues.skippedOne();
            }
            else {
                this.runExecution.interrupt();
            }
        }
        else {
            this.runExecution.success(this.currentValue.value_);
        }
    }
}
exports.RunnerIterator = RunnerIterator;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\RunnerIterator.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\Sampler.js", {"../../stream/Stream":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\stream\\Stream.js","../property/Property.generic":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\property\\Property.generic.js","../property/UnbiasedProperty":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\property\\UnbiasedProperty.js","./Tosser":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\Tosser.js","./configuration/GlobalParameters":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\GlobalParameters.js","./configuration/QualifiedParameters":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\QualifiedParameters.js","./utils/PathWalker":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\utils\\PathWalker.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5CSampler.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.statistics = exports.sample = void 0;
const Stream_1 = require("../../stream/Stream");
const Property_generic_1 = require("../property/Property.generic");
const UnbiasedProperty_1 = require("../property/UnbiasedProperty");
const GlobalParameters_1 = require("./configuration/GlobalParameters");
const QualifiedParameters_1 = require("./configuration/QualifiedParameters");
const Tosser_1 = require("./Tosser");
const PathWalker_1 = require("./utils/PathWalker");
function toProperty(generator, qParams) {
    const prop = !Object.prototype.hasOwnProperty.call(generator, 'isAsync')
        ? new Property_generic_1.Property(generator, () => true)
        : generator;
    return qParams.unbiased === true ? new UnbiasedProperty_1.UnbiasedProperty(prop) : prop;
}
function streamSample(generator, params) {
    const extendedParams = typeof params === 'number'
        ? Object.assign(Object.assign({}, (0, GlobalParameters_1.readConfigureGlobal)()), { numRuns: params }) : Object.assign(Object.assign({}, (0, GlobalParameters_1.readConfigureGlobal)()), params);
    const qParams = QualifiedParameters_1.QualifiedParameters.read(extendedParams);
    const nextProperty = toProperty(generator, qParams);
    const shrink = nextProperty.shrink.bind(nextProperty);
    const tossedValues = (0, Stream_1.stream)((0, Tosser_1.toss)(nextProperty, qParams.seed, qParams.randomType, qParams.examples));
    if (qParams.path.length === 0) {
        return tossedValues.take(qParams.numRuns).map((s) => s().value_);
    }
    return (0, Stream_1.stream)((0, PathWalker_1.pathWalk)(qParams.path, tossedValues.map((s) => s()), shrink))
        .take(qParams.numRuns)
        .map((s) => s.value_);
}
function sample(generator, params) {
    return [...streamSample(generator, params)];
}
exports.sample = sample;
function round2(n) {
    return (Math.round(n * 100) / 100).toFixed(2);
}
function statistics(generator, classify, params) {
    const extendedParams = typeof params === 'number'
        ? Object.assign(Object.assign({}, (0, GlobalParameters_1.readConfigureGlobal)()), { numRuns: params }) : Object.assign(Object.assign({}, (0, GlobalParameters_1.readConfigureGlobal)()), params);
    const qParams = QualifiedParameters_1.QualifiedParameters.read(extendedParams);
    const recorded = {};
    for (const g of streamSample(generator, params)) {
        const out = classify(g);
        const categories = Array.isArray(out) ? out : [out];
        for (const c of categories) {
            recorded[c] = (recorded[c] || 0) + 1;
        }
    }
    const data = Object.entries(recorded)
        .sort((a, b) => b[1] - a[1])
        .map((i) => [i[0], `${round2((i[1] * 100.0) / qParams.numRuns)}%`]);
    const longestName = data.map((i) => i[0].length).reduce((p, c) => Math.max(p, c), 0);
    const longestPercent = data.map((i) => i[1].length).reduce((p, c) => Math.max(p, c), 0);
    for (const item of data) {
        qParams.logger(`${item[0].padEnd(longestName, '.')}..${item[1].padStart(longestPercent, '.')}`);
    }
}
exports.statistics = statistics;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\Sampler.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\SourceValuesIterator.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5CSourceValuesIterator.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceValuesIterator = void 0;
class SourceValuesIterator {
    constructor(initialValues, maxInitialIterations, remainingSkips) {
        this.initialValues = initialValues;
        this.maxInitialIterations = maxInitialIterations;
        this.remainingSkips = remainingSkips;
    }
    [Symbol.iterator]() {
        return this;
    }
    next() {
        if (--this.maxInitialIterations !== -1 && this.remainingSkips >= 0) {
            const n = this.initialValues.next();
            if (!n.done)
                return { value: n.value(), done: false };
        }
        return { value: undefined, done: true };
    }
    skippedOne() {
        --this.remainingSkips;
        ++this.maxInitialIterations;
    }
}
exports.SourceValuesIterator = SourceValuesIterator;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\SourceValuesIterator.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\Tosser.js", {"../../random/generator/Random":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\random\\generator\\Random.js","../arbitrary/definition/Value":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\arbitrary\\definition\\Value.js","pure-rand":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\pure-rand.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5CTosser.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toss = void 0;
const pure_rand_1 = require("pure-rand");
const Random_1 = require("../../random/generator/Random");
const Value_1 = require("../arbitrary/definition/Value");
function lazyGenerate(generator, rng, idx) {
    return () => generator.generate(new Random_1.Random(rng), idx);
}
function* toss(generator, seed, random, examples) {
    yield* examples.map((e) => () => new Value_1.Value(e, undefined));
    let idx = 0;
    let rng = random(seed);
    for (;;) {
        rng = rng.jump ? rng.jump() : (0, pure_rand_1.skipN)(rng, 42);
        yield lazyGenerate(generator, rng, idx++);
    }
}
exports.toss = toss;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\Tosser.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\GlobalParameters.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5Cconfiguration%5CGlobalParameters.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resetConfigureGlobal = exports.readConfigureGlobal = exports.configureGlobal = void 0;
let globalParameters = {};
function configureGlobal(parameters) {
    globalParameters = parameters;
}
exports.configureGlobal = configureGlobal;
function readConfigureGlobal() {
    return globalParameters;
}
exports.readConfigureGlobal = readConfigureGlobal;
function resetConfigureGlobal() {
    globalParameters = {};
}
exports.resetConfigureGlobal = resetConfigureGlobal;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\configuration\\GlobalParameters.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\QualifiedParameters.js", {"./VerbosityLevel":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\VerbosityLevel.js","pure-rand":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\pure-rand.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5Cconfiguration%5CQualifiedParameters.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QualifiedParameters = void 0;
const pure_rand_1 = require("pure-rand");
const VerbosityLevel_1 = require("./VerbosityLevel");
class QualifiedParameters {
    constructor(op) {
        const p = op || {};
        this.seed = QualifiedParameters.readSeed(p);
        this.randomType = QualifiedParameters.readRandomType(p);
        this.numRuns = QualifiedParameters.readNumRuns(p);
        this.verbose = QualifiedParameters.readVerbose(p);
        this.maxSkipsPerRun = QualifiedParameters.readOrDefault(p, 'maxSkipsPerRun', 100);
        this.timeout = QualifiedParameters.readOrDefault(p, 'timeout', null);
        this.skipAllAfterTimeLimit = QualifiedParameters.readOrDefault(p, 'skipAllAfterTimeLimit', null);
        this.interruptAfterTimeLimit = QualifiedParameters.readOrDefault(p, 'interruptAfterTimeLimit', null);
        this.markInterruptAsFailure = QualifiedParameters.readBoolean(p, 'markInterruptAsFailure');
        this.skipEqualValues = QualifiedParameters.readBoolean(p, 'skipEqualValues');
        this.ignoreEqualValues = QualifiedParameters.readBoolean(p, 'ignoreEqualValues');
        this.logger = QualifiedParameters.readOrDefault(p, 'logger', (v) => {
            console.log(v);
        });
        this.path = QualifiedParameters.readOrDefault(p, 'path', '');
        this.unbiased = QualifiedParameters.readBoolean(p, 'unbiased');
        this.examples = QualifiedParameters.readOrDefault(p, 'examples', []);
        this.endOnFailure = QualifiedParameters.readBoolean(p, 'endOnFailure');
        this.reporter = QualifiedParameters.readOrDefault(p, 'reporter', null);
        this.asyncReporter = QualifiedParameters.readOrDefault(p, 'asyncReporter', null);
    }
    toParameters() {
        const orUndefined = (value) => (value !== null ? value : undefined);
        return {
            seed: this.seed,
            randomType: this.randomType,
            numRuns: this.numRuns,
            maxSkipsPerRun: this.maxSkipsPerRun,
            timeout: orUndefined(this.timeout),
            skipAllAfterTimeLimit: orUndefined(this.skipAllAfterTimeLimit),
            interruptAfterTimeLimit: orUndefined(this.interruptAfterTimeLimit),
            markInterruptAsFailure: this.markInterruptAsFailure,
            skipEqualValues: this.skipEqualValues,
            ignoreEqualValues: this.ignoreEqualValues,
            path: this.path,
            logger: this.logger,
            unbiased: this.unbiased,
            verbose: this.verbose,
            examples: this.examples,
            endOnFailure: this.endOnFailure,
            reporter: orUndefined(this.reporter),
            asyncReporter: orUndefined(this.asyncReporter),
        };
    }
    static read(op) {
        return new QualifiedParameters(op);
    }
}
exports.QualifiedParameters = QualifiedParameters;
QualifiedParameters.readSeed = (p) => {
    if (p.seed == null)
        return Date.now() ^ (Math.random() * 0x100000000);
    const seed32 = p.seed | 0;
    if (p.seed === seed32)
        return seed32;
    const gap = p.seed - seed32;
    return seed32 ^ (gap * 0x100000000);
};
QualifiedParameters.readRandomType = (p) => {
    if (p.randomType == null)
        return pure_rand_1.default.xorshift128plus;
    if (typeof p.randomType === 'string') {
        switch (p.randomType) {
            case 'mersenne':
                return pure_rand_1.default.mersenne;
            case 'congruential':
                return pure_rand_1.default.congruential;
            case 'congruential32':
                return pure_rand_1.default.congruential32;
            case 'xorshift128plus':
                return pure_rand_1.default.xorshift128plus;
            case 'xoroshiro128plus':
                return pure_rand_1.default.xoroshiro128plus;
            default:
                throw new Error(`Invalid random specified: '${p.randomType}'`);
        }
    }
    return p.randomType;
};
QualifiedParameters.readNumRuns = (p) => {
    const defaultValue = 100;
    if (p.numRuns != null)
        return p.numRuns;
    if (p.num_runs != null)
        return p.num_runs;
    return defaultValue;
};
QualifiedParameters.readVerbose = (p) => {
    if (p.verbose == null)
        return VerbosityLevel_1.VerbosityLevel.None;
    if (typeof p.verbose === 'boolean') {
        return p.verbose === true ? VerbosityLevel_1.VerbosityLevel.Verbose : VerbosityLevel_1.VerbosityLevel.None;
    }
    if (p.verbose <= VerbosityLevel_1.VerbosityLevel.None) {
        return VerbosityLevel_1.VerbosityLevel.None;
    }
    if (p.verbose >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
        return VerbosityLevel_1.VerbosityLevel.VeryVerbose;
    }
    return p.verbose | 0;
};
QualifiedParameters.readBoolean = (p, key) => p[key] === true;
QualifiedParameters.readOrDefault = (p, key, defaultValue) => {
    const value = p[key];
    return value != null ? value : defaultValue;
};

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\configuration\\QualifiedParameters.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\VerbosityLevel.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5Cconfiguration%5CVerbosityLevel.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VerbosityLevel = void 0;
var VerbosityLevel;
(function (VerbosityLevel) {
    VerbosityLevel[VerbosityLevel["None"] = 0] = "None";
    VerbosityLevel[VerbosityLevel["Verbose"] = 1] = "Verbose";
    VerbosityLevel[VerbosityLevel["VeryVerbose"] = 2] = "VeryVerbose";
})(VerbosityLevel = exports.VerbosityLevel || (exports.VerbosityLevel = {}));

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\configuration\\VerbosityLevel.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\reporter\\ExecutionStatus.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5Creporter%5CExecutionStatus.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecutionStatus = void 0;
var ExecutionStatus;
(function (ExecutionStatus) {
    ExecutionStatus[ExecutionStatus["Success"] = 0] = "Success";
    ExecutionStatus[ExecutionStatus["Skipped"] = -1] = "Skipped";
    ExecutionStatus[ExecutionStatus["Failure"] = 1] = "Failure";
})(ExecutionStatus = exports.ExecutionStatus || (exports.ExecutionStatus = {}));

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\reporter\\ExecutionStatus.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\reporter\\RunExecution.js", {"../configuration/VerbosityLevel":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\VerbosityLevel.js","./ExecutionStatus":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\reporter\\ExecutionStatus.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5Creporter%5CRunExecution.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RunExecution = void 0;
const VerbosityLevel_1 = require("../configuration/VerbosityLevel");
const ExecutionStatus_1 = require("./ExecutionStatus");
class RunExecution {
    constructor(verbosity, interruptedAsFailure) {
        this.verbosity = verbosity;
        this.interruptedAsFailure = interruptedAsFailure;
        this.isSuccess = () => this.pathToFailure == null;
        this.firstFailure = () => (this.pathToFailure ? +this.pathToFailure.split(':')[0] : -1);
        this.numShrinks = () => (this.pathToFailure ? this.pathToFailure.split(':').length - 1 : 0);
        this.rootExecutionTrees = [];
        this.currentLevelExecutionTrees = this.rootExecutionTrees;
        this.failure = null;
        this.numSkips = 0;
        this.numSuccesses = 0;
        this.interrupted = false;
    }
    appendExecutionTree(status, value) {
        const currentTree = { status, value, children: [] };
        this.currentLevelExecutionTrees.push(currentTree);
        return currentTree;
    }
    fail(value, id, failure) {
        if (this.verbosity >= VerbosityLevel_1.VerbosityLevel.Verbose) {
            const currentTree = this.appendExecutionTree(ExecutionStatus_1.ExecutionStatus.Failure, value);
            this.currentLevelExecutionTrees = currentTree.children;
        }
        if (this.pathToFailure == null)
            this.pathToFailure = `${id}`;
        else
            this.pathToFailure += `:${id}`;
        this.value = value;
        this.failure = failure;
    }
    skip(value) {
        if (this.verbosity >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
            this.appendExecutionTree(ExecutionStatus_1.ExecutionStatus.Skipped, value);
        }
        if (this.pathToFailure == null) {
            ++this.numSkips;
        }
    }
    success(value) {
        if (this.verbosity >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
            this.appendExecutionTree(ExecutionStatus_1.ExecutionStatus.Success, value);
        }
        if (this.pathToFailure == null) {
            ++this.numSuccesses;
        }
    }
    interrupt() {
        this.interrupted = true;
    }
    extractFailures() {
        if (this.isSuccess()) {
            return [];
        }
        const failures = [];
        let cursor = this.rootExecutionTrees;
        while (cursor.length > 0 && cursor[cursor.length - 1].status === ExecutionStatus_1.ExecutionStatus.Failure) {
            const failureTree = cursor[cursor.length - 1];
            failures.push(failureTree.value);
            cursor = failureTree.children;
        }
        return failures;
    }
    toRunDetails(seed, basePath, maxSkips, qParams) {
        if (!this.isSuccess()) {
            return {
                failed: true,
                interrupted: this.interrupted,
                numRuns: this.firstFailure() + 1 - this.numSkips,
                numSkips: this.numSkips,
                numShrinks: this.numShrinks(),
                seed,
                counterexample: this.value,
                counterexamplePath: RunExecution.mergePaths(basePath, this.pathToFailure),
                error: this.failure.errorMessage,
                errorInstance: this.failure.error,
                failures: this.extractFailures(),
                executionSummary: this.rootExecutionTrees,
                verbose: this.verbosity,
                runConfiguration: qParams.toParameters(),
            };
        }
        const failed = this.numSkips > maxSkips || (this.interrupted && this.interruptedAsFailure);
        return {
            failed,
            interrupted: this.interrupted,
            numRuns: this.numSuccesses,
            numSkips: this.numSkips,
            numShrinks: 0,
            seed,
            counterexample: null,
            counterexamplePath: null,
            error: null,
            errorInstance: null,
            failures: [],
            executionSummary: this.rootExecutionTrees,
            verbose: this.verbosity,
            runConfiguration: qParams.toParameters(),
        };
    }
}
exports.RunExecution = RunExecution;
RunExecution.mergePaths = (offsetPath, path) => {
    if (offsetPath.length === 0)
        return path;
    const offsetItems = offsetPath.split(':');
    const remainingItems = path.split(':');
    const middle = +offsetItems[offsetItems.length - 1] + +remainingItems[0];
    return [...offsetItems.slice(0, offsetItems.length - 1), `${middle}`, ...remainingItems.slice(1)].join(':');
};

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\reporter\\RunExecution.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\utils\\PathWalker.js", {"../../../stream/Stream":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\stream\\Stream.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5Cutils%5CPathWalker.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pathWalk = void 0;
const Stream_1 = require("../../../stream/Stream");
function pathWalk(path, initialValues, shrink) {
    let values = (0, Stream_1.stream)(initialValues);
    const segments = path.split(':').map((text) => +text);
    if (segments.length === 0)
        return values;
    if (!segments.every((v) => !Number.isNaN(v))) {
        throw new Error(`Unable to replay, got invalid path=${path}`);
    }
    values = values.drop(segments[0]);
    for (const s of segments.slice(1)) {
        const valueToShrink = values.getNthOrLast(0);
        if (valueToShrink == null) {
            throw new Error(`Unable to replay, got wrong path=${path}`);
        }
        values = shrink(valueToShrink).drop(s);
    }
    return values;
}
exports.pathWalk = pathWalk;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\utils\\PathWalker.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\utils\\RunDetailsFormatter.js", {"../../../utils/stringify":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\utils\\stringify.js","../configuration/VerbosityLevel":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\VerbosityLevel.js","../reporter/ExecutionStatus":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\reporter\\ExecutionStatus.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5Cutils%5CRunDetailsFormatter.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.asyncDefaultReportMessage = exports.defaultReportMessage = exports.asyncReportRunDetails = exports.reportRunDetails = void 0;
const stringify_1 = require("../../../utils/stringify");
const VerbosityLevel_1 = require("../configuration/VerbosityLevel");
const ExecutionStatus_1 = require("../reporter/ExecutionStatus");
function formatHints(hints) {
    if (hints.length === 1) {
        return `Hint: ${hints[0]}`;
    }
    return hints.map((h, idx) => `Hint (${idx + 1}): ${h}`).join('\n');
}
function formatFailures(failures, stringifyOne) {
    return `Encountered failures were:\n- ${failures.map(stringifyOne).join('\n- ')}`;
}
function formatExecutionSummary(executionTrees, stringifyOne) {
    const summaryLines = [];
    const remainingTreesAndDepth = [];
    for (const tree of executionTrees.slice().reverse()) {
        remainingTreesAndDepth.push({ depth: 1, tree });
    }
    while (remainingTreesAndDepth.length !== 0) {
        const currentTreeAndDepth = remainingTreesAndDepth.pop();
        const currentTree = currentTreeAndDepth.tree;
        const currentDepth = currentTreeAndDepth.depth;
        const statusIcon = currentTree.status === ExecutionStatus_1.ExecutionStatus.Success
            ? '\x1b[32m\u221A\x1b[0m'
            : currentTree.status === ExecutionStatus_1.ExecutionStatus.Failure
                ? '\x1b[31m\xD7\x1b[0m'
                : '\x1b[33m!\x1b[0m';
        const leftPadding = Array(currentDepth).join('. ');
        summaryLines.push(`${leftPadding}${statusIcon} ${stringifyOne(currentTree.value)}`);
        for (const tree of currentTree.children.slice().reverse()) {
            remainingTreesAndDepth.push({ depth: currentDepth + 1, tree });
        }
    }
    return `Execution summary:\n${summaryLines.join('\n')}`;
}
function preFormatTooManySkipped(out, stringifyOne) {
    const message = `Failed to run property, too many pre-condition failures encountered\n{ seed: ${out.seed} }\n\nRan ${out.numRuns} time(s)\nSkipped ${out.numSkips} time(s)`;
    let details = null;
    const hints = [
        'Try to reduce the number of rejected values by combining map, flatMap and built-in arbitraries',
        'Increase failure tolerance by setting maxSkipsPerRun to an higher value',
    ];
    if (out.verbose >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
        details = formatExecutionSummary(out.executionSummary, stringifyOne);
    }
    else {
        hints.push('Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status');
    }
    return { message, details, hints };
}
function preFormatFailure(out, stringifyOne) {
    const message = `Property failed after ${out.numRuns} tests\n{ seed: ${out.seed}, path: "${out.counterexamplePath}", endOnFailure: true }\nCounterexample: ${stringifyOne(out.counterexample)}\nShrunk ${out.numShrinks} time(s)\nGot error: ${out.error}`;
    let details = null;
    const hints = [];
    if (out.verbose >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
        details = formatExecutionSummary(out.executionSummary, stringifyOne);
    }
    else if (out.verbose === VerbosityLevel_1.VerbosityLevel.Verbose) {
        details = formatFailures(out.failures, stringifyOne);
    }
    else {
        hints.push('Enable verbose mode in order to have the list of all failing values encountered during the run');
    }
    return { message, details, hints };
}
function preFormatEarlyInterrupted(out, stringifyOne) {
    const message = `Property interrupted after ${out.numRuns} tests\n{ seed: ${out.seed} }`;
    let details = null;
    const hints = [];
    if (out.verbose >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
        details = formatExecutionSummary(out.executionSummary, stringifyOne);
    }
    else {
        hints.push('Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status');
    }
    return { message, details, hints };
}
function defaultReportMessageInternal(out, stringifyOne) {
    if (!out.failed)
        return;
    const { message, details, hints } = out.counterexamplePath === null
        ? out.interrupted
            ? preFormatEarlyInterrupted(out, stringifyOne)
            : preFormatTooManySkipped(out, stringifyOne)
        : preFormatFailure(out, stringifyOne);
    let errorMessage = message;
    if (details != null)
        errorMessage += `\n\n${details}`;
    if (hints.length > 0)
        errorMessage += `\n\n${formatHints(hints)}`;
    return errorMessage;
}
function defaultReportMessage(out) {
    return defaultReportMessageInternal(out, stringify_1.stringify);
}
exports.defaultReportMessage = defaultReportMessage;
async function asyncDefaultReportMessage(out) {
    const pendingStringifieds = [];
    function stringifyOne(value) {
        const stringified = (0, stringify_1.possiblyAsyncStringify)(value);
        if (typeof stringified === 'string') {
            return stringified;
        }
        pendingStringifieds.push(Promise.all([value, stringified]));
        return '\u2026';
    }
    const firstTryMessage = defaultReportMessageInternal(out, stringifyOne);
    if (pendingStringifieds.length === 0) {
        return firstTryMessage;
    }
    const registeredValues = new Map(await Promise.all(pendingStringifieds));
    function stringifySecond(value) {
        const asyncStringifiedIfRegistered = registeredValues.get(value);
        if (asyncStringifiedIfRegistered !== undefined) {
            return asyncStringifiedIfRegistered;
        }
        return (0, stringify_1.stringify)(value);
    }
    return defaultReportMessageInternal(out, stringifySecond);
}
exports.asyncDefaultReportMessage = asyncDefaultReportMessage;
function throwIfFailed(out) {
    if (!out.failed)
        return;
    throw new Error(defaultReportMessage(out));
}
async function asyncThrowIfFailed(out) {
    if (!out.failed)
        return;
    throw new Error(await asyncDefaultReportMessage(out));
}
function reportRunDetails(out) {
    if (out.runConfiguration.asyncReporter)
        return out.runConfiguration.asyncReporter(out);
    else if (out.runConfiguration.reporter)
        return out.runConfiguration.reporter(out);
    else
        return throwIfFailed(out);
}
exports.reportRunDetails = reportRunDetails;
async function asyncReportRunDetails(out) {
    if (out.runConfiguration.asyncReporter)
        return out.runConfiguration.asyncReporter(out);
    else if (out.runConfiguration.reporter)
        return out.runConfiguration.reporter(out);
    else
        return asyncThrowIfFailed(out);
}
exports.asyncReportRunDetails = asyncReportRunDetails;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\utils\\RunDetailsFormatter.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\symbols.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Csymbols.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cloneIfNeeded = exports.hasCloneMethod = exports.cloneMethod = void 0;
exports.cloneMethod = Symbol('fast-check/cloneMethod');
function hasCloneMethod(instance) {
    return (instance !== null &&
        (typeof instance === 'object' || typeof instance === 'function') &&
        exports.cloneMethod in instance &&
        typeof instance[exports.cloneMethod] === 'function');
}
exports.hasCloneMethod = hasCloneMethod;
function cloneIfNeeded(instance) {
    return hasCloneMethod(instance) ? instance[exports.cloneMethod]() : instance;
}
exports.cloneIfNeeded = cloneIfNeeded;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\symbols.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\fast-check-default.js", {"./arbitrary/_internals/helpers/DepthContext":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\DepthContext.js","./arbitrary/anything":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\anything.js","./arbitrary/array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\array.js","./arbitrary/ascii":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\ascii.js","./arbitrary/asciiString":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\asciiString.js","./arbitrary/base64":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\base64.js","./arbitrary/base64String":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\base64String.js","./arbitrary/bigInt":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\bigInt.js","./arbitrary/bigInt64Array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\bigInt64Array.js","./arbitrary/bigIntN":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\bigIntN.js","./arbitrary/bigUint":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\bigUint.js","./arbitrary/bigUint64Array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\bigUint64Array.js","./arbitrary/bigUintN":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\bigUintN.js","./arbitrary/boolean":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\boolean.js","./arbitrary/char":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\char.js","./arbitrary/char16bits":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\char16bits.js","./arbitrary/clone":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\clone.js","./arbitrary/commands":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\commands.js","./arbitrary/compareBooleanFunc":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\compareBooleanFunc.js","./arbitrary/compareFunc":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\compareFunc.js","./arbitrary/constant":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\constant.js","./arbitrary/constantFrom":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\constantFrom.js","./arbitrary/context":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\context.js","./arbitrary/date":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\date.js","./arbitrary/dictionary":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\dictionary.js","./arbitrary/domain":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\domain.js","./arbitrary/double":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\double.js","./arbitrary/emailAddress":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\emailAddress.js","./arbitrary/falsy":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\falsy.js","./arbitrary/float":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\float.js","./arbitrary/float32Array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\float32Array.js","./arbitrary/float64Array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\float64Array.js","./arbitrary/fullUnicode":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\fullUnicode.js","./arbitrary/fullUnicodeString":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\fullUnicodeString.js","./arbitrary/func":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\func.js","./arbitrary/hexa":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\hexa.js","./arbitrary/hexaString":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\hexaString.js","./arbitrary/infiniteStream":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\infiniteStream.js","./arbitrary/int16Array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\int16Array.js","./arbitrary/int32Array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\int32Array.js","./arbitrary/int8Array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\int8Array.js","./arbitrary/integer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\integer.js","./arbitrary/ipV4":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\ipV4.js","./arbitrary/ipV4Extended":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\ipV4Extended.js","./arbitrary/ipV6":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\ipV6.js","./arbitrary/json":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\json.js","./arbitrary/jsonValue":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\jsonValue.js","./arbitrary/letrec":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\letrec.js","./arbitrary/lorem":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\lorem.js","./arbitrary/mapToConstant":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\mapToConstant.js","./arbitrary/maxSafeInteger":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\maxSafeInteger.js","./arbitrary/maxSafeNat":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\maxSafeNat.js","./arbitrary/memo":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\memo.js","./arbitrary/mixedCase":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\mixedCase.js","./arbitrary/nat":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\nat.js","./arbitrary/object":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\object.js","./arbitrary/oneof":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\oneof.js","./arbitrary/option":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\option.js","./arbitrary/record":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\record.js","./arbitrary/scheduler":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\scheduler.js","./arbitrary/shuffledSubarray":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\shuffledSubarray.js","./arbitrary/sparseArray":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\sparseArray.js","./arbitrary/string":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\string.js","./arbitrary/string16bits":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\string16bits.js","./arbitrary/stringOf":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\stringOf.js","./arbitrary/subarray":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\subarray.js","./arbitrary/tuple":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\tuple.js","./arbitrary/uint16Array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\uint16Array.js","./arbitrary/uint32Array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\uint32Array.js","./arbitrary/uint8Array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\uint8Array.js","./arbitrary/uint8ClampedArray":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\uint8ClampedArray.js","./arbitrary/unicode":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\unicode.js","./arbitrary/unicodeJson":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\unicodeJson.js","./arbitrary/unicodeJsonValue":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\unicodeJsonValue.js","./arbitrary/unicodeString":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\unicodeString.js","./arbitrary/uniqueArray":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\uniqueArray.js","./arbitrary/uuid":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\uuid.js","./arbitrary/uuidV":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\uuidV.js","./arbitrary/webAuthority":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\webAuthority.js","./arbitrary/webFragments":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\webFragments.js","./arbitrary/webQueryParameters":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\webQueryParameters.js","./arbitrary/webSegment":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\webSegment.js","./arbitrary/webUrl":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\arbitrary\\webUrl.js","./check/arbitrary/definition/Arbitrary":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\arbitrary\\definition\\Arbitrary.js","./check/arbitrary/definition/Value":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\arbitrary\\definition\\Value.js","./check/model/ModelRunner":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\model\\ModelRunner.js","./check/precondition/Pre":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\precondition\\Pre.js","./check/precondition/PreconditionFailure":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\precondition\\PreconditionFailure.js","./check/property/AsyncProperty":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\property\\AsyncProperty.js","./check/property/Property":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\property\\Property.js","./check/runner/Runner":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\Runner.js","./check/runner/Sampler":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\Sampler.js","./check/runner/configuration/GlobalParameters":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\GlobalParameters.js","./check/runner/configuration/VerbosityLevel":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\VerbosityLevel.js","./check/runner/reporter/ExecutionStatus":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\reporter\\ExecutionStatus.js","./check/runner/utils/RunDetailsFormatter":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\runner\\utils\\RunDetailsFormatter.js","./check/symbols":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\check\\symbols.js","./random/generator/Random":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\random\\generator\\Random.js","./stream/Stream":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\stream\\Stream.js","./utils/hash":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\utils\\hash.js","./utils/stringify":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\utils\\stringify.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Cfast-check-default.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sparseArray = exports.array = exports.subarray = exports.shuffledSubarray = exports.clone = exports.oneof = exports.option = exports.mapToConstant = exports.constantFrom = exports.constant = exports.lorem = exports.base64String = exports.hexaString = exports.fullUnicodeString = exports.unicodeString = exports.stringOf = exports.string16bits = exports.asciiString = exports.string = exports.mixedCase = exports.base64 = exports.hexa = exports.fullUnicode = exports.unicode = exports.char16bits = exports.ascii = exports.char = exports.bigUint = exports.bigInt = exports.bigUintN = exports.bigIntN = exports.maxSafeNat = exports.maxSafeInteger = exports.nat = exports.integer = exports.double = exports.float = exports.falsy = exports.boolean = exports.asyncProperty = exports.property = exports.PreconditionFailure = exports.pre = exports.assert = exports.check = exports.statistics = exports.sample = exports.__commitHash = exports.__version = exports.__type = void 0;
exports.cloneMethod = exports.Value = exports.Arbitrary = exports.schedulerFor = exports.scheduler = exports.commands = exports.scheduledModelRun = exports.modelRun = exports.asyncModelRun = exports.bigUint64Array = exports.bigInt64Array = exports.float64Array = exports.float32Array = exports.uint32Array = exports.int32Array = exports.uint16Array = exports.int16Array = exports.uint8ClampedArray = exports.uint8Array = exports.int8Array = exports.uuidV = exports.uuid = exports.emailAddress = exports.webUrl = exports.webQueryParameters = exports.webFragments = exports.webSegment = exports.webAuthority = exports.domain = exports.ipV6 = exports.ipV4Extended = exports.ipV4 = exports.date = exports.context = exports.func = exports.compareFunc = exports.compareBooleanFunc = exports.memo = exports.letrec = exports.unicodeJsonValue = exports.unicodeJson = exports.jsonValue = exports.json = exports.object = exports.anything = exports.dictionary = exports.record = exports.tuple = exports.uniqueArray = exports.infiniteStream = void 0;
exports.createDepthIdentifier = exports.stream = exports.Stream = exports.Random = exports.ExecutionStatus = exports.resetConfigureGlobal = exports.readConfigureGlobal = exports.configureGlobal = exports.VerbosityLevel = exports.hash = exports.asyncDefaultReportMessage = exports.defaultReportMessage = exports.asyncStringify = exports.stringify = exports.getDepthContextFor = exports.hasAsyncToStringMethod = exports.asyncToStringMethod = exports.hasToStringMethod = exports.toStringMethod = exports.hasCloneMethod = exports.cloneIfNeeded = void 0;
const Pre_1 = require("./check/precondition/Pre");
Object.defineProperty(exports, "pre", { enumerable: true, get: function () { return Pre_1.pre; } });
const AsyncProperty_1 = require("./check/property/AsyncProperty");
Object.defineProperty(exports, "asyncProperty", { enumerable: true, get: function () { return AsyncProperty_1.asyncProperty; } });
const Property_1 = require("./check/property/Property");
Object.defineProperty(exports, "property", { enumerable: true, get: function () { return Property_1.property; } });
const Runner_1 = require("./check/runner/Runner");
Object.defineProperty(exports, "assert", { enumerable: true, get: function () { return Runner_1.assert; } });
Object.defineProperty(exports, "check", { enumerable: true, get: function () { return Runner_1.check; } });
const Sampler_1 = require("./check/runner/Sampler");
Object.defineProperty(exports, "sample", { enumerable: true, get: function () { return Sampler_1.sample; } });
Object.defineProperty(exports, "statistics", { enumerable: true, get: function () { return Sampler_1.statistics; } });
const array_1 = require("./arbitrary/array");
Object.defineProperty(exports, "array", { enumerable: true, get: function () { return array_1.array; } });
const bigInt_1 = require("./arbitrary/bigInt");
Object.defineProperty(exports, "bigInt", { enumerable: true, get: function () { return bigInt_1.bigInt; } });
const bigIntN_1 = require("./arbitrary/bigIntN");
Object.defineProperty(exports, "bigIntN", { enumerable: true, get: function () { return bigIntN_1.bigIntN; } });
const bigUint_1 = require("./arbitrary/bigUint");
Object.defineProperty(exports, "bigUint", { enumerable: true, get: function () { return bigUint_1.bigUint; } });
const bigUintN_1 = require("./arbitrary/bigUintN");
Object.defineProperty(exports, "bigUintN", { enumerable: true, get: function () { return bigUintN_1.bigUintN; } });
const boolean_1 = require("./arbitrary/boolean");
Object.defineProperty(exports, "boolean", { enumerable: true, get: function () { return boolean_1.boolean; } });
const falsy_1 = require("./arbitrary/falsy");
Object.defineProperty(exports, "falsy", { enumerable: true, get: function () { return falsy_1.falsy; } });
const ascii_1 = require("./arbitrary/ascii");
Object.defineProperty(exports, "ascii", { enumerable: true, get: function () { return ascii_1.ascii; } });
const base64_1 = require("./arbitrary/base64");
Object.defineProperty(exports, "base64", { enumerable: true, get: function () { return base64_1.base64; } });
const char_1 = require("./arbitrary/char");
Object.defineProperty(exports, "char", { enumerable: true, get: function () { return char_1.char; } });
const char16bits_1 = require("./arbitrary/char16bits");
Object.defineProperty(exports, "char16bits", { enumerable: true, get: function () { return char16bits_1.char16bits; } });
const fullUnicode_1 = require("./arbitrary/fullUnicode");
Object.defineProperty(exports, "fullUnicode", { enumerable: true, get: function () { return fullUnicode_1.fullUnicode; } });
const hexa_1 = require("./arbitrary/hexa");
Object.defineProperty(exports, "hexa", { enumerable: true, get: function () { return hexa_1.hexa; } });
const unicode_1 = require("./arbitrary/unicode");
Object.defineProperty(exports, "unicode", { enumerable: true, get: function () { return unicode_1.unicode; } });
const constant_1 = require("./arbitrary/constant");
Object.defineProperty(exports, "constant", { enumerable: true, get: function () { return constant_1.constant; } });
const constantFrom_1 = require("./arbitrary/constantFrom");
Object.defineProperty(exports, "constantFrom", { enumerable: true, get: function () { return constantFrom_1.constantFrom; } });
const context_1 = require("./arbitrary/context");
Object.defineProperty(exports, "context", { enumerable: true, get: function () { return context_1.context; } });
const date_1 = require("./arbitrary/date");
Object.defineProperty(exports, "date", { enumerable: true, get: function () { return date_1.date; } });
const clone_1 = require("./arbitrary/clone");
Object.defineProperty(exports, "clone", { enumerable: true, get: function () { return clone_1.clone; } });
const dictionary_1 = require("./arbitrary/dictionary");
Object.defineProperty(exports, "dictionary", { enumerable: true, get: function () { return dictionary_1.dictionary; } });
const emailAddress_1 = require("./arbitrary/emailAddress");
Object.defineProperty(exports, "emailAddress", { enumerable: true, get: function () { return emailAddress_1.emailAddress; } });
const double_1 = require("./arbitrary/double");
Object.defineProperty(exports, "double", { enumerable: true, get: function () { return double_1.double; } });
const float_1 = require("./arbitrary/float");
Object.defineProperty(exports, "float", { enumerable: true, get: function () { return float_1.float; } });
const compareBooleanFunc_1 = require("./arbitrary/compareBooleanFunc");
Object.defineProperty(exports, "compareBooleanFunc", { enumerable: true, get: function () { return compareBooleanFunc_1.compareBooleanFunc; } });
const compareFunc_1 = require("./arbitrary/compareFunc");
Object.defineProperty(exports, "compareFunc", { enumerable: true, get: function () { return compareFunc_1.compareFunc; } });
const func_1 = require("./arbitrary/func");
Object.defineProperty(exports, "func", { enumerable: true, get: function () { return func_1.func; } });
const domain_1 = require("./arbitrary/domain");
Object.defineProperty(exports, "domain", { enumerable: true, get: function () { return domain_1.domain; } });
const integer_1 = require("./arbitrary/integer");
Object.defineProperty(exports, "integer", { enumerable: true, get: function () { return integer_1.integer; } });
const maxSafeInteger_1 = require("./arbitrary/maxSafeInteger");
Object.defineProperty(exports, "maxSafeInteger", { enumerable: true, get: function () { return maxSafeInteger_1.maxSafeInteger; } });
const maxSafeNat_1 = require("./arbitrary/maxSafeNat");
Object.defineProperty(exports, "maxSafeNat", { enumerable: true, get: function () { return maxSafeNat_1.maxSafeNat; } });
const nat_1 = require("./arbitrary/nat");
Object.defineProperty(exports, "nat", { enumerable: true, get: function () { return nat_1.nat; } });
const ipV4_1 = require("./arbitrary/ipV4");
Object.defineProperty(exports, "ipV4", { enumerable: true, get: function () { return ipV4_1.ipV4; } });
const ipV4Extended_1 = require("./arbitrary/ipV4Extended");
Object.defineProperty(exports, "ipV4Extended", { enumerable: true, get: function () { return ipV4Extended_1.ipV4Extended; } });
const ipV6_1 = require("./arbitrary/ipV6");
Object.defineProperty(exports, "ipV6", { enumerable: true, get: function () { return ipV6_1.ipV6; } });
const letrec_1 = require("./arbitrary/letrec");
Object.defineProperty(exports, "letrec", { enumerable: true, get: function () { return letrec_1.letrec; } });
const lorem_1 = require("./arbitrary/lorem");
Object.defineProperty(exports, "lorem", { enumerable: true, get: function () { return lorem_1.lorem; } });
const mapToConstant_1 = require("./arbitrary/mapToConstant");
Object.defineProperty(exports, "mapToConstant", { enumerable: true, get: function () { return mapToConstant_1.mapToConstant; } });
const memo_1 = require("./arbitrary/memo");
Object.defineProperty(exports, "memo", { enumerable: true, get: function () { return memo_1.memo; } });
const mixedCase_1 = require("./arbitrary/mixedCase");
Object.defineProperty(exports, "mixedCase", { enumerable: true, get: function () { return mixedCase_1.mixedCase; } });
const object_1 = require("./arbitrary/object");
Object.defineProperty(exports, "object", { enumerable: true, get: function () { return object_1.object; } });
const json_1 = require("./arbitrary/json");
Object.defineProperty(exports, "json", { enumerable: true, get: function () { return json_1.json; } });
const anything_1 = require("./arbitrary/anything");
Object.defineProperty(exports, "anything", { enumerable: true, get: function () { return anything_1.anything; } });
const unicodeJsonValue_1 = require("./arbitrary/unicodeJsonValue");
Object.defineProperty(exports, "unicodeJsonValue", { enumerable: true, get: function () { return unicodeJsonValue_1.unicodeJsonValue; } });
const jsonValue_1 = require("./arbitrary/jsonValue");
Object.defineProperty(exports, "jsonValue", { enumerable: true, get: function () { return jsonValue_1.jsonValue; } });
const unicodeJson_1 = require("./arbitrary/unicodeJson");
Object.defineProperty(exports, "unicodeJson", { enumerable: true, get: function () { return unicodeJson_1.unicodeJson; } });
const oneof_1 = require("./arbitrary/oneof");
Object.defineProperty(exports, "oneof", { enumerable: true, get: function () { return oneof_1.oneof; } });
const option_1 = require("./arbitrary/option");
Object.defineProperty(exports, "option", { enumerable: true, get: function () { return option_1.option; } });
const record_1 = require("./arbitrary/record");
Object.defineProperty(exports, "record", { enumerable: true, get: function () { return record_1.record; } });
const uniqueArray_1 = require("./arbitrary/uniqueArray");
Object.defineProperty(exports, "uniqueArray", { enumerable: true, get: function () { return uniqueArray_1.uniqueArray; } });
const infiniteStream_1 = require("./arbitrary/infiniteStream");
Object.defineProperty(exports, "infiniteStream", { enumerable: true, get: function () { return infiniteStream_1.infiniteStream; } });
const asciiString_1 = require("./arbitrary/asciiString");
Object.defineProperty(exports, "asciiString", { enumerable: true, get: function () { return asciiString_1.asciiString; } });
const base64String_1 = require("./arbitrary/base64String");
Object.defineProperty(exports, "base64String", { enumerable: true, get: function () { return base64String_1.base64String; } });
const fullUnicodeString_1 = require("./arbitrary/fullUnicodeString");
Object.defineProperty(exports, "fullUnicodeString", { enumerable: true, get: function () { return fullUnicodeString_1.fullUnicodeString; } });
const hexaString_1 = require("./arbitrary/hexaString");
Object.defineProperty(exports, "hexaString", { enumerable: true, get: function () { return hexaString_1.hexaString; } });
const string_1 = require("./arbitrary/string");
Object.defineProperty(exports, "string", { enumerable: true, get: function () { return string_1.string; } });
const string16bits_1 = require("./arbitrary/string16bits");
Object.defineProperty(exports, "string16bits", { enumerable: true, get: function () { return string16bits_1.string16bits; } });
const stringOf_1 = require("./arbitrary/stringOf");
Object.defineProperty(exports, "stringOf", { enumerable: true, get: function () { return stringOf_1.stringOf; } });
const unicodeString_1 = require("./arbitrary/unicodeString");
Object.defineProperty(exports, "unicodeString", { enumerable: true, get: function () { return unicodeString_1.unicodeString; } });
const subarray_1 = require("./arbitrary/subarray");
Object.defineProperty(exports, "subarray", { enumerable: true, get: function () { return subarray_1.subarray; } });
const shuffledSubarray_1 = require("./arbitrary/shuffledSubarray");
Object.defineProperty(exports, "shuffledSubarray", { enumerable: true, get: function () { return shuffledSubarray_1.shuffledSubarray; } });
const tuple_1 = require("./arbitrary/tuple");
Object.defineProperty(exports, "tuple", { enumerable: true, get: function () { return tuple_1.tuple; } });
const uuid_1 = require("./arbitrary/uuid");
Object.defineProperty(exports, "uuid", { enumerable: true, get: function () { return uuid_1.uuid; } });
const uuidV_1 = require("./arbitrary/uuidV");
Object.defineProperty(exports, "uuidV", { enumerable: true, get: function () { return uuidV_1.uuidV; } });
const webAuthority_1 = require("./arbitrary/webAuthority");
Object.defineProperty(exports, "webAuthority", { enumerable: true, get: function () { return webAuthority_1.webAuthority; } });
const webFragments_1 = require("./arbitrary/webFragments");
Object.defineProperty(exports, "webFragments", { enumerable: true, get: function () { return webFragments_1.webFragments; } });
const webQueryParameters_1 = require("./arbitrary/webQueryParameters");
Object.defineProperty(exports, "webQueryParameters", { enumerable: true, get: function () { return webQueryParameters_1.webQueryParameters; } });
const webSegment_1 = require("./arbitrary/webSegment");
Object.defineProperty(exports, "webSegment", { enumerable: true, get: function () { return webSegment_1.webSegment; } });
const webUrl_1 = require("./arbitrary/webUrl");
Object.defineProperty(exports, "webUrl", { enumerable: true, get: function () { return webUrl_1.webUrl; } });
const commands_1 = require("./arbitrary/commands");
Object.defineProperty(exports, "commands", { enumerable: true, get: function () { return commands_1.commands; } });
const ModelRunner_1 = require("./check/model/ModelRunner");
Object.defineProperty(exports, "asyncModelRun", { enumerable: true, get: function () { return ModelRunner_1.asyncModelRun; } });
Object.defineProperty(exports, "modelRun", { enumerable: true, get: function () { return ModelRunner_1.modelRun; } });
Object.defineProperty(exports, "scheduledModelRun", { enumerable: true, get: function () { return ModelRunner_1.scheduledModelRun; } });
const Random_1 = require("./random/generator/Random");
Object.defineProperty(exports, "Random", { enumerable: true, get: function () { return Random_1.Random; } });
const GlobalParameters_1 = require("./check/runner/configuration/GlobalParameters");
Object.defineProperty(exports, "configureGlobal", { enumerable: true, get: function () { return GlobalParameters_1.configureGlobal; } });
Object.defineProperty(exports, "readConfigureGlobal", { enumerable: true, get: function () { return GlobalParameters_1.readConfigureGlobal; } });
Object.defineProperty(exports, "resetConfigureGlobal", { enumerable: true, get: function () { return GlobalParameters_1.resetConfigureGlobal; } });
const VerbosityLevel_1 = require("./check/runner/configuration/VerbosityLevel");
Object.defineProperty(exports, "VerbosityLevel", { enumerable: true, get: function () { return VerbosityLevel_1.VerbosityLevel; } });
const ExecutionStatus_1 = require("./check/runner/reporter/ExecutionStatus");
Object.defineProperty(exports, "ExecutionStatus", { enumerable: true, get: function () { return ExecutionStatus_1.ExecutionStatus; } });
const symbols_1 = require("./check/symbols");
Object.defineProperty(exports, "cloneMethod", { enumerable: true, get: function () { return symbols_1.cloneMethod; } });
Object.defineProperty(exports, "cloneIfNeeded", { enumerable: true, get: function () { return symbols_1.cloneIfNeeded; } });
Object.defineProperty(exports, "hasCloneMethod", { enumerable: true, get: function () { return symbols_1.hasCloneMethod; } });
const Stream_1 = require("./stream/Stream");
Object.defineProperty(exports, "Stream", { enumerable: true, get: function () { return Stream_1.Stream; } });
Object.defineProperty(exports, "stream", { enumerable: true, get: function () { return Stream_1.stream; } });
const hash_1 = require("./utils/hash");
Object.defineProperty(exports, "hash", { enumerable: true, get: function () { return hash_1.hash; } });
const stringify_1 = require("./utils/stringify");
Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return stringify_1.stringify; } });
Object.defineProperty(exports, "asyncStringify", { enumerable: true, get: function () { return stringify_1.asyncStringify; } });
Object.defineProperty(exports, "toStringMethod", { enumerable: true, get: function () { return stringify_1.toStringMethod; } });
Object.defineProperty(exports, "hasToStringMethod", { enumerable: true, get: function () { return stringify_1.hasToStringMethod; } });
Object.defineProperty(exports, "asyncToStringMethod", { enumerable: true, get: function () { return stringify_1.asyncToStringMethod; } });
Object.defineProperty(exports, "hasAsyncToStringMethod", { enumerable: true, get: function () { return stringify_1.hasAsyncToStringMethod; } });
const scheduler_1 = require("./arbitrary/scheduler");
Object.defineProperty(exports, "scheduler", { enumerable: true, get: function () { return scheduler_1.scheduler; } });
Object.defineProperty(exports, "schedulerFor", { enumerable: true, get: function () { return scheduler_1.schedulerFor; } });
const RunDetailsFormatter_1 = require("./check/runner/utils/RunDetailsFormatter");
Object.defineProperty(exports, "defaultReportMessage", { enumerable: true, get: function () { return RunDetailsFormatter_1.defaultReportMessage; } });
Object.defineProperty(exports, "asyncDefaultReportMessage", { enumerable: true, get: function () { return RunDetailsFormatter_1.asyncDefaultReportMessage; } });
const PreconditionFailure_1 = require("./check/precondition/PreconditionFailure");
Object.defineProperty(exports, "PreconditionFailure", { enumerable: true, get: function () { return PreconditionFailure_1.PreconditionFailure; } });
const int8Array_1 = require("./arbitrary/int8Array");
Object.defineProperty(exports, "int8Array", { enumerable: true, get: function () { return int8Array_1.int8Array; } });
const int16Array_1 = require("./arbitrary/int16Array");
Object.defineProperty(exports, "int16Array", { enumerable: true, get: function () { return int16Array_1.int16Array; } });
const int32Array_1 = require("./arbitrary/int32Array");
Object.defineProperty(exports, "int32Array", { enumerable: true, get: function () { return int32Array_1.int32Array; } });
const uint8Array_1 = require("./arbitrary/uint8Array");
Object.defineProperty(exports, "uint8Array", { enumerable: true, get: function () { return uint8Array_1.uint8Array; } });
const uint8ClampedArray_1 = require("./arbitrary/uint8ClampedArray");
Object.defineProperty(exports, "uint8ClampedArray", { enumerable: true, get: function () { return uint8ClampedArray_1.uint8ClampedArray; } });
const uint16Array_1 = require("./arbitrary/uint16Array");
Object.defineProperty(exports, "uint16Array", { enumerable: true, get: function () { return uint16Array_1.uint16Array; } });
const uint32Array_1 = require("./arbitrary/uint32Array");
Object.defineProperty(exports, "uint32Array", { enumerable: true, get: function () { return uint32Array_1.uint32Array; } });
const float32Array_1 = require("./arbitrary/float32Array");
Object.defineProperty(exports, "float32Array", { enumerable: true, get: function () { return float32Array_1.float32Array; } });
const float64Array_1 = require("./arbitrary/float64Array");
Object.defineProperty(exports, "float64Array", { enumerable: true, get: function () { return float64Array_1.float64Array; } });
const sparseArray_1 = require("./arbitrary/sparseArray");
Object.defineProperty(exports, "sparseArray", { enumerable: true, get: function () { return sparseArray_1.sparseArray; } });
const Arbitrary_1 = require("./check/arbitrary/definition/Arbitrary");
Object.defineProperty(exports, "Arbitrary", { enumerable: true, get: function () { return Arbitrary_1.Arbitrary; } });
const Value_1 = require("./check/arbitrary/definition/Value");
Object.defineProperty(exports, "Value", { enumerable: true, get: function () { return Value_1.Value; } });
const DepthContext_1 = require("./arbitrary/_internals/helpers/DepthContext");
Object.defineProperty(exports, "createDepthIdentifier", { enumerable: true, get: function () { return DepthContext_1.createDepthIdentifier; } });
Object.defineProperty(exports, "getDepthContextFor", { enumerable: true, get: function () { return DepthContext_1.getDepthContextFor; } });
const bigInt64Array_1 = require("./arbitrary/bigInt64Array");
Object.defineProperty(exports, "bigInt64Array", { enumerable: true, get: function () { return bigInt64Array_1.bigInt64Array; } });
const bigUint64Array_1 = require("./arbitrary/bigUint64Array");
Object.defineProperty(exports, "bigUint64Array", { enumerable: true, get: function () { return bigUint64Array_1.bigUint64Array; } });
const __type = 'commonjs';
exports.__type = __type;
const __version = '3.1.1';
exports.__version = __version;
const __commitHash = '35ac775d3a2353a9458b1426c2ac97397b99cdbd';
exports.__commitHash = __commitHash;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\fast-check-default.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\fast-check.js", {"./fast-check-default":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\fast-check-default.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Cfast-check.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
const fc = require("./fast-check-default");
exports.default = fc;
__exportStar(require("./fast-check-default"), exports);

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\fast-check.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\random\\generator\\Random.js", {"pure-rand":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\pure-rand.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Crandom%5Cgenerator%5CRandom.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Random = void 0;
const pure_rand_1 = require("pure-rand");
class Random {
    constructor(sourceRng) {
        this.internalRng = sourceRng.clone();
    }
    clone() {
        return new Random(this.internalRng);
    }
    next(bits) {
        return (0, pure_rand_1.unsafeUniformIntDistribution)(0, (1 << bits) - 1, this.internalRng);
    }
    nextBoolean() {
        return (0, pure_rand_1.unsafeUniformIntDistribution)(0, 1, this.internalRng) == 1;
    }
    nextInt(min, max) {
        return (0, pure_rand_1.unsafeUniformIntDistribution)(min == null ? Random.MIN_INT : min, max == null ? Random.MAX_INT : max, this.internalRng);
    }
    nextBigInt(min, max) {
        return (0, pure_rand_1.unsafeUniformBigIntDistribution)(min, max, this.internalRng);
    }
    nextArrayInt(min, max) {
        return (0, pure_rand_1.unsafeUniformArrayIntDistribution)(min, max, this.internalRng);
    }
    nextDouble() {
        const a = this.next(26);
        const b = this.next(27);
        return (a * Random.DBL_FACTOR + b) * Random.DBL_DIVISOR;
    }
}
exports.Random = Random;
Random.MIN_INT = 0x80000000 | 0;
Random.MAX_INT = 0x7fffffff | 0;
Random.DBL_FACTOR = Math.pow(2, 27);
Random.DBL_DIVISOR = Math.pow(2, -53);

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\random\\generator\\Random.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\stream\\LazyIterableIterator.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Cstream%5CLazyIterableIterator.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeLazy = void 0;
class LazyIterableIterator {
    constructor(producer) {
        this.producer = producer;
    }
    [Symbol.iterator]() {
        if (this.it === undefined) {
            this.it = this.producer();
        }
        return this.it;
    }
    next() {
        if (this.it === undefined) {
            this.it = this.producer();
        }
        return this.it.next();
    }
}
function makeLazy(producer) {
    return new LazyIterableIterator(producer);
}
exports.makeLazy = makeLazy;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\stream\\LazyIterableIterator.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\stream\\Stream.js", {"./StreamHelpers":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\stream\\StreamHelpers.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Cstream%5CStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stream = exports.Stream = void 0;
const StreamHelpers_1 = require("./StreamHelpers");
class Stream {
    constructor(g) {
        this.g = g;
    }
    static nil() {
        return new Stream((0, StreamHelpers_1.nilHelper)());
    }
    static of(...elements) {
        return new Stream(elements[Symbol.iterator]());
    }
    next() {
        return this.g.next();
    }
    [Symbol.iterator]() {
        return this.g;
    }
    map(f) {
        return new Stream((0, StreamHelpers_1.mapHelper)(this.g, f));
    }
    flatMap(f) {
        return new Stream((0, StreamHelpers_1.flatMapHelper)(this.g, f));
    }
    dropWhile(f) {
        let foundEligible = false;
        function* helper(v) {
            if (foundEligible || !f(v)) {
                foundEligible = true;
                yield v;
            }
        }
        return this.flatMap(helper);
    }
    drop(n) {
        let idx = 0;
        function helper() {
            return idx++ < n;
        }
        return this.dropWhile(helper);
    }
    takeWhile(f) {
        return new Stream((0, StreamHelpers_1.takeWhileHelper)(this.g, f));
    }
    take(n) {
        return new Stream((0, StreamHelpers_1.takeNHelper)(this.g, n));
    }
    filter(f) {
        return new Stream((0, StreamHelpers_1.filterHelper)(this.g, f));
    }
    every(f) {
        for (const v of this.g) {
            if (!f(v)) {
                return false;
            }
        }
        return true;
    }
    has(f) {
        for (const v of this.g) {
            if (f(v)) {
                return [true, v];
            }
        }
        return [false, null];
    }
    join(...others) {
        return new Stream((0, StreamHelpers_1.joinHelper)(this.g, others));
    }
    getNthOrLast(nth) {
        let remaining = nth;
        let last = null;
        for (const v of this.g) {
            if (remaining-- === 0)
                return v;
            last = v;
        }
        return last;
    }
}
exports.Stream = Stream;
function stream(g) {
    return new Stream(g);
}
exports.stream = stream;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\stream\\Stream.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\stream\\StreamHelpers.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Cstream%5CStreamHelpers.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.joinHelper = exports.takeWhileHelper = exports.takeNHelper = exports.filterHelper = exports.flatMapHelper = exports.mapHelper = exports.nilHelper = void 0;
class Nil {
    [Symbol.iterator]() {
        return this;
    }
    next(value) {
        return { value, done: true };
    }
}
Nil.nil = new Nil();
function nilHelper() {
    return Nil.nil;
}
exports.nilHelper = nilHelper;
function* mapHelper(g, f) {
    for (const v of g) {
        yield f(v);
    }
}
exports.mapHelper = mapHelper;
function* flatMapHelper(g, f) {
    for (const v of g) {
        yield* f(v);
    }
}
exports.flatMapHelper = flatMapHelper;
function* filterHelper(g, f) {
    for (const v of g) {
        if (f(v)) {
            yield v;
        }
    }
}
exports.filterHelper = filterHelper;
function* takeNHelper(g, n) {
    for (let i = 0; i < n; ++i) {
        const cur = g.next();
        if (cur.done) {
            break;
        }
        yield cur.value;
    }
}
exports.takeNHelper = takeNHelper;
function* takeWhileHelper(g, f) {
    let cur = g.next();
    while (!cur.done && f(cur.value)) {
        yield cur.value;
        cur = g.next();
    }
}
exports.takeWhileHelper = takeWhileHelper;
function* joinHelper(g, others) {
    for (let cur = g.next(); !cur.done; cur = g.next()) {
        yield cur.value;
    }
    for (const s of others) {
        for (let cur = s.next(); !cur.done; cur = s.next()) {
            yield cur.value;
        }
    }
}
exports.joinHelper = joinHelper;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\stream\\StreamHelpers.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\utils\\hash.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Cutils%5Chash.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hash = void 0;
const crc32Table = [
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832,
    0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a,
    0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
    0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab,
    0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4,
    0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074,
    0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525,
    0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
    0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76,
    0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6,
    0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7,
    0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7,
    0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
    0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330,
    0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,
];
function hash(repr) {
    let crc = 0xffffffff;
    for (let idx = 0; idx < repr.length; ++idx) {
        const c = repr.charCodeAt(idx);
        if (c < 0x80) {
            crc = crc32Table[(crc & 0xff) ^ c] ^ (crc >> 8);
        }
        else if (c < 0x800) {
            crc = crc32Table[(crc & 0xff) ^ (192 | ((c >> 6) & 31))] ^ (crc >> 8);
            crc = crc32Table[(crc & 0xff) ^ (128 | (c & 63))] ^ (crc >> 8);
        }
        else if (c >= 0xd800 && c < 0xe000) {
            const cNext = repr.charCodeAt(++idx);
            if (c >= 0xdc00 || cNext < 0xdc00 || cNext > 0xdfff || Number.isNaN(cNext)) {
                idx -= 1;
                crc = crc32Table[(crc & 0xff) ^ 0xef] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ 0xbf] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ 0xbd] ^ (crc >> 8);
            }
            else {
                const c1 = (c & 1023) + 64;
                const c2 = cNext & 1023;
                crc = crc32Table[(crc & 0xff) ^ (240 | ((c1 >> 8) & 7))] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ (128 | ((c1 >> 2) & 63))] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ (128 | ((c2 >> 6) & 15) | ((c1 & 3) << 4))] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ (128 | (c2 & 63))] ^ (crc >> 8);
            }
        }
        else {
            crc = crc32Table[(crc & 0xff) ^ (224 | ((c >> 12) & 15))] ^ (crc >> 8);
            crc = crc32Table[(crc & 0xff) ^ (128 | ((c >> 6) & 63))] ^ (crc >> 8);
            crc = crc32Table[(crc & 0xff) ^ (128 | (c & 63))] ^ (crc >> 8);
        }
    }
    return (crc | 0) + 0x80000000;
}
exports.hash = hash;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\utils\\hash.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fast-check\\lib\\utils\\stringify.js", {"buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfast-check%5Clib%5Cutils%5Cstringify.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.asyncStringify = exports.possiblyAsyncStringify = exports.stringify = exports.stringifyInternal = exports.hasAsyncToStringMethod = exports.asyncToStringMethod = exports.hasToStringMethod = exports.toStringMethod = void 0;
exports.toStringMethod = Symbol('fast-check/toStringMethod');
function hasToStringMethod(instance) {
    return (instance !== null &&
        (typeof instance === 'object' || typeof instance === 'function') &&
        exports.toStringMethod in instance &&
        typeof instance[exports.toStringMethod] === 'function');
}
exports.hasToStringMethod = hasToStringMethod;
exports.asyncToStringMethod = Symbol('fast-check/asyncToStringMethod');
function hasAsyncToStringMethod(instance) {
    return (instance !== null &&
        (typeof instance === 'object' || typeof instance === 'function') &&
        exports.asyncToStringMethod in instance &&
        typeof instance[exports.asyncToStringMethod] === 'function');
}
exports.hasAsyncToStringMethod = hasAsyncToStringMethod;
const findSymbolNameRegex = /^Symbol\((.*)\)$/;
function getSymbolDescription(s) {
    if (s.description !== undefined)
        return s.description;
    const m = findSymbolNameRegex.exec(String(s));
    return m && m[1].length ? m[1] : null;
}
function stringifyNumber(numValue) {
    switch (numValue) {
        case 0:
            return 1 / numValue === Number.NEGATIVE_INFINITY ? '-0' : '0';
        case Number.NEGATIVE_INFINITY:
            return 'Number.NEGATIVE_INFINITY';
        case Number.POSITIVE_INFINITY:
            return 'Number.POSITIVE_INFINITY';
        default:
            return numValue === numValue ? String(numValue) : 'Number.NaN';
    }
}
function isSparseArray(arr) {
    let previousNumberedIndex = -1;
    for (const index in arr) {
        const numberedIndex = Number(index);
        if (numberedIndex !== previousNumberedIndex + 1)
            return true;
        previousNumberedIndex = numberedIndex;
    }
    return previousNumberedIndex + 1 !== arr.length;
}
function stringifyInternal(value, previousValues, getAsyncContent) {
    const currentValues = previousValues.concat([value]);
    if (typeof value === 'object') {
        if (previousValues.indexOf(value) !== -1) {
            return '[cyclic]';
        }
    }
    if (hasAsyncToStringMethod(value)) {
        const content = getAsyncContent(value);
        if (content.state === 'fulfilled') {
            return content.value;
        }
    }
    if (hasToStringMethod(value)) {
        try {
            return value[exports.toStringMethod]();
        }
        catch (err) {
        }
    }
    switch (Object.prototype.toString.call(value)) {
        case '[object Array]': {
            const arr = value;
            if (arr.length >= 50 && isSparseArray(arr)) {
                const assignments = [];
                for (const index in arr) {
                    if (!Number.isNaN(Number(index)))
                        assignments.push(`${index}:${stringifyInternal(arr[index], currentValues, getAsyncContent)}`);
                }
                return assignments.length !== 0
                    ? `Object.assign(Array(${arr.length}),{${assignments.join(',')}})`
                    : `Array(${arr.length})`;
            }
            const stringifiedArray = arr.map((v) => stringifyInternal(v, currentValues, getAsyncContent)).join(',');
            return arr.length === 0 || arr.length - 1 in arr ? `[${stringifiedArray}]` : `[${stringifiedArray},]`;
        }
        case '[object BigInt]':
            return `${value}n`;
        case '[object Boolean]':
            return typeof value === 'boolean' ? JSON.stringify(value) : `new Boolean(${JSON.stringify(value)})`;
        case '[object Date]': {
            const d = value;
            return Number.isNaN(d.getTime()) ? `new Date(NaN)` : `new Date(${JSON.stringify(d.toISOString())})`;
        }
        case '[object Map]':
            return `new Map(${stringifyInternal(Array.from(value), currentValues, getAsyncContent)})`;
        case '[object Null]':
            return `null`;
        case '[object Number]':
            return typeof value === 'number' ? stringifyNumber(value) : `new Number(${stringifyNumber(Number(value))})`;
        case '[object Object]': {
            try {
                const toStringAccessor = value.toString;
                if (typeof toStringAccessor === 'function' && toStringAccessor !== Object.prototype.toString) {
                    return value.toString();
                }
            }
            catch (err) {
                return '[object Object]';
            }
            const mapper = (k) => `${k === '__proto__'
                ? '["__proto__"]'
                : typeof k === 'symbol'
                    ? `[${stringifyInternal(k, currentValues, getAsyncContent)}]`
                    : JSON.stringify(k)}:${stringifyInternal(value[k], currentValues, getAsyncContent)}`;
            const stringifiedProperties = [
                ...Object.keys(value).map(mapper),
                ...Object.getOwnPropertySymbols(value)
                    .filter((s) => {
                    const descriptor = Object.getOwnPropertyDescriptor(value, s);
                    return descriptor && descriptor.enumerable;
                })
                    .map(mapper),
            ];
            const rawRepr = '{' + stringifiedProperties.join(',') + '}';
            if (Object.getPrototypeOf(value) === null) {
                return rawRepr === '{}' ? 'Object.create(null)' : `Object.assign(Object.create(null),${rawRepr})`;
            }
            return rawRepr;
        }
        case '[object Set]':
            return `new Set(${stringifyInternal(Array.from(value), currentValues, getAsyncContent)})`;
        case '[object String]':
            return typeof value === 'string' ? JSON.stringify(value) : `new String(${JSON.stringify(value)})`;
        case '[object Symbol]': {
            const s = value;
            if (Symbol.keyFor(s) !== undefined) {
                return `Symbol.for(${JSON.stringify(Symbol.keyFor(s))})`;
            }
            const desc = getSymbolDescription(s);
            if (desc === null) {
                return 'Symbol()';
            }
            const knownSymbol = desc.startsWith('Symbol.') && Symbol[desc.substring(7)];
            return s === knownSymbol ? desc : `Symbol(${JSON.stringify(desc)})`;
        }
        case '[object Promise]': {
            const promiseContent = getAsyncContent(value);
            switch (promiseContent.state) {
                case 'fulfilled':
                    return `Promise.resolve(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
                case 'rejected':
                    return `Promise.reject(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
                case 'pending':
                    return `new Promise(() => {/*pending*/})`;
                case 'unknown':
                default:
                    return `new Promise(() => {/*unknown*/})`;
            }
        }
        case '[object Error]':
            if (value instanceof Error) {
                return `new Error(${stringifyInternal(value.message, currentValues, getAsyncContent)})`;
            }
            break;
        case '[object Undefined]':
            return `undefined`;
        case '[object Int8Array]':
        case '[object Uint8Array]':
        case '[object Uint8ClampedArray]':
        case '[object Int16Array]':
        case '[object Uint16Array]':
        case '[object Int32Array]':
        case '[object Uint32Array]':
        case '[object Float32Array]':
        case '[object Float64Array]':
        case '[object BigInt64Array]':
        case '[object BigUint64Array]': {
            if (typeof Buffer !== 'undefined' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(value)) {
                return `Buffer.from(${stringifyInternal(Array.from(value.values()), currentValues, getAsyncContent)})`;
            }
            const valuePrototype = Object.getPrototypeOf(value);
            const className = valuePrototype && valuePrototype.constructor && valuePrototype.constructor.name;
            if (typeof className === 'string') {
                const typedArray = value;
                const valuesFromTypedArr = typedArray.values();
                return `${className}.from(${stringifyInternal(Array.from(valuesFromTypedArr), currentValues, getAsyncContent)})`;
            }
            break;
        }
    }
    try {
        return value.toString();
    }
    catch (_a) {
        return Object.prototype.toString.call(value);
    }
}
exports.stringifyInternal = stringifyInternal;
function stringify(value) {
    return stringifyInternal(value, [], () => ({ state: 'unknown', value: undefined }));
}
exports.stringify = stringify;
function possiblyAsyncStringify(value) {
    const stillPendingMarker = Symbol();
    const pendingPromisesForCache = [];
    const cache = new Map();
    function createDelay0() {
        let handleId = null;
        const cancel = () => {
            if (handleId !== null) {
                clearTimeout(handleId);
            }
        };
        const delay = new Promise((resolve) => {
            handleId = setTimeout(() => {
                handleId = null;
                resolve(stillPendingMarker);
            }, 0);
        });
        return { delay, cancel };
    }
    const unknownState = { state: 'unknown', value: undefined };
    const getAsyncContent = function getAsyncContent(data) {
        const cacheKey = data;
        if (cache.has(cacheKey)) {
            return cache.get(cacheKey);
        }
        const delay0 = createDelay0();
        const p = exports.asyncToStringMethod in data
            ? Promise.resolve().then(() => data[exports.asyncToStringMethod]())
            : data;
        p.catch(() => { });
        pendingPromisesForCache.push(Promise.race([p, delay0.delay]).then((successValue) => {
            if (successValue === stillPendingMarker)
                cache.set(cacheKey, { state: 'pending', value: undefined });
            else
                cache.set(cacheKey, { state: 'fulfilled', value: successValue });
            delay0.cancel();
        }, (errorValue) => {
            cache.set(cacheKey, { state: 'rejected', value: errorValue });
            delay0.cancel();
        }));
        cache.set(cacheKey, unknownState);
        return unknownState;
    };
    function loop() {
        const stringifiedValue = stringifyInternal(value, [], getAsyncContent);
        if (pendingPromisesForCache.length === 0) {
            return stringifiedValue;
        }
        return Promise.all(pendingPromisesForCache.splice(0)).then(loop);
    }
    return loop();
}
exports.possiblyAsyncStringify = possiblyAsyncStringify;
async function asyncStringify(value) {
    return Promise.resolve(possiblyAsyncStringify(value));
}
exports.asyncStringify = asyncStringify;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\utils\\stringify.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\constants.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cconstants.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FOCUS_NO_AUTOFOCUS = exports.FOCUS_AUTO = exports.FOCUS_ALLOW = exports.FOCUS_DISABLED = exports.FOCUS_GROUP = void 0;
/**
 * defines a focus group
 */
exports.FOCUS_GROUP = 'data-focus-lock';
/**
 * disables element discovery inside a group marked by key
 */
exports.FOCUS_DISABLED = 'data-focus-lock-disabled';
/**
 * allows uncontrolled focus within the marked area, effectively disabling focus lock for it's content
 */
exports.FOCUS_ALLOW = 'data-no-focus-lock';
/**
 * instructs autofocus engine to pick default autofocus inside a given node
 * can be set on the element or container
 */
exports.FOCUS_AUTO = 'data-autofocus-inside';
/**
 * instructs autofocus to ignore elements within a given node
 * can be set on the element or container
 */
exports.FOCUS_NO_AUTOFOCUS = 'data-no-autofocus';

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\constants.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\focusInside.js", {"./utils/DOMutils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\DOMutils.js","./utils/all-affected":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\all-affected.js","./utils/array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\array.js","./utils/getActiveElement":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\getActiveElement.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5CfocusInside.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.focusInside = void 0;
var DOMutils_1 = require("./utils/DOMutils");
var all_affected_1 = require("./utils/all-affected");
var array_1 = require("./utils/array");
var getActiveElement_1 = require("./utils/getActiveElement");
var focusInFrame = function (frame, activeElement) { return frame === activeElement; };
var focusInsideIframe = function (topNode, activeElement) {
    return Boolean((0, array_1.toArray)(topNode.querySelectorAll('iframe')).some(function (node) { return focusInFrame(node, activeElement); }));
};
/**
 * @returns {Boolean} true, if the current focus is inside given node or nodes
 */
var focusInside = function (topNode, activeElement) {
    // const activeElement = document && getActiveElement();
    if (activeElement === void 0) { activeElement = (0, getActiveElement_1.getActiveElement)((0, array_1.getFirst)(topNode).ownerDocument); }
    if (!activeElement || (activeElement.dataset && activeElement.dataset.focusGuard)) {
        return false;
    }
    return (0, all_affected_1.getAllAffectedNodes)(topNode).some(function (node) {
        return (0, DOMutils_1.contains)(node, activeElement) || focusInsideIframe(node, activeElement);
    });
};
exports.focusInside = focusInside;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\focusInside.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\focusIsHidden.js", {"./constants":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\constants.js","./utils/DOMutils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\DOMutils.js","./utils/array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\array.js","./utils/getActiveElement":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\getActiveElement.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5CfocusIsHidden.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.focusIsHidden = void 0;
var constants_1 = require("./constants");
var DOMutils_1 = require("./utils/DOMutils");
var array_1 = require("./utils/array");
var getActiveElement_1 = require("./utils/getActiveElement");
/**
 * focus is hidden FROM the focus-lock
 * ie contained inside a node focus-lock shall ignore
 * @returns {boolean} focus is currently is in "allow" area
 */
var focusIsHidden = function (inDocument) {
    if (inDocument === void 0) { inDocument = document; }
    var activeElement = (0, getActiveElement_1.getActiveElement)(inDocument);
    if (!activeElement) {
        return false;
    }
    // this does not support setting FOCUS_ALLOW within shadow dom
    return (0, array_1.toArray)(inDocument.querySelectorAll("[".concat(constants_1.FOCUS_ALLOW, "]"))).some(function (node) { return (0, DOMutils_1.contains)(node, activeElement); });
};
exports.focusIsHidden = focusIsHidden;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\focusIsHidden.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\focusMerge.js", {"./solver":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\solver.js","./utils/DOMutils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\DOMutils.js","./utils/all-affected":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\all-affected.js","./utils/array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\array.js","./utils/auto-focus":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\auto-focus.js","./utils/getActiveElement":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\getActiveElement.js","./utils/is":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\is.js","./utils/parenting":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\parenting.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5CfocusMerge.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFocusMerge = void 0;
var solver_1 = require("./solver");
var DOMutils_1 = require("./utils/DOMutils");
var all_affected_1 = require("./utils/all-affected");
var array_1 = require("./utils/array");
var auto_focus_1 = require("./utils/auto-focus");
var getActiveElement_1 = require("./utils/getActiveElement");
var is_1 = require("./utils/is");
var parenting_1 = require("./utils/parenting");
var reorderNodes = function (srcNodes, dstNodes) {
    var remap = new Map();
    // no Set(dstNodes) for IE11 :(
    dstNodes.forEach(function (entity) { return remap.set(entity.node, entity); });
    // remap to dstNodes
    return srcNodes.map(function (node) { return remap.get(node); }).filter(is_1.isDefined);
};
/**
 * given top node(s) and the last active element return the element to be focused next
 * @param topNode
 * @param lastNode
 */
var getFocusMerge = function (topNode, lastNode) {
    var activeElement = (0, getActiveElement_1.getActiveElement)((0, array_1.asArray)(topNode).length > 0 ? document : (0, array_1.getFirst)(topNode).ownerDocument);
    var entries = (0, all_affected_1.getAllAffectedNodes)(topNode).filter(is_1.isNotAGuard);
    var commonParent = (0, parenting_1.getTopCommonParent)(activeElement || topNode, topNode, entries);
    var visibilityCache = new Map();
    var anyFocusable = (0, DOMutils_1.getAllTabbableNodes)(entries, visibilityCache);
    var innerElements = (0, DOMutils_1.getTabbableNodes)(entries, visibilityCache).filter(function (_a) {
        var node = _a.node;
        return (0, is_1.isNotAGuard)(node);
    });
    if (!innerElements[0]) {
        innerElements = anyFocusable;
        if (!innerElements[0]) {
            return undefined;
        }
    }
    var outerNodes = (0, DOMutils_1.getAllTabbableNodes)([commonParent], visibilityCache).map(function (_a) {
        var node = _a.node;
        return node;
    });
    var orderedInnerElements = reorderNodes(outerNodes, innerElements);
    var innerNodes = orderedInnerElements.map(function (_a) {
        var node = _a.node;
        return node;
    });
    var newId = (0, solver_1.newFocus)(innerNodes, outerNodes, activeElement, lastNode);
    if (newId === solver_1.NEW_FOCUS) {
        var focusNode = (0, auto_focus_1.pickAutofocus)(anyFocusable, innerNodes, (0, parenting_1.allParentAutofocusables)(entries, visibilityCache));
        if (focusNode) {
            return { node: focusNode };
        }
        else {
            console.warn('focus-lock: cannot find any node to move focus into');
            return undefined;
        }
    }
    if (newId === undefined) {
        return newId;
    }
    return orderedInnerElements[newId];
};
exports.getFocusMerge = getFocusMerge;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\focusMerge.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\focusables.js", {"./utils/DOMutils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\DOMutils.js","./utils/all-affected":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\all-affected.js","./utils/is":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\is.js","./utils/parenting":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\parenting.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cfocusables.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFocusableIn = exports.getFocusabledIn = void 0;
var DOMutils_1 = require("./utils/DOMutils");
var all_affected_1 = require("./utils/all-affected");
var is_1 = require("./utils/is");
var parenting_1 = require("./utils/parenting");
/**
 * return list of focusable elements inside a given top node
 * @deprecated use {@link getFocusableIn}. Yep, there is typo in the function name
 */
var getFocusabledIn = function (topNode) {
    var entries = (0, all_affected_1.getAllAffectedNodes)(topNode).filter(is_1.isNotAGuard);
    var commonParent = (0, parenting_1.getTopCommonParent)(topNode, topNode, entries);
    var visibilityCache = new Map();
    var outerNodes = (0, DOMutils_1.getTabbableNodes)([commonParent], visibilityCache, true);
    var innerElements = (0, DOMutils_1.getTabbableNodes)(entries, visibilityCache)
        .filter(function (_a) {
        var node = _a.node;
        return (0, is_1.isNotAGuard)(node);
    })
        .map(function (_a) {
        var node = _a.node;
        return node;
    });
    return outerNodes.map(function (_a) {
        var node = _a.node, index = _a.index;
        return ({
            node: node,
            index: index,
            lockItem: innerElements.indexOf(node) >= 0,
            guard: (0, is_1.isGuard)(node),
        });
    });
};
exports.getFocusabledIn = getFocusabledIn;
/**
 * return list of focusable elements inside a given top node
 */
exports.getFocusableIn = exports.getFocusabledIn;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\focusables.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\index.js", {"./constants":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\constants.js","./focusInside":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\focusInside.js","./focusIsHidden":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\focusIsHidden.js","./focusMerge":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\focusMerge.js","./focusables":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\focusables.js","./setFocus":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\setFocus.js","./sibling":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\sibling.js","./tabHook":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\tabHook.js","./utils/all-affected":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\all-affected.js","./utils/getActiveElement":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\getActiveElement.js","tslib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\tslib\\tslib.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getActiveElement = exports.focusPrevElement = exports.focusNextElement = exports.getAllAffectedNodes = exports.constants = exports.getFocusabledIn = exports.getFocusableIn = exports.focusMerge = exports.focusIsHidden = exports.focusInside = exports.tabHook = void 0;
var tslib_1 = require("tslib");
var constants = (0, tslib_1.__importStar)(require("./constants"));
exports.constants = constants;
var focusInside_1 = require("./focusInside");
Object.defineProperty(exports, "focusInside", { enumerable: true, get: function () { return focusInside_1.focusInside; } });
var focusIsHidden_1 = require("./focusIsHidden");
Object.defineProperty(exports, "focusIsHidden", { enumerable: true, get: function () { return focusIsHidden_1.focusIsHidden; } });
var focusMerge_1 = require("./focusMerge");
Object.defineProperty(exports, "focusMerge", { enumerable: true, get: function () { return focusMerge_1.getFocusMerge; } });
var focusables_1 = require("./focusables");
Object.defineProperty(exports, "getFocusabledIn", { enumerable: true, get: function () { return focusables_1.getFocusabledIn; } });
Object.defineProperty(exports, "getFocusableIn", { enumerable: true, get: function () { return focusables_1.getFocusableIn; } });
var setFocus_1 = require("./setFocus");
var sibling_1 = require("./sibling");
Object.defineProperty(exports, "focusNextElement", { enumerable: true, get: function () { return sibling_1.focusNextElement; } });
Object.defineProperty(exports, "focusPrevElement", { enumerable: true, get: function () { return sibling_1.focusPrevElement; } });
var tabHook_1 = (0, tslib_1.__importDefault)(require("./tabHook"));
exports.tabHook = tabHook_1.default;
var all_affected_1 = require("./utils/all-affected");
Object.defineProperty(exports, "getAllAffectedNodes", { enumerable: true, get: function () { return all_affected_1.getAllAffectedNodes; } });
var getActiveElement_1 = require("./utils/getActiveElement");
Object.defineProperty(exports, "getActiveElement", { enumerable: true, get: function () { return getActiveElement_1.getActiveElement; } });
exports.default = setFocus_1.setFocus;
//

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\setFocus.js", {"./focusMerge":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\focusMerge.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5CsetFocus.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setFocus = exports.focusOn = void 0;
var focusMerge_1 = require("./focusMerge");
var focusOn = function (target, focusOptions) {
    if ('focus' in target) {
        target.focus(focusOptions);
    }
    if ('contentWindow' in target && target.contentWindow) {
        target.contentWindow.focus();
    }
};
exports.focusOn = focusOn;
var guardCount = 0;
var lockDisabled = false;
/**
 * Sets focus at a given node. The last focused element will help to determine which element(first or last) should be focused.
 * HTML markers (see {@link __import__('./constants').FOCUS_AUTO} constants) can control autofocus
 * @param topNode
 * @param lastNode
 * @param options
 */
var setFocus = function (topNode, lastNode, options) {
    if (options === void 0) { options = {}; }
    var focusable = (0, focusMerge_1.getFocusMerge)(topNode, lastNode);
    if (lockDisabled) {
        return;
    }
    if (focusable) {
        if (guardCount > 2) {
            // tslint:disable-next-line:no-console
            console.error('FocusLock: focus-fighting detected. Only one focus management system could be active. ' +
                'See https://github.com/theKashey/focus-lock/#focus-fighting');
            lockDisabled = true;
            setTimeout(function () {
                lockDisabled = false;
            }, 1);
            return;
        }
        guardCount++;
        (0, exports.focusOn)(focusable.node, options.focusOptions);
        guardCount--;
    }
};
exports.setFocus = setFocus;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\setFocus.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\sibling.js", {"./setFocus":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\setFocus.js","./utils/DOMutils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\DOMutils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Csibling.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.focusPrevElement = exports.focusNextElement = void 0;
var setFocus_1 = require("./setFocus");
var DOMutils_1 = require("./utils/DOMutils");
var getRelativeFocusable = function (element, scope) {
    if (!element || !scope || !(0, DOMutils_1.contains)(scope, element)) {
        return {};
    }
    var focusables = (0, DOMutils_1.getTabbableNodes)([scope], new Map());
    var current = focusables.findIndex(function (_a) {
        var node = _a.node;
        return node === element;
    });
    if (current === -1) {
        return {};
    }
    return {
        prev: focusables[current - 1],
        next: focusables[current + 1],
        first: focusables[0],
        last: focusables[focusables.length - 1],
    };
};
var defaultOptions = function (options) {
    return Object.assign({
        scope: document.body,
        cycle: true,
    }, options);
};
/**
 * focuses next element in the tab-order
 * @param baseElement - common parent to scope active element search or tab cycle order
 * @param {FocusNextOptions} [options] - focus options
 */
var focusNextElement = function (baseElement, options) {
    if (options === void 0) { options = {}; }
    var _a = defaultOptions(options), scope = _a.scope, cycle = _a.cycle;
    var _b = getRelativeFocusable(baseElement, scope), next = _b.next, first = _b.first;
    var newTarget = next || (cycle && first);
    if (newTarget) {
        (0, setFocus_1.focusOn)(newTarget.node, options.focusOptions);
    }
};
exports.focusNextElement = focusNextElement;
/**
 * focuses prev element in the tab order
 * @param baseElement - common parent to scope active element search or tab cycle order
 * @param {FocusNextOptions} [options] - focus options
 */
var focusPrevElement = function (baseElement, options) {
    if (options === void 0) { options = {}; }
    var _a = defaultOptions(options), scope = _a.scope, cycle = _a.cycle;
    var _b = getRelativeFocusable(baseElement, scope), prev = _b.prev, last = _b.last;
    var newTarget = prev || (cycle && last);
    if (newTarget) {
        (0, setFocus_1.focusOn)(newTarget.node, options.focusOptions);
    }
};
exports.focusPrevElement = focusPrevElement;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\sibling.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\solver.js", {"./utils/correctFocus":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\correctFocus.js","./utils/firstFocus":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\firstFocus.js","./utils/is":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\is.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Csolver.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.newFocus = exports.NEW_FOCUS = void 0;
var correctFocus_1 = require("./utils/correctFocus");
var firstFocus_1 = require("./utils/firstFocus");
var is_1 = require("./utils/is");
exports.NEW_FOCUS = 'NEW_FOCUS';
/**
 * Main solver for the "find next focus" question
 * @param innerNodes
 * @param outerNodes
 * @param activeElement
 * @param lastNode
 * @returns {number|string|undefined|*}
 */
var newFocus = function (innerNodes, outerNodes, activeElement, lastNode) {
    var cnt = innerNodes.length;
    var firstFocus = innerNodes[0];
    var lastFocus = innerNodes[cnt - 1];
    var isOnGuard = (0, is_1.isGuard)(activeElement);
    // focus is inside
    if (activeElement && innerNodes.indexOf(activeElement) >= 0) {
        return undefined;
    }
    var activeIndex = activeElement !== undefined ? outerNodes.indexOf(activeElement) : -1;
    var lastIndex = lastNode ? outerNodes.indexOf(lastNode) : activeIndex;
    var lastNodeInside = lastNode ? innerNodes.indexOf(lastNode) : -1;
    var indexDiff = activeIndex - lastIndex;
    var firstNodeIndex = outerNodes.indexOf(firstFocus);
    var lastNodeIndex = outerNodes.indexOf(lastFocus);
    var correctedNodes = (0, correctFocus_1.correctNodes)(outerNodes);
    var correctedIndex = activeElement !== undefined ? correctedNodes.indexOf(activeElement) : -1;
    var correctedIndexDiff = correctedIndex - (lastNode ? correctedNodes.indexOf(lastNode) : activeIndex);
    var returnFirstNode = (0, firstFocus_1.pickFocusable)(innerNodes, 0);
    var returnLastNode = (0, firstFocus_1.pickFocusable)(innerNodes, cnt - 1);
    // new focus
    if (activeIndex === -1 || lastNodeInside === -1) {
        return exports.NEW_FOCUS;
    }
    // old focus
    if (!indexDiff && lastNodeInside >= 0) {
        return lastNodeInside;
    }
    // first element
    if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
        return returnLastNode;
    }
    // last element
    if (activeIndex >= lastNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
        return returnFirstNode;
    }
    // jump out, but not on the guard
    if (indexDiff && Math.abs(correctedIndexDiff) > 1) {
        return lastNodeInside;
    }
    // focus above lock
    if (activeIndex <= firstNodeIndex) {
        return returnLastNode;
    }
    // focus below lock
    if (activeIndex > lastNodeIndex) {
        return returnFirstNode;
    }
    // index is inside tab order, but outside Lock
    if (indexDiff) {
        if (Math.abs(indexDiff) > 1) {
            return lastNodeInside;
        }
        return (cnt + lastNodeInside + indexDiff) % cnt;
    }
    // do nothing
    return undefined;
};
exports.newFocus = newFocus;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\solver.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\tabHook.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5CtabHook.js
      return function (require, module, exports) {
"use strict";
/* eslint-disable */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @deprecated does nothing
 */
exports.default = {
    attach: function () { },
    detach: function () { },
};

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\tabHook.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\DOMutils.js", {"./array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\array.js","./is":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\is.js","./tabOrder":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\tabOrder.js","./tabUtils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\tabUtils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5CDOMutils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.contains = exports.parentAutofocusables = exports.getAllTabbableNodes = exports.getTabbableNodes = exports.filterAutoFocusable = exports.filterFocusable = void 0;
var array_1 = require("./array");
var is_1 = require("./is");
var tabOrder_1 = require("./tabOrder");
var tabUtils_1 = require("./tabUtils");
/**
 * given list of focusable elements keeps the ones user can interact with
 * @param nodes
 * @param visibilityCache
 */
var filterFocusable = function (nodes, visibilityCache) {
    return (0, array_1.toArray)(nodes)
        .filter(function (node) { return (0, is_1.isVisibleCached)(visibilityCache, node); })
        .filter(function (node) { return (0, is_1.notHiddenInput)(node); });
};
exports.filterFocusable = filterFocusable;
var filterAutoFocusable = function (nodes, cache) {
    if (cache === void 0) { cache = new Map(); }
    return (0, array_1.toArray)(nodes).filter(function (node) { return (0, is_1.isAutoFocusAllowedCached)(cache, node); });
};
exports.filterAutoFocusable = filterAutoFocusable;
/**
 * only tabbable ones
 * (but with guards which would be ignored)
 */
var getTabbableNodes = function (topNodes, visibilityCache, withGuards) {
    return (0, tabOrder_1.orderByTabIndex)((0, exports.filterFocusable)((0, tabUtils_1.getFocusables)(topNodes, withGuards), visibilityCache), true, withGuards);
};
exports.getTabbableNodes = getTabbableNodes;
/**
 * actually anything "focusable", not only tabbable
 * (without guards, as long as they are not expected to be focused)
 */
var getAllTabbableNodes = function (topNodes, visibilityCache) {
    return (0, tabOrder_1.orderByTabIndex)((0, exports.filterFocusable)((0, tabUtils_1.getFocusables)(topNodes), visibilityCache), false);
};
exports.getAllTabbableNodes = getAllTabbableNodes;
/**
 * return list of nodes which are expected to be auto-focused
 * @param topNode
 * @param visibilityCache
 */
var parentAutofocusables = function (topNode, visibilityCache) {
    return (0, exports.filterFocusable)((0, tabUtils_1.getParentAutofocusables)(topNode), visibilityCache);
};
exports.parentAutofocusables = parentAutofocusables;
/*
 * Determines if element is contained in scope, including nested shadow DOMs
 */
var contains = function (scope, element) {
    if (scope.shadowRoot) {
        return (0, exports.contains)(scope.shadowRoot, element);
    }
    else {
        if (Object.getPrototypeOf(scope).contains !== undefined &&
            Object.getPrototypeOf(scope).contains.call(scope, element)) {
            return true;
        }
        return (0, array_1.toArray)(scope.children).some(function (child) {
            var _a;
            if (child instanceof HTMLIFrameElement) {
                var iframeBody = (_a = child.contentDocument) === null || _a === void 0 ? void 0 : _a.body;
                if (iframeBody) {
                    return (0, exports.contains)(iframeBody, element);
                }
                return false;
            }
            return (0, exports.contains)(child, element);
        });
    }
};
exports.contains = contains;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\DOMutils.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\all-affected.js", {"../constants":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\constants.js","./array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\array.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5Call-affected.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllAffectedNodes = void 0;
var constants_1 = require("../constants");
var array_1 = require("./array");
/**
 * in case of multiple nodes nested inside each other
 * keeps only top ones
 * this is O(nlogn)
 * @param nodes
 * @returns {*}
 */
var filterNested = function (nodes) {
    var contained = new Set();
    var l = nodes.length;
    for (var i = 0; i < l; i += 1) {
        for (var j = i + 1; j < l; j += 1) {
            var position = nodes[i].compareDocumentPosition(nodes[j]);
            /* eslint-disable no-bitwise */
            if ((position & Node.DOCUMENT_POSITION_CONTAINED_BY) > 0) {
                contained.add(j);
            }
            if ((position & Node.DOCUMENT_POSITION_CONTAINS) > 0) {
                contained.add(i);
            }
            /* eslint-enable */
        }
    }
    return nodes.filter(function (_, index) { return !contained.has(index); });
};
/**
 * finds top most parent for a node
 * @param node
 * @returns {*}
 */
var getTopParent = function (node) {
    return node.parentNode ? getTopParent(node.parentNode) : node;
};
/**
 * returns all "focus containers" inside a given node
 * @param node
 * @returns {T}
 */
var getAllAffectedNodes = function (node) {
    var nodes = (0, array_1.asArray)(node);
    return nodes.filter(Boolean).reduce(function (acc, currentNode) {
        var group = currentNode.getAttribute(constants_1.FOCUS_GROUP);
        acc.push.apply(acc, (group
            ? filterNested((0, array_1.toArray)(getTopParent(currentNode).querySelectorAll("[".concat(constants_1.FOCUS_GROUP, "=\"").concat(group, "\"]:not([").concat(constants_1.FOCUS_DISABLED, "=\"disabled\"])"))))
            : [currentNode]));
        return acc;
    }, []);
};
exports.getAllAffectedNodes = getAllAffectedNodes;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\all-affected.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\array.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5Carray.js
      return function (require, module, exports) {
"use strict";
/*
IE11 support
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFirst = exports.asArray = exports.toArray = void 0;
var toArray = function (a) {
    var ret = Array(a.length);
    for (var i = 0; i < a.length; ++i) {
        ret[i] = a[i];
    }
    return ret;
};
exports.toArray = toArray;
var asArray = function (a) { return (Array.isArray(a) ? a : [a]); };
exports.asArray = asArray;
var getFirst = function (a) { return (Array.isArray(a) ? a[0] : a); };
exports.getFirst = getFirst;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\array.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\auto-focus.js", {"./DOMutils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\DOMutils.js","./firstFocus":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\firstFocus.js","./is":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\is.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5Cauto-focus.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pickAutofocus = void 0;
var DOMutils_1 = require("./DOMutils");
var firstFocus_1 = require("./firstFocus");
var is_1 = require("./is");
var findAutoFocused = function (autoFocusables) {
    return function (node) {
        var _a;
        var autofocus = (_a = (0, is_1.getDataset)(node)) === null || _a === void 0 ? void 0 : _a.autofocus;
        return (
        // @ts-expect-error
        node.autofocus ||
            //
            (autofocus !== undefined && autofocus !== 'false') ||
            //
            autoFocusables.indexOf(node) >= 0);
    };
};
var pickAutofocus = function (nodesIndexes, orderedNodes, groups) {
    var nodes = nodesIndexes.map(function (_a) {
        var node = _a.node;
        return node;
    });
    var autoFocusable = (0, DOMutils_1.filterAutoFocusable)(nodes.filter(findAutoFocused(groups)));
    if (autoFocusable && autoFocusable.length) {
        return (0, firstFocus_1.pickFirstFocus)(autoFocusable);
    }
    return (0, firstFocus_1.pickFirstFocus)((0, DOMutils_1.filterAutoFocusable)(orderedNodes));
};
exports.pickAutofocus = pickAutofocus;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\auto-focus.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\correctFocus.js", {"./is":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\is.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5CcorrectFocus.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.correctNodes = exports.correctNode = void 0;
var is_1 = require("./is");
var findSelectedRadio = function (node, nodes) {
    return nodes
        .filter(is_1.isRadioElement)
        .filter(function (el) { return el.name === node.name; })
        .filter(function (el) { return el.checked; })[0] || node;
};
var correctNode = function (node, nodes) {
    if ((0, is_1.isRadioElement)(node) && node.name) {
        return findSelectedRadio(node, nodes);
    }
    return node;
};
exports.correctNode = correctNode;
/**
 * giving a set of radio inputs keeps only selected (tabbable) ones
 * @param nodes
 */
var correctNodes = function (nodes) {
    // IE11 has no Set(array) constructor
    var resultSet = new Set();
    nodes.forEach(function (node) { return resultSet.add((0, exports.correctNode)(node, nodes)); });
    // using filter to support IE11
    return nodes.filter(function (node) { return resultSet.has(node); });
};
exports.correctNodes = correctNodes;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\correctFocus.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\firstFocus.js", {"./correctFocus":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\correctFocus.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5CfirstFocus.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pickFocusable = exports.pickFirstFocus = void 0;
var correctFocus_1 = require("./correctFocus");
var pickFirstFocus = function (nodes) {
    if (nodes[0] && nodes.length > 1) {
        return (0, correctFocus_1.correctNode)(nodes[0], nodes);
    }
    return nodes[0];
};
exports.pickFirstFocus = pickFirstFocus;
var pickFocusable = function (nodes, index) {
    if (nodes.length > 1) {
        return nodes.indexOf((0, correctFocus_1.correctNode)(nodes[index], nodes));
    }
    return index;
};
exports.pickFocusable = pickFocusable;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\firstFocus.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\getActiveElement.js", {"./safe":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\safe.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5CgetActiveElement.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getActiveElement = void 0;
/**
 * returns active element from document or from nested shadowdoms
 */
var safe_1 = require("./safe");
var getActiveElement = function (inDocument) {
    if (inDocument === void 0) { inDocument = document; }
    if (!inDocument || !inDocument.activeElement) {
        return undefined;
    }
    var activeElement = inDocument.activeElement;
    return (activeElement.shadowRoot
        ? (0, exports.getActiveElement)(activeElement.shadowRoot)
        : activeElement instanceof HTMLIFrameElement && (0, safe_1.safeProbe)(function () { return activeElement.contentWindow.document; })
            ? (0, exports.getActiveElement)(activeElement.contentWindow.document)
            : activeElement);
};
exports.getActiveElement = getActiveElement;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\getActiveElement.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\is.js", {"../constants":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\constants.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5Cis.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDefined = exports.isNotAGuard = exports.isGuard = exports.isAutoFocusAllowed = exports.notHiddenInput = exports.isRadioElement = exports.isHTMLInputElement = exports.isHTMLButtonElement = exports.getDataset = exports.isAutoFocusAllowedCached = exports.isVisibleCached = void 0;
var constants_1 = require("../constants");
var isElementHidden = function (node) {
    // we can measure only "elements"
    // consider others as "visible"
    if (node.nodeType !== Node.ELEMENT_NODE) {
        return false;
    }
    var computedStyle = window.getComputedStyle(node, null);
    if (!computedStyle || !computedStyle.getPropertyValue) {
        return false;
    }
    return (computedStyle.getPropertyValue('display') === 'none' || computedStyle.getPropertyValue('visibility') === 'hidden');
};
var getParentNode = function (node) {
    // DOCUMENT_FRAGMENT_NODE can also point on ShadowRoot. In this case .host will point on the next node
    return node.parentNode && node.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE
        ? // eslint-disable-next-line @typescript-eslint/no-explicit-any
            node.parentNode.host
        : node.parentNode;
};
var isTopNode = function (node) {
    // @ts-ignore
    return node === document || (node && node.nodeType === Node.DOCUMENT_NODE);
};
var isVisibleUncached = function (node, checkParent) {
    return !node || isTopNode(node) || (!isElementHidden(node) && checkParent(getParentNode(node)));
};
var isVisibleCached = function (visibilityCache, node) {
    var cached = visibilityCache.get(node);
    if (cached !== undefined) {
        return cached;
    }
    var result = isVisibleUncached(node, exports.isVisibleCached.bind(undefined, visibilityCache));
    visibilityCache.set(node, result);
    return result;
};
exports.isVisibleCached = isVisibleCached;
var isAutoFocusAllowedUncached = function (node, checkParent) {
    return node && !isTopNode(node) ? ((0, exports.isAutoFocusAllowed)(node) ? checkParent(getParentNode(node)) : false) : true;
};
var isAutoFocusAllowedCached = function (cache, node) {
    var cached = cache.get(node);
    if (cached !== undefined) {
        return cached;
    }
    var result = isAutoFocusAllowedUncached(node, exports.isAutoFocusAllowedCached.bind(undefined, cache));
    cache.set(node, result);
    return result;
};
exports.isAutoFocusAllowedCached = isAutoFocusAllowedCached;
var getDataset = function (node) {
    // @ts-ignore
    return node.dataset;
};
exports.getDataset = getDataset;
var isHTMLButtonElement = function (node) { return node.tagName === 'BUTTON'; };
exports.isHTMLButtonElement = isHTMLButtonElement;
var isHTMLInputElement = function (node) { return node.tagName === 'INPUT'; };
exports.isHTMLInputElement = isHTMLInputElement;
var isRadioElement = function (node) {
    return (0, exports.isHTMLInputElement)(node) && node.type === 'radio';
};
exports.isRadioElement = isRadioElement;
var notHiddenInput = function (node) {
    return !(((0, exports.isHTMLInputElement)(node) || (0, exports.isHTMLButtonElement)(node)) && (node.type === 'hidden' || node.disabled));
};
exports.notHiddenInput = notHiddenInput;
var isAutoFocusAllowed = function (node) {
    var attribute = node.getAttribute(constants_1.FOCUS_NO_AUTOFOCUS);
    return ![true, 'true', ''].includes(attribute);
};
exports.isAutoFocusAllowed = isAutoFocusAllowed;
var isGuard = function (node) { var _a; return Boolean(node && ((_a = (0, exports.getDataset)(node)) === null || _a === void 0 ? void 0 : _a.focusGuard)); };
exports.isGuard = isGuard;
var isNotAGuard = function (node) { return !(0, exports.isGuard)(node); };
exports.isNotAGuard = isNotAGuard;
var isDefined = function (x) { return Boolean(x); };
exports.isDefined = isDefined;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\is.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\parenting.js", {"./DOMutils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\DOMutils.js","./array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\array.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5Cparenting.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.allParentAutofocusables = exports.getTopCommonParent = exports.getCommonParent = void 0;
var DOMutils_1 = require("./DOMutils");
var DOMutils_2 = require("./DOMutils");
var array_1 = require("./array");
var getParents = function (node, parents) {
    if (parents === void 0) { parents = []; }
    parents.push(node);
    if (node.parentNode) {
        getParents(node.parentNode.host || node.parentNode, parents);
    }
    return parents;
};
/**
 * finds a parent for both nodeA and nodeB
 * @param nodeA
 * @param nodeB
 * @returns {boolean|*}
 */
var getCommonParent = function (nodeA, nodeB) {
    var parentsA = getParents(nodeA);
    var parentsB = getParents(nodeB);
    // tslint:disable-next-line:prefer-for-of
    for (var i = 0; i < parentsA.length; i += 1) {
        var currentParent = parentsA[i];
        if (parentsB.indexOf(currentParent) >= 0) {
            return currentParent;
        }
    }
    return false;
};
exports.getCommonParent = getCommonParent;
var getTopCommonParent = function (baseActiveElement, leftEntry, rightEntries) {
    var activeElements = (0, array_1.asArray)(baseActiveElement);
    var leftEntries = (0, array_1.asArray)(leftEntry);
    var activeElement = activeElements[0];
    var topCommon = false;
    leftEntries.filter(Boolean).forEach(function (entry) {
        topCommon = (0, exports.getCommonParent)(topCommon || entry, entry) || topCommon;
        rightEntries.filter(Boolean).forEach(function (subEntry) {
            var common = (0, exports.getCommonParent)(activeElement, subEntry);
            if (common) {
                if (!topCommon || (0, DOMutils_2.contains)(common, topCommon)) {
                    topCommon = common;
                }
                else {
                    topCommon = (0, exports.getCommonParent)(common, topCommon);
                }
            }
        });
    });
    // TODO: add assert here?
    return topCommon;
};
exports.getTopCommonParent = getTopCommonParent;
/**
 * return list of nodes which are expected to be autofocused inside a given top nodes
 * @param entries
 * @param visibilityCache
 */
var allParentAutofocusables = function (entries, visibilityCache) {
    return entries.reduce(function (acc, node) { return acc.concat((0, DOMutils_1.parentAutofocusables)(node, visibilityCache)); }, []);
};
exports.allParentAutofocusables = allParentAutofocusables;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\parenting.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\safe.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5Csafe.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.safeProbe = void 0;
var safeProbe = function (cb) {
    try {
        return cb();
    }
    catch (e) {
        return undefined;
    }
};
exports.safeProbe = safeProbe;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\safe.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\tabOrder.js", {"./array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\array.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5CtabOrder.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.orderByTabIndex = exports.tabSort = void 0;
var array_1 = require("./array");
var tabSort = function (a, b) {
    var tabDiff = a.tabIndex - b.tabIndex;
    var indexDiff = a.index - b.index;
    if (tabDiff) {
        if (!a.tabIndex) {
            return 1;
        }
        if (!b.tabIndex) {
            return -1;
        }
    }
    return tabDiff || indexDiff;
};
exports.tabSort = tabSort;
var orderByTabIndex = function (nodes, filterNegative, keepGuards) {
    return (0, array_1.toArray)(nodes)
        .map(function (node, index) { return ({
        node: node,
        index: index,
        tabIndex: keepGuards && node.tabIndex === -1 ? ((node.dataset || {}).focusGuard ? 0 : -1) : node.tabIndex,
    }); })
        .filter(function (data) { return !filterNegative || data.tabIndex >= 0; })
        .sort(exports.tabSort);
};
exports.orderByTabIndex = orderByTabIndex;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\tabOrder.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\tabUtils.js", {"../constants":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\constants.js","./array":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\array.js","./tabbables":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\tabbables.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5CtabUtils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getParentAutofocusables = exports.getFocusables = void 0;
var constants_1 = require("../constants");
var array_1 = require("./array");
var tabbables_1 = require("./tabbables");
var queryTabbables = tabbables_1.tabbables.join(',');
var queryGuardTabbables = "".concat(queryTabbables, ", [data-focus-guard]");
var getFocusablesWithShadowDom = function (parent, withGuards) {
    return (0, array_1.toArray)((parent.shadowRoot || parent).children).reduce(function (acc, child) {
        return acc.concat(child.matches(withGuards ? queryGuardTabbables : queryTabbables) ? [child] : [], getFocusablesWithShadowDom(child));
    }, []);
};
var getFocusablesWithIFrame = function (parent, withGuards) {
    var _a;
    // contentDocument of iframe will be null if current origin cannot access it
    if (parent instanceof HTMLIFrameElement && ((_a = parent.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) {
        return (0, exports.getFocusables)([parent.contentDocument.body], withGuards);
    }
    return [parent];
};
var getFocusables = function (parents, withGuards) {
    return parents.reduce(function (acc, parent) {
        var _a;
        var focusableWithShadowDom = getFocusablesWithShadowDom(parent, withGuards);
        var focusableWithIframes = (_a = []).concat.apply(_a, focusableWithShadowDom.map(function (node) { return getFocusablesWithIFrame(node, withGuards); }));
        return acc.concat(
        // add all tabbables inside and within shadow DOMs in DOM order
        focusableWithIframes, 
        // add if node is tabbable itself
        parent.parentNode
            ? (0, array_1.toArray)(parent.parentNode.querySelectorAll(queryTabbables)).filter(function (node) { return node === parent; })
            : []);
    }, []);
};
exports.getFocusables = getFocusables;
/**
 * return a list of focusable nodes within an area marked as "auto-focusable"
 * @param parent
 */
var getParentAutofocusables = function (parent) {
    var parentFocus = parent.querySelectorAll("[".concat(constants_1.FOCUS_AUTO, "]"));
    return (0, array_1.toArray)(parentFocus)
        .map(function (node) { return (0, exports.getFocusables)([node]); })
        .reduce(function (acc, nodes) { return acc.concat(nodes); }, []);
};
exports.getParentAutofocusables = getParentAutofocusables;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\tabUtils.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\focus-lock\\dist\\es5\\utils\\tabbables.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5Ctabbables.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tabbables = void 0;
/**
 * list of the object to be considered as focusable
 */
exports.tabbables = [
    'button:enabled',
    'select:enabled',
    'textarea:enabled',
    'input:enabled',
    // elements with explicit roles will also use explicit tabindex
    // '[role="button"]',
    'a[href]',
    'area[href]',
    'summary',
    'iframe',
    'object',
    'embed',
    'audio[controls]',
    'video[controls]',
    '[tabindex]',
    '[contenteditable]',
    '[autofocus]',
];

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\tabbables.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\foreach\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cforeach%5Cindex.js
      return function (require, module, exports) {

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


      };
    };
  }
  }
}, {package:"@truffle/decoder>@truffle/source-map-utils>json-pointer>foreach",file:"node_modules\\foreach\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\function-bind\\implementation.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfunction-bind%5Cimplementation.js
      return function (require, module, exports) {
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

      };
    };
  }
  }
}, {package:"browserify>has>function-bind",file:"node_modules\\function-bind\\implementation.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\function-bind\\index.js", {"./implementation":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\function-bind\\implementation.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfunction-bind%5Cindex.js
      return function (require, module, exports) {
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

      };
    };
  }
  }
}, {package:"browserify>has>function-bind",file:"node_modules\\function-bind\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\functions-have-names\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfunctions-have-names%5Cindex.js
      return function (require, module, exports) {
'use strict';

var functionsHaveNames = function functionsHaveNames() {
	return typeof function f() {}.name === 'string';
};

var gOPD = Object.getOwnPropertyDescriptor;
if (gOPD) {
	try {
		gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		gOPD = null;
	}
}

functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
	if (!functionsHaveNames() || !gOPD) {
		return false;
	}
	var desc = gOPD(function () {}, 'name');
	return !!desc && !!desc.configurable;
};

var $bind = Function.prototype.bind;

functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
	return functionsHaveNames() && typeof $bind === 'function' && function f() {}.bind().name !== '';
};

module.exports = functionsHaveNames;

      };
    };
  }
  }
}, {package:"string.prototype.matchall>regexp.prototype.flags>functions-have-names",file:"node_modules\\functions-have-names\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\fuse.js\\dist\\fuse.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cfuse.js%5Cdist%5Cfuse.js
      return function (require, module, exports) {
/*!
 * Fuse.js v3.6.1 - Lightweight fuzzy-search (http://fusejs.io)
 * 
 * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)
 * All Rights Reserved. Apache Software License 2.0
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("Fuse",[],t):"object"==typeof exports?exports.Fuse=t():e.Fuse=t()}(this,function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t,r){function n(e){return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function o(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var i=r(1),a=r(7),s=a.get,c=(a.deepValue,a.isArray),h=function(){function e(t,r){var n=r.location,o=void 0===n?0:n,i=r.distance,a=void 0===i?100:i,c=r.threshold,h=void 0===c?.6:c,l=r.maxPatternLength,u=void 0===l?32:l,f=r.caseSensitive,v=void 0!==f&&f,p=r.tokenSeparator,d=void 0===p?/ +/g:p,g=r.findAllMatches,y=void 0!==g&&g,m=r.minMatchCharLength,k=void 0===m?1:m,b=r.id,S=void 0===b?null:b,x=r.keys,M=void 0===x?[]:x,_=r.shouldSort,w=void 0===_||_,L=r.getFn,A=void 0===L?s:L,O=r.sortFn,C=void 0===O?function(e,t){return e.score-t.score}:O,j=r.tokenize,P=void 0!==j&&j,I=r.matchAllTokens,F=void 0!==I&&I,T=r.includeMatches,N=void 0!==T&&T,z=r.includeScore,E=void 0!==z&&z,W=r.verbose,K=void 0!==W&&W;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.options={location:o,distance:a,threshold:h,maxPatternLength:u,isCaseSensitive:v,tokenSeparator:d,findAllMatches:y,minMatchCharLength:k,id:S,keys:M,includeMatches:N,includeScore:E,shouldSort:w,getFn:A,sortFn:C,verbose:K,tokenize:P,matchAllTokens:F},this.setCollection(t),this._processKeys(M)}var t,r,a;return t=e,(r=[{key:"setCollection",value:function(e){return this.list=e,e}},{key:"_processKeys",value:function(e){if(this._keyWeights={},this._keyNames=[],e.length&&"string"==typeof e[0])for(var t=0,r=e.length;t<r;t+=1){var n=e[t];this._keyWeights[n]=1,this._keyNames.push(n)}else{for(var o=null,i=null,a=0,s=0,c=e.length;s<c;s+=1){var h=e[s];if(!h.hasOwnProperty("name"))throw new Error('Missing "name" property in key object');var l=h.name;if(this._keyNames.push(l),!h.hasOwnProperty("weight"))throw new Error('Missing "weight" property in key object');var u=h.weight;if(u<0||u>1)throw new Error('"weight" property in key must bein the range of [0, 1)');i=null==i?u:Math.max(i,u),o=null==o?u:Math.min(o,u),this._keyWeights[l]=u,a+=u}if(a>1)throw new Error("Total of weights cannot exceed 1")}}},{key:"search",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{limit:!1};this._log('---------\nSearch pattern: "'.concat(e,'"'));var r=this._prepareSearchers(e),n=r.tokenSearchers,o=r.fullSearcher,i=this._search(n,o);return this._computeScore(i),this.options.shouldSort&&this._sort(i),t.limit&&"number"==typeof t.limit&&(i=i.slice(0,t.limit)),this._format(i)}},{key:"_prepareSearchers",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",t=[];if(this.options.tokenize)for(var r=e.split(this.options.tokenSeparator),n=0,o=r.length;n<o;n+=1)t.push(new i(r[n],this.options));return{tokenSearchers:t,fullSearcher:new i(e,this.options)}}},{key:"_search",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1?arguments[1]:void 0,r=this.list,n={},o=[];if("string"==typeof r[0]){for(var i=0,a=r.length;i<a;i+=1)this._analyze({key:"",value:r[i],record:i,index:i},{resultMap:n,results:o,tokenSearchers:e,fullSearcher:t});return o}for(var s=0,c=r.length;s<c;s+=1)for(var h=r[s],l=0,u=this._keyNames.length;l<u;l+=1){var f=this._keyNames[l];this._analyze({key:f,value:this.options.getFn(h,f),record:h,index:s},{resultMap:n,results:o,tokenSearchers:e,fullSearcher:t})}return o}},{key:"_analyze",value:function(e,t){var r=this,n=e.key,o=e.arrayIndex,i=void 0===o?-1:o,a=e.value,s=e.record,h=e.index,l=t.tokenSearchers,u=void 0===l?[]:l,f=t.fullSearcher,v=t.resultMap,p=void 0===v?{}:v,d=t.results,g=void 0===d?[]:d;!function e(t,o,i,a){if(null!=o)if("string"==typeof o){var s=!1,h=-1,l=0;r._log("\nKey: ".concat(""===n?"--":n));var v=f.search(o);if(r._log('Full text: "'.concat(o,'", score: ').concat(v.score)),r.options.tokenize){for(var d=o.split(r.options.tokenSeparator),y=d.length,m=[],k=0,b=u.length;k<b;k+=1){var S=u[k];r._log('\nPattern: "'.concat(S.pattern,'"'));for(var x=!1,M=0;M<y;M+=1){var _=d[M],w=S.search(_),L={};w.isMatch?(L[_]=w.score,s=!0,x=!0,m.push(w.score)):(L[_]=1,r.options.matchAllTokens||m.push(1)),r._log('Token: "'.concat(_,'", score: ').concat(L[_]))}x&&(l+=1)}h=m[0];for(var A=m.length,O=1;O<A;O+=1)h+=m[O];h/=A,r._log("Token score average:",h)}var C=v.score;h>-1&&(C=(C+h)/2),r._log("Score average:",C);var j=!r.options.tokenize||!r.options.matchAllTokens||l>=u.length;if(r._log("\nCheck Matches: ".concat(j)),(s||v.isMatch)&&j){var P={key:n,arrayIndex:t,value:o,score:C};r.options.includeMatches&&(P.matchedIndices=v.matchedIndices);var I=p[a];I?I.output.push(P):(p[a]={item:i,output:[P]},g.push(p[a]))}}else if(c(o))for(var F=0,T=o.length;F<T;F+=1)e(F,o[F],i,a)}(i,a,s,h)}},{key:"_computeScore",value:function(e){this._log("\n\nComputing score:\n");for(var t=this._keyWeights,r=!!Object.keys(t).length,n=0,o=e.length;n<o;n+=1){for(var i=e[n],a=i.output,s=a.length,c=1,h=0;h<s;h+=1){var l=a[h],u=l.key,f=r?t[u]:1,v=0===l.score&&t&&t[u]>0?Number.EPSILON:l.score;c*=Math.pow(v,f)}i.score=c,this._log(i)}}},{key:"_sort",value:function(e){this._log("\n\nSorting...."),e.sort(this.options.sortFn)}},{key:"_format",value:function(e){var t=[];if(this.options.verbose){var r=[];this._log("\n\nOutput:\n\n",JSON.stringify(e,function(e,t){if("object"===n(t)&&null!==t){if(-1!==r.indexOf(t))return;r.push(t)}return t},2)),r=null}var o=[];this.options.includeMatches&&o.push(function(e,t){var r=e.output;t.matches=[];for(var n=0,o=r.length;n<o;n+=1){var i=r[n];if(0!==i.matchedIndices.length){var a={indices:i.matchedIndices,value:i.value};i.key&&(a.key=i.key),i.hasOwnProperty("arrayIndex")&&i.arrayIndex>-1&&(a.arrayIndex=i.arrayIndex),t.matches.push(a)}}}),this.options.includeScore&&o.push(function(e,t){t.score=e.score});for(var i=0,a=e.length;i<a;i+=1){var s=e[i];if(this.options.id&&(s.item=this.options.getFn(s.item,this.options.id)[0]),o.length){for(var c={item:s.item},h=0,l=o.length;h<l;h+=1)o[h](s,c);t.push(c)}else t.push(s.item)}return t}},{key:"_log",value:function(){var e;this.options.verbose&&(e=console).log.apply(e,arguments)}}])&&o(t.prototype,r),a&&o(t,a),e}();e.exports=h},function(e,t,r){function n(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var o=r(2),i=r(3),a=r(6),s=function(){function e(t,r){var n=r.location,o=void 0===n?0:n,i=r.distance,s=void 0===i?100:i,c=r.threshold,h=void 0===c?.6:c,l=r.maxPatternLength,u=void 0===l?32:l,f=r.isCaseSensitive,v=void 0!==f&&f,p=r.tokenSeparator,d=void 0===p?/ +/g:p,g=r.findAllMatches,y=void 0!==g&&g,m=r.minMatchCharLength,k=void 0===m?1:m,b=r.includeMatches,S=void 0!==b&&b;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.options={location:o,distance:s,threshold:h,maxPatternLength:u,isCaseSensitive:v,tokenSeparator:d,findAllMatches:y,includeMatches:S,minMatchCharLength:k},this.pattern=v?t:t.toLowerCase(),this.pattern.length<=u&&(this.patternAlphabet=a(this.pattern))}var t,r,s;return t=e,(r=[{key:"search",value:function(e){var t=this.options,r=t.isCaseSensitive,n=t.includeMatches;if(r||(e=e.toLowerCase()),this.pattern===e){var a={isMatch:!0,score:0};return n&&(a.matchedIndices=[[0,e.length-1]]),a}var s=this.options,c=s.maxPatternLength,h=s.tokenSeparator;if(this.pattern.length>c)return o(e,this.pattern,h);var l=this.options,u=l.location,f=l.distance,v=l.threshold,p=l.findAllMatches,d=l.minMatchCharLength;return i(e,this.pattern,this.patternAlphabet,{location:u,distance:f,threshold:v,findAllMatches:p,minMatchCharLength:d,includeMatches:n})}}])&&n(t.prototype,r),s&&n(t,s),e}();e.exports=s},function(e,t){var r=/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g;e.exports=function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:/ +/g,o=new RegExp(t.replace(r,"\\$&").replace(n,"|")),i=e.match(o),a=!!i,s=[];if(a)for(var c=0,h=i.length;c<h;c+=1){var l=i[c];s.push([e.indexOf(l),l.length-1])}return{score:a?.5:1,isMatch:a,matchedIndices:s}}},function(e,t,r){var n=r(4),o=r(5);e.exports=function(e,t,r,i){for(var a=i.location,s=void 0===a?0:a,c=i.distance,h=void 0===c?100:c,l=i.threshold,u=void 0===l?.6:l,f=i.findAllMatches,v=void 0!==f&&f,p=i.minMatchCharLength,d=void 0===p?1:p,g=i.includeMatches,y=void 0!==g&&g,m=s,k=e.length,b=u,S=e.indexOf(t,m),x=t.length,M=[],_=0;_<k;_+=1)M[_]=0;if(-1!==S){var w=n(t,{errors:0,currentLocation:S,expectedLocation:m,distance:h});if(b=Math.min(w,b),-1!==(S=e.lastIndexOf(t,m+x))){var L=n(t,{errors:0,currentLocation:S,expectedLocation:m,distance:h});b=Math.min(L,b)}}S=-1;for(var A=[],O=1,C=x+k,j=1<<(x<=31?x-1:30),P=0;P<x;P+=1){for(var I=0,F=C;I<F;){n(t,{errors:P,currentLocation:m+F,expectedLocation:m,distance:h})<=b?I=F:C=F,F=Math.floor((C-I)/2+I)}C=F;var T=Math.max(1,m-F+1),N=v?k:Math.min(m+F,k)+x,z=Array(N+2);z[N+1]=(1<<P)-1;for(var E=N;E>=T;E-=1){var W=E-1,K=r[e.charAt(W)];if(K&&(M[W]=1),z[E]=(z[E+1]<<1|1)&K,0!==P&&(z[E]|=(A[E+1]|A[E])<<1|1|A[E+1]),z[E]&j&&(O=n(t,{errors:P,currentLocation:W,expectedLocation:m,distance:h}))<=b){if(b=O,(S=W)<=m)break;T=Math.max(1,2*m-S)}}if(n(t,{errors:P+1,currentLocation:m,expectedLocation:m,distance:h})>b)break;A=z}var $={isMatch:S>=0,score:0===O?.001:O};return y&&($.matchedIndices=o(M,d)),$}},function(e,t){e.exports=function(e,t){var r=t.errors,n=void 0===r?0:r,o=t.currentLocation,i=void 0===o?0:o,a=t.expectedLocation,s=void 0===a?0:a,c=t.distance,h=void 0===c?100:c,l=n/e.length,u=Math.abs(s-i);return h?l+u/h:u?1:l}},function(e,t){e.exports=function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,r=[],n=-1,o=-1,i=0,a=e.length;i<a;i+=1){var s=e[i];s&&-1===n?n=i:s||-1===n||((o=i-1)-n+1>=t&&r.push([n,o]),n=-1)}return e[i-1]&&i-n>=t&&r.push([n,i-1]),r}},function(e,t){e.exports=function(e){for(var t={},r=e.length,n=0;n<r;n+=1)t[e.charAt(n)]=0;for(var o=0;o<r;o+=1)t[e.charAt(o)]|=1<<r-o-1;return t}},function(e,t){var r=function(e){return Array.isArray?Array.isArray(e):"[object Array]"===Object.prototype.toString.call(e)},n=function(e){return null==e?"":function(e){if("string"==typeof e)return e;var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}(e)},o=function(e){return"string"==typeof e},i=function(e){return"number"==typeof e};e.exports={get:function(e,t){var a=[];return function e(t,s){if(s){var c=s.indexOf("."),h=s,l=null;-1!==c&&(h=s.slice(0,c),l=s.slice(c+1));var u=t[h];if(null!=u)if(l||!o(u)&&!i(u))if(r(u))for(var f=0,v=u.length;f<v;f+=1)e(u[f],l);else l&&e(u,l);else a.push(n(u))}else a.push(t)}(e,t),a},isArray:r,isString:o,isNum:i,toString:n}}])});
      };
    };
  }
  }
}, {package:"fuse.js",file:"node_modules\\fuse.js\\dist\\fuse.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\get-intrinsic\\index.js", {"function-bind":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\function-bind\\index.js","has":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\has\\src\\index.js","has-proto":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\has-proto\\index.js","has-symbols":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\has-symbols\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cget-intrinsic%5Cindex.js
      return function (require, module, exports) {
'use strict';

var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = require('has-symbols')();
var hasProto = require('has-proto')();

var getProto = Object.getPrototypeOf || (
	hasProto
		? function (x) { return x.__proto__; } // eslint-disable-line no-proto
		: null
);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = require('function-bind');
var hasOwn = require('has');
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};

      };
    };
  }
  }
}, {package:"string.prototype.matchall>get-intrinsic",file:"node_modules\\get-intrinsic\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\get-params\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cget-params%5Cindex.js
      return function (require, module, exports) {
/* global window */
var GetParams = function (func) {
	'use strict';

	if (typeof func !== 'function') {
		return [];
	}

	var patternComments = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
	var patternArguments = /([^\s,]+)/g;

	var funcString = func
		.toString()
		.replace(patternComments, '');

	var result = funcString
		.slice(
			funcString.indexOf('(') + 1,
			funcString.indexOf(')')
		)
		.match(patternArguments);

	if (result === null) {
		return [];
	}

	return result;
};

if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	module.exports = GetParams;
}

if (typeof window !== 'undefined') {
	window.GetParams = GetParams;
}

      };
    };
  }
  }
}, {package:"remote-redux-devtools>redux-devtools-core>get-params",file:"node_modules\\get-params\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\gl-mat4\\identity.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cgl-mat4%5Cidentity.js
      return function (require, module, exports) {
module.exports = identity;

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
      };
    };
  }
  }
}, {package:"@metamask/logo>gl-mat4",file:"node_modules\\gl-mat4\\identity.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\gl-mat4\\invert.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cgl-mat4%5Cinvert.js
      return function (require, module, exports) {
module.exports = invert;

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};
      };
    };
  }
  }
}, {package:"@metamask/logo>gl-mat4",file:"node_modules\\gl-mat4\\invert.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\gl-mat4\\lookAt.js", {"./identity":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\gl-mat4\\identity.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cgl-mat4%5ClookAt.js
      return function (require, module, exports) {
var identity = require('./identity');

module.exports = lookAt;

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < 0.000001 &&
        Math.abs(eyey - centery) < 0.000001 &&
        Math.abs(eyez - centerz) < 0.000001) {
        return identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};
      };
    };
  }
  }
}, {package:"@metamask/logo>gl-mat4",file:"node_modules\\gl-mat4\\lookAt.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\gl-mat4\\multiply.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cgl-mat4%5Cmultiply.js
      return function (require, module, exports) {
module.exports = multiply;

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};
      };
    };
  }
  }
}, {package:"@metamask/logo>gl-mat4",file:"node_modules\\gl-mat4\\multiply.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\gl-mat4\\perspective.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cgl-mat4%5Cperspective.js
      return function (require, module, exports) {
module.exports = perspective;

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};
      };
    };
  }
  }
}, {package:"@metamask/logo>gl-mat4",file:"node_modules\\gl-mat4\\perspective.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\gl-mat4\\rotate.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cgl-mat4%5Crotate.js
      return function (require, module, exports) {
module.exports = rotate;

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < 0.000001) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};
      };
    };
  }
  }
}, {package:"@metamask/logo>gl-mat4",file:"node_modules\\gl-mat4\\rotate.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\gl-vec3\\transformMat4.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cgl-vec3%5CtransformMat4.js
      return function (require, module, exports) {
module.exports = transformMat4;

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15]
    w = w || 1.0
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w
    return out
}
      };
    };
  }
  }
}, {package:"@metamask/logo>gl-vec3",file:"node_modules\\gl-vec3\\transformMat4.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\gud\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cgud%5Cindex.js
      return function (require, module, exports) {
// @flow
'use strict';

var key = '__global_unique_id__';

module.exports = function() {
  return global[key] = (global[key] || 0) + 1;
};

      };
    };
  }
  }
}, {package:"react-router-dom>react-router>mini-create-react-context>gud",file:"node_modules\\gud\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\has-property-descriptors\\index.js", {"get-intrinsic":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\get-intrinsic\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Chas-property-descriptors%5Cindex.js
      return function (require, module, exports) {
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	if ($defineProperty) {
		try {
			$defineProperty({}, 'a', { value: 1 });
			return true;
		} catch (e) {
			// IE 8 has a broken defineProperty
			return false;
		}
	}
	return false;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!hasPropertyDescriptors()) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;

      };
    };
  }
  }
}, {package:"globalthis>define-properties>has-property-descriptors",file:"node_modules\\has-property-descriptors\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\has-proto\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Chas-proto%5Cindex.js
      return function (require, module, exports) {
'use strict';

var test = {
	foo: {}
};

var $Object = Object;

module.exports = function hasProto() {
	return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
};

      };
    };
  }
  }
}, {package:"string.prototype.matchall>es-abstract>has-proto",file:"node_modules\\has-proto\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\has-symbols\\index.js", {"./shams":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\has-symbols\\shams.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Chas-symbols%5Cindex.js
      return function (require, module, exports) {
'use strict';

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

      };
    };
  }
  }
}, {package:"string.prototype.matchall>has-symbols",file:"node_modules\\has-symbols\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\has-symbols\\shams.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Chas-symbols%5Cshams.js
      return function (require, module, exports) {
'use strict';

/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

      };
    };
  }
  }
}, {package:"string.prototype.matchall>has-symbols",file:"node_modules\\has-symbols\\shams.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\has-tostringtag\\shams.js", {"has-symbols/shams":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\has-symbols\\shams.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Chas-tostringtag%5Cshams.js
      return function (require, module, exports) {
'use strict';

var hasSymbols = require('has-symbols/shams');

module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};

      };
    };
  }
  }
}, {package:"koa>is-generator-function>has-tostringtag",file:"node_modules\\has-tostringtag\\shams.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\has\\src\\index.js", {"function-bind":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\function-bind\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Chas%5Csrc%5Cindex.js
      return function (require, module, exports) {
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

      };
    };
  }
  }
}, {package:"browserify>has",file:"node_modules\\has\\src\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\header-case\\header-case.js", {"no-case":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\no-case\\no-case.js","upper-case":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\upper-case\\upper-case.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cheader-case%5Cheader-case.js
      return function (require, module, exports) {
var noCase = require('no-case')
var upperCase = require('upper-case')

/**
 * Header case a string.
 *
 * @param  {string} value
 * @param  {string} [locale]
 * @return {string}
 */
module.exports = function (value, locale) {
  return noCase(value, locale, '-').replace(/^.|-./g, function (m) {
    return upperCase(m, locale)
  })
}

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>header-case",file:"node_modules\\header-case\\header-case.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\hoist-non-react-statics\\dist\\hoist-non-react-statics.cjs.js", {"react-is":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\react-is\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Choist-non-react-statics%5Cdist%5Choist-non-react-statics.cjs.js
      return function (require, module, exports) {
'use strict';

var reactIs = require('react-is');

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

module.exports = hoistNonReactStatics;

      };
    };
  }
  }
}, {package:"react-redux>hoist-non-react-statics",file:"node_modules\\hoist-non-react-statics\\dist\\hoist-non-react-statics.cjs.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\hyphenate-style-name\\index.cjs.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Chyphenate-style-name%5Cindex.cjs.js
      return function (require, module, exports) {
'use strict';

/* eslint-disable no-var, prefer-template */
var uppercasePattern = /[A-Z]/g;
var msPattern = /^ms-/;
var cache = {};

function toHyphenLower(match) {
  return '-' + match.toLowerCase()
}

function hyphenateStyleName(name) {
  if (cache.hasOwnProperty(name)) {
    return cache[name]
  }

  var hName = name.replace(uppercasePattern, toHyphenLower);
  return (cache[name] = msPattern.test(hName) ? '-' + hName : hName)
}

module.exports = hyphenateStyleName;

      };
    };
  }
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-camel-case>hyphenate-style-name",file:"node_modules\\hyphenate-style-name\\index.cjs.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\is-arguments\\index.js", {"call-bind/callBound":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\call-bind\\callBound.js","has-tostringtag/shams":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\has-tostringtag\\shams.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cis-arguments%5Cindex.js
      return function (require, module, exports) {
'use strict';

var hasToStringTag = require('has-tostringtag/shams')();
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

      };
    };
  }
  }
}, {package:"@metamask/eth-token-tracker>deep-equal>is-arguments",file:"node_modules\\is-arguments\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\is-date-object\\index.js", {"has-tostringtag/shams":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\has-tostringtag\\shams.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cis-date-object%5Cindex.js
      return function (require, module, exports) {
'use strict';

var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateGetDayCall(value) {
	try {
		getDay.call(value);
		return true;
	} catch (e) {
		return false;
	}
};

var toStr = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag = require('has-tostringtag/shams')();

module.exports = function isDateObject(value) {
	if (typeof value !== 'object' || value === null) {
		return false;
	}
	return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};

      };
    };
  }
  }
}, {package:"@metamask/eth-token-tracker>deep-equal>is-date-object",file:"node_modules\\is-date-object\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\is-dom\\index.js", {"is-object":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\is-object\\index.js","is-window":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\is-window\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cis-dom%5Cindex.js
      return function (require, module, exports) {
var isObject = require('is-object')
var isWindow = require('is-window')

function isNode (val) {
  if (!isObject(val) || !isWindow(window) || typeof window.Node !== 'function') {
    return false
  }

  return typeof val.nodeType === 'number' &&
    typeof val.nodeName === 'string'
}

module.exports = isNode

      };
    };
  }
  }
}, {package:"react-inspector>is-dom",file:"node_modules\\is-dom\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\is-in-browser\\dist\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cis-in-browser%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isBrowser = exports.isBrowser = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && document.nodeType === 9;

exports.default = isBrowser;
      };
    };
  }
  }
}, {package:"@material-ui/core>@material-ui/styles>jss>is-in-browser",file:"node_modules\\is-in-browser\\dist\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\is-lower-case\\is-lower-case.js", {"lower-case":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lower-case\\lower-case.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cis-lower-case%5Cis-lower-case.js
      return function (require, module, exports) {
var lowerCase = require('lower-case')

/**
 * Check if a string is lower case.
 *
 * @param  {String}  string
 * @param  {String}  [locale]
 * @return {Boolean}
 */
module.exports = function (string, locale) {
  return lowerCase(string, locale) === string
}

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>is-lower-case",file:"node_modules\\is-lower-case\\is-lower-case.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\is-object\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cis-object%5Cindex.js
      return function (require, module, exports) {
"use strict";

module.exports = function isObject(x) {
	return typeof x === "object" && x !== null;
};

      };
    };
  }
  }
}, {package:"proxyquire>fill-keys>is-object",file:"node_modules\\is-object\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\is-regex\\index.js", {"call-bind/callBound":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\call-bind\\callBound.js","has-tostringtag/shams":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\has-tostringtag\\shams.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cis-regex%5Cindex.js
      return function (require, module, exports) {
'use strict';

var callBound = require('call-bind/callBound');
var hasToStringTag = require('has-tostringtag/shams')();
var has;
var $exec;
var isRegexMarker;
var badStringifier;

if (hasToStringTag) {
	has = callBound('Object.prototype.hasOwnProperty');
	$exec = callBound('RegExp.prototype.exec');
	isRegexMarker = {};

	var throwRegexMarker = function () {
		throw isRegexMarker;
	};
	badStringifier = {
		toString: throwRegexMarker,
		valueOf: throwRegexMarker
	};

	if (typeof Symbol.toPrimitive === 'symbol') {
		badStringifier[Symbol.toPrimitive] = throwRegexMarker;
	}
}

var $toString = callBound('Object.prototype.toString');
var gOPD = Object.getOwnPropertyDescriptor;
var regexClass = '[object RegExp]';

module.exports = hasToStringTag
	// eslint-disable-next-line consistent-return
	? function isRegex(value) {
		if (!value || typeof value !== 'object') {
			return false;
		}

		var descriptor = gOPD(value, 'lastIndex');
		var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
		if (!hasLastIndexDataProperty) {
			return false;
		}

		try {
			$exec(value, badStringifier);
		} catch (e) {
			return e === isRegexMarker;
		}
	}
	: function isRegex(value) {
		// In older browsers, typeof regex incorrectly returns 'function'
		if (!value || (typeof value !== 'object' && typeof value !== 'function')) {
			return false;
		}

		return $toString(value) === regexClass;
	};

      };
    };
  }
  }
}, {package:"string.prototype.matchall>es-abstract>is-regex",file:"node_modules\\is-regex\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\is-upper-case\\is-upper-case.js", {"upper-case":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\upper-case\\upper-case.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cis-upper-case%5Cis-upper-case.js
      return function (require, module, exports) {
var upperCase = require('upper-case')

/**
 * Check if a string is upper case.
 *
 * @param  {String}  string
 * @param  {String}  [locale]
 * @return {Boolean}
 */
module.exports = function (string, locale) {
  return upperCase(string, locale) === string
}

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>is-upper-case",file:"node_modules\\is-upper-case\\is-upper-case.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\is-window\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cis-window%5Cindex.js
      return function (require, module, exports) {
'use strict';

module.exports = function (obj) {

  if (obj == null) {
    return false;
  }

  var o = Object(obj);

  return o === o.window;
};

      };
    };
  }
  }
}, {package:"@lavamoat/snow>is-cross-origin>is-window",file:"node_modules\\is-window\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jsan\\index.js", {"./lib":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jsan\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cjsan%5Cindex.js
      return function (require, module, exports) {
module.exports = require('./lib');

      };
    };
  }
  }
}, {package:"remote-redux-devtools>jsan",file:"node_modules\\jsan\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jsan\\lib\\cycle.js", {"./path-getter":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jsan\\lib\\path-getter.js","./utils":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jsan\\lib\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cjsan%5Clib%5Ccycle.js
      return function (require, module, exports) {
var pathGetter = require('./path-getter');
var utils = require('./utils');

var WMap = typeof WeakMap !== 'undefined'?
  WeakMap:
  function() {
    var keys = [];
    var values = [];
    return {
      set: function(key, value) {
        keys.push(key);
        values.push(value);
      },
      get: function(key) {
        for (var i = 0; i < keys.length; i++) {
          if (keys[i] === key) {
            return values[i];
          }
        }
      }
    }
  };

// Based on https://github.com/douglascrockford/JSON-js/blob/master/cycle.js

exports.decycle = function decycle(object, options, replacer) {
  'use strict';

  var map = new WMap()

  var noCircularOption = !Object.prototype.hasOwnProperty.call(options, 'circular');
  var withRefs = options.refs !== false;

  return (function derez(_value, path, key) {

    // The derez recurses through the object, producing the deep copy.

    var i,        // The loop counter
      name,       // Property name
      nu;         // The new object or array

    // typeof null === 'object', so go on if this value is really an object but not
    // one of the weird builtin objects.

    var value = typeof replacer === 'function' ? replacer(key || '', _value) : _value;

    if (options.date && value instanceof Date) {
      return {$jsan: 'd' + value.getTime()};
    }
    if (options.regex && value instanceof RegExp) {
      return {$jsan: 'r' + utils.getRegexFlags(value) + ',' + value.source};
    }
    if (options['function'] && typeof value === 'function') {
      return {$jsan: 'f' + utils.stringifyFunction(value, options['function'])}
    }
    if (options['nan'] && typeof value === 'number' && isNaN(value)) {
      return {$jsan: 'n'}
    }
    if (options['infinity']) {
      if (Number.POSITIVE_INFINITY === value) return {$jsan: 'i'}
      if (Number.NEGATIVE_INFINITY === value) return {$jsan: 'y'}
    }
    if (options['undefined'] && value === undefined) {
      return {$jsan: 'u'}
    }
    if (options['error'] && value instanceof Error) {
      return {$jsan: 'e' + value.message}
    }
    if (options['symbol'] && typeof value === 'symbol') {
      var symbolKey = Symbol.keyFor(value)
      if (symbolKey !== undefined) {
        return {$jsan: 'g' + symbolKey}
      }

      // 'Symbol(foo)'.slice(7, -1) === 'foo'
      return {$jsan: 's' + value.toString().slice(7, -1)}
    }

    if (options['map'] && typeof Map === 'function' && value instanceof Map && typeof Array.from === 'function') {
      return {$jsan: 'm' + JSON.stringify(decycle(Array.from(value), options, replacer))}
    }

    if (options['set'] && typeof Set === 'function' && value instanceof Set && typeof Array.from === 'function') {
      return {$jsan: 'l' + JSON.stringify(decycle(Array.from(value), options, replacer))}
    }

    if (value && typeof value.toJSON === 'function') {
      try {
        value = value.toJSON(key);
      } catch (error) {
        var keyString = (key || '$');
        return "toJSON failed for '" + (map.get(value) || keyString) + "'";
      }
    }

    if (typeof value === 'object' && value !== null &&
      !(value instanceof Boolean) &&
      !(value instanceof Date)    &&
      !(value instanceof Number)  &&
      !(value instanceof RegExp)  &&
      !(value instanceof String)  &&
      !(typeof value === 'symbol')  &&
      !(value instanceof Error)) {

        // If the value is an object or array, look to see if we have already
        // encountered it. If so, return a $ref/path object.

      if (typeof value === 'object') {
        var foundPath = map.get(value);
        if (foundPath) {
          if (noCircularOption && withRefs) {
            return {$jsan: foundPath};
          }
          if (path.indexOf(foundPath) === 0) {
            if (!noCircularOption) {
              return typeof options.circular === 'function'?
              options.circular(value, path, foundPath):
              options.circular;
            }
            return {$jsan: foundPath};
          }
          if (withRefs) return {$jsan: foundPath};
        }
        map.set(value, path);
      }


      // If it is an array, replicate the array.

      if (Object.prototype.toString.apply(value) === '[object Array]') {
          nu = [];
          for (i = 0; i < value.length; i += 1) {
              nu[i] = derez(value[i], path + '[' + i + ']', i);
          }
      } else {

        // If it is an object, replicate the object.

        nu = {};
        for (name in value) {
          if (Object.prototype.hasOwnProperty.call(value, name)) {
            var nextPath = /^\w+$/.test(name) ?
              '.' + name :
              '[' + JSON.stringify(name) + ']';
            nu[name] = name === '$jsan' ? [derez(value[name], path + nextPath)] : derez(value[name], path + nextPath, name);
          }
        }
      }
      return nu;
    }
    return value;
  }(object, '$'));
};


exports.retrocycle = function retrocycle($) {
  'use strict';


  return (function rez(value) {

    // The rez function walks recursively through the object looking for $jsan
    // properties. When it finds one that has a value that is a path, then it
    // replaces the $jsan object with a reference to the value that is found by
    // the path.

    var i, item, name, path;

    if (value && typeof value === 'object') {
      if (Object.prototype.toString.apply(value) === '[object Array]') {
        for (i = 0; i < value.length; i += 1) {
          item = value[i];
          if (item && typeof item === 'object') {
            if (item.$jsan) {
              value[i] = utils.restore(item.$jsan, $);
            } else {
              rez(item);
            }
          }
        }
      } else {
        for (name in value) {
          // base case passed raw object
          if(typeof value[name] === 'string' && name === '$jsan'){
            return utils.restore(value.$jsan, $);
            break;
          }
          else {
            if (name === '$jsan') {
              value[name] = value[name][0];
            }
            if (typeof value[name] === 'object') {
              item = value[name];
              if (item && typeof item === 'object') {
                if (item.$jsan) {
                  value[name] = utils.restore(item.$jsan, $);
                } else {
                  rez(item);
                }
              }
            }
          }
        }
      }
    }
    return value;
  }($));
};

      };
    };
  }
  }
}, {package:"remote-redux-devtools>jsan",file:"node_modules\\jsan\\lib\\cycle.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jsan\\lib\\index.js", {"./cycle":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jsan\\lib\\cycle.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cjsan%5Clib%5Cindex.js
      return function (require, module, exports) {
var cycle = require('./cycle');

exports.stringify = function stringify(value, replacer, space, _options) {

  if (arguments.length < 4) {
    try {
      if (arguments.length === 1) {
        return JSON.stringify(value);
      } else {
        return JSON.stringify.apply(JSON, arguments);
      }
    } catch (e) {}
  }

  var options = _options || false;
  if (typeof options === 'boolean') {
    options = {
      'date': options,
      'function': options,
      'regex': options,
      'undefined': options,
      'error': options,
      'symbol': options,
      'map': options,
      'set': options,
      'nan': options,
      'infinity': options
    }
  }

  var decycled = cycle.decycle(value, options, replacer);
  if (arguments.length === 1) {
    return JSON.stringify(decycled);
  } else {
    // decycle already handles when replacer is a function.
    return JSON.stringify(decycled, Array.isArray(replacer) ? replacer : null, space);
  }
}

exports.parse = function parse(text, reviver) {
  var needsRetrocycle = /"\$jsan"/.test(text);
  var parsed;
  if (arguments.length === 1) {
    parsed = JSON.parse(text);
  } else {
    parsed = JSON.parse(text, reviver);
  }
  if (needsRetrocycle) {
    parsed = cycle.retrocycle(parsed);
  }
  return parsed;
}

      };
    };
  }
  }
}, {package:"remote-redux-devtools>jsan",file:"node_modules\\jsan\\lib\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jsan\\lib\\path-getter.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cjsan%5Clib%5Cpath-getter.js
      return function (require, module, exports) {
module.exports = pathGetter;

function pathGetter(obj, path) {
  if (path !== '$') {
    var paths = getPaths(path);
    for (var i = 0; i < paths.length; i++) {
      path = paths[i].toString().replace(/\\"/g, '"');
      if (typeof obj[path] === 'undefined' && i !== paths.length - 1) continue;
      obj = obj[path];
    }
  }
  return obj;
}

function getPaths(pathString) {
  var regex = /(?:\.(\w+))|(?:\[(\d+)\])|(?:\["((?:[^\\"]|\\.)*)"\])/g;
  var matches = [];
  var match;
  while (match = regex.exec(pathString)) {
    matches.push( match[1] || match[2] || match[3] );
  }
  return matches;
}

      };
    };
  }
  }
}, {package:"remote-redux-devtools>jsan",file:"node_modules\\jsan\\lib\\path-getter.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jsan\\lib\\utils.js", {"./":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jsan\\lib\\index.js","./path-getter":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jsan\\lib\\path-getter.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cjsan%5Clib%5Cutils.js
      return function (require, module, exports) {
var pathGetter = require('./path-getter');
var jsan = require('./');

exports.getRegexFlags = function getRegexFlags(regex) {
  var flags = '';
  if (regex.ignoreCase) flags += 'i';
  if (regex.global) flags += 'g';
  if (regex.multiline) flags += 'm';
  return flags;
};

exports.stringifyFunction = function stringifyFunction(fn, customToString) {
  if (typeof customToString === 'function') {
    return customToString(fn);
  }
  var str = fn.toString();
  var match = str.match(/^[^{]*{|^[^=]*=>/);
  var start = match ? match[0] : '<function> ';
  var end = str[str.length - 1] === '}' ? '}' : '';
  return start.replace(/\r\n|\n/g, ' ').replace(/\s+/g, ' ') + ' /* ... */ ' + end;
};

exports.restore = function restore(obj, root) {
  var type = obj[0];
  var rest = obj.slice(1);
  switch(type) {
    case '$':
      return pathGetter(root, obj);
    case 'r':
      var comma = rest.indexOf(',');
      var flags = rest.slice(0, comma);
      var source = rest.slice(comma + 1);
      return RegExp(source, flags);
    case 'd':
      return new Date(+rest);
    case 'f':
      var fn = function() { throw new Error("can't run jsan parsed function") };
      fn.toString = function() { return rest; };
      return fn;
    case 'u':
      return undefined;
    case 'e':
      var error = new Error(rest);
      error.stack = 'Stack is unavailable for jsan parsed errors';
      return error;
    case 's':
      return Symbol(rest);
    case 'g':
      return Symbol.for(rest);
    case 'm':
      return new Map(jsan.parse(rest));
    case 'l':
      return new Set(jsan.parse(rest));
    case 'n':
      return NaN;
    case 'i':
      return Infinity;
    case 'y':
      return -Infinity;
    default:
      console.warn('unknown type', obj);
      return obj;
  }
}

      };
    };
  }
  }
}, {package:"remote-redux-devtools>jsan",file:"node_modules\\jsan\\lib\\utils.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\json-pointer\\index.js", {"foreach":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\foreach\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cjson-pointer%5Cindex.js
      return function (require, module, exports) {
'use strict';

var each = require('foreach');
module.exports = api;


/**
 * Convenience wrapper around the api.
 * Calls `.get` when called with an `object` and a `pointer`.
 * Calls `.set` when also called with `value`.
 * If only supplied `object`, returns a partially applied function, mapped to the object.
 *
 * @param {Object} obj
 * @param {String|Array} pointer
 * @param value
 * @returns {*}
 */

function api (obj, pointer, value) {
    // .set()
    if (arguments.length === 3) {
        return api.set(obj, pointer, value);
    }
    // .get()
    if (arguments.length === 2) {
        return api.get(obj, pointer);
    }
    // Return a partially applied function on `obj`.
    var wrapped = api.bind(api, obj);

    // Support for oo style
    for (var name in api) {
        if (api.hasOwnProperty(name)) {
            wrapped[name] = api[name].bind(wrapped, obj);
        }
    }
    return wrapped;
}


/**
 * Lookup a json pointer in an object
 *
 * @param {Object} obj
 * @param {String|Array} pointer
 * @returns {*}
 */
api.get = function get (obj, pointer) {
    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);

    for (var i = 0; i < refTokens.length; ++i) {
        var tok = refTokens[i];
        if (!(typeof obj == 'object' && tok in obj)) {
            throw new Error('Invalid reference token: ' + tok);
        }
        obj = obj[tok];
    }
    return obj;
};

/**
 * Sets a value on an object
 *
 * @param {Object} obj
 * @param {String|Array} pointer
 * @param value
 */
api.set = function set (obj, pointer, value) {
    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer),
      nextTok = refTokens[0];

    if (refTokens.length === 0) {
      throw Error('Can not set the root object');
    }

    for (var i = 0; i < refTokens.length - 1; ++i) {
        var tok = refTokens[i];
        if (typeof tok !== 'string' && typeof tok !== 'number') {
          tok = String(tok)
        }
        if (tok === "__proto__" || tok === "constructor" || tok === "prototype") {
            continue
        }
        if (tok === '-' && Array.isArray(obj)) {
          tok = obj.length;
        }
        nextTok = refTokens[i + 1];

        if (!(tok in obj)) {
            if (nextTok.match(/^(\d+|-)$/)) {
                obj[tok] = [];
            } else {
                obj[tok] = {};
            }
        }
        obj = obj[tok];
    }
    if (nextTok === '-' && Array.isArray(obj)) {
      nextTok = obj.length;
    }
    obj[nextTok] = value;
    return this;
};

/**
 * Removes an attribute
 *
 * @param {Object} obj
 * @param {String|Array} pointer
 */
api.remove = function (obj, pointer) {
    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);
    var finalToken = refTokens[refTokens.length -1];
    if (finalToken === undefined) {
        throw new Error('Invalid JSON pointer for remove: "' + pointer + '"');
    }

    var parent = api.get(obj, refTokens.slice(0, -1));
    if (Array.isArray(parent)) {
      var index = +finalToken;
      if (finalToken === '' && isNaN(index)) {
        throw new Error('Invalid array index: "' + finalToken + '"');
      }

      Array.prototype.splice.call(parent, index, 1);
    } else {
      delete parent[finalToken];
    }
};

/**
 * Returns a (pointer -> value) dictionary for an object
 *
 * @param obj
 * @param {function} descend
 * @returns {}
 */
api.dict = function dict (obj, descend) {
    var results = {};
    api.walk(obj, function (value, pointer) {
        results[pointer] = value;
    }, descend);
    return results;
};

/**
 * Iterates over an object
 * Iterator: function (value, pointer) {}
 *
 * @param obj
 * @param {function} iterator
 * @param {function} descend
 */
api.walk = function walk (obj, iterator, descend) {
    var refTokens = [];

    descend = descend || function (value) {
        var type = Object.prototype.toString.call(value);
        return type === '[object Object]' || type === '[object Array]';
    };

    (function next (cur) {
        each(cur, function (value, key) {
            refTokens.push(String(key));
            if (descend(value)) {
                next(value);
            } else {
                iterator(value, api.compile(refTokens));
            }
            refTokens.pop();
        });
    }(obj));
};

/**
 * Tests if an object has a value for a json pointer
 *
 * @param obj
 * @param pointer
 * @returns {boolean}
 */
api.has = function has (obj, pointer) {
    try {
        api.get(obj, pointer);
    } catch (e) {
        return false;
    }
    return true;
};

/**
 * Escapes a reference token
 *
 * @param str
 * @returns {string}
 */
api.escape = function escape (str) {
    return str.toString().replace(/~/g, '~0').replace(/\//g, '~1');
};

/**
 * Unescapes a reference token
 *
 * @param str
 * @returns {string}
 */
api.unescape = function unescape (str) {
    return str.replace(/~1/g, '/').replace(/~0/g, '~');
};

/**
 * Converts a json pointer into a array of reference tokens
 *
 * @param pointer
 * @returns {Array}
 */
api.parse = function parse (pointer) {
    if (pointer === '') { return []; }
    if (pointer.charAt(0) !== '/') { throw new Error('Invalid JSON pointer: ' + pointer); }
    return pointer.substring(1).split(/\//).map(api.unescape);
};

/**
 * Builds a json pointer from a array of reference tokens
 *
 * @param refTokens
 * @returns {string}
 */
api.compile = function compile (refTokens) {
    if (refTokens.length === 0) { return ''; }
    return '/' + refTokens.map(api.escape).join('/');
};

      };
    };
  }
  }
}, {package:"@truffle/decoder>@truffle/source-map-utils>json-pointer",file:"node_modules\\json-pointer\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jss-plugin-camel-case\\dist\\jss-plugin-camel-case.cjs.js", {"hyphenate-style-name":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\hyphenate-style-name\\index.cjs.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cjss-plugin-camel-case%5Cdist%5Cjss-plugin-camel-case.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var hyphenate = _interopDefault(require('hyphenate-style-name'));

/**
 * Convert camel cased property names to dash separated.
 *
 * @param {Object} style
 * @return {Object}
 */

function convertCase(style) {
  var converted = {};

  for (var prop in style) {
    var key = prop.indexOf('--') === 0 ? prop : hyphenate(prop);
    converted[key] = style[prop];
  }

  if (style.fallbacks) {
    if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map(convertCase);else converted.fallbacks = convertCase(style.fallbacks);
  }

  return converted;
}
/**
 * Allow camel cased property names by converting them back to dasherized.
 *
 * @param {Rule} rule
 */


function camelCase() {
  function onProcessStyle(style) {
    if (Array.isArray(style)) {
      // Handle rules like @font-face, which can have multiple styles in an array
      for (var index = 0; index < style.length; index++) {
        style[index] = convertCase(style[index]);
      }

      return style;
    }

    return convertCase(style);
  }

  function onChangeValue(value, prop, rule) {
    if (prop.indexOf('--') === 0) {
      return value;
    }

    var hyphenatedProp = hyphenate(prop); // There was no camel case in place

    if (prop === hyphenatedProp) return value;
    rule.prop(hyphenatedProp, value); // Core will ignore that property value we set the proper one above.

    return null;
  }

  return {
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

exports.default = camelCase;

      };
    };
  }
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-camel-case",file:"node_modules\\jss-plugin-camel-case\\dist\\jss-plugin-camel-case.cjs.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jss-plugin-default-unit\\dist\\jss-plugin-default-unit.cjs.js", {"jss":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jss\\dist\\jss.cjs.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cjss-plugin-default-unit%5Cdist%5Cjss-plugin-default-unit.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jss = require('jss');

var px = jss.hasCSSTOMSupport && CSS ? CSS.px : 'px';
var ms = jss.hasCSSTOMSupport && CSS ? CSS.ms : 'ms';
var percent = jss.hasCSSTOMSupport && CSS ? CSS.percent : '%';
/**
 * Generated jss-plugin-default-unit CSS property units
 *
 * @type object
 */

var defaultUnits = {
  // Animation properties
  'animation-delay': ms,
  'animation-duration': ms,
  // Background properties
  'background-position': px,
  'background-position-x': px,
  'background-position-y': px,
  'background-size': px,
  // Border Properties
  border: px,
  'border-bottom': px,
  'border-bottom-left-radius': px,
  'border-bottom-right-radius': px,
  'border-bottom-width': px,
  'border-left': px,
  'border-left-width': px,
  'border-radius': px,
  'border-right': px,
  'border-right-width': px,
  'border-top': px,
  'border-top-left-radius': px,
  'border-top-right-radius': px,
  'border-top-width': px,
  'border-width': px,
  // Margin properties
  margin: px,
  'margin-bottom': px,
  'margin-left': px,
  'margin-right': px,
  'margin-top': px,
  // Padding properties
  padding: px,
  'padding-bottom': px,
  'padding-left': px,
  'padding-right': px,
  'padding-top': px,
  // Mask properties
  'mask-position-x': px,
  'mask-position-y': px,
  'mask-size': px,
  // Width and height properties
  height: px,
  width: px,
  'min-height': px,
  'max-height': px,
  'min-width': px,
  'max-width': px,
  // Position properties
  bottom: px,
  left: px,
  top: px,
  right: px,
  // Shadow properties
  'box-shadow': px,
  'text-shadow': px,
  // Column properties
  'column-gap': px,
  'column-rule': px,
  'column-rule-width': px,
  'column-width': px,
  // Font and text properties
  'font-size': px,
  'font-size-delta': px,
  'letter-spacing': px,
  'text-indent': px,
  'text-stroke': px,
  'text-stroke-width': px,
  'word-spacing': px,
  // Motion properties
  motion: px,
  'motion-offset': px,
  // Outline properties
  outline: px,
  'outline-offset': px,
  'outline-width': px,
  // Perspective properties
  perspective: px,
  'perspective-origin-x': percent,
  'perspective-origin-y': percent,
  // Transform properties
  'transform-origin': percent,
  'transform-origin-x': percent,
  'transform-origin-y': percent,
  'transform-origin-z': percent,
  // Transition properties
  'transition-delay': ms,
  'transition-duration': ms,
  // Alignment properties
  'vertical-align': px,
  'flex-basis': px,
  // Some random properties
  'shape-margin': px,
  size: px,
  // Grid properties
  grid: px,
  'grid-gap': px,
  'grid-row-gap': px,
  'grid-column-gap': px,
  'grid-template-rows': px,
  'grid-template-columns': px,
  'grid-auto-rows': px,
  'grid-auto-columns': px,
  // Not existing properties.
  // Used to avoid issues with jss-plugin-expand integration.
  'box-shadow-x': px,
  'box-shadow-y': px,
  'box-shadow-blur': px,
  'box-shadow-spread': px,
  'font-line-height': px,
  'text-shadow-x': px,
  'text-shadow-y': px,
  'text-shadow-blur': px
};

/**
 * Clones the object and adds a camel cased property version.
 */
function addCamelCasedVersion(obj) {
  var regExp = /(-[a-z])/g;

  var replace = function replace(str) {
    return str[1].toUpperCase();
  };

  var newObj = {};

  for (var _key in obj) {
    newObj[_key] = obj[_key];
    newObj[_key.replace(regExp, replace)] = obj[_key];
  }

  return newObj;
}

var units = addCamelCasedVersion(defaultUnits);
/**
 * Recursive deep style passing function
 */

function iterate(prop, value, options) {
  if (!value) return value;

  if (Array.isArray(value)) {
    for (var i = 0; i < value.length; i++) {
      value[i] = iterate(prop, value[i], options);
    }
  } else if (typeof value === 'object') {
    if (prop === 'fallbacks') {
      for (var innerProp in value) {
        value[innerProp] = iterate(innerProp, value[innerProp], options);
      }
    } else {
      for (var _innerProp in value) {
        value[_innerProp] = iterate(prop + "-" + _innerProp, value[_innerProp], options);
      }
    }
  } else if (typeof value === 'number') {
    var unit = options[prop] || units[prop];

    if (unit) {
      return typeof unit === 'function' ? unit(value).toString() : "" + value + unit;
    }

    return value.toString();
  }

  return value;
}
/**
 * Add unit to numeric values.
 */


function defaultUnit(options) {
  if (options === void 0) {
    options = {};
  }

  var camelCasedOptions = addCamelCasedVersion(options);

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;

    for (var prop in style) {
      style[prop] = iterate(prop, style[prop], camelCasedOptions);
    }

    return style;
  }

  function onChangeValue(value, prop) {
    return iterate(prop, value, camelCasedOptions);
  }

  return {
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

exports.default = defaultUnit;

      };
    };
  }
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-default-unit",file:"node_modules\\jss-plugin-default-unit\\dist\\jss-plugin-default-unit.cjs.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jss-plugin-global\\dist\\jss-plugin-global.cjs.js", {"@babel/runtime/helpers/extends":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@babel\\runtime\\helpers\\extends.js","jss":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jss\\dist\\jss.cjs.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cjss-plugin-global%5Cdist%5Cjss-plugin-global.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var jss = require('jss');

var at = '@global';
var atPrefix = '@global ';

var GlobalContainerRule =
/*#__PURE__*/
function () {
  function GlobalContainerRule(key, styles, options) {
    this.type = 'global';
    this.at = at;
    this.rules = void 0;
    this.options = void 0;
    this.key = void 0;
    this.isProcessed = false;
    this.key = key;
    this.options = options;
    this.rules = new jss.RuleList(_extends({}, options, {
      parent: this
    }));

    for (var selector in styles) {
      this.rules.add(selector, styles[selector]);
    }

    this.rules.process();
  }
  /**
   * Get a rule.
   */


  var _proto = GlobalContainerRule.prototype;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Create and register rule, run plugins.
   */
  ;

  _proto.addRule = function addRule(name, style, options) {
    var rule = this.rules.add(name, style, options);
    this.options.jss.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto.toString = function toString() {
    return this.rules.toString();
  };

  return GlobalContainerRule;
}();

var GlobalPrefixedRule =
/*#__PURE__*/
function () {
  function GlobalPrefixedRule(key, style, options) {
    this.type = 'global';
    this.at = at;
    this.options = void 0;
    this.rule = void 0;
    this.isProcessed = false;
    this.key = void 0;
    this.key = key;
    this.options = options;
    var selector = key.substr(atPrefix.length);
    this.rule = options.jss.createRule(selector, style, _extends({}, options, {
      parent: this
    }));
  }

  var _proto2 = GlobalPrefixedRule.prototype;

  _proto2.toString = function toString(options) {
    return this.rule ? this.rule.toString(options) : '';
  };

  return GlobalPrefixedRule;
}();

var separatorRegExp = /\s*,\s*/g;

function addScope(selector, scope) {
  var parts = selector.split(separatorRegExp);
  var scoped = '';

  for (var i = 0; i < parts.length; i++) {
    scoped += scope + " " + parts[i].trim();
    if (parts[i + 1]) scoped += ', ';
  }

  return scoped;
}

function handleNestedGlobalContainerRule(rule) {
  var options = rule.options,
      style = rule.style;
  var rules = style ? style[at] : null;
  if (!rules) return;

  for (var name in rules) {
    options.sheet.addRule(name, rules[name], _extends({}, options, {
      selector: addScope(name, rule.selector)
    }));
  }

  delete style[at];
}

function handlePrefixedGlobalRule(rule) {
  var options = rule.options,
      style = rule.style;

  for (var prop in style) {
    if (prop[0] !== '@' || prop.substr(0, at.length) !== at) continue;
    var selector = addScope(prop.substr(at.length), rule.selector);
    options.sheet.addRule(selector, style[prop], _extends({}, options, {
      selector: selector
    }));
    delete style[prop];
  }
}
/**
 * Convert nested rules to separate, remove them from original styles.
 *
 * @param {Rule} rule
 * @api public
 */


function jssGlobal() {
  function onCreateRule(name, styles, options) {
    if (!name) return null;

    if (name === at) {
      return new GlobalContainerRule(name, styles, options);
    }

    if (name[0] === '@' && name.substr(0, atPrefix.length) === atPrefix) {
      return new GlobalPrefixedRule(name, styles, options);
    }

    var parent = options.parent;

    if (parent) {
      if (parent.type === 'global' || parent.options.parent && parent.options.parent.type === 'global') {
        options.scoped = false;
      }
    }

    if (options.scoped === false) {
      options.selector = name;
    }

    return null;
  }

  function onProcessRule(rule) {
    if (rule.type !== 'style') return;
    handleNestedGlobalContainerRule(rule);
    handlePrefixedGlobalRule(rule);
  }

  return {
    onCreateRule: onCreateRule,
    onProcessRule: onProcessRule
  };
}

exports.default = jssGlobal;

      };
    };
  }
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-global",file:"node_modules\\jss-plugin-global\\dist\\jss-plugin-global.cjs.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jss-plugin-nested\\dist\\jss-plugin-nested.cjs.js", {"@babel/runtime/helpers/extends":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@babel\\runtime\\helpers\\extends.js","tiny-warning":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\tiny-warning\\dist\\tiny-warning.cjs.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cjss-plugin-nested%5Cdist%5Cjss-plugin-nested.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var warning = _interopDefault(require('tiny-warning'));

var separatorRegExp = /\s*,\s*/g;
var parentRegExp = /&/g;
var refRegExp = /\$([\w-]+)/g;
/**
 * Convert nested rules to separate, remove them from original styles.
 *
 * @param {Rule} rule
 * @api public
 */

function jssNested() {
  // Get a function to be used for $ref replacement.
  function getReplaceRef(container, sheet) {
    return function (match, key) {
      var rule = container.getRule(key) || sheet && sheet.getRule(key);

      if (rule) {
        rule = rule;
        return rule.selector;
      }

      "development" !== "production" ? warning(false, "[JSS] Could not find the referenced rule \"" + key + "\" in \"" + (container.options.meta || container.toString()) + "\".") : void 0;
      return key;
    };
  }

  function replaceParentRefs(nestedProp, parentProp) {
    var parentSelectors = parentProp.split(separatorRegExp);
    var nestedSelectors = nestedProp.split(separatorRegExp);
    var result = '';

    for (var i = 0; i < parentSelectors.length; i++) {
      var parent = parentSelectors[i];

      for (var j = 0; j < nestedSelectors.length; j++) {
        var nested = nestedSelectors[j];
        if (result) result += ', '; // Replace all & by the parent or prefix & with the parent.

        result += nested.indexOf('&') !== -1 ? nested.replace(parentRegExp, parent) : parent + " " + nested;
      }
    }

    return result;
  }

  function getOptions(rule, container, prevOptions) {
    // Options has been already created, now we only increase index.
    if (prevOptions) return _extends({}, prevOptions, {
      index: prevOptions.index + 1
    });
    var nestingLevel = rule.options.nestingLevel;
    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;

    var options = _extends({}, rule.options, {
      nestingLevel: nestingLevel,
      index: container.indexOf(rule) + 1 // We don't need the parent name to be set options for chlid.

    });

    delete options.name;
    return options;
  }

  function onProcessStyle(style, rule, sheet) {
    if (rule.type !== 'style') return style;
    var styleRule = rule;
    var container = styleRule.options.parent;
    var options;
    var replaceRef;

    for (var prop in style) {
      var isNested = prop.indexOf('&') !== -1;
      var isNestedConditional = prop[0] === '@';
      if (!isNested && !isNestedConditional) continue;
      options = getOptions(styleRule, container, options);

      if (isNested) {
        var selector = replaceParentRefs(prop, styleRule.selector); // Lazily create the ref replacer function just once for
        // all nested rules within the sheet.

        if (!replaceRef) replaceRef = getReplaceRef(container, sheet); // Replace all $refs.

        selector = selector.replace(refRegExp, replaceRef);
        container.addRule(selector, style[prop], _extends({}, options, {
          selector: selector
        }));
      } else if (isNestedConditional) {
        // Place conditional right after the parent rule to ensure right ordering.
        container.addRule(prop, {}, options) // Flow expects more options but they aren't required
        // And flow doesn't know this will always be a StyleRule which has the addRule method
        // $FlowFixMe
        .addRule(styleRule.key, style[prop], {
          selector: styleRule.selector
        });
      }

      delete style[prop];
    }

    return style;
  }

  return {
    onProcessStyle: onProcessStyle
  };
}

exports.default = jssNested;

      };
    };
  }
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-nested",file:"node_modules\\jss-plugin-nested\\dist\\jss-plugin-nested.cjs.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jss-plugin-props-sort\\dist\\jss-plugin-props-sort.cjs.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cjss-plugin-props-sort%5Cdist%5Cjss-plugin-props-sort.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * Sort props by length.
 */
function jssPropsSort() {
  var sort = function sort(prop0, prop1) {
    if (prop0.length === prop1.length) {
      return prop0 > prop1 ? 1 : -1;
    }

    return prop0.length - prop1.length;
  };

  return {
    onProcessStyle: function onProcessStyle(style, rule) {
      if (rule.type !== 'style') return style;
      var newStyle = {};
      var props = Object.keys(style).sort(sort);

      for (var i = 0; i < props.length; i++) {
        newStyle[props[i]] = style[props[i]];
      }

      return newStyle;
    }
  };
}

exports.default = jssPropsSort;

      };
    };
  }
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-props-sort",file:"node_modules\\jss-plugin-props-sort\\dist\\jss-plugin-props-sort.cjs.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jss-plugin-rule-value-function\\dist\\jss-plugin-rule-value-function.cjs.js", {"jss":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jss\\dist\\jss.cjs.js","tiny-warning":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\tiny-warning\\dist\\tiny-warning.cjs.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cjss-plugin-rule-value-function%5Cdist%5Cjss-plugin-rule-value-function.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var warning = _interopDefault(require('tiny-warning'));
var jss = require('jss');

var now = Date.now();
var fnValuesNs = "fnValues" + now;
var fnRuleNs = "fnStyle" + ++now;
function functionPlugin() {
  return {
    onCreateRule: function onCreateRule(name, decl, options) {
      if (typeof decl !== 'function') return null;
      var rule = jss.createRule(name, {}, options);
      rule[fnRuleNs] = decl;
      return rule;
    },
    onProcessStyle: function onProcessStyle(style, rule) {
      // We need to extract function values from the declaration, so that we can keep core unaware of them.
      // We need to do that only once.
      // We don't need to extract functions on each style update, since this can happen only once.
      // We don't support function values inside of function rules.
      if (fnValuesNs in rule || fnRuleNs in rule) return style;
      var fnValues = {};

      for (var prop in style) {
        var value = style[prop];
        if (typeof value !== 'function') continue;
        delete style[prop];
        fnValues[prop] = value;
      } // $FlowFixMe


      rule[fnValuesNs] = fnValues;
      return style;
    },
    onUpdate: function onUpdate(data, rule, sheet, options) {
      var styleRule = rule;
      var fnRule = styleRule[fnRuleNs]; // If we have a style function, the entire rule is dynamic and style object
      // will be returned from that function.

      if (fnRule) {
        // Empty object will remove all currently defined props
        // in case function rule returns a falsy value.
        styleRule.style = fnRule(data) || {};

        if ("development" === 'development') {
          for (var prop in styleRule.style) {
            if (typeof styleRule.style[prop] === 'function') {
              "development" !== "production" ? warning(false, '[JSS] Function values inside function rules are not supported.') : void 0;
              break;
            }
          }
        }
      }

      var fnValues = styleRule[fnValuesNs]; // If we have a fn values map, it is a rule with function values.

      if (fnValues) {
        for (var _prop in fnValues) {
          styleRule.prop(_prop, fnValues[_prop](data), options);
        }
      }
    }
  };
}

exports.default = functionPlugin;

      };
    };
  }
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-rule-value-function",file:"node_modules\\jss-plugin-rule-value-function\\dist\\jss-plugin-rule-value-function.cjs.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jss-plugin-vendor-prefixer\\dist\\jss-plugin-vendor-prefixer.cjs.js", {"css-vendor":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\css-vendor\\dist\\css-vendor.cjs.js","jss":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jss\\dist\\jss.cjs.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cjss-plugin-vendor-prefixer%5Cdist%5Cjss-plugin-vendor-prefixer.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vendor = require('css-vendor');
var jss = require('jss');

/**
 * Add vendor prefix to a property name when needed.
 *
 * @api public
 */

function jssVendorPrefixer() {
  function onProcessRule(rule) {
    if (rule.type === 'keyframes') {
      var atRule = rule;
      atRule.at = vendor.supportedKeyframes(atRule.at);
    }
  }

  function prefixStyle(style) {
    for (var prop in style) {
      var value = style[prop];

      if (prop === 'fallbacks' && Array.isArray(value)) {
        style[prop] = value.map(prefixStyle);
        continue;
      }

      var changeProp = false;
      var supportedProp = vendor.supportedProperty(prop);
      if (supportedProp && supportedProp !== prop) changeProp = true;
      var changeValue = false;
      var supportedValue = vendor.supportedValue(supportedProp, jss.toCssValue(value));
      if (supportedValue && supportedValue !== value) changeValue = true;

      if (changeProp || changeValue) {
        if (changeProp) delete style[prop];
        style[supportedProp || prop] = supportedValue || value;
      }
    }

    return style;
  }

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;
    return prefixStyle(style);
  }

  function onChangeValue(value, prop) {
    return vendor.supportedValue(prop, jss.toCssValue(value)) || value;
  }

  return {
    onProcessRule: onProcessRule,
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

exports.default = jssVendorPrefixer;

      };
    };
  }
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-vendor-prefixer",file:"node_modules\\jss-plugin-vendor-prefixer\\dist\\jss-plugin-vendor-prefixer.cjs.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\jss\\dist\\jss.cjs.js", {"@babel/runtime/helpers/assertThisInitialized":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@babel\\runtime\\helpers\\assertThisInitialized.js","@babel/runtime/helpers/createClass":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@babel\\runtime\\helpers\\createClass.js","@babel/runtime/helpers/extends":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@babel\\runtime\\helpers\\extends.js","@babel/runtime/helpers/inheritsLoose":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@babel\\runtime\\helpers\\inheritsLoose.js","@babel/runtime/helpers/objectWithoutPropertiesLoose":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@babel\\runtime\\helpers\\objectWithoutPropertiesLoose.js","is-in-browser":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\is-in-browser\\dist\\index.js","tiny-warning":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\tiny-warning\\dist\\tiny-warning.cjs.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cjss%5Cdist%5Cjss.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var isInBrowser = _interopDefault(require('is-in-browser'));
var warning = _interopDefault(require('tiny-warning'));
var _createClass = _interopDefault(require('@babel/runtime/helpers/createClass'));
var _inheritsLoose = _interopDefault(require('@babel/runtime/helpers/inheritsLoose'));
var _assertThisInitialized = _interopDefault(require('@babel/runtime/helpers/assertThisInitialized'));
var _objectWithoutPropertiesLoose = _interopDefault(require('@babel/runtime/helpers/objectWithoutPropertiesLoose'));

var plainObjectConstrurctor = {}.constructor;
function cloneStyle(style) {
  if (style == null || typeof style !== 'object') return style;
  if (Array.isArray(style)) return style.map(cloneStyle);
  if (style.constructor !== plainObjectConstrurctor) return style;
  var newStyle = {};

  for (var name in style) {
    newStyle[name] = cloneStyle(style[name]);
  }

  return newStyle;
}

/**
 * Create a rule instance.
 */

function createRule(name, decl, options) {
  if (name === void 0) {
    name = 'unnamed';
  }

  var jss = options.jss;
  var declCopy = cloneStyle(decl);
  var rule = jss.plugins.onCreateRule(name, declCopy, options);
  if (rule) return rule; // It is an at-rule and it has no instance.

  if (name[0] === '@') {
    "development" !== "production" ? warning(false, "[JSS] Unknown rule " + name) : void 0;
  }

  return null;
}

var join = function join(value, by) {
  var result = '';

  for (var i = 0; i < value.length; i++) {
    // Remove !important from the value, it will be readded later.
    if (value[i] === '!important') break;
    if (result) result += by;
    result += value[i];
  }

  return result;
};
/**
 * Converts array values to string.
 *
 * `margin: [['5px', '10px']]` > `margin: 5px 10px;`
 * `border: ['1px', '2px']` > `border: 1px, 2px;`
 * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`
 * `color: ['red', !important]` > `color: red !important;`
 */


function toCssValue(value, ignoreImportant) {
  if (ignoreImportant === void 0) {
    ignoreImportant = false;
  }

  if (!Array.isArray(value)) return value;
  var cssValue = ''; // Support space separated values via `[['5px', '10px']]`.

  if (Array.isArray(value[0])) {
    for (var i = 0; i < value.length; i++) {
      if (value[i] === '!important') break;
      if (cssValue) cssValue += ', ';
      cssValue += join(value[i], ' ');
    }
  } else cssValue = join(value, ', '); // Add !important, because it was ignored.


  if (!ignoreImportant && value[value.length - 1] === '!important') {
    cssValue += ' !important';
  }

  return cssValue;
}

/**
 * Indent a string.
 * http://jsperf.com/array-join-vs-for
 */
function indentStr(str, indent) {
  var result = '';

  for (var index = 0; index < indent; index++) {
    result += '  ';
  }

  return result + str;
}
/**
 * Converts a Rule to CSS string.
 */


function toCss(selector, style, options) {
  if (options === void 0) {
    options = {};
  }

  var result = '';
  if (!style) return result;
  var _options = options,
      _options$indent = _options.indent,
      indent = _options$indent === void 0 ? 0 : _options$indent;
  var fallbacks = style.fallbacks;
  if (selector) indent++; // Apply fallbacks first.

  if (fallbacks) {
    // Array syntax {fallbacks: [{prop: value}]}
    if (Array.isArray(fallbacks)) {
      for (var index = 0; index < fallbacks.length; index++) {
        var fallback = fallbacks[index];

        for (var prop in fallback) {
          var value = fallback[prop];

          if (value != null) {
            if (result) result += '\n';
            result += "" + indentStr(prop + ": " + toCssValue(value) + ";", indent);
          }
        }
      }
    } else {
      // Object syntax {fallbacks: {prop: value}}
      for (var _prop in fallbacks) {
        var _value = fallbacks[_prop];

        if (_value != null) {
          if (result) result += '\n';
          result += "" + indentStr(_prop + ": " + toCssValue(_value) + ";", indent);
        }
      }
    }
  }

  for (var _prop2 in style) {
    var _value2 = style[_prop2];

    if (_value2 != null && _prop2 !== 'fallbacks') {
      if (result) result += '\n';
      result += "" + indentStr(_prop2 + ": " + toCssValue(_value2) + ";", indent);
    }
  } // Allow empty style in this case, because properties will be added dynamically.


  if (!result && !options.allowEmpty) return result; // When rule is being stringified before selector was defined.

  if (!selector) return result;
  indent--;
  if (result) result = "\n" + result + "\n";
  return indentStr(selector + " {" + result, indent) + indentStr('}', indent);
}

var escapeRegex = /([[\].#*$><+~=|^:(),"'`\s])/g;
var nativeEscape = typeof CSS !== 'undefined' && CSS.escape;
var escape = (function (str) {
  return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, '\\$1');
});

var BaseStyleRule =
/*#__PURE__*/
function () {
  function BaseStyleRule(key, style, options) {
    this.type = 'style';
    this.key = void 0;
    this.isProcessed = false;
    this.style = void 0;
    this.renderer = void 0;
    this.renderable = void 0;
    this.options = void 0;
    var sheet = options.sheet,
        Renderer = options.Renderer;
    this.key = key;
    this.options = options;
    this.style = style;
    if (sheet) this.renderer = sheet.renderer;else if (Renderer) this.renderer = new Renderer();
  }
  /**
   * Get or set a style property.
   */


  var _proto = BaseStyleRule.prototype;

  _proto.prop = function prop(name, value, options) {
    // It's a getter.
    if (value === undefined) return this.style[name]; // Don't do anything if the value has not changed.

    var force = options ? options.force : false;
    if (!force && this.style[name] === value) return this;
    var newValue = value;

    if (!options || options.process !== false) {
      newValue = this.options.jss.plugins.onChangeValue(value, name, this);
    }

    var isEmpty = newValue == null || newValue === false;
    var isDefined = name in this.style; // Value is empty and wasn't defined before.

    if (isEmpty && !isDefined && !force) return this; // We are going to remove this value.

    var remove = isEmpty && isDefined;
    if (remove) delete this.style[name];else this.style[name] = newValue; // Renderable is defined if StyleSheet option `link` is true.

    if (this.renderable && this.renderer) {
      if (remove) this.renderer.removeProperty(this.renderable, name);else this.renderer.setProperty(this.renderable, name, newValue);
      return this;
    }

    var sheet = this.options.sheet;

    if (sheet && sheet.attached) {
      "development" !== "production" ? warning(false, '[JSS] Rule is not linked. Missing sheet option "link: true".') : void 0;
    }

    return this;
  };

  return BaseStyleRule;
}();
var StyleRule =
/*#__PURE__*/
function (_BaseStyleRule) {
  _inheritsLoose(StyleRule, _BaseStyleRule);

  function StyleRule(key, style, options) {
    var _this;

    _this = _BaseStyleRule.call(this, key, style, options) || this;
    _this.selectorText = void 0;
    _this.id = void 0;
    _this.renderable = void 0;
    var selector = options.selector,
        scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;

    if (selector) {
      _this.selectorText = selector;
    } else if (scoped !== false) {
      _this.id = generateId(_assertThisInitialized(_assertThisInitialized(_this)), sheet);
      _this.selectorText = "." + escape(_this.id);
    }

    return _this;
  }
  /**
   * Set selector string.
   * Attention: use this with caution. Most browsers didn't implement
   * selectorText setter, so this may result in rerendering of entire Style Sheet.
   */


  var _proto2 = StyleRule.prototype;

  /**
   * Apply rule to an element inline.
   */
  _proto2.applyTo = function applyTo(renderable) {
    var renderer = this.renderer;

    if (renderer) {
      var json = this.toJSON();

      for (var prop in json) {
        renderer.setProperty(renderable, prop, json[prop]);
      }
    }

    return this;
  }
  /**
   * Returns JSON representation of the rule.
   * Fallbacks are not supported.
   * Useful for inline styles.
   */
  ;

  _proto2.toJSON = function toJSON() {
    var json = {};

    for (var prop in this.style) {
      var value = this.style[prop];
      if (typeof value !== 'object') json[prop] = value;else if (Array.isArray(value)) json[prop] = toCssValue(value);
    }

    return json;
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto2.toString = function toString(options) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? _extends({}, options, {
      allowEmpty: true
    }) : options;
    return toCss(this.selectorText, this.style, opts);
  };

  _createClass(StyleRule, [{
    key: "selector",
    set: function set(selector) {
      if (selector === this.selectorText) return;
      this.selectorText = selector;
      var renderer = this.renderer,
          renderable = this.renderable;
      if (!renderable || !renderer) return;
      var hasChanged = renderer.setSelector(renderable, selector); // If selector setter is not implemented, rerender the rule.

      if (!hasChanged) {
        renderer.replaceRule(renderable, this);
      }
    }
    /**
     * Get selector string.
     */
    ,
    get: function get() {
      return this.selectorText;
    }
  }]);

  return StyleRule;
}(BaseStyleRule);
var pluginStyleRule = {
  onCreateRule: function onCreateRule(name, style, options) {
    if (name[0] === '@' || options.parent && options.parent.type === 'keyframes') {
      return null;
    }

    return new StyleRule(name, style, options);
  }
};

var defaultToStringOptions = {
  indent: 1,
  children: true
};
var atRegExp = /@([\w-]+)/;
/**
 * Conditional rule for @media, @supports
 */

var ConditionalRule =
/*#__PURE__*/
function () {
  function ConditionalRule(key, styles, options) {
    this.type = 'conditional';
    this.at = void 0;
    this.key = void 0;
    this.query = void 0;
    this.rules = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key; // Key might contain a unique suffix in case the `name` passed by user was duplicate.

    this.query = options.name;
    var atMatch = key.match(atRegExp);
    this.at = atMatch ? atMatch[1] : 'unknown';
    this.options = options;
    this.rules = new RuleList(_extends({}, options, {
      parent: this
    }));

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }
  /**
   * Get a rule.
   */


  var _proto = ConditionalRule.prototype;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Create and register rule, run plugins.
   */
  ;

  _proto.addRule = function addRule(name, style, options) {
    var rule = this.rules.add(name, style, options);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    if (options === void 0) {
      options = defaultToStringOptions;
    }

    if (options.indent == null) options.indent = defaultToStringOptions.indent;
    if (options.children == null) options.children = defaultToStringOptions.children;

    if (options.children === false) {
      return this.query + " {}";
    }

    var children = this.rules.toString(options);
    return children ? this.query + " {\n" + children + "\n}" : '';
  };

  return ConditionalRule;
}();
var keyRegExp = /@media|@supports\s+/;
var pluginConditionalRule = {
  onCreateRule: function onCreateRule(key, styles, options) {
    return keyRegExp.test(key) ? new ConditionalRule(key, styles, options) : null;
  }
};

var defaultToStringOptions$1 = {
  indent: 1,
  children: true
};
var nameRegExp = /@keyframes\s+([\w-]+)/;
/**
 * Rule for @keyframes
 */

var KeyframesRule =
/*#__PURE__*/
function () {
  function KeyframesRule(key, frames, options) {
    this.type = 'keyframes';
    this.at = '@keyframes';
    this.key = void 0;
    this.name = void 0;
    this.id = void 0;
    this.rules = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    var nameMatch = key.match(nameRegExp);

    if (nameMatch && nameMatch[1]) {
      this.name = nameMatch[1];
    } else {
      this.name = 'noname';
      "development" !== "production" ? warning(false, "[JSS] Bad keyframes name " + key) : void 0;
    }

    this.key = this.type + "-" + this.name;
    this.options = options;
    var scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;
    this.id = scoped === false ? this.name : escape(generateId(this, sheet));
    this.rules = new RuleList(_extends({}, options, {
      parent: this
    }));

    for (var name in frames) {
      this.rules.add(name, frames[name], _extends({}, options, {
        parent: this
      }));
    }

    this.rules.process();
  }
  /**
   * Generates a CSS string.
   */


  var _proto = KeyframesRule.prototype;

  _proto.toString = function toString(options) {
    if (options === void 0) {
      options = defaultToStringOptions$1;
    }

    if (options.indent == null) options.indent = defaultToStringOptions$1.indent;
    if (options.children == null) options.children = defaultToStringOptions$1.children;

    if (options.children === false) {
      return this.at + " " + this.id + " {}";
    }

    var children = this.rules.toString(options);
    if (children) children = "\n" + children + "\n";
    return this.at + " " + this.id + " {" + children + "}";
  };

  return KeyframesRule;
}();
var keyRegExp$1 = /@keyframes\s+/;
var refRegExp = /\$([\w-]+)/g;

var findReferencedKeyframe = function findReferencedKeyframe(val, keyframes) {
  if (typeof val === 'string') {
    return val.replace(refRegExp, function (match, name) {
      if (name in keyframes) {
        return keyframes[name];
      }

      "development" !== "production" ? warning(false, "[JSS] Referenced keyframes rule \"" + name + "\" is not defined.") : void 0;
      return match;
    });
  }

  return val;
};
/**
 * Replace the reference for a animation name.
 */


var replaceRef = function replaceRef(style, prop, keyframes) {
  var value = style[prop];
  var refKeyframe = findReferencedKeyframe(value, keyframes);

  if (refKeyframe !== value) {
    style[prop] = refKeyframe;
  }
};

var plugin = {
  onCreateRule: function onCreateRule(key, frames, options) {
    return typeof key === 'string' && keyRegExp$1.test(key) ? new KeyframesRule(key, frames, options) : null;
  },
  // Animation name ref replacer.
  onProcessStyle: function onProcessStyle(style, rule, sheet) {
    if (rule.type !== 'style' || !sheet) return style;
    if ('animation-name' in style) replaceRef(style, 'animation-name', sheet.keyframes);
    if ('animation' in style) replaceRef(style, 'animation', sheet.keyframes);
    return style;
  },
  onChangeValue: function onChangeValue(val, prop, rule) {
    var sheet = rule.options.sheet;

    if (!sheet) {
      return val;
    }

    switch (prop) {
      case 'animation':
        return findReferencedKeyframe(val, sheet.keyframes);

      case 'animation-name':
        return findReferencedKeyframe(val, sheet.keyframes);

      default:
        return val;
    }
  }
};

var KeyframeRule =
/*#__PURE__*/
function (_BaseStyleRule) {
  _inheritsLoose(KeyframeRule, _BaseStyleRule);

  function KeyframeRule() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _BaseStyleRule.call.apply(_BaseStyleRule, [this].concat(args)) || this;
    _this.renderable = void 0;
    return _this;
  }

  var _proto = KeyframeRule.prototype;

  /**
   * Generates a CSS string.
   */
  _proto.toString = function toString(options) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? _extends({}, options, {
      allowEmpty: true
    }) : options;
    return toCss(this.key, this.style, opts);
  };

  return KeyframeRule;
}(BaseStyleRule);
var pluginKeyframeRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    if (options.parent && options.parent.type === 'keyframes') {
      return new KeyframeRule(key, style, options);
    }

    return null;
  }
};

var FontFaceRule =
/*#__PURE__*/
function () {
  function FontFaceRule(key, style, options) {
    this.type = 'font-face';
    this.at = '@font-face';
    this.key = void 0;
    this.style = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    this.style = style;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */


  var _proto = FontFaceRule.prototype;

  _proto.toString = function toString(options) {
    if (Array.isArray(this.style)) {
      var str = '';

      for (var index = 0; index < this.style.length; index++) {
        str += toCss(this.at, this.style[index]);
        if (this.style[index + 1]) str += '\n';
      }

      return str;
    }

    return toCss(this.at, this.style, options);
  };

  return FontFaceRule;
}();
var keyRegExp$2 = /@font-face/;
var pluginFontFaceRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options) : null;
  }
};

var ViewportRule =
/*#__PURE__*/
function () {
  function ViewportRule(key, style, options) {
    this.type = 'viewport';
    this.at = '@viewport';
    this.key = void 0;
    this.style = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    this.style = style;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */


  var _proto = ViewportRule.prototype;

  _proto.toString = function toString(options) {
    return toCss(this.key, this.style, options);
  };

  return ViewportRule;
}();
var pluginViewportRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    return key === '@viewport' || key === '@-ms-viewport' ? new ViewportRule(key, style, options) : null;
  }
};

var SimpleRule =
/*#__PURE__*/
function () {
  function SimpleRule(key, value, options) {
    this.type = 'simple';
    this.key = void 0;
    this.value = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    this.value = value;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */
  // eslint-disable-next-line no-unused-vars


  var _proto = SimpleRule.prototype;

  _proto.toString = function toString(options) {
    if (Array.isArray(this.value)) {
      var str = '';

      for (var index = 0; index < this.value.length; index++) {
        str += this.key + " " + this.value[index] + ";";
        if (this.value[index + 1]) str += '\n';
      }

      return str;
    }

    return this.key + " " + this.value + ";";
  };

  return SimpleRule;
}();
var keysMap = {
  '@charset': true,
  '@import': true,
  '@namespace': true
};
var pluginSimpleRule = {
  onCreateRule: function onCreateRule(key, value, options) {
    return key in keysMap ? new SimpleRule(key, value, options) : null;
  }
};

var plugins = [pluginStyleRule, pluginConditionalRule, plugin, pluginKeyframeRule, pluginFontFaceRule, pluginViewportRule, pluginSimpleRule];

var defaultUpdateOptions = {
  process: true
};
var forceUpdateOptions = {
  force: true,
  process: true
  /**
   * Contains rules objects and allows adding/removing etc.
   * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
   */

};

var RuleList =
/*#__PURE__*/
function () {
  // Rules registry for access by .get() method.
  // It contains the same rule registered by name and by selector.
  // Original styles object.
  // Used to ensure correct rules order.
  function RuleList(options) {
    this.map = {};
    this.raw = {};
    this.index = [];
    this.counter = 0;
    this.options = void 0;
    this.classes = void 0;
    this.keyframes = void 0;
    this.options = options;
    this.classes = options.classes;
    this.keyframes = options.keyframes;
  }
  /**
   * Create and register rule.
   *
   * Will not render after Style Sheet was rendered the first time.
   */


  var _proto = RuleList.prototype;

  _proto.add = function add(name, decl, ruleOptions) {
    var _this$options = this.options,
        parent = _this$options.parent,
        sheet = _this$options.sheet,
        jss = _this$options.jss,
        Renderer = _this$options.Renderer,
        generateId = _this$options.generateId,
        scoped = _this$options.scoped;

    var options = _extends({
      classes: this.classes,
      parent: parent,
      sheet: sheet,
      jss: jss,
      Renderer: Renderer,
      generateId: generateId,
      scoped: scoped,
      name: name
    }, ruleOptions); // When user uses .createStyleSheet(), duplicate names are not possible, but
    // `sheet.addRule()` opens the door for any duplicate rule name. When this happens
    // we need to make the key unique within this RuleList instance scope.


    var key = name;

    if (name in this.raw) {
      key = name + "-d" + this.counter++;
    } // We need to save the original decl before creating the rule
    // because cache plugin needs to use it as a key to return a cached rule.


    this.raw[key] = decl;

    if (key in this.classes) {
      // E.g. rules inside of @media container
      options.selector = "." + escape(this.classes[key]);
    }

    var rule = createRule(key, decl, options);
    if (!rule) return null;
    this.register(rule);
    var index = options.index === undefined ? this.index.length : options.index;
    this.index.splice(index, 0, rule);
    return rule;
  }
  /**
   * Get a rule.
   */
  ;

  _proto.get = function get(name) {
    return this.map[name];
  }
  /**
   * Delete a rule.
   */
  ;

  _proto.remove = function remove(rule) {
    this.unregister(rule);
    delete this.raw[rule.key];
    this.index.splice(this.index.indexOf(rule), 1);
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.index.indexOf(rule);
  }
  /**
   * Run `onProcessRule()` plugins on every rule.
   */
  ;

  _proto.process = function process() {
    var plugins = this.options.jss.plugins; // We need to clone array because if we modify the index somewhere else during a loop
    // we end up with very hard-to-track-down side effects.

    this.index.slice(0).forEach(plugins.onProcessRule, plugins);
  }
  /**
   * Register a rule in `.map`, `.classes` and `.keyframes` maps.
   */
  ;

  _proto.register = function register(rule) {
    this.map[rule.key] = rule;

    if (rule instanceof StyleRule) {
      this.map[rule.selector] = rule;
      if (rule.id) this.classes[rule.key] = rule.id;
    } else if (rule instanceof KeyframesRule && this.keyframes) {
      this.keyframes[rule.name] = rule.id;
    }
  }
  /**
   * Unregister a rule.
   */
  ;

  _proto.unregister = function unregister(rule) {
    delete this.map[rule.key];

    if (rule instanceof StyleRule) {
      delete this.map[rule.selector];
      delete this.classes[rule.key];
    } else if (rule instanceof KeyframesRule) {
      delete this.keyframes[rule.name];
    }
  }
  /**
   * Update the function values with a new data.
   */
  ;

  _proto.update = function update() {
    var name;
    var data;
    var options;

    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
      name = arguments.length <= 0 ? undefined : arguments[0]; // $FlowFixMe

      data = arguments.length <= 1 ? undefined : arguments[1]; // $FlowFixMe

      options = arguments.length <= 2 ? undefined : arguments[2];
    } else {
      data = arguments.length <= 0 ? undefined : arguments[0]; // $FlowFixMe

      options = arguments.length <= 1 ? undefined : arguments[1];
      name = null;
    }

    if (name) {
      this.updateOne(this.map[name], data, options);
    } else {
      for (var index = 0; index < this.index.length; index++) {
        this.updateOne(this.index[index], data, options);
      }
    }
  }
  /**
   * Execute plugins, update rule props.
   */
  ;

  _proto.updateOne = function updateOne(rule, data, options) {
    if (options === void 0) {
      options = defaultUpdateOptions;
    }

    var _this$options2 = this.options,
        plugins = _this$options2.jss.plugins,
        sheet = _this$options2.sheet; // It is a rules container like for e.g. ConditionalRule.

    if (rule.rules instanceof RuleList) {
      rule.rules.update(data, options);
      return;
    }

    var styleRule = rule;
    var style = styleRule.style;
    plugins.onUpdate(data, rule, sheet, options); // We rely on a new `style` ref in case it was mutated during onUpdate hook.

    if (options.process && style && style !== styleRule.style) {
      // We need to run the plugins in case new `style` relies on syntax plugins.
      plugins.onProcessStyle(styleRule.style, styleRule, sheet); // Update and add props.

      for (var prop in styleRule.style) {
        var nextValue = styleRule.style[prop];
        var prevValue = style[prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

        if (nextValue !== prevValue) {
          styleRule.prop(prop, nextValue, forceUpdateOptions);
        }
      } // Remove props.


      for (var _prop in style) {
        var _nextValue = styleRule.style[_prop];
        var _prevValue = style[_prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

        if (_nextValue == null && _nextValue !== _prevValue) {
          styleRule.prop(_prop, null, forceUpdateOptions);
        }
      }
    }
  }
  /**
   * Convert rules to a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    var str = '';
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;

    for (var index = 0; index < this.index.length; index++) {
      var rule = this.index[index];
      var css = rule.toString(options); // No need to render an empty rule.

      if (!css && !link) continue;
      if (str) str += '\n';
      str += css;
    }

    return str;
  };

  return RuleList;
}();

var StyleSheet =
/*#__PURE__*/
function () {
  function StyleSheet(styles, options) {
    this.options = void 0;
    this.deployed = void 0;
    this.attached = void 0;
    this.rules = void 0;
    this.renderer = void 0;
    this.classes = void 0;
    this.keyframes = void 0;
    this.queue = void 0;
    this.attached = false;
    this.deployed = false;
    this.classes = {};
    this.keyframes = {};
    this.options = _extends({}, options, {
      sheet: this,
      parent: this,
      classes: this.classes,
      keyframes: this.keyframes
    });

    if (options.Renderer) {
      this.renderer = new options.Renderer(this);
    }

    this.rules = new RuleList(this.options);

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }
  /**
   * Attach renderable to the render tree.
   */


  var _proto = StyleSheet.prototype;

  _proto.attach = function attach() {
    if (this.attached) return this;
    if (this.renderer) this.renderer.attach();
    this.attached = true; // Order is important, because we can't use insertRule API if style element is not attached.

    if (!this.deployed) this.deploy();
    return this;
  }
  /**
   * Remove renderable from render tree.
   */
  ;

  _proto.detach = function detach() {
    if (!this.attached) return this;
    if (this.renderer) this.renderer.detach();
    this.attached = false;
    return this;
  }
  /**
   * Add a rule to the current stylesheet.
   * Will insert a rule also after the stylesheet has been rendered first time.
   */
  ;

  _proto.addRule = function addRule(name, decl, options) {
    var queue = this.queue; // Plugins can create rules.
    // In order to preserve the right order, we need to queue all `.addRule` calls,
    // which happen after the first `rules.add()` call.

    if (this.attached && !queue) this.queue = [];
    var rule = this.rules.add(name, decl, options);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);

    if (this.attached) {
      if (!this.deployed) return rule; // Don't insert rule directly if there is no stringified version yet.
      // It will be inserted all together when .attach is called.

      if (queue) queue.push(rule);else {
        this.insertRule(rule);

        if (this.queue) {
          this.queue.forEach(this.insertRule, this);
          this.queue = undefined;
        }
      }
      return rule;
    } // We can't add rules to a detached style node.
    // We will redeploy the sheet once user will attach it.


    this.deployed = false;
    return rule;
  }
  /**
   * Insert rule into the StyleSheet
   */
  ;

  _proto.insertRule = function insertRule(rule) {
    if (this.renderer) {
      this.renderer.insertRule(rule);
    }
  }
  /**
   * Create and add rules.
   * Will render also after Style Sheet was rendered the first time.
   */
  ;

  _proto.addRules = function addRules(styles, options) {
    var added = [];

    for (var name in styles) {
      var rule = this.addRule(name, styles[name], options);
      if (rule) added.push(rule);
    }

    return added;
  }
  /**
   * Get a rule by name.
   */
  ;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Delete a rule by name.
   * Returns `true`: if rule has been deleted from the DOM.
   */
  ;

  _proto.deleteRule = function deleteRule(name) {
    var rule = typeof name === 'object' ? name : this.rules.get(name);
    if (!rule) return false;
    this.rules.remove(rule);

    if (this.attached && rule.renderable && this.renderer) {
      return this.renderer.deleteRule(rule.renderable);
    }

    return true;
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Deploy pure CSS string to a renderable.
   */
  ;

  _proto.deploy = function deploy() {
    if (this.renderer) this.renderer.deploy();
    this.deployed = true;
    return this;
  }
  /**
   * Update the function values with a new data.
   */
  ;

  _proto.update = function update() {
    var _this$rules;

    (_this$rules = this.rules).update.apply(_this$rules, arguments);

    return this;
  }
  /**
   * Updates a single rule.
   */
  ;

  _proto.updateOne = function updateOne(rule, data, options) {
    this.rules.updateOne(rule, data, options);
    return this;
  }
  /**
   * Convert rules to a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    return this.rules.toString(options);
  };

  return StyleSheet;
}();

var PluginsRegistry =
/*#__PURE__*/
function () {
  function PluginsRegistry() {
    this.plugins = {
      internal: [],
      external: []
    };
    this.registry = void 0;
  }

  var _proto = PluginsRegistry.prototype;

  /**
   * Call `onCreateRule` hooks and return an object if returned by a hook.
   */
  _proto.onCreateRule = function onCreateRule(name, decl, options) {
    for (var i = 0; i < this.registry.onCreateRule.length; i++) {
      var rule = this.registry.onCreateRule[i](name, decl, options);
      if (rule) return rule;
    }

    return null;
  }
  /**
   * Call `onProcessRule` hooks.
   */
  ;

  _proto.onProcessRule = function onProcessRule(rule) {
    if (rule.isProcessed) return;
    var sheet = rule.options.sheet;

    for (var i = 0; i < this.registry.onProcessRule.length; i++) {
      this.registry.onProcessRule[i](rule, sheet);
    }

    if (rule.style) this.onProcessStyle(rule.style, rule, sheet);
    rule.isProcessed = true;
  }
  /**
   * Call `onProcessStyle` hooks.
   */
  ;

  _proto.onProcessStyle = function onProcessStyle(style, rule, sheet) {
    for (var i = 0; i < this.registry.onProcessStyle.length; i++) {
      // $FlowFixMe
      rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);
    }
  }
  /**
   * Call `onProcessSheet` hooks.
   */
  ;

  _proto.onProcessSheet = function onProcessSheet(sheet) {
    for (var i = 0; i < this.registry.onProcessSheet.length; i++) {
      this.registry.onProcessSheet[i](sheet);
    }
  }
  /**
   * Call `onUpdate` hooks.
   */
  ;

  _proto.onUpdate = function onUpdate(data, rule, sheet, options) {
    for (var i = 0; i < this.registry.onUpdate.length; i++) {
      this.registry.onUpdate[i](data, rule, sheet, options);
    }
  }
  /**
   * Call `onChangeValue` hooks.
   */
  ;

  _proto.onChangeValue = function onChangeValue(value, prop, rule) {
    var processedValue = value;

    for (var i = 0; i < this.registry.onChangeValue.length; i++) {
      processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);
    }

    return processedValue;
  }
  /**
   * Register a plugin.
   */
  ;

  _proto.use = function use(newPlugin, options) {
    if (options === void 0) {
      options = {
        queue: 'external'
      };
    }

    var plugins = this.plugins[options.queue]; // Avoids applying same plugin twice, at least based on ref.

    if (plugins.indexOf(newPlugin) !== -1) {
      return;
    }

    plugins.push(newPlugin);
    this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function (registry, plugin) {
      for (var name in plugin) {
        if (name in registry) {
          registry[name].push(plugin[name]);
        } else {
          "development" !== "production" ? warning(false, "[JSS] Unknown hook \"" + name + "\".") : void 0;
        }
      }

      return registry;
    }, {
      onCreateRule: [],
      onProcessRule: [],
      onProcessStyle: [],
      onProcessSheet: [],
      onChangeValue: [],
      onUpdate: []
    });
  };

  return PluginsRegistry;
}();

/**
 * Sheets registry to access them all at one place.
 */
var SheetsRegistry =
/*#__PURE__*/
function () {
  function SheetsRegistry() {
    this.registry = [];
  }

  var _proto = SheetsRegistry.prototype;

  /**
   * Register a Style Sheet.
   */
  _proto.add = function add(sheet) {
    var registry = this.registry;
    var index = sheet.options.index;
    if (registry.indexOf(sheet) !== -1) return;

    if (registry.length === 0 || index >= this.index) {
      registry.push(sheet);
      return;
    } // Find a position.


    for (var i = 0; i < registry.length; i++) {
      if (registry[i].options.index > index) {
        registry.splice(i, 0, sheet);
        return;
      }
    }
  }
  /**
   * Reset the registry.
   */
  ;

  _proto.reset = function reset() {
    this.registry = [];
  }
  /**
   * Remove a Style Sheet.
   */
  ;

  _proto.remove = function remove(sheet) {
    var index = this.registry.indexOf(sheet);
    this.registry.splice(index, 1);
  }
  /**
   * Convert all attached sheets to a CSS string.
   */
  ;

  _proto.toString = function toString(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        attached = _ref.attached,
        options = _objectWithoutPropertiesLoose(_ref, ["attached"]);

    var css = '';

    for (var i = 0; i < this.registry.length; i++) {
      var sheet = this.registry[i];

      if (attached != null && sheet.attached !== attached) {
        continue;
      }

      if (css) css += '\n';
      css += sheet.toString(options);
    }

    return css;
  };

  _createClass(SheetsRegistry, [{
    key: "index",

    /**
     * Current highest index number.
     */
    get: function get() {
      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
    }
  }]);

  return SheetsRegistry;
}();

/**
 * This is a global sheets registry. Only DomRenderer will add sheets to it.
 * On the server one should use an own SheetsRegistry instance and add the
 * sheets to it, because you need to make sure to create a new registry for
 * each request in order to not leak sheets across requests.
 */

var sheets = new SheetsRegistry();

/* eslint-disable */
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var globalThis = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();

var ns = '2f1acc6c3a606b082e5eef5e54414ffb';
if (globalThis[ns] == null) globalThis[ns] = 0; // Bundle may contain multiple JSS versions at the same time. In order to identify
// the current version with just one short number and use it for classes generation
// we use a counter. Also it is more accurate, because user can manually reevaluate
// the module.

var moduleId = globalThis[ns]++;

var maxRules = 1e10;

/**
 * Returns a function which generates unique class names based on counters.
 * When new generator function is created, rule counter is reseted.
 * We need to reset the rule counter for SSR for each request.
 */
var createGenerateId = function createGenerateId(options) {
  if (options === void 0) {
    options = {};
  }

  var ruleCounter = 0;
  return function (rule, sheet) {
    ruleCounter += 1;

    if (ruleCounter > maxRules) {
      "development" !== "production" ? warning(false, "[JSS] You might have a memory leak. Rule counter is at " + ruleCounter + ".") : void 0;
    }

    var jssId = '';
    var prefix = '';

    if (sheet) {
      if (sheet.options.classNamePrefix) {
        prefix = sheet.options.classNamePrefix;
      }

      if (sheet.options.jss.id != null) {
        jssId = String(sheet.options.jss.id);
      }
    }

    if (options.minify) {
      // Using "c" because a number can't be the first char in a class name.
      return "" + (prefix || 'c') + moduleId + jssId + ruleCounter;
    }

    return prefix + rule.key + "-" + moduleId + (jssId ? "-" + jssId : '') + "-" + ruleCounter;
  };
};

/**
 * Cache the value from the first time a function is called.
 */
var memoize = function memoize(fn) {
  var value;
  return function () {
    if (!value) value = fn();
    return value;
  };
};
/**
 * Get a style property value.
 */


function getPropertyValue(cssRule, prop) {
  try {
    // Support CSSTOM.
    if (cssRule.attributeStyleMap) {
      return cssRule.attributeStyleMap.get(prop);
    }

    return cssRule.style.getPropertyValue(prop);
  } catch (err) {
    // IE may throw if property is unknown.
    return '';
  }
}
/**
 * Set a style property.
 */


function setProperty(cssRule, prop, value) {
  try {
    var cssValue = value;

    if (Array.isArray(value)) {
      cssValue = toCssValue(value, true);

      if (value[value.length - 1] === '!important') {
        cssRule.style.setProperty(prop, cssValue, 'important');
        return true;
      }
    } // Support CSSTOM.


    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.set(prop, cssValue);
    } else {
      cssRule.style.setProperty(prop, cssValue);
    }
  } catch (err) {
    // IE may throw if property is unknown.
    return false;
  }

  return true;
}
/**
 * Remove a style property.
 */


function removeProperty(cssRule, prop) {
  try {
    // Support CSSTOM.
    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.delete(prop);
    } else {
      cssRule.style.removeProperty(prop);
    }
  } catch (err) {
    "development" !== "production" ? warning(false, "[JSS] DOMException \"" + err.message + "\" was thrown. Tried to remove property \"" + prop + "\".") : void 0;
  }
}
/**
 * Set the selector.
 */


function setSelector(cssRule, selectorText) {
  cssRule.selectorText = selectorText; // Return false if setter was not successful.
  // Currently works in chrome only.

  return cssRule.selectorText === selectorText;
}
/**
 * Gets the `head` element upon the first call and caches it.
 * We assume it can't be null.
 */


var getHead = memoize(function () {
  return document.querySelector('head');
});
/**
 * Find attached sheet with an index higher than the passed one.
 */

function findHigherSheet(registry, options) {
  for (var i = 0; i < registry.length; i++) {
    var sheet = registry[i];

    if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }

  return null;
}
/**
 * Find attached sheet with the highest index.
 */


function findHighestSheet(registry, options) {
  for (var i = registry.length - 1; i >= 0; i--) {
    var sheet = registry[i];

    if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }

  return null;
}
/**
 * Find a comment with "jss" inside.
 */


function findCommentNode(text) {
  var head = getHead();

  for (var i = 0; i < head.childNodes.length; i++) {
    var node = head.childNodes[i];

    if (node.nodeType === 8 && node.nodeValue.trim() === text) {
      return node;
    }
  }

  return null;
}

/**
 * Find a node before which we can insert the sheet.
 */
function findPrevNode(options) {
  var registry = sheets.registry;

  if (registry.length > 0) {
    // Try to insert before the next higher sheet.
    var sheet = findHigherSheet(registry, options);

    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element
      };
    } // Otherwise insert after the last attached.


    sheet = findHighestSheet(registry, options);

    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element.nextSibling
      };
    }
  } // Try to find a comment placeholder if registry is empty.


  var insertionPoint = options.insertionPoint;

  if (insertionPoint && typeof insertionPoint === 'string') {
    var comment = findCommentNode(insertionPoint);

    if (comment) {
      return {
        parent: comment.parentNode,
        node: comment.nextSibling
      };
    } // If user specifies an insertion point and it can't be found in the document -
    // bad specificity issues may appear.


    "development" !== "production" ? warning(false, "[JSS] Insertion point \"" + insertionPoint + "\" not found.") : void 0;
  }

  return false;
}
/**
 * Insert style element into the DOM.
 */


function insertStyle(style, options) {
  var insertionPoint = options.insertionPoint;
  var nextNode = findPrevNode(options);

  if (nextNode !== false && nextNode.parent) {
    nextNode.parent.insertBefore(style, nextNode.node);
    return;
  } // Works with iframes and any node types.


  if (insertionPoint && typeof insertionPoint.nodeType === 'number') {
    // https://stackoverflow.com/questions/41328728/force-casting-in-flow
    var insertionPointElement = insertionPoint;
    var parentNode = insertionPointElement.parentNode;
    if (parentNode) parentNode.insertBefore(style, insertionPointElement.nextSibling);else "development" !== "production" ? warning(false, '[JSS] Insertion point is not in the DOM.') : void 0;
    return;
  }

  getHead().appendChild(style);
}
/**
 * Read jss nonce setting from the page if the user has set it.
 */


var getNonce = memoize(function () {
  var node = document.querySelector('meta[property="csp-nonce"]');
  return node ? node.getAttribute('content') : null;
});

var _insertRule = function insertRule(container, rule, index) {
  var maxIndex = container.cssRules.length; // In case previous insertion fails, passed index might be wrong

  if (index === undefined || index > maxIndex) {
    // eslint-disable-next-line no-param-reassign
    index = maxIndex;
  }

  try {
    if ('insertRule' in container) {
      var c = container;
      c.insertRule(rule, index);
    } // Keyframes rule.
    else if ('appendRule' in container) {
        var _c = container;

        _c.appendRule(rule);
      }
  } catch (err) {
    "development" !== "production" ? warning(false, "[JSS] " + err.message) : void 0;
    return false;
  }

  return container.cssRules[index];
};

var createStyle = function createStyle() {
  var el = document.createElement('style'); // Without it, IE will have a broken source order specificity if we
  // insert rules after we insert the style tag.
  // It seems to kick-off the source order specificity algorithm.

  el.textContent = '\n';
  return el;
};

var DomRenderer =
/*#__PURE__*/
function () {
  // HTMLStyleElement needs fixing https://github.com/facebook/flow/issues/2696
  function DomRenderer(sheet) {
    this.getPropertyValue = getPropertyValue;
    this.setProperty = setProperty;
    this.removeProperty = removeProperty;
    this.setSelector = setSelector;
    this.element = void 0;
    this.sheet = void 0;
    this.hasInsertedRules = false;
    // There is no sheet when the renderer is used from a standalone StyleRule.
    if (sheet) sheets.add(sheet);
    this.sheet = sheet;

    var _ref = this.sheet ? this.sheet.options : {},
        media = _ref.media,
        meta = _ref.meta,
        element = _ref.element;

    this.element = element || createStyle();
    this.element.setAttribute('data-jss', '');
    if (media) this.element.setAttribute('media', media);
    if (meta) this.element.setAttribute('data-meta', meta);
    var nonce = getNonce();
    if (nonce) this.element.setAttribute('nonce', nonce);
  }
  /**
   * Insert style element into render tree.
   */


  var _proto = DomRenderer.prototype;

  _proto.attach = function attach() {
    // In the case the element node is external and it is already in the DOM.
    if (this.element.parentNode || !this.sheet) return;
    insertStyle(this.element, this.sheet.options); // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`
    // most browsers create a new CSSStyleSheet, except of all IEs.

    var deployed = Boolean(this.sheet && this.sheet.deployed);

    if (this.hasInsertedRules && deployed) {
      this.hasInsertedRules = false;
      this.deploy();
    }
  }
  /**
   * Remove style element from render tree.
   */
  ;

  _proto.detach = function detach() {
    var parentNode = this.element.parentNode;
    if (parentNode) parentNode.removeChild(this.element);
  }
  /**
   * Inject CSS string into element.
   */
  ;

  _proto.deploy = function deploy() {
    var sheet = this.sheet;
    if (!sheet) return;

    if (sheet.options.link) {
      this.insertRules(sheet.rules);
      return;
    }

    this.element.textContent = "\n" + sheet.toString() + "\n";
  }
  /**
   * Insert RuleList into an element.
   */
  ;

  _proto.insertRules = function insertRules(rules, nativeParent) {
    for (var i = 0; i < rules.index.length; i++) {
      this.insertRule(rules.index[i], i, nativeParent);
    }
  }
  /**
   * Insert a rule into element.
   */
  ;

  _proto.insertRule = function insertRule(rule, index, nativeParent) {
    if (nativeParent === void 0) {
      nativeParent = this.element.sheet;
    }

    if (rule.rules) {
      var parent = rule;
      var latestNativeParent = nativeParent;

      if (rule.type === 'conditional' || rule.type === 'keyframes') {
        // We need to render the container without children first.
        latestNativeParent = _insertRule(nativeParent, parent.toString({
          children: false
        }), index);

        if (latestNativeParent === false) {
          return false;
        }
      }

      this.insertRules(parent.rules, latestNativeParent);
      return latestNativeParent;
    } // IE keeps the CSSStyleSheet after style node has been reattached,
    // so we need to check if the `renderable` reference the right style sheet and not
    // rerender those rules.


    if (rule.renderable && rule.renderable.parentStyleSheet === this.element.sheet) {
      return rule.renderable;
    }

    var ruleStr = rule.toString();
    if (!ruleStr) return false;

    var nativeRule = _insertRule(nativeParent, ruleStr, index);

    if (nativeRule === false) {
      return false;
    }

    this.hasInsertedRules = true;
    rule.renderable = nativeRule;
    return nativeRule;
  }
  /**
   * Delete a rule.
   */
  ;

  _proto.deleteRule = function deleteRule(cssRule) {
    var sheet = this.element.sheet;
    var index = this.indexOf(cssRule);
    if (index === -1) return false;
    sheet.deleteRule(index);
    return true;
  }
  /**
   * Get index of a CSS Rule.
   */
  ;

  _proto.indexOf = function indexOf(cssRule) {
    var cssRules = this.element.sheet.cssRules;

    for (var index = 0; index < cssRules.length; index++) {
      if (cssRule === cssRules[index]) return index;
    }

    return -1;
  }
  /**
   * Generate a new CSS rule and replace the existing one.
   *
   * Only used for some old browsers because they can't set a selector.
   */
  ;

  _proto.replaceRule = function replaceRule(cssRule, rule) {
    var index = this.indexOf(cssRule);
    if (index === -1) return false;
    this.element.sheet.deleteRule(index);
    return this.insertRule(rule, index);
  }
  /**
   * Get all rules elements.
   */
  ;

  _proto.getRules = function getRules() {
    return this.element.sheet.cssRules;
  };

  return DomRenderer;
}();

var instanceCounter = 0;

var Jss =
/*#__PURE__*/
function () {
  function Jss(options) {
    this.id = instanceCounter++;
    this.version = "10.3.0";
    this.plugins = new PluginsRegistry();
    this.options = {
      id: {
        minify: false
      },
      createGenerateId: createGenerateId,
      Renderer: isInBrowser ? DomRenderer : null,
      plugins: []
    };
    this.generateId = createGenerateId({
      minify: false
    });

    for (var i = 0; i < plugins.length; i++) {
      this.plugins.use(plugins[i], {
        queue: 'internal'
      });
    }

    this.setup(options);
  }
  /**
   * Prepares various options, applies plugins.
   * Should not be used twice on the same instance, because there is no plugins
   * deduplication logic.
   */


  var _proto = Jss.prototype;

  _proto.setup = function setup(options) {
    if (options === void 0) {
      options = {};
    }

    if (options.createGenerateId) {
      this.options.createGenerateId = options.createGenerateId;
    }

    if (options.id) {
      this.options.id = _extends({}, this.options.id, options.id);
    }

    if (options.createGenerateId || options.id) {
      this.generateId = this.options.createGenerateId(this.options.id);
    }

    if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;

    if ('Renderer' in options) {
      this.options.Renderer = options.Renderer;
    } // eslint-disable-next-line prefer-spread


    if (options.plugins) this.use.apply(this, options.plugins);
    return this;
  }
  /**
   * Create a Style Sheet.
   */
  ;

  _proto.createStyleSheet = function createStyleSheet(styles, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        index = _options.index;

    if (typeof index !== 'number') {
      index = sheets.index === 0 ? 0 : sheets.index + 1;
    }

    var sheet = new StyleSheet(styles, _extends({}, options, {
      jss: this,
      generateId: options.generateId || this.generateId,
      insertionPoint: this.options.insertionPoint,
      Renderer: this.options.Renderer,
      index: index
    }));
    this.plugins.onProcessSheet(sheet);
    return sheet;
  }
  /**
   * Detach the Style Sheet and remove it from the registry.
   */
  ;

  _proto.removeStyleSheet = function removeStyleSheet(sheet) {
    sheet.detach();
    sheets.remove(sheet);
    return this;
  }
  /**
   * Create a rule without a Style Sheet.
   * [Deprecated] will be removed in the next major version.
   */
  ;

  _proto.createRule = function createRule$1(name, style, options) {
    if (style === void 0) {
      style = {};
    }

    if (options === void 0) {
      options = {};
    }

    // Enable rule without name for inline styles.
    if (typeof name === 'object') {
      return this.createRule(undefined, name, style);
    }

    var ruleOptions = _extends({}, options, {
      name: name,
      jss: this,
      Renderer: this.options.Renderer
    });

    if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;
    if (!ruleOptions.classes) ruleOptions.classes = {};
    if (!ruleOptions.keyframes) ruleOptions.keyframes = {};

    var rule = createRule(name, style, ruleOptions);

    if (rule) this.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Register plugin. Passed function will be invoked with a rule instance.
   */
  ;

  _proto.use = function use() {
    var _this = this;

    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins[_key] = arguments[_key];
    }

    plugins.forEach(function (plugin) {
      _this.plugins.use(plugin);
    });
    return this;
  };

  return Jss;
}();

/**
 * Extracts a styles object with only props that contain function values.
 */
function getDynamicStyles(styles) {
  var to = null;

  for (var key in styles) {
    var value = styles[key];
    var type = typeof value;

    if (type === 'function') {
      if (!to) to = {};
      to[key] = value;
    } else if (type === 'object' && value !== null && !Array.isArray(value)) {
      var extracted = getDynamicStyles(value);

      if (extracted) {
        if (!to) to = {};
        to[key] = extracted;
      }
    }
  }

  return to;
}

/**
 * SheetsManager is like a WeakMap which is designed to count StyleSheet
 * instances and attach/detach automatically.
 */
var SheetsManager =
/*#__PURE__*/
function () {
  function SheetsManager() {
    this.length = 0;
    this.sheets = new WeakMap();
  }

  var _proto = SheetsManager.prototype;

  _proto.get = function get(key) {
    var entry = this.sheets.get(key);
    return entry && entry.sheet;
  };

  _proto.add = function add(key, sheet) {
    if (this.sheets.has(key)) return;
    this.length++;
    this.sheets.set(key, {
      sheet: sheet,
      refs: 0
    });
  };

  _proto.manage = function manage(key) {
    var entry = this.sheets.get(key);

    if (entry) {
      if (entry.refs === 0) {
        entry.sheet.attach();
      }

      entry.refs++;
      return entry.sheet;
    }

    warning(false, "[JSS] SheetsManager: can't find sheet to manage");
    return undefined;
  };

  _proto.unmanage = function unmanage(key) {
    var entry = this.sheets.get(key);

    if (entry) {
      if (entry.refs > 0) {
        entry.refs--;
        if (entry.refs === 0) entry.sheet.detach();
      }
    } else {
      warning(false, "SheetsManager: can't find sheet to unmanage");
    }
  };

  _createClass(SheetsManager, [{
    key: "size",
    get: function get() {
      return this.length;
    }
  }]);

  return SheetsManager;
}();

/**
 * A better abstraction over CSS.
 *
 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
 * @website https://github.com/cssinjs/jss
 * @license MIT
 */

/**
 * Export a constant indicating if this browser has CSSTOM support.
 * https://developers.google.com/web/updates/2018/03/cssom
 */
var hasCSSTOMSupport = typeof CSS !== 'undefined' && CSS && 'number' in CSS;
/**
 * Creates a new instance of Jss.
 */

var create = function create(options) {
  return new Jss(options);
};
/**
 * A global Jss instance.
 */

var index = create();

exports.RuleList = RuleList;
exports.SheetsManager = SheetsManager;
exports.SheetsRegistry = SheetsRegistry;
exports.create = create;
exports.createGenerateId = createGenerateId;
exports.createRule = createRule;
exports.default = index;
exports.getDynamicStyles = getDynamicStyles;
exports.hasCSSTOMSupport = hasCSSTOMSupport;
exports.sheets = sheets;
exports.toCssValue = toCssValue;

      };
    };
  }
  }
}, {package:"@material-ui/core>@material-ui/styles>jss",file:"node_modules\\jss\\dist\\jss.cjs.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\linked-list\\_source\\linked-list.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clinked-list%5C_source%5Clinked-list.js
      return function (require, module, exports) {
'use strict';

/**
 * Constants.
 */

var errorMessage;

errorMessage = 'An argument without append, prepend, ' +
    'or detach methods was given to `List';

/**
 * Creates a new List: A linked list is a bit like an Array, but
 * knows nothing about how many items are in it, and knows only about its
 * first (`head`) and last (`tail`) items. Each item (e.g. `head`, `tail`,
 * &c.) knows which item comes before or after it (its more like the
 * implementation of the DOM in JavaScript).
 * @global
 * @private
 * @constructor
 * @class Represents an instance of List.
 */

function List(/*items...*/) {
    if (arguments.length) {
        return List.from(arguments);
    }
}

var ListPrototype;

ListPrototype = List.prototype;

/**
 * Creates a new list from the arguments (each a list item) passed in.
 * @name List.of
 * @param {...ListItem} [items] - Zero or more items to attach.
 * @returns {list} - A new instance of List.
 */

List.of = function (/*items...*/) {
    return List.from.call(this, arguments);
};

/**
 * Creates a new list from the given array-like object (each a list item)
 * passed in.
 * @name List.from
 * @param {ListItem[]} [items] - The items to append.
 * @returns {list} - A new instance of List.
 */
List.from = function (items) {
    var list = new this(), length, iterator, item;

    if (items && (length = items.length)) {
        iterator = -1;

        while (++iterator < length) {
            item = items[iterator];

            if (item !== null && item !== undefined) {
                list.append(item);
            }
        }
    }

    return list;
};

/**
 * List#head
 * Default to `null`.
 */
ListPrototype.head = null;

/**
 * List#tail
 * Default to `null`.
 */
ListPrototype.tail = null;

/**
 * Returns the list's items as an array. This does *not* detach the items.
 * @name List#toArray
 * @returns {ListItem[]} - An array of (still attached) ListItems.
 */
ListPrototype.toArray = function () {
    var item = this.head,
        result = [];

    while (item) {
        result.push(item);
        item = item.next;
    }

    return result;
};

/**
 * Prepends the given item to the list: Item will be the new first item
 * (`head`).
 * @name List#prepend
 * @param {ListItem} item - The item to prepend.
 * @returns {ListItem} - An instance of ListItem (the given item).
 */
ListPrototype.prepend = function (item) {
    if (!item) {
        return false;
    }

    if (!item.append || !item.prepend || !item.detach) {
        throw new Error(errorMessage + '#prepend`.');
    }

    var self, head;

    // Cache self.
    self = this;

    // If self has a first item, defer prepend to the first items prepend
    // method, and return the result.
    head = self.head;

    if (head) {
        return head.prepend(item);
    }

    // ...otherwise, there is no `head` (or `tail`) item yet.

    // Detach the prependee.
    item.detach();

    // Set the prependees parent list to reference self.
    item.list = self;

    // Set self's first item to the prependee, and return the item.
    self.head = item;

    return item;
};

/**
 * Appends the given item to the list: Item will be the new last item (`tail`)
 * if the list had a first item, and its first item (`head`) otherwise.
 * @name List#append
 * @param {ListItem} item - The item to append.
 * @returns {ListItem} - An instance of ListItem (the given item).
 */

ListPrototype.append = function (item) {
    if (!item) {
        return false;
    }

    if (!item.append || !item.prepend || !item.detach) {
        throw new Error(errorMessage + '#append`.');
    }

    var self, head, tail;

    // Cache self.
    self = this;

    // If self has a last item, defer appending to the last items append
    // method, and return the result.
    tail = self.tail;

    if (tail) {
        return tail.append(item);
    }

    // If self has a first item, defer appending to the first items append
    // method, and return the result.
    head = self.head;

    if (head) {
        return head.append(item);
    }

    // ...otherwise, there is no `tail` or `head` item yet.

    // Detach the appendee.
    item.detach();

    // Set the appendees parent list to reference self.
    item.list = self;

    // Set self's first item to the appendee, and return the item.
    self.head = item;

    return item;
};

/**
 * Creates a new ListItem: A linked list item is a bit like DOM node:
 * It knows only about its "parent" (`list`), the item before it (`prev`),
 * and the item after it (`next`).
 * @global
 * @private
 * @constructor
 * @class Represents an instance of ListItem.
 */

function ListItem() {}

List.Item = ListItem;

var ListItemPrototype = ListItem.prototype;

ListItemPrototype.next = null;

ListItemPrototype.prev = null;

ListItemPrototype.list = null;

/**
 * Detaches the item operated on from its parent list.
 * @name ListItem#detach
 * @returns {ListItem} - The item operated on.
 */
ListItemPrototype.detach = function () {
    // Cache self, the parent list, and the previous and next items.
    var self = this,
        list = self.list,
        prev = self.prev,
        next = self.next;

    // If the item is already detached, return self.
    if (!list) {
        return self;
    }

    // If self is the last item in the parent list, link the lists last item
    // to the previous item.
    if (list.tail === self) {
        list.tail = prev;
    }

    // If self is the first item in the parent list, link the lists first item
    // to the next item.
    if (list.head === self) {
        list.head = next;
    }

    // If both the last and first items in the parent list are the same,
    // remove the link to the last item.
    if (list.tail === list.head) {
        list.tail = null;
    }

    // If a previous item exists, link its next item to selfs next item.
    if (prev) {
        prev.next = next;
    }

    // If a next item exists, link its previous item to selfs previous item.
    if (next) {
        next.prev = prev;
    }

    // Remove links from self to both the next and previous items, and to the
    // parent list.
    self.prev = self.next = self.list = null;

    // Return self.
    return self;
};

/**
 * Prepends the given item *before* the item operated on.
 * @name ListItem#prepend
 * @param {ListItem} item - The item to prepend.
 * @returns {ListItem} - The item operated on, or false when that item is not
 * attached.
 */
ListItemPrototype.prepend = function (item) {
    if (!item || !item.append || !item.prepend || !item.detach) {
        throw new Error(errorMessage + 'Item#prepend`.');
    }

    // Cache self, the parent list, and the previous item.
    var self = this,
        list = self.list,
        prev = self.prev;

    // If self is detached, return false.
    if (!list) {
        return false;
    }

    // Detach the prependee.
    item.detach();

    // If self has a previous item...
    if (prev) {
        // ...link the prependees previous item, to selfs previous item.
        item.prev = prev;

        // ...link the previous items next item, to self.
        prev.next = item;
    }

    // Set the prependees next item to self.
    item.next = self;

    // Set the prependees parent list to selfs parent list.
    item.list = list;

    // Set the previous item of self to the prependee.
    self.prev = item;

    // If self is the first item in the parent list, link the lists first item
    // to the prependee.
    if (self === list.head) {
        list.head = item;
    }

    // If the the parent list has no last item, link the lists last item to
    // self.
    if (!list.tail) {
        list.tail = self;
    }

    // Return the prependee.
    return item;
};

/**
 * Appends the given item *after* the item operated on.
 * @name ListItem#append
 * @param {ListItem} item - The item to append.
 * @returns {ListItem} - The item operated on, or false when that item is not
 * attached.
 */
ListItemPrototype.append = function (item) {
    // If item is falsey, return false.
    if (!item || !item.append || !item.prepend || !item.detach) {
        throw new Error(errorMessage + 'Item#append`.');
    }

    // Cache self, the parent list, and the next item.
    var self = this,
        list = self.list,
        next = self.next;

    // If self is detached, return false.
    if (!list) {
        return false;
    }

    // Detach the appendee.
    item.detach();

    // If self has a next item...
    if (next) {
        // ...link the appendees next item, to selfs next item.
        item.next = next;

        // ...link the next items previous item, to the appendee.
        next.prev = item;
    }

    // Set the appendees previous item to self.
    item.prev = self;

    // Set the appendees parent list to selfs parent list.
    item.list = list;

    // Set the next item of self to the appendee.
    self.next = item;

    // If the the parent list has no last item or if self is the parent lists
    // last item, link the lists last item to the appendee.
    if (self === list.tail || !list.tail) {
        list.tail = item;
    }

    // Return the appendee.
    return item;
};

/**
 * Expose `List`.
 */

module.exports = List;

      };
    };
  }
  }
}, {package:"remote-redux-devtools>socketcluster-client>linked-list",file:"node_modules\\linked-list\\_source\\linked-list.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\linked-list\\index.js", {"./_source/linked-list.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\linked-list\\_source\\linked-list.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clinked-list%5Cindex.js
      return function (require, module, exports) {
'use strict';

module.exports = require('./_source/linked-list.js');

      };
    };
  }
  }
}, {package:"remote-redux-devtools>socketcluster-client>linked-list",file:"node_modules\\linked-list\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\locale-currency\\index.js", {"./map":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\locale-currency\\map.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clocale-currency%5Cindex.js
      return function (require, module, exports) {
var map = require("./map");

var getCountryCode = function(localeString) {
    var components = localeString.split("_");
    if (components.length == 2) {
        return components.pop();
    }
    components = localeString.split("-");
    if (components.length == 2) {
        return components.pop();
    }
    return localeString;
}

exports.getCurrency = function(locale) {
    var countryCode = getCountryCode(locale).toUpperCase();
    if (countryCode in map) {
        return map[countryCode];
    }
    return null;
}

exports.getLocales = function(currencyCode) {
    currencyCode = currencyCode.toUpperCase();
    var locales = [];
    for (countryCode in map) {
        if (map[countryCode] === currencyCode) {
            locales.push(countryCode);
        }
    }
    return locales;
}
      };
    };
  }
  }
}, {package:"currency-formatter>locale-currency",file:"node_modules\\locale-currency\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\locale-currency\\map.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clocale-currency%5Cmap.js
      return function (require, module, exports) {
// Generated using ShowCurrencies.java
var map = {
AD: 'EUR',
AE: 'AED',
AF: 'AFN',
AG: 'XCD',
AI: 'XCD',
AL: 'ALL',
AM: 'AMD',
AN: 'ANG',
AO: 'AOA',
AR: 'ARS',
AS: 'USD',
AT: 'EUR',
AU: 'AUD',
AW: 'AWG',
AX: 'EUR',
AZ: 'AZN',
BA: 'BAM',
BB: 'BBD',
BD: 'BDT',
BE: 'EUR',
BF: 'XOF',
BG: 'BGN',
BH: 'BHD',
BI: 'BIF',
BJ: 'XOF',
BL: 'EUR',
BM: 'BMD',
BN: 'BND',
BO: 'BOB',
BQ: 'USD',
BR: 'BRL',
BS: 'BSD',
BT: 'BTN',
BV: 'NOK',
BW: 'BWP',
BY: 'BYR',
BZ: 'BZD',
CA: 'CAD',
CC: 'AUD',
CD: 'CDF',
CF: 'XAF',
CG: 'XAF',
CH: 'CHF',
CI: 'XOF',
CK: 'NZD',
CL: 'CLP',
CM: 'XAF',
CN: 'CNY',
CO: 'COP',
CR: 'CRC',
CU: 'CUP',
CV: 'CVE',
CW: 'ANG',
CX: 'AUD',
CY: 'EUR',
CZ: 'CZK',
DE: 'EUR',
DJ: 'DJF',
DK: 'DKK',
DM: 'XCD',
DO: 'DOP',
DZ: 'DZD',
EC: 'USD',
EE: 'EUR',
EG: 'EGP',
EH: 'MAD',
ER: 'ERN',
ES: 'EUR',
ET: 'ETB',
FI: 'EUR',
FJ: 'FJD',
FK: 'FKP',
FM: 'USD',
FO: 'DKK',
FR: 'EUR',
GA: 'XAF',
GB: 'GBP',
GD: 'XCD',
GE: 'GEL',
GF: 'EUR',
GG: 'GBP',
GH: 'GHS',
GI: 'GIP',
GL: 'DKK',
GM: 'GMD',
GN: 'GNF',
GP: 'EUR',
GQ: 'XAF',
GR: 'EUR',
GS: 'GBP',
GT: 'GTQ',
GU: 'USD',
GW: 'XOF',
GY: 'GYD',
HK: 'HKD',
HM: 'AUD',
HN: 'HNL',
HR: 'HRK',
HT: 'HTG',
HU: 'HUF',
ID: 'IDR',
IE: 'EUR',
IL: 'ILS',
IM: 'GBP',
IN: 'INR',
IO: 'USD',
IQ: 'IQD',
IR: 'IRR',
IS: 'ISK',
IT: 'EUR',
JE: 'GBP',
JM: 'JMD',
JO: 'JOD',
JP: 'JPY',
KE: 'KES',
KG: 'KGS',
KH: 'KHR',
KI: 'AUD',
KM: 'KMF',
KN: 'XCD',
KP: 'KPW',
KR: 'KRW',
KW: 'KWD',
KY: 'KYD',
KZ: 'KZT',
LA: 'LAK',
LB: 'LBP',
LC: 'XCD',
LI: 'CHF',
LK: 'LKR',
LR: 'LRD',
LS: 'LSL',
LT: 'LTL',
LU: 'EUR',
LV: 'LVL',
LY: 'LYD',
MA: 'MAD',
MC: 'EUR',
MD: 'MDL',
ME: 'EUR',
MF: 'EUR',
MG: 'MGA',
MH: 'USD',
MK: 'MKD',
ML: 'XOF',
MM: 'MMK',
MN: 'MNT',
MO: 'MOP',
MP: 'USD',
MQ: 'EUR',
MR: 'MRO',
MS: 'XCD',
MT: 'EUR',
MU: 'MUR',
MV: 'MVR',
MW: 'MWK',
MX: 'MXN',
MY: 'MYR',
MZ: 'MZN',
NA: 'NAD',
NC: 'XPF',
NE: 'XOF',
NF: 'AUD',
NG: 'NGN',
NI: 'NIO',
NL: 'EUR',
NO: 'NOK',
NP: 'NPR',
NR: 'AUD',
NU: 'NZD',
NZ: 'NZD',
OM: 'OMR',
PA: 'PAB',
PE: 'PEN',
PF: 'XPF',
PG: 'PGK',
PH: 'PHP',
PK: 'PKR',
PL: 'PLN',
PM: 'EUR',
PN: 'NZD',
PR: 'USD',
PS: 'ILS',
PT: 'EUR',
PW: 'USD',
PY: 'PYG',
QA: 'QAR',
RE: 'EUR',
RO: 'RON',
RS: 'RSD',
RU: 'RUB',
RW: 'RWF',
SA: 'SAR',
SB: 'SBD',
SC: 'SCR',
SD: 'SDG',
SE: 'SEK',
SG: 'SGD',
SH: 'SHP',
SI: 'EUR',
SJ: 'NOK',
SK: 'EUR',
SL: 'SLL',
SM: 'EUR',
SN: 'XOF',
SO: 'SOS',
SR: 'SRD',
ST: 'STD',
SV: 'SVC',
SX: 'ANG',
SY: 'SYP',
SZ: 'SZL',
TC: 'USD',
TD: 'XAF',
TF: 'EUR',
TG: 'XOF',
TH: 'THB',
TJ: 'TJS',
TK: 'NZD',
TL: 'USD',
TM: 'TMT',
TN: 'TND',
TO: 'TOP',
TR: 'TRY',
TT: 'TTD',
TV: 'AUD',
TW: 'TWD',
TZ: 'TZS',
UA: 'UAH',
UG: 'UGX',
UM: 'USD',
US: 'USD',
UY: 'UYU',
UZ: 'UZS',
VA: 'EUR',
VC: 'XCD',
VE: 'VEF',
VG: 'USD',
VI: 'USD',
VN: 'VND',
VU: 'VUV',
WF: 'XPF',
WS: 'WST',
YE: 'YER',
YT: 'EUR',
ZA: 'ZAR',
ZM: 'ZMK',
ZW: 'ZWL'
};

module.exports = map;
      };
    };
  }
  }
}, {package:"currency-formatter>locale-currency",file:"node_modules\\locale-currency\\map.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_apply.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_apply.js
      return function (require, module, exports) {
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_apply.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_arrayAggregator.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_arrayAggregator.js
      return function (require, module, exports) {
/**
 * A specialized version of `baseAggregator` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function arrayAggregator(array, setter, iteratee, accumulator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    var value = array[index];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}

module.exports = arrayAggregator;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_arrayAggregator.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_arrayIncludes.js", {"./_baseIndexOf":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseIndexOf.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_arrayIncludes.js
      return function (require, module, exports) {
var baseIndexOf = require('./_baseIndexOf');

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_arrayIncludes.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_arrayIncludesWith.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_arrayIncludesWith.js
      return function (require, module, exports) {
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_arrayIncludesWith.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseAggregator.js", {"./_baseEach":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseEach.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_baseAggregator.js
      return function (require, module, exports) {
var baseEach = require('./_baseEach');

/**
 * Aggregates elements of `collection` on `accumulator` with keys transformed
 * by `iteratee` and values set by `setter`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function baseAggregator(collection, setter, iteratee, accumulator) {
  baseEach(collection, function(value, key, collection) {
    setter(accumulator, value, iteratee(value), collection);
  });
  return accumulator;
}

module.exports = baseAggregator;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseAggregator.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseDifference.js", {"./_SetCache":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_SetCache.js","./_arrayIncludes":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_arrayIncludes.js","./_arrayIncludesWith":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_arrayIncludesWith.js","./_arrayMap":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_arrayMap.js","./_baseUnary":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseUnary.js","./_cacheHas":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_cacheHas.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_baseDifference.js
      return function (require, module, exports) {
var SetCache = require('./_SetCache'),
    arrayIncludes = require('./_arrayIncludes'),
    arrayIncludesWith = require('./_arrayIncludesWith'),
    arrayMap = require('./_arrayMap'),
    baseUnary = require('./_baseUnary'),
    cacheHas = require('./_cacheHas');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee == null ? value : iteratee(value);

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

module.exports = baseDifference;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseDifference.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseEach.js", {"./_baseForOwn":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseForOwn.js","./_createBaseEach":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_createBaseEach.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_baseEach.js
      return function (require, module, exports) {
var baseForOwn = require('./_baseForOwn'),
    createBaseEach = require('./_createBaseEach');

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseEach.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseFindIndex.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_baseFindIndex.js
      return function (require, module, exports) {
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseFindIndex.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseFlatten.js", {"./_arrayPush":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_arrayPush.js","./_isFlattenable":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_isFlattenable.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_baseFlatten.js
      return function (require, module, exports) {
var arrayPush = require('./_arrayPush'),
    isFlattenable = require('./_isFlattenable');

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseFlatten.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseIndexOf.js", {"./_baseFindIndex":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseFindIndex.js","./_baseIsNaN":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseIsNaN.js","./_strictIndexOf":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_strictIndexOf.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_baseIndexOf.js
      return function (require, module, exports) {
var baseFindIndex = require('./_baseFindIndex'),
    baseIsNaN = require('./_baseIsNaN'),
    strictIndexOf = require('./_strictIndexOf');

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseIndexOf.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseIsNaN.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_baseIsNaN.js
      return function (require, module, exports) {
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseIsNaN.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseRest.js", {"./_overRest":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_overRest.js","./_setToString":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_setToString.js","./identity":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\identity.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_baseRest.js
      return function (require, module, exports) {
var identity = require('./identity'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseRest.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseSetToString.js", {"./_defineProperty":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_defineProperty.js","./constant":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\constant.js","./identity":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\identity.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_baseSetToString.js
      return function (require, module, exports) {
var constant = require('./constant'),
    defineProperty = require('./_defineProperty'),
    identity = require('./identity');

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseSetToString.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseSum.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_baseSum.js
      return function (require, module, exports) {
/**
 * The base implementation of `_.sum` and `_.sumBy` without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {number} Returns the sum.
 */
function baseSum(array, iteratee) {
  var result,
      index = -1,
      length = array.length;

  while (++index < length) {
    var current = iteratee(array[index]);
    if (current !== undefined) {
      result = result === undefined ? current : (result + current);
    }
  }
  return result;
}

module.exports = baseSum;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseSum.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseUniq.js", {"./_SetCache":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_SetCache.js","./_arrayIncludes":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_arrayIncludes.js","./_arrayIncludesWith":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_arrayIncludesWith.js","./_cacheHas":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_cacheHas.js","./_createSet":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_createSet.js","./_setToArray":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_setToArray.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_baseUniq.js
      return function (require, module, exports) {
var SetCache = require('./_SetCache'),
    arrayIncludes = require('./_arrayIncludes'),
    arrayIncludesWith = require('./_arrayIncludesWith'),
    cacheHas = require('./_cacheHas'),
    createSet = require('./_createSet'),
    setToArray = require('./_setToArray');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseUniq.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_createAggregator.js", {"./_arrayAggregator":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_arrayAggregator.js","./_baseAggregator":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseAggregator.js","./_baseIteratee":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseIteratee.js","./isArray":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\isArray.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_createAggregator.js
      return function (require, module, exports) {
var arrayAggregator = require('./_arrayAggregator'),
    baseAggregator = require('./_baseAggregator'),
    baseIteratee = require('./_baseIteratee'),
    isArray = require('./isArray');

/**
 * Creates a function like `_.groupBy`.
 *
 * @private
 * @param {Function} setter The function to set accumulator values.
 * @param {Function} [initializer] The accumulator object initializer.
 * @returns {Function} Returns the new aggregator function.
 */
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray(collection) ? arrayAggregator : baseAggregator,
        accumulator = initializer ? initializer() : {};

    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
  };
}

module.exports = createAggregator;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_createAggregator.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_createBaseEach.js", {"./isArrayLike":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\isArrayLike.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_createBaseEach.js
      return function (require, module, exports) {
var isArrayLike = require('./isArrayLike');

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_createBaseEach.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_createSet.js", {"./_Set":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_Set.js","./_setToArray":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_setToArray.js","./noop":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\noop.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_createSet.js
      return function (require, module, exports) {
var Set = require('./_Set'),
    noop = require('./noop'),
    setToArray = require('./_setToArray');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

module.exports = createSet;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_createSet.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_isFlattenable.js", {"./_Symbol":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_Symbol.js","./isArguments":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\isArguments.js","./isArray":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\isArray.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_isFlattenable.js
      return function (require, module, exports) {
var Symbol = require('./_Symbol'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray');

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_isFlattenable.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_overRest.js", {"./_apply":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_apply.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_overRest.js
      return function (require, module, exports) {
var apply = require('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_overRest.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_setToString.js", {"./_baseSetToString":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseSetToString.js","./_shortOut":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_shortOut.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_setToString.js
      return function (require, module, exports) {
var baseSetToString = require('./_baseSetToString'),
    shortOut = require('./_shortOut');

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_setToString.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_shortOut.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_shortOut.js
      return function (require, module, exports) {
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_shortOut.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_strictIndexOf.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5C_strictIndexOf.js
      return function (require, module, exports) {
/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_strictIndexOf.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\constant.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5Cconstant.js
      return function (require, module, exports) {
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\constant.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\difference.js", {"./_baseDifference":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseDifference.js","./_baseFlatten":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseFlatten.js","./_baseRest":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseRest.js","./isArrayLikeObject":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\isArrayLikeObject.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5Cdifference.js
      return function (require, module, exports) {
var baseDifference = require('./_baseDifference'),
    baseFlatten = require('./_baseFlatten'),
    baseRest = require('./_baseRest'),
    isArrayLikeObject = require('./isArrayLikeObject');

/**
 * Creates an array of `array` values not included in the other given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * **Note:** Unlike `_.pullAll`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.without, _.xor
 * @example
 *
 * _.difference([2, 1], [2, 3]);
 * // => [1]
 */
var difference = baseRest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
    : [];
});

module.exports = difference;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\difference.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\escapeRegExp.js", {"./toString":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\toString.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5CescapeRegExp.js
      return function (require, module, exports) {
var toString = require('./toString');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
    reHasRegExpChar = RegExp(reRegExpChar.source);

/**
 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https://lodash\.com/\)'
 */
function escapeRegExp(string) {
  string = toString(string);
  return (string && reHasRegExpChar.test(string))
    ? string.replace(reRegExpChar, '\\$&')
    : string;
}

module.exports = escapeRegExp;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\escapeRegExp.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\isArrayLikeObject.js", {"./isArrayLike":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\isArrayLike.js","./isObjectLike":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\isObjectLike.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5CisArrayLikeObject.js
      return function (require, module, exports) {
var isArrayLike = require('./isArrayLike'),
    isObjectLike = require('./isObjectLike');

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\isArrayLikeObject.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\isBoolean.js", {"./_baseGetTag":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseGetTag.js","./isObjectLike":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\isObjectLike.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5CisBoolean.js
      return function (require, module, exports) {
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]';

/**
 * Checks if `value` is classified as a boolean primitive or object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
 * @example
 *
 * _.isBoolean(false);
 * // => true
 *
 * _.isBoolean(null);
 * // => false
 */
function isBoolean(value) {
  return value === true || value === false ||
    (isObjectLike(value) && baseGetTag(value) == boolTag);
}

module.exports = isBoolean;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\isBoolean.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\isEqual.js", {"./_baseIsEqual":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseIsEqual.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5CisEqual.js
      return function (require, module, exports) {
var baseIsEqual = require('./_baseIsEqual');

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\isEqual.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\isNumber.js", {"./_baseGetTag":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseGetTag.js","./isObjectLike":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\isObjectLike.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5CisNumber.js
      return function (require, module, exports) {
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' ||
    (isObjectLike(value) && baseGetTag(value) == numberTag);
}

module.exports = isNumber;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\isNumber.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\isPlainObject.js", {"./_baseGetTag":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseGetTag.js","./_getPrototype":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_getPrototype.js","./isObjectLike":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\isObjectLike.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5CisPlainObject.js
      return function (require, module, exports) {
var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\isPlainObject.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\isString.js", {"./_baseGetTag":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseGetTag.js","./isArray":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\isArray.js","./isObjectLike":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\isObjectLike.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5CisString.js
      return function (require, module, exports) {
var baseGetTag = require('./_baseGetTag'),
    isArray = require('./isArray'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\isString.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\noop.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5Cnoop.js
      return function (require, module, exports) {
/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\noop.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\partition.js", {"./_createAggregator":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_createAggregator.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5Cpartition.js
      return function (require, module, exports) {
var createAggregator = require('./_createAggregator');

/**
 * Creates an array of elements split into two groups, the first of which
 * contains elements `predicate` returns truthy for, the second of which
 * contains elements `predicate` returns falsey for. The predicate is
 * invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the array of grouped elements.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': false },
 *   { 'user': 'fred',    'age': 40, 'active': true },
 *   { 'user': 'pebbles', 'age': 1,  'active': false }
 * ];
 *
 * _.partition(users, function(o) { return o.active; });
 * // => objects for [['fred'], ['barney', 'pebbles']]
 *
 * // The `_.matches` iteratee shorthand.
 * _.partition(users, { 'age': 1, 'active': false });
 * // => objects for [['pebbles'], ['barney', 'fred']]
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.partition(users, ['active', false]);
 * // => objects for [['barney', 'pebbles'], ['fred']]
 *
 * // The `_.property` iteratee shorthand.
 * _.partition(users, 'active');
 * // => objects for [['fred'], ['barney', 'pebbles']]
 */
var partition = createAggregator(function(result, value, key) {
  result[key ? 0 : 1].push(value);
}, function() { return [[], []]; });

module.exports = partition;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\partition.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\sum.js", {"./_baseSum":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseSum.js","./identity":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\identity.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5Csum.js
      return function (require, module, exports) {
var baseSum = require('./_baseSum'),
    identity = require('./identity');

/**
 * Computes the sum of the values in `array`.
 *
 * @static
 * @memberOf _
 * @since 3.4.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {number} Returns the sum.
 * @example
 *
 * _.sum([4, 2, 8, 6]);
 * // => 20
 */
function sum(array) {
  return (array && array.length)
    ? baseSum(array, identity)
    : 0;
}

module.exports = sum;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\sum.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\union.js", {"./_baseFlatten":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseFlatten.js","./_baseRest":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseRest.js","./_baseUniq":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\_baseUniq.js","./isArrayLikeObject":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lodash\\isArrayLikeObject.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clodash%5Cunion.js
      return function (require, module, exports) {
var baseFlatten = require('./_baseFlatten'),
    baseRest = require('./_baseRest'),
    baseUniq = require('./_baseUniq'),
    isArrayLikeObject = require('./isArrayLikeObject');

/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */
var union = baseRest(function(arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});

module.exports = union;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\union.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lower-case-first\\lower-case-first.js", {"lower-case":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lower-case\\lower-case.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clower-case-first%5Clower-case-first.js
      return function (require, module, exports) {
var lowerCase = require('lower-case')

/**
 * Lower case the first character of a string.
 *
 * @param  {String} str
 * @return {String}
 */
module.exports = function (str, locale) {
  if (str == null) {
    return ''
  }

  str = String(str)

  return lowerCase(str.charAt(0), locale) + str.substr(1)
}

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>lower-case-first",file:"node_modules\\lower-case-first\\lower-case-first.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lower-case\\lower-case.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Clower-case%5Clower-case.js
      return function (require, module, exports) {
/**
 * Special language-specific overrides.
 *
 * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt
 *
 * @type {Object}
 */
var LANGUAGES = {
  tr: {
    regexp: /\u0130|\u0049|\u0049\u0307/g,
    map: {
      '\u0130': '\u0069',
      '\u0049': '\u0131',
      '\u0049\u0307': '\u0069'
    }
  },
  az: {
    regexp: /[\u0130]/g,
    map: {
      '\u0130': '\u0069',
      '\u0049': '\u0131',
      '\u0049\u0307': '\u0069'
    }
  },
  lt: {
    regexp: /[\u0049\u004A\u012E\u00CC\u00CD\u0128]/g,
    map: {
      '\u0049': '\u0069\u0307',
      '\u004A': '\u006A\u0307',
      '\u012E': '\u012F\u0307',
      '\u00CC': '\u0069\u0307\u0300',
      '\u00CD': '\u0069\u0307\u0301',
      '\u0128': '\u0069\u0307\u0303'
    }
  }
}

/**
 * Lowercase a string.
 *
 * @param  {String} str
 * @return {String}
 */
module.exports = function (str, locale) {
  var lang = LANGUAGES[locale]

  str = str == null ? '' : String(str)

  if (lang) {
    str = str.replace(lang.regexp, function (m) { return lang.map[m] })
  }

  return str.toLowerCase()
}

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>lower-case",file:"node_modules\\lower-case\\lower-case.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\mersenne-twister\\src\\mersenne-twister.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cmersenne-twister%5Csrc%5Cmersenne-twister.js
      return function (require, module, exports) {
/*
  https://github.com/banksean wrapped Makoto Matsumoto and Takuji Nishimura's code in a namespace
  so it's better encapsulated. Now you can have multiple random number generators
  and they won't stomp all over eachother's state.

  If you want to use this as a substitute for Math.random(), use the random()
  method like so:

  var m = new MersenneTwister();
  var randomNumber = m.random();

  You can also call the other genrand_{foo}() methods on the instance.

  If you want to use a specific seed in order to get a repeatable random
  sequence, pass an integer into the constructor:

  var m = new MersenneTwister(123);

  and that will always produce the same random sequence.

  Sean McCullough (banksean@gmail.com)
*/

/*
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.

   Before using, initialize the state by using init_seed(seed)
   or init_by_array(init_key, key_length).

   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote
        products derived from this software without specific prior written
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


   Any feedback is very welcome.
   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
*/

var MersenneTwister = function(seed) {
	if (seed == undefined) {
		seed = new Date().getTime();
	}

	/* Period parameters */
	this.N = 624;
	this.M = 397;
	this.MATRIX_A = 0x9908b0df;   /* constant vector a */
	this.UPPER_MASK = 0x80000000; /* most significant w-r bits */
	this.LOWER_MASK = 0x7fffffff; /* least significant r bits */

	this.mt = new Array(this.N); /* the array for the state vector */
	this.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */

	if (seed.constructor == Array) {
		this.init_by_array(seed, seed.length);
	}
	else {
		this.init_seed(seed);
	}
}

/* initializes mt[N] with a seed */
/* origin name init_genrand */
MersenneTwister.prototype.init_seed = function(s) {
	this.mt[0] = s >>> 0;
	for (this.mti=1; this.mti<this.N; this.mti++) {
		var s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30);
		this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)
		+ this.mti;
		/* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
		/* In the previous versions, MSBs of the seed affect   */
		/* only MSBs of the array mt[].                        */
		/* 2002/01/09 modified by Makoto Matsumoto             */
		this.mt[this.mti] >>>= 0;
		/* for >32 bit machines */
	}
}

/* initialize by an array with array-length */
/* init_key is the array for initializing keys */
/* key_length is its length */
/* slight change for C++, 2004/2/26 */
MersenneTwister.prototype.init_by_array = function(init_key, key_length) {
	var i, j, k;
	this.init_seed(19650218);
	i=1; j=0;
	k = (this.N>key_length ? this.N : key_length);
	for (; k; k--) {
		var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30)
		this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))
		+ init_key[j] + j; /* non linear */
		this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
		i++; j++;
		if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
		if (j>=key_length) j=0;
	}
	for (k=this.N-1; k; k--) {
		var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);
		this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))
		- i; /* non linear */
		this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
		i++;
		if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
	}

	this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */
}

/* generates a random number on [0,0xffffffff]-interval */
/* origin name genrand_int32 */
MersenneTwister.prototype.random_int = function() {
	var y;
	var mag01 = new Array(0x0, this.MATRIX_A);
	/* mag01[x] = x * MATRIX_A  for x=0,1 */

	if (this.mti >= this.N) { /* generate N words at one time */
		var kk;

		if (this.mti == this.N+1)  /* if init_seed() has not been called, */
			this.init_seed(5489);  /* a default initial seed is used */

		for (kk=0;kk<this.N-this.M;kk++) {
			y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
			this.mt[kk] = this.mt[kk+this.M] ^ (y >>> 1) ^ mag01[y & 0x1];
		}
		for (;kk<this.N-1;kk++) {
			y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
			this.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];
		}
		y = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);
		this.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];

		this.mti = 0;
	}

	y = this.mt[this.mti++];

	/* Tempering */
	y ^= (y >>> 11);
	y ^= (y << 7) & 0x9d2c5680;
	y ^= (y << 15) & 0xefc60000;
	y ^= (y >>> 18);

	return y >>> 0;
}

/* generates a random number on [0,0x7fffffff]-interval */
/* origin name genrand_int31 */
MersenneTwister.prototype.random_int31 = function() {
	return (this.random_int()>>>1);
}

/* generates a random number on [0,1]-real-interval */
/* origin name genrand_real1 */
MersenneTwister.prototype.random_incl = function() {
	return this.random_int()*(1.0/4294967295.0);
	/* divided by 2^32-1 */
}

/* generates a random number on [0,1)-real-interval */
MersenneTwister.prototype.random = function() {
	return this.random_int()*(1.0/4294967296.0);
	/* divided by 2^32 */
}

/* generates a random number on (0,1)-real-interval */
/* origin name genrand_real3 */
MersenneTwister.prototype.random_excl = function() {
	return (this.random_int() + 0.5)*(1.0/4294967296.0);
	/* divided by 2^32 */
}

/* generates a random number on [0,1) with 53-bit resolution*/
/* origin name genrand_res53 */
MersenneTwister.prototype.random_long = function() {
	var a=this.random_int()>>>5, b=this.random_int()>>>6;
	return(a*67108864.0+b)*(1.0/9007199254740992.0);
}

/* These real versions are due to Isaku Wada, 2002/01/09 added */

module.exports = MersenneTwister;

      };
    };
  }
  }
}, {package:"@metamask/jazzicon>mersenne-twister",file:"node_modules\\mersenne-twister\\src\\mersenne-twister.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\mini-create-react-context\\dist\\cjs\\index.js", {"@babel/runtime/helpers/inheritsLoose":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@babel\\runtime\\helpers\\inheritsLoose.js","gud":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\gud\\index.js","prop-types":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\prop-types\\index.js","react":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\react\\index.js","tiny-warning":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\tiny-warning\\dist\\tiny-warning.cjs.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cmini-create-react-context%5Cdist%5Ccjs%5Cindex.js
      return function (require, module, exports) {
'use strict';function _interopDefault(e){return(e&&(typeof e==='object')&&'default'in e)?e['default']:e}var React=require('react'),React__default=_interopDefault(React),_inheritsLoose=_interopDefault(require('@babel/runtime/helpers/inheritsLoose')),PropTypes=_interopDefault(require('prop-types')),gud=_interopDefault(require('gud')),warning=_interopDefault(require('tiny-warning'));var MAX_SIGNED_31_BIT_INT = 1073741823;

function objectIs(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function (h) {
        return h !== handler;
      });
    },
    get: function get() {
      return value;
    },
    set: function set(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function (handler) {
        return handler(value, changedBits);
      });
    }
  };
}

function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}

function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;

  var contextProp = '__create-react-context-' + gud() + '__';

  var Provider =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(Provider, _Component);

    function Provider() {
      var _this;

      _this = _Component.apply(this, arguments) || this;
      _this.emitter = createEventEmitter(_this.props.value);
      return _this;
    }

    var _proto = Provider.prototype;

    _proto.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };

    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits;

        if (objectIs(oldValue, newValue)) {
          changedBits = 0;
        } else {
          changedBits = typeof calculateChangedBits === 'function' ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;

          if ("development" !== 'production') {
            warning((changedBits & MAX_SIGNED_31_BIT_INT) === changedBits, 'calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: ' + changedBits);
          }

          changedBits |= 0;

          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };

    _proto.render = function render() {
      return this.props.children;
    };

    return Provider;
  }(React.Component);

  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = PropTypes.object.isRequired, _Provider$childContex);

  var Consumer =
  /*#__PURE__*/
  function (_Component2) {
    _inheritsLoose(Consumer, _Component2);

    function Consumer() {
      var _this2;

      _this2 = _Component2.apply(this, arguments) || this;
      _this2.state = {
        value: _this2.getValue()
      };

      _this2.onUpdate = function (newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;

        if ((observedBits & changedBits) !== 0) {
          _this2.setState({
            value: _this2.getValue()
          });
        }
      };

      return _this2;
    }

    var _proto2 = Consumer.prototype;

    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;
      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };

    _proto2.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }

      var observedBits = this.props.observedBits;
      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };

    _proto2.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };

    _proto2.getValue = function getValue() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };

    _proto2.render = function render() {
      return onlyChild(this.props.children)(this.state.value);
    };

    return Consumer;
  }(React.Component);

  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = PropTypes.object, _Consumer$contextType);
  return {
    Provider: Provider,
    Consumer: Consumer
  };
}var index = React__default.createContext || createReactContext;module.exports=index;
      };
    };
  }
  }
}, {package:"react-router-dom>react-router>mini-create-react-context",file:"node_modules\\mini-create-react-context\\dist\\cjs\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\multihashes\\node_modules\\multibase\\src\\base.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cbase.js
      return function (require, module, exports) {
'use strict'

class Base {
  constructor (name, code, implementation, alphabet) {
    this.name = name
    this.code = code
    this.alphabet = alphabet
    if (implementation && alphabet) {
      this.engine = implementation(alphabet)
    }
  }

  encode (stringOrBuffer) {
    return this.engine.encode(stringOrBuffer)
  }

  decode (stringOrBuffer) {
    return this.engine.decode(stringOrBuffer)
  }

  isImplemented () {
    return this.engine
  }
}

module.exports = Base

      };
    };
  }
  }
}, {package:"@truffle/decoder>@truffle/encoder>@ensdomains/ensjs>content-hash>multihashes>multibase",file:"node_modules\\multihashes\\node_modules\\multibase\\src\\base.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\multihashes\\node_modules\\multibase\\src\\base16.js", {"buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cbase16.js
      return function (require, module, exports) {
'use strict'
const { Buffer } = require('buffer')

module.exports = function base16 (alphabet) {
  return {
    encode (input) {
      if (typeof input === 'string') {
        return Buffer.from(input).toString('hex')
      }
      return input.toString('hex')
    },
    decode (input) {
      for (const char of input) {
        if (alphabet.indexOf(char) < 0) {
          throw new Error('invalid base16 character')
        }
      }
      return Buffer.from(input, 'hex')
    }
  }
}

      };
    };
  }
  }
}, {package:"@truffle/decoder>@truffle/encoder>@ensdomains/ensjs>content-hash>multihashes>multibase",file:"node_modules\\multihashes\\node_modules\\multibase\\src\\base16.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\multihashes\\node_modules\\multibase\\src\\base32.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cbase32.js
      return function (require, module, exports) {
'use strict'

function decode (input, alphabet) {
  input = input.replace(new RegExp('=', 'g'), '')
  const length = input.length

  let bits = 0
  let value = 0

  let index = 0
  const output = new Uint8Array((length * 5 / 8) | 0)

  for (let i = 0; i < length; i++) {
    value = (value << 5) | alphabet.indexOf(input[i])
    bits += 5

    if (bits >= 8) {
      output[index++] = (value >>> (bits - 8)) & 255
      bits -= 8
    }
  }

  return output.buffer
}

function encode (buffer, alphabet) {
  const length = buffer.byteLength
  const view = new Uint8Array(buffer)
  const padding = alphabet.indexOf('=') === alphabet.length - 1

  if (padding) {
    alphabet = alphabet.substring(0, alphabet.length - 1)
  }

  let bits = 0
  let value = 0
  let output = ''

  for (let i = 0; i < length; i++) {
    value = (value << 8) | view[i]
    bits += 8

    while (bits >= 5) {
      output += alphabet[(value >>> (bits - 5)) & 31]
      bits -= 5
    }
  }

  if (bits > 0) {
    output += alphabet[(value << (5 - bits)) & 31]
  }

  if (padding) {
    while ((output.length % 8) !== 0) {
      output += '='
    }
  }

  return output
}

module.exports = function base32 (alphabet) {
  return {
    encode (input) {
      if (typeof input === 'string') {
        return encode(Uint8Array.from(input), alphabet)
      }

      return encode(input, alphabet)
    },
    decode (input) {
      for (const char of input) {
        if (alphabet.indexOf(char) < 0) {
          throw new Error('invalid base32 character')
        }
      }

      return decode(input, alphabet)
    }
  }
}

      };
    };
  }
  }
}, {package:"@truffle/decoder>@truffle/encoder>@ensdomains/ensjs>content-hash>multihashes>multibase",file:"node_modules\\multihashes\\node_modules\\multibase\\src\\base32.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\multihashes\\node_modules\\multibase\\src\\base64.js", {"buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cbase64.js
      return function (require, module, exports) {
'use strict'
const { Buffer } = require('buffer')

module.exports = function base64 (alphabet) {
  // The alphabet is only used to know:
  //   1. If padding is enabled (must contain '=')
  //   2. If the output must be url-safe (must contain '-' and '_')
  //   3. If the input of the output function is valid
  // The alphabets from RFC 4648 are always used.
  const padding = alphabet.indexOf('=') > -1
  const url = alphabet.indexOf('-') > -1 && alphabet.indexOf('_') > -1

  return {
    encode (input) {
      let output = ''

      if (typeof input === 'string') {
        output = Buffer.from(input).toString('base64')
      } else {
        output = input.toString('base64')
      }

      if (url) {
        output = output.replace(/\+/g, '-').replace(/\//g, '_')
      }

      const pad = output.indexOf('=')
      if (pad > 0 && !padding) {
        output = output.substring(0, pad)
      }

      return output
    },
    decode (input) {
      for (const char of input) {
        if (alphabet.indexOf(char) < 0) {
          throw new Error('invalid base64 character')
        }
      }

      return Buffer.from(input, 'base64')
    }
  }
}

      };
    };
  }
  }
}, {package:"@truffle/decoder>@truffle/encoder>@ensdomains/ensjs>content-hash>multihashes>multibase",file:"node_modules\\multihashes\\node_modules\\multibase\\src\\base64.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\multihashes\\node_modules\\multibase\\src\\constants.js", {"./base.js":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\multihashes\\node_modules\\multibase\\src\\base.js","./base16":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\multihashes\\node_modules\\multibase\\src\\base16.js","./base32":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\multihashes\\node_modules\\multibase\\src\\base32.js","./base64":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\multihashes\\node_modules\\multibase\\src\\base64.js","base-x":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\base-x\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cconstants.js
      return function (require, module, exports) {
'use strict'

const Base = require('./base.js')
const baseX = require('base-x')
const base16 = require('./base16')
const base32 = require('./base32')
const base64 = require('./base64')

// name, code, implementation, alphabet
const constants = [
  ['base1', '1', '', '1'],
  ['base2', '0', baseX, '01'],
  ['base8', '7', baseX, '01234567'],
  ['base10', '9', baseX, '0123456789'],
  ['base16', 'f', base16, '0123456789abcdef'],
  ['base32', 'b', base32, 'abcdefghijklmnopqrstuvwxyz234567'],
  ['base32pad', 'c', base32, 'abcdefghijklmnopqrstuvwxyz234567='],
  ['base32hex', 'v', base32, '0123456789abcdefghijklmnopqrstuv'],
  ['base32hexpad', 't', base32, '0123456789abcdefghijklmnopqrstuv='],
  ['base32z', 'h', base32, 'ybndrfg8ejkmcpqxot1uwisza345h769'],
  ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
  ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
  ['base64', 'm', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
  ['base64pad', 'M', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
  ['base64url', 'u', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
  ['base64urlpad', 'U', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
]

const names = constants.reduce((prev, tupple) => {
  prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])
  return prev
}, {})

const codes = constants.reduce((prev, tupple) => {
  prev[tupple[1]] = names[tupple[0]]
  return prev
}, {})

module.exports = {
  names: names,
  codes: codes
}

      };
    };
  }
  }
}, {package:"@truffle/decoder>@truffle/encoder>@ensdomains/ensjs>content-hash>multihashes>multibase",file:"node_modules\\multihashes\\node_modules\\multibase\\src\\constants.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\multihashes\\node_modules\\multibase\\src\\index.js", {"./constants":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\multihashes\\node_modules\\multibase\\src\\constants.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cindex.js
      return function (require, module, exports) {
/**
 * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
 * @module Multibase
 */
'use strict'

const { Buffer } = require('buffer')
const constants = require('./constants')

exports = module.exports = multibase
exports.encode = encode
exports.decode = decode
exports.isEncoded = isEncoded
exports.names = Object.freeze(Object.keys(constants.names))
exports.codes = Object.freeze(Object.keys(constants.codes))

/**
 * Create a new buffer with the multibase varint+code.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Buffer} buf - The data to be prefixed with multibase.
 * @memberof Multibase
 * @returns {Buffer}
 */
function multibase (nameOrCode, buf) {
  if (!buf) {
    throw new Error('requires an encoded buffer')
  }
  const base = getBase(nameOrCode)
  const codeBuf = Buffer.from(base.code)

  const name = base.name
  validEncode(name, buf)
  return Buffer.concat([codeBuf, buf])
}

/**
 * Encode data with the specified base and add the multibase prefix.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Buffer} buf - The data to be encoded.
 * @returns {Buffer}
 * @memberof Multibase
 */
function encode (nameOrCode, buf) {
  const base = getBase(nameOrCode)
  const name = base.name

  return multibase(name, Buffer.from(base.encode(buf)))
}

/**
 * Takes a buffer or string encoded with multibase header, decodes it and
 * returns the decoded buffer
 *
 * @param {Buffer|string} bufOrString
 * @returns {Buffer}
 * @memberof Multibase
 *
 */
function decode (bufOrString) {
  if (Buffer.isBuffer(bufOrString)) {
    bufOrString = bufOrString.toString()
  }

  const code = bufOrString.substring(0, 1)
  bufOrString = bufOrString.substring(1, bufOrString.length)

  if (typeof bufOrString === 'string') {
    bufOrString = Buffer.from(bufOrString)
  }

  const base = getBase(code)
  return Buffer.from(base.decode(bufOrString.toString()))
}

/**
 * Is the given data multibase encoded?
 *
 * @param {Buffer|string} bufOrString
 * @returns {boolean}
 * @memberof Multibase
 */
function isEncoded (bufOrString) {
  if (Buffer.isBuffer(bufOrString)) {
    bufOrString = bufOrString.toString()
  }

  // Ensure bufOrString is a string
  if (Object.prototype.toString.call(bufOrString) !== '[object String]') {
    return false
  }

  const code = bufOrString.substring(0, 1)
  try {
    const base = getBase(code)
    return base.name
  } catch (err) {
    return false
  }
}

/**
 * @param {string} name
 * @param {Buffer} buf
 * @private
 * @returns {undefined}
 */
function validEncode (name, buf) {
  const base = getBase(name)
  base.decode(buf.toString())
}

function getBase (nameOrCode) {
  let base

  if (constants.names[nameOrCode]) {
    base = constants.names[nameOrCode]
  } else if (constants.codes[nameOrCode]) {
    base = constants.codes[nameOrCode]
  } else {
    throw new Error('Unsupported encoding')
  }

  if (!base.isImplemented()) {
    throw new Error('Base ' + nameOrCode + ' is not implemented yet')
  }

  return base
}

      };
    };
  }
  }
}, {package:"@truffle/decoder>@truffle/encoder>@ensdomains/ensjs>content-hash>multihashes>multibase",file:"node_modules\\multihashes\\node_modules\\multibase\\src\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\multihashes\\src\\constants.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cmultihashes%5Csrc%5Cconstants.js
      return function (require, module, exports) {
/* eslint quote-props: off */
/* eslint key-spacing: off */
'use strict'

exports.names = Object.freeze({
  'identity':   0x0,
  'sha1':       0x11,
  'sha2-256':   0x12,
  'sha2-512':   0x13,
  'dbl-sha2-256': 0x56,
  'sha3-224':   0x17,
  'sha3-256':   0x16,
  'sha3-384':   0x15,
  'sha3-512':   0x14,
  'shake-128':  0x18,
  'shake-256':  0x19,
  'keccak-224': 0x1A,
  'keccak-256': 0x1B,
  'keccak-384': 0x1C,
  'keccak-512': 0x1D,
  'murmur3-128': 0x22,
  'murmur3-32':  0x23,
  'md4':         0xd4,
  'md5':         0xd5,
  'blake2b-8':   0xb201,
  'blake2b-16':  0xb202,
  'blake2b-24':  0xb203,
  'blake2b-32':  0xb204,
  'blake2b-40':  0xb205,
  'blake2b-48':  0xb206,
  'blake2b-56':  0xb207,
  'blake2b-64':  0xb208,
  'blake2b-72':  0xb209,
  'blake2b-80':  0xb20a,
  'blake2b-88':  0xb20b,
  'blake2b-96':  0xb20c,
  'blake2b-104': 0xb20d,
  'blake2b-112': 0xb20e,
  'blake2b-120': 0xb20f,
  'blake2b-128': 0xb210,
  'blake2b-136': 0xb211,
  'blake2b-144': 0xb212,
  'blake2b-152': 0xb213,
  'blake2b-160': 0xb214,
  'blake2b-168': 0xb215,
  'blake2b-176': 0xb216,
  'blake2b-184': 0xb217,
  'blake2b-192': 0xb218,
  'blake2b-200': 0xb219,
  'blake2b-208': 0xb21a,
  'blake2b-216': 0xb21b,
  'blake2b-224': 0xb21c,
  'blake2b-232': 0xb21d,
  'blake2b-240': 0xb21e,
  'blake2b-248': 0xb21f,
  'blake2b-256': 0xb220,
  'blake2b-264': 0xb221,
  'blake2b-272': 0xb222,
  'blake2b-280': 0xb223,
  'blake2b-288': 0xb224,
  'blake2b-296': 0xb225,
  'blake2b-304': 0xb226,
  'blake2b-312': 0xb227,
  'blake2b-320': 0xb228,
  'blake2b-328': 0xb229,
  'blake2b-336': 0xb22a,
  'blake2b-344': 0xb22b,
  'blake2b-352': 0xb22c,
  'blake2b-360': 0xb22d,
  'blake2b-368': 0xb22e,
  'blake2b-376': 0xb22f,
  'blake2b-384': 0xb230,
  'blake2b-392': 0xb231,
  'blake2b-400': 0xb232,
  'blake2b-408': 0xb233,
  'blake2b-416': 0xb234,
  'blake2b-424': 0xb235,
  'blake2b-432': 0xb236,
  'blake2b-440': 0xb237,
  'blake2b-448': 0xb238,
  'blake2b-456': 0xb239,
  'blake2b-464': 0xb23a,
  'blake2b-472': 0xb23b,
  'blake2b-480': 0xb23c,
  'blake2b-488': 0xb23d,
  'blake2b-496': 0xb23e,
  'blake2b-504': 0xb23f,
  'blake2b-512': 0xb240,
  'blake2s-8':   0xb241,
  'blake2s-16':  0xb242,
  'blake2s-24':  0xb243,
  'blake2s-32':  0xb244,
  'blake2s-40':  0xb245,
  'blake2s-48':  0xb246,
  'blake2s-56':  0xb247,
  'blake2s-64':  0xb248,
  'blake2s-72':  0xb249,
  'blake2s-80':  0xb24a,
  'blake2s-88':  0xb24b,
  'blake2s-96':  0xb24c,
  'blake2s-104': 0xb24d,
  'blake2s-112': 0xb24e,
  'blake2s-120': 0xb24f,
  'blake2s-128': 0xb250,
  'blake2s-136': 0xb251,
  'blake2s-144': 0xb252,
  'blake2s-152': 0xb253,
  'blake2s-160': 0xb254,
  'blake2s-168': 0xb255,
  'blake2s-176': 0xb256,
  'blake2s-184': 0xb257,
  'blake2s-192': 0xb258,
  'blake2s-200': 0xb259,
  'blake2s-208': 0xb25a,
  'blake2s-216': 0xb25b,
  'blake2s-224': 0xb25c,
  'blake2s-232': 0xb25d,
  'blake2s-240': 0xb25e,
  'blake2s-248': 0xb25f,
  'blake2s-256': 0xb260,
  'Skein256-8': 0xb301,
  'Skein256-16': 0xb302,
  'Skein256-24': 0xb303,
  'Skein256-32': 0xb304,
  'Skein256-40': 0xb305,
  'Skein256-48': 0xb306,
  'Skein256-56': 0xb307,
  'Skein256-64': 0xb308,
  'Skein256-72': 0xb309,
  'Skein256-80': 0xb30a,
  'Skein256-88': 0xb30b,
  'Skein256-96': 0xb30c,
  'Skein256-104': 0xb30d,
  'Skein256-112': 0xb30e,
  'Skein256-120': 0xb30f,
  'Skein256-128': 0xb310,
  'Skein256-136': 0xb311,
  'Skein256-144': 0xb312,
  'Skein256-152': 0xb313,
  'Skein256-160': 0xb314,
  'Skein256-168': 0xb315,
  'Skein256-176': 0xb316,
  'Skein256-184': 0xb317,
  'Skein256-192': 0xb318,
  'Skein256-200': 0xb319,
  'Skein256-208': 0xb31a,
  'Skein256-216': 0xb31b,
  'Skein256-224': 0xb31c,
  'Skein256-232': 0xb31d,
  'Skein256-240': 0xb31e,
  'Skein256-248': 0xb31f,
  'Skein256-256': 0xb320,
  'Skein512-8': 0xb321,
  'Skein512-16': 0xb322,
  'Skein512-24': 0xb323,
  'Skein512-32': 0xb324,
  'Skein512-40': 0xb325,
  'Skein512-48': 0xb326,
  'Skein512-56': 0xb327,
  'Skein512-64': 0xb328,
  'Skein512-72': 0xb329,
  'Skein512-80': 0xb32a,
  'Skein512-88': 0xb32b,
  'Skein512-96': 0xb32c,
  'Skein512-104': 0xb32d,
  'Skein512-112': 0xb32e,
  'Skein512-120': 0xb32f,
  'Skein512-128': 0xb330,
  'Skein512-136': 0xb331,
  'Skein512-144': 0xb332,
  'Skein512-152': 0xb333,
  'Skein512-160': 0xb334,
  'Skein512-168': 0xb335,
  'Skein512-176': 0xb336,
  'Skein512-184': 0xb337,
  'Skein512-192': 0xb338,
  'Skein512-200': 0xb339,
  'Skein512-208': 0xb33a,
  'Skein512-216': 0xb33b,
  'Skein512-224': 0xb33c,
  'Skein512-232': 0xb33d,
  'Skein512-240': 0xb33e,
  'Skein512-248': 0xb33f,
  'Skein512-256': 0xb340,
  'Skein512-264': 0xb341,
  'Skein512-272': 0xb342,
  'Skein512-280': 0xb343,
  'Skein512-288': 0xb344,
  'Skein512-296': 0xb345,
  'Skein512-304': 0xb346,
  'Skein512-312': 0xb347,
  'Skein512-320': 0xb348,
  'Skein512-328': 0xb349,
  'Skein512-336': 0xb34a,
  'Skein512-344': 0xb34b,
  'Skein512-352': 0xb34c,
  'Skein512-360': 0xb34d,
  'Skein512-368': 0xb34e,
  'Skein512-376': 0xb34f,
  'Skein512-384': 0xb350,
  'Skein512-392': 0xb351,
  'Skein512-400': 0xb352,
  'Skein512-408': 0xb353,
  'Skein512-416': 0xb354,
  'Skein512-424': 0xb355,
  'Skein512-432': 0xb356,
  'Skein512-440': 0xb357,
  'Skein512-448': 0xb358,
  'Skein512-456': 0xb359,
  'Skein512-464': 0xb35a,
  'Skein512-472': 0xb35b,
  'Skein512-480': 0xb35c,
  'Skein512-488': 0xb35d,
  'Skein512-496': 0xb35e,
  'Skein512-504': 0xb35f,
  'Skein512-512': 0xb360,
  'Skein1024-8': 0xb361,
  'Skein1024-16': 0xb362,
  'Skein1024-24': 0xb363,
  'Skein1024-32': 0xb364,
  'Skein1024-40': 0xb365,
  'Skein1024-48': 0xb366,
  'Skein1024-56': 0xb367,
  'Skein1024-64': 0xb368,
  'Skein1024-72': 0xb369,
  'Skein1024-80': 0xb36a,
  'Skein1024-88': 0xb36b,
  'Skein1024-96': 0xb36c,
  'Skein1024-104': 0xb36d,
  'Skein1024-112': 0xb36e,
  'Skein1024-120': 0xb36f,
  'Skein1024-128': 0xb370,
  'Skein1024-136': 0xb371,
  'Skein1024-144': 0xb372,
  'Skein1024-152': 0xb373,
  'Skein1024-160': 0xb374,
  'Skein1024-168': 0xb375,
  'Skein1024-176': 0xb376,
  'Skein1024-184': 0xb377,
  'Skein1024-192': 0xb378,
  'Skein1024-200': 0xb379,
  'Skein1024-208': 0xb37a,
  'Skein1024-216': 0xb37b,
  'Skein1024-224': 0xb37c,
  'Skein1024-232': 0xb37d,
  'Skein1024-240': 0xb37e,
  'Skein1024-248': 0xb37f,
  'Skein1024-256': 0xb380,
  'Skein1024-264': 0xb381,
  'Skein1024-272': 0xb382,
  'Skein1024-280': 0xb383,
  'Skein1024-288': 0xb384,
  'Skein1024-296': 0xb385,
  'Skein1024-304': 0xb386,
  'Skein1024-312': 0xb387,
  'Skein1024-320': 0xb388,
  'Skein1024-328': 0xb389,
  'Skein1024-336': 0xb38a,
  'Skein1024-344': 0xb38b,
  'Skein1024-352': 0xb38c,
  'Skein1024-360': 0xb38d,
  'Skein1024-368': 0xb38e,
  'Skein1024-376': 0xb38f,
  'Skein1024-384': 0xb390,
  'Skein1024-392': 0xb391,
  'Skein1024-400': 0xb392,
  'Skein1024-408': 0xb393,
  'Skein1024-416': 0xb394,
  'Skein1024-424': 0xb395,
  'Skein1024-432': 0xb396,
  'Skein1024-440': 0xb397,
  'Skein1024-448': 0xb398,
  'Skein1024-456': 0xb399,
  'Skein1024-464': 0xb39a,
  'Skein1024-472': 0xb39b,
  'Skein1024-480': 0xb39c,
  'Skein1024-488': 0xb39d,
  'Skein1024-496': 0xb39e,
  'Skein1024-504': 0xb39f,
  'Skein1024-512': 0xb3a0,
  'Skein1024-520': 0xb3a1,
  'Skein1024-528': 0xb3a2,
  'Skein1024-536': 0xb3a3,
  'Skein1024-544': 0xb3a4,
  'Skein1024-552': 0xb3a5,
  'Skein1024-560': 0xb3a6,
  'Skein1024-568': 0xb3a7,
  'Skein1024-576': 0xb3a8,
  'Skein1024-584': 0xb3a9,
  'Skein1024-592': 0xb3aa,
  'Skein1024-600': 0xb3ab,
  'Skein1024-608': 0xb3ac,
  'Skein1024-616': 0xb3ad,
  'Skein1024-624': 0xb3ae,
  'Skein1024-632': 0xb3af,
  'Skein1024-640': 0xb3b0,
  'Skein1024-648': 0xb3b1,
  'Skein1024-656': 0xb3b2,
  'Skein1024-664': 0xb3b3,
  'Skein1024-672': 0xb3b4,
  'Skein1024-680': 0xb3b5,
  'Skein1024-688': 0xb3b6,
  'Skein1024-696': 0xb3b7,
  'Skein1024-704': 0xb3b8,
  'Skein1024-712': 0xb3b9,
  'Skein1024-720': 0xb3ba,
  'Skein1024-728': 0xb3bb,
  'Skein1024-736': 0xb3bc,
  'Skein1024-744': 0xb3bd,
  'Skein1024-752': 0xb3be,
  'Skein1024-760': 0xb3bf,
  'Skein1024-768': 0xb3c0,
  'Skein1024-776': 0xb3c1,
  'Skein1024-784': 0xb3c2,
  'Skein1024-792': 0xb3c3,
  'Skein1024-800': 0xb3c4,
  'Skein1024-808': 0xb3c5,
  'Skein1024-816': 0xb3c6,
  'Skein1024-824': 0xb3c7,
  'Skein1024-832': 0xb3c8,
  'Skein1024-840': 0xb3c9,
  'Skein1024-848': 0xb3ca,
  'Skein1024-856': 0xb3cb,
  'Skein1024-864': 0xb3cc,
  'Skein1024-872': 0xb3cd,
  'Skein1024-880': 0xb3ce,
  'Skein1024-888': 0xb3cf,
  'Skein1024-896': 0xb3d0,
  'Skein1024-904': 0xb3d1,
  'Skein1024-912': 0xb3d2,
  'Skein1024-920': 0xb3d3,
  'Skein1024-928': 0xb3d4,
  'Skein1024-936': 0xb3d5,
  'Skein1024-944': 0xb3d6,
  'Skein1024-952': 0xb3d7,
  'Skein1024-960': 0xb3d8,
  'Skein1024-968': 0xb3d9,
  'Skein1024-976': 0xb3da,
  'Skein1024-984': 0xb3db,
  'Skein1024-992': 0xb3dc,
  'Skein1024-1000': 0xb3dd,
  'Skein1024-1008': 0xb3de,
  'Skein1024-1016': 0xb3df,
  'Skein1024-1024': 0xb3e0
})

exports.codes = Object.freeze({
  0x0: 'identity',

  // sha family
  0x11: 'sha1',
  0x12: 'sha2-256',
  0x13: 'sha2-512',
  0x56: 'dbl-sha2-256',
  0x17: 'sha3-224',
  0x16: 'sha3-256',
  0x15: 'sha3-384',
  0x14: 'sha3-512',
  0x18: 'shake-128',
  0x19: 'shake-256',
  0x1A: 'keccak-224',
  0x1B: 'keccak-256',
  0x1C: 'keccak-384',
  0x1D: 'keccak-512',

  0x22: 'murmur3-128',
  0x23: 'murmur3-32',

  0xd4: 'md4',
  0xd5: 'md5',

  // blake2
  0xb201: 'blake2b-8',
  0xb202: 'blake2b-16',
  0xb203: 'blake2b-24',
  0xb204: 'blake2b-32',
  0xb205: 'blake2b-40',
  0xb206: 'blake2b-48',
  0xb207: 'blake2b-56',
  0xb208: 'blake2b-64',
  0xb209: 'blake2b-72',
  0xb20a: 'blake2b-80',
  0xb20b: 'blake2b-88',
  0xb20c: 'blake2b-96',
  0xb20d: 'blake2b-104',
  0xb20e: 'blake2b-112',
  0xb20f: 'blake2b-120',
  0xb210: 'blake2b-128',
  0xb211: 'blake2b-136',
  0xb212: 'blake2b-144',
  0xb213: 'blake2b-152',
  0xb214: 'blake2b-160',
  0xb215: 'blake2b-168',
  0xb216: 'blake2b-176',
  0xb217: 'blake2b-184',
  0xb218: 'blake2b-192',
  0xb219: 'blake2b-200',
  0xb21a: 'blake2b-208',
  0xb21b: 'blake2b-216',
  0xb21c: 'blake2b-224',
  0xb21d: 'blake2b-232',
  0xb21e: 'blake2b-240',
  0xb21f: 'blake2b-248',
  0xb220: 'blake2b-256',
  0xb221: 'blake2b-264',
  0xb222: 'blake2b-272',
  0xb223: 'blake2b-280',
  0xb224: 'blake2b-288',
  0xb225: 'blake2b-296',
  0xb226: 'blake2b-304',
  0xb227: 'blake2b-312',
  0xb228: 'blake2b-320',
  0xb229: 'blake2b-328',
  0xb22a: 'blake2b-336',
  0xb22b: 'blake2b-344',
  0xb22c: 'blake2b-352',
  0xb22d: 'blake2b-360',
  0xb22e: 'blake2b-368',
  0xb22f: 'blake2b-376',
  0xb230: 'blake2b-384',
  0xb231: 'blake2b-392',
  0xb232: 'blake2b-400',
  0xb233: 'blake2b-408',
  0xb234: 'blake2b-416',
  0xb235: 'blake2b-424',
  0xb236: 'blake2b-432',
  0xb237: 'blake2b-440',
  0xb238: 'blake2b-448',
  0xb239: 'blake2b-456',
  0xb23a: 'blake2b-464',
  0xb23b: 'blake2b-472',
  0xb23c: 'blake2b-480',
  0xb23d: 'blake2b-488',
  0xb23e: 'blake2b-496',
  0xb23f: 'blake2b-504',
  0xb240: 'blake2b-512',
  0xb241: 'blake2s-8',
  0xb242: 'blake2s-16',
  0xb243: 'blake2s-24',
  0xb244: 'blake2s-32',
  0xb245: 'blake2s-40',
  0xb246: 'blake2s-48',
  0xb247: 'blake2s-56',
  0xb248: 'blake2s-64',
  0xb249: 'blake2s-72',
  0xb24a: 'blake2s-80',
  0xb24b: 'blake2s-88',
  0xb24c: 'blake2s-96',
  0xb24d: 'blake2s-104',
  0xb24e: 'blake2s-112',
  0xb24f: 'blake2s-120',
  0xb250: 'blake2s-128',
  0xb251: 'blake2s-136',
  0xb252: 'blake2s-144',
  0xb253: 'blake2s-152',
  0xb254: 'blake2s-160',
  0xb255: 'blake2s-168',
  0xb256: 'blake2s-176',
  0xb257: 'blake2s-184',
  0xb258: 'blake2s-192',
  0xb259: 'blake2s-200',
  0xb25a: 'blake2s-208',
  0xb25b: 'blake2s-216',
  0xb25c: 'blake2s-224',
  0xb25d: 'blake2s-232',
  0xb25e: 'blake2s-240',
  0xb25f: 'blake2s-248',
  0xb260: 'blake2s-256',

  // skein
  0xb301: 'Skein256-8',
  0xb302: 'Skein256-16',
  0xb303: 'Skein256-24',
  0xb304: 'Skein256-32',
  0xb305: 'Skein256-40',
  0xb306: 'Skein256-48',
  0xb307: 'Skein256-56',
  0xb308: 'Skein256-64',
  0xb309: 'Skein256-72',
  0xb30a: 'Skein256-80',
  0xb30b: 'Skein256-88',
  0xb30c: 'Skein256-96',
  0xb30d: 'Skein256-104',
  0xb30e: 'Skein256-112',
  0xb30f: 'Skein256-120',
  0xb310: 'Skein256-128',
  0xb311: 'Skein256-136',
  0xb312: 'Skein256-144',
  0xb313: 'Skein256-152',
  0xb314: 'Skein256-160',
  0xb315: 'Skein256-168',
  0xb316: 'Skein256-176',
  0xb317: 'Skein256-184',
  0xb318: 'Skein256-192',
  0xb319: 'Skein256-200',
  0xb31a: 'Skein256-208',
  0xb31b: 'Skein256-216',
  0xb31c: 'Skein256-224',
  0xb31d: 'Skein256-232',
  0xb31e: 'Skein256-240',
  0xb31f: 'Skein256-248',
  0xb320: 'Skein256-256',
  0xb321: 'Skein512-8',
  0xb322: 'Skein512-16',
  0xb323: 'Skein512-24',
  0xb324: 'Skein512-32',
  0xb325: 'Skein512-40',
  0xb326: 'Skein512-48',
  0xb327: 'Skein512-56',
  0xb328: 'Skein512-64',
  0xb329: 'Skein512-72',
  0xb32a: 'Skein512-80',
  0xb32b: 'Skein512-88',
  0xb32c: 'Skein512-96',
  0xb32d: 'Skein512-104',
  0xb32e: 'Skein512-112',
  0xb32f: 'Skein512-120',
  0xb330: 'Skein512-128',
  0xb331: 'Skein512-136',
  0xb332: 'Skein512-144',
  0xb333: 'Skein512-152',
  0xb334: 'Skein512-160',
  0xb335: 'Skein512-168',
  0xb336: 'Skein512-176',
  0xb337: 'Skein512-184',
  0xb338: 'Skein512-192',
  0xb339: 'Skein512-200',
  0xb33a: 'Skein512-208',
  0xb33b: 'Skein512-216',
  0xb33c: 'Skein512-224',
  0xb33d: 'Skein512-232',
  0xb33e: 'Skein512-240',
  0xb33f: 'Skein512-248',
  0xb340: 'Skein512-256',
  0xb341: 'Skein512-264',
  0xb342: 'Skein512-272',
  0xb343: 'Skein512-280',
  0xb344: 'Skein512-288',
  0xb345: 'Skein512-296',
  0xb346: 'Skein512-304',
  0xb347: 'Skein512-312',
  0xb348: 'Skein512-320',
  0xb349: 'Skein512-328',
  0xb34a: 'Skein512-336',
  0xb34b: 'Skein512-344',
  0xb34c: 'Skein512-352',
  0xb34d: 'Skein512-360',
  0xb34e: 'Skein512-368',
  0xb34f: 'Skein512-376',
  0xb350: 'Skein512-384',
  0xb351: 'Skein512-392',
  0xb352: 'Skein512-400',
  0xb353: 'Skein512-408',
  0xb354: 'Skein512-416',
  0xb355: 'Skein512-424',
  0xb356: 'Skein512-432',
  0xb357: 'Skein512-440',
  0xb358: 'Skein512-448',
  0xb359: 'Skein512-456',
  0xb35a: 'Skein512-464',
  0xb35b: 'Skein512-472',
  0xb35c: 'Skein512-480',
  0xb35d: 'Skein512-488',
  0xb35e: 'Skein512-496',
  0xb35f: 'Skein512-504',
  0xb360: 'Skein512-512',
  0xb361: 'Skein1024-8',
  0xb362: 'Skein1024-16',
  0xb363: 'Skein1024-24',
  0xb364: 'Skein1024-32',
  0xb365: 'Skein1024-40',
  0xb366: 'Skein1024-48',
  0xb367: 'Skein1024-56',
  0xb368: 'Skein1024-64',
  0xb369: 'Skein1024-72',
  0xb36a: 'Skein1024-80',
  0xb36b: 'Skein1024-88',
  0xb36c: 'Skein1024-96',
  0xb36d: 'Skein1024-104',
  0xb36e: 'Skein1024-112',
  0xb36f: 'Skein1024-120',
  0xb370: 'Skein1024-128',
  0xb371: 'Skein1024-136',
  0xb372: 'Skein1024-144',
  0xb373: 'Skein1024-152',
  0xb374: 'Skein1024-160',
  0xb375: 'Skein1024-168',
  0xb376: 'Skein1024-176',
  0xb377: 'Skein1024-184',
  0xb378: 'Skein1024-192',
  0xb379: 'Skein1024-200',
  0xb37a: 'Skein1024-208',
  0xb37b: 'Skein1024-216',
  0xb37c: 'Skein1024-224',
  0xb37d: 'Skein1024-232',
  0xb37e: 'Skein1024-240',
  0xb37f: 'Skein1024-248',
  0xb380: 'Skein1024-256',
  0xb381: 'Skein1024-264',
  0xb382: 'Skein1024-272',
  0xb383: 'Skein1024-280',
  0xb384: 'Skein1024-288',
  0xb385: 'Skein1024-296',
  0xb386: 'Skein1024-304',
  0xb387: 'Skein1024-312',
  0xb388: 'Skein1024-320',
  0xb389: 'Skein1024-328',
  0xb38a: 'Skein1024-336',
  0xb38b: 'Skein1024-344',
  0xb38c: 'Skein1024-352',
  0xb38d: 'Skein1024-360',
  0xb38e: 'Skein1024-368',
  0xb38f: 'Skein1024-376',
  0xb390: 'Skein1024-384',
  0xb391: 'Skein1024-392',
  0xb392: 'Skein1024-400',
  0xb393: 'Skein1024-408',
  0xb394: 'Skein1024-416',
  0xb395: 'Skein1024-424',
  0xb396: 'Skein1024-432',
  0xb397: 'Skein1024-440',
  0xb398: 'Skein1024-448',
  0xb399: 'Skein1024-456',
  0xb39a: 'Skein1024-464',
  0xb39b: 'Skein1024-472',
  0xb39c: 'Skein1024-480',
  0xb39d: 'Skein1024-488',
  0xb39e: 'Skein1024-496',
  0xb39f: 'Skein1024-504',
  0xb3a0: 'Skein1024-512',
  0xb3a1: 'Skein1024-520',
  0xb3a2: 'Skein1024-528',
  0xb3a3: 'Skein1024-536',
  0xb3a4: 'Skein1024-544',
  0xb3a5: 'Skein1024-552',
  0xb3a6: 'Skein1024-560',
  0xb3a7: 'Skein1024-568',
  0xb3a8: 'Skein1024-576',
  0xb3a9: 'Skein1024-584',
  0xb3aa: 'Skein1024-592',
  0xb3ab: 'Skein1024-600',
  0xb3ac: 'Skein1024-608',
  0xb3ad: 'Skein1024-616',
  0xb3ae: 'Skein1024-624',
  0xb3af: 'Skein1024-632',
  0xb3b0: 'Skein1024-640',
  0xb3b1: 'Skein1024-648',
  0xb3b2: 'Skein1024-656',
  0xb3b3: 'Skein1024-664',
  0xb3b4: 'Skein1024-672',
  0xb3b5: 'Skein1024-680',
  0xb3b6: 'Skein1024-688',
  0xb3b7: 'Skein1024-696',
  0xb3b8: 'Skein1024-704',
  0xb3b9: 'Skein1024-712',
  0xb3ba: 'Skein1024-720',
  0xb3bb: 'Skein1024-728',
  0xb3bc: 'Skein1024-736',
  0xb3bd: 'Skein1024-744',
  0xb3be: 'Skein1024-752',
  0xb3bf: 'Skein1024-760',
  0xb3c0: 'Skein1024-768',
  0xb3c1: 'Skein1024-776',
  0xb3c2: 'Skein1024-784',
  0xb3c3: 'Skein1024-792',
  0xb3c4: 'Skein1024-800',
  0xb3c5: 'Skein1024-808',
  0xb3c6: 'Skein1024-816',
  0xb3c7: 'Skein1024-824',
  0xb3c8: 'Skein1024-832',
  0xb3c9: 'Skein1024-840',
  0xb3ca: 'Skein1024-848',
  0xb3cb: 'Skein1024-856',
  0xb3cc: 'Skein1024-864',
  0xb3cd: 'Skein1024-872',
  0xb3ce: 'Skein1024-880',
  0xb3cf: 'Skein1024-888',
  0xb3d0: 'Skein1024-896',
  0xb3d1: 'Skein1024-904',
  0xb3d2: 'Skein1024-912',
  0xb3d3: 'Skein1024-920',
  0xb3d4: 'Skein1024-928',
  0xb3d5: 'Skein1024-936',
  0xb3d6: 'Skein1024-944',
  0xb3d7: 'Skein1024-952',
  0xb3d8: 'Skein1024-960',
  0xb3d9: 'Skein1024-968',
  0xb3da: 'Skein1024-976',
  0xb3db: 'Skein1024-984',
  0xb3dc: 'Skein1024-992',
  0xb3dd: 'Skein1024-1000',
  0xb3de: 'Skein1024-1008',
  0xb3df: 'Skein1024-1016',
  0xb3e0: 'Skein1024-1024'
})

exports.defaultLengths = Object.freeze({
  0x11: 20,
  0x12: 32,
  0x13: 64,
  0x56: 32,
  0x17: 28,
  0x16: 32,
  0x15: 48,
  0x14: 64,
  0x18: 32,
  0x19: 64,
  0x1A: 28,
  0x1B: 32,
  0x1C: 48,
  0x1D: 64,
  0x22: 32,

  0xb201: 0x01,
  0xb202: 0x02,
  0xb203: 0x03,
  0xb204: 0x04,
  0xb205: 0x05,
  0xb206: 0x06,
  0xb207: 0x07,
  0xb208: 0x08,
  0xb209: 0x09,
  0xb20a: 0x0a,
  0xb20b: 0x0b,
  0xb20c: 0x0c,
  0xb20d: 0x0d,
  0xb20e: 0x0e,
  0xb20f: 0x0f,
  0xb210: 0x10,
  0xb211: 0x11,
  0xb212: 0x12,
  0xb213: 0x13,
  0xb214: 0x14,
  0xb215: 0x15,
  0xb216: 0x16,
  0xb217: 0x17,
  0xb218: 0x18,
  0xb219: 0x19,
  0xb21a: 0x1a,
  0xb21b: 0x1b,
  0xb21c: 0x1c,
  0xb21d: 0x1d,
  0xb21e: 0x1e,
  0xb21f: 0x1f,
  0xb220: 0x20,
  0xb221: 0x21,
  0xb222: 0x22,
  0xb223: 0x23,
  0xb224: 0x24,
  0xb225: 0x25,
  0xb226: 0x26,
  0xb227: 0x27,
  0xb228: 0x28,
  0xb229: 0x29,
  0xb22a: 0x2a,
  0xb22b: 0x2b,
  0xb22c: 0x2c,
  0xb22d: 0x2d,
  0xb22e: 0x2e,
  0xb22f: 0x2f,
  0xb230: 0x30,
  0xb231: 0x31,
  0xb232: 0x32,
  0xb233: 0x33,
  0xb234: 0x34,
  0xb235: 0x35,
  0xb236: 0x36,
  0xb237: 0x37,
  0xb238: 0x38,
  0xb239: 0x39,
  0xb23a: 0x3a,
  0xb23b: 0x3b,
  0xb23c: 0x3c,
  0xb23d: 0x3d,
  0xb23e: 0x3e,
  0xb23f: 0x3f,
  0xb240: 0x40,
  0xb241: 0x01,
  0xb242: 0x02,
  0xb243: 0x03,
  0xb244: 0x04,
  0xb245: 0x05,
  0xb246: 0x06,
  0xb247: 0x07,
  0xb248: 0x08,
  0xb249: 0x09,
  0xb24a: 0x0a,
  0xb24b: 0x0b,
  0xb24c: 0x0c,
  0xb24d: 0x0d,
  0xb24e: 0x0e,
  0xb24f: 0x0f,
  0xb250: 0x10,
  0xb251: 0x11,
  0xb252: 0x12,
  0xb253: 0x13,
  0xb254: 0x14,
  0xb255: 0x15,
  0xb256: 0x16,
  0xb257: 0x17,
  0xb258: 0x18,
  0xb259: 0x19,
  0xb25a: 0x1a,
  0xb25b: 0x1b,
  0xb25c: 0x1c,
  0xb25d: 0x1d,
  0xb25e: 0x1e,
  0xb25f: 0x1f,
  0xb260: 0x20,
  0xb301: 0x01,
  0xb302: 0x02,
  0xb303: 0x03,
  0xb304: 0x04,
  0xb305: 0x05,
  0xb306: 0x06,
  0xb307: 0x07,
  0xb308: 0x08,
  0xb309: 0x09,
  0xb30a: 0x0a,
  0xb30b: 0x0b,
  0xb30c: 0x0c,
  0xb30d: 0x0d,
  0xb30e: 0x0e,
  0xb30f: 0x0f,
  0xb310: 0x10,
  0xb311: 0x11,
  0xb312: 0x12,
  0xb313: 0x13,
  0xb314: 0x14,
  0xb315: 0x15,
  0xb316: 0x16,
  0xb317: 0x17,
  0xb318: 0x18,
  0xb319: 0x19,
  0xb31a: 0x1a,
  0xb31b: 0x1b,
  0xb31c: 0x1c,
  0xb31d: 0x1d,
  0xb31e: 0x1e,
  0xb31f: 0x1f,
  0xb320: 0x20,
  0xb321: 0x01,
  0xb322: 0x02,
  0xb323: 0x03,
  0xb324: 0x04,
  0xb325: 0x05,
  0xb326: 0x06,
  0xb327: 0x07,
  0xb328: 0x08,
  0xb329: 0x09,
  0xb32a: 0x0a,
  0xb32b: 0x0b,
  0xb32c: 0x0c,
  0xb32d: 0x0d,
  0xb32e: 0x0e,
  0xb32f: 0x0f,
  0xb330: 0x10,
  0xb331: 0x11,
  0xb332: 0x12,
  0xb333: 0x13,
  0xb334: 0x14,
  0xb335: 0x15,
  0xb336: 0x16,
  0xb337: 0x17,
  0xb338: 0x18,
  0xb339: 0x19,
  0xb33a: 0x1a,
  0xb33b: 0x1b,
  0xb33c: 0x1c,
  0xb33d: 0x1d,
  0xb33e: 0x1e,
  0xb33f: 0x1f,
  0xb340: 0x20,
  0xb341: 0x21,
  0xb342: 0x22,
  0xb343: 0x23,
  0xb344: 0x24,
  0xb345: 0x25,
  0xb346: 0x26,
  0xb347: 0x27,
  0xb348: 0x28,
  0xb349: 0x29,
  0xb34a: 0x2a,
  0xb34b: 0x2b,
  0xb34c: 0x2c,
  0xb34d: 0x2d,
  0xb34e: 0x2e,
  0xb34f: 0x2f,
  0xb350: 0x30,
  0xb351: 0x31,
  0xb352: 0x32,
  0xb353: 0x33,
  0xb354: 0x34,
  0xb355: 0x35,
  0xb356: 0x36,
  0xb357: 0x37,
  0xb358: 0x38,
  0xb359: 0x39,
  0xb35a: 0x3a,
  0xb35b: 0x3b,
  0xb35c: 0x3c,
  0xb35d: 0x3d,
  0xb35e: 0x3e,
  0xb35f: 0x3f,
  0xb360: 0x40,
  0xb361: 0x01,
  0xb362: 0x02,
  0xb363: 0x03,
  0xb364: 0x04,
  0xb365: 0x05,
  0xb366: 0x06,
  0xb367: 0x07,
  0xb368: 0x08,
  0xb369: 0x09,
  0xb36a: 0x0a,
  0xb36b: 0x0b,
  0xb36c: 0x0c,
  0xb36d: 0x0d,
  0xb36e: 0x0e,
  0xb36f: 0x0f,
  0xb370: 0x10,
  0xb371: 0x11,
  0xb372: 0x12,
  0xb373: 0x13,
  0xb374: 0x14,
  0xb375: 0x15,
  0xb376: 0x16,
  0xb377: 0x17,
  0xb378: 0x18,
  0xb379: 0x19,
  0xb37a: 0x1a,
  0xb37b: 0x1b,
  0xb37c: 0x1c,
  0xb37d: 0x1d,
  0xb37e: 0x1e,
  0xb37f: 0x1f,
  0xb380: 0x20,
  0xb381: 0x21,
  0xb382: 0x22,
  0xb383: 0x23,
  0xb384: 0x24,
  0xb385: 0x25,
  0xb386: 0x26,
  0xb387: 0x27,
  0xb388: 0x28,
  0xb389: 0x29,
  0xb38a: 0x2a,
  0xb38b: 0x2b,
  0xb38c: 0x2c,
  0xb38d: 0x2d,
  0xb38e: 0x2e,
  0xb38f: 0x2f,
  0xb390: 0x30,
  0xb391: 0x31,
  0xb392: 0x32,
  0xb393: 0x33,
  0xb394: 0x34,
  0xb395: 0x35,
  0xb396: 0x36,
  0xb397: 0x37,
  0xb398: 0x38,
  0xb399: 0x39,
  0xb39a: 0x3a,
  0xb39b: 0x3b,
  0xb39c: 0x3c,
  0xb39d: 0x3d,
  0xb39e: 0x3e,
  0xb39f: 0x3f,
  0xb3a0: 0x40,
  0xb3a1: 0x41,
  0xb3a2: 0x42,
  0xb3a3: 0x43,
  0xb3a4: 0x44,
  0xb3a5: 0x45,
  0xb3a6: 0x46,
  0xb3a7: 0x47,
  0xb3a8: 0x48,
  0xb3a9: 0x49,
  0xb3aa: 0x4a,
  0xb3ab: 0x4b,
  0xb3ac: 0x4c,
  0xb3ad: 0x4d,
  0xb3ae: 0x4e,
  0xb3af: 0x4f,
  0xb3b0: 0x50,
  0xb3b1: 0x51,
  0xb3b2: 0x52,
  0xb3b3: 0x53,
  0xb3b4: 0x54,
  0xb3b5: 0x55,
  0xb3b6: 0x56,
  0xb3b7: 0x57,
  0xb3b8: 0x58,
  0xb3b9: 0x59,
  0xb3ba: 0x5a,
  0xb3bb: 0x5b,
  0xb3bc: 0x5c,
  0xb3bd: 0x5d,
  0xb3be: 0x5e,
  0xb3bf: 0x5f,
  0xb3c0: 0x60,
  0xb3c1: 0x61,
  0xb3c2: 0x62,
  0xb3c3: 0x63,
  0xb3c4: 0x64,
  0xb3c5: 0x65,
  0xb3c6: 0x66,
  0xb3c7: 0x67,
  0xb3c8: 0x68,
  0xb3c9: 0x69,
  0xb3ca: 0x6a,
  0xb3cb: 0x6b,
  0xb3cc: 0x6c,
  0xb3cd: 0x6d,
  0xb3ce: 0x6e,
  0xb3cf: 0x6f,
  0xb3d0: 0x70,
  0xb3d1: 0x71,
  0xb3d2: 0x72,
  0xb3d3: 0x73,
  0xb3d4: 0x74,
  0xb3d5: 0x75,
  0xb3d6: 0x76,
  0xb3d7: 0x77,
  0xb3d8: 0x78,
  0xb3d9: 0x79,
  0xb3da: 0x7a,
  0xb3db: 0x7b,
  0xb3dc: 0x7c,
  0xb3dd: 0x7d,
  0xb3de: 0x7e,
  0xb3df: 0x7f,
  0xb3e0: 0x80
})

      };
    };
  }
  }
}, {package:"@truffle/decoder>@truffle/encoder>@ensdomains/ensjs>content-hash>multihashes",file:"node_modules\\multihashes\\src\\constants.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\multihashes\\src\\index.js", {"./constants":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\multihashes\\src\\constants.js","buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js","multibase":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\multihashes\\node_modules\\multibase\\src\\index.js","varint":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\varint\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cmultihashes%5Csrc%5Cindex.js
      return function (require, module, exports) {
/**
 * Multihash implementation in JavaScript.
 *
 * @module multihash
 */
'use strict'

const { Buffer } = require('buffer')
const multibase = require('multibase')
const varint = require('varint')
const cs = require('./constants')

exports.names = cs.names
exports.codes = cs.codes
exports.defaultLengths = cs.defaultLengths

/**
 * Convert the given multihash to a hex encoded string.
 *
 * @param {Buffer} hash
 * @returns {string}
 */
exports.toHexString = function toHexString (hash) {
  if (!Buffer.isBuffer(hash)) {
    throw new Error('must be passed a buffer')
  }

  return hash.toString('hex')
}

/**
 * Convert the given hex encoded string to a multihash.
 *
 * @param {string} hash
 * @returns {Buffer}
 */
exports.fromHexString = function fromHexString (hash) {
  return Buffer.from(hash, 'hex')
}

/**
 * Convert the given multihash to a base58 encoded string.
 *
 * @param {Buffer} hash
 * @returns {string}
 */
exports.toB58String = function toB58String (hash) {
  if (!Buffer.isBuffer(hash)) {
    throw new Error('must be passed a buffer')
  }

  return multibase.encode('base58btc', hash).toString().slice(1)
}

/**
 * Convert the given base58 encoded string to a multihash.
 *
 * @param {string|Buffer} hash
 * @returns {Buffer}
 */
exports.fromB58String = function fromB58String (hash) {
  let encoded = hash
  if (Buffer.isBuffer(hash)) {
    encoded = hash.toString()
  }

  return multibase.decode('z' + encoded)
}

/**
 * Decode a hash from the given multihash.
 *
 * @param {Buffer} buf
 * @returns {{code: number, name: string, length: number, digest: Buffer}} result
 */
exports.decode = function decode (buf) {
  if (!(Buffer.isBuffer(buf))) {
    throw new Error('multihash must be a Buffer')
  }

  if (buf.length < 2) {
    throw new Error('multihash too short. must be > 2 bytes.')
  }

  const code = varint.decode(buf)
  if (!exports.isValidCode(code)) {
    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)
  }
  buf = buf.slice(varint.decode.bytes)

  const len = varint.decode(buf)
  if (len < 0) {
    throw new Error(`multihash invalid length: ${len}`)
  }
  buf = buf.slice(varint.decode.bytes)

  if (buf.length !== len) {
    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`)
  }

  return {
    code: code,
    name: cs.codes[code],
    length: len,
    digest: buf
  }
}

/**
 *  Encode a hash digest along with the specified function code.
 *
 * > **Note:** the length is derived from the length of the digest itself.
 *
 * @param {Buffer} digest
 * @param {string|number} code
 * @param {number} [length]
 * @returns {Buffer}
 */
exports.encode = function encode (digest, code, length) {
  if (!digest || code === undefined) {
    throw new Error('multihash encode requires at least two args: digest, code')
  }

  // ensure it's a hashfunction code.
  const hashfn = exports.coerceCode(code)

  if (!(Buffer.isBuffer(digest))) {
    throw new Error('digest should be a Buffer')
  }

  if (length == null) {
    length = digest.length
  }

  if (length && digest.length !== length) {
    throw new Error('digest length should be equal to specified length.')
  }

  return Buffer.concat([
    Buffer.from(varint.encode(hashfn)),
    Buffer.from(varint.encode(length)),
    digest
  ])
}

/**
 * Converts a hash function name into the matching code.
 * If passed a number it will return the number if it's a valid code.
 * @param {string|number} name
 * @returns {number}
 */
exports.coerceCode = function coerceCode (name) {
  let code = name

  if (typeof name === 'string') {
    if (cs.names[name] === undefined) {
      throw new Error(`Unrecognized hash function named: ${name}`)
    }
    code = cs.names[name]
  }

  if (typeof code !== 'number') {
    throw new Error(`Hash function code should be a number. Got: ${code}`)
  }

  if (cs.codes[code] === undefined && !exports.isAppCode(code)) {
    throw new Error(`Unrecognized function code: ${code}`)
  }

  return code
}

/**
 * Checks wether a code is part of the app range
 *
 * @param {number} code
 * @returns {boolean}
 */
exports.isAppCode = function appCode (code) {
  return code > 0 && code < 0x10
}

/**
 * Checks whether a multihash code is valid.
 *
 * @param {number} code
 * @returns {boolean}
 */
exports.isValidCode = function validCode (code) {
  if (exports.isAppCode(code)) {
    return true
  }

  if (cs.codes[code]) {
    return true
  }

  return false
}

/**
 * Check if the given buffer is a valid multihash. Throws an error if it is not valid.
 *
 * @param {Buffer} multihash
 * @returns {undefined}
 * @throws {Error}
 */
function validate (multihash) {
  exports.decode(multihash) // throws if bad.
}
exports.validate = validate

/**
 * Returns a prefix from a valid multihash. Throws an error if it is not valid.
 *
 * @param {Buffer} multihash
 * @returns {undefined}
 * @throws {Error}
 */
exports.prefix = function prefix (multihash) {
  validate(multihash)

  return multihash.slice(0, 2)
}

      };
    };
  }
  }
}, {package:"@truffle/decoder>@truffle/encoder>@ensdomains/ensjs>content-hash>multihashes",file:"node_modules\\multihashes\\src\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\nanoid\\non-secure\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cnanoid%5Cnon-secure%5Cindex.js
      return function (require, module, exports) {
// This alphabet uses a-z A-Z 0-9 _- symbols.
// Symbols are generated for smaller size.
// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA
var url = '-_'
// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).
var i = 36
while (i--) {
  // 36 is radix. Number.prototype.toString(36) returns number
  // in Base36 representation. Base36 is like hex, but it uses 0–9 and a-z.
  url += i.toString(36)
}
// Loop from 36 to 10 (from Z to A in Base36).
i = 36
while (i-- - 10) {
  url += i.toString(36).toUpperCase()
}

/**
 * Generate URL-friendly unique ID. This method use non-secure predictable
 * random generator with bigger collision probability.
 *
 * @param {number} [size=21] The number of symbols in ID.
 *
 * @return {string} Random string.
 *
 * @example
 * const nanoid = require('nanoid/non-secure')
 * model.id = nanoid() //=> "Uakgb_J5m9g-0JDMbcJqL"
 *
 * @name nonSecure
 * @function
 */
module.exports = function (size) {
  var id = ''
  i = size || 21
  // Compact alternative for `for (var i = 0; i < size; i++)`
  while (i--) {
    // `| 0` is compact and faster alternative for `Math.floor()`
    id += url[Math.random() * 64 | 0]
  }
  return id
}

      };
    };
  }
  }
}, {package:"nanoid",file:"node_modules\\nanoid\\non-secure\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\no-case\\no-case.js", {"./vendor/camel-case-regexp":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\no-case\\vendor\\camel-case-regexp.js","./vendor/camel-case-upper-regexp":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\no-case\\vendor\\camel-case-upper-regexp.js","./vendor/non-word-regexp":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\no-case\\vendor\\non-word-regexp.js","lower-case":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\lower-case\\lower-case.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cno-case%5Cno-case.js
      return function (require, module, exports) {
var lowerCase = require('lower-case')

var NON_WORD_REGEXP = require('./vendor/non-word-regexp')
var CAMEL_CASE_REGEXP = require('./vendor/camel-case-regexp')
var CAMEL_CASE_UPPER_REGEXP = require('./vendor/camel-case-upper-regexp')

/**
 * Sentence case a string.
 *
 * @param  {string} str
 * @param  {string} locale
 * @param  {string} replacement
 * @return {string}
 */
module.exports = function (str, locale, replacement) {
  if (str == null) {
    return ''
  }

  replacement = typeof replacement !== 'string' ? ' ' : replacement

  function replace (match, index, value) {
    if (index === 0 || index === (value.length - match.length)) {
      return ''
    }

    return replacement
  }

  str = String(str)
    // Support camel case ("camelCase" -> "camel Case").
    .replace(CAMEL_CASE_REGEXP, '$1 $2')
    // Support odd camel case ("CAMELCase" -> "CAMEL Case").
    .replace(CAMEL_CASE_UPPER_REGEXP, '$1 $2')
    // Remove all non-word characters and replace with a single space.
    .replace(NON_WORD_REGEXP, replace)

  // Lower case the entire string.
  return lowerCase(str, locale)
}

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>no-case",file:"node_modules\\no-case\\no-case.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\no-case\\vendor\\camel-case-regexp.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cno-case%5Cvendor%5Ccamel-case-regexp.js
      return function (require, module, exports) {
module.exports = /([a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19])([A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A])/g

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>no-case",file:"node_modules\\no-case\\vendor\\camel-case-regexp.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\no-case\\vendor\\camel-case-upper-regexp.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cno-case%5Cvendor%5Ccamel-case-upper-regexp.js
      return function (require, module, exports) {
module.exports = /([A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A])([A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A][a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A])/g

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>no-case",file:"node_modules\\no-case\\vendor\\camel-case-upper-regexp.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\no-case\\vendor\\non-word-regexp.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cno-case%5Cvendor%5Cnon-word-regexp.js
      return function (require, module, exports) {
module.exports = /[^A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]+/g

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>no-case",file:"node_modules\\no-case\\vendor\\non-word-regexp.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\node-interval-tree\\lib\\index.js", {"shallowequal":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\shallowequal\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cnode-interval-tree%5Clib%5Cindex.js
      return function (require, module, exports) {
"use strict";
// An augmented AVL Tree where each node maintains a list of records and their search intervals.
// Record is composed of an interval and its underlying data, sent by a client. This allows the
// interval tree to have the same interval inserted multiple times, as long its data is different.
// Both insertion and deletion require O(log n) time. Searching requires O(k*logn) time, where `k`
// is the number of intervals in the output list.
Object.defineProperty(exports, "__esModule", { value: true });
var isSame = require("shallowequal");
function height(node) {
    if (node === undefined) {
        return -1;
    }
    else {
        return node.height;
    }
}
var Node = /** @class */ (function () {
    function Node(intervalTree, record) {
        this.intervalTree = intervalTree;
        this.records = [];
        this.height = 0;
        this.key = record.low;
        this.max = record.high;
        // Save the array of all records with the same key for this node
        this.records.push(record);
    }
    // Gets the highest record.high value for this node
    Node.prototype.getNodeHigh = function () {
        var high = this.records[0].high;
        for (var i = 1; i < this.records.length; i++) {
            if (this.records[i].high > high) {
                high = this.records[i].high;
            }
        }
        return high;
    };
    // Updates height value of the node. Called during insertion, rebalance, removal
    Node.prototype.updateHeight = function () {
        this.height = Math.max(height(this.left), height(this.right)) + 1;
    };
    // Updates the max value of all the parents after inserting into already existing node, as well as
    // removing the node completely or removing the record of an already existing node. Starts with
    // the parent of an affected node and bubbles up to root
    Node.prototype.updateMaxOfParents = function () {
        if (this === undefined) {
            return;
        }
        var thisHigh = this.getNodeHigh();
        if (this.left !== undefined && this.right !== undefined) {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(this.left.max, thisHigh);
        }
        else if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(this.right.max, thisHigh);
        }
        else {
            this.max = thisHigh;
        }
        if (this.parent) {
            this.parent.updateMaxOfParents();
        }
    };
    /*
    Left-Left case:
  
           z                                      y
          / \                                   /   \
         y   T4      Right Rotate (z)          x     z
        / \          - - - - - - - - ->       / \   / \
       x   T3                                T1 T2 T3 T4
      / \
    T1   T2
  
    Left-Right case:
  
         z                               z                           x
        / \                             / \                        /   \
       y   T4  Left Rotate (y)         x  T4  Right Rotate(z)     y     z
      / \      - - - - - - - - ->     / \      - - - - - - - ->  / \   / \
    T1   x                           y  T3                      T1 T2 T3 T4
        / \                         / \
      T2   T3                      T1 T2
    */
    // Handles Left-Left case and Left-Right case after rebalancing AVL tree
    Node.prototype._updateMaxAfterRightRotate = function () {
        var parent = this.parent;
        var left = parent.left;
        // Update max of left sibling (x in first case, y in second)
        var thisParentLeftHigh = left.getNodeHigh();
        if (left.left === undefined && left.right !== undefined) {
            left.max = Math.max(thisParentLeftHigh, left.right.max);
        }
        else if (left.left !== undefined && left.right === undefined) {
            left.max = Math.max(thisParentLeftHigh, left.left.max);
        }
        else if (left.left === undefined && left.right === undefined) {
            left.max = thisParentLeftHigh;
        }
        else {
            left.max = Math.max(Math.max(left.left.max, left.right.max), thisParentLeftHigh);
        }
        // Update max of itself (z)
        var thisHigh = this.getNodeHigh();
        if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(thisHigh, this.right.max);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(thisHigh, this.left.max);
        }
        else if (this.left === undefined && this.right === undefined) {
            this.max = thisHigh;
        }
        else {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        // Update max of parent (y in first case, x in second)
        parent.max = Math.max(Math.max(parent.left.max, parent.right.max), parent.getNodeHigh());
    };
    /*
    Right-Right case:
  
      z                               y
     / \                            /   \
    T1  y     Left Rotate(z)       z     x
       / \   - - - - - - - ->     / \   / \
      T2  x                      T1 T2 T3 T4
         / \
        T3 T4
  
    Right-Left case:
  
       z                            z                            x
      / \                          / \                         /   \
     T1  y   Right Rotate (y)     T1  x      Left Rotate(z)   z     y
        / \  - - - - - - - - ->      / \   - - - - - - - ->  / \   / \
       x  T4                        T2  y                   T1 T2 T3 T4
      / \                              / \
    T2   T3                           T3 T4
    */
    // Handles Right-Right case and Right-Left case in rebalancing AVL tree
    Node.prototype._updateMaxAfterLeftRotate = function () {
        var parent = this.parent;
        var right = parent.right;
        // Update max of right sibling (x in first case, y in second)
        var thisParentRightHigh = right.getNodeHigh();
        if (right.left === undefined && right.right !== undefined) {
            right.max = Math.max(thisParentRightHigh, right.right.max);
        }
        else if (right.left !== undefined && right.right === undefined) {
            right.max = Math.max(thisParentRightHigh, right.left.max);
        }
        else if (right.left === undefined && right.right === undefined) {
            right.max = thisParentRightHigh;
        }
        else {
            right.max = Math.max(Math.max(right.left.max, right.right.max), thisParentRightHigh);
        }
        // Update max of itself (z)
        var thisHigh = this.getNodeHigh();
        if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(thisHigh, this.right.max);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(thisHigh, this.left.max);
        }
        else if (this.left === undefined && this.right === undefined) {
            this.max = thisHigh;
        }
        else {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        // Update max of parent (y in first case, x in second)
        parent.max = Math.max(Math.max(parent.left.max, right.max), parent.getNodeHigh());
    };
    Node.prototype._leftRotate = function () {
        var rightChild = this.right;
        rightChild.parent = this.parent;
        if (rightChild.parent === undefined) {
            this.intervalTree.root = rightChild;
        }
        else {
            if (rightChild.parent.left === this) {
                rightChild.parent.left = rightChild;
            }
            else if (rightChild.parent.right === this) {
                rightChild.parent.right = rightChild;
            }
        }
        this.right = rightChild.left;
        if (this.right !== undefined) {
            this.right.parent = this;
        }
        rightChild.left = this;
        this.parent = rightChild;
        this.updateHeight();
        rightChild.updateHeight();
    };
    Node.prototype._rightRotate = function () {
        var leftChild = this.left;
        leftChild.parent = this.parent;
        if (leftChild.parent === undefined) {
            this.intervalTree.root = leftChild;
        }
        else {
            if (leftChild.parent.left === this) {
                leftChild.parent.left = leftChild;
            }
            else if (leftChild.parent.right === this) {
                leftChild.parent.right = leftChild;
            }
        }
        this.left = leftChild.right;
        if (this.left !== undefined) {
            this.left.parent = this;
        }
        leftChild.right = this;
        this.parent = leftChild;
        this.updateHeight();
        leftChild.updateHeight();
    };
    // Rebalances the tree if the height value between two nodes of the same parent is greater than
    // two. There are 4 cases that can happen which are outlined in the graphics above
    Node.prototype._rebalance = function () {
        if (height(this.left) >= 2 + height(this.right)) {
            var left = this.left;
            if (height(left.left) >= height(left.right)) {
                // Left-Left case
                this._rightRotate();
                this._updateMaxAfterRightRotate();
            }
            else {
                // Left-Right case
                left._leftRotate();
                this._rightRotate();
                this._updateMaxAfterRightRotate();
            }
        }
        else if (height(this.right) >= 2 + height(this.left)) {
            var right = this.right;
            if (height(right.right) >= height(right.left)) {
                // Right-Right case
                this._leftRotate();
                this._updateMaxAfterLeftRotate();
            }
            else {
                // Right-Left case
                right._rightRotate();
                this._leftRotate();
                this._updateMaxAfterLeftRotate();
            }
        }
    };
    Node.prototype.insert = function (record) {
        if (record.low < this.key) {
            // Insert into left subtree
            if (this.left === undefined) {
                this.left = new Node(this.intervalTree, record);
                this.left.parent = this;
            }
            else {
                this.left.insert(record);
            }
        }
        else {
            // Insert into right subtree
            if (this.right === undefined) {
                this.right = new Node(this.intervalTree, record);
                this.right.parent = this;
            }
            else {
                this.right.insert(record);
            }
        }
        // Update the max value of this ancestor if needed
        if (this.max < record.high) {
            this.max = record.high;
        }
        // Update height of each node
        this.updateHeight();
        // Rebalance the tree to ensure all operations are executed in O(logn) time. This is especially
        // important in searching, as the tree has a high chance of degenerating without the rebalancing
        this._rebalance();
    };
    Node.prototype._getOverlappingRecords = function (currentNode, low, high) {
        if (currentNode.key <= high && low <= currentNode.getNodeHigh()) {
            // Nodes are overlapping, check if individual records in the node are overlapping
            var tempResults = [];
            for (var i = 0; i < currentNode.records.length; i++) {
                if (currentNode.records[i].high >= low) {
                    tempResults.push(currentNode.records[i]);
                }
            }
            return tempResults;
        }
        return [];
    };
    Node.prototype.search = function (low, high) {
        // Don't search nodes that don't exist
        if (this === undefined) {
            return [];
        }
        var leftSearch = [];
        var ownSearch = [];
        var rightSearch = [];
        // If interval is to the right of the rightmost point of any interval in this node and all its
        // children, there won't be any matches
        if (low > this.max) {
            return [];
        }
        // Search left children
        if (this.left !== undefined && this.left.max >= low) {
            leftSearch = this.left.search(low, high);
        }
        // Check this node
        ownSearch = this._getOverlappingRecords(this, low, high);
        // If interval is to the left of the start of this interval, then it can't be in any child to
        // the right
        if (high < this.key) {
            return leftSearch.concat(ownSearch);
        }
        // Otherwise, search right children
        if (this.right !== undefined) {
            rightSearch = this.right.search(low, high);
        }
        // Return accumulated results, if any
        return leftSearch.concat(ownSearch, rightSearch);
    };
    // Searches for a node by a `key` value
    Node.prototype.searchExisting = function (low) {
        if (this === undefined) {
            return undefined;
        }
        if (this.key === low) {
            return this;
        }
        else if (low < this.key) {
            if (this.left !== undefined) {
                return this.left.searchExisting(low);
            }
        }
        else {
            if (this.right !== undefined) {
                return this.right.searchExisting(low);
            }
        }
        return undefined;
    };
    // Returns the smallest node of the subtree
    Node.prototype._minValue = function () {
        if (this.left === undefined) {
            return this;
        }
        else {
            return this.left._minValue();
        }
    };
    Node.prototype.remove = function (node) {
        var parent = this.parent;
        if (node.key < this.key) {
            // Node to be removed is on the left side
            if (this.left !== undefined) {
                return this.left.remove(node);
            }
            else {
                return undefined;
            }
        }
        else if (node.key > this.key) {
            // Node to be removed is on the right side
            if (this.right !== undefined) {
                return this.right.remove(node);
            }
            else {
                return undefined;
            }
        }
        else {
            if (this.left !== undefined && this.right !== undefined) {
                // Node has two children
                var minValue = this.right._minValue();
                this.key = minValue.key;
                this.records = minValue.records;
                return this.right.remove(this);
            }
            else if (parent.left === this) {
                // One child or no child case on left side
                if (this.right !== undefined) {
                    parent.left = this.right;
                    this.right.parent = parent;
                }
                else {
                    parent.left = this.left;
                    if (this.left !== undefined) {
                        this.left.parent = parent;
                    }
                }
                parent.updateMaxOfParents();
                parent.updateHeight();
                parent._rebalance();
                return this;
            }
            else if (parent.right === this) {
                // One child or no child case on right side
                if (this.right !== undefined) {
                    parent.right = this.right;
                    this.right.parent = parent;
                }
                else {
                    parent.right = this.left;
                    if (this.left !== undefined) {
                        this.left.parent = parent;
                    }
                }
                parent.updateMaxOfParents();
                parent.updateHeight();
                parent._rebalance();
                return this;
            }
        }
    };
    return Node;
}());
exports.Node = Node;
var IntervalTree = /** @class */ (function () {
    function IntervalTree() {
        this.count = 0;
    }
    IntervalTree.prototype.insert = function (record) {
        if (record.low > record.high) {
            throw new Error('`low` value must be lower or equal to `high` value');
        }
        if (this.root === undefined) {
            // Base case: Tree is empty, new node becomes root
            this.root = new Node(this, record);
            this.count++;
            return true;
        }
        else {
            // Otherwise, check if node already exists with the same key
            var node = this.root.searchExisting(record.low);
            if (node !== undefined) {
                // Check the records in this node if there already is the one with same low, high, data
                for (var i = 0; i < node.records.length; i++) {
                    if (isSame(node.records[i], record)) {
                        // This record is same as the one we're trying to insert; return false to indicate
                        // nothing has been inserted
                        return false;
                    }
                }
                // Add the record to the node
                node.records.push(record);
                // Update max of the node and its parents if necessary
                if (record.high > node.max) {
                    node.max = record.high;
                    if (node.parent) {
                        node.parent.updateMaxOfParents();
                    }
                }
                this.count++;
                return true;
            }
            else {
                // Node with this key doesn't already exist. Call insert function on root's node
                this.root.insert(record);
                this.count++;
                return true;
            }
        }
    };
    IntervalTree.prototype.search = function (low, high) {
        if (this.root === undefined) {
            // Tree is empty; return empty array
            return [];
        }
        else {
            return this.root.search(low, high);
        }
    };
    IntervalTree.prototype.remove = function (record) {
        if (this.root === undefined) {
            // Tree is empty; nothing to remove
            return false;
        }
        else {
            var node = this.root.searchExisting(record.low);
            if (node === undefined) {
                return false;
            }
            else if (node.records.length > 1) {
                var removedRecord = void 0;
                // Node with this key has 2 or more records. Find the one we need and remove it
                for (var i = 0; i < node.records.length; i++) {
                    if (isSame(node.records[i], record)) {
                        removedRecord = node.records[i];
                        node.records.splice(i, 1);
                        break;
                    }
                }
                if (removedRecord) {
                    removedRecord = undefined;
                    // Update max of that node and its parents if necessary
                    if (record.high === node.max) {
                        var nodeHigh = node.getNodeHigh();
                        if (node.left !== undefined && node.right !== undefined) {
                            node.max = Math.max(Math.max(node.left.max, node.right.max), nodeHigh);
                        }
                        else if (node.left !== undefined && node.right === undefined) {
                            node.max = Math.max(node.left.max, nodeHigh);
                        }
                        else if (node.left === undefined && node.right !== undefined) {
                            node.max = Math.max(node.right.max, nodeHigh);
                        }
                        else {
                            node.max = nodeHigh;
                        }
                        if (node.parent) {
                            node.parent.updateMaxOfParents();
                        }
                    }
                    this.count--;
                    return true;
                }
                else {
                    return false;
                }
            }
            else if (node.records.length === 1) {
                // Node with this key has only 1 record. Check if the remaining record in this node is
                // actually the one we want to remove
                if (isSame(node.records[0], record)) {
                    // The remaining record is the one we want to remove. Remove the whole node from the tree
                    if (this.root.key === node.key) {
                        // We're removing the root element. Create a dummy node that will temporarily take
                        // root's parent role
                        var rootParent = new Node(this, { low: record.low, high: record.low });
                        rootParent.left = this.root;
                        this.root.parent = rootParent;
                        var removedNode = this.root.remove(node);
                        this.root = rootParent.left;
                        if (this.root !== undefined) {
                            this.root.parent = undefined;
                        }
                        if (removedNode) {
                            removedNode = undefined;
                            this.count--;
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        var removedNode = this.root.remove(node);
                        if (removedNode) {
                            removedNode = undefined;
                            this.count--;
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
                else {
                    // The remaining record is not the one we want to remove
                    return false;
                }
            }
            else {
                // No records at all in this node?! Shouldn't happen
                return false;
            }
        }
    };
    IntervalTree.prototype.inOrder = function () {
        return new InOrder(this.root);
    };
    IntervalTree.prototype.preOrder = function () {
        return new PreOrder(this.root);
    };
    return IntervalTree;
}());
exports.IntervalTree = IntervalTree;
var DataIntervalTree = /** @class */ (function () {
    function DataIntervalTree() {
        this.tree = new IntervalTree();
    }
    DataIntervalTree.prototype.insert = function (low, high, data) {
        return this.tree.insert({ low: low, high: high, data: data });
    };
    DataIntervalTree.prototype.remove = function (low, high, data) {
        return this.tree.remove({ low: low, high: high, data: data });
    };
    DataIntervalTree.prototype.search = function (low, high) {
        return this.tree.search(low, high).map(function (v) { return v.data; });
    };
    DataIntervalTree.prototype.inOrder = function () {
        return this.tree.inOrder();
    };
    DataIntervalTree.prototype.preOrder = function () {
        return this.tree.preOrder();
    };
    Object.defineProperty(DataIntervalTree.prototype, "count", {
        get: function () {
            return this.tree.count;
        },
        enumerable: true,
        configurable: true
    });
    return DataIntervalTree;
}());
exports.default = DataIntervalTree;
var InOrder = /** @class */ (function () {
    function InOrder(startNode) {
        this.stack = [];
        if (startNode !== undefined) {
            this.push(startNode);
        }
    }
    InOrder.prototype.next = function () {
        // Will only happen if stack is empty and pop is called
        if (this.currentNode === undefined) {
            return {
                done: true,
                value: undefined,
            };
        }
        // Process this node
        if (this.i < this.currentNode.records.length) {
            return {
                done: false,
                value: this.currentNode.records[this.i++],
            };
        }
        if (this.currentNode.right !== undefined) {
            this.push(this.currentNode.right);
        }
        else {
            // Might pop the last and set this.currentNode = undefined
            this.pop();
        }
        return this.next();
    };
    InOrder.prototype.push = function (node) {
        this.currentNode = node;
        this.i = 0;
        while (this.currentNode.left !== undefined) {
            this.stack.push(this.currentNode);
            this.currentNode = this.currentNode.left;
        }
    };
    InOrder.prototype.pop = function () {
        this.currentNode = this.stack.pop();
        this.i = 0;
    };
    return InOrder;
}());
exports.InOrder = InOrder;
if (typeof Symbol === 'function') {
    InOrder.prototype[Symbol.iterator] = function () { return this; };
}
var PreOrder = /** @class */ (function () {
    function PreOrder(startNode) {
        this.stack = [];
        this.i = 0;
        this.currentNode = startNode;
    }
    PreOrder.prototype.next = function () {
        // Will only happen if stack is empty and pop is called,
        // which only happens if there is no right node (i.e we are done)
        if (this.currentNode === undefined) {
            return {
                done: true,
                value: undefined,
            };
        }
        // Process this node
        if (this.i < this.currentNode.records.length) {
            return {
                done: false,
                value: this.currentNode.records[this.i++],
            };
        }
        if (this.currentNode.right !== undefined) {
            this.push(this.currentNode.right);
        }
        if (this.currentNode.left !== undefined) {
            this.push(this.currentNode.left);
        }
        this.pop();
        return this.next();
    };
    PreOrder.prototype.push = function (node) {
        this.stack.push(node);
    };
    PreOrder.prototype.pop = function () {
        this.currentNode = this.stack.pop();
        this.i = 0;
    };
    return PreOrder;
}());
exports.PreOrder = PreOrder;
if (typeof Symbol === 'function') {
    PreOrder.prototype[Symbol.iterator] = function () { return this; };
}
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@truffle/decoder>@truffle/source-map-utils>node-interval-tree",file:"node_modules\\node-interval-tree\\lib\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\nofilter\\lib\\index.js", {"buffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\buffer\\index.js","stream":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\stream-browserify\\index.js","util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\browserify\\node_modules\\util\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cnofilter%5Clib%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const stream = require('stream')
const util = require('util')

/**
 * NoFilter stream.  Can be used to sink or source data to and from
 * other node streams.  Implemented as the "identity" Transform stream
 * (hence the name), but allows for inspecting data that is in-flight.
 *
 * Allows passing in source data (input, inputEncoding) at creation
 * time.  Source data can also be passed in the options object.
 *
 * @example <caption>source</caption>
 * const n = new NoFilter('Zm9v', 'base64');
 * n.pipe(process.stdout);
 *
 * @example <caption>sink</caption>
 * const n = new Nofilter();
 * // NOTE: 'finish' fires when the input is done writing
 * n.on('finish', function() { console.log(n.toString('base64')); });
 * process.stdin.pipe(n);
 */
class NoFilter extends stream.Transform {
  /**
   * Create an instance of NoFilter.
   *
   * @param {string|Buffer} [input] - Source data
   * @param {string} [inputEncoding=null] - Encoding name for input,
   *   ignored if input is not a String
   * @param {Object} [options={}] - Other options
   * @param {string|Buffer} [options.input=null] - Input source data
   * @param {string} [options.inputEncoding=null] - Encoding name for input,
   *   ignored if input is not a String
   * @param {number} [options.highWaterMark=16384] - The maximum number of bytes
   *   to store in the internal buffer before ceasing to read from the
   *   underlying resource. Default=16kb, or 16 for objectMode streams
   * @param {string} [options.encoding=null] - If specified, then buffers will
   *   be decoded to strings using the specified encoding
   * @param {boolean} [options.objectMode=false] - Whether this stream should
   *   behave as a stream of objects. Meaning that stream.read(n) returns a
   *   single value instead of a Buffer of size n
   * @param {boolean} [options.decodeStrings=true] - Whether or not to decode
   *   strings into Buffers before passing them to _write()
   * @param {boolean} [options.watchPipe=true] - Whether to watch for 'pipe'
   *   events, setting this stream's objectMode based on the objectMode of the
   *   input stream
   * @param {boolean} [options.readError=false] - If true, when a read()
   *   underflows, throw an error.
   */
  constructor(input, inputEncoding, options) {
    if (options == null) {
      options = {}
    }
    let inp
    let inpE
    switch (typeof(input)) {
      case 'object':
        if (Buffer.isBuffer(input)) {
          inp = input
          if ((inputEncoding != null) && (typeof(inputEncoding) === 'object')) {
            options = inputEncoding
          }
        } else {
          options = input
        }
        break
      case 'string':
        inp = input
        if ((inputEncoding != null) && (typeof(inputEncoding) === 'object')) {
          options = inputEncoding
        } else {
          inpE = inputEncoding
        }
        break
    }

    if ((options == null)) {
      options = {}
    }
    if (inp == null) {
      inp = options.input
    }
    if (inpE == null) {
      inpE = options.inputEncoding
    }
    delete options.input
    delete options.inputEncoding
    const watchPipe = options.watchPipe != null ? options.watchPipe : true
    delete options.watchPipe
    const readError = !! options.readError
    delete options.readError
    super(options)

    this.readError = readError

    if (watchPipe) {
      this.on('pipe', readable => {
        const om = readable._readableState.objectMode
        if ((this.length > 0) && (om !== this._readableState.objectMode)) {
          throw new Error(
            'Do not switch objectMode in the middle of the stream')
        }

        this._readableState.objectMode = om
        return this._writableState.objectMode = om
      })
    }

    if (inp != null) {
      this.end(inp, inpE)
    }
  }

  /**
   * Is the given object a {NoFilter}?
   *
   * @param {Object} obj The object to test.
   * @returns {boolean} true if obj is a NoFilter
   */
  static isNoFilter(obj) {
    return obj instanceof this
  }

  /**
   * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.
   *
   * @param {NoFilter} nf1 - The first object to compare
   * @param {NoFilter} nf2 - The second object to compare
   * @returns {number} -1, 0, 1 for less, equal, greater
   *
   * @example
   * const arr = [new NoFilter('1234'), new NoFilter('0123')];
   * arr.sort(NoFilter.compare);
   */
  static compare(nf1, nf2) {
    if (!(nf1 instanceof this)) {
      throw new TypeError('Arguments must be NoFilters')
    }
    if (nf1 === nf2) {
      return 0
    } else {
      return nf1.compare(nf2)
    }
  }

  /**
   * Returns a buffer which is the result of concatenating all the
   * NoFilters in the list together. If the list has no items, or if
   * the totalLength is 0, then it returns a zero-length buffer.
   *
   * If length is not provided, it is read from the buffers in the
   * list. However, this adds an additional loop to the function, so
   * it is faster to provide the length explicitly if you already know it.
   *
   * @param {Array<NoFilter>} list Inputs.  Must not be all either in object
   *   mode, or all not in object mode.
   * @param {number} [length=null] Number of bytes or objects to read
   * @returns {Buffer|Array} The concatenated values as an array if in object
   *   mode, otherwise a Buffer
   */
  static concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('list argument must be an Array of NoFilters')
    }
    if ((list.length === 0) || (length === 0)) {
      return Buffer.alloc(0)
    }
    if ((length == null)) {
      length = list.reduce((tot, nf) => {
        if (!(nf instanceof NoFilter)) {
          throw new TypeError('list argument must be an Array of NoFilters')
        }
        return tot + nf.length
      }, 0)
    }
    let allBufs = true
    let allObjs = true
    const bufs = list.map(nf => {
      if (!(nf instanceof NoFilter)) {
        throw new TypeError('list argument must be an Array of NoFilters')
      }
      const buf = nf.slice()
      if (Buffer.isBuffer(buf)) {
        allObjs = false
      } else {
        allBufs = false
      }
      return buf
    })
    if (allBufs) {
      return Buffer.concat(bufs, length)
    }
    if (allObjs) {
      return [].concat(...bufs).slice(0, length)
    }
    // TODO: maybe coalesce buffers, counting bytes, and flatten in arrays
    // counting objects?  I can't imagine why that would be useful.
    throw new Error('Concatenating mixed object and byte streams not supported')
  }

  /**
   * @private
   */
  _transform(chunk, encoding, callback) {
    if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {
      chunk = Buffer.from(chunk, encoding)
    }
    this.push(chunk)
    callback()
  }

  /**
   * @private
   */
  _bufArray() {
    let bufs = this._readableState.buffer
    // HACK: replace with something else one day.  This is what I get for
    // relying on internals.
    if (!Array.isArray(bufs)) {
      let b = bufs.head
      bufs = []
      while (b != null) {
        bufs.push(b.data)
        b = b.next
      }
    }
    return bufs
  }

  /**
   * Pulls some data out of the internal buffer and returns it.
   * If there is no data available, then it will return null.
   *
   * If you pass in a size argument, then it will return that many bytes. If
   * size bytes are not available, then it will return null, unless we've
   * ended, in which case it will return the data remaining in the buffer.
   *
   * If you do not specify a size argument, then it will return all the data in
   * the internal buffer.
   *
   * @param {number} [size=null] - Number of bytes to read.
   * @returns {string|Buffer|null} If no data or not enough data, null.  If
   *   decoding output a string, otherwise a Buffer
   * @throws Error - if readError is true and there was underflow
   * @fires NoFilter#read
   */
  read(size) {
    const buf = super.read(size)
    if (buf != null) {
      /*
       * Read event. Fired whenever anything is read from the stream.
       *
       * @event NoFilter#read
       * @type {Buffer|string|Object}
       *
       */
      this.emit('read', buf)
      if (this.readError && (buf.length < size)) {
        throw new Error(`Read ${buf.length}, wanted ${size}`)
      }
    } else if (this.readError) {
      throw new Error(`No data available, wanted ${size}`)
    }
    return buf
  }

  /**
   * Return a promise fulfilled with the full contents, after the 'finish'
   * event fires.  Errors on the stream cause the promise to be rejected.
   *
   * @param {function} [cb=null] - finished/error callback used in *addition*
   *   to the promise
   * @returns {Promise<Buffer|String>} fulfilled when complete
   */
  promise(cb) {
    let done = false
    return new Promise((resolve, reject) => {
      this.on('finish', () => {
        const data = this.read()
        if ((cb != null) && !done) {
          done = true
          cb(null, data)
        }
        resolve(data)
      })
      this.on('error', (er) => {
        if ((cb != null) && !done) {
          done = true
          cb(er)
        }
        reject(er)
      })
    })
  }

  /**
   * Returns a number indicating whether this comes before or after or is the
   * same as the other NoFilter in sort order.
   *
   * @param {NoFilter} other - The other object to compare
   * @returns {Number} -1, 0, 1 for less, equal, greater
   */
  compare(other) {
    if (!(other instanceof NoFilter)) {
      throw new TypeError('Arguments must be NoFilters')
    }
    if (this === other) {
      return 0
    } else {
      const buf1 = this.slice()
      const buf2 = other.slice()
      // these will both be buffers because of the check above.
      if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {
        return buf1.compare(buf2)
      }
      throw new Error('Cannot compare streams in object mode')
    }
  }

  /**
   * Do these NoFilter's contain the same bytes?  Doesn't work if either is
   * in object mode.
   *
   * @param {NoFilter} other
   * @returns {boolean} Equal?
   */
  equals(other) {
    return this.compare(other) === 0
  }

  /**
   * Read bytes or objects without consuming them.  Useful for diagnostics.
   * Note: as a side-effect, concatenates multiple writes together into what
   * looks like a single write, so that this concat doesn't have to happen
   * multiple times when you're futzing with the same NoFilter.
   *
   * @param {Number} [start=0] - beginning offset
   * @param {Number} [end=length] - ending offset
   * @returns {Buffer|Array} if in object mode, an array of objects.  Otherwise,
   *   concatenated array of contents.
   */
  slice(start, end) {
    if (this._readableState.objectMode) {
      return this._bufArray().slice(start, end)
    }
    const bufs = this._bufArray()
    switch (bufs.length) {
      case 0: return Buffer.alloc(0)
      case 1: return bufs[0].slice(start, end)
      default:
        const b = Buffer.concat(bufs)
        // TODO: store the concatented bufs back
        // @_readableState.buffer = [b]
        return b.slice(start, end)
    }
  }

  /**
    * Get a byte by offset.  I didn't want to get into metaprogramming
    * to give you the `NoFilter[0]` syntax.
    *
    * @param {Number} index - The byte to retrieve
    * @returns {Number} 0-255
    */
  get(index) {
    return this.slice()[index]
  }

  /**
   * Return an object compatible with Buffer's toJSON implementation, so
   * that round-tripping will produce a Buffer.
   *
   * @returns {Object}
   *
   * @example output for 'foo'
   *   { type: 'Buffer', data: [ 102, 111, 111 ] }
   */
  toJSON() {
    const b = this.slice()
    if (Buffer.isBuffer(b)) {
      return b.toJSON()
    } else {
      return b
    }
  }

  /**
   * Decodes and returns a string from buffer data encoded using the specified
   * character set encoding. If encoding is undefined or null, then encoding
   * defaults to 'utf8'. The start and end parameters default to 0 and
   * NoFilter.length when undefined.
   *
   * @param {String} [encoding='utf8'] - Which to use for decoding?
   * @param {Number} [start=0] - Start offset
   * @param {Number} [end=length] - End offset
   * @returns {String}
   */
  toString(encoding, start, end) {
    const buf = this.slice(start, end)
    if (!Buffer.isBuffer(buf)) {
      return JSON.stringify(buf)
    }
    if ((!encoding || (encoding === 'utf8')) && util.TextDecoder) {
      const td = new util.TextDecoder('utf8', {
        fatal: true,
        ignoreBOM: true
      })
      return td.decode(buf)
    }
    return buf.toString(encoding, start, end)
  }

  /**
   * @private
   * @deprecated
   */
  inspect(depth, options) {
    return this[util.inspect.custom](depth, options)
  }

  /**
   * @private
   */
  [util.inspect.custom](depth, options) {
    const bufs = this._bufArray()
    const hex = bufs.map((b) => {
      if (Buffer.isBuffer(b)) {
        if ((options != null ? options.stylize : undefined)) {
          return options.stylize(b.toString('hex'), 'string')
        } else {
          return b.toString('hex')
        }
      } else {
        return util.inspect(b, options)
      }
    }).join(', ')
    return `${this.constructor.name} [${hex}]`
  }

  /**
   * Current readable length, in bytes.
   *
   * @member {number}
   * @readonly
   */
  get length() {
    return this._readableState.length
  }

  /**
   * Write a JavaScript BigInt to the stream.  Negative numbers will be
   * written as their 2's complement version.
   *
   * @param {bigint} val - The value to write
   * @returns {boolean} true on success
   */
  writeBigInt(val) {
    let str = val.toString(16)
    if (val < 0) {
      // two's complement
      // Note: str always starts with '-' here.
      const sz = BigInt(Math.floor(str.length / 2))
      const mask = BigInt(1) << (sz * BigInt(8))
      val = mask + val
      str = val.toString(16)
    }
    if (str.length % 2) {
      str = '0' + str
    }
    return this.push(Buffer.from(str, 'hex'))
  }

  /**
   * Read a variable-sized JavaScript unsigned BigInt from the stream.
   *
   * @param {number}  [len=null] - number of bytes to read or all remaining
   *   if null
   * @returns {bigint}
   */
  readUBigInt(len) {
    const b = this.read(len)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return BigInt('0x' + b.toString('hex'))
  }

  /**
   * Read a variable-sized JavaScript signed BigInt from the stream in 2's
   * complement format.
   *
   * @param {number} [len=null] - number of bytes to read or all remaining
   *   if null
   * @returns {bigint}
   */
  readBigInt(len) {
    const b = this.read(len)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    let ret = BigInt('0x' + b.toString('hex'))
    // negative?
    if (b[0] & 0x80) {
      // two's complement
      const mask = BigInt(1) << (BigInt(b.length) * BigInt(8))
      ret = ret - mask
    }
    return ret
  }
}

/**
 * @param {string} meth - method to call
 * @param {number} len - number of bytes to write
 * @private
 */
function _read_gen(meth, len) {
  return function(val) {
    const b = this.read(len)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b[meth].call(b, 0, true)
  }
}

/**
 * @param {string} meth - method to call
 * @param {number} len - number of bytes to write
 * @private
 */
function _write_gen(meth, len) {
  return function(val) {
    const b = Buffer.alloc(len)
    b[meth].call(b, val, 0, true)
    return this.push(b)
  }
}

Object.assign(NoFilter.prototype, {
  /**
   * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.
   *
   * @function writeUInt8
   * @memberOf NoFilter
   * @instance
   * @param {Number} value - 0-255
   * @returns {boolean} true on success
   */
  writeUInt8: _write_gen('writeUInt8', 1),

  /**
   * Write a little-endian 16-bit unsigned integer to the stream.  Adds
   * 2 bytes.
   *
   * @function writeUInt16LE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeUInt16LE: _write_gen('writeUInt16LE', 2),

  /**
   * Write a big-endian 16-bit unsigned integer to the stream.  Adds
   * 2 bytes.
   *
   * @function writeUInt16BE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeUInt16BE: _write_gen('writeUInt16BE', 2),

  /**
   * Write a little-endian 32-bit unsigned integer to the stream.  Adds
   * 4 bytes.
   *
   * @function writeUInt32LE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeUInt32LE: _write_gen('writeUInt32LE', 4),

  /**
   * Write a big-endian 32-bit unsigned integer to the stream.  Adds
   * 4 bytes.
   *
   * @function writeUInt32BE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeUInt32BE: _write_gen('writeUInt32BE', 4),

  /**
   * Write a signed 8-bit integer to the stream.  Adds 1 byte.
   *
   * @function writeInt8
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeInt8: _write_gen('writeInt8', 1),

  /**
   * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.
   *
   * @function writeInt16LE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeInt16LE: _write_gen('writeInt16LE', 2),

  /**
   * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.
   *
   * @function writeInt16BE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeInt16BE: _write_gen('writeInt16BE', 2),

  /**
   * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.
   *
   * @function writeInt32LE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeInt32LE: _write_gen('writeInt32LE', 4),

  /**
   * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.
   *
   * @function writeInt32BE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeInt32BE: _write_gen('writeInt32BE', 4),

  /**
   * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.
   *
   * @function writeFloatLE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeFloatLE: _write_gen('writeFloatLE', 4),

  /**
   * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.
   *
   * @function writeFloatBE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeFloatBE: _write_gen('writeFloatBE', 4),

  /**
   * Write a little-endian 64-bit float to the stream.  Adds 8 bytes.
   *
   * @function writeDoubleLE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeDoubleLE: _write_gen('writeDoubleLE', 8),

  /**
   * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.
   *
   * @function writeDoubleBE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeDoubleBE: _write_gen('writeDoubleBE', 8),

  /**
   * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.
   *
   * @function readUInt8
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readUInt8: _read_gen('readUInt8', 1),

  /**
   * Read a little-endian unsigned 16-bit integer from the stream.
   * Consumes 2 bytes.
   *
   * @function readUInt16LE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readUInt16LE: _read_gen('readUInt16LE', 2),

  /**
   * Read a big-endian unsigned 16-bit integer from the stream.
   * Consumes 2 bytes.
   *
   * @function readUInt16BE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readUInt16BE: _read_gen('readUInt16BE', 2),

  /**
   * Read a little-endian unsigned 32-bit integer from the stream.
   * Consumes 4 bytes.
   *
   * @function readUInt32LE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readUInt32LE: _read_gen('readUInt32LE', 4),

  /**
   * Read a big-endian unsigned 16-bit integer from the stream.
   * Consumes 4 bytes.
   *
   * @function readUInt32BE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readUInt32BE: _read_gen('readUInt32BE', 4),

  /**
   * Read a signed 8-bit integer from the stream.
   * Consumes 1 byte.
   *
   * @function readInt8
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readInt8: _read_gen('readInt8', 1),

  /**
   * Read a signed 16-bit little-endian integer from the stream.
   * Consumes 2 bytes.
   *
   * @function readInt16LE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readInt16LE: _read_gen('readInt16LE', 2),

  /**
   * Read a signed 16-bit big-endian integer from the stream.
   * Consumes 2 bytes.
   *
   * @function readInt16BE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readInt16BE: _read_gen('readInt16BE', 2),

  /**
   * Read a signed 32-bit little-endian integer from the stream.
   * Consumes 4 bytes.
   *
   * @function readInt32LE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readInt32LE: _read_gen('readInt32LE', 4),

  /**
   * Read a signed 32-bit big-endian integer from the stream.
   * Consumes 4 bytes.
   *
   * @function readInt32BE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readInt32BE: _read_gen('readInt32BE', 4),

  /**
   * Read a 32-bit little-endian float from the stream.
   * Consumes 4 bytes.
   *
   * @function readFloatLE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readFloatLE: _read_gen('readFloatLE', 4),

  /**
   * Read a 32-bit big-endian float from the stream.
   * Consumes 4 bytes.
   *
   * @function readFloatBE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readFloatBE: _read_gen('readFloatBE', 4),

  /**
   * Read a 64-bit little-endian float from the stream.
   * Consumes 8 bytes.
   *
   * @function readDoubleLE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readDoubleLE: _read_gen('readDoubleLE', 8),

  /**
   * Read a 64-bit big-endian float from the stream.
   * Consumes 8 bytes.
   *
   * @function readDoubleBE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readDoubleBE: _read_gen('readDoubleBE', 8)
})

module.exports = NoFilter

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@truffle/codec>cbor>nofilter",file:"node_modules\\nofilter\\lib\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\object-is\\implementation.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cobject-is%5Cimplementation.js
      return function (require, module, exports) {
'use strict';

var numberIsNaN = function (value) {
	return value !== value;
};

module.exports = function is(a, b) {
	if (a === 0 && b === 0) {
		return 1 / a === 1 / b;
	}
	if (a === b) {
		return true;
	}
	if (numberIsNaN(a) && numberIsNaN(b)) {
		return true;
	}
	return false;
};


      };
    };
  }
  }
}, {package:"@ngraveio/bc-ur>assert>object-is",file:"node_modules\\object-is\\implementation.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\object-is\\index.js", {"./implementation":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\object-is\\implementation.js","./polyfill":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\object-is\\polyfill.js","./shim":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\object-is\\shim.js","call-bind":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\call-bind\\index.js","define-properties":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\define-properties\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cobject-is%5Cindex.js
      return function (require, module, exports) {
'use strict';

var define = require('define-properties');
var callBind = require('call-bind');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');

var polyfill = callBind(getPolyfill(), Object);

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;

      };
    };
  }
  }
}, {package:"@ngraveio/bc-ur>assert>object-is",file:"node_modules\\object-is\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\object-is\\polyfill.js", {"./implementation":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\object-is\\implementation.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cobject-is%5Cpolyfill.js
      return function (require, module, exports) {
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	return typeof Object.is === 'function' ? Object.is : implementation;
};

      };
    };
  }
  }
}, {package:"@ngraveio/bc-ur>assert>object-is",file:"node_modules\\object-is\\polyfill.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\object-is\\shim.js", {"./polyfill":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\object-is\\polyfill.js","define-properties":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\define-properties\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cobject-is%5Cshim.js
      return function (require, module, exports) {
'use strict';

var getPolyfill = require('./polyfill');
var define = require('define-properties');

module.exports = function shimObjectIs() {
	var polyfill = getPolyfill();
	define(Object, { is: polyfill }, {
		is: function testObjectIs() {
			return Object.is !== polyfill;
		}
	});
	return polyfill;
};

      };
    };
  }
  }
}, {package:"@ngraveio/bc-ur>assert>object-is",file:"node_modules\\object-is\\shim.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\object-keys\\implementation.js", {"./isArguments":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\object-keys\\isArguments.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cobject-keys%5Cimplementation.js
      return function (require, module, exports) {
'use strict';

var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = require('./isArguments'); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;

      };
    };
  }
  }
}, {package:"globalthis>define-properties>object-keys",file:"node_modules\\object-keys\\implementation.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\object-keys\\index.js", {"./implementation":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\object-keys\\implementation.js","./isArguments":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\object-keys\\isArguments.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cobject-keys%5Cindex.js
      return function (require, module, exports) {
'use strict';

var slice = Array.prototype.slice;
var isArgs = require('./isArguments');

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : require('./implementation');

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

      };
    };
  }
  }
}, {package:"globalthis>define-properties>object-keys",file:"node_modules\\object-keys\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\object-keys\\isArguments.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cobject-keys%5CisArguments.js
      return function (require, module, exports) {
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

      };
    };
  }
  }
}, {package:"globalthis>define-properties>object-keys",file:"node_modules\\object-keys\\isArguments.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\os-browserify\\browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cos-browserify%5Cbrowser.js
      return function (require, module, exports) {
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

exports.homedir = function () {
	return '/'
};

      };
    };
  }
  }
}, {package:"browserify>os-browserify",file:"node_modules\\os-browserify\\browser.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\param-case\\param-case.js", {"no-case":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\no-case\\no-case.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cparam-case%5Cparam-case.js
      return function (require, module, exports) {
var noCase = require('no-case')

/**
 * Param case a string.
 *
 * @param  {string} value
 * @param  {string} [locale]
 * @return {string}
 */
module.exports = function (value, locale) {
  return noCase(value, locale, '-')
}

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>param-case",file:"node_modules\\param-case\\param-case.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pascal-case\\pascal-case.js", {"camel-case":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\camel-case\\camel-case.js","upper-case-first":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\upper-case-first\\upper-case-first.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cpascal-case%5Cpascal-case.js
      return function (require, module, exports) {
var camelCase = require('camel-case')
var upperCaseFirst = require('upper-case-first')

/**
 * Pascal case a string.
 *
 * @param  {string}  value
 * @param  {string}  [locale]
 * @param  {boolean} [mergeNumbers]
 * @return {string}
 */
module.exports = function (value, locale, mergeNumbers) {
  return upperCaseFirst(camelCase(value, locale, mergeNumbers), locale)
}

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>pascal-case",file:"node_modules\\pascal-case\\pascal-case.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\path-case\\path-case.js", {"no-case":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\no-case\\no-case.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cpath-case%5Cpath-case.js
      return function (require, module, exports) {
var noCase = require('no-case')

/**
 * Path case a string.
 *
 * @param  {string} value
 * @param  {string} [locale]
 * @return {string}
 */
module.exports = function (value, locale) {
  return noCase(value, locale, '/')
}

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>path-case",file:"node_modules\\path-case\\path-case.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\path-to-regexp\\index.js", {"isarray":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\path-to-regexp\\node_modules\\isarray\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cpath-to-regexp%5Cindex.js
      return function (require, module, exports) {
var isarray = require('isarray')

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp
module.exports.parse = parse
module.exports.compile = compile
module.exports.tokensToFunction = tokensToFunction
module.exports.tokensToRegExp = tokensToRegExp

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g')

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = []
  var key = 0
  var index = 0
  var path = ''
  var defaultDelimiter = options && options.delimiter || '/'
  var res

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0]
    var escaped = res[1]
    var offset = res.index
    path += str.slice(index, offset)
    index = offset + m.length

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1]
      continue
    }

    var next = str[index]
    var prefix = res[2]
    var name = res[3]
    var capture = res[4]
    var group = res[5]
    var modifier = res[6]
    var asterisk = res[7]

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path)
      path = ''
    }

    var partial = prefix != null && next != null && next !== prefix
    var repeat = modifier === '+' || modifier === '*'
    var optional = modifier === '?' || modifier === '*'
    var delimiter = res[2] || defaultDelimiter
    var pattern = capture || group

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    })
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index)
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path)
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options))
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length)

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')
    }
  }

  return function (obj, opts) {
    var path = ''
    var data = obj || {}
    var options = opts || {}
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i]

      if (typeof token === 'string') {
        path += token

        continue
      }

      var value = data[token.name]
      var segment

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j])

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value)

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g)

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      })
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = []

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source)
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  var strict = options.strict
  var end = options.end !== false
  var route = ''

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i]

    if (typeof token === 'string') {
      route += escapeString(token)
    } else {
      var prefix = escapeString(token.prefix)
      var capture = '(?:' + token.pattern + ')'

      keys.push(token)

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*'
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?'
        } else {
          capture = prefix + '(' + capture + ')?'
        }
      } else {
        capture = prefix + '(' + capture + ')'
      }

      route += capture
    }
  }

  var delimiter = escapeString(options.delimiter || '/')
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'
  }

  if (end) {
    route += '$'
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}

      };
    };
  }
  }
}, {package:"sinon>nise>path-to-regexp",file:"node_modules\\path-to-regexp\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\path-to-regexp\\node_modules\\isarray\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cpath-to-regexp%5Cnode_modules%5Cisarray%5Cindex.js
      return function (require, module, exports) {
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

      };
    };
  }
  }
}, {package:"sinon>nise>path-to-regexp>isarray",file:"node_modules\\path-to-regexp\\node_modules\\isarray\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\popper.js\\dist\\umd\\popper.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cpopper.js%5Cdist%5Cumd%5Cpopper.js
      return function (require, module, exports) {
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.15.0
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Popper = factory());
}(this, (function () { 'use strict';

var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';

var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
var timeoutDuration = 0;
for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
    timeoutDuration = 1;
    break;
  }
}

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null;

  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent || null;
  // Skip hidden elements which don't have an offsetParent
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }

  // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.right - result.left;
  var height = sizes.height || element.clientHeight || result.bottom - result.top;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop, 10);
    var marginLeft = parseFloat(styles.marginLeft, 10);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  var parentNode = getParentNode(element);
  if (!parentNode) {
    return false;
  }
  return isFixed(parentNode);
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }
  return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  // NOTE: 1 DOM access here

  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  data.positionFixed = this.options.positionFixed;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicity asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */
function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var round = Math.round,
      floor = Math.floor;

  var noRound = function noRound(v) {
    return v;
  };

  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);

  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;

  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;

    // flips variation if reference element overflows boundaries
    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    // flips variation if popper content overflows boundaries
    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);

    var flippedVariation = flippedVariationByRef || flippedVariationByContent;

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself
  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification
  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];

  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

  // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;

  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport',
    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,
    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

return Popper;

})));
//# sourceMappingURL=popper.js.map

      };
    };
  }
  }
}, {package:"react-tippy>popper.js",file:"node_modules\\popper.js\\dist\\umd\\popper.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\prop-types\\checkPropTypes.js", {"./lib/ReactPropTypesSecret":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\prop-types\\lib\\ReactPropTypesSecret.js","./lib/has":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\prop-types\\lib\\has.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cprop-types%5CcheckPropTypes.js
      return function (require, module, exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var printWarning = function() {};

if ("development" !== 'production') {
  var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');
  var loggedTypeFailures = {};
  var has = require('./lib/has');

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) { /**/ }
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if ("development" !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +
              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if ("development" !== 'production') {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;

      };
    };
  }
  }
}, {package:"prop-types",file:"node_modules\\prop-types\\checkPropTypes.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\prop-types\\factoryWithThrowingShims.js", {"./lib/ReactPropTypesSecret":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\prop-types\\lib\\ReactPropTypesSecret.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cprop-types%5CfactoryWithThrowingShims.js
      return function (require, module, exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');

function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

      };
    };
  }
  }
}, {package:"prop-types",file:"node_modules\\prop-types\\factoryWithThrowingShims.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\prop-types\\factoryWithTypeCheckers.js", {"./checkPropTypes":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\prop-types\\checkPropTypes.js","./lib/ReactPropTypesSecret":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\prop-types\\lib\\ReactPropTypesSecret.js","./lib/has":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\prop-types\\lib\\has.js","object-assign":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\object-assign\\index.js","react-is":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\react-is\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cprop-types%5CfactoryWithTypeCheckers.js
      return function (require, module, exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var ReactIs = require('react-is');
var assign = require('object-assign');

var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');
var has = require('./lib/has');
var checkPropTypes = require('./checkPropTypes');

var printWarning = function() {};

if ("development" !== 'production') {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bigint: createPrimitiveTypeChecker('bigint'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message, data) {
    this.message = message;
    this.data = data && typeof data === 'object' ? data: {};
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if ("development" !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ("development" !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError(
          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),
          {expectedType: expectedType}
        );
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if ("development" !== 'production') {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      "development" !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      var expectedTypes = [];
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
        if (checkerResult == null) {
          return null;
        }
        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
          expectedTypes.push(checkerResult.data.expectedType);
        }
      }
      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function invalidValidatorError(componentName, location, propFullName, key, type) {
    return new PropTypeError(
      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +
      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'
    );
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (typeof checker !== 'function') {
          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (has(shapeTypes, key) && typeof checker !== 'function') {
          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
        }
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

      };
    };
  }
  }
}, {package:"prop-types",file:"node_modules\\prop-types\\factoryWithTypeCheckers.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\prop-types\\index.js", {"./factoryWithThrowingShims":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\prop-types\\factoryWithThrowingShims.js","./factoryWithTypeCheckers":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\prop-types\\factoryWithTypeCheckers.js","react-is":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\react-is\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cprop-types%5Cindex.js
      return function (require, module, exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if ("development" !== 'production') {
  var ReactIs = require('react-is');

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(ReactIs.isElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = require('./factoryWithThrowingShims')();
}

      };
    };
  }
  }
}, {package:"prop-types",file:"node_modules\\prop-types\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\prop-types\\lib\\ReactPropTypesSecret.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cprop-types%5Clib%5CReactPropTypesSecret.js
      return function (require, module, exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

      };
    };
  }
  }
}, {package:"prop-types",file:"node_modules\\prop-types\\lib\\ReactPropTypesSecret.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\prop-types\\lib\\has.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cprop-types%5Clib%5Chas.js
      return function (require, module, exports) {
module.exports = Function.call.bind(Object.prototype.hasOwnProperty);

      };
    };
  }
  }
}, {package:"prop-types",file:"node_modules\\prop-types\\lib\\has.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\UniformArrayIntDistribution.js", {"./UnsafeUniformArrayIntDistribution":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformArrayIntDistribution.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cpure-rand%5Clib%5Cdistribution%5CUniformArrayIntDistribution.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.uniformArrayIntDistribution = void 0;
var UnsafeUniformArrayIntDistribution_1 = require("./UnsafeUniformArrayIntDistribution");
function uniformArrayIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [(0, UnsafeUniformArrayIntDistribution_1.unsafeUniformArrayIntDistribution)(from, to, nextRng), nextRng];
    }
    return function (rng) {
        var nextRng = rng.clone();
        return [(0, UnsafeUniformArrayIntDistribution_1.unsafeUniformArrayIntDistribution)(from, to, nextRng), nextRng];
    };
}
exports.uniformArrayIntDistribution = uniformArrayIntDistribution;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\distribution\\UniformArrayIntDistribution.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\UniformBigIntDistribution.js", {"./UnsafeUniformBigIntDistribution":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformBigIntDistribution.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cpure-rand%5Clib%5Cdistribution%5CUniformBigIntDistribution.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.uniformBigIntDistribution = void 0;
var UnsafeUniformBigIntDistribution_1 = require("./UnsafeUniformBigIntDistribution");
function uniformBigIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [(0, UnsafeUniformBigIntDistribution_1.unsafeUniformBigIntDistribution)(from, to, nextRng), nextRng];
    }
    return function (rng) {
        var nextRng = rng.clone();
        return [(0, UnsafeUniformBigIntDistribution_1.unsafeUniformBigIntDistribution)(from, to, nextRng), nextRng];
    };
}
exports.uniformBigIntDistribution = uniformBigIntDistribution;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\distribution\\UniformBigIntDistribution.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\UniformIntDistribution.js", {"./UnsafeUniformIntDistribution":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformIntDistribution.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cpure-rand%5Clib%5Cdistribution%5CUniformIntDistribution.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.uniformIntDistribution = void 0;
var UnsafeUniformIntDistribution_1 = require("./UnsafeUniformIntDistribution");
function uniformIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [(0, UnsafeUniformIntDistribution_1.unsafeUniformIntDistribution)(from, to, nextRng), nextRng];
    }
    return function (rng) {
        var nextRng = rng.clone();
        return [(0, UnsafeUniformIntDistribution_1.unsafeUniformIntDistribution)(from, to, nextRng), nextRng];
    };
}
exports.uniformIntDistribution = uniformIntDistribution;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\distribution\\UniformIntDistribution.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformArrayIntDistribution.js", {"./internals/ArrayInt":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\internals\\ArrayInt.js","./internals/UnsafeUniformArrayIntDistributionInternal":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\internals\\UnsafeUniformArrayIntDistributionInternal.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cpure-rand%5Clib%5Cdistribution%5CUnsafeUniformArrayIntDistribution.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.unsafeUniformArrayIntDistribution = void 0;
var ArrayInt_1 = require("./internals/ArrayInt");
var UnsafeUniformArrayIntDistributionInternal_1 = require("./internals/UnsafeUniformArrayIntDistributionInternal");
function unsafeUniformArrayIntDistribution(from, to, rng) {
    var rangeSize = (0, ArrayInt_1.trimArrayIntInplace)((0, ArrayInt_1.addOneToPositiveArrayInt)((0, ArrayInt_1.substractArrayIntToNew)(to, from)));
    var emptyArrayIntData = rangeSize.data.slice(0);
    var g = (0, UnsafeUniformArrayIntDistributionInternal_1.unsafeUniformArrayIntDistributionInternal)(emptyArrayIntData, rangeSize.data, rng);
    return (0, ArrayInt_1.trimArrayIntInplace)((0, ArrayInt_1.addArrayIntToNew)({ sign: 1, data: g }, from));
}
exports.unsafeUniformArrayIntDistribution = unsafeUniformArrayIntDistribution;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformArrayIntDistribution.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformBigIntDistribution.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cpure-rand%5Clib%5Cdistribution%5CUnsafeUniformBigIntDistribution.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.unsafeUniformBigIntDistribution = void 0;
var SBigInt = typeof BigInt !== 'undefined' ? BigInt : undefined;
function unsafeUniformBigIntDistribution(from, to, rng) {
    var diff = to - from + SBigInt(1);
    var MinRng = SBigInt(rng.min());
    var NumValues = SBigInt(rng.max() - rng.min() + 1);
    var FinalNumValues = NumValues;
    var NumIterations = SBigInt(1);
    while (FinalNumValues < diff) {
        FinalNumValues *= NumValues;
        ++NumIterations;
    }
    var MaxAcceptedRandom = FinalNumValues - (FinalNumValues % diff);
    while (true) {
        var value = SBigInt(0);
        for (var num = SBigInt(0); num !== NumIterations; ++num) {
            var out = rng.unsafeNext();
            value = NumValues * value + (SBigInt(out) - MinRng);
        }
        if (value < MaxAcceptedRandom) {
            var inDiff = value % diff;
            return inDiff + from;
        }
    }
}
exports.unsafeUniformBigIntDistribution = unsafeUniformBigIntDistribution;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformBigIntDistribution.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformIntDistribution.js", {"./internals/ArrayInt":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\internals\\ArrayInt.js","./internals/UnsafeUniformArrayIntDistributionInternal":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\internals\\UnsafeUniformArrayIntDistributionInternal.js","./internals/UnsafeUniformIntDistributionInternal":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\internals\\UnsafeUniformIntDistributionInternal.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cpure-rand%5Clib%5Cdistribution%5CUnsafeUniformIntDistribution.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.unsafeUniformIntDistribution = void 0;
var UnsafeUniformIntDistributionInternal_1 = require("./internals/UnsafeUniformIntDistributionInternal");
var ArrayInt_1 = require("./internals/ArrayInt");
var UnsafeUniformArrayIntDistributionInternal_1 = require("./internals/UnsafeUniformArrayIntDistributionInternal");
var safeNumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;
var sharedA = { sign: 1, data: [0, 0] };
var sharedB = { sign: 1, data: [0, 0] };
var sharedC = { sign: 1, data: [0, 0] };
var sharedData = [0, 0];
function uniformLargeIntInternal(from, to, rangeSize, rng) {
    var rangeSizeArrayIntValue = rangeSize <= safeNumberMaxSafeInteger
        ? (0, ArrayInt_1.fromNumberToArrayInt64)(sharedC, rangeSize)
        : (0, ArrayInt_1.substractArrayInt64)(sharedC, (0, ArrayInt_1.fromNumberToArrayInt64)(sharedA, to), (0, ArrayInt_1.fromNumberToArrayInt64)(sharedB, from));
    if (rangeSizeArrayIntValue.data[1] === 0xffffffff) {
        rangeSizeArrayIntValue.data[0] += 1;
        rangeSizeArrayIntValue.data[1] = 0;
    }
    else {
        rangeSizeArrayIntValue.data[1] += 1;
    }
    (0, UnsafeUniformArrayIntDistributionInternal_1.unsafeUniformArrayIntDistributionInternal)(sharedData, rangeSizeArrayIntValue.data, rng);
    return sharedData[0] * 0x100000000 + sharedData[1] + from;
}
function unsafeUniformIntDistribution(from, to, rng) {
    var rangeSize = to - from;
    if (rangeSize <= 0xffffffff) {
        var g = (0, UnsafeUniformIntDistributionInternal_1.unsafeUniformIntDistributionInternal)(rangeSize + 1, rng);
        return g + from;
    }
    return uniformLargeIntInternal(from, to, rangeSize, rng);
}
exports.unsafeUniformIntDistribution = unsafeUniformIntDistribution;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformIntDistribution.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\internals\\ArrayInt.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cpure-rand%5Clib%5Cdistribution%5Cinternals%5CArrayInt.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.substractArrayInt64 = exports.fromNumberToArrayInt64 = exports.trimArrayIntInplace = exports.substractArrayIntToNew = exports.addOneToPositiveArrayInt = exports.addArrayIntToNew = void 0;
function addArrayIntToNew(arrayIntA, arrayIntB) {
    if (arrayIntA.sign !== arrayIntB.sign) {
        return substractArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
    }
    var data = [];
    var reminder = 0;
    var dataA = arrayIntA.data;
    var dataB = arrayIntB.data;
    for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        var current = vA + vB + reminder;
        data.push(current >>> 0);
        reminder = ~~(current / 0x100000000);
    }
    if (reminder !== 0) {
        data.push(reminder);
    }
    return { sign: arrayIntA.sign, data: data.reverse() };
}
exports.addArrayIntToNew = addArrayIntToNew;
function addOneToPositiveArrayInt(arrayInt) {
    arrayInt.sign = 1;
    var data = arrayInt.data;
    for (var index = data.length - 1; index >= 0; --index) {
        if (data[index] === 0xffffffff) {
            data[index] = 0;
        }
        else {
            data[index] += 1;
            return arrayInt;
        }
    }
    data.unshift(1);
    return arrayInt;
}
exports.addOneToPositiveArrayInt = addOneToPositiveArrayInt;
function isStrictlySmaller(dataA, dataB) {
    var maxLength = Math.max(dataA.length, dataB.length);
    for (var index = 0; index < maxLength; ++index) {
        var indexA = index + dataA.length - maxLength;
        var indexB = index + dataB.length - maxLength;
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        if (vA < vB)
            return true;
        if (vA > vB)
            return false;
    }
    return false;
}
function substractArrayIntToNew(arrayIntA, arrayIntB) {
    if (arrayIntA.sign !== arrayIntB.sign) {
        return addArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
    }
    var dataA = arrayIntA.data;
    var dataB = arrayIntB.data;
    if (isStrictlySmaller(dataA, dataB)) {
        var out = substractArrayIntToNew(arrayIntB, arrayIntA);
        out.sign = -out.sign;
        return out;
    }
    var data = [];
    var reminder = 0;
    for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        var current = vA - vB - reminder;
        data.push(current >>> 0);
        reminder = current < 0 ? 1 : 0;
    }
    return { sign: arrayIntA.sign, data: data.reverse() };
}
exports.substractArrayIntToNew = substractArrayIntToNew;
function trimArrayIntInplace(arrayInt) {
    var data = arrayInt.data;
    var firstNonZero = 0;
    for (; firstNonZero !== data.length && data[firstNonZero] === 0; ++firstNonZero) { }
    if (firstNonZero === data.length) {
        arrayInt.sign = 1;
        arrayInt.data = [0];
        return arrayInt;
    }
    data.splice(0, firstNonZero);
    return arrayInt;
}
exports.trimArrayIntInplace = trimArrayIntInplace;
function fromNumberToArrayInt64(out, n) {
    if (n < 0) {
        var posN = -n;
        out.sign = -1;
        out.data[0] = ~~(posN / 0x100000000);
        out.data[1] = posN >>> 0;
    }
    else {
        out.sign = 1;
        out.data[0] = ~~(n / 0x100000000);
        out.data[1] = n >>> 0;
    }
    return out;
}
exports.fromNumberToArrayInt64 = fromNumberToArrayInt64;
function substractArrayInt64(out, arrayIntA, arrayIntB) {
    var lowA = arrayIntA.data[1];
    var highA = arrayIntA.data[0];
    var signA = arrayIntA.sign;
    var lowB = arrayIntB.data[1];
    var highB = arrayIntB.data[0];
    var signB = arrayIntB.sign;
    out.sign = 1;
    if (signA === 1 && signB === -1) {
        var low_1 = lowA + lowB;
        var high = highA + highB + (low_1 > 0xffffffff ? 1 : 0);
        out.data[0] = high >>> 0;
        out.data[1] = low_1 >>> 0;
        return out;
    }
    var lowFirst = lowA;
    var highFirst = highA;
    var lowSecond = lowB;
    var highSecond = highB;
    if (signA === -1) {
        lowFirst = lowB;
        highFirst = highB;
        lowSecond = lowA;
        highSecond = highA;
    }
    var reminderLow = 0;
    var low = lowFirst - lowSecond;
    if (low < 0) {
        reminderLow = 1;
        low = low >>> 0;
    }
    out.data[0] = highFirst - highSecond - reminderLow;
    out.data[1] = low;
    return out;
}
exports.substractArrayInt64 = substractArrayInt64;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\distribution\\internals\\ArrayInt.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\internals\\UnsafeUniformArrayIntDistributionInternal.js", {"./UnsafeUniformIntDistributionInternal":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\internals\\UnsafeUniformIntDistributionInternal.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cpure-rand%5Clib%5Cdistribution%5Cinternals%5CUnsafeUniformArrayIntDistributionInternal.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.unsafeUniformArrayIntDistributionInternal = void 0;
var UnsafeUniformIntDistributionInternal_1 = require("./UnsafeUniformIntDistributionInternal");
function unsafeUniformArrayIntDistributionInternal(out, rangeSize, rng) {
    var rangeLength = rangeSize.length;
    while (true) {
        for (var index = 0; index !== rangeLength; ++index) {
            var indexRangeSize = index === 0 ? rangeSize[0] + 1 : 0x100000000;
            var g = (0, UnsafeUniformIntDistributionInternal_1.unsafeUniformIntDistributionInternal)(indexRangeSize, rng);
            out[index] = g;
        }
        for (var index = 0; index !== rangeLength; ++index) {
            var current = out[index];
            var currentInRange = rangeSize[index];
            if (current < currentInRange) {
                return out;
            }
            else if (current > currentInRange) {
                break;
            }
        }
    }
}
exports.unsafeUniformArrayIntDistributionInternal = unsafeUniformArrayIntDistributionInternal;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\distribution\\internals\\UnsafeUniformArrayIntDistributionInternal.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\internals\\UnsafeUniformIntDistributionInternal.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cpure-rand%5Clib%5Cdistribution%5Cinternals%5CUnsafeUniformIntDistributionInternal.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.unsafeUniformIntDistributionInternal = void 0;
function unsafeUniformIntDistributionInternal(rangeSize, rng) {
    var MinRng = rng.min();
    var NumValues = rng.max() - rng.min() + 1;
    if (rangeSize <= NumValues) {
        var nrng_1 = rng;
        var MaxAllowed = NumValues - (NumValues % rangeSize);
        while (true) {
            var out = nrng_1.unsafeNext();
            var deltaV = out - MinRng;
            if (deltaV < MaxAllowed) {
                return deltaV % rangeSize;
            }
        }
    }
    var FinalNumValues = NumValues * NumValues;
    var NumIterations = 2;
    while (FinalNumValues < rangeSize) {
        FinalNumValues *= NumValues;
        ++NumIterations;
    }
    var MaxAcceptedRandom = rangeSize * Math.floor((1 * FinalNumValues) / rangeSize);
    var nrng = rng;
    while (true) {
        var value = 0;
        for (var num = 0; num !== NumIterations; ++num) {
            var out = nrng.unsafeNext();
            value = NumValues * value + (out - MinRng);
        }
        if (value < MaxAcceptedRandom) {
            var inDiff = value - rangeSize * Math.floor((1 * value) / rangeSize);
            return inDiff;
        }
    }
}
exports.unsafeUniformIntDistributionInternal = unsafeUniformIntDistributionInternal;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\distribution\\internals\\UnsafeUniformIntDistributionInternal.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\generator\\LinearCongruential.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cpure-rand%5Clib%5Cgenerator%5CLinearCongruential.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.congruential32 = exports.congruential = void 0;
var MULTIPLIER = 0x000343fd;
var INCREMENT = 0x00269ec3;
var MASK = 0xffffffff;
var MASK_2 = (1 << 31) - 1;
var computeNextSeed = function (seed) {
    return (seed * MULTIPLIER + INCREMENT) & MASK;
};
var computeValueFromNextSeed = function (nextseed) {
    return (nextseed & MASK_2) >> 16;
};
var LinearCongruential = (function () {
    function LinearCongruential(seed) {
        this.seed = seed;
    }
    LinearCongruential.prototype.min = function () {
        return LinearCongruential.min;
    };
    LinearCongruential.prototype.max = function () {
        return LinearCongruential.max;
    };
    LinearCongruential.prototype.clone = function () {
        return new LinearCongruential(this.seed);
    };
    LinearCongruential.prototype.next = function () {
        var nextRng = new LinearCongruential(this.seed);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    LinearCongruential.prototype.unsafeNext = function () {
        this.seed = computeNextSeed(this.seed);
        return computeValueFromNextSeed(this.seed);
    };
    LinearCongruential.min = 0;
    LinearCongruential.max = Math.pow(2, 15) - 1;
    return LinearCongruential;
}());
var LinearCongruential32 = (function () {
    function LinearCongruential32(seed) {
        this.seed = seed;
    }
    LinearCongruential32.prototype.min = function () {
        return LinearCongruential32.min;
    };
    LinearCongruential32.prototype.max = function () {
        return LinearCongruential32.max;
    };
    LinearCongruential32.prototype.clone = function () {
        return new LinearCongruential32(this.seed);
    };
    LinearCongruential32.prototype.next = function () {
        var nextRng = new LinearCongruential32(this.seed);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    LinearCongruential32.prototype.unsafeNext = function () {
        var s1 = computeNextSeed(this.seed);
        var v1 = computeValueFromNextSeed(s1);
        var s2 = computeNextSeed(s1);
        var v2 = computeValueFromNextSeed(s2);
        this.seed = computeNextSeed(s2);
        var v3 = computeValueFromNextSeed(this.seed);
        var vnext = v3 + ((v2 + (v1 << 15)) << 15);
        return ((vnext + 0x80000000) | 0) + 0x80000000;
    };
    LinearCongruential32.min = 0;
    LinearCongruential32.max = 0xffffffff;
    return LinearCongruential32;
}());
var congruential = function (seed) {
    return new LinearCongruential(seed);
};
exports.congruential = congruential;
var congruential32 = function (seed) {
    return new LinearCongruential32(seed);
};
exports.congruential32 = congruential32;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\generator\\LinearCongruential.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\generator\\MersenneTwister.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cpure-rand%5Clib%5Cgenerator%5CMersenneTwister.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
var MersenneTwister = (function () {
    function MersenneTwister(states, index) {
        this.states = states;
        this.index = index;
    }
    MersenneTwister.twist = function (prev) {
        var mt = prev.slice();
        for (var idx = 0; idx !== MersenneTwister.N - MersenneTwister.M; ++idx) {
            var y_1 = (mt[idx] & MersenneTwister.MASK_UPPER) + (mt[idx + 1] & MersenneTwister.MASK_LOWER);
            mt[idx] = mt[idx + MersenneTwister.M] ^ (y_1 >>> 1) ^ (-(y_1 & 1) & MersenneTwister.A);
        }
        for (var idx = MersenneTwister.N - MersenneTwister.M; idx !== MersenneTwister.N - 1; ++idx) {
            var y_2 = (mt[idx] & MersenneTwister.MASK_UPPER) + (mt[idx + 1] & MersenneTwister.MASK_LOWER);
            mt[idx] = mt[idx + MersenneTwister.M - MersenneTwister.N] ^ (y_2 >>> 1) ^ (-(y_2 & 1) & MersenneTwister.A);
        }
        var y = (mt[MersenneTwister.N - 1] & MersenneTwister.MASK_UPPER) + (mt[0] & MersenneTwister.MASK_LOWER);
        mt[MersenneTwister.N - 1] = mt[MersenneTwister.M - 1] ^ (y >>> 1) ^ (-(y & 1) & MersenneTwister.A);
        return mt;
    };
    MersenneTwister.seeded = function (seed) {
        var out = Array(MersenneTwister.N);
        out[0] = seed;
        for (var idx = 1; idx !== MersenneTwister.N; ++idx) {
            var xored = out[idx - 1] ^ (out[idx - 1] >>> 30);
            out[idx] = (Math.imul(MersenneTwister.F, xored) + idx) | 0;
        }
        return out;
    };
    MersenneTwister.from = function (seed) {
        return new MersenneTwister(MersenneTwister.twist(MersenneTwister.seeded(seed)), 0);
    };
    MersenneTwister.prototype.min = function () {
        return MersenneTwister.min;
    };
    MersenneTwister.prototype.max = function () {
        return MersenneTwister.max;
    };
    MersenneTwister.prototype.clone = function () {
        return new MersenneTwister(this.states, this.index);
    };
    MersenneTwister.prototype.next = function () {
        var nextRng = new MersenneTwister(this.states, this.index);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    MersenneTwister.prototype.unsafeNext = function () {
        var y = this.states[this.index];
        y ^= this.states[this.index] >>> MersenneTwister.U;
        y ^= (y << MersenneTwister.S) & MersenneTwister.B;
        y ^= (y << MersenneTwister.T) & MersenneTwister.C;
        y ^= y >>> MersenneTwister.L;
        if (++this.index >= MersenneTwister.N) {
            this.states = MersenneTwister.twist(this.states);
            this.index = 0;
        }
        return y >>> 0;
    };
    MersenneTwister.min = 0;
    MersenneTwister.max = 0xffffffff;
    MersenneTwister.N = 624;
    MersenneTwister.M = 397;
    MersenneTwister.R = 31;
    MersenneTwister.A = 0x9908b0df;
    MersenneTwister.F = 1812433253;
    MersenneTwister.U = 11;
    MersenneTwister.S = 7;
    MersenneTwister.B = 0x9d2c5680;
    MersenneTwister.T = 15;
    MersenneTwister.C = 0xefc60000;
    MersenneTwister.L = 18;
    MersenneTwister.MASK_LOWER = Math.pow(2, MersenneTwister.R) - 1;
    MersenneTwister.MASK_UPPER = Math.pow(2, MersenneTwister.R);
    return MersenneTwister;
}());
function default_1(seed) {
    return MersenneTwister.from(seed);
}
exports["default"] = default_1;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\generator\\MersenneTwister.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\generator\\RandomGenerator.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cpure-rand%5Clib%5Cgenerator%5CRandomGenerator.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.skipN = exports.unsafeSkipN = exports.generateN = exports.unsafeGenerateN = void 0;
function unsafeGenerateN(rng, num) {
    var out = [];
    for (var idx = 0; idx != num; ++idx) {
        out.push(rng.unsafeNext());
    }
    return out;
}
exports.unsafeGenerateN = unsafeGenerateN;
function generateN(rng, num) {
    var nextRng = rng.clone();
    var out = unsafeGenerateN(nextRng, num);
    return [out, nextRng];
}
exports.generateN = generateN;
function unsafeSkipN(rng, num) {
    for (var idx = 0; idx != num; ++idx) {
        rng.unsafeNext();
    }
}
exports.unsafeSkipN = unsafeSkipN;
function skipN(rng, num) {
    var nextRng = rng.clone();
    unsafeSkipN(nextRng, num);
    return nextRng;
}
exports.skipN = skipN;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\generator\\RandomGenerator.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\generator\\XorShift.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cpure-rand%5Clib%5Cgenerator%5CXorShift.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.xorshift128plus = void 0;
var XorShift128Plus = (function () {
    function XorShift128Plus(s01, s00, s11, s10) {
        this.s01 = s01;
        this.s00 = s00;
        this.s11 = s11;
        this.s10 = s10;
    }
    XorShift128Plus.prototype.min = function () {
        return -0x80000000;
    };
    XorShift128Plus.prototype.max = function () {
        return 0x7fffffff;
    };
    XorShift128Plus.prototype.clone = function () {
        return new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
    };
    XorShift128Plus.prototype.next = function () {
        var nextRng = new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    XorShift128Plus.prototype.unsafeNext = function () {
        var a0 = this.s00 ^ (this.s00 << 23);
        var a1 = this.s01 ^ ((this.s01 << 23) | (this.s00 >>> 9));
        var b0 = a0 ^ this.s10 ^ ((a0 >>> 18) | (a1 << 14)) ^ ((this.s10 >>> 5) | (this.s11 << 27));
        var b1 = a1 ^ this.s11 ^ (a1 >>> 18) ^ (this.s11 >>> 5);
        var out = (this.s00 + this.s10) | 0;
        this.s01 = this.s11;
        this.s00 = this.s10;
        this.s11 = b1;
        this.s10 = b0;
        return out;
    };
    XorShift128Plus.prototype.jump = function () {
        var nextRng = new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
        nextRng.unsafeJump();
        return nextRng;
    };
    XorShift128Plus.prototype.unsafeJump = function () {
        var ns01 = 0;
        var ns00 = 0;
        var ns11 = 0;
        var ns10 = 0;
        var jump = [0x635d2dff, 0x8a5cd789, 0x5c472f96, 0x121fd215];
        for (var i = 0; i !== 4; ++i) {
            for (var mask = 1; mask; mask <<= 1) {
                if (jump[i] & mask) {
                    ns01 ^= this.s01;
                    ns00 ^= this.s00;
                    ns11 ^= this.s11;
                    ns10 ^= this.s10;
                }
                this.unsafeNext();
            }
        }
        this.s01 = ns01;
        this.s00 = ns00;
        this.s11 = ns11;
        this.s10 = ns10;
    };
    return XorShift128Plus;
}());
var xorshift128plus = function (seed) {
    return new XorShift128Plus(-1, ~seed, seed | 0, 0);
};
exports.xorshift128plus = xorshift128plus;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\generator\\XorShift.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\generator\\XoroShiro.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cpure-rand%5Clib%5Cgenerator%5CXoroShiro.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.xoroshiro128plus = void 0;
var XoroShiro128Plus = (function () {
    function XoroShiro128Plus(s01, s00, s11, s10) {
        this.s01 = s01;
        this.s00 = s00;
        this.s11 = s11;
        this.s10 = s10;
    }
    XoroShiro128Plus.prototype.min = function () {
        return -0x80000000;
    };
    XoroShiro128Plus.prototype.max = function () {
        return 0x7fffffff;
    };
    XoroShiro128Plus.prototype.clone = function () {
        return new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
    };
    XoroShiro128Plus.prototype.next = function () {
        var nextRng = new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    XoroShiro128Plus.prototype.unsafeNext = function () {
        var out = (this.s00 + this.s10) | 0;
        var a0 = this.s10 ^ this.s00;
        var a1 = this.s11 ^ this.s01;
        var s00 = this.s00;
        var s01 = this.s01;
        this.s00 = (s00 << 24) ^ (s01 >>> 8) ^ a0 ^ (a0 << 16);
        this.s01 = (s01 << 24) ^ (s00 >>> 8) ^ a1 ^ ((a1 << 16) | (a0 >>> 16));
        this.s10 = (a1 << 5) ^ (a0 >>> 27);
        this.s11 = (a0 << 5) ^ (a1 >>> 27);
        return out;
    };
    XoroShiro128Plus.prototype.jump = function () {
        var nextRng = new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
        nextRng.unsafeJump();
        return nextRng;
    };
    XoroShiro128Plus.prototype.unsafeJump = function () {
        var ns01 = 0;
        var ns00 = 0;
        var ns11 = 0;
        var ns10 = 0;
        var jump = [0xd8f554a5, 0xdf900294, 0x4b3201fc, 0x170865df];
        for (var i = 0; i !== 4; ++i) {
            for (var mask = 1; mask; mask <<= 1) {
                if (jump[i] & mask) {
                    ns01 ^= this.s01;
                    ns00 ^= this.s00;
                    ns11 ^= this.s11;
                    ns10 ^= this.s10;
                }
                this.unsafeNext();
            }
        }
        this.s01 = ns01;
        this.s00 = ns00;
        this.s11 = ns11;
        this.s10 = ns10;
    };
    return XoroShiro128Plus;
}());
var xoroshiro128plus = function (seed) {
    return new XoroShiro128Plus(-1, ~seed, seed | 0, 0);
};
exports.xoroshiro128plus = xoroshiro128plus;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\generator\\XoroShiro.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\pure-rand-default.js", {"./distribution/UniformArrayIntDistribution":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\UniformArrayIntDistribution.js","./distribution/UniformBigIntDistribution":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\UniformBigIntDistribution.js","./distribution/UniformIntDistribution":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\UniformIntDistribution.js","./distribution/UnsafeUniformArrayIntDistribution":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformArrayIntDistribution.js","./distribution/UnsafeUniformBigIntDistribution":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformBigIntDistribution.js","./distribution/UnsafeUniformIntDistribution":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformIntDistribution.js","./generator/LinearCongruential":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\generator\\LinearCongruential.js","./generator/MersenneTwister":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\generator\\MersenneTwister.js","./generator/RandomGenerator":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\generator\\RandomGenerator.js","./generator/XorShift":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\generator\\XorShift.js","./generator/XoroShiro":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\generator\\XoroShiro.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cpure-rand%5Clib%5Cpure-rand-default.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.unsafeUniformIntDistribution = exports.unsafeUniformBigIntDistribution = exports.unsafeUniformArrayIntDistribution = exports.uniformIntDistribution = exports.uniformBigIntDistribution = exports.uniformArrayIntDistribution = exports.xoroshiro128plus = exports.xorshift128plus = exports.mersenne = exports.congruential32 = exports.congruential = exports.unsafeSkipN = exports.unsafeGenerateN = exports.skipN = exports.generateN = exports.__commitHash = exports.__version = exports.__type = void 0;
var RandomGenerator_1 = require("./generator/RandomGenerator");
exports.generateN = RandomGenerator_1.generateN;
exports.skipN = RandomGenerator_1.skipN;
exports.unsafeGenerateN = RandomGenerator_1.unsafeGenerateN;
exports.unsafeSkipN = RandomGenerator_1.unsafeSkipN;
var LinearCongruential_1 = require("./generator/LinearCongruential");
exports.congruential = LinearCongruential_1.congruential;
exports.congruential32 = LinearCongruential_1.congruential32;
var MersenneTwister_1 = require("./generator/MersenneTwister");
exports.mersenne = MersenneTwister_1["default"];
var XorShift_1 = require("./generator/XorShift");
exports.xorshift128plus = XorShift_1.xorshift128plus;
var XoroShiro_1 = require("./generator/XoroShiro");
exports.xoroshiro128plus = XoroShiro_1.xoroshiro128plus;
var UniformArrayIntDistribution_1 = require("./distribution/UniformArrayIntDistribution");
exports.uniformArrayIntDistribution = UniformArrayIntDistribution_1.uniformArrayIntDistribution;
var UniformBigIntDistribution_1 = require("./distribution/UniformBigIntDistribution");
exports.uniformBigIntDistribution = UniformBigIntDistribution_1.uniformBigIntDistribution;
var UniformIntDistribution_1 = require("./distribution/UniformIntDistribution");
exports.uniformIntDistribution = UniformIntDistribution_1.uniformIntDistribution;
var UnsafeUniformArrayIntDistribution_1 = require("./distribution/UnsafeUniformArrayIntDistribution");
exports.unsafeUniformArrayIntDistribution = UnsafeUniformArrayIntDistribution_1.unsafeUniformArrayIntDistribution;
var UnsafeUniformBigIntDistribution_1 = require("./distribution/UnsafeUniformBigIntDistribution");
exports.unsafeUniformBigIntDistribution = UnsafeUniformBigIntDistribution_1.unsafeUniformBigIntDistribution;
var UnsafeUniformIntDistribution_1 = require("./distribution/UnsafeUniformIntDistribution");
exports.unsafeUniformIntDistribution = UnsafeUniformIntDistribution_1.unsafeUniformIntDistribution;
var __type = 'commonjs';
exports.__type = __type;
var __version = '5.0.5';
exports.__version = __version;
var __commitHash = '8b812d9651b4a18e9115aa13d84fe1b5eb9b068d';
exports.__commitHash = __commitHash;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\pure-rand-default.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\pure-rand.js", {"./pure-rand-default":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\pure-rand\\lib\\pure-rand-default.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cpure-rand%5Clib%5Cpure-rand.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
exports.__esModule = true;
var prand = require("./pure-rand-default");
exports["default"] = prand;
__exportStar(require("./pure-rand-default"), exports);

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\pure-rand.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qr.js\\lib\\8BitByte.js", {"./mode":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qr.js\\lib\\mode.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cqr.js%5Clib%5C8BitByte.js
      return function (require, module, exports) {
var mode = require('./mode');

function QR8bitByte(data) {
	this.mode = mode.MODE_8BIT_BYTE;
	this.data = data;
}

QR8bitByte.prototype = {

	getLength : function(buffer) {
		return this.data.length;
	},
	
	write : function(buffer) {
		for (var i = 0; i < this.data.length; i++) {
			// not JIS ...
			buffer.put(this.data.charCodeAt(i), 8);
		}
	}
};

module.exports = QR8bitByte;


      };
    };
  }
  }
}, {package:"qrcode.react>qr.js",file:"node_modules\\qr.js\\lib\\8BitByte.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qr.js\\lib\\BitBuffer.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cqr.js%5Clib%5CBitBuffer.js
      return function (require, module, exports) {
function QRBitBuffer() {
	this.buffer = new Array();
	this.length = 0;
}

QRBitBuffer.prototype = {

	get : function(index) {
		var bufIndex = Math.floor(index / 8);
		return ( (this.buffer[bufIndex] >>> (7 - index % 8) ) & 1) == 1;
	},
	
	put : function(num, length) {
		for (var i = 0; i < length; i++) {
			this.putBit( ( (num >>> (length - i - 1) ) & 1) == 1);
		}
	},
	
	getLengthInBits : function() {
		return this.length;
	},
	
	putBit : function(bit) {
	
		var bufIndex = Math.floor(this.length / 8);
		if (this.buffer.length <= bufIndex) {
			this.buffer.push(0);
		}
	
		if (bit) {
			this.buffer[bufIndex] |= (0x80 >>> (this.length % 8) );
		}
	
		this.length++;
	}
};

module.exports = QRBitBuffer;

      };
    };
  }
  }
}, {package:"qrcode.react>qr.js",file:"node_modules\\qr.js\\lib\\BitBuffer.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qr.js\\lib\\ErrorCorrectLevel.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cqr.js%5Clib%5CErrorCorrectLevel.js
      return function (require, module, exports) {
module.exports = {
	L : 1,
	M : 0,
	Q : 3,
	H : 2
};


      };
    };
  }
  }
}, {package:"qrcode.react>qr.js",file:"node_modules\\qr.js\\lib\\ErrorCorrectLevel.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qr.js\\lib\\Polynomial.js", {"./math":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qr.js\\lib\\math.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cqr.js%5Clib%5CPolynomial.js
      return function (require, module, exports) {
var math = require('./math');

function QRPolynomial(num, shift) {

	if (num.length == undefined) {
		throw new Error(num.length + "/" + shift);
	}

	var offset = 0;

	while (offset < num.length && num[offset] == 0) {
		offset++;
	}

	this.num = new Array(num.length - offset + shift);
	for (var i = 0; i < num.length - offset; i++) {
		this.num[i] = num[i + offset];
	}
}

QRPolynomial.prototype = {

	get : function(index) {
		return this.num[index];
	},
	
	getLength : function() {
		return this.num.length;
	},
	
	multiply : function(e) {
	
		var num = new Array(this.getLength() + e.getLength() - 1);
	
		for (var i = 0; i < this.getLength(); i++) {
			for (var j = 0; j < e.getLength(); j++) {
				num[i + j] ^= math.gexp(math.glog(this.get(i) ) + math.glog(e.get(j) ) );
			}
		}
	
		return new QRPolynomial(num, 0);
	},
	
	mod : function(e) {
	
		if (this.getLength() - e.getLength() < 0) {
			return this;
		}
	
		var ratio = math.glog(this.get(0) ) - math.glog(e.get(0) );
	
		var num = new Array(this.getLength() );
		
		for (var i = 0; i < this.getLength(); i++) {
			num[i] = this.get(i);
		}
		
		for (var i = 0; i < e.getLength(); i++) {
			num[i] ^= math.gexp(math.glog(e.get(i) ) + ratio);
		}
	
		// recursive call
		return new QRPolynomial(num, 0).mod(e);
	}
};

module.exports = QRPolynomial;

      };
    };
  }
  }
}, {package:"qrcode.react>qr.js",file:"node_modules\\qr.js\\lib\\Polynomial.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qr.js\\lib\\QRCode.js", {"./8BitByte":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qr.js\\lib\\8BitByte.js","./BitBuffer":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qr.js\\lib\\BitBuffer.js","./Polynomial":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qr.js\\lib\\Polynomial.js","./RSBlock":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qr.js\\lib\\RSBlock.js","./util":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qr.js\\lib\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cqr.js%5Clib%5CQRCode.js
      return function (require, module, exports) {
var BitByte = require('./8BitByte');
var RSBlock = require('./RSBlock');
var BitBuffer = require('./BitBuffer');
var util = require('./util');
var Polynomial = require('./Polynomial');

function QRCode(typeNumber, errorCorrectLevel) {
	this.typeNumber = typeNumber;
	this.errorCorrectLevel = errorCorrectLevel;
	this.modules = null;
	this.moduleCount = 0;
	this.dataCache = null;
	this.dataList = [];
}

// for client side minification
var proto = QRCode.prototype;

proto.addData = function(data) {
	var newData = new BitByte(data);
	this.dataList.push(newData);
	this.dataCache = null;
};

proto.isDark = function(row, col) {
	if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
		throw new Error(row + "," + col);
	}
	return this.modules[row][col];
};

proto.getModuleCount = function() {
	return this.moduleCount;
};

proto.make = function() {
	// Calculate automatically typeNumber if provided is < 1
	if (this.typeNumber < 1 ){
		var typeNumber = 1;
		for (typeNumber = 1; typeNumber < 40; typeNumber++) {
			var rsBlocks = RSBlock.getRSBlocks(typeNumber, this.errorCorrectLevel);

			var buffer = new BitBuffer();
			var totalDataCount = 0;
			for (var i = 0; i < rsBlocks.length; i++) {
				totalDataCount += rsBlocks[i].dataCount;
			}

			for (var i = 0; i < this.dataList.length; i++) {
				var data = this.dataList[i];
				buffer.put(data.mode, 4);
				buffer.put(data.getLength(), util.getLengthInBits(data.mode, typeNumber) );
				data.write(buffer);
			}
			if (buffer.getLengthInBits() <= totalDataCount * 8)
				break;
		}
		this.typeNumber = typeNumber;
	}
	this.makeImpl(false, this.getBestMaskPattern() );
};

proto.makeImpl = function(test, maskPattern) {
	
	this.moduleCount = this.typeNumber * 4 + 17;
	this.modules = new Array(this.moduleCount);
	
	for (var row = 0; row < this.moduleCount; row++) {
		
		this.modules[row] = new Array(this.moduleCount);
		
		for (var col = 0; col < this.moduleCount; col++) {
			this.modules[row][col] = null;//(col + row) % 3;
		}
	}

	this.setupPositionProbePattern(0, 0);
	this.setupPositionProbePattern(this.moduleCount - 7, 0);
	this.setupPositionProbePattern(0, this.moduleCount - 7);
	this.setupPositionAdjustPattern();
	this.setupTimingPattern();
	this.setupTypeInfo(test, maskPattern);
	
	if (this.typeNumber >= 7) {
		this.setupTypeNumber(test);
	}

	if (this.dataCache == null) {
		this.dataCache = QRCode.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
	}

	this.mapData(this.dataCache, maskPattern);
};

proto.setupPositionProbePattern = function(row, col)  {
	
	for (var r = -1; r <= 7; r++) {
		
		if (row + r <= -1 || this.moduleCount <= row + r) continue;
		
		for (var c = -1; c <= 7; c++) {
			
			if (col + c <= -1 || this.moduleCount <= col + c) continue;
			
			if ( (0 <= r && r <= 6 && (c == 0 || c == 6) )
					|| (0 <= c && c <= 6 && (r == 0 || r == 6) )
					|| (2 <= r && r <= 4 && 2 <= c && c <= 4) ) {
				this.modules[row + r][col + c] = true;
			} else {
				this.modules[row + r][col + c] = false;
			}
		}		
	}		
};

proto.getBestMaskPattern = function() {

	var minLostPoint = 0;
	var pattern = 0;

	for (var i = 0; i < 8; i++) {
		
		this.makeImpl(true, i);

		var lostPoint = util.getLostPoint(this);

		if (i == 0 || minLostPoint >  lostPoint) {
			minLostPoint = lostPoint;
			pattern = i;
		}
	}

	return pattern;
};

proto.createMovieClip = function(target_mc, instance_name, depth) {

	var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
	var cs = 1;

	this.make();

	for (var row = 0; row < this.modules.length; row++) {
		
		var y = row * cs;
		
		for (var col = 0; col < this.modules[row].length; col++) {

			var x = col * cs;
			var dark = this.modules[row][col];
		
			if (dark) {
				qr_mc.beginFill(0, 100);
				qr_mc.moveTo(x, y);
				qr_mc.lineTo(x + cs, y);
				qr_mc.lineTo(x + cs, y + cs);
				qr_mc.lineTo(x, y + cs);
				qr_mc.endFill();
			}
		}
	}
	
	return qr_mc;
};

proto.setupTimingPattern = function() {
	
	for (var r = 8; r < this.moduleCount - 8; r++) {
		if (this.modules[r][6] != null) {
			continue;
		}
		this.modules[r][6] = (r % 2 == 0);
	}

	for (var c = 8; c < this.moduleCount - 8; c++) {
		if (this.modules[6][c] != null) {
			continue;
		}
		this.modules[6][c] = (c % 2 == 0);
	}
};

proto.setupPositionAdjustPattern = function() {

	var pos = util.getPatternPosition(this.typeNumber);
	
	for (var i = 0; i < pos.length; i++) {
	
		for (var j = 0; j < pos.length; j++) {
		
			var row = pos[i];
			var col = pos[j];
			
			if (this.modules[row][col] != null) {
				continue;
			}
			
			for (var r = -2; r <= 2; r++) {
			
				for (var c = -2; c <= 2; c++) {
				
					if (r == -2 || r == 2 || c == -2 || c == 2
							|| (r == 0 && c == 0) ) {
						this.modules[row + r][col + c] = true;
					} else {
						this.modules[row + r][col + c] = false;
					}
				}
			}
		}
	}
};

proto.setupTypeNumber = function(test) {

	var bits = util.getBCHTypeNumber(this.typeNumber);

	for (var i = 0; i < 18; i++) {
		var mod = (!test && ( (bits >> i) & 1) == 1);
		this.modules[Math.floor(i / 3)][i % 3 + this.moduleCount - 8 - 3] = mod;
	}

	for (var i = 0; i < 18; i++) {
		var mod = (!test && ( (bits >> i) & 1) == 1);
		this.modules[i % 3 + this.moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
	}
};

proto.setupTypeInfo = function(test, maskPattern) {

	var data = (this.errorCorrectLevel << 3) | maskPattern;
	var bits = util.getBCHTypeInfo(data);

	// vertical		
	for (var i = 0; i < 15; i++) {

		var mod = (!test && ( (bits >> i) & 1) == 1);

		if (i < 6) {
			this.modules[i][8] = mod;
		} else if (i < 8) {
			this.modules[i + 1][8] = mod;
		} else {
			this.modules[this.moduleCount - 15 + i][8] = mod;
		}
	}

	// horizontal
	for (var i = 0; i < 15; i++) {

		var mod = (!test && ( (bits >> i) & 1) == 1);
		
		if (i < 8) {
			this.modules[8][this.moduleCount - i - 1] = mod;
		} else if (i < 9) {
			this.modules[8][15 - i - 1 + 1] = mod;
		} else {
			this.modules[8][15 - i - 1] = mod;
		}
	}

	// fixed module
	this.modules[this.moduleCount - 8][8] = (!test);
};

proto.mapData = function(data, maskPattern) {
	
	var inc = -1;
	var row = this.moduleCount - 1;
	var bitIndex = 7;
	var byteIndex = 0;
	
	for (var col = this.moduleCount - 1; col > 0; col -= 2) {

		if (col == 6) col--;

		while (true) {

			for (var c = 0; c < 2; c++) {
				
				if (this.modules[row][col - c] == null) {
					
					var dark = false;

					if (byteIndex < data.length) {
						dark = ( ( (data[byteIndex] >>> bitIndex) & 1) == 1);
					}

					var mask = util.getMask(maskPattern, row, col - c);

					if (mask) {
						dark = !dark;
					}
					
					this.modules[row][col - c] = dark;
					bitIndex--;

					if (bitIndex == -1) {
						byteIndex++;
						bitIndex = 7;
					}
				}
			}
							
			row += inc;

			if (row < 0 || this.moduleCount <= row) {
				row -= inc;
				inc = -inc;
				break;
			}
		}
	}
};

QRCode.PAD0 = 0xEC;
QRCode.PAD1 = 0x11;

QRCode.createData = function(typeNumber, errorCorrectLevel, dataList) {
	
	var rsBlocks = RSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
	
	var buffer = new BitBuffer();
	
	for (var i = 0; i < dataList.length; i++) {
		var data = dataList[i];
		buffer.put(data.mode, 4);
		buffer.put(data.getLength(), util.getLengthInBits(data.mode, typeNumber) );
		data.write(buffer);
	}

	// calc num max data.
	var totalDataCount = 0;
	for (var i = 0; i < rsBlocks.length; i++) {
		totalDataCount += rsBlocks[i].dataCount;
	}

	if (buffer.getLengthInBits() > totalDataCount * 8) {
		throw new Error("code length overflow. ("
			+ buffer.getLengthInBits()
			+ ">"
			+  totalDataCount * 8
			+ ")");
	}

	// end code
	if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
		buffer.put(0, 4);
	}

	// padding
	while (buffer.getLengthInBits() % 8 != 0) {
		buffer.putBit(false);
	}

	// padding
	while (true) {
		
		if (buffer.getLengthInBits() >= totalDataCount * 8) {
			break;
		}
		buffer.put(QRCode.PAD0, 8);
		
		if (buffer.getLengthInBits() >= totalDataCount * 8) {
			break;
		}
		buffer.put(QRCode.PAD1, 8);
	}

	return QRCode.createBytes(buffer, rsBlocks);
};

QRCode.createBytes = function(buffer, rsBlocks) {

	var offset = 0;
	
	var maxDcCount = 0;
	var maxEcCount = 0;
	
	var dcdata = new Array(rsBlocks.length);
	var ecdata = new Array(rsBlocks.length);
	
	for (var r = 0; r < rsBlocks.length; r++) {

		var dcCount = rsBlocks[r].dataCount;
		var ecCount = rsBlocks[r].totalCount - dcCount;

		maxDcCount = Math.max(maxDcCount, dcCount);
		maxEcCount = Math.max(maxEcCount, ecCount);
		
		dcdata[r] = new Array(dcCount);
		
		for (var i = 0; i < dcdata[r].length; i++) {
			dcdata[r][i] = 0xff & buffer.buffer[i + offset];
		}
		offset += dcCount;
		
		var rsPoly = util.getErrorCorrectPolynomial(ecCount);
		var rawPoly = new Polynomial(dcdata[r], rsPoly.getLength() - 1);

		var modPoly = rawPoly.mod(rsPoly);
		ecdata[r] = new Array(rsPoly.getLength() - 1);
		for (var i = 0; i < ecdata[r].length; i++) {
            var modIndex = i + modPoly.getLength() - ecdata[r].length;
			ecdata[r][i] = (modIndex >= 0)? modPoly.get(modIndex) : 0;
		}

	}
	
	var totalCodeCount = 0;
	for (var i = 0; i < rsBlocks.length; i++) {
		totalCodeCount += rsBlocks[i].totalCount;
	}

	var data = new Array(totalCodeCount);
	var index = 0;

	for (var i = 0; i < maxDcCount; i++) {
		for (var r = 0; r < rsBlocks.length; r++) {
			if (i < dcdata[r].length) {
				data[index++] = dcdata[r][i];
			}
		}
	}

	for (var i = 0; i < maxEcCount; i++) {
		for (var r = 0; r < rsBlocks.length; r++) {
			if (i < ecdata[r].length) {
				data[index++] = ecdata[r][i];
			}
		}
	}

	return data;
};

module.exports = QRCode;


      };
    };
  }
  }
}, {package:"qrcode.react>qr.js",file:"node_modules\\qr.js\\lib\\QRCode.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qr.js\\lib\\RSBlock.js", {"./ErrorCorrectLevel":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qr.js\\lib\\ErrorCorrectLevel.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cqr.js%5Clib%5CRSBlock.js
      return function (require, module, exports) {
// ErrorCorrectLevel
var ECL = require('./ErrorCorrectLevel');

function QRRSBlock(totalCount, dataCount) {
	this.totalCount = totalCount;
	this.dataCount  = dataCount;
}

QRRSBlock.RS_BLOCK_TABLE = [

	// L
	// M
	// Q
	// H

	// 1
	[1, 26, 19],
	[1, 26, 16],
	[1, 26, 13],
	[1, 26, 9],
	
	// 2
	[1, 44, 34],
	[1, 44, 28],
	[1, 44, 22],
	[1, 44, 16],

	// 3
	[1, 70, 55],
	[1, 70, 44],
	[2, 35, 17],
	[2, 35, 13],

	// 4		
	[1, 100, 80],
	[2, 50, 32],
	[2, 50, 24],
	[4, 25, 9],
	
	// 5
	[1, 134, 108],
	[2, 67, 43],
	[2, 33, 15, 2, 34, 16],
	[2, 33, 11, 2, 34, 12],
	
	// 6
	[2, 86, 68],
	[4, 43, 27],
	[4, 43, 19],
	[4, 43, 15],
	
	// 7		
	[2, 98, 78],
	[4, 49, 31],
	[2, 32, 14, 4, 33, 15],
	[4, 39, 13, 1, 40, 14],
	
	// 8
	[2, 121, 97],
	[2, 60, 38, 2, 61, 39],
	[4, 40, 18, 2, 41, 19],
	[4, 40, 14, 2, 41, 15],
	
	// 9
	[2, 146, 116],
	[3, 58, 36, 2, 59, 37],
	[4, 36, 16, 4, 37, 17],
	[4, 36, 12, 4, 37, 13],
	
	// 10		
	[2, 86, 68, 2, 87, 69],
	[4, 69, 43, 1, 70, 44],
	[6, 43, 19, 2, 44, 20],
	[6, 43, 15, 2, 44, 16],

	// 11
	[4, 101, 81],
	[1, 80, 50, 4, 81, 51],
	[4, 50, 22, 4, 51, 23],
	[3, 36, 12, 8, 37, 13],

	// 12
	[2, 116, 92, 2, 117, 93],
	[6, 58, 36, 2, 59, 37],
	[4, 46, 20, 6, 47, 21],
	[7, 42, 14, 4, 43, 15],

	// 13
	[4, 133, 107],
	[8, 59, 37, 1, 60, 38],
	[8, 44, 20, 4, 45, 21],
	[12, 33, 11, 4, 34, 12],

	// 14
	[3, 145, 115, 1, 146, 116],
	[4, 64, 40, 5, 65, 41],
	[11, 36, 16, 5, 37, 17],
	[11, 36, 12, 5, 37, 13],

	// 15
	[5, 109, 87, 1, 110, 88],
	[5, 65, 41, 5, 66, 42],
	[5, 54, 24, 7, 55, 25],
	[11, 36, 12],

	// 16
	[5, 122, 98, 1, 123, 99],
	[7, 73, 45, 3, 74, 46],
	[15, 43, 19, 2, 44, 20],
	[3, 45, 15, 13, 46, 16],

	// 17
	[1, 135, 107, 5, 136, 108],
	[10, 74, 46, 1, 75, 47],
	[1, 50, 22, 15, 51, 23],
	[2, 42, 14, 17, 43, 15],

	// 18
	[5, 150, 120, 1, 151, 121],
	[9, 69, 43, 4, 70, 44],
	[17, 50, 22, 1, 51, 23],
	[2, 42, 14, 19, 43, 15],

	// 19
	[3, 141, 113, 4, 142, 114],
	[3, 70, 44, 11, 71, 45],
	[17, 47, 21, 4, 48, 22],
	[9, 39, 13, 16, 40, 14],

	// 20
	[3, 135, 107, 5, 136, 108],
	[3, 67, 41, 13, 68, 42],
	[15, 54, 24, 5, 55, 25],
	[15, 43, 15, 10, 44, 16],

	// 21
	[4, 144, 116, 4, 145, 117],
	[17, 68, 42],
	[17, 50, 22, 6, 51, 23],
	[19, 46, 16, 6, 47, 17],

	// 22
	[2, 139, 111, 7, 140, 112],
	[17, 74, 46],
	[7, 54, 24, 16, 55, 25],
	[34, 37, 13],

	// 23
	[4, 151, 121, 5, 152, 122],
	[4, 75, 47, 14, 76, 48],
	[11, 54, 24, 14, 55, 25],
	[16, 45, 15, 14, 46, 16],

	// 24
	[6, 147, 117, 4, 148, 118],
	[6, 73, 45, 14, 74, 46],
	[11, 54, 24, 16, 55, 25],
	[30, 46, 16, 2, 47, 17],

	// 25
	[8, 132, 106, 4, 133, 107],
	[8, 75, 47, 13, 76, 48],
	[7, 54, 24, 22, 55, 25],
	[22, 45, 15, 13, 46, 16],

	// 26
	[10, 142, 114, 2, 143, 115],
	[19, 74, 46, 4, 75, 47],
	[28, 50, 22, 6, 51, 23],
	[33, 46, 16, 4, 47, 17],

	// 27
	[8, 152, 122, 4, 153, 123],
	[22, 73, 45, 3, 74, 46],
	[8, 53, 23, 26, 54, 24],
	[12, 45, 15, 28, 46, 16],

	// 28
	[3, 147, 117, 10, 148, 118],
	[3, 73, 45, 23, 74, 46],
	[4, 54, 24, 31, 55, 25],
	[11, 45, 15, 31, 46, 16],

	// 29
	[7, 146, 116, 7, 147, 117],
	[21, 73, 45, 7, 74, 46],
	[1, 53, 23, 37, 54, 24],
	[19, 45, 15, 26, 46, 16],

	// 30
	[5, 145, 115, 10, 146, 116],
	[19, 75, 47, 10, 76, 48],
	[15, 54, 24, 25, 55, 25],
	[23, 45, 15, 25, 46, 16],

	// 31
	[13, 145, 115, 3, 146, 116],
	[2, 74, 46, 29, 75, 47],
	[42, 54, 24, 1, 55, 25],
	[23, 45, 15, 28, 46, 16],

	// 32
	[17, 145, 115],
	[10, 74, 46, 23, 75, 47],
	[10, 54, 24, 35, 55, 25],
	[19, 45, 15, 35, 46, 16],

	// 33
	[17, 145, 115, 1, 146, 116],
	[14, 74, 46, 21, 75, 47],
	[29, 54, 24, 19, 55, 25],
	[11, 45, 15, 46, 46, 16],

	// 34
	[13, 145, 115, 6, 146, 116],
	[14, 74, 46, 23, 75, 47],
	[44, 54, 24, 7, 55, 25],
	[59, 46, 16, 1, 47, 17],

	// 35
	[12, 151, 121, 7, 152, 122],
	[12, 75, 47, 26, 76, 48],
	[39, 54, 24, 14, 55, 25],
	[22, 45, 15, 41, 46, 16],

	// 36
	[6, 151, 121, 14, 152, 122],
	[6, 75, 47, 34, 76, 48],
	[46, 54, 24, 10, 55, 25],
	[2, 45, 15, 64, 46, 16],

	// 37
	[17, 152, 122, 4, 153, 123],
	[29, 74, 46, 14, 75, 47],
	[49, 54, 24, 10, 55, 25],
	[24, 45, 15, 46, 46, 16],

	// 38
	[4, 152, 122, 18, 153, 123],
	[13, 74, 46, 32, 75, 47],
	[48, 54, 24, 14, 55, 25],
	[42, 45, 15, 32, 46, 16],

	// 39
	[20, 147, 117, 4, 148, 118],
	[40, 75, 47, 7, 76, 48],
	[43, 54, 24, 22, 55, 25],
	[10, 45, 15, 67, 46, 16],

	// 40
	[19, 148, 118, 6, 149, 119],
	[18, 75, 47, 31, 76, 48],
	[34, 54, 24, 34, 55, 25],
	[20, 45, 15, 61, 46, 16]
];

QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
	
	var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
	
	if (rsBlock == undefined) {
		throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
	}

	var length = rsBlock.length / 3;
	
	var list = new Array();
	
	for (var i = 0; i < length; i++) {

		var count = rsBlock[i * 3 + 0];
		var totalCount = rsBlock[i * 3 + 1];
		var dataCount  = rsBlock[i * 3 + 2];

		for (var j = 0; j < count; j++) {
			list.push(new QRRSBlock(totalCount, dataCount) );	
		}
	}
	
	return list;
}

QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {

	switch(errorCorrectLevel) {
	case ECL.L :
		return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
	case ECL.M :
		return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
	case ECL.Q :
		return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
	case ECL.H :
		return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
	default :
		return undefined;
	}
}

module.exports = QRRSBlock;

      };
    };
  }
  }
}, {package:"qrcode.react>qr.js",file:"node_modules\\qr.js\\lib\\RSBlock.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qr.js\\lib\\math.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cqr.js%5Clib%5Cmath.js
      return function (require, module, exports) {
var QRMath = {

	glog : function(n) {
	
		if (n < 1) {
			throw new Error("glog(" + n + ")");
		}
		
		return QRMath.LOG_TABLE[n];
	},
	
	gexp : function(n) {
	
		while (n < 0) {
			n += 255;
		}
	
		while (n >= 256) {
			n -= 255;
		}
	
		return QRMath.EXP_TABLE[n];
	},
	
	EXP_TABLE : new Array(256),
	
	LOG_TABLE : new Array(256)

};
	
for (var i = 0; i < 8; i++) {
	QRMath.EXP_TABLE[i] = 1 << i;
}
for (var i = 8; i < 256; i++) {
	QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4]
		^ QRMath.EXP_TABLE[i - 5]
		^ QRMath.EXP_TABLE[i - 6]
		^ QRMath.EXP_TABLE[i - 8];
}
for (var i = 0; i < 255; i++) {
	QRMath.LOG_TABLE[QRMath.EXP_TABLE[i] ] = i;
}

module.exports = QRMath;

      };
    };
  }
  }
}, {package:"qrcode.react>qr.js",file:"node_modules\\qr.js\\lib\\math.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qr.js\\lib\\mode.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cqr.js%5Clib%5Cmode.js
      return function (require, module, exports) {
module.exports = {
	MODE_NUMBER :		1 << 0,
	MODE_ALPHA_NUM : 	1 << 1,
	MODE_8BIT_BYTE : 	1 << 2,
	MODE_KANJI :		1 << 3
};

      };
    };
  }
  }
}, {package:"qrcode.react>qr.js",file:"node_modules\\qr.js\\lib\\mode.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qr.js\\lib\\util.js", {"./Polynomial":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qr.js\\lib\\Polynomial.js","./math":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qr.js\\lib\\math.js","./mode":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qr.js\\lib\\mode.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cqr.js%5Clib%5Cutil.js
      return function (require, module, exports) {
var Mode = require('./mode');
var Polynomial = require('./Polynomial');
var math = require('./math');

var QRMaskPattern = {
	PATTERN000 : 0,
	PATTERN001 : 1,
	PATTERN010 : 2,
	PATTERN011 : 3,
	PATTERN100 : 4,
	PATTERN101 : 5,
	PATTERN110 : 6,
	PATTERN111 : 7
};

var QRUtil = {

    PATTERN_POSITION_TABLE : [
	    [],
	    [6, 18],
	    [6, 22],
	    [6, 26],
	    [6, 30],
	    [6, 34],
	    [6, 22, 38],
	    [6, 24, 42],
	    [6, 26, 46],
	    [6, 28, 50],
	    [6, 30, 54],		
	    [6, 32, 58],
	    [6, 34, 62],
	    [6, 26, 46, 66],
	    [6, 26, 48, 70],
	    [6, 26, 50, 74],
	    [6, 30, 54, 78],
	    [6, 30, 56, 82],
	    [6, 30, 58, 86],
	    [6, 34, 62, 90],
	    [6, 28, 50, 72, 94],
	    [6, 26, 50, 74, 98],
	    [6, 30, 54, 78, 102],
	    [6, 28, 54, 80, 106],
	    [6, 32, 58, 84, 110],
	    [6, 30, 58, 86, 114],
	    [6, 34, 62, 90, 118],
	    [6, 26, 50, 74, 98, 122],
	    [6, 30, 54, 78, 102, 126],
	    [6, 26, 52, 78, 104, 130],
	    [6, 30, 56, 82, 108, 134],
	    [6, 34, 60, 86, 112, 138],
	    [6, 30, 58, 86, 114, 142],
	    [6, 34, 62, 90, 118, 146],
	    [6, 30, 54, 78, 102, 126, 150],
	    [6, 24, 50, 76, 102, 128, 154],
	    [6, 28, 54, 80, 106, 132, 158],
	    [6, 32, 58, 84, 110, 136, 162],
	    [6, 26, 54, 82, 110, 138, 166],
	    [6, 30, 58, 86, 114, 142, 170]
    ],

    G15 : (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0),
    G18 : (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0),
    G15_MASK : (1 << 14) | (1 << 12) | (1 << 10)	| (1 << 4) | (1 << 1),

    getBCHTypeInfo : function(data) {
	    var d = data << 10;
	    while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
		    d ^= (QRUtil.G15 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) ) ); 	
	    }
	    return ( (data << 10) | d) ^ QRUtil.G15_MASK;
    },

    getBCHTypeNumber : function(data) {
	    var d = data << 12;
	    while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
		    d ^= (QRUtil.G18 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) ) ); 	
	    }
	    return (data << 12) | d;
    },

    getBCHDigit : function(data) {

	    var digit = 0;

	    while (data != 0) {
		    digit++;
		    data >>>= 1;
	    }

	    return digit;
    },

    getPatternPosition : function(typeNumber) {
	    return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
    },

    getMask : function(maskPattern, i, j) {
	    
	    switch (maskPattern) {
		    
	    case QRMaskPattern.PATTERN000 : return (i + j) % 2 == 0;
	    case QRMaskPattern.PATTERN001 : return i % 2 == 0;
	    case QRMaskPattern.PATTERN010 : return j % 3 == 0;
	    case QRMaskPattern.PATTERN011 : return (i + j) % 3 == 0;
	    case QRMaskPattern.PATTERN100 : return (Math.floor(i / 2) + Math.floor(j / 3) ) % 2 == 0;
	    case QRMaskPattern.PATTERN101 : return (i * j) % 2 + (i * j) % 3 == 0;
	    case QRMaskPattern.PATTERN110 : return ( (i * j) % 2 + (i * j) % 3) % 2 == 0;
	    case QRMaskPattern.PATTERN111 : return ( (i * j) % 3 + (i + j) % 2) % 2 == 0;

	    default :
		    throw new Error("bad maskPattern:" + maskPattern);
	    }
    },

    getErrorCorrectPolynomial : function(errorCorrectLength) {

	    var a = new Polynomial([1], 0);

	    for (var i = 0; i < errorCorrectLength; i++) {
		    a = a.multiply(new Polynomial([1, math.gexp(i)], 0) );
	    }

	    return a;
    },

    getLengthInBits : function(mode, type) {

	    if (1 <= type && type < 10) {

		    // 1 - 9

		    switch(mode) {
		    case Mode.MODE_NUMBER 	: return 10;
		    case Mode.MODE_ALPHA_NUM 	: return 9;
		    case Mode.MODE_8BIT_BYTE	: return 8;
		    case Mode.MODE_KANJI  	: return 8;
		    default :
			    throw new Error("mode:" + mode);
		    }

	    } else if (type < 27) {

		    // 10 - 26

		    switch(mode) {
		    case Mode.MODE_NUMBER 	: return 12;
		    case Mode.MODE_ALPHA_NUM 	: return 11;
		    case Mode.MODE_8BIT_BYTE	: return 16;
		    case Mode.MODE_KANJI  	: return 10;
		    default :
			    throw new Error("mode:" + mode);
		    }

	    } else if (type < 41) {

		    // 27 - 40

		    switch(mode) {
		    case Mode.MODE_NUMBER 	: return 14;
		    case Mode.MODE_ALPHA_NUM	: return 13;
		    case Mode.MODE_8BIT_BYTE	: return 16;
		    case Mode.MODE_KANJI  	: return 12;
		    default :
			    throw new Error("mode:" + mode);
		    }

	    } else {
		    throw new Error("type:" + type);
	    }
    },

    getLostPoint : function(qrCode) {
	    
	    var moduleCount = qrCode.getModuleCount();
	    
	    var lostPoint = 0;
	    
	    // LEVEL1
	    
	    for (var row = 0; row < moduleCount; row++) {

		    for (var col = 0; col < moduleCount; col++) {

			    var sameCount = 0;
			    var dark = qrCode.isDark(row, col);

				for (var r = -1; r <= 1; r++) {

				    if (row + r < 0 || moduleCount <= row + r) {
					    continue;
				    }

				    for (var c = -1; c <= 1; c++) {

					    if (col + c < 0 || moduleCount <= col + c) {
						    continue;
					    }

					    if (r == 0 && c == 0) {
						    continue;
					    }

					    if (dark == qrCode.isDark(row + r, col + c) ) {
						    sameCount++;
					    }
				    }
			    }

			    if (sameCount > 5) {
				    lostPoint += (3 + sameCount - 5);
			    }
		    }
	    }

	    // LEVEL2

	    for (var row = 0; row < moduleCount - 1; row++) {
		    for (var col = 0; col < moduleCount - 1; col++) {
			    var count = 0;
			    if (qrCode.isDark(row,     col    ) ) count++;
			    if (qrCode.isDark(row + 1, col    ) ) count++;
			    if (qrCode.isDark(row,     col + 1) ) count++;
			    if (qrCode.isDark(row + 1, col + 1) ) count++;
			    if (count == 0 || count == 4) {
				    lostPoint += 3;
			    }
		    }
	    }

	    // LEVEL3

	    for (var row = 0; row < moduleCount; row++) {
		    for (var col = 0; col < moduleCount - 6; col++) {
			    if (qrCode.isDark(row, col)
					    && !qrCode.isDark(row, col + 1)
					    &&  qrCode.isDark(row, col + 2)
					    &&  qrCode.isDark(row, col + 3)
					    &&  qrCode.isDark(row, col + 4)
					    && !qrCode.isDark(row, col + 5)
					    &&  qrCode.isDark(row, col + 6) ) {
				    lostPoint += 40;
			    }
		    }
	    }

	    for (var col = 0; col < moduleCount; col++) {
		    for (var row = 0; row < moduleCount - 6; row++) {
			    if (qrCode.isDark(row, col)
					    && !qrCode.isDark(row + 1, col)
					    &&  qrCode.isDark(row + 2, col)
					    &&  qrCode.isDark(row + 3, col)
					    &&  qrCode.isDark(row + 4, col)
					    && !qrCode.isDark(row + 5, col)
					    &&  qrCode.isDark(row + 6, col) ) {
				    lostPoint += 40;
			    }
		    }
	    }

	    // LEVEL4
	    
	    var darkCount = 0;

	    for (var col = 0; col < moduleCount; col++) {
		    for (var row = 0; row < moduleCount; row++) {
			    if (qrCode.isDark(row, col) ) {
				    darkCount++;
			    }
		    }
	    }
	    
	    var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
	    lostPoint += ratio * 10;

	    return lostPoint;		
    }
};

module.exports = QRUtil;

      };
    };
  }
  }
}, {package:"qrcode.react>qr.js",file:"node_modules\\qr.js\\lib\\util.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qrcode-generator\\qrcode.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cqrcode-generator%5Cqrcode.js
      return function (require, module, exports) {
//---------------------------------------------------------------------
//
// QR Code Generator for JavaScript
//
// Copyright (c) 2009 Kazuhiko Arase
//
// URL: http://www.d-project.com/
//
// Licensed under the MIT license:
//  http://www.opensource.org/licenses/mit-license.php
//
// The word 'QR Code' is registered trademark of
// DENSO WAVE INCORPORATED
//  http://www.denso-wave.com/qrcode/faqpatent-e.html
//
//---------------------------------------------------------------------

var qrcode = function() {

  //---------------------------------------------------------------------
  // qrcode
  //---------------------------------------------------------------------

  /**
   * qrcode
   * @param typeNumber 1 to 40
   * @param errorCorrectionLevel 'L','M','Q','H'
   */
  var qrcode = function(typeNumber, errorCorrectionLevel) {

    var PAD0 = 0xEC;
    var PAD1 = 0x11;

    var _typeNumber = typeNumber;
    var _errorCorrectionLevel = QRErrorCorrectionLevel[errorCorrectionLevel];
    var _modules = null;
    var _moduleCount = 0;
    var _dataCache = null;
    var _dataList = [];

    var _this = {};

    var makeImpl = function(test, maskPattern) {

      _moduleCount = _typeNumber * 4 + 17;
      _modules = function(moduleCount) {
        var modules = new Array(moduleCount);
        for (var row = 0; row < moduleCount; row += 1) {
          modules[row] = new Array(moduleCount);
          for (var col = 0; col < moduleCount; col += 1) {
            modules[row][col] = null;
          }
        }
        return modules;
      }(_moduleCount);

      setupPositionProbePattern(0, 0);
      setupPositionProbePattern(_moduleCount - 7, 0);
      setupPositionProbePattern(0, _moduleCount - 7);
      setupPositionAdjustPattern();
      setupTimingPattern();
      setupTypeInfo(test, maskPattern);

      if (_typeNumber >= 7) {
        setupTypeNumber(test);
      }

      if (_dataCache == null) {
        _dataCache = createData(_typeNumber, _errorCorrectionLevel, _dataList);
      }

      mapData(_dataCache, maskPattern);
    };

    var setupPositionProbePattern = function(row, col) {

      for (var r = -1; r <= 7; r += 1) {

        if (row + r <= -1 || _moduleCount <= row + r) continue;

        for (var c = -1; c <= 7; c += 1) {

          if (col + c <= -1 || _moduleCount <= col + c) continue;

          if ( (0 <= r && r <= 6 && (c == 0 || c == 6) )
              || (0 <= c && c <= 6 && (r == 0 || r == 6) )
              || (2 <= r && r <= 4 && 2 <= c && c <= 4) ) {
            _modules[row + r][col + c] = true;
          } else {
            _modules[row + r][col + c] = false;
          }
        }
      }
    };

    var getBestMaskPattern = function() {

      var minLostPoint = 0;
      var pattern = 0;

      for (var i = 0; i < 8; i += 1) {

        makeImpl(true, i);

        var lostPoint = QRUtil.getLostPoint(_this);

        if (i == 0 || minLostPoint > lostPoint) {
          minLostPoint = lostPoint;
          pattern = i;
        }
      }

      return pattern;
    };

    var setupTimingPattern = function() {

      for (var r = 8; r < _moduleCount - 8; r += 1) {
        if (_modules[r][6] != null) {
          continue;
        }
        _modules[r][6] = (r % 2 == 0);
      }

      for (var c = 8; c < _moduleCount - 8; c += 1) {
        if (_modules[6][c] != null) {
          continue;
        }
        _modules[6][c] = (c % 2 == 0);
      }
    };

    var setupPositionAdjustPattern = function() {

      var pos = QRUtil.getPatternPosition(_typeNumber);

      for (var i = 0; i < pos.length; i += 1) {

        for (var j = 0; j < pos.length; j += 1) {

          var row = pos[i];
          var col = pos[j];

          if (_modules[row][col] != null) {
            continue;
          }

          for (var r = -2; r <= 2; r += 1) {

            for (var c = -2; c <= 2; c += 1) {

              if (r == -2 || r == 2 || c == -2 || c == 2
                  || (r == 0 && c == 0) ) {
                _modules[row + r][col + c] = true;
              } else {
                _modules[row + r][col + c] = false;
              }
            }
          }
        }
      }
    };

    var setupTypeNumber = function(test) {

      var bits = QRUtil.getBCHTypeNumber(_typeNumber);

      for (var i = 0; i < 18; i += 1) {
        var mod = (!test && ( (bits >> i) & 1) == 1);
        _modules[Math.floor(i / 3)][i % 3 + _moduleCount - 8 - 3] = mod;
      }

      for (var i = 0; i < 18; i += 1) {
        var mod = (!test && ( (bits >> i) & 1) == 1);
        _modules[i % 3 + _moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
      }
    };

    var setupTypeInfo = function(test, maskPattern) {

      var data = (_errorCorrectionLevel << 3) | maskPattern;
      var bits = QRUtil.getBCHTypeInfo(data);

      // vertical
      for (var i = 0; i < 15; i += 1) {

        var mod = (!test && ( (bits >> i) & 1) == 1);

        if (i < 6) {
          _modules[i][8] = mod;
        } else if (i < 8) {
          _modules[i + 1][8] = mod;
        } else {
          _modules[_moduleCount - 15 + i][8] = mod;
        }
      }

      // horizontal
      for (var i = 0; i < 15; i += 1) {

        var mod = (!test && ( (bits >> i) & 1) == 1);

        if (i < 8) {
          _modules[8][_moduleCount - i - 1] = mod;
        } else if (i < 9) {
          _modules[8][15 - i - 1 + 1] = mod;
        } else {
          _modules[8][15 - i - 1] = mod;
        }
      }

      // fixed module
      _modules[_moduleCount - 8][8] = (!test);
    };

    var mapData = function(data, maskPattern) {

      var inc = -1;
      var row = _moduleCount - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      var maskFunc = QRUtil.getMaskFunction(maskPattern);

      for (var col = _moduleCount - 1; col > 0; col -= 2) {

        if (col == 6) col -= 1;

        while (true) {

          for (var c = 0; c < 2; c += 1) {

            if (_modules[row][col - c] == null) {

              var dark = false;

              if (byteIndex < data.length) {
                dark = ( ( (data[byteIndex] >>> bitIndex) & 1) == 1);
              }

              var mask = maskFunc(row, col - c);

              if (mask) {
                dark = !dark;
              }

              _modules[row][col - c] = dark;
              bitIndex -= 1;

              if (bitIndex == -1) {
                byteIndex += 1;
                bitIndex = 7;
              }
            }
          }

          row += inc;

          if (row < 0 || _moduleCount <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    };

    var createBytes = function(buffer, rsBlocks) {

      var offset = 0;

      var maxDcCount = 0;
      var maxEcCount = 0;

      var dcdata = new Array(rsBlocks.length);
      var ecdata = new Array(rsBlocks.length);

      for (var r = 0; r < rsBlocks.length; r += 1) {

        var dcCount = rsBlocks[r].dataCount;
        var ecCount = rsBlocks[r].totalCount - dcCount;

        maxDcCount = Math.max(maxDcCount, dcCount);
        maxEcCount = Math.max(maxEcCount, ecCount);

        dcdata[r] = new Array(dcCount);

        for (var i = 0; i < dcdata[r].length; i += 1) {
          dcdata[r][i] = 0xff & buffer.getBuffer()[i + offset];
        }
        offset += dcCount;

        var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
        var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);

        var modPoly = rawPoly.mod(rsPoly);
        ecdata[r] = new Array(rsPoly.getLength() - 1);
        for (var i = 0; i < ecdata[r].length; i += 1) {
          var modIndex = i + modPoly.getLength() - ecdata[r].length;
          ecdata[r][i] = (modIndex >= 0)? modPoly.getAt(modIndex) : 0;
        }
      }

      var totalCodeCount = 0;
      for (var i = 0; i < rsBlocks.length; i += 1) {
        totalCodeCount += rsBlocks[i].totalCount;
      }

      var data = new Array(totalCodeCount);
      var index = 0;

      for (var i = 0; i < maxDcCount; i += 1) {
        for (var r = 0; r < rsBlocks.length; r += 1) {
          if (i < dcdata[r].length) {
            data[index] = dcdata[r][i];
            index += 1;
          }
        }
      }

      for (var i = 0; i < maxEcCount; i += 1) {
        for (var r = 0; r < rsBlocks.length; r += 1) {
          if (i < ecdata[r].length) {
            data[index] = ecdata[r][i];
            index += 1;
          }
        }
      }

      return data;
    };

    var createData = function(typeNumber, errorCorrectionLevel, dataList) {

      var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectionLevel);

      var buffer = qrBitBuffer();

      for (var i = 0; i < dataList.length; i += 1) {
        var data = dataList[i];
        buffer.put(data.getMode(), 4);
        buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );
        data.write(buffer);
      }

      // calc num max data.
      var totalDataCount = 0;
      for (var i = 0; i < rsBlocks.length; i += 1) {
        totalDataCount += rsBlocks[i].dataCount;
      }

      if (buffer.getLengthInBits() > totalDataCount * 8) {
        throw 'code length overflow. ('
          + buffer.getLengthInBits()
          + '>'
          + totalDataCount * 8
          + ')';
      }

      // end code
      if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
        buffer.put(0, 4);
      }

      // padding
      while (buffer.getLengthInBits() % 8 != 0) {
        buffer.putBit(false);
      }

      // padding
      while (true) {

        if (buffer.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer.put(PAD0, 8);

        if (buffer.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer.put(PAD1, 8);
      }

      return createBytes(buffer, rsBlocks);
    };

    _this.addData = function(data, mode) {

      mode = mode || 'Byte';

      var newData = null;

      switch(mode) {
      case 'Numeric' :
        newData = qrNumber(data);
        break;
      case 'Alphanumeric' :
        newData = qrAlphaNum(data);
        break;
      case 'Byte' :
        newData = qr8BitByte(data);
        break;
      case 'Kanji' :
        newData = qrKanji(data);
        break;
      default :
        throw 'mode:' + mode;
      }

      _dataList.push(newData);
      _dataCache = null;
    };

    _this.isDark = function(row, col) {
      if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {
        throw row + ',' + col;
      }
      return _modules[row][col];
    };

    _this.getModuleCount = function() {
      return _moduleCount;
    };

    _this.make = function() {
      if (_typeNumber < 1) {
        var typeNumber = 1;

        for (; typeNumber < 40; typeNumber++) {
          var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, _errorCorrectionLevel);
          var buffer = qrBitBuffer();

          for (var i = 0; i < _dataList.length; i++) {
            var data = _dataList[i];
            buffer.put(data.getMode(), 4);
            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );
            data.write(buffer);
          }

          var totalDataCount = 0;
          for (var i = 0; i < rsBlocks.length; i++) {
            totalDataCount += rsBlocks[i].dataCount;
          }

          if (buffer.getLengthInBits() <= totalDataCount * 8) {
            break;
          }
        }

        _typeNumber = typeNumber;
      }

      makeImpl(false, getBestMaskPattern() );
    };

    _this.createTableTag = function(cellSize, margin) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      var qrHtml = '';

      qrHtml += '<table style="';
      qrHtml += ' border-width: 0px; border-style: none;';
      qrHtml += ' border-collapse: collapse;';
      qrHtml += ' padding: 0px; margin: ' + margin + 'px;';
      qrHtml += '">';
      qrHtml += '<tbody>';

      for (var r = 0; r < _this.getModuleCount(); r += 1) {

        qrHtml += '<tr>';

        for (var c = 0; c < _this.getModuleCount(); c += 1) {
          qrHtml += '<td style="';
          qrHtml += ' border-width: 0px; border-style: none;';
          qrHtml += ' border-collapse: collapse;';
          qrHtml += ' padding: 0px; margin: 0px;';
          qrHtml += ' width: ' + cellSize + 'px;';
          qrHtml += ' height: ' + cellSize + 'px;';
          qrHtml += ' background-color: ';
          qrHtml += _this.isDark(r, c)? '#000000' : '#ffffff';
          qrHtml += ';';
          qrHtml += '"/>';
        }

        qrHtml += '</tr>';
      }

      qrHtml += '</tbody>';
      qrHtml += '</table>';

      return qrHtml;
    };

    _this.createSvgTag = function(cellSize, margin) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;
      var size = _this.getModuleCount() * cellSize + margin * 2;
      var c, mc, r, mr, qrSvg='', rect;

      rect = 'l' + cellSize + ',0 0,' + cellSize +
        ' -' + cellSize + ',0 0,-' + cellSize + 'z ';

      qrSvg += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"';
      qrSvg += ' width="' + size + 'px"';
      qrSvg += ' height="' + size + 'px"';
      qrSvg += ' viewBox="0 0 ' + size + ' ' + size + '" ';
      qrSvg += ' preserveAspectRatio="xMinYMin meet">';
      qrSvg += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>';
      qrSvg += '<path d="';

      for (r = 0; r < _this.getModuleCount(); r += 1) {
        mr = r * cellSize + margin;
        for (c = 0; c < _this.getModuleCount(); c += 1) {
          if (_this.isDark(r, c) ) {
            mc = c*cellSize+margin;
            qrSvg += 'M' + mc + ',' + mr + rect;
          }
        }
      }

      qrSvg += '" stroke="transparent" fill="black"/>';
      qrSvg += '</svg>';

      return qrSvg;
    };

    _this.createDataURL = function(cellSize, margin) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var min = margin;
      var max = size - margin;

      return createDataURL(size, size, function(x, y) {
        if (min <= x && x < max && min <= y && y < max) {
          var c = Math.floor( (x - min) / cellSize);
          var r = Math.floor( (y - min) / cellSize);
          return _this.isDark(r, c)? 0 : 1;
        } else {
          return 1;
        }
      } );
    };

    _this.createImgTag = function(cellSize, margin, alt) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;

      var img = '';
      img += '<img';
      img += '\u0020src="';
      img += _this.createDataURL(cellSize, margin);
      img += '"';
      img += '\u0020width="';
      img += size;
      img += '"';
      img += '\u0020height="';
      img += size;
      img += '"';
      if (alt) {
        img += '\u0020alt="';
        img += alt;
        img += '"';
      }
      img += '/>';

      return img;
    };

    var _createHalfASCII = function(margin) {
      var cellSize = 1;
      margin = (typeof margin == 'undefined')? cellSize * 2 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var min = margin;
      var max = size - margin;

      var y, x, r1, r2, p;

      var blocks = {
        '██': '█',
        '█ ': '▀',
        ' █': '▄',
        '  ': ' '
      };

      var ascii = '';
      for (y = 0; y < size; y += 2) {
        r1 = Math.floor((y - min) / cellSize);
        r2 = Math.floor((y + 1 - min) / cellSize);
        for (x = 0; x < size; x += 1) {
          p = '█';

          if (min <= x && x < max && min <= y && y < max && _this.isDark(r1, Math.floor((x - min) / cellSize))) {
            p = ' ';
          }

          if (min <= x && x < max && min <= y+1 && y+1 < max && _this.isDark(r2, Math.floor((x - min) / cellSize))) {
            p += ' ';
          }
          else {
            p += '█';
          }

          // Output 2 characters per pixel, to create full square. 1 character per pixels gives only half width of square.
          ascii += blocks[p];
        }

        ascii += '\n';
      }

      if (size % 2) {
        return ascii.substring(0, ascii.length - size - 1) + Array(size+1).join('▀');
      }

      return ascii.substring(0, ascii.length-1);
    };

    _this.createASCII = function(cellSize, margin) {
      cellSize = cellSize || 1;

      if (cellSize < 2) {
        return _createHalfASCII(margin);
      }

      cellSize -= 1;
      margin = (typeof margin == 'undefined')? cellSize * 2 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var min = margin;
      var max = size - margin;

      var y, x, r, p;

      var white = Array(cellSize+1).join('██');
      var black = Array(cellSize+1).join('  ');

      var ascii = '';
      var line = '';
      for (y = 0; y < size; y += 1) {
        r = Math.floor( (y - min) / cellSize);
        line = '';
        for (x = 0; x < size; x += 1) {
          p = 1;

          if (min <= x && x < max && min <= y && y < max && _this.isDark(r, Math.floor((x - min) / cellSize))) {
            p = 0;
          }

          // Output 2 characters per pixel, to create full square. 1 character per pixels gives only half width of square.
          line += p ? white : black;
        }

        for (r = 0; r < cellSize; r += 1) {
          ascii += line + '\n';
        }
      }

      return ascii.substring(0, ascii.length-1);
    };

    _this.renderTo2dContext = function(context, cellSize) {
      cellSize = cellSize || 2;
      var length = _this.getModuleCount();
      for (var row = 0; row < length; row++) {
        for (var col = 0; col < length; col++) {
          context.fillStyle = _this.isDark(row, col) ? 'black' : 'white';
          context.fillRect(row * cellSize, col * cellSize, cellSize, cellSize);
        }
      }
    }

    return _this;
  };

  //---------------------------------------------------------------------
  // qrcode.stringToBytes
  //---------------------------------------------------------------------

  qrcode.stringToBytesFuncs = {
    'default' : function(s) {
      var bytes = [];
      for (var i = 0; i < s.length; i += 1) {
        var c = s.charCodeAt(i);
        bytes.push(c & 0xff);
      }
      return bytes;
    }
  };

  qrcode.stringToBytes = qrcode.stringToBytesFuncs['default'];

  //---------------------------------------------------------------------
  // qrcode.createStringToBytes
  //---------------------------------------------------------------------

  /**
   * @param unicodeData base64 string of byte array.
   * [16bit Unicode],[16bit Bytes], ...
   * @param numChars
   */
  qrcode.createStringToBytes = function(unicodeData, numChars) {

    // create conversion map.

    var unicodeMap = function() {

      var bin = base64DecodeInputStream(unicodeData);
      var read = function() {
        var b = bin.read();
        if (b == -1) throw 'eof';
        return b;
      };

      var count = 0;
      var unicodeMap = {};
      while (true) {
        var b0 = bin.read();
        if (b0 == -1) break;
        var b1 = read();
        var b2 = read();
        var b3 = read();
        var k = String.fromCharCode( (b0 << 8) | b1);
        var v = (b2 << 8) | b3;
        unicodeMap[k] = v;
        count += 1;
      }
      if (count != numChars) {
        throw count + ' != ' + numChars;
      }

      return unicodeMap;
    }();

    var unknownChar = '?'.charCodeAt(0);

    return function(s) {
      var bytes = [];
      for (var i = 0; i < s.length; i += 1) {
        var c = s.charCodeAt(i);
        if (c < 128) {
          bytes.push(c);
        } else {
          var b = unicodeMap[s.charAt(i)];
          if (typeof b == 'number') {
            if ( (b & 0xff) == b) {
              // 1byte
              bytes.push(b);
            } else {
              // 2bytes
              bytes.push(b >>> 8);
              bytes.push(b & 0xff);
            }
          } else {
            bytes.push(unknownChar);
          }
        }
      }
      return bytes;
    };
  };

  //---------------------------------------------------------------------
  // QRMode
  //---------------------------------------------------------------------

  var QRMode = {
    MODE_NUMBER :    1 << 0,
    MODE_ALPHA_NUM : 1 << 1,
    MODE_8BIT_BYTE : 1 << 2,
    MODE_KANJI :     1 << 3
  };

  //---------------------------------------------------------------------
  // QRErrorCorrectionLevel
  //---------------------------------------------------------------------

  var QRErrorCorrectionLevel = {
    L : 1,
    M : 0,
    Q : 3,
    H : 2
  };

  //---------------------------------------------------------------------
  // QRMaskPattern
  //---------------------------------------------------------------------

  var QRMaskPattern = {
    PATTERN000 : 0,
    PATTERN001 : 1,
    PATTERN010 : 2,
    PATTERN011 : 3,
    PATTERN100 : 4,
    PATTERN101 : 5,
    PATTERN110 : 6,
    PATTERN111 : 7
  };

  //---------------------------------------------------------------------
  // QRUtil
  //---------------------------------------------------------------------

  var QRUtil = function() {

    var PATTERN_POSITION_TABLE = [
      [],
      [6, 18],
      [6, 22],
      [6, 26],
      [6, 30],
      [6, 34],
      [6, 22, 38],
      [6, 24, 42],
      [6, 26, 46],
      [6, 28, 50],
      [6, 30, 54],
      [6, 32, 58],
      [6, 34, 62],
      [6, 26, 46, 66],
      [6, 26, 48, 70],
      [6, 26, 50, 74],
      [6, 30, 54, 78],
      [6, 30, 56, 82],
      [6, 30, 58, 86],
      [6, 34, 62, 90],
      [6, 28, 50, 72, 94],
      [6, 26, 50, 74, 98],
      [6, 30, 54, 78, 102],
      [6, 28, 54, 80, 106],
      [6, 32, 58, 84, 110],
      [6, 30, 58, 86, 114],
      [6, 34, 62, 90, 118],
      [6, 26, 50, 74, 98, 122],
      [6, 30, 54, 78, 102, 126],
      [6, 26, 52, 78, 104, 130],
      [6, 30, 56, 82, 108, 134],
      [6, 34, 60, 86, 112, 138],
      [6, 30, 58, 86, 114, 142],
      [6, 34, 62, 90, 118, 146],
      [6, 30, 54, 78, 102, 126, 150],
      [6, 24, 50, 76, 102, 128, 154],
      [6, 28, 54, 80, 106, 132, 158],
      [6, 32, 58, 84, 110, 136, 162],
      [6, 26, 54, 82, 110, 138, 166],
      [6, 30, 58, 86, 114, 142, 170]
    ];
    var G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);
    var G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);
    var G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);

    var _this = {};

    var getBCHDigit = function(data) {
      var digit = 0;
      while (data != 0) {
        digit += 1;
        data >>>= 1;
      }
      return digit;
    };

    _this.getBCHTypeInfo = function(data) {
      var d = data << 10;
      while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {
        d ^= (G15 << (getBCHDigit(d) - getBCHDigit(G15) ) );
      }
      return ( (data << 10) | d) ^ G15_MASK;
    };

    _this.getBCHTypeNumber = function(data) {
      var d = data << 12;
      while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {
        d ^= (G18 << (getBCHDigit(d) - getBCHDigit(G18) ) );
      }
      return (data << 12) | d;
    };

    _this.getPatternPosition = function(typeNumber) {
      return PATTERN_POSITION_TABLE[typeNumber - 1];
    };

    _this.getMaskFunction = function(maskPattern) {

      switch (maskPattern) {

      case QRMaskPattern.PATTERN000 :
        return function(i, j) { return (i + j) % 2 == 0; };
      case QRMaskPattern.PATTERN001 :
        return function(i, j) { return i % 2 == 0; };
      case QRMaskPattern.PATTERN010 :
        return function(i, j) { return j % 3 == 0; };
      case QRMaskPattern.PATTERN011 :
        return function(i, j) { return (i + j) % 3 == 0; };
      case QRMaskPattern.PATTERN100 :
        return function(i, j) { return (Math.floor(i / 2) + Math.floor(j / 3) ) % 2 == 0; };
      case QRMaskPattern.PATTERN101 :
        return function(i, j) { return (i * j) % 2 + (i * j) % 3 == 0; };
      case QRMaskPattern.PATTERN110 :
        return function(i, j) { return ( (i * j) % 2 + (i * j) % 3) % 2 == 0; };
      case QRMaskPattern.PATTERN111 :
        return function(i, j) { return ( (i * j) % 3 + (i + j) % 2) % 2 == 0; };

      default :
        throw 'bad maskPattern:' + maskPattern;
      }
    };

    _this.getErrorCorrectPolynomial = function(errorCorrectLength) {
      var a = qrPolynomial([1], 0);
      for (var i = 0; i < errorCorrectLength; i += 1) {
        a = a.multiply(qrPolynomial([1, QRMath.gexp(i)], 0) );
      }
      return a;
    };

    _this.getLengthInBits = function(mode, type) {

      if (1 <= type && type < 10) {

        // 1 - 9

        switch(mode) {
        case QRMode.MODE_NUMBER    : return 10;
        case QRMode.MODE_ALPHA_NUM : return 9;
        case QRMode.MODE_8BIT_BYTE : return 8;
        case QRMode.MODE_KANJI     : return 8;
        default :
          throw 'mode:' + mode;
        }

      } else if (type < 27) {

        // 10 - 26

        switch(mode) {
        case QRMode.MODE_NUMBER    : return 12;
        case QRMode.MODE_ALPHA_NUM : return 11;
        case QRMode.MODE_8BIT_BYTE : return 16;
        case QRMode.MODE_KANJI     : return 10;
        default :
          throw 'mode:' + mode;
        }

      } else if (type < 41) {

        // 27 - 40

        switch(mode) {
        case QRMode.MODE_NUMBER    : return 14;
        case QRMode.MODE_ALPHA_NUM : return 13;
        case QRMode.MODE_8BIT_BYTE : return 16;
        case QRMode.MODE_KANJI     : return 12;
        default :
          throw 'mode:' + mode;
        }

      } else {
        throw 'type:' + type;
      }
    };

    _this.getLostPoint = function(qrcode) {

      var moduleCount = qrcode.getModuleCount();

      var lostPoint = 0;

      // LEVEL1

      for (var row = 0; row < moduleCount; row += 1) {
        for (var col = 0; col < moduleCount; col += 1) {

          var sameCount = 0;
          var dark = qrcode.isDark(row, col);

          for (var r = -1; r <= 1; r += 1) {

            if (row + r < 0 || moduleCount <= row + r) {
              continue;
            }

            for (var c = -1; c <= 1; c += 1) {

              if (col + c < 0 || moduleCount <= col + c) {
                continue;
              }

              if (r == 0 && c == 0) {
                continue;
              }

              if (dark == qrcode.isDark(row + r, col + c) ) {
                sameCount += 1;
              }
            }
          }

          if (sameCount > 5) {
            lostPoint += (3 + sameCount - 5);
          }
        }
      };

      // LEVEL2

      for (var row = 0; row < moduleCount - 1; row += 1) {
        for (var col = 0; col < moduleCount - 1; col += 1) {
          var count = 0;
          if (qrcode.isDark(row, col) ) count += 1;
          if (qrcode.isDark(row + 1, col) ) count += 1;
          if (qrcode.isDark(row, col + 1) ) count += 1;
          if (qrcode.isDark(row + 1, col + 1) ) count += 1;
          if (count == 0 || count == 4) {
            lostPoint += 3;
          }
        }
      }

      // LEVEL3

      for (var row = 0; row < moduleCount; row += 1) {
        for (var col = 0; col < moduleCount - 6; col += 1) {
          if (qrcode.isDark(row, col)
              && !qrcode.isDark(row, col + 1)
              &&  qrcode.isDark(row, col + 2)
              &&  qrcode.isDark(row, col + 3)
              &&  qrcode.isDark(row, col + 4)
              && !qrcode.isDark(row, col + 5)
              &&  qrcode.isDark(row, col + 6) ) {
            lostPoint += 40;
          }
        }
      }

      for (var col = 0; col < moduleCount; col += 1) {
        for (var row = 0; row < moduleCount - 6; row += 1) {
          if (qrcode.isDark(row, col)
              && !qrcode.isDark(row + 1, col)
              &&  qrcode.isDark(row + 2, col)
              &&  qrcode.isDark(row + 3, col)
              &&  qrcode.isDark(row + 4, col)
              && !qrcode.isDark(row + 5, col)
              &&  qrcode.isDark(row + 6, col) ) {
            lostPoint += 40;
          }
        }
      }

      // LEVEL4

      var darkCount = 0;

      for (var col = 0; col < moduleCount; col += 1) {
        for (var row = 0; row < moduleCount; row += 1) {
          if (qrcode.isDark(row, col) ) {
            darkCount += 1;
          }
        }
      }

      var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
      lostPoint += ratio * 10;

      return lostPoint;
    };

    return _this;
  }();

  //---------------------------------------------------------------------
  // QRMath
  //---------------------------------------------------------------------

  var QRMath = function() {

    var EXP_TABLE = new Array(256);
    var LOG_TABLE = new Array(256);

    // initialize tables
    for (var i = 0; i < 8; i += 1) {
      EXP_TABLE[i] = 1 << i;
    }
    for (var i = 8; i < 256; i += 1) {
      EXP_TABLE[i] = EXP_TABLE[i - 4]
        ^ EXP_TABLE[i - 5]
        ^ EXP_TABLE[i - 6]
        ^ EXP_TABLE[i - 8];
    }
    for (var i = 0; i < 255; i += 1) {
      LOG_TABLE[EXP_TABLE[i] ] = i;
    }

    var _this = {};

    _this.glog = function(n) {

      if (n < 1) {
        throw 'glog(' + n + ')';
      }

      return LOG_TABLE[n];
    };

    _this.gexp = function(n) {

      while (n < 0) {
        n += 255;
      }

      while (n >= 256) {
        n -= 255;
      }

      return EXP_TABLE[n];
    };

    return _this;
  }();

  //---------------------------------------------------------------------
  // qrPolynomial
  //---------------------------------------------------------------------

  function qrPolynomial(num, shift) {

    if (typeof num.length == 'undefined') {
      throw num.length + '/' + shift;
    }

    var _num = function() {
      var offset = 0;
      while (offset < num.length && num[offset] == 0) {
        offset += 1;
      }
      var _num = new Array(num.length - offset + shift);
      for (var i = 0; i < num.length - offset; i += 1) {
        _num[i] = num[i + offset];
      }
      return _num;
    }();

    var _this = {};

    _this.getAt = function(index) {
      return _num[index];
    };

    _this.getLength = function() {
      return _num.length;
    };

    _this.multiply = function(e) {

      var num = new Array(_this.getLength() + e.getLength() - 1);

      for (var i = 0; i < _this.getLength(); i += 1) {
        for (var j = 0; j < e.getLength(); j += 1) {
          num[i + j] ^= QRMath.gexp(QRMath.glog(_this.getAt(i) ) + QRMath.glog(e.getAt(j) ) );
        }
      }

      return qrPolynomial(num, 0);
    };

    _this.mod = function(e) {

      if (_this.getLength() - e.getLength() < 0) {
        return _this;
      }

      var ratio = QRMath.glog(_this.getAt(0) ) - QRMath.glog(e.getAt(0) );

      var num = new Array(_this.getLength() );
      for (var i = 0; i < _this.getLength(); i += 1) {
        num[i] = _this.getAt(i);
      }

      for (var i = 0; i < e.getLength(); i += 1) {
        num[i] ^= QRMath.gexp(QRMath.glog(e.getAt(i) ) + ratio);
      }

      // recursive call
      return qrPolynomial(num, 0).mod(e);
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // QRRSBlock
  //---------------------------------------------------------------------

  var QRRSBlock = function() {

    var RS_BLOCK_TABLE = [

      // L
      // M
      // Q
      // H

      // 1
      [1, 26, 19],
      [1, 26, 16],
      [1, 26, 13],
      [1, 26, 9],

      // 2
      [1, 44, 34],
      [1, 44, 28],
      [1, 44, 22],
      [1, 44, 16],

      // 3
      [1, 70, 55],
      [1, 70, 44],
      [2, 35, 17],
      [2, 35, 13],

      // 4
      [1, 100, 80],
      [2, 50, 32],
      [2, 50, 24],
      [4, 25, 9],

      // 5
      [1, 134, 108],
      [2, 67, 43],
      [2, 33, 15, 2, 34, 16],
      [2, 33, 11, 2, 34, 12],

      // 6
      [2, 86, 68],
      [4, 43, 27],
      [4, 43, 19],
      [4, 43, 15],

      // 7
      [2, 98, 78],
      [4, 49, 31],
      [2, 32, 14, 4, 33, 15],
      [4, 39, 13, 1, 40, 14],

      // 8
      [2, 121, 97],
      [2, 60, 38, 2, 61, 39],
      [4, 40, 18, 2, 41, 19],
      [4, 40, 14, 2, 41, 15],

      // 9
      [2, 146, 116],
      [3, 58, 36, 2, 59, 37],
      [4, 36, 16, 4, 37, 17],
      [4, 36, 12, 4, 37, 13],

      // 10
      [2, 86, 68, 2, 87, 69],
      [4, 69, 43, 1, 70, 44],
      [6, 43, 19, 2, 44, 20],
      [6, 43, 15, 2, 44, 16],

      // 11
      [4, 101, 81],
      [1, 80, 50, 4, 81, 51],
      [4, 50, 22, 4, 51, 23],
      [3, 36, 12, 8, 37, 13],

      // 12
      [2, 116, 92, 2, 117, 93],
      [6, 58, 36, 2, 59, 37],
      [4, 46, 20, 6, 47, 21],
      [7, 42, 14, 4, 43, 15],

      // 13
      [4, 133, 107],
      [8, 59, 37, 1, 60, 38],
      [8, 44, 20, 4, 45, 21],
      [12, 33, 11, 4, 34, 12],

      // 14
      [3, 145, 115, 1, 146, 116],
      [4, 64, 40, 5, 65, 41],
      [11, 36, 16, 5, 37, 17],
      [11, 36, 12, 5, 37, 13],

      // 15
      [5, 109, 87, 1, 110, 88],
      [5, 65, 41, 5, 66, 42],
      [5, 54, 24, 7, 55, 25],
      [11, 36, 12, 7, 37, 13],

      // 16
      [5, 122, 98, 1, 123, 99],
      [7, 73, 45, 3, 74, 46],
      [15, 43, 19, 2, 44, 20],
      [3, 45, 15, 13, 46, 16],

      // 17
      [1, 135, 107, 5, 136, 108],
      [10, 74, 46, 1, 75, 47],
      [1, 50, 22, 15, 51, 23],
      [2, 42, 14, 17, 43, 15],

      // 18
      [5, 150, 120, 1, 151, 121],
      [9, 69, 43, 4, 70, 44],
      [17, 50, 22, 1, 51, 23],
      [2, 42, 14, 19, 43, 15],

      // 19
      [3, 141, 113, 4, 142, 114],
      [3, 70, 44, 11, 71, 45],
      [17, 47, 21, 4, 48, 22],
      [9, 39, 13, 16, 40, 14],

      // 20
      [3, 135, 107, 5, 136, 108],
      [3, 67, 41, 13, 68, 42],
      [15, 54, 24, 5, 55, 25],
      [15, 43, 15, 10, 44, 16],

      // 21
      [4, 144, 116, 4, 145, 117],
      [17, 68, 42],
      [17, 50, 22, 6, 51, 23],
      [19, 46, 16, 6, 47, 17],

      // 22
      [2, 139, 111, 7, 140, 112],
      [17, 74, 46],
      [7, 54, 24, 16, 55, 25],
      [34, 37, 13],

      // 23
      [4, 151, 121, 5, 152, 122],
      [4, 75, 47, 14, 76, 48],
      [11, 54, 24, 14, 55, 25],
      [16, 45, 15, 14, 46, 16],

      // 24
      [6, 147, 117, 4, 148, 118],
      [6, 73, 45, 14, 74, 46],
      [11, 54, 24, 16, 55, 25],
      [30, 46, 16, 2, 47, 17],

      // 25
      [8, 132, 106, 4, 133, 107],
      [8, 75, 47, 13, 76, 48],
      [7, 54, 24, 22, 55, 25],
      [22, 45, 15, 13, 46, 16],

      // 26
      [10, 142, 114, 2, 143, 115],
      [19, 74, 46, 4, 75, 47],
      [28, 50, 22, 6, 51, 23],
      [33, 46, 16, 4, 47, 17],

      // 27
      [8, 152, 122, 4, 153, 123],
      [22, 73, 45, 3, 74, 46],
      [8, 53, 23, 26, 54, 24],
      [12, 45, 15, 28, 46, 16],

      // 28
      [3, 147, 117, 10, 148, 118],
      [3, 73, 45, 23, 74, 46],
      [4, 54, 24, 31, 55, 25],
      [11, 45, 15, 31, 46, 16],

      // 29
      [7, 146, 116, 7, 147, 117],
      [21, 73, 45, 7, 74, 46],
      [1, 53, 23, 37, 54, 24],
      [19, 45, 15, 26, 46, 16],

      // 30
      [5, 145, 115, 10, 146, 116],
      [19, 75, 47, 10, 76, 48],
      [15, 54, 24, 25, 55, 25],
      [23, 45, 15, 25, 46, 16],

      // 31
      [13, 145, 115, 3, 146, 116],
      [2, 74, 46, 29, 75, 47],
      [42, 54, 24, 1, 55, 25],
      [23, 45, 15, 28, 46, 16],

      // 32
      [17, 145, 115],
      [10, 74, 46, 23, 75, 47],
      [10, 54, 24, 35, 55, 25],
      [19, 45, 15, 35, 46, 16],

      // 33
      [17, 145, 115, 1, 146, 116],
      [14, 74, 46, 21, 75, 47],
      [29, 54, 24, 19, 55, 25],
      [11, 45, 15, 46, 46, 16],

      // 34
      [13, 145, 115, 6, 146, 116],
      [14, 74, 46, 23, 75, 47],
      [44, 54, 24, 7, 55, 25],
      [59, 46, 16, 1, 47, 17],

      // 35
      [12, 151, 121, 7, 152, 122],
      [12, 75, 47, 26, 76, 48],
      [39, 54, 24, 14, 55, 25],
      [22, 45, 15, 41, 46, 16],

      // 36
      [6, 151, 121, 14, 152, 122],
      [6, 75, 47, 34, 76, 48],
      [46, 54, 24, 10, 55, 25],
      [2, 45, 15, 64, 46, 16],

      // 37
      [17, 152, 122, 4, 153, 123],
      [29, 74, 46, 14, 75, 47],
      [49, 54, 24, 10, 55, 25],
      [24, 45, 15, 46, 46, 16],

      // 38
      [4, 152, 122, 18, 153, 123],
      [13, 74, 46, 32, 75, 47],
      [48, 54, 24, 14, 55, 25],
      [42, 45, 15, 32, 46, 16],

      // 39
      [20, 147, 117, 4, 148, 118],
      [40, 75, 47, 7, 76, 48],
      [43, 54, 24, 22, 55, 25],
      [10, 45, 15, 67, 46, 16],

      // 40
      [19, 148, 118, 6, 149, 119],
      [18, 75, 47, 31, 76, 48],
      [34, 54, 24, 34, 55, 25],
      [20, 45, 15, 61, 46, 16]
    ];

    var qrRSBlock = function(totalCount, dataCount) {
      var _this = {};
      _this.totalCount = totalCount;
      _this.dataCount = dataCount;
      return _this;
    };

    var _this = {};

    var getRsBlockTable = function(typeNumber, errorCorrectionLevel) {

      switch(errorCorrectionLevel) {
      case QRErrorCorrectionLevel.L :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
      case QRErrorCorrectionLevel.M :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
      case QRErrorCorrectionLevel.Q :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
      case QRErrorCorrectionLevel.H :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
      default :
        return undefined;
      }
    };

    _this.getRSBlocks = function(typeNumber, errorCorrectionLevel) {

      var rsBlock = getRsBlockTable(typeNumber, errorCorrectionLevel);

      if (typeof rsBlock == 'undefined') {
        throw 'bad rs block @ typeNumber:' + typeNumber +
            '/errorCorrectionLevel:' + errorCorrectionLevel;
      }

      var length = rsBlock.length / 3;

      var list = [];

      for (var i = 0; i < length; i += 1) {

        var count = rsBlock[i * 3 + 0];
        var totalCount = rsBlock[i * 3 + 1];
        var dataCount = rsBlock[i * 3 + 2];

        for (var j = 0; j < count; j += 1) {
          list.push(qrRSBlock(totalCount, dataCount) );
        }
      }

      return list;
    };

    return _this;
  }();

  //---------------------------------------------------------------------
  // qrBitBuffer
  //---------------------------------------------------------------------

  var qrBitBuffer = function() {

    var _buffer = [];
    var _length = 0;

    var _this = {};

    _this.getBuffer = function() {
      return _buffer;
    };

    _this.getAt = function(index) {
      var bufIndex = Math.floor(index / 8);
      return ( (_buffer[bufIndex] >>> (7 - index % 8) ) & 1) == 1;
    };

    _this.put = function(num, length) {
      for (var i = 0; i < length; i += 1) {
        _this.putBit( ( (num >>> (length - i - 1) ) & 1) == 1);
      }
    };

    _this.getLengthInBits = function() {
      return _length;
    };

    _this.putBit = function(bit) {

      var bufIndex = Math.floor(_length / 8);
      if (_buffer.length <= bufIndex) {
        _buffer.push(0);
      }

      if (bit) {
        _buffer[bufIndex] |= (0x80 >>> (_length % 8) );
      }

      _length += 1;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qrNumber
  //---------------------------------------------------------------------

  var qrNumber = function(data) {

    var _mode = QRMode.MODE_NUMBER;
    var _data = data;

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return _data.length;
    };

    _this.write = function(buffer) {

      var data = _data;

      var i = 0;

      while (i + 2 < data.length) {
        buffer.put(strToNum(data.substring(i, i + 3) ), 10);
        i += 3;
      }

      if (i < data.length) {
        if (data.length - i == 1) {
          buffer.put(strToNum(data.substring(i, i + 1) ), 4);
        } else if (data.length - i == 2) {
          buffer.put(strToNum(data.substring(i, i + 2) ), 7);
        }
      }
    };

    var strToNum = function(s) {
      var num = 0;
      for (var i = 0; i < s.length; i += 1) {
        num = num * 10 + chatToNum(s.charAt(i) );
      }
      return num;
    };

    var chatToNum = function(c) {
      if ('0' <= c && c <= '9') {
        return c.charCodeAt(0) - '0'.charCodeAt(0);
      }
      throw 'illegal char :' + c;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qrAlphaNum
  //---------------------------------------------------------------------

  var qrAlphaNum = function(data) {

    var _mode = QRMode.MODE_ALPHA_NUM;
    var _data = data;

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return _data.length;
    };

    _this.write = function(buffer) {

      var s = _data;

      var i = 0;

      while (i + 1 < s.length) {
        buffer.put(
          getCode(s.charAt(i) ) * 45 +
          getCode(s.charAt(i + 1) ), 11);
        i += 2;
      }

      if (i < s.length) {
        buffer.put(getCode(s.charAt(i) ), 6);
      }
    };

    var getCode = function(c) {

      if ('0' <= c && c <= '9') {
        return c.charCodeAt(0) - '0'.charCodeAt(0);
      } else if ('A' <= c && c <= 'Z') {
        return c.charCodeAt(0) - 'A'.charCodeAt(0) + 10;
      } else {
        switch (c) {
        case ' ' : return 36;
        case '$' : return 37;
        case '%' : return 38;
        case '*' : return 39;
        case '+' : return 40;
        case '-' : return 41;
        case '.' : return 42;
        case '/' : return 43;
        case ':' : return 44;
        default :
          throw 'illegal char :' + c;
        }
      }
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qr8BitByte
  //---------------------------------------------------------------------

  var qr8BitByte = function(data) {

    var _mode = QRMode.MODE_8BIT_BYTE;
    var _data = data;
    var _bytes = qrcode.stringToBytes(data);

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return _bytes.length;
    };

    _this.write = function(buffer) {
      for (var i = 0; i < _bytes.length; i += 1) {
        buffer.put(_bytes[i], 8);
      }
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qrKanji
  //---------------------------------------------------------------------

  var qrKanji = function(data) {

    var _mode = QRMode.MODE_KANJI;
    var _data = data;

    var stringToBytes = qrcode.stringToBytesFuncs['SJIS'];
    if (!stringToBytes) {
      throw 'sjis not supported.';
    }
    !function(c, code) {
      // self test for sjis support.
      var test = stringToBytes(c);
      if (test.length != 2 || ( (test[0] << 8) | test[1]) != code) {
        throw 'sjis not supported.';
      }
    }('\u53cb', 0x9746);

    var _bytes = stringToBytes(data);

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return ~~(_bytes.length / 2);
    };

    _this.write = function(buffer) {

      var data = _bytes;

      var i = 0;

      while (i + 1 < data.length) {

        var c = ( (0xff & data[i]) << 8) | (0xff & data[i + 1]);

        if (0x8140 <= c && c <= 0x9FFC) {
          c -= 0x8140;
        } else if (0xE040 <= c && c <= 0xEBBF) {
          c -= 0xC140;
        } else {
          throw 'illegal char at ' + (i + 1) + '/' + c;
        }

        c = ( (c >>> 8) & 0xff) * 0xC0 + (c & 0xff);

        buffer.put(c, 13);

        i += 2;
      }

      if (i < data.length) {
        throw 'illegal char at ' + (i + 1);
      }
    };

    return _this;
  };

  //=====================================================================
  // GIF Support etc.
  //

  //---------------------------------------------------------------------
  // byteArrayOutputStream
  //---------------------------------------------------------------------

  var byteArrayOutputStream = function() {

    var _bytes = [];

    var _this = {};

    _this.writeByte = function(b) {
      _bytes.push(b & 0xff);
    };

    _this.writeShort = function(i) {
      _this.writeByte(i);
      _this.writeByte(i >>> 8);
    };

    _this.writeBytes = function(b, off, len) {
      off = off || 0;
      len = len || b.length;
      for (var i = 0; i < len; i += 1) {
        _this.writeByte(b[i + off]);
      }
    };

    _this.writeString = function(s) {
      for (var i = 0; i < s.length; i += 1) {
        _this.writeByte(s.charCodeAt(i) );
      }
    };

    _this.toByteArray = function() {
      return _bytes;
    };

    _this.toString = function() {
      var s = '';
      s += '[';
      for (var i = 0; i < _bytes.length; i += 1) {
        if (i > 0) {
          s += ',';
        }
        s += _bytes[i];
      }
      s += ']';
      return s;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // base64EncodeOutputStream
  //---------------------------------------------------------------------

  var base64EncodeOutputStream = function() {

    var _buffer = 0;
    var _buflen = 0;
    var _length = 0;
    var _base64 = '';

    var _this = {};

    var writeEncoded = function(b) {
      _base64 += String.fromCharCode(encode(b & 0x3f) );
    };

    var encode = function(n) {
      if (n < 0) {
        // error.
      } else if (n < 26) {
        return 0x41 + n;
      } else if (n < 52) {
        return 0x61 + (n - 26);
      } else if (n < 62) {
        return 0x30 + (n - 52);
      } else if (n == 62) {
        return 0x2b;
      } else if (n == 63) {
        return 0x2f;
      }
      throw 'n:' + n;
    };

    _this.writeByte = function(n) {

      _buffer = (_buffer << 8) | (n & 0xff);
      _buflen += 8;
      _length += 1;

      while (_buflen >= 6) {
        writeEncoded(_buffer >>> (_buflen - 6) );
        _buflen -= 6;
      }
    };

    _this.flush = function() {

      if (_buflen > 0) {
        writeEncoded(_buffer << (6 - _buflen) );
        _buffer = 0;
        _buflen = 0;
      }

      if (_length % 3 != 0) {
        // padding
        var padlen = 3 - _length % 3;
        for (var i = 0; i < padlen; i += 1) {
          _base64 += '=';
        }
      }
    };

    _this.toString = function() {
      return _base64;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // base64DecodeInputStream
  //---------------------------------------------------------------------

  var base64DecodeInputStream = function(str) {

    var _str = str;
    var _pos = 0;
    var _buffer = 0;
    var _buflen = 0;

    var _this = {};

    _this.read = function() {

      while (_buflen < 8) {

        if (_pos >= _str.length) {
          if (_buflen == 0) {
            return -1;
          }
          throw 'unexpected end of file./' + _buflen;
        }

        var c = _str.charAt(_pos);
        _pos += 1;

        if (c == '=') {
          _buflen = 0;
          return -1;
        } else if (c.match(/^\s$/) ) {
          // ignore if whitespace.
          continue;
        }

        _buffer = (_buffer << 6) | decode(c.charCodeAt(0) );
        _buflen += 6;
      }

      var n = (_buffer >>> (_buflen - 8) ) & 0xff;
      _buflen -= 8;
      return n;
    };

    var decode = function(c) {
      if (0x41 <= c && c <= 0x5a) {
        return c - 0x41;
      } else if (0x61 <= c && c <= 0x7a) {
        return c - 0x61 + 26;
      } else if (0x30 <= c && c <= 0x39) {
        return c - 0x30 + 52;
      } else if (c == 0x2b) {
        return 62;
      } else if (c == 0x2f) {
        return 63;
      } else {
        throw 'c:' + c;
      }
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // gifImage (B/W)
  //---------------------------------------------------------------------

  var gifImage = function(width, height) {

    var _width = width;
    var _height = height;
    var _data = new Array(width * height);

    var _this = {};

    _this.setPixel = function(x, y, pixel) {
      _data[y * _width + x] = pixel;
    };

    _this.write = function(out) {

      //---------------------------------
      // GIF Signature

      out.writeString('GIF87a');

      //---------------------------------
      // Screen Descriptor

      out.writeShort(_width);
      out.writeShort(_height);

      out.writeByte(0x80); // 2bit
      out.writeByte(0);
      out.writeByte(0);

      //---------------------------------
      // Global Color Map

      // black
      out.writeByte(0x00);
      out.writeByte(0x00);
      out.writeByte(0x00);

      // white
      out.writeByte(0xff);
      out.writeByte(0xff);
      out.writeByte(0xff);

      //---------------------------------
      // Image Descriptor

      out.writeString(',');
      out.writeShort(0);
      out.writeShort(0);
      out.writeShort(_width);
      out.writeShort(_height);
      out.writeByte(0);

      //---------------------------------
      // Local Color Map

      //---------------------------------
      // Raster Data

      var lzwMinCodeSize = 2;
      var raster = getLZWRaster(lzwMinCodeSize);

      out.writeByte(lzwMinCodeSize);

      var offset = 0;

      while (raster.length - offset > 255) {
        out.writeByte(255);
        out.writeBytes(raster, offset, 255);
        offset += 255;
      }

      out.writeByte(raster.length - offset);
      out.writeBytes(raster, offset, raster.length - offset);
      out.writeByte(0x00);

      //---------------------------------
      // GIF Terminator
      out.writeString(';');
    };

    var bitOutputStream = function(out) {

      var _out = out;
      var _bitLength = 0;
      var _bitBuffer = 0;

      var _this = {};

      _this.write = function(data, length) {

        if ( (data >>> length) != 0) {
          throw 'length over';
        }

        while (_bitLength + length >= 8) {
          _out.writeByte(0xff & ( (data << _bitLength) | _bitBuffer) );
          length -= (8 - _bitLength);
          data >>>= (8 - _bitLength);
          _bitBuffer = 0;
          _bitLength = 0;
        }

        _bitBuffer = (data << _bitLength) | _bitBuffer;
        _bitLength = _bitLength + length;
      };

      _this.flush = function() {
        if (_bitLength > 0) {
          _out.writeByte(_bitBuffer);
        }
      };

      return _this;
    };

    var getLZWRaster = function(lzwMinCodeSize) {

      var clearCode = 1 << lzwMinCodeSize;
      var endCode = (1 << lzwMinCodeSize) + 1;
      var bitLength = lzwMinCodeSize + 1;

      // Setup LZWTable
      var table = lzwTable();

      for (var i = 0; i < clearCode; i += 1) {
        table.add(String.fromCharCode(i) );
      }
      table.add(String.fromCharCode(clearCode) );
      table.add(String.fromCharCode(endCode) );

      var byteOut = byteArrayOutputStream();
      var bitOut = bitOutputStream(byteOut);

      // clear code
      bitOut.write(clearCode, bitLength);

      var dataIndex = 0;

      var s = String.fromCharCode(_data[dataIndex]);
      dataIndex += 1;

      while (dataIndex < _data.length) {

        var c = String.fromCharCode(_data[dataIndex]);
        dataIndex += 1;

        if (table.contains(s + c) ) {

          s = s + c;

        } else {

          bitOut.write(table.indexOf(s), bitLength);

          if (table.size() < 0xfff) {

            if (table.size() == (1 << bitLength) ) {
              bitLength += 1;
            }

            table.add(s + c);
          }

          s = c;
        }
      }

      bitOut.write(table.indexOf(s), bitLength);

      // end code
      bitOut.write(endCode, bitLength);

      bitOut.flush();

      return byteOut.toByteArray();
    };

    var lzwTable = function() {

      var _map = {};
      var _size = 0;

      var _this = {};

      _this.add = function(key) {
        if (_this.contains(key) ) {
          throw 'dup key:' + key;
        }
        _map[key] = _size;
        _size += 1;
      };

      _this.size = function() {
        return _size;
      };

      _this.indexOf = function(key) {
        return _map[key];
      };

      _this.contains = function(key) {
        return typeof _map[key] != 'undefined';
      };

      return _this;
    };

    return _this;
  };

  var createDataURL = function(width, height, getPixel) {
    var gif = gifImage(width, height);
    for (var y = 0; y < height; y += 1) {
      for (var x = 0; x < width; x += 1) {
        gif.setPixel(x, y, getPixel(x, y) );
      }
    }

    var b = byteArrayOutputStream();
    gif.write(b);

    var base64 = base64EncodeOutputStream();
    var bytes = b.toByteArray();
    for (var i = 0; i < bytes.length; i += 1) {
      base64.writeByte(bytes[i]);
    }
    base64.flush();

    return 'data:image/gif;base64,' + base64;
  };

  //---------------------------------------------------------------------
  // returns qrcode function.

  return qrcode;
}();

// multibyte support
!function() {

  qrcode.stringToBytesFuncs['UTF-8'] = function(s) {
    // http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
    function toUTF8Array(str) {
      var utf8 = [];
      for (var i=0; i < str.length; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 0x80) utf8.push(charcode);
        else if (charcode < 0x800) {
          utf8.push(0xc0 | (charcode >> 6),
              0x80 | (charcode & 0x3f));
        }
        else if (charcode < 0xd800 || charcode >= 0xe000) {
          utf8.push(0xe0 | (charcode >> 12),
              0x80 | ((charcode>>6) & 0x3f),
              0x80 | (charcode & 0x3f));
        }
        // surrogate pair
        else {
          i++;
          // UTF-16 encodes 0x10000-0x10FFFF by
          // subtracting 0x10000 and splitting the
          // 20 bits of 0x0-0xFFFFF into two halves
          charcode = 0x10000 + (((charcode & 0x3ff)<<10)
            | (str.charCodeAt(i) & 0x3ff));
          utf8.push(0xf0 | (charcode >>18),
              0x80 | ((charcode>>12) & 0x3f),
              0x80 | ((charcode>>6) & 0x3f),
              0x80 | (charcode & 0x3f));
        }
      }
      return utf8;
    }
    return toUTF8Array(s);
  };

}();

(function (factory) {
  if (typeof define === 'function' && define.amd) {
      define([], factory);
  } else if (typeof exports === 'object') {
      module.exports = factory();
  }
}(function () {
    return qrcode;
}));

      };
    };
  }
  }
}, {package:"qrcode-generator",file:"node_modules\\qrcode-generator\\qrcode.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qrcode.react\\lib\\index.js", {"prop-types":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\prop-types\\index.js","qr.js/lib/ErrorCorrectLevel":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qr.js\\lib\\ErrorCorrectLevel.js","qr.js/lib/QRCode":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\qr.js\\lib\\QRCode.js","react":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\react\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Cqrcode.react%5Clib%5Cindex.js
      return function (require, module, exports) {
'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var React = require('react');

var PropTypes = require('prop-types'); // qr.js doesn't handle error level of zero (M) so we need to do it right,
// thus the deep require.


var QRCodeImpl = require('qr.js/lib/QRCode');

var ErrorCorrectLevel = require('qr.js/lib/ErrorCorrectLevel'); // TODO: pull this off of the QRCode class type so it matches.


// Convert from UTF-16, forcing the use of byte-mode encoding in our QR Code.
// This allows us to encode Hanji, Kanji, emoji, etc. Ideally we'd do more
// detection and not resort to byte-mode if possible, but we're trading off
// a smaller library for a smaller amount of data we can potentially encode.
// Based on http://jonisalonen.com/2012/from-utf-16-to-utf-8-in-javascript/
function convertStr(str) {
  var out = '';

  for (var i = 0; i < str.length; i++) {
    var charcode = str.charCodeAt(i);

    if (charcode < 0x0080) {
      out += String.fromCharCode(charcode);
    } else if (charcode < 0x0800) {
      out += String.fromCharCode(0xc0 | charcode >> 6);
      out += String.fromCharCode(0x80 | charcode & 0x3f);
    } else if (charcode < 0xd800 || charcode >= 0xe000) {
      out += String.fromCharCode(0xe0 | charcode >> 12);
      out += String.fromCharCode(0x80 | charcode >> 6 & 0x3f);
      out += String.fromCharCode(0x80 | charcode & 0x3f);
    } else {
      // This is a surrogate pair, so we'll reconsitute the pieces and work
      // from that
      i++;
      charcode = 0x10000 + ((charcode & 0x3ff) << 10 | str.charCodeAt(i) & 0x3ff);
      out += String.fromCharCode(0xf0 | charcode >> 18);
      out += String.fromCharCode(0x80 | charcode >> 12 & 0x3f);
      out += String.fromCharCode(0x80 | charcode >> 6 & 0x3f);
      out += String.fromCharCode(0x80 | charcode & 0x3f);
    }
  }

  return out;
}

var DEFAULT_PROPS = {
  size: 128,
  level: 'L',
  bgColor: '#FFFFFF',
  fgColor: '#000000',
  includeMargin: false
};
var PROP_TYPES = "development" !== 'production' ? {
  value: PropTypes.string.isRequired,
  size: PropTypes.number,
  level: PropTypes.oneOf(['L', 'M', 'Q', 'H']),
  bgColor: PropTypes.string,
  fgColor: PropTypes.string,
  includeMargin: PropTypes.bool,
  imageSettings: PropTypes.shape({
    src: PropTypes.string.isRequired,
    height: PropTypes.number.isRequired,
    width: PropTypes.number.isRequired,
    excavate: PropTypes.bool,
    x: PropTypes.number,
    y: PropTypes.number
  })
} : {};
var MARGIN_SIZE = 4; // This is *very* rough estimate of max amount of QRCode allowed to be covered.
// It is "wrong" in a lot of ways (area is a terrible way to estimate, it
// really should be number of modules covered), but if for some reason we don't
// get an explicit height or width, I'd rather default to something than throw.

var DEFAULT_IMG_SCALE = 0.1;

function generatePath(modules) {
  var margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var ops = [];
  modules.forEach(function (row, y) {
    var start = null;
    row.forEach(function (cell, x) {
      if (!cell && start !== null) {
        // M0 0h7v1H0z injects the space with the move and drops the comma,
        // saving a char per operation
        ops.push("M".concat(start + margin, " ").concat(y + margin, "h").concat(x - start, "v1H").concat(start + margin, "z"));
        start = null;
        return;
      } // end of row, clean up or skip


      if (x === row.length - 1) {
        if (!cell) {
          // We would have closed the op above already so this can only mean
          // 2+ light modules in a row.
          return;
        }

        if (start === null) {
          // Just a single dark module.
          ops.push("M".concat(x + margin, ",").concat(y + margin, " h1v1H").concat(x + margin, "z"));
        } else {
          // Otherwise finish the current line.
          ops.push("M".concat(start + margin, ",").concat(y + margin, " h").concat(x + 1 - start, "v1H").concat(start + margin, "z"));
        }

        return;
      }

      if (cell && start === null) {
        start = x;
      }
    });
  });
  return ops.join('');
} // We could just do this in generatePath, except that we want to support
// non-Path2D canvas, so we need to keep it an explicit step.


function excavateModules(modules, excavation) {
  return modules.slice().map(function (row, y) {
    if (y < excavation.y || y >= excavation.y + excavation.h) {
      return row;
    }

    return row.map(function (cell, x) {
      if (x < excavation.x || x >= excavation.x + excavation.w) {
        return cell;
      }

      return false;
    });
  });
}

function getImageSettings(props, cells) {
  var imageSettings = props.imageSettings,
      size = props.size,
      includeMargin = props.includeMargin;

  if (imageSettings == null) {
    return null;
  }

  var margin = includeMargin ? MARGIN_SIZE : 0;
  var numCells = cells.length + margin * 2;
  var defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);
  var scale = numCells / size;
  var w = (imageSettings.width || defaultSize) * scale;
  var h = (imageSettings.height || defaultSize) * scale;
  var x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;
  var y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;
  var excavation = null;

  if (imageSettings.excavate) {
    var floorX = Math.floor(x);
    var floorY = Math.floor(y);
    var ceilW = Math.ceil(w + x - floorX);
    var ceilH = Math.ceil(h + y - floorY);
    excavation = {
      x: floorX,
      y: floorY,
      w: ceilW,
      h: ceilH
    };
  }

  return {
    x: x,
    y: y,
    h: h,
    w: w,
    excavation: excavation
  };
} // For canvas we're going to switch our drawing mode based on whether or not
// the environment supports Path2D. We only need the constructor to be
// supported, but Edge doesn't actually support the path (string) type
// argument. Luckily it also doesn't support the addPath() method. We can
// treat that as the same thing.


var SUPPORTS_PATH2D = function () {
  try {
    new Path2D().addPath(new Path2D());
  } catch (e) {
    return false;
  }

  return true;
}();

var QRCodeCanvas =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(QRCodeCanvas, _React$PureComponent);

  function QRCodeCanvas() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, QRCodeCanvas);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(QRCodeCanvas)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "_canvas", void 0);

    _defineProperty(_assertThisInitialized(_this), "_image", void 0);

    _defineProperty(_assertThisInitialized(_this), "state", {
      imgLoaded: false
    });

    _defineProperty(_assertThisInitialized(_this), "handleImageLoad", function () {
      _this.setState({
        imgLoaded: true
      });
    });

    return _this;
  }

  _createClass(QRCodeCanvas, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this._image && this._image.complete) {
        this.handleImageLoad();
      }

      this.update();
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var _this$props$imageSett, _nextProps$imageSetti;

      var currentSrc = (_this$props$imageSett = this.props.imageSettings) === null || _this$props$imageSett === void 0 ? void 0 : _this$props$imageSett.src;
      var nextSrc = (_nextProps$imageSetti = nextProps.imageSettings) === null || _nextProps$imageSetti === void 0 ? void 0 : _nextProps$imageSetti.src;

      if (currentSrc !== nextSrc) {
        this.setState({
          imgLoaded: false
        });
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.update();
    }
  }, {
    key: "update",
    value: function update() {
      var _this$props = this.props,
          value = _this$props.value,
          size = _this$props.size,
          level = _this$props.level,
          bgColor = _this$props.bgColor,
          fgColor = _this$props.fgColor,
          includeMargin = _this$props.includeMargin,
          imageSettings = _this$props.imageSettings; // We'll use type===-1 to force QRCode to automatically pick the best type

      var qrcode = new QRCodeImpl(-1, ErrorCorrectLevel[level]);
      qrcode.addData(convertStr(value));
      qrcode.make();

      if (this._canvas != null) {
        var canvas = this._canvas;
        var ctx = canvas.getContext('2d');

        if (!ctx) {
          return;
        }

        var cells = qrcode.modules;

        if (cells === null) {
          return;
        }

        var margin = includeMargin ? MARGIN_SIZE : 0;
        var numCells = cells.length + margin * 2;
        var calculatedImageSettings = getImageSettings(this.props, cells);

        if (imageSettings != null && calculatedImageSettings != null) {
          if (calculatedImageSettings.excavation != null) {
            cells = excavateModules(cells, calculatedImageSettings.excavation);
          }
        } // We're going to scale this so that the number of drawable units
        // matches the number of cells. This avoids rounding issues, but does
        // result in some potentially unwanted single pixel issues between
        // blocks, only in environments that don't support Path2D.


        var pixelRatio = window.devicePixelRatio || 1;
        canvas.height = canvas.width = size * pixelRatio;
        var scale = size / numCells * pixelRatio;
        ctx.scale(scale, scale); // Draw solid background, only paint dark modules.

        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, numCells, numCells);
        ctx.fillStyle = fgColor;

        if (SUPPORTS_PATH2D) {
          // $FlowFixMe: Path2D c'tor doesn't support args yet.
          ctx.fill(new Path2D(generatePath(cells, margin)));
        } else {
          cells.forEach(function (row, rdx) {
            row.forEach(function (cell, cdx) {
              if (cell) {
                ctx.fillRect(cdx + margin, rdx + margin, 1, 1);
              }
            });
          });
        }

        if (this.state.imgLoaded && this._image && calculatedImageSettings != null) {
          ctx.drawImage(this._image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props2 = this.props,
          value = _this$props2.value,
          size = _this$props2.size,
          level = _this$props2.level,
          bgColor = _this$props2.bgColor,
          fgColor = _this$props2.fgColor,
          style = _this$props2.style,
          includeMargin = _this$props2.includeMargin,
          imageSettings = _this$props2.imageSettings,
          otherProps = _objectWithoutProperties(_this$props2, ["value", "size", "level", "bgColor", "fgColor", "style", "includeMargin", "imageSettings"]);

      var canvasStyle = _objectSpread({
        height: size,
        width: size
      }, style);

      var img = null;
      var imgSrc = imageSettings && imageSettings.src;

      if (imageSettings != null && imgSrc != null) {
        img = React.createElement("img", {
          src: imgSrc,
          style: {
            display: 'none'
          },
          onLoad: this.handleImageLoad,
          ref: function ref(_ref) {
            return _this2._image = _ref;
          }
        });
      }

      return React.createElement(React.Fragment, null, React.createElement("canvas", _extends({
        style: canvasStyle,
        height: size,
        width: size,
        ref: function ref(_ref2) {
          return _this2._canvas = _ref2;
        }
      }, otherProps)), img);
    }
  }]);

  return QRCodeCanvas;
}(React.PureComponent);

_defineProperty(QRCodeCanvas, "defaultProps", DEFAULT_PROPS);

if ("development" !== 'production') {
  QRCodeCanvas.propTypes = PROP_TYPES;
}

var QRCodeSVG =
/*#__PURE__*/
function (_React$PureComponent2) {
  _inherits(QRCodeSVG, _React$PureComponent2);

  function QRCodeSVG() {
    _classCallCheck(this, QRCodeSVG);

    return _possibleConstructorReturn(this, _getPrototypeOf(QRCodeSVG).apply(this, arguments));
  }

  _createClass(QRCodeSVG, [{
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          value = _this$props3.value,
          size = _this$props3.size,
          level = _this$props3.level,
          bgColor = _this$props3.bgColor,
          fgColor = _this$props3.fgColor,
          includeMargin = _this$props3.includeMargin,
          imageSettings = _this$props3.imageSettings,
          otherProps = _objectWithoutProperties(_this$props3, ["value", "size", "level", "bgColor", "fgColor", "includeMargin", "imageSettings"]); // We'll use type===-1 to force QRCode to automatically pick the best type


      var qrcode = new QRCodeImpl(-1, ErrorCorrectLevel[level]);
      qrcode.addData(convertStr(value));
      qrcode.make();
      var cells = qrcode.modules;

      if (cells === null) {
        return null;
      }

      var margin = includeMargin ? MARGIN_SIZE : 0;
      var numCells = cells.length + margin * 2;
      var calculatedImageSettings = getImageSettings(this.props, cells);
      var image = null;

      if (imageSettings != null && calculatedImageSettings != null) {
        if (calculatedImageSettings.excavation != null) {
          cells = excavateModules(cells, calculatedImageSettings.excavation);
        }

        image = React.createElement("image", {
          xlinkHref: imageSettings.src,
          height: calculatedImageSettings.h,
          width: calculatedImageSettings.w,
          x: calculatedImageSettings.x + margin,
          y: calculatedImageSettings.y + margin,
          preserveAspectRatio: "none"
        });
      } // Drawing strategy: instead of a rect per module, we're going to create a
      // single path for the dark modules and layer that on top of a light rect,
      // for a total of 2 DOM nodes. We pay a bit more in string concat but that's
      // way faster than DOM ops.
      // For level 1, 441 nodes -> 2
      // For level 40, 31329 -> 2


      var fgPath = generatePath(cells, margin);
      return React.createElement("svg", _extends({
        shapeRendering: "crispEdges",
        height: size,
        width: size,
        viewBox: "0 0 ".concat(numCells, " ").concat(numCells)
      }, otherProps), React.createElement("path", {
        fill: bgColor,
        d: "M0,0 h".concat(numCells, "v").concat(numCells, "H0z")
      }), React.createElement("path", {
        fill: fgColor,
        d: fgPath
      }), image);
    }
  }]);

  return QRCodeSVG;
}(React.PureComponent);

_defineProperty(QRCodeSVG, "defaultProps", DEFAULT_PROPS);

if ("development" !== 'production') {
  QRCodeSVG.propTypes = PROP_TYPES;
}

var QRCode = function QRCode(props) {
  var renderAs = props.renderAs,
      otherProps = _objectWithoutProperties(props, ["renderAs"]);

  var Component = renderAs === 'svg' ? QRCodeSVG : QRCodeCanvas;
  return React.createElement(Component, otherProps);
};

QRCode.defaultProps = _objectSpread({
  renderAs: 'canvas'
}, DEFAULT_PROPS);
module.exports = QRCode;
      };
    };
  }
  }
}, {package:"qrcode.react",file:"node_modules\\qrcode.react\\lib\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\react-clientside-effect\\lib\\index.js", {"@babel/runtime/helpers/defineProperty":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/inheritsLoose":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\@babel\\runtime\\helpers\\inheritsLoose.js","react":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\react\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Creact-clientside-effect%5Clib%5Cindex.js
      return function (require, module, exports) {
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _inheritsLoose = _interopDefault(require('@babel/runtime/helpers/inheritsLoose'));
var _defineProperty = _interopDefault(require('@babel/runtime/helpers/defineProperty'));
var React = require('react');
var React__default = _interopDefault(React);

function withSideEffect(reducePropsToState, handleStateChangeOnClient) {
  if ("development" !== "production") {
    if (typeof reducePropsToState !== 'function') {
      throw new Error('Expected reducePropsToState to be a function.');
    }

    if (typeof handleStateChangeOnClient !== 'function') {
      throw new Error('Expected handleStateChangeOnClient to be a function.');
    }
  }

  function getDisplayName(WrappedComponent) {
    return WrappedComponent.displayName || WrappedComponent.name || 'Component';
  }

  return function wrap(WrappedComponent) {
    if ("development" !== "production") {
      if (typeof WrappedComponent !== 'function') {
        throw new Error('Expected WrappedComponent to be a React component.');
      }
    }

    var mountedInstances = [];
    var state;

    function emitChange() {
      state = reducePropsToState(mountedInstances.map(function (instance) {
        return instance.props;
      }));
      handleStateChangeOnClient(state);
    }

    var SideEffect = /*#__PURE__*/function (_PureComponent) {
      _inheritsLoose(SideEffect, _PureComponent);

      function SideEffect() {
        return _PureComponent.apply(this, arguments) || this;
      }

      // Try to use displayName of wrapped component
      SideEffect.peek = function peek() {
        return state;
      };

      var _proto = SideEffect.prototype;

      _proto.componentDidMount = function componentDidMount() {
        mountedInstances.push(this);
        emitChange();
      };

      _proto.componentDidUpdate = function componentDidUpdate() {
        emitChange();
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        var index = mountedInstances.indexOf(this);
        mountedInstances.splice(index, 1);
        emitChange();
      };

      _proto.render = function render() {
        return /*#__PURE__*/React__default.createElement(WrappedComponent, this.props);
      };

      return SideEffect;
    }(React.PureComponent);

    _defineProperty(SideEffect, "displayName", "SideEffect(" + getDisplayName(WrappedComponent) + ")");

    return SideEffect;
  };
}

module.exports = withSideEffect;

      };
    };
  }
  }
}, {package:"react-focus-lock>react-clientside-effect",file:"node_modules\\react-clientside-effect\\lib\\index.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\react-devtools-core\\backend.js", {"./dist/backend":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\react-devtools-core\\dist\\backend.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Creact-devtools-core%5Cbackend.js
      return function (require, module, exports) {
module.exports = require('./dist/backend');

      };
    };
  }
  }
}, {package:"react-devtools>react-devtools-core",file:"node_modules\\react-devtools-core\\backend.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\react-devtools-core\\dist\\backend.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Creact-devtools-core%5Cdist%5Cbackend.js
      return function (require, module, exports) {
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ReactDevToolsBackend"] = factory();
	else
		root["ReactDevToolsBackend"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 28);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* unused harmony export alphaSortKeys */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return getAllEnumerableKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return getWrappedDisplayName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return getDisplayName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return getUID; });
/* unused harmony export utfDecodeString */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return utfEncodeString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return printOperationsArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return getDefaultComponentFilters; });
/* unused harmony export getSavedComponentFilters */
/* unused harmony export setSavedComponentFilters */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return castBool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return castBrowserTheme; });
/* unused harmony export getAppendComponentStack */
/* unused harmony export getBreakOnConsoleErrors */
/* unused harmony export getHideConsoleLogsInStrictMode */
/* unused harmony export getShowInlineWarningsAndErrors */
/* unused harmony export getDefaultOpenInEditorURL */
/* unused harmony export getOpenInEditorURL */
/* unused harmony export separateDisplayNameAndHOCs */
/* unused harmony export shallowDiffers */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return getInObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return deletePathInObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return renamePathInObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return setInObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return getDataType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return getDisplayNameForReactElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return formatDataForPreview; });
/* unused harmony export isPlainObject */
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_is__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1);
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5);
/* harmony import */ var _hydration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);
/* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */









// $FlowFixMe[method-unbinding]
var hasOwnProperty = Object.prototype.hasOwnProperty;
var cachedDisplayNames = new WeakMap(); // On large trees, encoding takes significant time.
// Try to reuse the already encoded strings.

var encodedStringCache = new lru_cache__WEBPACK_IMPORTED_MODULE_0___default.a({
  max: 1000
});
function alphaSortKeys(a, b) {
  if (a.toString() > b.toString()) {
    return 1;
  } else if (b.toString() > a.toString()) {
    return -1;
  } else {
    return 0;
  }
}
function getAllEnumerableKeys(obj) {
  var keys = new Set();
  var current = obj;

  var _loop = function _loop() {
    var currentKeys = [].concat(_toConsumableArray(Object.keys(current)), _toConsumableArray(Object.getOwnPropertySymbols(current)));
    var descriptors = Object.getOwnPropertyDescriptors(current);
    currentKeys.forEach(function (key) {
      // $FlowFixMe[incompatible-type]: key can be a Symbol https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor
      if (descriptors[key].enumerable) {
        keys.add(key);
      }
    });
    current = Object.getPrototypeOf(current);
  };

  while (current != null) {
    _loop();
  }

  return keys;
} // Mirror https://github.com/facebook/react/blob/7c21bf72ace77094fd1910cc350a548287ef8350/packages/shared/getComponentName.js#L27-L37

function getWrappedDisplayName(outerType, innerType, wrapperName, fallbackName) {
  var displayName = outerType.displayName;
  return displayName || "".concat(wrapperName, "(").concat(getDisplayName(innerType, fallbackName), ")");
}
function getDisplayName(type) {
  var fallbackName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Anonymous';
  var nameFromCache = cachedDisplayNames.get(type);

  if (nameFromCache != null) {
    return nameFromCache;
  }

  var displayName = fallbackName; // The displayName property is not guaranteed to be a string.
  // It's only safe to use for our purposes if it's a string.
  // github.com/facebook/react-devtools/issues/803

  if (typeof type.displayName === 'string') {
    displayName = type.displayName;
  } else if (typeof type.name === 'string' && type.name !== '') {
    displayName = type.name;
  }

  cachedDisplayNames.set(type, displayName);
  return displayName;
}
var uidCounter = 0;
function getUID() {
  return ++uidCounter;
}
function utfDecodeString(array) {
  // Avoid spreading the array (e.g. String.fromCodePoint(...array))
  // Functions arguments are first placed on the stack before the function is called
  // which throws a RangeError for large arrays.
  // See github.com/facebook/react/issues/22293
  var string = '';

  for (var i = 0; i < array.length; i++) {
    var char = array[i];
    string += String.fromCodePoint(char);
  }

  return string;
}

function surrogatePairToCodePoint(charCode1, charCode2) {
  return ((charCode1 & 0x3ff) << 10) + (charCode2 & 0x3ff) + 0x10000;
} // Credit for this encoding approach goes to Tim Down:
// https://stackoverflow.com/questions/4877326/how-can-i-tell-if-a-string-contains-multibyte-characters-in-javascript


function utfEncodeString(string) {
  var cached = encodedStringCache.get(string);

  if (cached !== undefined) {
    return cached;
  }

  var encoded = [];
  var i = 0;
  var charCode;

  while (i < string.length) {
    charCode = string.charCodeAt(i); // Handle multibyte unicode characters (like emoji).

    if ((charCode & 0xf800) === 0xd800) {
      encoded.push(surrogatePairToCodePoint(charCode, string.charCodeAt(++i)));
    } else {
      encoded.push(charCode);
    }

    ++i;
  }

  encodedStringCache.set(string, encoded);
  return encoded;
}
function printOperationsArray(operations) {
  // The first two values are always rendererID and rootID
  var rendererID = operations[0];
  var rootID = operations[1];
  var logs = ["operations for renderer:".concat(rendererID, " and root:").concat(rootID)];
  var i = 2; // Reassemble the string table.

  var stringTable = [null // ID = 0 corresponds to the null string.
  ];
  var stringTableSize = operations[i++];
  var stringTableEnd = i + stringTableSize;

  while (i < stringTableEnd) {
    var nextLength = operations[i++];
    var nextString = utfDecodeString(operations.slice(i, i + nextLength));
    stringTable.push(nextString);
    i += nextLength;
  }

  while (i < operations.length) {
    var operation = operations[i];

    switch (operation) {
      case _constants__WEBPACK_IMPORTED_MODULE_3__[/* TREE_OPERATION_ADD */ "l"]:
        {
          var _id = operations[i + 1];
          var type = operations[i + 2];
          i += 3;

          if (type === _types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeRoot */ "m"]) {
            logs.push("Add new root node ".concat(_id));
            i++; // isStrictModeCompliant

            i++; // supportsProfiling

            i++; // supportsStrictMode

            i++; // hasOwnerMetadata
          } else {
            var parentID = operations[i];
            i++;
            i++; // ownerID

            var displayNameStringID = operations[i];
            var displayName = stringTable[displayNameStringID];
            i++;
            i++; // key

            logs.push("Add node ".concat(_id, " (").concat(displayName || 'null', ") as child of ").concat(parentID));
          }

          break;
        }

      case _constants__WEBPACK_IMPORTED_MODULE_3__[/* TREE_OPERATION_REMOVE */ "m"]:
        {
          var removeLength = operations[i + 1];
          i += 2;

          for (var removeIndex = 0; removeIndex < removeLength; removeIndex++) {
            var _id2 = operations[i];
            i += 1;
            logs.push("Remove node ".concat(_id2));
          }

          break;
        }

      case _constants__WEBPACK_IMPORTED_MODULE_3__[/* TREE_OPERATION_REMOVE_ROOT */ "n"]:
        {
          i += 1;
          logs.push("Remove root ".concat(rootID));
          break;
        }

      case _constants__WEBPACK_IMPORTED_MODULE_3__[/* TREE_OPERATION_SET_SUBTREE_MODE */ "p"]:
        {
          var _id3 = operations[i + 1];
          var mode = operations[i + 1];
          i += 3;
          logs.push("Mode ".concat(mode, " set for subtree with root ").concat(_id3));
          break;
        }

      case _constants__WEBPACK_IMPORTED_MODULE_3__[/* TREE_OPERATION_REORDER_CHILDREN */ "o"]:
        {
          var _id4 = operations[i + 1];
          var numChildren = operations[i + 2];
          i += 3;
          var children = operations.slice(i, i + numChildren);
          i += numChildren;
          logs.push("Re-order node ".concat(_id4, " children ").concat(children.join(',')));
          break;
        }

      case _constants__WEBPACK_IMPORTED_MODULE_3__[/* TREE_OPERATION_UPDATE_TREE_BASE_DURATION */ "r"]:
        // Base duration updates are only sent while profiling is in progress.
        // We can ignore them at this point.
        // The profiler UI uses them lazily in order to generate the tree.
        i += 3;
        break;

      case _constants__WEBPACK_IMPORTED_MODULE_3__[/* TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS */ "q"]:
        var id = operations[i + 1];
        var numErrors = operations[i + 2];
        var numWarnings = operations[i + 3];
        i += 4;
        logs.push("Node ".concat(id, " has ").concat(numErrors, " errors and ").concat(numWarnings, " warnings"));
        break;

      default:
        throw Error("Unsupported Bridge operation \"".concat(operation, "\""));
    }
  }

  console.log(logs.join('\n  '));
}
function getDefaultComponentFilters() {
  return [{
    type: _types__WEBPACK_IMPORTED_MODULE_4__[/* ComponentFilterElementType */ "b"],
    value: _types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeHostComponent */ "i"],
    isEnabled: true
  }];
}
function getSavedComponentFilters() {
  try {
    var raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageGetItem */ "a"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY */ "a"]);

    if (raw != null) {
      return JSON.parse(raw);
    }
  } catch (error) {}

  return getDefaultComponentFilters();
}
function setSavedComponentFilters(componentFilters) {
  Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageSetItem */ "b"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY */ "a"], JSON.stringify(componentFilters));
}

function parseBool(s) {
  if (s === 'true') {
    return true;
  }

  if (s === 'false') {
    return false;
  }
}

function castBool(v) {
  if (v === true || v === false) {
    return v;
  }
}
function castBrowserTheme(v) {
  if (v === 'light' || v === 'dark' || v === 'auto') {
    return v;
  }
}
function getAppendComponentStack() {
  var _parseBool;

  var raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageGetItem */ "a"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_SHOULD_APPEND_COMPONENT_STACK_KEY */ "d"]);
  return (_parseBool = parseBool(raw)) !== null && _parseBool !== void 0 ? _parseBool : true;
}
function getBreakOnConsoleErrors() {
  var _parseBool2;

  var raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageGetItem */ "a"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS */ "e"]);
  return (_parseBool2 = parseBool(raw)) !== null && _parseBool2 !== void 0 ? _parseBool2 : false;
}
function getHideConsoleLogsInStrictMode() {
  var _parseBool3;

  var raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageGetItem */ "a"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_HIDE_CONSOLE_LOGS_IN_STRICT_MODE */ "b"]);
  return (_parseBool3 = parseBool(raw)) !== null && _parseBool3 !== void 0 ? _parseBool3 : false;
}
function getShowInlineWarningsAndErrors() {
  var _parseBool4;

  var raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageGetItem */ "a"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY */ "f"]);
  return (_parseBool4 = parseBool(raw)) !== null && _parseBool4 !== void 0 ? _parseBool4 : true;
}
function getDefaultOpenInEditorURL() {
  return typeof "" === 'string' ? "" : '';
}
function getOpenInEditorURL() {
  try {
    var raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageGetItem */ "a"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_OPEN_IN_EDITOR_URL */ "c"]);

    if (raw != null) {
      return JSON.parse(raw);
    }
  } catch (error) {}

  return getDefaultOpenInEditorURL();
}
function separateDisplayNameAndHOCs(displayName, type) {
  if (displayName === null) {
    return [null, null];
  }

  var hocDisplayNames = null;

  switch (type) {
    case _types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeClass */ "e"]:
    case _types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeForwardRef */ "g"]:
    case _types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeFunction */ "h"]:
    case _types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeMemo */ "j"]:
      if (displayName.indexOf('(') >= 0) {
        var matches = displayName.match(/[^()]+/g);

        if (matches != null) {
          displayName = matches.pop();
          hocDisplayNames = matches;
        }
      }

      break;

    default:
      break;
  }

  return [displayName, hocDisplayNames];
} // Pulled from react-compat
// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349

function shallowDiffers(prev, next) {
  for (var attribute in prev) {
    if (!(attribute in next)) {
      return true;
    }
  }

  for (var _attribute in next) {
    if (prev[_attribute] !== next[_attribute]) {
      return true;
    }
  }

  return false;
}
function getInObject(object, path) {
  return path.reduce(function (reduced, attr) {
    if (reduced) {
      if (hasOwnProperty.call(reduced, attr)) {
        return reduced[attr];
      }

      if (typeof reduced[Symbol.iterator] === 'function') {
        // Convert iterable to array and return array[index]
        //
        // TRICKY
        // Don't use [...spread] syntax for this purpose.
        // This project uses @babel/plugin-transform-spread in "loose" mode which only works with Array values.
        // Other types (e.g. typed arrays, Sets) will not spread correctly.
        return Array.from(reduced)[attr];
      }
    }

    return null;
  }, object);
}
function deletePathInObject(object, path) {
  var length = path.length;
  var last = path[length - 1];

  if (object != null) {
    var parent = getInObject(object, path.slice(0, length - 1));

    if (parent) {
      if (Object(_isArray__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(parent)) {
        parent.splice(last, 1);
      } else {
        delete parent[last];
      }
    }
  }
}
function renamePathInObject(object, oldPath, newPath) {
  var length = oldPath.length;

  if (object != null) {
    var parent = getInObject(object, oldPath.slice(0, length - 1));

    if (parent) {
      var lastOld = oldPath[length - 1];
      var lastNew = newPath[length - 1];
      parent[lastNew] = parent[lastOld];

      if (Object(_isArray__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(parent)) {
        parent.splice(lastOld, 1);
      } else {
        delete parent[lastOld];
      }
    }
  }
}
function setInObject(object, path, value) {
  var length = path.length;
  var last = path[length - 1];

  if (object != null) {
    var parent = getInObject(object, path.slice(0, length - 1));

    if (parent) {
      parent[last] = value;
    }
  }
}

/**
 * Get a enhanced/artificial type string based on the object instance
 */
function getDataType(data) {
  if (data === null) {
    return 'null';
  } else if (data === undefined) {
    return 'undefined';
  }

  if (Object(react_is__WEBPACK_IMPORTED_MODULE_1__["isElement"])(data)) {
    return 'react_element';
  }

  if (typeof HTMLElement !== 'undefined' && data instanceof HTMLElement) {
    return 'html_element';
  }

  var type = _typeof(data);

  switch (type) {
    case 'bigint':
      return 'bigint';

    case 'boolean':
      return 'boolean';

    case 'function':
      return 'function';

    case 'number':
      if (Number.isNaN(data)) {
        return 'nan';
      } else if (!Number.isFinite(data)) {
        return 'infinity';
      } else {
        return 'number';
      }

    case 'object':
      if (Object(_isArray__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(data)) {
        return 'array';
      } else if (ArrayBuffer.isView(data)) {
        return hasOwnProperty.call(data.constructor, 'BYTES_PER_ELEMENT') ? 'typed_array' : 'data_view';
      } else if (data.constructor && data.constructor.name === 'ArrayBuffer') {
        // HACK This ArrayBuffer check is gross; is there a better way?
        // We could try to create a new DataView with the value.
        // If it doesn't error, we know it's an ArrayBuffer,
        // but this seems kind of awkward and expensive.
        return 'array_buffer';
      } else if (typeof data[Symbol.iterator] === 'function') {
        var iterator = data[Symbol.iterator]();

        if (!iterator) {// Proxies might break assumptoins about iterators.
          // See github.com/facebook/react/issues/21654
        } else {
          return iterator === data ? 'opaque_iterator' : 'iterator';
        }
      } else if (data.constructor && data.constructor.name === 'RegExp') {
        return 'regexp';
      } else {
        // $FlowFixMe[method-unbinding]
        var toStringValue = Object.prototype.toString.call(data);

        if (toStringValue === '[object Date]') {
          return 'date';
        } else if (toStringValue === '[object HTMLAllCollection]') {
          return 'html_all_collection';
        }
      }

      if (!isPlainObject(data)) {
        return 'class_instance';
      }

      return 'object';

    case 'string':
      return 'string';

    case 'symbol':
      return 'symbol';

    case 'undefined':
      if ( // $FlowFixMe[method-unbinding]
      Object.prototype.toString.call(data) === '[object HTMLAllCollection]') {
        return 'html_all_collection';
      }

      return 'undefined';

    default:
      return 'unknown';
  }
}
function getDisplayNameForReactElement(element) {
  var elementType = Object(react_is__WEBPACK_IMPORTED_MODULE_1__["typeOf"])(element);

  switch (elementType) {
    case react_is__WEBPACK_IMPORTED_MODULE_1__["ContextConsumer"]:
      return 'ContextConsumer';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["ContextProvider"]:
      return 'ContextProvider';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["ForwardRef"]:
      return 'ForwardRef';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Fragment"]:
      return 'Fragment';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Lazy"]:
      return 'Lazy';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Memo"]:
      return 'Memo';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Portal"]:
      return 'Portal';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Profiler"]:
      return 'Profiler';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["StrictMode"]:
      return 'StrictMode';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Suspense"]:
      return 'Suspense';

    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_2__[/* REACT_SUSPENSE_LIST_TYPE */ "a"]:
      return 'SuspenseList';

    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_2__[/* REACT_TRACING_MARKER_TYPE */ "b"]:
      return 'TracingMarker';

    default:
      var type = element.type;

      if (typeof type === 'string') {
        return type;
      } else if (typeof type === 'function') {
        return getDisplayName(type, 'Anonymous');
      } else if (type != null) {
        return 'NotImplementedInDevtools';
      } else {
        return 'Element';
      }

  }
}
var MAX_PREVIEW_STRING_LENGTH = 50;

function truncateForDisplay(string) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MAX_PREVIEW_STRING_LENGTH;

  if (string.length > length) {
    return string.slice(0, length) + '…';
  } else {
    return string;
  }
} // Attempts to mimic Chrome's inline preview for values.
// For example, the following value...
//   {
//      foo: 123,
//      bar: "abc",
//      baz: [true, false],
//      qux: { ab: 1, cd: 2 }
//   };
//
// Would show a preview of...
//   {foo: 123, bar: "abc", baz: Array(2), qux: {…}}
//
// And the following value...
//   [
//     123,
//     "abc",
//     [true, false],
//     { foo: 123, bar: "abc" }
//   ];
//
// Would show a preview of...
//   [123, "abc", Array(2), {…}]


function formatDataForPreview(data, showFormattedValue) {
  if (data != null && hasOwnProperty.call(data, _hydration__WEBPACK_IMPORTED_MODULE_6__[/* meta */ "b"].type)) {
    return showFormattedValue ? data[_hydration__WEBPACK_IMPORTED_MODULE_6__[/* meta */ "b"].preview_long] : data[_hydration__WEBPACK_IMPORTED_MODULE_6__[/* meta */ "b"].preview_short];
  }

  var type = getDataType(data);

  switch (type) {
    case 'html_element':
      return "<".concat(truncateForDisplay(data.tagName.toLowerCase()), " />");

    case 'function':
      return truncateForDisplay("\u0192 ".concat(typeof data.name === 'function' ? '' : data.name, "() {}"));

    case 'string':
      return "\"".concat(data, "\"");

    case 'bigint':
      return truncateForDisplay(data.toString() + 'n');

    case 'regexp':
      return truncateForDisplay(data.toString());

    case 'symbol':
      return truncateForDisplay(data.toString());

    case 'react_element':
      return "<".concat(truncateForDisplay(getDisplayNameForReactElement(data) || 'Unknown'), " />");

    case 'array_buffer':
      return "ArrayBuffer(".concat(data.byteLength, ")");

    case 'data_view':
      return "DataView(".concat(data.buffer.byteLength, ")");

    case 'array':
      if (showFormattedValue) {
        var formatted = '';

        for (var i = 0; i < data.length; i++) {
          if (i > 0) {
            formatted += ', ';
          }

          formatted += formatDataForPreview(data[i], false);

          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {
            // Prevent doing a lot of unnecessary iteration...
            break;
          }
        }

        return "[".concat(truncateForDisplay(formatted), "]");
      } else {
        var length = hasOwnProperty.call(data, _hydration__WEBPACK_IMPORTED_MODULE_6__[/* meta */ "b"].size) ? data[_hydration__WEBPACK_IMPORTED_MODULE_6__[/* meta */ "b"].size] : data.length;
        return "Array(".concat(length, ")");
      }

    case 'typed_array':
      var shortName = "".concat(data.constructor.name, "(").concat(data.length, ")");

      if (showFormattedValue) {
        var _formatted = '';

        for (var _i = 0; _i < data.length; _i++) {
          if (_i > 0) {
            _formatted += ', ';
          }

          _formatted += data[_i];

          if (_formatted.length > MAX_PREVIEW_STRING_LENGTH) {
            // Prevent doing a lot of unnecessary iteration...
            break;
          }
        }

        return "".concat(shortName, " [").concat(truncateForDisplay(_formatted), "]");
      } else {
        return shortName;
      }

    case 'iterator':
      var name = data.constructor.name;

      if (showFormattedValue) {
        // TRICKY
        // Don't use [...spread] syntax for this purpose.
        // This project uses @babel/plugin-transform-spread in "loose" mode which only works with Array values.
        // Other types (e.g. typed arrays, Sets) will not spread correctly.
        var array = Array.from(data);
        var _formatted2 = '';

        for (var _i2 = 0; _i2 < array.length; _i2++) {
          var entryOrEntries = array[_i2];

          if (_i2 > 0) {
            _formatted2 += ', ';
          } // TRICKY
          // Browsers display Maps and Sets differently.
          // To mimic their behavior, detect if we've been given an entries tuple.
          //   Map(2) {"abc" => 123, "def" => 123}
          //   Set(2) {"abc", 123}


          if (Object(_isArray__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(entryOrEntries)) {
            var key = formatDataForPreview(entryOrEntries[0], true);
            var value = formatDataForPreview(entryOrEntries[1], false);
            _formatted2 += "".concat(key, " => ").concat(value);
          } else {
            _formatted2 += formatDataForPreview(entryOrEntries, false);
          }

          if (_formatted2.length > MAX_PREVIEW_STRING_LENGTH) {
            // Prevent doing a lot of unnecessary iteration...
            break;
          }
        }

        return "".concat(name, "(").concat(data.size, ") {").concat(truncateForDisplay(_formatted2), "}");
      } else {
        return "".concat(name, "(").concat(data.size, ")");
      }

    case 'opaque_iterator':
      {
        return data[Symbol.toStringTag];
      }

    case 'date':
      return data.toString();

    case 'class_instance':
      return data.constructor.name;

    case 'object':
      if (showFormattedValue) {
        var keys = Array.from(getAllEnumerableKeys(data)).sort(alphaSortKeys);
        var _formatted3 = '';

        for (var _i3 = 0; _i3 < keys.length; _i3++) {
          var _key = keys[_i3];

          if (_i3 > 0) {
            _formatted3 += ', ';
          }

          _formatted3 += "".concat(_key.toString(), ": ").concat(formatDataForPreview(data[_key], false));

          if (_formatted3.length > MAX_PREVIEW_STRING_LENGTH) {
            // Prevent doing a lot of unnecessary iteration...
            break;
          }
        }

        return "{".concat(truncateForDisplay(_formatted3), "}");
      } else {
        return '{…}';
      }

    case 'boolean':
    case 'number':
    case 'infinity':
    case 'nan':
    case 'null':
    case 'undefined':
      return data;

    default:
      try {
        return truncateForDisplay(String(data));
      } catch (error) {
        return 'unserializable';
      }

  }
} // Basically checking that the object only has Object in its prototype chain

var isPlainObject = function isPlainObject(object) {
  var objectPrototype = Object.getPrototypeOf(object);
  if (!objectPrototype) return true;
  var objectParentPrototype = Object.getPrototypeOf(objectPrototype);
  return !objectParentPrototype;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(19)))

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return ElementTypeClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return ElementTypeContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return ElementTypeFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return ElementTypeForwardRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return ElementTypeHostComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return ElementTypeMemo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return ElementTypeOtherOrUnknown; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return ElementTypeProfiler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return ElementTypeRoot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return ElementTypeSuspense; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return ElementTypeSuspenseList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return ElementTypeTracingMarker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ComponentFilterElementType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ComponentFilterDisplayName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return ComponentFilterLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return ComponentFilterHOC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return StrictMode; });
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * WARNING:
 * This file contains types that are designed for React DevTools UI and how it interacts with the backend.
 * They might be used in different versions of DevTools backends.
 * Be mindful of backwards compatibility when making changes.
 */
// WARNING
// The values below are referenced by ComponentFilters (which are saved via localStorage).
// Do not change them or it will break previously saved user customizations.
// If new element types are added, use new numbers rather than re-ordering existing ones.
//
// Changing these types is also a backwards breaking change for the standalone shell,
// since the frontend and backend must share the same values-
// and the backend is embedded in certain environments (like React Native).
var ElementTypeClass = 1;
var ElementTypeContext = 2;
var ElementTypeFunction = 5;
var ElementTypeForwardRef = 6;
var ElementTypeHostComponent = 7;
var ElementTypeMemo = 8;
var ElementTypeOtherOrUnknown = 9;
var ElementTypeProfiler = 10;
var ElementTypeRoot = 11;
var ElementTypeSuspense = 12;
var ElementTypeSuspenseList = 13;
var ElementTypeTracingMarker = 14; // Different types of elements displayed in the Elements tree.
// These types may be used to visually distinguish types,
// or to enable/disable certain functionality.

// WARNING
// The values below are referenced by ComponentFilters (which are saved via localStorage).
// Do not change them or it will break previously saved user customizations.
// If new filter types are added, use new numbers rather than re-ordering existing ones.
var ComponentFilterElementType = 1;
var ComponentFilterDisplayName = 2;
var ComponentFilterLocation = 3;
var ComponentFilterHOC = 4;
var StrictMode = 1;

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export CHROME_WEBSTORE_EXTENSION_ID */
/* unused harmony export INTERNAL_EXTENSION_ID */
/* unused harmony export LOCAL_EXTENSION_ID */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return __DEBUG__; });
/* unused harmony export __PERFORMANCE_PROFILE__ */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return TREE_OPERATION_ADD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return TREE_OPERATION_REMOVE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return TREE_OPERATION_REORDER_CHILDREN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return TREE_OPERATION_UPDATE_TREE_BASE_DURATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return TREE_OPERATION_REMOVE_ROOT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return TREE_OPERATION_SET_SUBTREE_MODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return PROFILING_FLAG_BASIC_SUPPORT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return PROFILING_FLAG_TIMELINE_SUPPORT; });
/* unused harmony export LOCAL_STORAGE_DEFAULT_TAB_KEY */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return SESSION_STORAGE_LAST_SELECTION_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return LOCAL_STORAGE_OPEN_IN_EDITOR_URL; });
/* unused harmony export LOCAL_STORAGE_PARSE_HOOK_NAMES_KEY */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return SESSION_STORAGE_RELOAD_AND_PROFILE_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS; });
/* unused harmony export LOCAL_STORAGE_BROWSER_THEME */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return LOCAL_STORAGE_SHOULD_APPEND_COMPONENT_STACK_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY; });
/* unused harmony export LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return LOCAL_STORAGE_HIDE_CONSOLE_LOGS_IN_STRICT_MODE; });
/* unused harmony export PROFILER_EXPORT_VERSION */
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var CHROME_WEBSTORE_EXTENSION_ID = 'fmkadmapgofadopljbjfkapdkoienihi';
var INTERNAL_EXTENSION_ID = 'dnjnjgbfilfphmojnmhliehogmojhclc';
var LOCAL_EXTENSION_ID = 'ikiahnapldjmdmpkmfhjdjilojjhgcbf'; // Flip this flag to true to enable verbose console debug logging.

var __DEBUG__ = false; // Flip this flag to true to enable performance.mark() and performance.measure() timings.

var __PERFORMANCE_PROFILE__ = false;
var TREE_OPERATION_ADD = 1;
var TREE_OPERATION_REMOVE = 2;
var TREE_OPERATION_REORDER_CHILDREN = 3;
var TREE_OPERATION_UPDATE_TREE_BASE_DURATION = 4;
var TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS = 5;
var TREE_OPERATION_REMOVE_ROOT = 6;
var TREE_OPERATION_SET_SUBTREE_MODE = 7;
var PROFILING_FLAG_BASIC_SUPPORT = 1;
var PROFILING_FLAG_TIMELINE_SUPPORT = 2;
var LOCAL_STORAGE_DEFAULT_TAB_KEY = 'React::DevTools::defaultTab';
var LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY = 'React::DevTools::componentFilters';
var SESSION_STORAGE_LAST_SELECTION_KEY = 'React::DevTools::lastSelection';
var LOCAL_STORAGE_OPEN_IN_EDITOR_URL = 'React::DevTools::openInEditorUrl';
var LOCAL_STORAGE_PARSE_HOOK_NAMES_KEY = 'React::DevTools::parseHookNames';
var SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY = 'React::DevTools::recordChangeDescriptions';
var SESSION_STORAGE_RELOAD_AND_PROFILE_KEY = 'React::DevTools::reloadAndProfile';
var LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS = 'React::DevTools::breakOnConsoleErrors';
var LOCAL_STORAGE_BROWSER_THEME = 'React::DevTools::theme';
var LOCAL_STORAGE_SHOULD_APPEND_COMPONENT_STACK_KEY = 'React::DevTools::appendComponentStack';
var LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY = 'React::DevTools::showInlineWarningsAndErrors';
var LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY = 'React::DevTools::traceUpdatesEnabled';
var LOCAL_STORAGE_HIDE_CONSOLE_LOGS_IN_STRICT_MODE = 'React::DevTools::hideConsoleLogsInStrictMode';
var PROFILER_EXPORT_VERSION = 5;

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CONCURRENT_MODE_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return CONCURRENT_MODE_SYMBOL_STRING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return CONTEXT_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return CONTEXT_SYMBOL_STRING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return SERVER_CONTEXT_SYMBOL_STRING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return DEPRECATED_ASYNC_MODE_SYMBOL_STRING; });
/* unused harmony export ELEMENT_NUMBER */
/* unused harmony export ELEMENT_SYMBOL_STRING */
/* unused harmony export DEBUG_TRACING_MODE_NUMBER */
/* unused harmony export DEBUG_TRACING_MODE_SYMBOL_STRING */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return FORWARD_REF_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return FORWARD_REF_SYMBOL_STRING; });
/* unused harmony export FRAGMENT_NUMBER */
/* unused harmony export FRAGMENT_SYMBOL_STRING */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return LAZY_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return LAZY_SYMBOL_STRING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return MEMO_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return MEMO_SYMBOL_STRING; });
/* unused harmony export PORTAL_NUMBER */
/* unused harmony export PORTAL_SYMBOL_STRING */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return PROFILER_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return PROFILER_SYMBOL_STRING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return PROVIDER_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return PROVIDER_SYMBOL_STRING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return SCOPE_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return SCOPE_SYMBOL_STRING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return STRICT_MODE_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return STRICT_MODE_SYMBOL_STRING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return SUSPENSE_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return SUSPENSE_SYMBOL_STRING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return SUSPENSE_LIST_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return SUSPENSE_LIST_SYMBOL_STRING; });
/* unused harmony export SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED_SYMBOL_STRING */
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// This list should be kept updated to reflect additions to 'shared/ReactSymbols'.
// DevTools can't import symbols from 'shared/ReactSymbols' directly for two reasons:
// 1. DevTools requires symbols which may have been deleted in more recent versions (e.g. concurrent mode)
// 2. DevTools must support both Symbol and numeric forms of each symbol;
//    Since e.g. standalone DevTools runs in a separate process, it can't rely on its own ES capabilities.
var CONCURRENT_MODE_NUMBER = 0xeacf;
var CONCURRENT_MODE_SYMBOL_STRING = 'Symbol(react.concurrent_mode)';
var CONTEXT_NUMBER = 0xeace;
var CONTEXT_SYMBOL_STRING = 'Symbol(react.context)';
var SERVER_CONTEXT_SYMBOL_STRING = 'Symbol(react.server_context)';
var DEPRECATED_ASYNC_MODE_SYMBOL_STRING = 'Symbol(react.async_mode)';
var ELEMENT_NUMBER = 0xeac7;
var ELEMENT_SYMBOL_STRING = 'Symbol(react.element)';
var DEBUG_TRACING_MODE_NUMBER = 0xeae1;
var DEBUG_TRACING_MODE_SYMBOL_STRING = 'Symbol(react.debug_trace_mode)';
var FORWARD_REF_NUMBER = 0xead0;
var FORWARD_REF_SYMBOL_STRING = 'Symbol(react.forward_ref)';
var FRAGMENT_NUMBER = 0xeacb;
var FRAGMENT_SYMBOL_STRING = 'Symbol(react.fragment)';
var LAZY_NUMBER = 0xead4;
var LAZY_SYMBOL_STRING = 'Symbol(react.lazy)';
var MEMO_NUMBER = 0xead3;
var MEMO_SYMBOL_STRING = 'Symbol(react.memo)';
var PORTAL_NUMBER = 0xeaca;
var PORTAL_SYMBOL_STRING = 'Symbol(react.portal)';
var PROFILER_NUMBER = 0xead2;
var PROFILER_SYMBOL_STRING = 'Symbol(react.profiler)';
var PROVIDER_NUMBER = 0xeacd;
var PROVIDER_SYMBOL_STRING = 'Symbol(react.provider)';
var SCOPE_NUMBER = 0xead7;
var SCOPE_SYMBOL_STRING = 'Symbol(react.scope)';
var STRICT_MODE_NUMBER = 0xeacc;
var STRICT_MODE_SYMBOL_STRING = 'Symbol(react.strict_mode)';
var SUSPENSE_NUMBER = 0xead1;
var SUSPENSE_SYMBOL_STRING = 'Symbol(react.suspense)';
var SUSPENSE_LIST_NUMBER = 0xead8;
var SUSPENSE_LIST_SYMBOL_STRING = 'Symbol(react.suspense_list)';
var SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED_SYMBOL_STRING = 'Symbol(react.server_context.defaultValue)';

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "j", function() { return /* binding */ hasAssignedBackend; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ cleanForBridge; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ copyWithDelete; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ copyWithRename; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* binding */ copyWithSet; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* binding */ getEffectDurations; });
__webpack_require__.d(__webpack_exports__, "l", function() { return /* binding */ serializeToString; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* binding */ formatWithStyles; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* binding */ format; });
__webpack_require__.d(__webpack_exports__, "k", function() { return /* binding */ isSynchronousXHRSupported; });
__webpack_require__.d(__webpack_exports__, "h", function() { return /* binding */ gt; });
__webpack_require__.d(__webpack_exports__, "i", function() { return /* binding */ gte; });

// CONCATENATED MODULE: /Users/hoxy/repos/react/node_modules/compare-versions/lib/esm/index.js
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Compare [semver](https://semver.org/) version strings to find greater, equal or lesser.
 * This library supports the full semver specification, including comparing versions with different number of digits like `1.0.0`, `1.0`, `1`, and pre-release versions like `1.0.0-alpha`.
 * @param v1 - First version to compare
 * @param v2 - Second version to compare
 * @returns Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).
 */
var compareVersions = function compareVersions(v1, v2) {
  // validate input and split into segments
  var n1 = validateAndParse(v1);
  var n2 = validateAndParse(v2); // pop off the patch

  var p1 = n1.pop();
  var p2 = n2.pop(); // validate numbers

  var r = compareSegments(n1, n2);
  if (r !== 0) return r; // validate pre-release

  if (p1 && p2) {
    return compareSegments(p1.split('.'), p2.split('.'));
  } else if (p1 || p2) {
    return p1 ? -1 : 1;
  }

  return 0;
};
/**
 * Validate [semver](https://semver.org/) version strings.
 *
 * @param version Version number to validate
 * @returns `true` if the version number is a valid semver version number, `false` otherwise.
 *
 * @example
 * ```
 * validate('1.0.0-rc.1'); // return true
 * validate('1.0-rc.1'); // return false
 * validate('foo'); // return false
 * ```
 */

var validate = function validate(version) {
  return typeof version === 'string' && /^[v\d]/.test(version) && semver.test(version);
};
/**
 * Compare [semver](https://semver.org/) version strings using the specified operator.
 *
 * @param v1 First version to compare
 * @param v2 Second version to compare
 * @param operator Allowed arithmetic operator to use
 * @returns `true` if the comparison between the firstVersion and the secondVersion satisfies the operator, `false` otherwise.
 *
 * @example
 * ```
 * compare('10.1.8', '10.0.4', '>'); // return true
 * compare('10.0.1', '10.0.1', '='); // return true
 * compare('10.1.1', '10.2.2', '<'); // return true
 * compare('10.1.1', '10.2.2', '<='); // return true
 * compare('10.1.1', '10.2.2', '>='); // return false
 * ```
 */

var compare = function compare(v1, v2, operator) {
  // validate input operator
  assertValidOperator(operator); // since result of compareVersions can only be -1 or 0 or 1
  // a simple map can be used to replace switch

  var res = compareVersions(v1, v2);
  return operatorResMap[operator].includes(res);
};
/**
 * Match [npm semver](https://docs.npmjs.com/cli/v6/using-npm/semver) version range.
 *
 * @param version Version number to match
 * @param range Range pattern for version
 * @returns `true` if the version number is within the range, `false` otherwise.
 *
 * @example
 * ```
 * satisfies('1.1.0', '^1.0.0'); // return true
 * satisfies('1.1.0', '~1.0.0'); // return false
 * ```
 */

var satisfies = function satisfies(version, range) {
  // if no range operator then "="
  var m = range.match(/^([<>=~^]+)/);
  var op = m ? m[1] : '='; // if gt/lt/eq then operator compare

  if (op !== '^' && op !== '~') return compare(version, range, op); // else range of either "~" or "^" is assumed

  var _validateAndParse = validateAndParse(version),
      _validateAndParse2 = _slicedToArray(_validateAndParse, 5),
      v1 = _validateAndParse2[0],
      v2 = _validateAndParse2[1],
      v3 = _validateAndParse2[2],
      vp = _validateAndParse2[4];

  var _validateAndParse3 = validateAndParse(range),
      _validateAndParse4 = _slicedToArray(_validateAndParse3, 5),
      r1 = _validateAndParse4[0],
      r2 = _validateAndParse4[1],
      r3 = _validateAndParse4[2],
      rp = _validateAndParse4[4];

  var v = [v1, v2, v3];
  var r = [r1, r2 !== null && r2 !== void 0 ? r2 : 'x', r3 !== null && r3 !== void 0 ? r3 : 'x']; // validate pre-release

  if (rp) {
    if (!vp) return false;
    if (compareSegments(v, r) !== 0) return false;
    if (compareSegments(vp.split('.'), rp.split('.')) === -1) return false;
  } // first non-zero number


  var nonZero = r.findIndex(function (v) {
    return v !== '0';
  }) + 1; // pointer to where segments can be >=

  var i = op === '~' ? 2 : nonZero > 1 ? nonZero : 1; // before pointer must be equal

  if (compareSegments(v.slice(0, i), r.slice(0, i)) !== 0) return false; // after pointer must be >=

  if (compareSegments(v.slice(i), r.slice(i)) === -1) return false;
  return true;
};
var semver = /^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;

var validateAndParse = function validateAndParse(version) {
  if (typeof version !== 'string') {
    throw new TypeError('Invalid argument expected string');
  }

  var match = version.match(semver);

  if (!match) {
    throw new Error("Invalid argument not valid semver ('".concat(version, "' received)"));
  }

  match.shift();
  return match;
};

var isWildcard = function isWildcard(s) {
  return s === '*' || s === 'x' || s === 'X';
};

var tryParse = function tryParse(v) {
  var n = parseInt(v, 10);
  return isNaN(n) ? v : n;
};

var forceType = function forceType(a, b) {
  return _typeof(a) !== _typeof(b) ? [String(a), String(b)] : [a, b];
};

var compareStrings = function compareStrings(a, b) {
  if (isWildcard(a) || isWildcard(b)) return 0;

  var _forceType = forceType(tryParse(a), tryParse(b)),
      _forceType2 = _slicedToArray(_forceType, 2),
      ap = _forceType2[0],
      bp = _forceType2[1];

  if (ap > bp) return 1;
  if (ap < bp) return -1;
  return 0;
};

var compareSegments = function compareSegments(a, b) {
  for (var i = 0; i < Math.max(a.length, b.length); i++) {
    var r = compareStrings(a[i] || '0', b[i] || '0');
    if (r !== 0) return r;
  }

  return 0;
};

var operatorResMap = {
  '>': [1],
  '>=': [0, 1],
  '=': [0],
  '<=': [-1, 0],
  '<': [-1]
};
var allowedOperators = Object.keys(operatorResMap);

var assertValidOperator = function assertValidOperator(op) {
  if (typeof op !== 'string') {
    throw new TypeError("Invalid operator type, expected string but got ".concat(_typeof(op)));
  }

  if (allowedOperators.indexOf(op) === -1) {
    throw new Error("Invalid operator, expected one of ".concat(allowedOperators.join('|')));
  }
};
// EXTERNAL MODULE: ../react-devtools-shared/src/hydration.js
var hydration = __webpack_require__(10);

// EXTERNAL MODULE: ../shared/isArray.js
var isArray = __webpack_require__(9);

// CONCATENATED MODULE: ../react-devtools-shared/src/backend/utils.js
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || utils_unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function utils_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return utils_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return utils_arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return utils_arrayLikeToArray(arr); }

function utils_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function utils_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { utils_typeof = function _typeof(obj) { return typeof obj; }; } else { utils_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return utils_typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */



// TODO: update this to the first React version that has a corresponding DevTools backend
var FIRST_DEVTOOLS_BACKEND_LOCKSTEP_VER = '999.9.9';
function hasAssignedBackend(version) {
  if (version == null || version === '') {
    return false;
  }

  return gte(version, FIRST_DEVTOOLS_BACKEND_LOCKSTEP_VER);
}
function cleanForBridge(data, isPathAllowed) {
  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  if (data !== null) {
    var cleanedPaths = [];
    var unserializablePaths = [];
    var cleanedData = Object(hydration["a" /* dehydrate */])(data, cleanedPaths, unserializablePaths, path, isPathAllowed);
    return {
      data: cleanedData,
      cleaned: cleanedPaths,
      unserializable: unserializablePaths
    };
  } else {
    return null;
  }
}
function copyWithDelete(obj, path) {
  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var key = path[index];
  var updated = Object(isArray["a" /* default */])(obj) ? obj.slice() : _objectSpread({}, obj);

  if (index + 1 === path.length) {
    if (Object(isArray["a" /* default */])(updated)) {
      updated.splice(key, 1);
    } else {
      delete updated[key];
    }
  } else {
    // $FlowFixMe[incompatible-use] number or string is fine here
    updated[key] = copyWithDelete(obj[key], path, index + 1);
  }

  return updated;
} // This function expects paths to be the same except for the final value.
// e.g. ['path', 'to', 'foo'] and ['path', 'to', 'bar']

function copyWithRename(obj, oldPath, newPath) {
  var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var oldKey = oldPath[index];
  var updated = Object(isArray["a" /* default */])(obj) ? obj.slice() : _objectSpread({}, obj);

  if (index + 1 === oldPath.length) {
    var newKey = newPath[index]; // $FlowFixMe[incompatible-use] number or string is fine here

    updated[newKey] = updated[oldKey];

    if (Object(isArray["a" /* default */])(updated)) {
      updated.splice(oldKey, 1);
    } else {
      delete updated[oldKey];
    }
  } else {
    // $FlowFixMe[incompatible-use] number or string is fine here
    updated[oldKey] = copyWithRename(obj[oldKey], oldPath, newPath, index + 1);
  }

  return updated;
}
function copyWithSet(obj, path, value) {
  var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  if (index >= path.length) {
    return value;
  }

  var key = path[index];
  var updated = Object(isArray["a" /* default */])(obj) ? obj.slice() : _objectSpread({}, obj); // $FlowFixMe[incompatible-use] number or string is fine here

  updated[key] = copyWithSet(obj[key], path, value, index + 1);
  return updated;
}
function getEffectDurations(root) {
  // Profiling durations are only available for certain builds.
  // If available, they'll be stored on the HostRoot.
  var effectDuration = null;
  var passiveEffectDuration = null;
  var hostRoot = root.current;

  if (hostRoot != null) {
    var stateNode = hostRoot.stateNode;

    if (stateNode != null) {
      effectDuration = stateNode.effectDuration != null ? stateNode.effectDuration : null;
      passiveEffectDuration = stateNode.passiveEffectDuration != null ? stateNode.passiveEffectDuration : null;
    }
  }

  return {
    effectDuration: effectDuration,
    passiveEffectDuration: passiveEffectDuration
  };
}
function serializeToString(data) {
  if (data === undefined) {
    return 'undefined';
  }

  var cache = new Set(); // Use a custom replacer function to protect against circular references.

  return JSON.stringify(data, function (key, value) {
    if (utils_typeof(value) === 'object' && value !== null) {
      if (cache.has(value)) {
        return;
      }

      cache.add(value);
    }

    if (typeof value === 'bigint') {
      return value.toString() + 'n';
    }

    return value;
  }, 2);
} // Formats an array of args with a style for console methods, using
// the following algorithm:
//     1. The first param is a string that contains %c
//          - Bail out and return the args without modifying the styles.
//            We don't want to affect styles that the developer deliberately set.
//     2. The first param is a string that doesn't contain %c but contains
//        string formatting
//          - [`%c${args[0]}`, style, ...args.slice(1)]
//          - Note: we assume that the string formatting that the developer uses
//            is correct.
//     3. The first param is a string that doesn't contain string formatting
//        OR is not a string
//          - Create a formatting string where:
//                 boolean, string, symbol -> %s
//                 number -> %f OR %i depending on if it's an int or float
//                 default -> %o

function formatWithStyles(inputArgs, style) {
  if (inputArgs === undefined || inputArgs === null || inputArgs.length === 0 || // Matches any of %c but not %%c
  typeof inputArgs[0] === 'string' && inputArgs[0].match(/([^%]|^)(%c)/g) || style === undefined) {
    return inputArgs;
  } // Matches any of %(o|O|d|i|s|f), but not %%(o|O|d|i|s|f)


  var REGEXP = /([^%]|^)((%%)*)(%([oOdisf]))/g;

  if (typeof inputArgs[0] === 'string' && inputArgs[0].match(REGEXP)) {
    return ["%c".concat(inputArgs[0]), style].concat(_toConsumableArray(inputArgs.slice(1)));
  } else {
    var firstArg = inputArgs.reduce(function (formatStr, elem, i) {
      if (i > 0) {
        formatStr += ' ';
      }

      switch (utils_typeof(elem)) {
        case 'string':
        case 'boolean':
        case 'symbol':
          return formatStr += '%s';

        case 'number':
          var formatting = Number.isInteger(elem) ? '%i' : '%f';
          return formatStr += formatting;

        default:
          return formatStr += '%o';
      }
    }, '%c');
    return [firstArg, style].concat(_toConsumableArray(inputArgs));
  }
} // based on https://github.com/tmpfs/format-util/blob/0e62d430efb0a1c51448709abd3e2406c14d8401/format.js#L1
// based on https://developer.mozilla.org/en-US/docs/Web/API/console#Using_string_substitutions
// Implements s, d, i and f placeholders
// NOTE: KEEP IN SYNC with src/hook.js

function format(maybeMessage) {
  for (var _len = arguments.length, inputArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    inputArgs[_key - 1] = arguments[_key];
  }

  var args = inputArgs.slice();
  var formatted = String(maybeMessage); // If the first argument is a string, check for substitutions.

  if (typeof maybeMessage === 'string') {
    if (args.length) {
      var REGEXP = /(%?)(%([jds]))/g;
      formatted = formatted.replace(REGEXP, function (match, escaped, ptn, flag) {
        var arg = args.shift();

        switch (flag) {
          case 's':
            arg += '';
            break;

          case 'd':
          case 'i':
            arg = parseInt(arg, 10).toString();
            break;

          case 'f':
            arg = parseFloat(arg).toString();
            break;
        }

        if (!escaped) {
          return arg;
        }

        args.unshift(arg);
        return match;
      });
    }
  } // Arguments that remain after formatting.


  if (args.length) {
    for (var i = 0; i < args.length; i++) {
      formatted += ' ' + String(args[i]);
    }
  } // Update escaped %% values.


  formatted = formatted.replace(/%{2,2}/g, '%');
  return String(formatted);
}
function isSynchronousXHRSupported() {
  return !!(window.document && window.document.featurePolicy && window.document.featurePolicy.allowsFeature('sync-xhr'));
}
function gt() {
  var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return compareVersions(a, b) === 1;
}
function gte() {
  var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return compareVersions(a, b) > -1;
}

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return localStorageGetItem; });
/* unused harmony export localStorageRemoveItem */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return localStorageSetItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return sessionStorageGetItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return sessionStorageRemoveItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return sessionStorageSetItem; });
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function localStorageGetItem(key) {
  try {
    return localStorage.getItem(key);
  } catch (error) {
    return null;
  }
}
function localStorageRemoveItem(key) {
  try {
    localStorage.removeItem(key);
  } catch (error) {}
}
function localStorageSetItem(key, value) {
  try {
    return localStorage.setItem(key, value);
  } catch (error) {}
}
function sessionStorageGetItem(key) {
  try {
    return sessionStorage.getItem(key);
  } catch (error) {
    return null;
  }
}
function sessionStorageRemoveItem(key) {
  try {
    sessionStorage.removeItem(key);
  } catch (error) {}
}
function sessionStorageSetItem(key, value) {
  try {
    return sessionStorage.setItem(key, value);
  } catch (error) {}
}

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var isArray = Array.isArray;
/* harmony default export */ __webpack_exports__["a"] = (isArray);

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(22);
} else {}

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* unused harmony export isStringComponentStack */
/* unused harmony export dangerous_setTargetConsoleForTesting */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return registerRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return patch; });
/* unused harmony export unpatch */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return patchForStrictMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return unpatchForStrictMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return patchConsoleUsingWindowValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return writeConsolePatchSettingsToWindow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return installConsoleFunctionsToWindow; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
/* harmony import */ var _DevToolsFiberComponentStack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14);
/* harmony import */ var react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(0);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */





var OVERRIDE_CONSOLE_METHODS = ['error', 'trace', 'warn'];
var DIMMED_NODE_CONSOLE_COLOR = '\x1b[2m%s\x1b[0m'; // React's custom built component stack strings match "\s{4}in"
// Chrome's prefix matches "\s{4}at"

var PREFIX_REGEX = /\s{4}(in|at)\s{1}/; // Firefox and Safari have no prefix ("")
// but we can fallback to looking for location info (e.g. "foo.js:12:345")

var ROW_COLUMN_NUMBER_REGEX = /:\d+:\d+(\n|$)/;
function isStringComponentStack(text) {
  return PREFIX_REGEX.test(text) || ROW_COLUMN_NUMBER_REGEX.test(text);
}
var STYLE_DIRECTIVE_REGEX = /^%c/; // This function tells whether or not the arguments for a console
// method has been overridden by the patchForStrictMode function.
// If it has we'll need to do some special formatting of the arguments
// so the console color stays consistent

function isStrictModeOverride(args, method) {
  return args.length >= 2 && STYLE_DIRECTIVE_REGEX.test(args[0]) && args[1] === "color: ".concat(getConsoleColor(method) || '');
}

function getConsoleColor(method) {
  switch (method) {
    case 'warn':
      return consoleSettingsRef.browserTheme === 'light' ? "rgba(250, 180, 50, 0.75)" : "rgba(250, 180, 50, 0.5)";

    case 'error':
      return consoleSettingsRef.browserTheme === 'light' ? "rgba(250, 123, 130, 0.75)" : "rgba(250, 123, 130, 0.5)";

    case 'log':
    default:
      return consoleSettingsRef.browserTheme === 'light' ? "rgba(125, 125, 125, 0.75)" : "rgba(125, 125, 125, 0.5)";
  }
}

var injectedRenderers = new Map();
var targetConsole = console;
var targetConsoleMethods = {};

for (var method in console) {
  targetConsoleMethods[method] = console[method];
}

var unpatchFn = null;
var isNode = false;

try {
  isNode = undefined === global;
} catch (error) {} // Enables e.g. Jest tests to inject a mock console object.


function dangerous_setTargetConsoleForTesting(targetConsoleForTesting) {
  targetConsole = targetConsoleForTesting;
  targetConsoleMethods = {};

  for (var _method in targetConsole) {
    targetConsoleMethods[_method] = console[_method];
  }
} // v16 renderers should use this method to inject internals necessary to generate a component stack.
// These internals will be used if the console is patched.
// Injecting them separately allows the console to easily be patched or un-patched later (at runtime).

function registerRenderer(renderer, onErrorOrWarning) {
  var currentDispatcherRef = renderer.currentDispatcherRef,
      getCurrentFiber = renderer.getCurrentFiber,
      findFiberByHostInstance = renderer.findFiberByHostInstance,
      version = renderer.version; // Ignore React v15 and older because they don't expose a component stack anyway.

  if (typeof findFiberByHostInstance !== 'function') {
    return;
  } // currentDispatcherRef gets injected for v16.8+ to support hooks inspection.
  // getCurrentFiber gets injected for v16.9+.


  if (currentDispatcherRef != null && typeof getCurrentFiber === 'function') {
    var _getInternalReactCons = Object(_renderer__WEBPACK_IMPORTED_MODULE_1__[/* getInternalReactConstants */ "b"])(version),
        ReactTypeOfWork = _getInternalReactCons.ReactTypeOfWork;

    injectedRenderers.set(renderer, {
      currentDispatcherRef: currentDispatcherRef,
      getCurrentFiber: getCurrentFiber,
      workTagMap: ReactTypeOfWork,
      onErrorOrWarning: onErrorOrWarning
    });
  }
}
var consoleSettingsRef = {
  appendComponentStack: false,
  breakOnConsoleErrors: false,
  showInlineWarningsAndErrors: false,
  hideConsoleLogsInStrictMode: false,
  browserTheme: 'dark'
}; // Patches console methods to append component stack for the current fiber.
// Call unpatch() to remove the injected behavior.

function patch(_ref) {
  var appendComponentStack = _ref.appendComponentStack,
      breakOnConsoleErrors = _ref.breakOnConsoleErrors,
      showInlineWarningsAndErrors = _ref.showInlineWarningsAndErrors,
      hideConsoleLogsInStrictMode = _ref.hideConsoleLogsInStrictMode,
      browserTheme = _ref.browserTheme;
  // Settings may change after we've patched the console.
  // Using a shared ref allows the patch function to read the latest values.
  consoleSettingsRef.appendComponentStack = appendComponentStack;
  consoleSettingsRef.breakOnConsoleErrors = breakOnConsoleErrors;
  consoleSettingsRef.showInlineWarningsAndErrors = showInlineWarningsAndErrors;
  consoleSettingsRef.hideConsoleLogsInStrictMode = hideConsoleLogsInStrictMode;
  consoleSettingsRef.browserTheme = browserTheme;

  if (appendComponentStack || breakOnConsoleErrors || showInlineWarningsAndErrors) {
    if (unpatchFn !== null) {
      // Don't patch twice.
      return;
    }

    var originalConsoleMethods = {};

    unpatchFn = function unpatchFn() {
      for (var _method2 in originalConsoleMethods) {
        try {
          targetConsole[_method2] = originalConsoleMethods[_method2];
        } catch (error) {}
      }
    };

    OVERRIDE_CONSOLE_METHODS.forEach(function (method) {
      try {
        var originalMethod = originalConsoleMethods[method] = targetConsole[method].__REACT_DEVTOOLS_ORIGINAL_METHOD__ ? targetConsole[method].__REACT_DEVTOOLS_ORIGINAL_METHOD__ : targetConsole[method]; // $FlowFixMe[missing-local-annot]

        var overrideMethod = function overrideMethod() {
          var shouldAppendWarningStack = false;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          if (method !== 'log') {
            if (consoleSettingsRef.appendComponentStack) {
              var lastArg = args.length > 0 ? args[args.length - 1] : null;
              var alreadyHasComponentStack = typeof lastArg === 'string' && isStringComponentStack(lastArg); // If we are ever called with a string that already has a component stack,
              // e.g. a React error/warning, don't append a second stack.

              shouldAppendWarningStack = !alreadyHasComponentStack;
            }
          }

          var shouldShowInlineWarningsAndErrors = consoleSettingsRef.showInlineWarningsAndErrors && (method === 'error' || method === 'warn'); // Search for the first renderer that has a current Fiber.
          // We don't handle the edge case of stacks for more than one (e.g. interleaved renderers?)
          // eslint-disable-next-line no-for-of-loops/no-for-of-loops

          var _iterator = _createForOfIteratorHelper(injectedRenderers.values()),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _step$value = _step.value,
                  currentDispatcherRef = _step$value.currentDispatcherRef,
                  getCurrentFiber = _step$value.getCurrentFiber,
                  onErrorOrWarning = _step$value.onErrorOrWarning,
                  workTagMap = _step$value.workTagMap;
              var current = getCurrentFiber();

              if (current != null) {
                try {
                  if (shouldShowInlineWarningsAndErrors) {
                    // patch() is called by two places: (1) the hook and (2) the renderer backend.
                    // The backend is what implements a message queue, so it's the only one that injects onErrorOrWarning.
                    if (typeof onErrorOrWarning === 'function') {
                      onErrorOrWarning(current, method, // Copy args before we mutate them (e.g. adding the component stack)
                      args.slice());
                    }
                  }

                  if (shouldAppendWarningStack) {
                    var componentStack = Object(_DevToolsFiberComponentStack__WEBPACK_IMPORTED_MODULE_2__[/* getStackByFiberInDevAndProd */ "b"])(workTagMap, current, currentDispatcherRef);

                    if (componentStack !== '') {
                      if (isStrictModeOverride(args, method)) {
                        args[0] = "".concat(args[0], " %s");
                        args.push(componentStack);
                      } else {
                        args.push(componentStack);
                      }
                    }
                  }
                } catch (error) {
                  // Don't let a DevTools or React internal error interfere with logging.
                  setTimeout(function () {
                    throw error;
                  }, 0);
                } finally {
                  break;
                }
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          if (consoleSettingsRef.breakOnConsoleErrors) {
            // --- Welcome to debugging with React DevTools ---
            // This debugger statement means that you've enabled the "break on warnings" feature.
            // Use the browser's Call Stack panel to step out of this override function-
            // to where the original warning or error was logged.
            // eslint-disable-next-line no-debugger
            debugger;
          }

          originalMethod.apply(void 0, args);
        };

        overrideMethod.__REACT_DEVTOOLS_ORIGINAL_METHOD__ = originalMethod;
        originalMethod.__REACT_DEVTOOLS_OVERRIDE_METHOD__ = overrideMethod;
        targetConsole[method] = overrideMethod;
      } catch (error) {}
    });
  } else {
    unpatch();
  }
} // Removed component stack patch from console methods.

function unpatch() {
  if (unpatchFn !== null) {
    unpatchFn();
    unpatchFn = null;
  }
}
var unpatchForStrictModeFn = null; // NOTE: KEEP IN SYNC with src/hook.js:patchConsoleForInitialRenderInStrictMode

function patchForStrictMode() {
  if (react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_3__[/* consoleManagedByDevToolsDuringStrictMode */ "a"]) {
    var overrideConsoleMethods = ['error', 'group', 'groupCollapsed', 'info', 'log', 'trace', 'warn'];

    if (unpatchForStrictModeFn !== null) {
      // Don't patch twice.
      return;
    }

    var originalConsoleMethods = {};

    unpatchForStrictModeFn = function unpatchForStrictModeFn() {
      for (var _method3 in originalConsoleMethods) {
        try {
          targetConsole[_method3] = originalConsoleMethods[_method3];
        } catch (error) {}
      }
    };

    overrideConsoleMethods.forEach(function (method) {
      try {
        var originalMethod = originalConsoleMethods[method] = targetConsole[method].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ ? targetConsole[method].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ : targetConsole[method]; // $FlowFixMe[missing-local-annot]

        var overrideMethod = function overrideMethod() {
          if (!consoleSettingsRef.hideConsoleLogsInStrictMode) {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            // Dim the text color of the double logs if we're not
            // hiding them.
            if (isNode) {
              originalMethod(DIMMED_NODE_CONSOLE_COLOR, _utils__WEBPACK_IMPORTED_MODULE_0__[/* format */ "e"].apply(void 0, args));
            } else {
              var color = getConsoleColor(method);

              if (color) {
                originalMethod.apply(void 0, _toConsumableArray(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatWithStyles */ "f"])(args, "color: ".concat(color))));
              } else {
                throw Error('Console color is not defined');
              }
            }
          }
        };

        overrideMethod.__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ = originalMethod;
        originalMethod.__REACT_DEVTOOLS_STRICT_MODE_OVERRIDE_METHOD__ = overrideMethod;
        targetConsole[method] = overrideMethod;
      } catch (error) {}
    });
  }
} // NOTE: KEEP IN SYNC with src/hook.js:unpatchConsoleForInitialRenderInStrictMode

function unpatchForStrictMode() {
  if (react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_3__[/* consoleManagedByDevToolsDuringStrictMode */ "a"]) {
    if (unpatchForStrictModeFn !== null) {
      unpatchForStrictModeFn();
      unpatchForStrictModeFn = null;
    }
  }
}
function patchConsoleUsingWindowValues() {
  var _castBool, _castBool2, _castBool3, _castBool4, _castBrowserTheme;

  var appendComponentStack = (_castBool = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* castBool */ "a"])(window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__)) !== null && _castBool !== void 0 ? _castBool : true;
  var breakOnConsoleErrors = (_castBool2 = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* castBool */ "a"])(window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__)) !== null && _castBool2 !== void 0 ? _castBool2 : false;
  var showInlineWarningsAndErrors = (_castBool3 = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* castBool */ "a"])(window.__REACT_DEVTOOLS_SHOW_INLINE_WARNINGS_AND_ERRORS__)) !== null && _castBool3 !== void 0 ? _castBool3 : true;
  var hideConsoleLogsInStrictMode = (_castBool4 = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* castBool */ "a"])(window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__)) !== null && _castBool4 !== void 0 ? _castBool4 : false;
  var browserTheme = (_castBrowserTheme = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* castBrowserTheme */ "b"])(window.__REACT_DEVTOOLS_BROWSER_THEME__)) !== null && _castBrowserTheme !== void 0 ? _castBrowserTheme : 'dark';
  patch({
    appendComponentStack: appendComponentStack,
    breakOnConsoleErrors: breakOnConsoleErrors,
    showInlineWarningsAndErrors: showInlineWarningsAndErrors,
    hideConsoleLogsInStrictMode: hideConsoleLogsInStrictMode,
    browserTheme: browserTheme
  });
} // After receiving cached console patch settings from React Native, we set them on window.
// When the console is initially patched (in renderer.js and hook.js), these values are read.
// The browser extension (etc.) sets these values on window, but through another method.

function writeConsolePatchSettingsToWindow(settings) {
  window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__ = settings.appendComponentStack;
  window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__ = settings.breakOnConsoleErrors;
  window.__REACT_DEVTOOLS_SHOW_INLINE_WARNINGS_AND_ERRORS__ = settings.showInlineWarningsAndErrors;
  window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__ = settings.hideConsoleLogsInStrictMode;
  window.__REACT_DEVTOOLS_BROWSER_THEME__ = settings.browserTheme;
}
function installConsoleFunctionsToWindow() {
  window.__REACT_DEVTOOLS_CONSOLE_FUNCTIONS__ = {
    patchConsoleUsingWindowValues: patchConsoleUsingWindowValues,
    registerRendererWithConsole: registerRenderer
  };
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16)))

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

function isArray(a) {
  return isArrayImpl(a);
}

/* harmony default export */ __webpack_exports__["a"] = (isArray);

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return meta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return dehydrate; });
/* unused harmony export fillInPath */
/* unused harmony export hydrate */
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var meta = {
  inspectable: Symbol('inspectable'),
  inspected: Symbol('inspected'),
  name: Symbol('name'),
  preview_long: Symbol('preview_long'),
  preview_short: Symbol('preview_short'),
  readonly: Symbol('readonly'),
  size: Symbol('size'),
  type: Symbol('type'),
  unserializable: Symbol('unserializable')
};
// This threshold determines the depth at which the bridge "dehydrates" nested data.
// Dehydration means that we don't serialize the data for e.g. postMessage or stringify,
// unless the frontend explicitly requests it (e.g. a user clicks to expand a props object).
//
// Reducing this threshold will improve the speed of initial component inspection,
// but may decrease the responsiveness of expanding objects/arrays to inspect further.
var LEVEL_THRESHOLD = 2;
/**
 * Generate the dehydrated metadata for complex object instances
 */

function createDehydrated(type, inspectable, data, cleaned, path) {
  cleaned.push(path);
  var dehydrated = {
    inspectable: inspectable,
    type: type,
    preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
    preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
    name: !data.constructor || data.constructor.name === 'Object' ? '' : data.constructor.name
  };

  if (type === 'array' || type === 'typed_array') {
    dehydrated.size = data.length;
  } else if (type === 'object') {
    dehydrated.size = Object.keys(data).length;
  }

  if (type === 'iterator' || type === 'typed_array') {
    dehydrated.readonly = true;
  }

  return dehydrated;
}
/**
 * Strip out complex data (instances, functions, and data nested > LEVEL_THRESHOLD levels deep).
 * The paths of the stripped out objects are appended to the `cleaned` list.
 * On the other side of the barrier, the cleaned list is used to "re-hydrate" the cleaned representation into
 * an object with symbols as attributes, so that a sanitized object can be distinguished from a normal object.
 *
 * Input: {"some": {"attr": fn()}, "other": AnInstance}
 * Output: {
 *   "some": {
 *     "attr": {"name": the fn.name, type: "function"}
 *   },
 *   "other": {
 *     "name": "AnInstance",
 *     "type": "object",
 *   },
 * }
 * and cleaned = [["some", "attr"], ["other"]]
 */


function dehydrate(data, cleaned, unserializable, path, isPathAllowed) {
  var level = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
  var type = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getDataType */ "f"])(data);
  var isPathAllowedCheck;

  switch (type) {
    case 'html_element':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
        name: data.tagName,
        type: type
      };

    case 'function':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
        name: typeof data.name === 'function' || !data.name ? 'function' : data.name,
        type: type
      };

    case 'string':
      isPathAllowedCheck = isPathAllowed(path);

      if (isPathAllowedCheck) {
        return data;
      } else {
        return data.length <= 500 ? data : data.slice(0, 500) + '...';
      }

    case 'bigint':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
        name: data.toString(),
        type: type
      };

    case 'symbol':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
        name: data.toString(),
        type: type
      };
    // React Elements aren't very inspector-friendly,
    // and often contain private fields or circular references.

    case 'react_element':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
        name: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getDisplayNameForReactElement */ "i"])(data) || 'Unknown',
        type: type
      };
    // ArrayBuffers error if you try to inspect them.

    case 'array_buffer':
    case 'data_view':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
        name: type === 'data_view' ? 'DataView' : 'ArrayBuffer',
        size: data.byteLength,
        type: type
      };

    case 'array':
      isPathAllowedCheck = isPathAllowed(path);

      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
        return createDehydrated(type, true, data, cleaned, path);
      }

      return data.map(function (item, i) {
        return dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
      });

    case 'html_all_collection':
    case 'typed_array':
    case 'iterator':
      isPathAllowedCheck = isPathAllowed(path);

      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
        return createDehydrated(type, true, data, cleaned, path);
      } else {
        var unserializableValue = {
          unserializable: true,
          type: type,
          readonly: true,
          size: type === 'typed_array' ? data.length : undefined,
          preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
          preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
          name: !data.constructor || data.constructor.name === 'Object' ? '' : data.constructor.name
        }; // TRICKY
        // Don't use [...spread] syntax for this purpose.
        // This project uses @babel/plugin-transform-spread in "loose" mode which only works with Array values.
        // Other types (e.g. typed arrays, Sets) will not spread correctly.

        Array.from(data).forEach(function (item, i) {
          return unserializableValue[i] = dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
        });
        unserializable.push(path);
        return unserializableValue;
      }

    case 'opaque_iterator':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
        name: data[Symbol.toStringTag],
        type: type
      };

    case 'date':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
        name: data.toString(),
        type: type
      };

    case 'regexp':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
        name: data.toString(),
        type: type
      };

    case 'object':
      isPathAllowedCheck = isPathAllowed(path);

      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
        return createDehydrated(type, true, data, cleaned, path);
      } else {
        var object = {};
        Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getAllEnumerableKeys */ "e"])(data).forEach(function (key) {
          var name = key.toString();
          object[name] = dehydrate(data[key], cleaned, unserializable, path.concat([name]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
        });
        return object;
      }

    case 'class_instance':
      isPathAllowedCheck = isPathAllowed(path);

      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
        return createDehydrated(type, true, data, cleaned, path);
      }

      var value = {
        unserializable: true,
        type: type,
        readonly: true,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
        name: data.constructor.name
      };
      Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getAllEnumerableKeys */ "e"])(data).forEach(function (key) {
        var keyAsString = key.toString();
        value[keyAsString] = dehydrate(data[key], cleaned, unserializable, path.concat([keyAsString]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
      });
      unserializable.push(path);
      return value;

    case 'infinity':
    case 'nan':
    case 'undefined':
      // Some values are lossy when sent through a WebSocket.
      // We dehydrate+rehydrate them to preserve their type.
      cleaned.push(path);
      return {
        type: type
      };

    default:
      return data;
  }
}
function fillInPath(object, data, path, value) {
  var target = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getInObject */ "j"])(object, path);

  if (target != null) {
    if (!target[meta.unserializable]) {
      delete target[meta.inspectable];
      delete target[meta.inspected];
      delete target[meta.name];
      delete target[meta.preview_long];
      delete target[meta.preview_short];
      delete target[meta.readonly];
      delete target[meta.size];
      delete target[meta.type];
    }
  }

  if (value !== null && data.unserializable.length > 0) {
    var unserializablePath = data.unserializable[0];
    var isMatch = unserializablePath.length === path.length;

    for (var i = 0; i < path.length; i++) {
      if (path[i] !== unserializablePath[i]) {
        isMatch = false;
        break;
      }
    }

    if (isMatch) {
      upgradeUnserializable(value, value);
    }
  }

  Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* setInObject */ "o"])(object, path, value);
}
function hydrate(object, cleaned, unserializable) {
  cleaned.forEach(function (path) {
    var length = path.length;
    var last = path[length - 1];
    var parent = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getInObject */ "j"])(object, path.slice(0, length - 1));

    if (!parent || !parent.hasOwnProperty(last)) {
      return;
    }

    var value = parent[last];

    if (!value) {
      return;
    } else if (value.type === 'infinity') {
      parent[last] = Infinity;
    } else if (value.type === 'nan') {
      parent[last] = NaN;
    } else if (value.type === 'undefined') {
      parent[last] = undefined;
    } else {
      // Replace the string keys with Symbols so they're non-enumerable.
      var replaced = {};
      replaced[meta.inspectable] = !!value.inspectable;
      replaced[meta.inspected] = false;
      replaced[meta.name] = value.name;
      replaced[meta.preview_long] = value.preview_long;
      replaced[meta.preview_short] = value.preview_short;
      replaced[meta.size] = value.size;
      replaced[meta.readonly] = !!value.readonly;
      replaced[meta.type] = value.type;
      parent[last] = replaced;
    }
  });
  unserializable.forEach(function (path) {
    var length = path.length;
    var last = path[length - 1];
    var parent = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getInObject */ "j"])(object, path.slice(0, length - 1));

    if (!parent || !parent.hasOwnProperty(last)) {
      return;
    }

    var node = parent[last];

    var replacement = _objectSpread({}, node);

    upgradeUnserializable(replacement, node);
    parent[last] = replacement;
  });
  return object;
}

function upgradeUnserializable(destination, source) {
  var _Object$definePropert;

  Object.defineProperties(destination, (_Object$definePropert = {}, _defineProperty(_Object$definePropert, meta.inspected, {
    configurable: true,
    enumerable: false,
    value: !!source.inspected
  }), _defineProperty(_Object$definePropert, meta.name, {
    configurable: true,
    enumerable: false,
    value: source.name
  }), _defineProperty(_Object$definePropert, meta.preview_long, {
    configurable: true,
    enumerable: false,
    value: source.preview_long
  }), _defineProperty(_Object$definePropert, meta.preview_short, {
    configurable: true,
    enumerable: false,
    value: source.preview_short
  }), _defineProperty(_Object$definePropert, meta.size, {
    configurable: true,
    enumerable: false,
    value: source.size
  }), _defineProperty(_Object$definePropert, meta.readonly, {
    configurable: true,
    enumerable: false,
    value: !!source.readonly
  }), _defineProperty(_Object$definePropert, meta.type, {
    configurable: true,
    enumerable: false,
    value: source.type
  }), _defineProperty(_Object$definePropert, meta.unserializable, {
    configurable: true,
    enumerable: false,
    value: !!source.unserializable
  }), _Object$definePropert));
  delete destination.inspected;
  delete destination.name;
  delete destination.preview_long;
  delete destination.preview_short;
  delete destination.size;
  delete destination.readonly;
  delete destination.type;
  delete destination.unserializable;
}

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return consoleManagedByDevToolsDuringStrictMode; });
/* unused harmony export enableLogger */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return enableStyleXFeatures; });
/* unused harmony export isInternalFacebookBuild */
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/************************************************************************
 * This file is forked between different DevTools implementations.
 * It should never be imported directly!
 * It should always be imported from "react-devtools-feature-flags".
 ************************************************************************/
var consoleManagedByDevToolsDuringStrictMode = false;
var enableLogger = false;
var enableStyleXFeatures = false;
var isInternalFacebookBuild = false;
/************************************************************************
 * Do not edit the code below.
 * It ensures this fork exports the same types as the default flags file.
 ************************************************************************/

// Flow magic to verify the exports of this file match the original version.
null;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';
/** Used as references for various `Number` constants. */

var NAN = 0 / 0;
/** `Object#toString` result references. */

var symbolTag = '[object Symbol]';
/** Used to match leading and trailing whitespace. */

var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/** Detect free variable `global` from Node.js. */

var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */

var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
/** Used for built-in method references. */

var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var objectToString = objectProto.toString;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max,
    nativeMin = Math.min;
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */

var now = function now() {
  return root.Date.now();
};
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */


function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  wait = toNumber(wait) || 0;

  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time; // Start the timer for the trailing edge.

    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;
    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.

    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = now();

    if (shouldInvoke(time)) {
      return trailingEdge(time);
    } // Restart the timer.


    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.

    if (trailing && lastArgs) {
      return invokeFunc(time);
    }

    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }

    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }

      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }

    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }

    return result;
  }

  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */


function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */


function isObject(value) {
  var type = _typeof(value);

  return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */


function isObjectLike(value) {
  return !!value && _typeof(value) == 'object';
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */


function isSymbol(value) {
  return _typeof(value) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */


function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (isSymbol(value)) {
    return NAN;
  }

  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = throttle;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16)))

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ getInternalReactConstants; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ attach; });

// EXTERNAL MODULE: ../react-devtools-shared/src/types.js
var types = __webpack_require__(1);

// EXTERNAL MODULE: ../react-devtools-shared/src/utils.js
var utils = __webpack_require__(0);

// EXTERNAL MODULE: ../react-devtools-shared/src/storage.js
var storage = __webpack_require__(5);

// EXTERNAL MODULE: ../react-devtools-shared/src/backend/utils.js + 1 modules
var backend_utils = __webpack_require__(4);

// EXTERNAL MODULE: ../react-devtools-shared/src/constants.js
var constants = __webpack_require__(2);

// EXTERNAL MODULE: /Users/hoxy/repos/react/build/oss-experimental/react-debug-tools/index.js
var react_debug_tools = __webpack_require__(18);

// EXTERNAL MODULE: ../react-devtools-shared/src/backend/console.js
var backend_console = __webpack_require__(8);

// EXTERNAL MODULE: ../react-devtools-shared/src/backend/ReactSymbols.js
var ReactSymbols = __webpack_require__(3);

// EXTERNAL MODULE: ../react-devtools-shared/src/config/DevToolsFeatureFlags.core-oss.js
var DevToolsFeatureFlags_core_oss = __webpack_require__(11);

// CONCATENATED MODULE: ../shared/objectIs.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
  ;
}

var objectIs = // $FlowFixMe[method-unbinding]
typeof Object.is === 'function' ? Object.is : is;
/* harmony default export */ var shared_objectIs = (objectIs);
// CONCATENATED MODULE: ../shared/hasOwnProperty.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// $FlowFixMe[method-unbinding]
var hasOwnProperty_hasOwnProperty = Object.prototype.hasOwnProperty;
/* harmony default export */ var shared_hasOwnProperty = (hasOwnProperty_hasOwnProperty);
// EXTERNAL MODULE: ../react-devtools-shared/src/isArray.js
var isArray = __webpack_require__(6);

// CONCATENATED MODULE: ../react-devtools-shared/src/backend/StyleX/utils.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var cachedStyleNameToValueMap = new Map();
function getStyleXData(data) {
  var sources = new Set();
  var resolvedStyles = {};
  crawlData(data, sources, resolvedStyles);
  return {
    sources: Array.from(sources).sort(),
    resolvedStyles: resolvedStyles
  };
}
function crawlData(data, sources, resolvedStyles) {
  if (data == null) {
    return;
  }

  if (Object(isArray["a" /* default */])(data)) {
    data.forEach(function (entry) {
      if (entry == null) {
        return;
      }

      if (Object(isArray["a" /* default */])(entry)) {
        crawlData(entry, sources, resolvedStyles);
      } else {
        crawlObjectProperties(entry, sources, resolvedStyles);
      }
    });
  } else {
    crawlObjectProperties(data, sources, resolvedStyles);
  }

  resolvedStyles = Object.fromEntries(Object.entries(resolvedStyles).sort());
}

function crawlObjectProperties(entry, sources, resolvedStyles) {
  var keys = Object.keys(entry);
  keys.forEach(function (key) {
    var value = entry[key];

    if (typeof value === 'string') {
      if (key === value) {
        // Special case; this key is the name of the style's source/file/module.
        sources.add(key);
      } else {
        var propertyValue = getPropertyValueForStyleName(value);

        if (propertyValue != null) {
          resolvedStyles[key] = propertyValue;
        }
      }
    } else {
      var nestedStyle = {};
      resolvedStyles[key] = nestedStyle;
      crawlData([value], sources, nestedStyle);
    }
  });
}

function getPropertyValueForStyleName(styleName) {
  if (cachedStyleNameToValueMap.has(styleName)) {
    return cachedStyleNameToValueMap.get(styleName);
  }

  for (var styleSheetIndex = 0; styleSheetIndex < document.styleSheets.length; styleSheetIndex++) {
    var styleSheet = document.styleSheets[styleSheetIndex];
    var rules = null; // this might throw if CORS rules are enforced https://www.w3.org/TR/cssom-1/#the-cssstylesheet-interface

    try {
      rules = styleSheet.cssRules;
    } catch (_e) {
      continue;
    }

    for (var ruleIndex = 0; ruleIndex < rules.length; ruleIndex++) {
      if (!(rules[ruleIndex] instanceof CSSStyleRule)) {
        continue;
      }

      var rule = rules[ruleIndex];
      var cssText = rule.cssText,
          selectorText = rule.selectorText,
          style = rule.style;

      if (selectorText != null) {
        if (selectorText.startsWith(".".concat(styleName))) {
          var match = cssText.match(/{ *([a-z\-]+):/);

          if (match !== null) {
            var property = match[1];
            var value = style.getPropertyValue(property);
            cachedStyleNameToValueMap.set(styleName, value);
            return value;
          } else {
            return null;
          }
        }
      }
    }
  }

  return null;
}
// EXTERNAL MODULE: ../shared/isArray.js
var shared_isArray = __webpack_require__(9);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/constants.js
var CHANGE_LOG_URL = 'https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md';
var UNSUPPORTED_VERSION_URL = 'https://reactjs.org/blog/2019/08/15/new-react-devtools.html#how-do-i-get-the-old-version-back';
var REACT_DEVTOOLS_WORKPLACE_URL = 'https://fburl.com/react-devtools-workplace-group';
var THEME_STYLES = {
  light: {
    '--color-attribute-name': '#ef6632',
    '--color-attribute-name-not-editable': '#23272f',
    '--color-attribute-name-inverted': 'rgba(255, 255, 255, 0.7)',
    '--color-attribute-value': '#1a1aa6',
    '--color-attribute-value-inverted': '#ffffff',
    '--color-attribute-editable-value': '#1a1aa6',
    '--color-background': '#ffffff',
    '--color-background-hover': 'rgba(0, 136, 250, 0.1)',
    '--color-background-inactive': '#e5e5e5',
    '--color-background-invalid': '#fff0f0',
    '--color-background-selected': '#0088fa',
    '--color-button-background': '#ffffff',
    '--color-button-background-focus': '#ededed',
    '--color-button': '#5f6673',
    '--color-button-disabled': '#cfd1d5',
    '--color-button-active': '#0088fa',
    '--color-button-focus': '#23272f',
    '--color-button-hover': '#23272f',
    '--color-border': '#eeeeee',
    '--color-commit-did-not-render-fill': '#cfd1d5',
    '--color-commit-did-not-render-fill-text': '#000000',
    '--color-commit-did-not-render-pattern': '#cfd1d5',
    '--color-commit-did-not-render-pattern-text': '#333333',
    '--color-commit-gradient-0': '#37afa9',
    '--color-commit-gradient-1': '#63b19e',
    '--color-commit-gradient-2': '#80b393',
    '--color-commit-gradient-3': '#97b488',
    '--color-commit-gradient-4': '#abb67d',
    '--color-commit-gradient-5': '#beb771',
    '--color-commit-gradient-6': '#cfb965',
    '--color-commit-gradient-7': '#dfba57',
    '--color-commit-gradient-8': '#efbb49',
    '--color-commit-gradient-9': '#febc38',
    '--color-commit-gradient-text': '#000000',
    '--color-component-name': '#6a51b2',
    '--color-component-name-inverted': '#ffffff',
    '--color-component-badge-background': 'rgba(0, 0, 0, 0.1)',
    '--color-component-badge-background-inverted': 'rgba(255, 255, 255, 0.25)',
    '--color-component-badge-count': '#777d88',
    '--color-component-badge-count-inverted': 'rgba(255, 255, 255, 0.7)',
    '--color-console-error-badge-text': '#ffffff',
    '--color-console-error-background': '#fff0f0',
    '--color-console-error-border': '#ffd6d6',
    '--color-console-error-icon': '#eb3941',
    '--color-console-error-text': '#fe2e31',
    '--color-console-warning-badge-text': '#000000',
    '--color-console-warning-background': '#fffbe5',
    '--color-console-warning-border': '#fff5c1',
    '--color-console-warning-icon': '#f4bd00',
    '--color-console-warning-text': '#64460c',
    '--color-context-background': 'rgba(0,0,0,.9)',
    '--color-context-background-hover': 'rgba(255, 255, 255, 0.1)',
    '--color-context-background-selected': '#178fb9',
    '--color-context-border': '#3d424a',
    '--color-context-text': '#ffffff',
    '--color-context-text-selected': '#ffffff',
    '--color-dim': '#777d88',
    '--color-dimmer': '#cfd1d5',
    '--color-dimmest': '#eff0f1',
    '--color-error-background': 'hsl(0, 100%, 97%)',
    '--color-error-border': 'hsl(0, 100%, 92%)',
    '--color-error-text': '#ff0000',
    '--color-expand-collapse-toggle': '#777d88',
    '--color-link': '#0000ff',
    '--color-modal-background': 'rgba(255, 255, 255, 0.75)',
    '--color-bridge-version-npm-background': '#eff0f1',
    '--color-bridge-version-npm-text': '#000000',
    '--color-bridge-version-number': '#0088fa',
    '--color-primitive-hook-badge-background': '#e5e5e5',
    '--color-primitive-hook-badge-text': '#5f6673',
    '--color-record-active': '#fc3a4b',
    '--color-record-hover': '#3578e5',
    '--color-record-inactive': '#0088fa',
    '--color-resize-bar': '#eeeeee',
    '--color-resize-bar-active': '#dcdcdc',
    '--color-resize-bar-border': '#d1d1d1',
    '--color-resize-bar-dot': '#333333',
    '--color-timeline-internal-module': '#d1d1d1',
    '--color-timeline-internal-module-hover': '#c9c9c9',
    '--color-timeline-internal-module-text': '#444',
    '--color-timeline-native-event': '#ccc',
    '--color-timeline-native-event-hover': '#aaa',
    '--color-timeline-network-primary': '#fcf3dc',
    '--color-timeline-network-primary-hover': '#f0e7d1',
    '--color-timeline-network-secondary': '#efc457',
    '--color-timeline-network-secondary-hover': '#e3ba52',
    '--color-timeline-priority-background': '#f6f6f6',
    '--color-timeline-priority-border': '#eeeeee',
    '--color-timeline-user-timing': '#c9cacd',
    '--color-timeline-user-timing-hover': '#93959a',
    '--color-timeline-react-idle': '#d3e5f6',
    '--color-timeline-react-idle-hover': '#c3d9ef',
    '--color-timeline-react-render': '#9fc3f3',
    '--color-timeline-react-render-hover': '#83afe9',
    '--color-timeline-react-render-text': '#11365e',
    '--color-timeline-react-commit': '#c88ff0',
    '--color-timeline-react-commit-hover': '#b281d6',
    '--color-timeline-react-commit-text': '#3e2c4a',
    '--color-timeline-react-layout-effects': '#b281d6',
    '--color-timeline-react-layout-effects-hover': '#9d71bd',
    '--color-timeline-react-layout-effects-text': '#3e2c4a',
    '--color-timeline-react-passive-effects': '#b281d6',
    '--color-timeline-react-passive-effects-hover': '#9d71bd',
    '--color-timeline-react-passive-effects-text': '#3e2c4a',
    '--color-timeline-react-schedule': '#9fc3f3',
    '--color-timeline-react-schedule-hover': '#2683E2',
    '--color-timeline-react-suspense-rejected': '#f1cc14',
    '--color-timeline-react-suspense-rejected-hover': '#ffdf37',
    '--color-timeline-react-suspense-resolved': '#a6e59f',
    '--color-timeline-react-suspense-resolved-hover': '#89d281',
    '--color-timeline-react-suspense-unresolved': '#c9cacd',
    '--color-timeline-react-suspense-unresolved-hover': '#93959a',
    '--color-timeline-thrown-error': '#ee1638',
    '--color-timeline-thrown-error-hover': '#da1030',
    '--color-timeline-text-color': '#000000',
    '--color-timeline-text-dim-color': '#ccc',
    '--color-timeline-react-work-border': '#eeeeee',
    '--color-search-match': 'yellow',
    '--color-search-match-current': '#f7923b',
    '--color-selected-tree-highlight-active': 'rgba(0, 136, 250, 0.1)',
    '--color-selected-tree-highlight-inactive': 'rgba(0, 0, 0, 0.05)',
    '--color-scroll-caret': 'rgba(150, 150, 150, 0.5)',
    '--color-tab-selected-border': '#0088fa',
    '--color-text': '#000000',
    '--color-text-invalid': '#ff0000',
    '--color-text-selected': '#ffffff',
    '--color-toggle-background-invalid': '#fc3a4b',
    '--color-toggle-background-on': '#0088fa',
    '--color-toggle-background-off': '#cfd1d5',
    '--color-toggle-text': '#ffffff',
    '--color-warning-background': '#fb3655',
    '--color-warning-background-hover': '#f82042',
    '--color-warning-text-color': '#ffffff',
    '--color-warning-text-color-inverted': '#fd4d69',
    // The styles below should be kept in sync with 'root.css'
    // They are repeated there because they're used by e.g. tooltips or context menus
    // which get rendered outside of the DOM subtree (where normal theme/styles are written).
    '--color-scroll-thumb': '#c2c2c2',
    '--color-scroll-track': '#fafafa',
    '--color-tooltip-background': 'rgba(0, 0, 0, 0.9)',
    '--color-tooltip-text': '#ffffff'
  },
  dark: {
    '--color-attribute-name': '#9d87d2',
    '--color-attribute-name-not-editable': '#ededed',
    '--color-attribute-name-inverted': '#282828',
    '--color-attribute-value': '#cedae0',
    '--color-attribute-value-inverted': '#ffffff',
    '--color-attribute-editable-value': 'yellow',
    '--color-background': '#282c34',
    '--color-background-hover': 'rgba(255, 255, 255, 0.1)',
    '--color-background-inactive': '#3d424a',
    '--color-background-invalid': '#5c0000',
    '--color-background-selected': '#178fb9',
    '--color-button-background': '#282c34',
    '--color-button-background-focus': '#3d424a',
    '--color-button': '#afb3b9',
    '--color-button-active': '#61dafb',
    '--color-button-disabled': '#4f5766',
    '--color-button-focus': '#a2e9fc',
    '--color-button-hover': '#ededed',
    '--color-border': '#3d424a',
    '--color-commit-did-not-render-fill': '#777d88',
    '--color-commit-did-not-render-fill-text': '#000000',
    '--color-commit-did-not-render-pattern': '#666c77',
    '--color-commit-did-not-render-pattern-text': '#ffffff',
    '--color-commit-gradient-0': '#37afa9',
    '--color-commit-gradient-1': '#63b19e',
    '--color-commit-gradient-2': '#80b393',
    '--color-commit-gradient-3': '#97b488',
    '--color-commit-gradient-4': '#abb67d',
    '--color-commit-gradient-5': '#beb771',
    '--color-commit-gradient-6': '#cfb965',
    '--color-commit-gradient-7': '#dfba57',
    '--color-commit-gradient-8': '#efbb49',
    '--color-commit-gradient-9': '#febc38',
    '--color-commit-gradient-text': '#000000',
    '--color-component-name': '#61dafb',
    '--color-component-name-inverted': '#282828',
    '--color-component-badge-background': 'rgba(255, 255, 255, 0.25)',
    '--color-component-badge-background-inverted': 'rgba(0, 0, 0, 0.25)',
    '--color-component-badge-count': '#8f949d',
    '--color-component-badge-count-inverted': 'rgba(255, 255, 255, 0.7)',
    '--color-console-error-badge-text': '#000000',
    '--color-console-error-background': '#290000',
    '--color-console-error-border': '#5c0000',
    '--color-console-error-icon': '#eb3941',
    '--color-console-error-text': '#fc7f7f',
    '--color-console-warning-badge-text': '#000000',
    '--color-console-warning-background': '#332b00',
    '--color-console-warning-border': '#665500',
    '--color-console-warning-icon': '#f4bd00',
    '--color-console-warning-text': '#f5f2ed',
    '--color-context-background': 'rgba(255,255,255,.95)',
    '--color-context-background-hover': 'rgba(0, 136, 250, 0.1)',
    '--color-context-background-selected': '#0088fa',
    '--color-context-border': '#eeeeee',
    '--color-context-text': '#000000',
    '--color-context-text-selected': '#ffffff',
    '--color-dim': '#8f949d',
    '--color-dimmer': '#777d88',
    '--color-dimmest': '#4f5766',
    '--color-error-background': '#200',
    '--color-error-border': '#900',
    '--color-error-text': '#f55',
    '--color-expand-collapse-toggle': '#8f949d',
    '--color-link': '#61dafb',
    '--color-modal-background': 'rgba(0, 0, 0, 0.75)',
    '--color-bridge-version-npm-background': 'rgba(0, 0, 0, 0.25)',
    '--color-bridge-version-npm-text': '#ffffff',
    '--color-bridge-version-number': 'yellow',
    '--color-primitive-hook-badge-background': 'rgba(0, 0, 0, 0.25)',
    '--color-primitive-hook-badge-text': 'rgba(255, 255, 255, 0.7)',
    '--color-record-active': '#fc3a4b',
    '--color-record-hover': '#a2e9fc',
    '--color-record-inactive': '#61dafb',
    '--color-resize-bar': '#282c34',
    '--color-resize-bar-active': '#31363f',
    '--color-resize-bar-border': '#3d424a',
    '--color-resize-bar-dot': '#cfd1d5',
    '--color-timeline-internal-module': '#303542',
    '--color-timeline-internal-module-hover': '#363b4a',
    '--color-timeline-internal-module-text': '#7f8899',
    '--color-timeline-native-event': '#b2b2b2',
    '--color-timeline-native-event-hover': '#949494',
    '--color-timeline-network-primary': '#fcf3dc',
    '--color-timeline-network-primary-hover': '#e3dbc5',
    '--color-timeline-network-secondary': '#efc457',
    '--color-timeline-network-secondary-hover': '#d6af4d',
    '--color-timeline-priority-background': '#1d2129',
    '--color-timeline-priority-border': '#282c34',
    '--color-timeline-user-timing': '#c9cacd',
    '--color-timeline-user-timing-hover': '#93959a',
    '--color-timeline-react-idle': '#3d485b',
    '--color-timeline-react-idle-hover': '#465269',
    '--color-timeline-react-render': '#2683E2',
    '--color-timeline-react-render-hover': '#1a76d4',
    '--color-timeline-react-render-text': '#11365e',
    '--color-timeline-react-commit': '#731fad',
    '--color-timeline-react-commit-hover': '#611b94',
    '--color-timeline-react-commit-text': '#e5c1ff',
    '--color-timeline-react-layout-effects': '#611b94',
    '--color-timeline-react-layout-effects-hover': '#51167a',
    '--color-timeline-react-layout-effects-text': '#e5c1ff',
    '--color-timeline-react-passive-effects': '#611b94',
    '--color-timeline-react-passive-effects-hover': '#51167a',
    '--color-timeline-react-passive-effects-text': '#e5c1ff',
    '--color-timeline-react-schedule': '#2683E2',
    '--color-timeline-react-schedule-hover': '#1a76d4',
    '--color-timeline-react-suspense-rejected': '#f1cc14',
    '--color-timeline-react-suspense-rejected-hover': '#e4c00f',
    '--color-timeline-react-suspense-resolved': '#a6e59f',
    '--color-timeline-react-suspense-resolved-hover': '#89d281',
    '--color-timeline-react-suspense-unresolved': '#c9cacd',
    '--color-timeline-react-suspense-unresolved-hover': '#93959a',
    '--color-timeline-thrown-error': '#fb3655',
    '--color-timeline-thrown-error-hover': '#f82042',
    '--color-timeline-text-color': '#282c34',
    '--color-timeline-text-dim-color': '#555b66',
    '--color-timeline-react-work-border': '#3d424a',
    '--color-search-match': 'yellow',
    '--color-search-match-current': '#f7923b',
    '--color-selected-tree-highlight-active': 'rgba(23, 143, 185, 0.15)',
    '--color-selected-tree-highlight-inactive': 'rgba(255, 255, 255, 0.05)',
    '--color-scroll-caret': '#4f5766',
    '--color-shadow': 'rgba(0, 0, 0, 0.5)',
    '--color-tab-selected-border': '#178fb9',
    '--color-text': '#ffffff',
    '--color-text-invalid': '#ff8080',
    '--color-text-selected': '#ffffff',
    '--color-toggle-background-invalid': '#fc3a4b',
    '--color-toggle-background-on': '#178fb9',
    '--color-toggle-background-off': '#777d88',
    '--color-toggle-text': '#ffffff',
    '--color-warning-background': '#ee1638',
    '--color-warning-background-hover': '#da1030',
    '--color-warning-text-color': '#ffffff',
    '--color-warning-text-color-inverted': '#ee1638',
    // The styles below should be kept in sync with 'root.css'
    // They are repeated there because they're used by e.g. tooltips or context menus
    // which get rendered outside of the DOM subtree (where normal theme/styles are written).
    '--color-scroll-thumb': '#afb3b9',
    '--color-scroll-track': '#313640',
    '--color-tooltip-background': 'rgba(255, 255, 255, 0.95)',
    '--color-tooltip-text': '#000000'
  },
  compact: {
    '--font-size-monospace-small': '9px',
    '--font-size-monospace-normal': '11px',
    '--font-size-monospace-large': '15px',
    '--font-size-sans-small': '10px',
    '--font-size-sans-normal': '12px',
    '--font-size-sans-large': '14px',
    '--line-height-data': '18px'
  },
  comfortable: {
    '--font-size-monospace-small': '10px',
    '--font-size-monospace-normal': '13px',
    '--font-size-monospace-large': '17px',
    '--font-size-sans-small': '12px',
    '--font-size-sans-normal': '14px',
    '--font-size-sans-large': '16px',
    '--line-height-data': '22px'
  }
}; // HACK
//
// Sometimes the inline target is rendered before root styles are applied,
// which would result in e.g. NaN itemSize being passed to react-window list.

var COMFORTABLE_LINE_HEIGHT = parseInt(THEME_STYLES.comfortable['--line-height-data'], 10);
var COMPACT_LINE_HEIGHT = parseInt(THEME_STYLES.compact['--line-height-data'], 10);

// CONCATENATED MODULE: ../react-devtools-timeline/src/constants.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var REACT_TOTAL_NUM_LANES = 31; // Increment this number any time a backwards breaking change is made to the profiler metadata.

var SCHEDULING_PROFILER_VERSION = 1;
var SNAPSHOT_MAX_HEIGHT = 60;
// EXTERNAL MODULE: ../react-devtools-shared/src/backend/DevToolsFiberComponentStack.js + 2 modules
var DevToolsFiberComponentStack = __webpack_require__(14);

// CONCATENATED MODULE: ../react-devtools-shared/src/backend/profilingHooks.js
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


 // Add padding to the start/stop time of the profile.
// This makes the UI nicer to use.

var TIME_OFFSET = 10;
var performanceTarget = null; // If performance exists and supports the subset of the User Timing API that we require.

var supportsUserTiming = typeof performance !== 'undefined' && // $FlowFixMe[method-unbinding]
typeof performance.mark === 'function' && // $FlowFixMe[method-unbinding]
typeof performance.clearMarks === 'function';
var supportsUserTimingV3 = false;

if (supportsUserTiming) {
  var CHECK_V3_MARK = '__v3';
  var markOptions = {};
  Object.defineProperty(markOptions, 'startTime', {
    get: function get() {
      supportsUserTimingV3 = true;
      return 0;
    },
    set: function set() {}
  });

  try {
    // $FlowFixMe[extra-arg]: Flow expects the User Timing level 2 API.
    performance.mark(CHECK_V3_MARK, markOptions);
  } catch (error) {// Ignore
  } finally {
    performance.clearMarks(CHECK_V3_MARK);
  }
}

if (supportsUserTimingV3) {
  performanceTarget = performance;
} // Some environments (e.g. React Native / Hermes) don't support the performance API yet.


var getCurrentTime = // $FlowFixMe[method-unbinding]
(typeof performance === "undefined" ? "undefined" : _typeof(performance)) === 'object' && typeof performance.now === 'function' ? function () {
  return performance.now();
} : function () {
  return Date.now();
}; // Mocking the Performance Object (and User Timing APIs) for testing is fragile.
// This API allows tests to directly override the User Timing APIs.

function setPerformanceMock_ONLY_FOR_TESTING(performanceMock) {
  performanceTarget = performanceMock;
  supportsUserTiming = performanceMock !== null;
  supportsUserTimingV3 = performanceMock !== null;
}
function createProfilingHooks(_ref) {
  var getDisplayNameForFiber = _ref.getDisplayNameForFiber,
      getIsProfiling = _ref.getIsProfiling,
      getLaneLabelMap = _ref.getLaneLabelMap,
      workTagMap = _ref.workTagMap,
      currentDispatcherRef = _ref.currentDispatcherRef,
      reactVersion = _ref.reactVersion;
  var currentBatchUID = 0;
  var currentReactComponentMeasure = null;
  var currentReactMeasuresStack = [];
  var currentTimelineData = null;
  var currentFiberStacks = new Map();
  var isProfiling = false;
  var nextRenderShouldStartNewBatch = false;

  function getRelativeTime() {
    var currentTime = getCurrentTime();

    if (currentTimelineData) {
      if (currentTimelineData.startTime === 0) {
        currentTimelineData.startTime = currentTime - TIME_OFFSET;
      }

      return currentTime - currentTimelineData.startTime;
    }

    return 0;
  }

  function getInternalModuleRanges() {
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.getInternalModuleRanges === 'function') {
      // Ask the DevTools hook for module ranges that may have been reported by the current renderer(s).
      // Don't do this eagerly like the laneToLabelMap,
      // because some modules might not yet have registered their boundaries when the renderer is injected.
      var ranges = __REACT_DEVTOOLS_GLOBAL_HOOK__.getInternalModuleRanges(); // This check would not be required,
      // except that it's possible for things to override __REACT_DEVTOOLS_GLOBAL_HOOK__.


      if (Object(shared_isArray["a" /* default */])(ranges)) {
        return ranges;
      }
    }

    return null;
  }

  function getTimelineData() {
    return currentTimelineData;
  }

  function laneToLanesArray(lanes) {
    var lanesArray = [];
    var lane = 1;

    for (var index = 0; index < REACT_TOTAL_NUM_LANES; index++) {
      if (lane & lanes) {
        lanesArray.push(lane);
      }

      lane *= 2;
    }

    return lanesArray;
  }

  var laneToLabelMap = typeof getLaneLabelMap === 'function' ? getLaneLabelMap() : null;

  function markMetadata() {
    markAndClear("--react-version-".concat(reactVersion));
    markAndClear("--profiler-version-".concat(SCHEDULING_PROFILER_VERSION));
    var ranges = getInternalModuleRanges();

    if (ranges) {
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];

        if (Object(shared_isArray["a" /* default */])(range) && range.length === 2) {
          var _ranges$i = _slicedToArray(ranges[i], 2),
              startStackFrame = _ranges$i[0],
              stopStackFrame = _ranges$i[1];

          markAndClear("--react-internal-module-start-".concat(startStackFrame));
          markAndClear("--react-internal-module-stop-".concat(stopStackFrame));
        }
      }
    }

    if (laneToLabelMap != null) {
      var labels = Array.from(laneToLabelMap.values()).join(',');
      markAndClear("--react-lane-labels-".concat(labels));
    }
  }

  function markAndClear(markName) {
    // This method won't be called unless these functions are defined, so we can skip the extra typeof check.
    performanceTarget.mark(markName);
    performanceTarget.clearMarks(markName);
  }

  function recordReactMeasureStarted(type, lanes) {
    // Decide what depth thi work should be rendered at, based on what's on the top of the stack.
    // It's okay to render over top of "idle" work but everything else should be on its own row.
    var depth = 0;

    if (currentReactMeasuresStack.length > 0) {
      var top = currentReactMeasuresStack[currentReactMeasuresStack.length - 1];
      depth = top.type === 'render-idle' ? top.depth : top.depth + 1;
    }

    var lanesArray = laneToLanesArray(lanes);
    var reactMeasure = {
      type: type,
      batchUID: currentBatchUID,
      depth: depth,
      lanes: lanesArray,
      timestamp: getRelativeTime(),
      duration: 0
    };
    currentReactMeasuresStack.push(reactMeasure);

    if (currentTimelineData) {
      var _currentTimelineData = currentTimelineData,
          batchUIDToMeasuresMap = _currentTimelineData.batchUIDToMeasuresMap,
          laneToReactMeasureMap = _currentTimelineData.laneToReactMeasureMap;
      var reactMeasures = batchUIDToMeasuresMap.get(currentBatchUID);

      if (reactMeasures != null) {
        reactMeasures.push(reactMeasure);
      } else {
        batchUIDToMeasuresMap.set(currentBatchUID, [reactMeasure]);
      }

      lanesArray.forEach(function (lane) {
        reactMeasures = laneToReactMeasureMap.get(lane);

        if (reactMeasures) {
          reactMeasures.push(reactMeasure);
        }
      });
    }
  }

  function recordReactMeasureCompleted(type) {
    var currentTime = getRelativeTime();

    if (currentReactMeasuresStack.length === 0) {
      console.error('Unexpected type "%s" completed at %sms while currentReactMeasuresStack is empty.', type, currentTime); // Ignore work "completion" user timing mark that doesn't complete anything

      return;
    }

    var top = currentReactMeasuresStack.pop();

    if (top.type !== type) {
      console.error('Unexpected type "%s" completed at %sms before "%s" completed.', type, currentTime, top.type);
    } // $FlowFixMe[cannot-write] This property should not be writable outside of this function.


    top.duration = currentTime - top.timestamp;

    if (currentTimelineData) {
      currentTimelineData.duration = getRelativeTime() + TIME_OFFSET;
    }
  }

  function markCommitStarted(lanes) {
    if (isProfiling) {
      recordReactMeasureStarted('commit', lanes); // TODO (timeline) Re-think this approach to "batching"; I don't think it works for Suspense or pre-rendering.
      // This issue applies to the User Timing data also.

      nextRenderShouldStartNewBatch = true;
    }

    if (supportsUserTimingV3) {
      markAndClear("--commit-start-".concat(lanes)); // Some metadata only needs to be logged once per session,
      // but if profiling information is being recorded via the Performance tab,
      // DevTools has no way of knowing when the recording starts.
      // Because of that, we log thie type of data periodically (once per commit).

      markMetadata();
    }
  }

  function markCommitStopped() {
    if (isProfiling) {
      recordReactMeasureCompleted('commit');
      recordReactMeasureCompleted('render-idle');
    }

    if (supportsUserTimingV3) {
      markAndClear('--commit-stop');
    }
  }

  function markComponentRenderStarted(fiber) {
    if (isProfiling || supportsUserTimingV3) {
      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';

      if (isProfiling) {
        // TODO (timeline) Record and cache component stack
        if (isProfiling) {
          currentReactComponentMeasure = {
            componentName: componentName,
            duration: 0,
            timestamp: getRelativeTime(),
            type: 'render',
            warning: null
          };
        }
      }

      if (supportsUserTimingV3) {
        markAndClear("--component-render-start-".concat(componentName));
      }
    }
  }

  function markComponentRenderStopped() {
    if (isProfiling) {
      if (currentReactComponentMeasure) {
        if (currentTimelineData) {
          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);
        } // $FlowFixMe[incompatible-use] found when upgrading Flow


        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow
        getRelativeTime() - currentReactComponentMeasure.timestamp;
        currentReactComponentMeasure = null;
      }
    }

    if (supportsUserTimingV3) {
      markAndClear('--component-render-stop');
    }
  }

  function markComponentLayoutEffectMountStarted(fiber) {
    if (isProfiling || supportsUserTimingV3) {
      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';

      if (isProfiling) {
        // TODO (timeline) Record and cache component stack
        if (isProfiling) {
          currentReactComponentMeasure = {
            componentName: componentName,
            duration: 0,
            timestamp: getRelativeTime(),
            type: 'layout-effect-mount',
            warning: null
          };
        }
      }

      if (supportsUserTimingV3) {
        markAndClear("--component-layout-effect-mount-start-".concat(componentName));
      }
    }
  }

  function markComponentLayoutEffectMountStopped() {
    if (isProfiling) {
      if (currentReactComponentMeasure) {
        if (currentTimelineData) {
          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);
        } // $FlowFixMe[incompatible-use] found when upgrading Flow


        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow
        getRelativeTime() - currentReactComponentMeasure.timestamp;
        currentReactComponentMeasure = null;
      }
    }

    if (supportsUserTimingV3) {
      markAndClear('--component-layout-effect-mount-stop');
    }
  }

  function markComponentLayoutEffectUnmountStarted(fiber) {
    if (isProfiling || supportsUserTimingV3) {
      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';

      if (isProfiling) {
        // TODO (timeline) Record and cache component stack
        if (isProfiling) {
          currentReactComponentMeasure = {
            componentName: componentName,
            duration: 0,
            timestamp: getRelativeTime(),
            type: 'layout-effect-unmount',
            warning: null
          };
        }
      }

      if (supportsUserTimingV3) {
        markAndClear("--component-layout-effect-unmount-start-".concat(componentName));
      }
    }
  }

  function markComponentLayoutEffectUnmountStopped() {
    if (isProfiling) {
      if (currentReactComponentMeasure) {
        if (currentTimelineData) {
          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);
        } // $FlowFixMe[incompatible-use] found when upgrading Flow


        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow
        getRelativeTime() - currentReactComponentMeasure.timestamp;
        currentReactComponentMeasure = null;
      }
    }

    if (supportsUserTimingV3) {
      markAndClear('--component-layout-effect-unmount-stop');
    }
  }

  function markComponentPassiveEffectMountStarted(fiber) {
    if (isProfiling || supportsUserTimingV3) {
      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';

      if (isProfiling) {
        // TODO (timeline) Record and cache component stack
        if (isProfiling) {
          currentReactComponentMeasure = {
            componentName: componentName,
            duration: 0,
            timestamp: getRelativeTime(),
            type: 'passive-effect-mount',
            warning: null
          };
        }
      }

      if (supportsUserTimingV3) {
        markAndClear("--component-passive-effect-mount-start-".concat(componentName));
      }
    }
  }

  function markComponentPassiveEffectMountStopped() {
    if (isProfiling) {
      if (currentReactComponentMeasure) {
        if (currentTimelineData) {
          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);
        } // $FlowFixMe[incompatible-use] found when upgrading Flow


        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow
        getRelativeTime() - currentReactComponentMeasure.timestamp;
        currentReactComponentMeasure = null;
      }
    }

    if (supportsUserTimingV3) {
      markAndClear('--component-passive-effect-mount-stop');
    }
  }

  function markComponentPassiveEffectUnmountStarted(fiber) {
    if (isProfiling || supportsUserTimingV3) {
      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';

      if (isProfiling) {
        // TODO (timeline) Record and cache component stack
        if (isProfiling) {
          currentReactComponentMeasure = {
            componentName: componentName,
            duration: 0,
            timestamp: getRelativeTime(),
            type: 'passive-effect-unmount',
            warning: null
          };
        }
      }

      if (supportsUserTimingV3) {
        markAndClear("--component-passive-effect-unmount-start-".concat(componentName));
      }
    }
  }

  function markComponentPassiveEffectUnmountStopped() {
    if (isProfiling) {
      if (currentReactComponentMeasure) {
        if (currentTimelineData) {
          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);
        } // $FlowFixMe[incompatible-use] found when upgrading Flow


        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow
        getRelativeTime() - currentReactComponentMeasure.timestamp;
        currentReactComponentMeasure = null;
      }
    }

    if (supportsUserTimingV3) {
      markAndClear('--component-passive-effect-unmount-stop');
    }
  }

  function markComponentErrored(fiber, thrownValue, lanes) {
    if (isProfiling || supportsUserTimingV3) {
      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';
      var phase = fiber.alternate === null ? 'mount' : 'update';
      var message = '';

      if (thrownValue !== null && _typeof(thrownValue) === 'object' && typeof thrownValue.message === 'string') {
        message = thrownValue.message;
      } else if (typeof thrownValue === 'string') {
        message = thrownValue;
      }

      if (isProfiling) {
        // TODO (timeline) Record and cache component stack
        if (currentTimelineData) {
          currentTimelineData.thrownErrors.push({
            componentName: componentName,
            message: message,
            phase: phase,
            timestamp: getRelativeTime(),
            type: 'thrown-error'
          });
        }
      }

      if (supportsUserTimingV3) {
        markAndClear("--error-".concat(componentName, "-").concat(phase, "-").concat(message));
      }
    }
  }

  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // $FlowFixMe[incompatible-type]: Flow cannot handle polymorphic WeakMaps

  var wakeableIDs = new PossiblyWeakMap();
  var wakeableID = 0;

  function getWakeableID(wakeable) {
    if (!wakeableIDs.has(wakeable)) {
      wakeableIDs.set(wakeable, wakeableID++);
    }

    return wakeableIDs.get(wakeable);
  }

  function markComponentSuspended(fiber, wakeable, lanes) {
    if (isProfiling || supportsUserTimingV3) {
      var eventType = wakeableIDs.has(wakeable) ? 'resuspend' : 'suspend';
      var id = getWakeableID(wakeable);
      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';
      var phase = fiber.alternate === null ? 'mount' : 'update'; // Following the non-standard fn.displayName convention,
      // frameworks like Relay may also annotate Promises with a displayName,
      // describing what operation/data the thrown Promise is related to.
      // When this is available we should pass it along to the Timeline.

      var displayName = wakeable.displayName || '';
      var suspenseEvent = null;

      if (isProfiling) {
        // TODO (timeline) Record and cache component stack
        suspenseEvent = {
          componentName: componentName,
          depth: 0,
          duration: 0,
          id: "".concat(id),
          phase: phase,
          promiseName: displayName,
          resolution: 'unresolved',
          timestamp: getRelativeTime(),
          type: 'suspense',
          warning: null
        };

        if (currentTimelineData) {
          currentTimelineData.suspenseEvents.push(suspenseEvent);
        }
      }

      if (supportsUserTimingV3) {
        markAndClear("--suspense-".concat(eventType, "-").concat(id, "-").concat(componentName, "-").concat(phase, "-").concat(lanes, "-").concat(displayName));
      }

      wakeable.then(function () {
        if (suspenseEvent) {
          suspenseEvent.duration = getRelativeTime() - suspenseEvent.timestamp;
          suspenseEvent.resolution = 'resolved';
        }

        if (supportsUserTimingV3) {
          markAndClear("--suspense-resolved-".concat(id, "-").concat(componentName));
        }
      }, function () {
        if (suspenseEvent) {
          suspenseEvent.duration = getRelativeTime() - suspenseEvent.timestamp;
          suspenseEvent.resolution = 'rejected';
        }

        if (supportsUserTimingV3) {
          markAndClear("--suspense-rejected-".concat(id, "-").concat(componentName));
        }
      });
    }
  }

  function markLayoutEffectsStarted(lanes) {
    if (isProfiling) {
      recordReactMeasureStarted('layout-effects', lanes);
    }

    if (supportsUserTimingV3) {
      markAndClear("--layout-effects-start-".concat(lanes));
    }
  }

  function markLayoutEffectsStopped() {
    if (isProfiling) {
      recordReactMeasureCompleted('layout-effects');
    }

    if (supportsUserTimingV3) {
      markAndClear('--layout-effects-stop');
    }
  }

  function markPassiveEffectsStarted(lanes) {
    if (isProfiling) {
      recordReactMeasureStarted('passive-effects', lanes);
    }

    if (supportsUserTimingV3) {
      markAndClear("--passive-effects-start-".concat(lanes));
    }
  }

  function markPassiveEffectsStopped() {
    if (isProfiling) {
      recordReactMeasureCompleted('passive-effects');
    }

    if (supportsUserTimingV3) {
      markAndClear('--passive-effects-stop');
    }
  }

  function markRenderStarted(lanes) {
    if (isProfiling) {
      if (nextRenderShouldStartNewBatch) {
        nextRenderShouldStartNewBatch = false;
        currentBatchUID++;
      } // If this is a new batch of work, wrap an "idle" measure around it.
      // Log it before the "render" measure to preserve the stack ordering.


      if (currentReactMeasuresStack.length === 0 || currentReactMeasuresStack[currentReactMeasuresStack.length - 1].type !== 'render-idle') {
        recordReactMeasureStarted('render-idle', lanes);
      }

      recordReactMeasureStarted('render', lanes);
    }

    if (supportsUserTimingV3) {
      markAndClear("--render-start-".concat(lanes));
    }
  }

  function markRenderYielded() {
    if (isProfiling) {
      recordReactMeasureCompleted('render');
    }

    if (supportsUserTimingV3) {
      markAndClear('--render-yield');
    }
  }

  function markRenderStopped() {
    if (isProfiling) {
      recordReactMeasureCompleted('render');
    }

    if (supportsUserTimingV3) {
      markAndClear('--render-stop');
    }
  }

  function markRenderScheduled(lane) {
    if (isProfiling) {
      if (currentTimelineData) {
        currentTimelineData.schedulingEvents.push({
          lanes: laneToLanesArray(lane),
          timestamp: getRelativeTime(),
          type: 'schedule-render',
          warning: null
        });
      }
    }

    if (supportsUserTimingV3) {
      markAndClear("--schedule-render-".concat(lane));
    }
  }

  function markForceUpdateScheduled(fiber, lane) {
    if (isProfiling || supportsUserTimingV3) {
      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';

      if (isProfiling) {
        // TODO (timeline) Record and cache component stack
        if (currentTimelineData) {
          currentTimelineData.schedulingEvents.push({
            componentName: componentName,
            lanes: laneToLanesArray(lane),
            timestamp: getRelativeTime(),
            type: 'schedule-force-update',
            warning: null
          });
        }
      }

      if (supportsUserTimingV3) {
        markAndClear("--schedule-forced-update-".concat(lane, "-").concat(componentName));
      }
    }
  }

  function getParentFibers(fiber) {
    var parents = [];
    var parent = fiber;

    while (parent !== null) {
      parents.push(parent);
      parent = parent.return;
    }

    return parents;
  }

  function markStateUpdateScheduled(fiber, lane) {
    if (isProfiling || supportsUserTimingV3) {
      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';

      if (isProfiling) {
        // TODO (timeline) Record and cache component stack
        if (currentTimelineData) {
          var event = {
            componentName: componentName,
            // Store the parent fibers so we can post process
            // them after we finish profiling
            lanes: laneToLanesArray(lane),
            timestamp: getRelativeTime(),
            type: 'schedule-state-update',
            warning: null
          };
          currentFiberStacks.set(event, getParentFibers(fiber)); // $FlowFixMe[incompatible-use] found when upgrading Flow

          currentTimelineData.schedulingEvents.push(event);
        }
      }

      if (supportsUserTimingV3) {
        markAndClear("--schedule-state-update-".concat(lane, "-").concat(componentName));
      }
    }
  }

  function toggleProfilingStatus(value) {
    if (isProfiling !== value) {
      isProfiling = value;

      if (isProfiling) {
        var internalModuleSourceToRanges = new Map();

        if (supportsUserTimingV3) {
          var ranges = getInternalModuleRanges();

          if (ranges) {
            for (var i = 0; i < ranges.length; i++) {
              var range = ranges[i];

              if (Object(shared_isArray["a" /* default */])(range) && range.length === 2) {
                var _ranges$i2 = _slicedToArray(ranges[i], 2),
                    startStackFrame = _ranges$i2[0],
                    stopStackFrame = _ranges$i2[1];

                markAndClear("--react-internal-module-start-".concat(startStackFrame));
                markAndClear("--react-internal-module-stop-".concat(stopStackFrame));
              }
            }
          }
        }

        var laneToReactMeasureMap = new Map();
        var lane = 1;

        for (var index = 0; index < REACT_TOTAL_NUM_LANES; index++) {
          laneToReactMeasureMap.set(lane, []);
          lane *= 2;
        }

        currentBatchUID = 0;
        currentReactComponentMeasure = null;
        currentReactMeasuresStack = [];
        currentFiberStacks = new Map();
        currentTimelineData = {
          // Session wide metadata; only collected once.
          internalModuleSourceToRanges: internalModuleSourceToRanges,
          laneToLabelMap: laneToLabelMap || new Map(),
          reactVersion: reactVersion,
          // Data logged by React during profiling session.
          componentMeasures: [],
          schedulingEvents: [],
          suspenseEvents: [],
          thrownErrors: [],
          // Data inferred based on what React logs.
          batchUIDToMeasuresMap: new Map(),
          duration: 0,
          laneToReactMeasureMap: laneToReactMeasureMap,
          startTime: 0,
          // Data only available in Chrome profiles.
          flamechart: [],
          nativeEvents: [],
          networkMeasures: [],
          otherUserTimingMarks: [],
          snapshots: [],
          snapshotHeight: 0
        };
        nextRenderShouldStartNewBatch = true;
      } else {
        // Postprocess Profile data
        if (currentTimelineData !== null) {
          currentTimelineData.schedulingEvents.forEach(function (event) {
            if (event.type === 'schedule-state-update') {
              // TODO(luna): We can optimize this by creating a map of
              // fiber to component stack instead of generating the stack
              // for every fiber every time
              var fiberStack = currentFiberStacks.get(event);

              if (fiberStack && currentDispatcherRef != null) {
                event.componentStack = fiberStack.reduce(function (trace, fiber) {
                  return trace + Object(DevToolsFiberComponentStack["a" /* describeFiber */])(workTagMap, fiber, currentDispatcherRef);
                }, '');
              }
            }
          });
        } // Clear the current fiber stacks so we don't hold onto the fibers
        // in memory after profiling finishes


        currentFiberStacks.clear();
      }
    }
  }

  return {
    getTimelineData: getTimelineData,
    profilingHooks: {
      markCommitStarted: markCommitStarted,
      markCommitStopped: markCommitStopped,
      markComponentRenderStarted: markComponentRenderStarted,
      markComponentRenderStopped: markComponentRenderStopped,
      markComponentPassiveEffectMountStarted: markComponentPassiveEffectMountStarted,
      markComponentPassiveEffectMountStopped: markComponentPassiveEffectMountStopped,
      markComponentPassiveEffectUnmountStarted: markComponentPassiveEffectUnmountStarted,
      markComponentPassiveEffectUnmountStopped: markComponentPassiveEffectUnmountStopped,
      markComponentLayoutEffectMountStarted: markComponentLayoutEffectMountStarted,
      markComponentLayoutEffectMountStopped: markComponentLayoutEffectMountStopped,
      markComponentLayoutEffectUnmountStarted: markComponentLayoutEffectUnmountStarted,
      markComponentLayoutEffectUnmountStopped: markComponentLayoutEffectUnmountStopped,
      markComponentErrored: markComponentErrored,
      markComponentSuspended: markComponentSuspended,
      markLayoutEffectsStarted: markLayoutEffectsStarted,
      markLayoutEffectsStopped: markLayoutEffectsStopped,
      markPassiveEffectsStarted: markPassiveEffectsStarted,
      markPassiveEffectsStopped: markPassiveEffectsStopped,
      markRenderStarted: markRenderStarted,
      markRenderYielded: markRenderYielded,
      markRenderStopped: markRenderStopped,
      markRenderScheduled: markRenderScheduled,
      markForceUpdateScheduled: markForceUpdateScheduled,
      markStateUpdateScheduled: markStateUpdateScheduled
    },
    toggleProfilingStatus: toggleProfilingStatus
  };
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/renderer.js
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function renderer_slicedToArray(arr, i) { return renderer_arrayWithHoles(arr) || renderer_iterableToArrayLimit(arr, i) || renderer_unsupportedIterableToArray(arr, i) || renderer_nonIterableRest(); }

function renderer_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function renderer_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function renderer_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || renderer_unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return renderer_arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = renderer_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function renderer_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return renderer_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return renderer_arrayLikeToArray(o, minLen); }

function renderer_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function renderer_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { renderer_typeof = function _typeof(obj) { return typeof obj; }; } else { renderer_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return renderer_typeof(obj); }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
















function getFiberFlags(fiber) {
  // The name of this field changed from "effectTag" to "flags"
  return fiber.flags !== undefined ? fiber.flags : fiber.effectTag;
} // Some environments (e.g. React Native / Hermes) don't support the performance API yet.


var renderer_getCurrentTime = // $FlowFixMe[method-unbinding]
(typeof performance === "undefined" ? "undefined" : renderer_typeof(performance)) === 'object' && typeof performance.now === 'function' ? function () {
  return performance.now();
} : function () {
  return Date.now();
};
function getInternalReactConstants(version) {
  // **********************************************************
  // The section below is copied from files in React repo.
  // Keep it in sync, and add version guards if it changes.
  //
  // Technically these priority levels are invalid for versions before 16.9,
  // but 16.9 is the first version to report priority level to DevTools,
  // so we can avoid checking for earlier versions and support pre-16.9 canary releases in the process.
  var ReactPriorityLevels = {
    ImmediatePriority: 99,
    UserBlockingPriority: 98,
    NormalPriority: 97,
    LowPriority: 96,
    IdlePriority: 95,
    NoPriority: 90
  };

  if (Object(backend_utils["h" /* gt */])(version, '17.0.2')) {
    ReactPriorityLevels = {
      ImmediatePriority: 1,
      UserBlockingPriority: 2,
      NormalPriority: 3,
      LowPriority: 4,
      IdlePriority: 5,
      NoPriority: 0
    };
  }

  var StrictModeBits = 0;

  if (Object(backend_utils["i" /* gte */])(version, '18.0.0-alpha')) {
    // 18+
    StrictModeBits = 24;
  } else if (Object(backend_utils["i" /* gte */])(version, '16.9.0')) {
    // 16.9 - 17
    StrictModeBits = 1;
  } else if (Object(backend_utils["i" /* gte */])(version, '16.3.0')) {
    // 16.3 - 16.8
    StrictModeBits = 2;
  }

  var ReactTypeOfWork = null; // **********************************************************
  // The section below is copied from files in React repo.
  // Keep it in sync, and add version guards if it changes.
  //
  // TODO Update the gt() check below to be gte() whichever the next version number is.
  // Currently the version in Git is 17.0.2 (but that version has not been/may not end up being released).

  if (Object(backend_utils["h" /* gt */])(version, '17.0.1')) {
    ReactTypeOfWork = {
      CacheComponent: 24,
      // Experimental
      ClassComponent: 1,
      ContextConsumer: 9,
      ContextProvider: 10,
      CoroutineComponent: -1,
      // Removed
      CoroutineHandlerPhase: -1,
      // Removed
      DehydratedSuspenseComponent: 18,
      // Behind a flag
      ForwardRef: 11,
      Fragment: 7,
      FunctionComponent: 0,
      HostComponent: 5,
      HostPortal: 4,
      HostRoot: 3,
      HostHoistable: 26,
      // In reality, 18.2+. But doesn't hurt to include it here
      HostSingleton: 27,
      // Same as above
      HostText: 6,
      IncompleteClassComponent: 17,
      IndeterminateComponent: 2,
      LazyComponent: 16,
      LegacyHiddenComponent: 23,
      MemoComponent: 14,
      Mode: 8,
      OffscreenComponent: 22,
      // Experimental
      Profiler: 12,
      ScopeComponent: 21,
      // Experimental
      SimpleMemoComponent: 15,
      SuspenseComponent: 13,
      SuspenseListComponent: 19,
      // Experimental
      TracingMarkerComponent: 25,
      // Experimental - This is technically in 18 but we don't
      // want to fork again so we're adding it here instead
      YieldComponent: -1 // Removed

    };
  } else if (Object(backend_utils["i" /* gte */])(version, '17.0.0-alpha')) {
    ReactTypeOfWork = {
      CacheComponent: -1,
      // Doesn't exist yet
      ClassComponent: 1,
      ContextConsumer: 9,
      ContextProvider: 10,
      CoroutineComponent: -1,
      // Removed
      CoroutineHandlerPhase: -1,
      // Removed
      DehydratedSuspenseComponent: 18,
      // Behind a flag
      ForwardRef: 11,
      Fragment: 7,
      FunctionComponent: 0,
      HostComponent: 5,
      HostPortal: 4,
      HostRoot: 3,
      HostHoistable: -1,
      // Doesn't exist yet
      HostSingleton: -1,
      // Doesn't exist yet
      HostText: 6,
      IncompleteClassComponent: 17,
      IndeterminateComponent: 2,
      LazyComponent: 16,
      LegacyHiddenComponent: 24,
      MemoComponent: 14,
      Mode: 8,
      OffscreenComponent: 23,
      // Experimental
      Profiler: 12,
      ScopeComponent: 21,
      // Experimental
      SimpleMemoComponent: 15,
      SuspenseComponent: 13,
      SuspenseListComponent: 19,
      // Experimental
      TracingMarkerComponent: -1,
      // Doesn't exist yet
      YieldComponent: -1 // Removed

    };
  } else if (Object(backend_utils["i" /* gte */])(version, '16.6.0-beta.0')) {
    ReactTypeOfWork = {
      CacheComponent: -1,
      // Doesn't exist yet
      ClassComponent: 1,
      ContextConsumer: 9,
      ContextProvider: 10,
      CoroutineComponent: -1,
      // Removed
      CoroutineHandlerPhase: -1,
      // Removed
      DehydratedSuspenseComponent: 18,
      // Behind a flag
      ForwardRef: 11,
      Fragment: 7,
      FunctionComponent: 0,
      HostComponent: 5,
      HostPortal: 4,
      HostRoot: 3,
      HostHoistable: -1,
      // Doesn't exist yet
      HostSingleton: -1,
      // Doesn't exist yet
      HostText: 6,
      IncompleteClassComponent: 17,
      IndeterminateComponent: 2,
      LazyComponent: 16,
      LegacyHiddenComponent: -1,
      MemoComponent: 14,
      Mode: 8,
      OffscreenComponent: -1,
      // Experimental
      Profiler: 12,
      ScopeComponent: -1,
      // Experimental
      SimpleMemoComponent: 15,
      SuspenseComponent: 13,
      SuspenseListComponent: 19,
      // Experimental
      TracingMarkerComponent: -1,
      // Doesn't exist yet
      YieldComponent: -1 // Removed

    };
  } else if (Object(backend_utils["i" /* gte */])(version, '16.4.3-alpha')) {
    ReactTypeOfWork = {
      CacheComponent: -1,
      // Doesn't exist yet
      ClassComponent: 2,
      ContextConsumer: 11,
      ContextProvider: 12,
      CoroutineComponent: -1,
      // Removed
      CoroutineHandlerPhase: -1,
      // Removed
      DehydratedSuspenseComponent: -1,
      // Doesn't exist yet
      ForwardRef: 13,
      Fragment: 9,
      FunctionComponent: 0,
      HostComponent: 7,
      HostPortal: 6,
      HostRoot: 5,
      HostHoistable: -1,
      // Doesn't exist yet
      HostSingleton: -1,
      // Doesn't exist yet
      HostText: 8,
      IncompleteClassComponent: -1,
      // Doesn't exist yet
      IndeterminateComponent: 4,
      LazyComponent: -1,
      // Doesn't exist yet
      LegacyHiddenComponent: -1,
      MemoComponent: -1,
      // Doesn't exist yet
      Mode: 10,
      OffscreenComponent: -1,
      // Experimental
      Profiler: 15,
      ScopeComponent: -1,
      // Experimental
      SimpleMemoComponent: -1,
      // Doesn't exist yet
      SuspenseComponent: 16,
      SuspenseListComponent: -1,
      // Doesn't exist yet
      TracingMarkerComponent: -1,
      // Doesn't exist yet
      YieldComponent: -1 // Removed

    };
  } else {
    ReactTypeOfWork = {
      CacheComponent: -1,
      // Doesn't exist yet
      ClassComponent: 2,
      ContextConsumer: 12,
      ContextProvider: 13,
      CoroutineComponent: 7,
      CoroutineHandlerPhase: 8,
      DehydratedSuspenseComponent: -1,
      // Doesn't exist yet
      ForwardRef: 14,
      Fragment: 10,
      FunctionComponent: 1,
      HostComponent: 5,
      HostPortal: 4,
      HostRoot: 3,
      HostHoistable: -1,
      // Doesn't exist yet
      HostSingleton: -1,
      // Doesn't exist yet
      HostText: 6,
      IncompleteClassComponent: -1,
      // Doesn't exist yet
      IndeterminateComponent: 0,
      LazyComponent: -1,
      // Doesn't exist yet
      LegacyHiddenComponent: -1,
      MemoComponent: -1,
      // Doesn't exist yet
      Mode: 11,
      OffscreenComponent: -1,
      // Experimental
      Profiler: 15,
      ScopeComponent: -1,
      // Experimental
      SimpleMemoComponent: -1,
      // Doesn't exist yet
      SuspenseComponent: 16,
      SuspenseListComponent: -1,
      // Doesn't exist yet
      TracingMarkerComponent: -1,
      // Doesn't exist yet
      YieldComponent: 9
    };
  } // **********************************************************
  // End of copied code.
  // **********************************************************


  function getTypeSymbol(type) {
    var symbolOrNumber = renderer_typeof(type) === 'object' && type !== null ? type.$$typeof : type;
    return renderer_typeof(symbolOrNumber) === 'symbol' ? // $FlowFixMe[incompatible-return] `toString()` doesn't match the type signature?
    symbolOrNumber.toString() : symbolOrNumber;
  }

  var _ReactTypeOfWork = ReactTypeOfWork,
      CacheComponent = _ReactTypeOfWork.CacheComponent,
      ClassComponent = _ReactTypeOfWork.ClassComponent,
      IncompleteClassComponent = _ReactTypeOfWork.IncompleteClassComponent,
      FunctionComponent = _ReactTypeOfWork.FunctionComponent,
      IndeterminateComponent = _ReactTypeOfWork.IndeterminateComponent,
      ForwardRef = _ReactTypeOfWork.ForwardRef,
      HostRoot = _ReactTypeOfWork.HostRoot,
      HostHoistable = _ReactTypeOfWork.HostHoistable,
      HostSingleton = _ReactTypeOfWork.HostSingleton,
      HostComponent = _ReactTypeOfWork.HostComponent,
      HostPortal = _ReactTypeOfWork.HostPortal,
      HostText = _ReactTypeOfWork.HostText,
      Fragment = _ReactTypeOfWork.Fragment,
      LazyComponent = _ReactTypeOfWork.LazyComponent,
      LegacyHiddenComponent = _ReactTypeOfWork.LegacyHiddenComponent,
      MemoComponent = _ReactTypeOfWork.MemoComponent,
      OffscreenComponent = _ReactTypeOfWork.OffscreenComponent,
      Profiler = _ReactTypeOfWork.Profiler,
      ScopeComponent = _ReactTypeOfWork.ScopeComponent,
      SimpleMemoComponent = _ReactTypeOfWork.SimpleMemoComponent,
      SuspenseComponent = _ReactTypeOfWork.SuspenseComponent,
      SuspenseListComponent = _ReactTypeOfWork.SuspenseListComponent,
      TracingMarkerComponent = _ReactTypeOfWork.TracingMarkerComponent;

  function resolveFiberType(type) {
    var typeSymbol = getTypeSymbol(type);

    switch (typeSymbol) {
      case ReactSymbols["j" /* MEMO_NUMBER */]:
      case ReactSymbols["k" /* MEMO_SYMBOL_STRING */]:
        // recursively resolving memo type in case of memo(forwardRef(Component))
        return resolveFiberType(type.type);

      case ReactSymbols["f" /* FORWARD_REF_NUMBER */]:
      case ReactSymbols["g" /* FORWARD_REF_SYMBOL_STRING */]:
        return type.render;

      default:
        return type;
    }
  } // NOTICE Keep in sync with shouldFilterFiber() and other get*ForFiber methods


  function getDisplayNameForFiber(fiber) {
    var elementType = fiber.elementType,
        type = fiber.type,
        tag = fiber.tag;
    var resolvedType = type;

    if (renderer_typeof(type) === 'object' && type !== null) {
      resolvedType = resolveFiberType(type);
    }

    var resolvedContext = null;

    switch (tag) {
      case CacheComponent:
        return 'Cache';

      case ClassComponent:
      case IncompleteClassComponent:
        return Object(utils["h" /* getDisplayName */])(resolvedType);

      case FunctionComponent:
      case IndeterminateComponent:
        return Object(utils["h" /* getDisplayName */])(resolvedType);

      case ForwardRef:
        return Object(utils["l" /* getWrappedDisplayName */])(elementType, resolvedType, 'ForwardRef', 'Anonymous');

      case HostRoot:
        var fiberRoot = fiber.stateNode;

        if (fiberRoot != null && fiberRoot._debugRootType !== null) {
          return fiberRoot._debugRootType;
        }

        return null;

      case HostComponent:
      case HostSingleton:
      case HostHoistable:
        return type;

      case HostPortal:
      case HostText:
        return null;

      case Fragment:
        return 'Fragment';

      case LazyComponent:
        // This display name will not be user visible.
        // Once a Lazy component loads its inner component, React replaces the tag and type.
        // This display name will only show up in console logs when DevTools DEBUG mode is on.
        return 'Lazy';

      case MemoComponent:
      case SimpleMemoComponent:
        // Display name in React does not use `Memo` as a wrapper but fallback name.
        return Object(utils["l" /* getWrappedDisplayName */])(elementType, resolvedType, 'Memo', 'Anonymous');

      case SuspenseComponent:
        return 'Suspense';

      case LegacyHiddenComponent:
        return 'LegacyHidden';

      case OffscreenComponent:
        return 'Offscreen';

      case ScopeComponent:
        return 'Scope';

      case SuspenseListComponent:
        return 'SuspenseList';

      case Profiler:
        return 'Profiler';

      case TracingMarkerComponent:
        return 'TracingMarker';

      default:
        var typeSymbol = getTypeSymbol(type);

        switch (typeSymbol) {
          case ReactSymbols["a" /* CONCURRENT_MODE_NUMBER */]:
          case ReactSymbols["b" /* CONCURRENT_MODE_SYMBOL_STRING */]:
          case ReactSymbols["e" /* DEPRECATED_ASYNC_MODE_SYMBOL_STRING */]:
            return null;

          case ReactSymbols["n" /* PROVIDER_NUMBER */]:
          case ReactSymbols["o" /* PROVIDER_SYMBOL_STRING */]:
            // 16.3.0 exposed the context object as "context"
            // PR #12501 changed it to "_context" for 16.3.1+
            // NOTE Keep in sync with inspectElementRaw()
            resolvedContext = fiber.type._context || fiber.type.context;
            return "".concat(resolvedContext.displayName || 'Context', ".Provider");

          case ReactSymbols["c" /* CONTEXT_NUMBER */]:
          case ReactSymbols["d" /* CONTEXT_SYMBOL_STRING */]:
          case ReactSymbols["r" /* SERVER_CONTEXT_SYMBOL_STRING */]:
            // 16.3-16.5 read from "type" because the Consumer is the actual context object.
            // 16.6+ should read from "type._context" because Consumer can be different (in DEV).
            // NOTE Keep in sync with inspectElementRaw()
            resolvedContext = fiber.type._context || fiber.type; // NOTE: TraceUpdatesBackendManager depends on the name ending in '.Consumer'
            // If you change the name, figure out a more resilient way to detect it.

            return "".concat(resolvedContext.displayName || 'Context', ".Consumer");

          case ReactSymbols["s" /* STRICT_MODE_NUMBER */]:
          case ReactSymbols["t" /* STRICT_MODE_SYMBOL_STRING */]:
            return null;

          case ReactSymbols["l" /* PROFILER_NUMBER */]:
          case ReactSymbols["m" /* PROFILER_SYMBOL_STRING */]:
            return "Profiler(".concat(fiber.memoizedProps.id, ")");

          case ReactSymbols["p" /* SCOPE_NUMBER */]:
          case ReactSymbols["q" /* SCOPE_SYMBOL_STRING */]:
            return 'Scope';

          default:
            // Unknown element type.
            // This may mean a new element type that has not yet been added to DevTools.
            return null;
        }

    }
  }

  return {
    getDisplayNameForFiber: getDisplayNameForFiber,
    getTypeSymbol: getTypeSymbol,
    ReactPriorityLevels: ReactPriorityLevels,
    ReactTypeOfWork: ReactTypeOfWork,
    StrictModeBits: StrictModeBits
  };
} // Map of one or more Fibers in a pair to their unique id number.
// We track both Fibers to support Fast Refresh,
// which may forcefully replace one of the pair as part of hot reloading.
// In that case it's still important to be able to locate the previous ID during subsequent renders.

var fiberToIDMap = new Map(); // Map of id to one (arbitrary) Fiber in a pair.
// This Map is used to e.g. get the display name for a Fiber or schedule an update,
// operations that should be the same whether the current and work-in-progress Fiber is used.

var idToArbitraryFiberMap = new Map();
function attach(hook, rendererID, renderer, global) {
  // Newer versions of the reconciler package also specific reconciler version.
  // If that version number is present, use it.
  // Third party renderer versions may not match the reconciler version,
  // and the latter is what's important in terms of tags and symbols.
  var version = renderer.reconcilerVersion || renderer.version;

  var _getInternalReactCons = getInternalReactConstants(version),
      getDisplayNameForFiber = _getInternalReactCons.getDisplayNameForFiber,
      getTypeSymbol = _getInternalReactCons.getTypeSymbol,
      ReactPriorityLevels = _getInternalReactCons.ReactPriorityLevels,
      ReactTypeOfWork = _getInternalReactCons.ReactTypeOfWork,
      StrictModeBits = _getInternalReactCons.StrictModeBits;

  var CacheComponent = ReactTypeOfWork.CacheComponent,
      ClassComponent = ReactTypeOfWork.ClassComponent,
      ContextConsumer = ReactTypeOfWork.ContextConsumer,
      DehydratedSuspenseComponent = ReactTypeOfWork.DehydratedSuspenseComponent,
      ForwardRef = ReactTypeOfWork.ForwardRef,
      Fragment = ReactTypeOfWork.Fragment,
      FunctionComponent = ReactTypeOfWork.FunctionComponent,
      HostRoot = ReactTypeOfWork.HostRoot,
      HostHoistable = ReactTypeOfWork.HostHoistable,
      HostSingleton = ReactTypeOfWork.HostSingleton,
      HostPortal = ReactTypeOfWork.HostPortal,
      HostComponent = ReactTypeOfWork.HostComponent,
      HostText = ReactTypeOfWork.HostText,
      IncompleteClassComponent = ReactTypeOfWork.IncompleteClassComponent,
      IndeterminateComponent = ReactTypeOfWork.IndeterminateComponent,
      LegacyHiddenComponent = ReactTypeOfWork.LegacyHiddenComponent,
      MemoComponent = ReactTypeOfWork.MemoComponent,
      OffscreenComponent = ReactTypeOfWork.OffscreenComponent,
      SimpleMemoComponent = ReactTypeOfWork.SimpleMemoComponent,
      SuspenseComponent = ReactTypeOfWork.SuspenseComponent,
      SuspenseListComponent = ReactTypeOfWork.SuspenseListComponent,
      TracingMarkerComponent = ReactTypeOfWork.TracingMarkerComponent;
  var ImmediatePriority = ReactPriorityLevels.ImmediatePriority,
      UserBlockingPriority = ReactPriorityLevels.UserBlockingPriority,
      NormalPriority = ReactPriorityLevels.NormalPriority,
      LowPriority = ReactPriorityLevels.LowPriority,
      IdlePriority = ReactPriorityLevels.IdlePriority,
      NoPriority = ReactPriorityLevels.NoPriority;
  var getLaneLabelMap = renderer.getLaneLabelMap,
      injectProfilingHooks = renderer.injectProfilingHooks,
      overrideHookState = renderer.overrideHookState,
      overrideHookStateDeletePath = renderer.overrideHookStateDeletePath,
      overrideHookStateRenamePath = renderer.overrideHookStateRenamePath,
      overrideProps = renderer.overrideProps,
      overridePropsDeletePath = renderer.overridePropsDeletePath,
      overridePropsRenamePath = renderer.overridePropsRenamePath,
      scheduleRefresh = renderer.scheduleRefresh,
      setErrorHandler = renderer.setErrorHandler,
      setSuspenseHandler = renderer.setSuspenseHandler,
      scheduleUpdate = renderer.scheduleUpdate;
  var supportsTogglingError = typeof setErrorHandler === 'function' && typeof scheduleUpdate === 'function';
  var supportsTogglingSuspense = typeof setSuspenseHandler === 'function' && typeof scheduleUpdate === 'function';

  if (typeof scheduleRefresh === 'function') {
    // When Fast Refresh updates a component, the frontend may need to purge cached information.
    // For example, ASTs cached for the component (for named hooks) may no longer be valid.
    // Send a signal to the frontend to purge this cached information.
    // The "fastRefreshScheduled" dispatched is global (not Fiber or even Renderer specific).
    // This is less effecient since it means the front-end will need to purge the entire cache,
    // but this is probably an okay trade off in order to reduce coupling between the DevTools and Fast Refresh.
    renderer.scheduleRefresh = function () {
      try {
        hook.emit('fastRefreshScheduled');
      } finally {
        return scheduleRefresh.apply(void 0, arguments);
      }
    };
  }

  var getTimelineData = null;
  var toggleProfilingStatus = null;

  if (typeof injectProfilingHooks === 'function') {
    var response = createProfilingHooks({
      getDisplayNameForFiber: getDisplayNameForFiber,
      getIsProfiling: function getIsProfiling() {
        return isProfiling;
      },
      getLaneLabelMap: getLaneLabelMap,
      currentDispatcherRef: renderer.currentDispatcherRef,
      workTagMap: ReactTypeOfWork,
      reactVersion: version
    }); // Pass the Profiling hooks to the reconciler for it to call during render.

    injectProfilingHooks(response.profilingHooks); // Hang onto this toggle so we can notify the external methods of profiling status changes.

    getTimelineData = response.getTimelineData;
    toggleProfilingStatus = response.toggleProfilingStatus;
  } // Tracks Fibers with recently changed number of error/warning messages.
  // These collections store the Fiber rather than the ID,
  // in order to avoid generating an ID for Fibers that never get mounted
  // (due to e.g. Suspense or error boundaries).
  // onErrorOrWarning() adds Fibers and recordPendingErrorsAndWarnings() later clears them.


  var fibersWithChangedErrorOrWarningCounts = new Set();
  var pendingFiberToErrorsMap = new Map();
  var pendingFiberToWarningsMap = new Map(); // Mapping of fiber IDs to error/warning messages and counts.

  var fiberIDToErrorsMap = new Map();
  var fiberIDToWarningsMap = new Map();

  function clearErrorsAndWarnings() {
    // eslint-disable-next-line no-for-of-loops/no-for-of-loops
    var _iterator = _createForOfIteratorHelper(fiberIDToErrorsMap.keys()),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var id = _step.value;

        var _fiber = idToArbitraryFiberMap.get(id);

        if (_fiber != null) {
          fibersWithChangedErrorOrWarningCounts.add(_fiber);
          updateMostRecentlyInspectedElementIfNecessary(id);
        }
      } // eslint-disable-next-line no-for-of-loops/no-for-of-loops

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var _iterator2 = _createForOfIteratorHelper(fiberIDToWarningsMap.keys()),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _id = _step2.value;

        var _fiber2 = idToArbitraryFiberMap.get(_id);

        if (_fiber2 != null) {
          fibersWithChangedErrorOrWarningCounts.add(_fiber2);
          updateMostRecentlyInspectedElementIfNecessary(_id);
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    fiberIDToErrorsMap.clear();
    fiberIDToWarningsMap.clear();
    flushPendingEvents();
  }

  function clearMessageCountHelper(fiberID, pendingFiberToMessageCountMap, fiberIDToMessageCountMap) {
    var fiber = idToArbitraryFiberMap.get(fiberID);

    if (fiber != null) {
      // Throw out any pending changes.
      pendingFiberToErrorsMap.delete(fiber);

      if (fiberIDToMessageCountMap.has(fiberID)) {
        fiberIDToMessageCountMap.delete(fiberID); // If previous flushed counts have changed, schedule an update too.

        fibersWithChangedErrorOrWarningCounts.add(fiber);
        flushPendingEvents();
        updateMostRecentlyInspectedElementIfNecessary(fiberID);
      } else {
        fibersWithChangedErrorOrWarningCounts.delete(fiber);
      }
    }
  }

  function clearErrorsForFiberID(fiberID) {
    clearMessageCountHelper(fiberID, pendingFiberToErrorsMap, fiberIDToErrorsMap);
  }

  function clearWarningsForFiberID(fiberID) {
    clearMessageCountHelper(fiberID, pendingFiberToWarningsMap, fiberIDToWarningsMap);
  }

  function updateMostRecentlyInspectedElementIfNecessary(fiberID) {
    if (mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === fiberID) {
      hasElementUpdatedSinceLastInspected = true;
    }
  } // Called when an error or warning is logged during render, commit, or passive (including unmount functions).


  function onErrorOrWarning(fiber, type, args) {
    if (type === 'error') {
      var maybeID = getFiberIDUnsafe(fiber); // if this is an error simulated by us to trigger error boundary, ignore

      if (maybeID != null && forceErrorForFiberIDs.get(maybeID) === true) {
        return;
      }
    }

    var message = backend_utils["e" /* format */].apply(void 0, _toConsumableArray(args));

    if (constants["s" /* __DEBUG__ */]) {
      debug('onErrorOrWarning', fiber, null, "".concat(type, ": \"").concat(message, "\""));
    } // Mark this Fiber as needed its warning/error count updated during the next flush.


    fibersWithChangedErrorOrWarningCounts.add(fiber); // Track the warning/error for later.

    var fiberMap = type === 'error' ? pendingFiberToErrorsMap : pendingFiberToWarningsMap;
    var messageMap = fiberMap.get(fiber);

    if (messageMap != null) {
      var count = messageMap.get(message) || 0;
      messageMap.set(message, count + 1);
    } else {
      fiberMap.set(fiber, new Map([[message, 1]]));
    } // Passive effects may trigger errors or warnings too;
    // In this case, we should wait until the rest of the passive effects have run,
    // but we shouldn't wait until the next commit because that might be a long time.
    // This would also cause "tearing" between an inspected Component and the tree view.
    // Then again we don't want to flush too soon because this could be an error during async rendering.
    // Use a debounce technique to ensure that we'll eventually flush.


    flushPendingErrorsAndWarningsAfterDelay();
  } // Patching the console enables DevTools to do a few useful things:
  // * Append component stacks to warnings and error messages
  // * Disable logging during re-renders to inspect hooks (see inspectHooksOfFiber)


  Object(backend_console["e" /* registerRenderer */])(renderer, onErrorOrWarning); // The renderer interface can't read these preferences directly,
  // because it is stored in localStorage within the context of the extension.
  // It relies on the extension to pass the preference through via the global.

  Object(backend_console["c" /* patchConsoleUsingWindowValues */])();

  var debug = function debug(name, fiber, parentFiber) {
    var extraString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

    if (constants["s" /* __DEBUG__ */]) {
      var displayName = fiber.tag + ':' + (getDisplayNameForFiber(fiber) || 'null');
      var maybeID = getFiberIDUnsafe(fiber) || '<no id>';
      var parentDisplayName = parentFiber ? parentFiber.tag + ':' + (getDisplayNameForFiber(parentFiber) || 'null') : '';
      var maybeParentID = parentFiber ? getFiberIDUnsafe(parentFiber) || '<no-id>' : '';
      console.groupCollapsed("[renderer] %c".concat(name, " %c").concat(displayName, " (").concat(maybeID, ") %c").concat(parentFiber ? "".concat(parentDisplayName, " (").concat(maybeParentID, ")") : '', " %c").concat(extraString), 'color: red; font-weight: bold;', 'color: blue;', 'color: purple;', 'color: black;');
      console.log(new Error().stack.split('\n').slice(1).join('\n'));
      console.groupEnd();
    }
  }; // Configurable Components tree filters.


  var hideElementsWithDisplayNames = new Set();
  var hideElementsWithPaths = new Set();
  var hideElementsWithTypes = new Set(); // Highlight updates

  var traceUpdatesEnabled = false;
  var traceUpdatesForNodes = new Set();

  function applyComponentFilters(componentFilters) {
    hideElementsWithTypes.clear();
    hideElementsWithDisplayNames.clear();
    hideElementsWithPaths.clear();
    componentFilters.forEach(function (componentFilter) {
      if (!componentFilter.isEnabled) {
        return;
      }

      switch (componentFilter.type) {
        case types["a" /* ComponentFilterDisplayName */]:
          if (componentFilter.isValid && componentFilter.value !== '') {
            hideElementsWithDisplayNames.add(new RegExp(componentFilter.value, 'i'));
          }

          break;

        case types["b" /* ComponentFilterElementType */]:
          hideElementsWithTypes.add(componentFilter.value);
          break;

        case types["d" /* ComponentFilterLocation */]:
          if (componentFilter.isValid && componentFilter.value !== '') {
            hideElementsWithPaths.add(new RegExp(componentFilter.value, 'i'));
          }

          break;

        case types["c" /* ComponentFilterHOC */]:
          hideElementsWithDisplayNames.add(new RegExp('\\('));
          break;

        default:
          console.warn("Invalid component filter type \"".concat(componentFilter.type, "\""));
          break;
      }
    });
  } // The renderer interface can't read saved component filters directly,
  // because they are stored in localStorage within the context of the extension.
  // Instead it relies on the extension to pass filters through.


  if (window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ != null) {
    applyComponentFilters(window.__REACT_DEVTOOLS_COMPONENT_FILTERS__);
  } else {
    // Unfortunately this feature is not expected to work for React Native for now.
    // It would be annoying for us to spam YellowBox warnings with unactionable stuff,
    // so for now just skip this message...
    //console.warn('⚛️ DevTools: Could not locate saved component filters');
    // Fallback to assuming the default filters in this case.
    applyComponentFilters(Object(utils["g" /* getDefaultComponentFilters */])());
  } // If necessary, we can revisit optimizing this operation.
  // For example, we could add a new recursive unmount tree operation.
  // The unmount operations are already significantly smaller than mount operations though.
  // This is something to keep in mind for later.


  function updateComponentFilters(componentFilters) {
    if (isProfiling) {
      // Re-mounting a tree while profiling is in progress might break a lot of assumptions.
      // If necessary, we could support this- but it doesn't seem like a necessary use case.
      throw Error('Cannot modify filter preferences while profiling');
    } // Recursively unmount all roots.


    hook.getFiberRoots(rendererID).forEach(function (root) {
      currentRootID = getOrGenerateFiberID(root.current); // The TREE_OPERATION_REMOVE_ROOT operation serves two purposes:
      // 1. It avoids sending unnecessary bridge traffic to clear a root.
      // 2. It preserves Fiber IDs when remounting (below) which in turn ID to error/warning mapping.

      pushOperation(constants["n" /* TREE_OPERATION_REMOVE_ROOT */]);
      flushPendingEvents(root);
      currentRootID = -1;
    });
    applyComponentFilters(componentFilters); // Reset pseudo counters so that new path selections will be persisted.

    rootDisplayNameCounter.clear(); // Recursively re-mount all roots with new filter criteria applied.

    hook.getFiberRoots(rendererID).forEach(function (root) {
      currentRootID = getOrGenerateFiberID(root.current);
      setRootPseudoKey(currentRootID, root.current);
      mountFiberRecursively(root.current, null, false, false);
      flushPendingEvents(root);
      currentRootID = -1;
    }); // Also re-evaluate all error and warning counts given the new filters.

    reevaluateErrorsAndWarnings();
    flushPendingEvents();
  } // NOTICE Keep in sync with get*ForFiber methods


  function shouldFilterFiber(fiber) {
    var _debugSource = fiber._debugSource,
        tag = fiber.tag,
        type = fiber.type,
        key = fiber.key;

    switch (tag) {
      case DehydratedSuspenseComponent:
        // TODO: ideally we would show dehydrated Suspense immediately.
        // However, it has some special behavior (like disconnecting
        // an alternate and turning into real Suspense) which breaks DevTools.
        // For now, ignore it, and only show it once it gets hydrated.
        // https://github.com/bvaughn/react-devtools-experimental/issues/197
        return true;

      case HostPortal:
      case HostText:
      case LegacyHiddenComponent:
      case OffscreenComponent:
        return true;

      case HostRoot:
        // It is never valid to filter the root element.
        return false;

      case Fragment:
        return key === null;

      default:
        var typeSymbol = getTypeSymbol(type);

        switch (typeSymbol) {
          case ReactSymbols["a" /* CONCURRENT_MODE_NUMBER */]:
          case ReactSymbols["b" /* CONCURRENT_MODE_SYMBOL_STRING */]:
          case ReactSymbols["e" /* DEPRECATED_ASYNC_MODE_SYMBOL_STRING */]:
          case ReactSymbols["s" /* STRICT_MODE_NUMBER */]:
          case ReactSymbols["t" /* STRICT_MODE_SYMBOL_STRING */]:
            return true;

          default:
            break;
        }

    }

    var elementType = getElementTypeForFiber(fiber);

    if (hideElementsWithTypes.has(elementType)) {
      return true;
    }

    if (hideElementsWithDisplayNames.size > 0) {
      var displayName = getDisplayNameForFiber(fiber);

      if (displayName != null) {
        // eslint-disable-next-line no-for-of-loops/no-for-of-loops
        var _iterator3 = _createForOfIteratorHelper(hideElementsWithDisplayNames),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var displayNameRegExp = _step3.value;

            if (displayNameRegExp.test(displayName)) {
              return true;
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
    }

    if (_debugSource != null && hideElementsWithPaths.size > 0) {
      var fileName = _debugSource.fileName; // eslint-disable-next-line no-for-of-loops/no-for-of-loops

      var _iterator4 = _createForOfIteratorHelper(hideElementsWithPaths),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var pathRegExp = _step4.value;

          if (pathRegExp.test(fileName)) {
            return true;
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }

    return false;
  } // NOTICE Keep in sync with shouldFilterFiber() and other get*ForFiber methods


  function getElementTypeForFiber(fiber) {
    var type = fiber.type,
        tag = fiber.tag;

    switch (tag) {
      case ClassComponent:
      case IncompleteClassComponent:
        return types["e" /* ElementTypeClass */];

      case FunctionComponent:
      case IndeterminateComponent:
        return types["h" /* ElementTypeFunction */];

      case ForwardRef:
        return types["g" /* ElementTypeForwardRef */];

      case HostRoot:
        return types["m" /* ElementTypeRoot */];

      case HostComponent:
      case HostHoistable:
      case HostSingleton:
        return types["i" /* ElementTypeHostComponent */];

      case HostPortal:
      case HostText:
      case Fragment:
        return types["k" /* ElementTypeOtherOrUnknown */];

      case MemoComponent:
      case SimpleMemoComponent:
        return types["j" /* ElementTypeMemo */];

      case SuspenseComponent:
        return types["n" /* ElementTypeSuspense */];

      case SuspenseListComponent:
        return types["o" /* ElementTypeSuspenseList */];

      case TracingMarkerComponent:
        return types["p" /* ElementTypeTracingMarker */];

      default:
        var typeSymbol = getTypeSymbol(type);

        switch (typeSymbol) {
          case ReactSymbols["a" /* CONCURRENT_MODE_NUMBER */]:
          case ReactSymbols["b" /* CONCURRENT_MODE_SYMBOL_STRING */]:
          case ReactSymbols["e" /* DEPRECATED_ASYNC_MODE_SYMBOL_STRING */]:
            return types["k" /* ElementTypeOtherOrUnknown */];

          case ReactSymbols["n" /* PROVIDER_NUMBER */]:
          case ReactSymbols["o" /* PROVIDER_SYMBOL_STRING */]:
            return types["f" /* ElementTypeContext */];

          case ReactSymbols["c" /* CONTEXT_NUMBER */]:
          case ReactSymbols["d" /* CONTEXT_SYMBOL_STRING */]:
            return types["f" /* ElementTypeContext */];

          case ReactSymbols["s" /* STRICT_MODE_NUMBER */]:
          case ReactSymbols["t" /* STRICT_MODE_SYMBOL_STRING */]:
            return types["k" /* ElementTypeOtherOrUnknown */];

          case ReactSymbols["l" /* PROFILER_NUMBER */]:
          case ReactSymbols["m" /* PROFILER_SYMBOL_STRING */]:
            return types["l" /* ElementTypeProfiler */];

          default:
            return types["k" /* ElementTypeOtherOrUnknown */];
        }

    }
  } // When profiling is supported, we store the latest tree base durations for each Fiber.
  // This is so that we can quickly capture a snapshot of those values if profiling starts.
  // If we didn't store these values, we'd have to crawl the tree when profiling started,
  // and use a slow path to find each of the current Fibers.


  var idToTreeBaseDurationMap = new Map(); // When profiling is supported, we store the latest tree base durations for each Fiber.
  // This map enables us to filter these times by root when sending them to the frontend.

  var idToRootMap = new Map(); // When a mount or update is in progress, this value tracks the root that is being operated on.

  var currentRootID = -1; // Returns the unique ID for a Fiber or generates and caches a new one if the Fiber hasn't been seen before.
  // Once this method has been called for a Fiber, untrackFiberID() should always be called later to avoid leaking.

  function getOrGenerateFiberID(fiber) {
    var id = null;

    if (fiberToIDMap.has(fiber)) {
      id = fiberToIDMap.get(fiber);
    } else {
      var _alternate = fiber.alternate;

      if (_alternate !== null && fiberToIDMap.has(_alternate)) {
        id = fiberToIDMap.get(_alternate);
      }
    }

    var didGenerateID = false;

    if (id === null) {
      didGenerateID = true;
      id = Object(utils["k" /* getUID */])();
    } // This refinement is for Flow purposes only.


    var refinedID = id; // Make sure we're tracking this Fiber
    // e.g. if it just mounted or an error was logged during initial render.

    if (!fiberToIDMap.has(fiber)) {
      fiberToIDMap.set(fiber, refinedID);
      idToArbitraryFiberMap.set(refinedID, fiber);
    } // Also make sure we're tracking its alternate,
    // e.g. in case this is the first update after mount.


    var alternate = fiber.alternate;

    if (alternate !== null) {
      if (!fiberToIDMap.has(alternate)) {
        fiberToIDMap.set(alternate, refinedID);
      }
    }

    if (constants["s" /* __DEBUG__ */]) {
      if (didGenerateID) {
        debug('getOrGenerateFiberID()', fiber, fiber.return, 'Generated a new UID');
      }
    }

    return refinedID;
  } // Returns an ID if one has already been generated for the Fiber or throws.


  function getFiberIDThrows(fiber) {
    var maybeID = getFiberIDUnsafe(fiber);

    if (maybeID !== null) {
      return maybeID;
    }

    throw Error("Could not find ID for Fiber \"".concat(getDisplayNameForFiber(fiber) || '', "\""));
  } // Returns an ID if one has already been generated for the Fiber or null if one has not been generated.
  // Use this method while e.g. logging to avoid over-retaining Fibers.


  function getFiberIDUnsafe(fiber) {
    if (fiberToIDMap.has(fiber)) {
      return fiberToIDMap.get(fiber);
    } else {
      var alternate = fiber.alternate;

      if (alternate !== null && fiberToIDMap.has(alternate)) {
        return fiberToIDMap.get(alternate);
      }
    }

    return null;
  } // Removes a Fiber (and its alternate) from the Maps used to track their id.
  // This method should always be called when a Fiber is unmounting.


  function untrackFiberID(fiber) {
    if (constants["s" /* __DEBUG__ */]) {
      debug('untrackFiberID()', fiber, fiber.return, 'schedule after delay');
    } // Untrack Fibers after a slight delay in order to support a Fast Refresh edge case:
    // 1. Component type is updated and Fast Refresh schedules an update+remount.
    // 2. flushPendingErrorsAndWarningsAfterDelay() runs, sees the old Fiber is no longer mounted
    //    (it's been disconnected by Fast Refresh), and calls untrackFiberID() to clear it from the Map.
    // 3. React flushes pending passive effects before it runs the next render,
    //    which logs an error or warning, which causes a new ID to be generated for this Fiber.
    // 4. DevTools now tries to unmount the old Component with the new ID.
    //
    // The underlying problem here is the premature clearing of the Fiber ID,
    // but DevTools has no way to detect that a given Fiber has been scheduled for Fast Refresh.
    // (The "_debugNeedsRemount" flag won't necessarily be set.)
    //
    // The best we can do is to delay untracking by a small amount,
    // and give React time to process the Fast Refresh delay.


    untrackFibersSet.add(fiber); // React may detach alternate pointers during unmount;
    // Since our untracking code is async, we should explicily track the pending alternate here as well.

    var alternate = fiber.alternate;

    if (alternate !== null) {
      untrackFibersSet.add(alternate);
    }

    if (untrackFibersTimeoutID === null) {
      untrackFibersTimeoutID = setTimeout(untrackFibers, 1000);
    }
  }

  var untrackFibersSet = new Set();
  var untrackFibersTimeoutID = null;

  function untrackFibers() {
    if (untrackFibersTimeoutID !== null) {
      clearTimeout(untrackFibersTimeoutID);
      untrackFibersTimeoutID = null;
    }

    untrackFibersSet.forEach(function (fiber) {
      var fiberID = getFiberIDUnsafe(fiber);

      if (fiberID !== null) {
        idToArbitraryFiberMap.delete(fiberID); // Also clear any errors/warnings associated with this fiber.

        clearErrorsForFiberID(fiberID);
        clearWarningsForFiberID(fiberID);
      }

      fiberToIDMap.delete(fiber);
      var alternate = fiber.alternate;

      if (alternate !== null) {
        fiberToIDMap.delete(alternate);
      }

      if (forceErrorForFiberIDs.has(fiberID)) {
        forceErrorForFiberIDs.delete(fiberID);

        if (forceErrorForFiberIDs.size === 0 && setErrorHandler != null) {
          setErrorHandler(shouldErrorFiberAlwaysNull);
        }
      }
    });
    untrackFibersSet.clear();
  }

  function getChangeDescription(prevFiber, nextFiber) {
    switch (getElementTypeForFiber(nextFiber)) {
      case types["e" /* ElementTypeClass */]:
      case types["h" /* ElementTypeFunction */]:
      case types["j" /* ElementTypeMemo */]:
      case types["g" /* ElementTypeForwardRef */]:
        if (prevFiber === null) {
          return {
            context: null,
            didHooksChange: false,
            isFirstMount: true,
            props: null,
            state: null
          };
        } else {
          var data = {
            context: getContextChangedKeys(nextFiber),
            didHooksChange: false,
            isFirstMount: false,
            props: getChangedKeys(prevFiber.memoizedProps, nextFiber.memoizedProps),
            state: getChangedKeys(prevFiber.memoizedState, nextFiber.memoizedState)
          }; // Only traverse the hooks list once, depending on what info we're returning.

          var indices = getChangedHooksIndices(prevFiber.memoizedState, nextFiber.memoizedState);
          data.hooks = indices;
          data.didHooksChange = indices !== null && indices.length > 0;
          return data;
        }

      default:
        return null;
    }
  }

  function updateContextsForFiber(fiber) {
    switch (getElementTypeForFiber(fiber)) {
      case types["e" /* ElementTypeClass */]:
      case types["g" /* ElementTypeForwardRef */]:
      case types["h" /* ElementTypeFunction */]:
      case types["j" /* ElementTypeMemo */]:
        if (idToContextsMap !== null) {
          var id = getFiberIDThrows(fiber);
          var contexts = getContextsForFiber(fiber);

          if (contexts !== null) {
            // $FlowFixMe[incompatible-use] found when upgrading Flow
            idToContextsMap.set(id, contexts);
          }
        }

        break;

      default:
        break;
    }
  } // Differentiates between a null context value and no context.


  var NO_CONTEXT = {};

  function getContextsForFiber(fiber) {
    var legacyContext = NO_CONTEXT;
    var modernContext = NO_CONTEXT;

    switch (getElementTypeForFiber(fiber)) {
      case types["e" /* ElementTypeClass */]:
        var instance = fiber.stateNode;

        if (instance != null) {
          if (instance.constructor && instance.constructor.contextType != null) {
            modernContext = instance.context;
          } else {
            legacyContext = instance.context;

            if (legacyContext && Object.keys(legacyContext).length === 0) {
              legacyContext = NO_CONTEXT;
            }
          }
        }

        return [legacyContext, modernContext];

      case types["g" /* ElementTypeForwardRef */]:
      case types["h" /* ElementTypeFunction */]:
      case types["j" /* ElementTypeMemo */]:
        var dependencies = fiber.dependencies;

        if (dependencies && dependencies.firstContext) {
          modernContext = dependencies.firstContext;
        }

        return [legacyContext, modernContext];

      default:
        return null;
    }
  } // Record all contexts at the time profiling is started.
  // Fibers only store the current context value,
  // so we need to track them separately in order to determine changed keys.


  function crawlToInitializeContextsMap(fiber) {
    var id = getFiberIDUnsafe(fiber); // Not all Fibers in the subtree have mounted yet.
    // For example, Offscreen (hidden) or Suspense (suspended) subtrees won't yet be tracked.
    // We can safely skip these subtrees.

    if (id !== null) {
      updateContextsForFiber(fiber);
      var current = fiber.child;

      while (current !== null) {
        crawlToInitializeContextsMap(current);
        current = current.sibling;
      }
    }
  }

  function getContextChangedKeys(fiber) {
    if (idToContextsMap !== null) {
      var id = getFiberIDThrows(fiber); // $FlowFixMe[incompatible-use] found when upgrading Flow

      var prevContexts = idToContextsMap.has(id) ? // $FlowFixMe[incompatible-use] found when upgrading Flow
      idToContextsMap.get(id) : null;
      var nextContexts = getContextsForFiber(fiber);

      if (prevContexts == null || nextContexts == null) {
        return null;
      }

      var _prevContexts = renderer_slicedToArray(prevContexts, 2),
          prevLegacyContext = _prevContexts[0],
          prevModernContext = _prevContexts[1];

      var _nextContexts = renderer_slicedToArray(nextContexts, 2),
          nextLegacyContext = _nextContexts[0],
          nextModernContext = _nextContexts[1];

      switch (getElementTypeForFiber(fiber)) {
        case types["e" /* ElementTypeClass */]:
          if (prevContexts && nextContexts) {
            if (nextLegacyContext !== NO_CONTEXT) {
              return getChangedKeys(prevLegacyContext, nextLegacyContext);
            } else if (nextModernContext !== NO_CONTEXT) {
              return prevModernContext !== nextModernContext;
            }
          }

          break;

        case types["g" /* ElementTypeForwardRef */]:
        case types["h" /* ElementTypeFunction */]:
        case types["j" /* ElementTypeMemo */]:
          if (nextModernContext !== NO_CONTEXT) {
            var prevContext = prevModernContext;
            var nextContext = nextModernContext;

            while (prevContext && nextContext) {
              // Note this only works for versions of React that support this key (e.v. 18+)
              // For older versions, there's no good way to read the current context value after render has completed.
              // This is because React maintains a stack of context values during render,
              // but by the time DevTools is called, render has finished and the stack is empty.
              if (!shared_objectIs(prevContext.memoizedValue, nextContext.memoizedValue)) {
                return true;
              }

              prevContext = prevContext.next;
              nextContext = nextContext.next;
            }

            return false;
          }

          break;

        default:
          break;
      }
    }

    return null;
  }

  function isHookThatCanScheduleUpdate(hookObject) {
    var queue = hookObject.queue;

    if (!queue) {
      return false;
    }

    var boundHasOwnProperty = shared_hasOwnProperty.bind(queue); // Detect the shape of useState() or useReducer()
    // using the attributes that are unique to these hooks
    // but also stable (e.g. not tied to current Lanes implementation)

    var isStateOrReducer = boundHasOwnProperty('pending') && boundHasOwnProperty('dispatch') && typeof queue.dispatch === 'function'; // Detect useSyncExternalStore()

    var isSyncExternalStore = boundHasOwnProperty('value') && boundHasOwnProperty('getSnapshot') && typeof queue.getSnapshot === 'function'; // These are the only types of hooks that can schedule an update.

    return isStateOrReducer || isSyncExternalStore;
  }

  function didStatefulHookChange(prev, next) {
    var prevMemoizedState = prev.memoizedState;
    var nextMemoizedState = next.memoizedState;

    if (isHookThatCanScheduleUpdate(prev)) {
      return prevMemoizedState !== nextMemoizedState;
    }

    return false;
  }

  function getChangedHooksIndices(prev, next) {
    if (prev == null || next == null) {
      return null;
    }

    var indices = [];
    var index = 0;

    if (next.hasOwnProperty('baseState') && next.hasOwnProperty('memoizedState') && next.hasOwnProperty('next') && next.hasOwnProperty('queue')) {
      while (next !== null) {
        if (didStatefulHookChange(prev, next)) {
          indices.push(index);
        }

        next = next.next;
        prev = prev.next;
        index++;
      }
    }

    return indices;
  }

  function getChangedKeys(prev, next) {
    if (prev == null || next == null) {
      return null;
    } // We can't report anything meaningful for hooks changes.


    if (next.hasOwnProperty('baseState') && next.hasOwnProperty('memoizedState') && next.hasOwnProperty('next') && next.hasOwnProperty('queue')) {
      return null;
    }

    var keys = new Set([].concat(_toConsumableArray(Object.keys(prev)), _toConsumableArray(Object.keys(next))));
    var changedKeys = []; // eslint-disable-next-line no-for-of-loops/no-for-of-loops

    var _iterator5 = _createForOfIteratorHelper(keys),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var key = _step5.value;

        if (prev[key] !== next[key]) {
          changedKeys.push(key);
        }
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    return changedKeys;
  } // eslint-disable-next-line no-unused-vars


  function didFiberRender(prevFiber, nextFiber) {
    switch (nextFiber.tag) {
      case ClassComponent:
      case FunctionComponent:
      case ContextConsumer:
      case MemoComponent:
      case SimpleMemoComponent:
      case ForwardRef:
        // For types that execute user code, we check PerformedWork effect.
        // We don't reflect bailouts (either referential or sCU) in DevTools.
        // TODO: This flag is a leaked implementation detail. Once we start
        // releasing DevTools in lockstep with React, we should import a
        // function from the reconciler instead.
        var PerformedWork = 1;
        return (getFiberFlags(nextFiber) & PerformedWork) === PerformedWork;
      // Note: ContextConsumer only gets PerformedWork effect in 16.3.3+
      // so it won't get highlighted with React 16.3.0 to 16.3.2.

      default:
        // For host components and other types, we compare inputs
        // to determine whether something is an update.
        return prevFiber.memoizedProps !== nextFiber.memoizedProps || prevFiber.memoizedState !== nextFiber.memoizedState || prevFiber.ref !== nextFiber.ref;
    }
  }

  var pendingOperations = [];
  var pendingRealUnmountedIDs = [];
  var pendingSimulatedUnmountedIDs = [];
  var pendingOperationsQueue = [];
  var pendingStringTable = new Map();
  var pendingStringTableLength = 0;
  var pendingUnmountedRootID = null;

  function pushOperation(op) {
    if (false) {}

    pendingOperations.push(op);
  }

  function shouldBailoutWithPendingOperations() {
    if (isProfiling) {
      if (currentCommitProfilingMetadata != null && currentCommitProfilingMetadata.durations.length > 0) {
        return false;
      }
    }

    return pendingOperations.length === 0 && pendingRealUnmountedIDs.length === 0 && pendingSimulatedUnmountedIDs.length === 0 && pendingUnmountedRootID === null;
  }

  function flushOrQueueOperations(operations) {
    if (shouldBailoutWithPendingOperations()) {
      return;
    }

    if (pendingOperationsQueue !== null) {
      pendingOperationsQueue.push(operations);
    } else {
      hook.emit('operations', operations);
    }
  }

  var flushPendingErrorsAndWarningsAfterDelayTimeoutID = null;

  function clearPendingErrorsAndWarningsAfterDelay() {
    if (flushPendingErrorsAndWarningsAfterDelayTimeoutID !== null) {
      clearTimeout(flushPendingErrorsAndWarningsAfterDelayTimeoutID);
      flushPendingErrorsAndWarningsAfterDelayTimeoutID = null;
    }
  }

  function flushPendingErrorsAndWarningsAfterDelay() {
    clearPendingErrorsAndWarningsAfterDelay();
    flushPendingErrorsAndWarningsAfterDelayTimeoutID = setTimeout(function () {
      flushPendingErrorsAndWarningsAfterDelayTimeoutID = null;

      if (pendingOperations.length > 0) {
        // On the off chance that something else has pushed pending operations,
        // we should bail on warnings; it's probably not safe to push midway.
        return;
      }

      recordPendingErrorsAndWarnings();

      if (shouldBailoutWithPendingOperations()) {
        // No warnings or errors to flush; we can bail out early here too.
        return;
      } // We can create a smaller operations array than flushPendingEvents()
      // because we only need to flush warning and error counts.
      // Only a few pieces of fixed information are required up front.


      var operations = new Array(3 + pendingOperations.length);
      operations[0] = rendererID;
      operations[1] = currentRootID;
      operations[2] = 0; // String table size

      for (var j = 0; j < pendingOperations.length; j++) {
        operations[3 + j] = pendingOperations[j];
      }

      flushOrQueueOperations(operations);
      pendingOperations.length = 0;
    }, 1000);
  }

  function reevaluateErrorsAndWarnings() {
    fibersWithChangedErrorOrWarningCounts.clear();
    fiberIDToErrorsMap.forEach(function (countMap, fiberID) {
      var fiber = idToArbitraryFiberMap.get(fiberID);

      if (fiber != null) {
        fibersWithChangedErrorOrWarningCounts.add(fiber);
      }
    });
    fiberIDToWarningsMap.forEach(function (countMap, fiberID) {
      var fiber = idToArbitraryFiberMap.get(fiberID);

      if (fiber != null) {
        fibersWithChangedErrorOrWarningCounts.add(fiber);
      }
    });
    recordPendingErrorsAndWarnings();
  }

  function mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToMessageCountMap, fiberIDToMessageCountMap) {
    var newCount = 0;
    var messageCountMap = fiberIDToMessageCountMap.get(fiberID);
    var pendingMessageCountMap = pendingFiberToMessageCountMap.get(fiber);

    if (pendingMessageCountMap != null) {
      if (messageCountMap == null) {
        messageCountMap = pendingMessageCountMap;
        fiberIDToMessageCountMap.set(fiberID, pendingMessageCountMap);
      } else {
        // This Flow refinement should not be necessary and yet...
        var refinedMessageCountMap = messageCountMap;
        pendingMessageCountMap.forEach(function (pendingCount, message) {
          var previousCount = refinedMessageCountMap.get(message) || 0;
          refinedMessageCountMap.set(message, previousCount + pendingCount);
        });
      }
    }

    if (!shouldFilterFiber(fiber)) {
      if (messageCountMap != null) {
        messageCountMap.forEach(function (count) {
          newCount += count;
        });
      }
    }

    pendingFiberToMessageCountMap.delete(fiber);
    return newCount;
  }

  function recordPendingErrorsAndWarnings() {
    clearPendingErrorsAndWarningsAfterDelay();
    fibersWithChangedErrorOrWarningCounts.forEach(function (fiber) {
      var fiberID = getFiberIDUnsafe(fiber);

      if (fiberID === null) {// Don't send updates for Fibers that didn't mount due to e.g. Suspense or an error boundary.
      } else {
        var errorCount = mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToErrorsMap, fiberIDToErrorsMap);
        var warningCount = mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToWarningsMap, fiberIDToWarningsMap);
        pushOperation(constants["q" /* TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS */]);
        pushOperation(fiberID);
        pushOperation(errorCount);
        pushOperation(warningCount);
      } // Always clean up so that we don't leak.


      pendingFiberToErrorsMap.delete(fiber);
      pendingFiberToWarningsMap.delete(fiber);
    });
    fibersWithChangedErrorOrWarningCounts.clear();
  }

  function flushPendingEvents(root) {
    // Add any pending errors and warnings to the operations array.
    // We do this just before flushing, so we can ignore errors for no-longer-mounted Fibers.
    recordPendingErrorsAndWarnings();

    if (shouldBailoutWithPendingOperations()) {
      // If we aren't profiling, we can just bail out here.
      // No use sending an empty update over the bridge.
      //
      // The Profiler stores metadata for each commit and reconstructs the app tree per commit using:
      // (1) an initial tree snapshot and
      // (2) the operations array for each commit
      // Because of this, it's important that the operations and metadata arrays align,
      // So it's important not to omit even empty operations while profiling is active.
      return;
    }

    var numUnmountIDs = pendingRealUnmountedIDs.length + pendingSimulatedUnmountedIDs.length + (pendingUnmountedRootID === null ? 0 : 1);
    var operations = new Array( // Identify which renderer this update is coming from.
    2 + // [rendererID, rootFiberID]
    // How big is the string table?
    1 + // [stringTableLength]
    // Then goes the actual string table.
    pendingStringTableLength + ( // All unmounts are batched in a single message.
    // [TREE_OPERATION_REMOVE, removedIDLength, ...ids]
    numUnmountIDs > 0 ? 2 + numUnmountIDs : 0) + // Regular operations
    pendingOperations.length); // Identify which renderer this update is coming from.
    // This enables roots to be mapped to renderers,
    // Which in turn enables fiber props, states, and hooks to be inspected.

    var i = 0;
    operations[i++] = rendererID;
    operations[i++] = currentRootID; // Now fill in the string table.
    // [stringTableLength, str1Length, ...str1, str2Length, ...str2, ...]

    operations[i++] = pendingStringTableLength;
    pendingStringTable.forEach(function (entry, stringKey) {
      var encodedString = entry.encodedString; // Don't use the string length.
      // It won't work for multibyte characters (like emoji).

      var length = encodedString.length;
      operations[i++] = length;

      for (var j = 0; j < length; j++) {
        operations[i + j] = encodedString[j];
      }

      i += length;
    });

    if (numUnmountIDs > 0) {
      // All unmounts except roots are batched in a single message.
      operations[i++] = constants["m" /* TREE_OPERATION_REMOVE */]; // The first number is how many unmounted IDs we're gonna send.

      operations[i++] = numUnmountIDs; // Fill in the real unmounts in the reverse order.
      // They were inserted parents-first by React, but we want children-first.
      // So we traverse our array backwards.

      for (var j = pendingRealUnmountedIDs.length - 1; j >= 0; j--) {
        operations[i++] = pendingRealUnmountedIDs[j];
      } // Fill in the simulated unmounts (hidden Suspense subtrees) in their order.
      // (We want children to go before parents.)
      // They go *after* the real unmounts because we know for sure they won't be
      // children of already pushed "real" IDs. If they were, we wouldn't be able
      // to discover them during the traversal, as they would have been deleted.


      for (var _j = 0; _j < pendingSimulatedUnmountedIDs.length; _j++) {
        operations[i + _j] = pendingSimulatedUnmountedIDs[_j];
      }

      i += pendingSimulatedUnmountedIDs.length; // The root ID should always be unmounted last.

      if (pendingUnmountedRootID !== null) {
        operations[i] = pendingUnmountedRootID;
        i++;
      }
    } // Fill in the rest of the operations.


    for (var _j2 = 0; _j2 < pendingOperations.length; _j2++) {
      operations[i + _j2] = pendingOperations[_j2];
    }

    i += pendingOperations.length; // Let the frontend know about tree operations.

    flushOrQueueOperations(operations); // Reset all of the pending state now that we've told the frontend about it.

    pendingOperations.length = 0;
    pendingRealUnmountedIDs.length = 0;
    pendingSimulatedUnmountedIDs.length = 0;
    pendingUnmountedRootID = null;
    pendingStringTable.clear();
    pendingStringTableLength = 0;
  }

  function getStringID(string) {
    if (string === null) {
      return 0;
    }

    var existingEntry = pendingStringTable.get(string);

    if (existingEntry !== undefined) {
      return existingEntry.id;
    }

    var id = pendingStringTable.size + 1;
    var encodedString = Object(utils["p" /* utfEncodeString */])(string);
    pendingStringTable.set(string, {
      encodedString: encodedString,
      id: id
    }); // The string table total length needs to account both for the string length,
    // and for the array item that contains the length itself.
    //
    // Don't use string length for this table.
    // It won't work for multibyte characters (like emoji).

    pendingStringTableLength += encodedString.length + 1;
    return id;
  }

  function recordMount(fiber, parentFiber) {
    var isRoot = fiber.tag === HostRoot;
    var id = getOrGenerateFiberID(fiber);

    if (constants["s" /* __DEBUG__ */]) {
      debug('recordMount()', fiber, parentFiber);
    }

    var hasOwnerMetadata = fiber.hasOwnProperty('_debugOwner');
    var isProfilingSupported = fiber.hasOwnProperty('treeBaseDuration'); // Adding a new field here would require a bridge protocol version bump (a backwads breaking change).
    // Instead let's re-purpose a pre-existing field to carry more information.

    var profilingFlags = 0;

    if (isProfilingSupported) {
      profilingFlags = constants["g" /* PROFILING_FLAG_BASIC_SUPPORT */];

      if (typeof injectProfilingHooks === 'function') {
        profilingFlags |= constants["h" /* PROFILING_FLAG_TIMELINE_SUPPORT */];
      }
    }

    if (isRoot) {
      pushOperation(constants["l" /* TREE_OPERATION_ADD */]);
      pushOperation(id);
      pushOperation(types["m" /* ElementTypeRoot */]);
      pushOperation((fiber.mode & StrictModeBits) !== 0 ? 1 : 0);
      pushOperation(profilingFlags);
      pushOperation(StrictModeBits !== 0 ? 1 : 0);
      pushOperation(hasOwnerMetadata ? 1 : 0);

      if (isProfiling) {
        if (displayNamesByRootID !== null) {
          displayNamesByRootID.set(id, getDisplayNameForRoot(fiber));
        }
      }
    } else {
      var key = fiber.key;
      var displayName = getDisplayNameForFiber(fiber);
      var elementType = getElementTypeForFiber(fiber);
      var _debugOwner = fiber._debugOwner; // Ideally we should call getFiberIDThrows() for _debugOwner,
      // since owners are almost always higher in the tree (and so have already been processed),
      // but in some (rare) instances reported in open source, a descendant mounts before an owner.
      // Since this is a DEV only field it's probably okay to also just lazily generate and ID here if needed.
      // See https://github.com/facebook/react/issues/21445

      var ownerID = _debugOwner != null ? getOrGenerateFiberID(_debugOwner) : 0;
      var parentID = parentFiber ? getFiberIDThrows(parentFiber) : 0;
      var displayNameStringID = getStringID(displayName); // This check is a guard to handle a React element that has been modified
      // in such a way as to bypass the default stringification of the "key" property.

      var keyString = key === null ? null : String(key);
      var keyStringID = getStringID(keyString);
      pushOperation(constants["l" /* TREE_OPERATION_ADD */]);
      pushOperation(id);
      pushOperation(elementType);
      pushOperation(parentID);
      pushOperation(ownerID);
      pushOperation(displayNameStringID);
      pushOperation(keyStringID); // If this subtree has a new mode, let the frontend know.

      if ((fiber.mode & StrictModeBits) !== 0 && (parentFiber.mode & StrictModeBits) === 0) {
        pushOperation(constants["p" /* TREE_OPERATION_SET_SUBTREE_MODE */]);
        pushOperation(id);
        pushOperation(types["q" /* StrictMode */]);
      }
    }

    if (isProfilingSupported) {
      idToRootMap.set(id, currentRootID);
      recordProfilingDurations(fiber);
    }
  }

  function recordUnmount(fiber, isSimulated) {
    if (constants["s" /* __DEBUG__ */]) {
      debug('recordUnmount()', fiber, null, isSimulated ? 'unmount is simulated' : '');
    }

    if (trackedPathMatchFiber !== null) {
      // We're in the process of trying to restore previous selection.
      // If this fiber matched but is being unmounted, there's no use trying.
      // Reset the state so we don't keep holding onto it.
      if (fiber === trackedPathMatchFiber || fiber === trackedPathMatchFiber.alternate) {
        setTrackedPath(null);
      }
    }

    var unsafeID = getFiberIDUnsafe(fiber);

    if (unsafeID === null) {
      // If we've never seen this Fiber, it might be inside of a legacy render Suspense fragment (so the store is not even aware of it).
      // In that case we can just ignore it or it will cause errors later on.
      // One example of this is a Lazy component that never resolves before being unmounted.
      //
      // This also might indicate a Fast Refresh force-remount scenario.
      //
      // TODO: This is fragile and can obscure actual bugs.
      return;
    } // Flow refinement.


    var id = unsafeID;
    var isRoot = fiber.tag === HostRoot;

    if (isRoot) {
      // Roots must be removed only after all children (pending and simulated) have been removed.
      // So we track it separately.
      pendingUnmountedRootID = id;
    } else if (!shouldFilterFiber(fiber)) {
      // To maintain child-first ordering,
      // we'll push it into one of these queues,
      // and later arrange them in the correct order.
      if (isSimulated) {
        pendingSimulatedUnmountedIDs.push(id);
      } else {
        pendingRealUnmountedIDs.push(id);
      }
    }

    if (!fiber._debugNeedsRemount) {
      untrackFiberID(fiber);
      var isProfilingSupported = fiber.hasOwnProperty('treeBaseDuration');

      if (isProfilingSupported) {
        idToRootMap.delete(id);
        idToTreeBaseDurationMap.delete(id);
      }
    }
  }

  function mountFiberRecursively(firstChild, parentFiber, traverseSiblings, traceNearestHostComponentUpdate) {
    // Iterate over siblings rather than recursing.
    // This reduces the chance of stack overflow for wide trees (e.g. lists with many items).
    var fiber = firstChild;

    while (fiber !== null) {
      // Generate an ID even for filtered Fibers, in case it's needed later (e.g. for Profiling).
      getOrGenerateFiberID(fiber);

      if (constants["s" /* __DEBUG__ */]) {
        debug('mountFiberRecursively()', fiber, parentFiber);
      } // If we have the tree selection from previous reload, try to match this Fiber.
      // Also remember whether to do the same for siblings.


      var mightSiblingsBeOnTrackedPath = updateTrackedPathStateBeforeMount(fiber);
      var shouldIncludeInTree = !shouldFilterFiber(fiber);

      if (shouldIncludeInTree) {
        recordMount(fiber, parentFiber);
      }

      if (traceUpdatesEnabled) {
        if (traceNearestHostComponentUpdate) {
          var elementType = getElementTypeForFiber(fiber); // If an ancestor updated, we should mark the nearest host nodes for highlighting.

          if (elementType === types["i" /* ElementTypeHostComponent */]) {
            traceUpdatesForNodes.add(fiber.stateNode);
            traceNearestHostComponentUpdate = false;
          }
        } // We intentionally do not re-enable the traceNearestHostComponentUpdate flag in this branch,
        // because we don't want to highlight every host node inside of a newly mounted subtree.

      }

      var isSuspense = fiber.tag === ReactTypeOfWork.SuspenseComponent;

      if (isSuspense) {
        var isTimedOut = fiber.memoizedState !== null;

        if (isTimedOut) {
          // Special case: if Suspense mounts in a timed-out state,
          // get the fallback child from the inner fragment and mount
          // it as if it was our own child. Updates handle this too.
          var primaryChildFragment = fiber.child;
          var fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;
          var fallbackChild = fallbackChildFragment ? fallbackChildFragment.child : null;

          if (fallbackChild !== null) {
            mountFiberRecursively(fallbackChild, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);
          }
        } else {
          var primaryChild = null;
          var areSuspenseChildrenConditionallyWrapped = OffscreenComponent === -1;

          if (areSuspenseChildrenConditionallyWrapped) {
            primaryChild = fiber.child;
          } else if (fiber.child !== null) {
            primaryChild = fiber.child.child;
          }

          if (primaryChild !== null) {
            mountFiberRecursively(primaryChild, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);
          }
        }
      } else {
        if (fiber.child !== null) {
          mountFiberRecursively(fiber.child, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);
        }
      } // We're exiting this Fiber now, and entering its siblings.
      // If we have selection to restore, we might need to re-activate tracking.


      updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath);
      fiber = traverseSiblings ? fiber.sibling : null;
    }
  } // We use this to simulate unmounting for Suspense trees
  // when we switch from primary to fallback.


  function unmountFiberChildrenRecursively(fiber) {
    if (constants["s" /* __DEBUG__ */]) {
      debug('unmountFiberChildrenRecursively()', fiber);
    } // We might meet a nested Suspense on our way.


    var isTimedOutSuspense = fiber.tag === ReactTypeOfWork.SuspenseComponent && fiber.memoizedState !== null;
    var child = fiber.child;

    if (isTimedOutSuspense) {
      // If it's showing fallback tree, let's traverse it instead.
      var primaryChildFragment = fiber.child;
      var fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null; // Skip over to the real Fiber child.

      child = fallbackChildFragment ? fallbackChildFragment.child : null;
    }

    while (child !== null) {
      // Record simulated unmounts children-first.
      // We skip nodes without return because those are real unmounts.
      if (child.return !== null) {
        unmountFiberChildrenRecursively(child);
        recordUnmount(child, true);
      }

      child = child.sibling;
    }
  }

  function recordProfilingDurations(fiber) {
    var id = getFiberIDThrows(fiber);
    var actualDuration = fiber.actualDuration,
        treeBaseDuration = fiber.treeBaseDuration;
    idToTreeBaseDurationMap.set(id, treeBaseDuration || 0);

    if (isProfiling) {
      var alternate = fiber.alternate; // It's important to update treeBaseDuration even if the current Fiber did not render,
      // because it's possible that one of its descendants did.

      if (alternate == null || treeBaseDuration !== alternate.treeBaseDuration) {
        // Tree base duration updates are included in the operations typed array.
        // So we have to convert them from milliseconds to microseconds so we can send them as ints.
        var convertedTreeBaseDuration = Math.floor((treeBaseDuration || 0) * 1000);
        pushOperation(constants["r" /* TREE_OPERATION_UPDATE_TREE_BASE_DURATION */]);
        pushOperation(id);
        pushOperation(convertedTreeBaseDuration);
      }

      if (alternate == null || didFiberRender(alternate, fiber)) {
        if (actualDuration != null) {
          // The actual duration reported by React includes time spent working on children.
          // This is useful information, but it's also useful to be able to exclude child durations.
          // The frontend can't compute this, since the immediate children may have been filtered out.
          // So we need to do this on the backend.
          // Note that this calculated self duration is not the same thing as the base duration.
          // The two are calculated differently (tree duration does not accumulate).
          var selfDuration = actualDuration;
          var child = fiber.child;

          while (child !== null) {
            selfDuration -= child.actualDuration || 0;
            child = child.sibling;
          } // If profiling is active, store durations for elements that were rendered during the commit.
          // Note that we should do this for any fiber we performed work on, regardless of its actualDuration value.
          // In some cases actualDuration might be 0 for fibers we worked on (particularly if we're using Date.now)
          // In other cases (e.g. Memo) actualDuration might be greater than 0 even if we "bailed out".


          var metadata = currentCommitProfilingMetadata;
          metadata.durations.push(id, actualDuration, selfDuration);
          metadata.maxActualDuration = Math.max(metadata.maxActualDuration, actualDuration);

          if (recordChangeDescriptions) {
            var changeDescription = getChangeDescription(alternate, fiber);

            if (changeDescription !== null) {
              if (metadata.changeDescriptions !== null) {
                metadata.changeDescriptions.set(id, changeDescription);
              }
            }

            updateContextsForFiber(fiber);
          }
        }
      }
    }
  }

  function recordResetChildren(fiber, childSet) {
    if (constants["s" /* __DEBUG__ */]) {
      debug('recordResetChildren()', childSet, fiber);
    } // The frontend only really cares about the displayName, key, and children.
    // The first two don't really change, so we are only concerned with the order of children here.
    // This is trickier than a simple comparison though, since certain types of fibers are filtered.


    var nextChildren = []; // This is a naive implementation that shallowly recourses children.
    // We might want to revisit this if it proves to be too inefficient.

    var child = childSet;

    while (child !== null) {
      findReorderedChildrenRecursively(child, nextChildren);
      child = child.sibling;
    }

    var numChildren = nextChildren.length;

    if (numChildren < 2) {
      // No need to reorder.
      return;
    }

    pushOperation(constants["o" /* TREE_OPERATION_REORDER_CHILDREN */]);
    pushOperation(getFiberIDThrows(fiber));
    pushOperation(numChildren);

    for (var i = 0; i < nextChildren.length; i++) {
      pushOperation(nextChildren[i]);
    }
  }

  function findReorderedChildrenRecursively(fiber, nextChildren) {
    if (!shouldFilterFiber(fiber)) {
      nextChildren.push(getFiberIDThrows(fiber));
    } else {
      var child = fiber.child;
      var isTimedOutSuspense = fiber.tag === SuspenseComponent && fiber.memoizedState !== null;

      if (isTimedOutSuspense) {
        // Special case: if Suspense mounts in a timed-out state,
        // get the fallback child from the inner fragment,
        // and skip over the primary child.
        var primaryChildFragment = fiber.child;
        var fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;
        var fallbackChild = fallbackChildFragment ? fallbackChildFragment.child : null;

        if (fallbackChild !== null) {
          child = fallbackChild;
        }
      }

      while (child !== null) {
        findReorderedChildrenRecursively(child, nextChildren);
        child = child.sibling;
      }
    }
  } // Returns whether closest unfiltered fiber parent needs to reset its child list.


  function updateFiberRecursively(nextFiber, prevFiber, parentFiber, traceNearestHostComponentUpdate) {
    var id = getOrGenerateFiberID(nextFiber);

    if (constants["s" /* __DEBUG__ */]) {
      debug('updateFiberRecursively()', nextFiber, parentFiber);
    }

    if (traceUpdatesEnabled) {
      var elementType = getElementTypeForFiber(nextFiber);

      if (traceNearestHostComponentUpdate) {
        // If an ancestor updated, we should mark the nearest host nodes for highlighting.
        if (elementType === types["i" /* ElementTypeHostComponent */]) {
          traceUpdatesForNodes.add(nextFiber.stateNode);
          traceNearestHostComponentUpdate = false;
        }
      } else {
        if (elementType === types["h" /* ElementTypeFunction */] || elementType === types["e" /* ElementTypeClass */] || elementType === types["f" /* ElementTypeContext */] || elementType === types["j" /* ElementTypeMemo */] || elementType === types["g" /* ElementTypeForwardRef */]) {
          // Otherwise if this is a traced ancestor, flag for the nearest host descendant(s).
          traceNearestHostComponentUpdate = didFiberRender(prevFiber, nextFiber);
        }
      }
    }

    if (mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === id && didFiberRender(prevFiber, nextFiber)) {
      // If this Fiber has updated, clear cached inspected data.
      // If it is inspected again, it may need to be re-run to obtain updated hooks values.
      hasElementUpdatedSinceLastInspected = true;
    }

    var shouldIncludeInTree = !shouldFilterFiber(nextFiber);
    var isSuspense = nextFiber.tag === SuspenseComponent;
    var shouldResetChildren = false; // The behavior of timed-out Suspense trees is unique.
    // Rather than unmount the timed out content (and possibly lose important state),
    // React re-parents this content within a hidden Fragment while the fallback is showing.
    // This behavior doesn't need to be observable in the DevTools though.
    // It might even result in a bad user experience for e.g. node selection in the Elements panel.
    // The easiest fix is to strip out the intermediate Fragment fibers,
    // so the Elements panel and Profiler don't need to special case them.
    // Suspense components only have a non-null memoizedState if they're timed-out.

    var prevDidTimeout = isSuspense && prevFiber.memoizedState !== null;
    var nextDidTimeOut = isSuspense && nextFiber.memoizedState !== null; // The logic below is inspired by the code paths in updateSuspenseComponent()
    // inside ReactFiberBeginWork in the React source code.

    if (prevDidTimeout && nextDidTimeOut) {
      // Fallback -> Fallback:
      // 1. Reconcile fallback set.
      var nextFiberChild = nextFiber.child;
      var nextFallbackChildSet = nextFiberChild ? nextFiberChild.sibling : null; // Note: We can't use nextFiber.child.sibling.alternate
      // because the set is special and alternate may not exist.

      var prevFiberChild = prevFiber.child;
      var prevFallbackChildSet = prevFiberChild ? prevFiberChild.sibling : null;

      if (nextFallbackChildSet != null && prevFallbackChildSet != null && updateFiberRecursively(nextFallbackChildSet, prevFallbackChildSet, nextFiber, traceNearestHostComponentUpdate)) {
        shouldResetChildren = true;
      }
    } else if (prevDidTimeout && !nextDidTimeOut) {
      // Fallback -> Primary:
      // 1. Unmount fallback set
      // Note: don't emulate fallback unmount because React actually did it.
      // 2. Mount primary set
      var nextPrimaryChildSet = nextFiber.child;

      if (nextPrimaryChildSet !== null) {
        mountFiberRecursively(nextPrimaryChildSet, shouldIncludeInTree ? nextFiber : parentFiber, true, traceNearestHostComponentUpdate);
      }

      shouldResetChildren = true;
    } else if (!prevDidTimeout && nextDidTimeOut) {
      // Primary -> Fallback:
      // 1. Hide primary set
      // This is not a real unmount, so it won't get reported by React.
      // We need to manually walk the previous tree and record unmounts.
      unmountFiberChildrenRecursively(prevFiber); // 2. Mount fallback set

      var _nextFiberChild = nextFiber.child;

      var _nextFallbackChildSet = _nextFiberChild ? _nextFiberChild.sibling : null;

      if (_nextFallbackChildSet != null) {
        mountFiberRecursively(_nextFallbackChildSet, shouldIncludeInTree ? nextFiber : parentFiber, true, traceNearestHostComponentUpdate);
        shouldResetChildren = true;
      }
    } else {
      // Common case: Primary -> Primary.
      // This is the same code path as for non-Suspense fibers.
      if (nextFiber.child !== prevFiber.child) {
        // If the first child is different, we need to traverse them.
        // Each next child will be either a new child (mount) or an alternate (update).
        var nextChild = nextFiber.child;
        var prevChildAtSameIndex = prevFiber.child;

        while (nextChild) {
          // We already know children will be referentially different because
          // they are either new mounts or alternates of previous children.
          // Schedule updates and mounts depending on whether alternates exist.
          // We don't track deletions here because they are reported separately.
          if (nextChild.alternate) {
            var prevChild = nextChild.alternate;

            if (updateFiberRecursively(nextChild, prevChild, shouldIncludeInTree ? nextFiber : parentFiber, traceNearestHostComponentUpdate)) {
              // If a nested tree child order changed but it can't handle its own
              // child order invalidation (e.g. because it's filtered out like host nodes),
              // propagate the need to reset child order upwards to this Fiber.
              shouldResetChildren = true;
            } // However we also keep track if the order of the children matches
            // the previous order. They are always different referentially, but
            // if the instances line up conceptually we'll want to know that.


            if (prevChild !== prevChildAtSameIndex) {
              shouldResetChildren = true;
            }
          } else {
            mountFiberRecursively(nextChild, shouldIncludeInTree ? nextFiber : parentFiber, false, traceNearestHostComponentUpdate);
            shouldResetChildren = true;
          } // Try the next child.


          nextChild = nextChild.sibling; // Advance the pointer in the previous list so that we can
          // keep comparing if they line up.

          if (!shouldResetChildren && prevChildAtSameIndex !== null) {
            prevChildAtSameIndex = prevChildAtSameIndex.sibling;
          }
        } // If we have no more children, but used to, they don't line up.


        if (prevChildAtSameIndex !== null) {
          shouldResetChildren = true;
        }
      } else {
        if (traceUpdatesEnabled) {
          // If we're tracing updates and we've bailed out before reaching a host node,
          // we should fall back to recursively marking the nearest host descendants for highlight.
          if (traceNearestHostComponentUpdate) {
            var hostFibers = findAllCurrentHostFibers(getFiberIDThrows(nextFiber));
            hostFibers.forEach(function (hostFiber) {
              traceUpdatesForNodes.add(hostFiber.stateNode);
            });
          }
        }
      }
    }

    if (shouldIncludeInTree) {
      var isProfilingSupported = nextFiber.hasOwnProperty('treeBaseDuration');

      if (isProfilingSupported) {
        recordProfilingDurations(nextFiber);
      }
    }

    if (shouldResetChildren) {
      // We need to crawl the subtree for closest non-filtered Fibers
      // so that we can display them in a flat children set.
      if (shouldIncludeInTree) {
        // Normally, search for children from the rendered child.
        var nextChildSet = nextFiber.child;

        if (nextDidTimeOut) {
          // Special case: timed-out Suspense renders the fallback set.
          var _nextFiberChild2 = nextFiber.child;
          nextChildSet = _nextFiberChild2 ? _nextFiberChild2.sibling : null;
        }

        if (nextChildSet != null) {
          recordResetChildren(nextFiber, nextChildSet);
        } // We've handled the child order change for this Fiber.
        // Since it's included, there's no need to invalidate parent child order.


        return false;
      } else {
        // Let the closest unfiltered parent Fiber reset its child order instead.
        return true;
      }
    } else {
      return false;
    }
  }

  function cleanup() {// We don't patch any methods so there is no cleanup.
  }

  function rootSupportsProfiling(root) {
    if (root.memoizedInteractions != null) {
      // v16 builds include this field for the scheduler/tracing API.
      return true;
    } else if (root.current != null && root.current.hasOwnProperty('treeBaseDuration')) {
      // The scheduler/tracing API was removed in v17 though
      // so we need to check a non-root Fiber.
      return true;
    } else {
      return false;
    }
  }

  function flushInitialOperations() {
    var localPendingOperationsQueue = pendingOperationsQueue;
    pendingOperationsQueue = null;

    if (localPendingOperationsQueue !== null && localPendingOperationsQueue.length > 0) {
      // We may have already queued up some operations before the frontend connected
      // If so, let the frontend know about them.
      localPendingOperationsQueue.forEach(function (operations) {
        hook.emit('operations', operations);
      });
    } else {
      // Before the traversals, remember to start tracking
      // our path in case we have selection to restore.
      if (trackedPath !== null) {
        mightBeOnTrackedPath = true;
      } // If we have not been profiling, then we can just walk the tree and build up its current state as-is.


      hook.getFiberRoots(rendererID).forEach(function (root) {
        currentRootID = getOrGenerateFiberID(root.current);
        setRootPseudoKey(currentRootID, root.current); // Handle multi-renderer edge-case where only some v16 renderers support profiling.

        if (isProfiling && rootSupportsProfiling(root)) {
          // If profiling is active, store commit time and duration.
          // The frontend may request this information after profiling has stopped.
          currentCommitProfilingMetadata = {
            changeDescriptions: recordChangeDescriptions ? new Map() : null,
            durations: [],
            commitTime: renderer_getCurrentTime() - profilingStartTime,
            maxActualDuration: 0,
            priorityLevel: null,
            updaters: getUpdatersList(root),
            effectDuration: null,
            passiveEffectDuration: null
          };
        }

        mountFiberRecursively(root.current, null, false, false);
        flushPendingEvents(root);
        currentRootID = -1;
      });
    }
  }

  function getUpdatersList(root) {
    return root.memoizedUpdaters != null ? Array.from(root.memoizedUpdaters).filter(function (fiber) {
      return getFiberIDUnsafe(fiber) !== null;
    }).map(fiberToSerializedElement) : null;
  }

  function handleCommitFiberUnmount(fiber) {
    // If the untrackFiberSet already has the unmounted Fiber, this means we've already
    // recordedUnmount, so we don't need to do it again. If we don't do this, we might
    // end up double-deleting Fibers in some cases (like Legacy Suspense).
    if (!untrackFibersSet.has(fiber)) {
      // This is not recursive.
      // We can't traverse fibers after unmounting so instead
      // we rely on React telling us about each unmount.
      recordUnmount(fiber, false);
    }
  }

  function handlePostCommitFiberRoot(root) {
    if (isProfiling && rootSupportsProfiling(root)) {
      if (currentCommitProfilingMetadata !== null) {
        var _getEffectDurations = Object(backend_utils["g" /* getEffectDurations */])(root),
            effectDuration = _getEffectDurations.effectDuration,
            passiveEffectDuration = _getEffectDurations.passiveEffectDuration; // $FlowFixMe[incompatible-use] found when upgrading Flow


        currentCommitProfilingMetadata.effectDuration = effectDuration; // $FlowFixMe[incompatible-use] found when upgrading Flow

        currentCommitProfilingMetadata.passiveEffectDuration = passiveEffectDuration;
      }
    }
  }

  function handleCommitFiberRoot(root, priorityLevel) {
    var current = root.current;
    var alternate = current.alternate; // Flush any pending Fibers that we are untracking before processing the new commit.
    // If we don't do this, we might end up double-deleting Fibers in some cases (like Legacy Suspense).

    untrackFibers();
    currentRootID = getOrGenerateFiberID(current); // Before the traversals, remember to start tracking
    // our path in case we have selection to restore.

    if (trackedPath !== null) {
      mightBeOnTrackedPath = true;
    }

    if (traceUpdatesEnabled) {
      traceUpdatesForNodes.clear();
    } // Handle multi-renderer edge-case where only some v16 renderers support profiling.


    var isProfilingSupported = rootSupportsProfiling(root);

    if (isProfiling && isProfilingSupported) {
      // If profiling is active, store commit time and duration.
      // The frontend may request this information after profiling has stopped.
      currentCommitProfilingMetadata = {
        changeDescriptions: recordChangeDescriptions ? new Map() : null,
        durations: [],
        commitTime: renderer_getCurrentTime() - profilingStartTime,
        maxActualDuration: 0,
        priorityLevel: priorityLevel == null ? null : formatPriorityLevel(priorityLevel),
        updaters: getUpdatersList(root),
        // Initialize to null; if new enough React version is running,
        // these values will be read during separate handlePostCommitFiberRoot() call.
        effectDuration: null,
        passiveEffectDuration: null
      };
    }

    if (alternate) {
      // TODO: relying on this seems a bit fishy.
      var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && // A dehydrated root is not considered mounted
      alternate.memoizedState.isDehydrated !== true;
      var isMounted = current.memoizedState != null && current.memoizedState.element != null && // A dehydrated root is not considered mounted
      current.memoizedState.isDehydrated !== true;

      if (!wasMounted && isMounted) {
        // Mount a new root.
        setRootPseudoKey(currentRootID, current);
        mountFiberRecursively(current, null, false, false);
      } else if (wasMounted && isMounted) {
        // Update an existing root.
        updateFiberRecursively(current, alternate, null, false);
      } else if (wasMounted && !isMounted) {
        // Unmount an existing root.
        removeRootPseudoKey(currentRootID);
        recordUnmount(current, false);
      }
    } else {
      // Mount a new root.
      setRootPseudoKey(currentRootID, current);
      mountFiberRecursively(current, null, false, false);
    }

    if (isProfiling && isProfilingSupported) {
      if (!shouldBailoutWithPendingOperations()) {
        var commitProfilingMetadata = rootToCommitProfilingMetadataMap.get(currentRootID);

        if (commitProfilingMetadata != null) {
          commitProfilingMetadata.push(currentCommitProfilingMetadata);
        } else {
          rootToCommitProfilingMetadataMap.set(currentRootID, [currentCommitProfilingMetadata]);
        }
      }
    } // We're done here.


    flushPendingEvents(root);

    if (traceUpdatesEnabled) {
      hook.emit('traceUpdates', traceUpdatesForNodes);
    }

    currentRootID = -1;
  }

  function findAllCurrentHostFibers(id) {
    var fibers = [];
    var fiber = findCurrentFiberUsingSlowPathById(id);

    if (!fiber) {
      return fibers;
    } // Next we'll drill down this component to find all HostComponent/Text.


    var node = fiber;

    while (true) {
      if (node.tag === HostComponent || node.tag === HostText) {
        fibers.push(node);
      } else if (node.child) {
        node.child.return = node;
        node = node.child;
        continue;
      }

      if (node === fiber) {
        return fibers;
      }

      while (!node.sibling) {
        if (!node.return || node.return === fiber) {
          return fibers;
        }

        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    } // Flow needs the return here, but ESLint complains about it.
    // eslint-disable-next-line no-unreachable


    return fibers;
  }

  function findNativeNodesForFiberID(id) {
    try {
      var _fiber3 = findCurrentFiberUsingSlowPathById(id);

      if (_fiber3 === null) {
        return null;
      } // Special case for a timed-out Suspense.


      var isTimedOutSuspense = _fiber3.tag === SuspenseComponent && _fiber3.memoizedState !== null;

      if (isTimedOutSuspense) {
        // A timed-out Suspense's findDOMNode is useless.
        // Try our best to find the fallback directly.
        var maybeFallbackFiber = _fiber3.child && _fiber3.child.sibling;

        if (maybeFallbackFiber != null) {
          _fiber3 = maybeFallbackFiber;
        }
      }

      var hostFibers = findAllCurrentHostFibers(id);
      return hostFibers.map(function (hostFiber) {
        return hostFiber.stateNode;
      }).filter(Boolean);
    } catch (err) {
      // The fiber might have unmounted by now.
      return null;
    }
  }

  function getDisplayNameForFiberID(id) {
    var fiber = idToArbitraryFiberMap.get(id);
    return fiber != null ? getDisplayNameForFiber(fiber) : null;
  }

  function getFiberForNative(hostInstance) {
    return renderer.findFiberByHostInstance(hostInstance);
  }

  function getFiberIDForNative(hostInstance) {
    var findNearestUnfilteredAncestor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var fiber = renderer.findFiberByHostInstance(hostInstance);

    if (fiber != null) {
      if (findNearestUnfilteredAncestor) {
        while (fiber !== null && shouldFilterFiber(fiber)) {
          fiber = fiber.return;
        }
      }

      return getFiberIDThrows(fiber);
    }

    return null;
  } // This function is copied from React and should be kept in sync:
  // https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberTreeReflection.js


  function assertIsMounted(fiber) {
    if (getNearestMountedFiber(fiber) !== fiber) {
      throw new Error('Unable to find node on an unmounted component.');
    }
  } // This function is copied from React and should be kept in sync:
  // https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberTreeReflection.js


  function getNearestMountedFiber(fiber) {
    var node = fiber;
    var nearestMounted = fiber;

    if (!fiber.alternate) {
      // If there is no alternate, this might be a new tree that isn't inserted
      // yet. If it is, then it will have a pending insertion effect on it.
      var nextNode = node;

      do {
        node = nextNode; // TODO: This function, and these flags, are a leaked implementation
        // detail. Once we start releasing DevTools in lockstep with React, we
        // should import a function from the reconciler instead.

        var Placement = 2;
        var Hydrating = 4096;

        if ((node.flags & (Placement | Hydrating)) !== 0) {
          // This is an insertion or in-progress hydration. The nearest possible
          // mounted fiber is the parent but we need to continue to figure out
          // if that one is still mounted.
          nearestMounted = node.return;
        } // $FlowFixMe[incompatible-type] we bail out when we get a null


        nextNode = node.return;
      } while (nextNode);
    } else {
      while (node.return) {
        node = node.return;
      }
    }

    if (node.tag === HostRoot) {
      // TODO: Check if this was a nested HostRoot when used with
      // renderContainerIntoSubtree.
      return nearestMounted;
    } // If we didn't hit the root, that means that we're in an disconnected tree
    // that has been unmounted.


    return null;
  } // This function is copied from React and should be kept in sync:
  // https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberTreeReflection.js
  // It would be nice if we updated React to inject this function directly (vs just indirectly via findDOMNode).
  // BEGIN copied code


  function findCurrentFiberUsingSlowPathById(id) {
    var fiber = idToArbitraryFiberMap.get(id);

    if (fiber == null) {
      console.warn("Could not find Fiber with id \"".concat(id, "\""));
      return null;
    }

    var alternate = fiber.alternate;

    if (!alternate) {
      // If there is no alternate, then we only need to check if it is mounted.
      var nearestMounted = getNearestMountedFiber(fiber);

      if (nearestMounted === null) {
        throw new Error('Unable to find node on an unmounted component.');
      }

      if (nearestMounted !== fiber) {
        return null;
      }

      return fiber;
    } // If we have two possible branches, we'll walk backwards up to the root
    // to see what path the root points to. On the way we may hit one of the
    // special cases and we'll deal with them.


    var a = fiber;
    var b = alternate;

    while (true) {
      var parentA = a.return;

      if (parentA === null) {
        // We're at the root.
        break;
      }

      var parentB = parentA.alternate;

      if (parentB === null) {
        // There is no alternate. This is an unusual case. Currently, it only
        // happens when a Suspense component is hidden. An extra fragment fiber
        // is inserted in between the Suspense fiber and its children. Skip
        // over this extra fragment fiber and proceed to the next parent.
        var nextParent = parentA.return;

        if (nextParent !== null) {
          a = b = nextParent;
          continue;
        } // If there's no parent, we're at the root.


        break;
      } // If both copies of the parent fiber point to the same child, we can
      // assume that the child is current. This happens when we bailout on low
      // priority: the bailed out fiber's child reuses the current child.


      if (parentA.child === parentB.child) {
        var child = parentA.child;

        while (child) {
          if (child === a) {
            // We've determined that A is the current branch.
            assertIsMounted(parentA);
            return fiber;
          }

          if (child === b) {
            // We've determined that B is the current branch.
            assertIsMounted(parentA);
            return alternate;
          }

          child = child.sibling;
        } // We should never have an alternate for any mounting node. So the only
        // way this could possibly happen is if this was unmounted, if at all.


        throw new Error('Unable to find node on an unmounted component.');
      }

      if (a.return !== b.return) {
        // The return pointer of A and the return pointer of B point to different
        // fibers. We assume that return pointers never criss-cross, so A must
        // belong to the child set of A.return, and B must belong to the child
        // set of B.return.
        a = parentA;
        b = parentB;
      } else {
        // The return pointers point to the same fiber. We'll have to use the
        // default, slow path: scan the child sets of each parent alternate to see
        // which child belongs to which set.
        //
        // Search parent A's child set
        var didFindChild = false;
        var _child = parentA.child;

        while (_child) {
          if (_child === a) {
            didFindChild = true;
            a = parentA;
            b = parentB;
            break;
          }

          if (_child === b) {
            didFindChild = true;
            b = parentA;
            a = parentB;
            break;
          }

          _child = _child.sibling;
        }

        if (!didFindChild) {
          // Search parent B's child set
          _child = parentB.child;

          while (_child) {
            if (_child === a) {
              didFindChild = true;
              a = parentB;
              b = parentA;
              break;
            }

            if (_child === b) {
              didFindChild = true;
              b = parentB;
              a = parentA;
              break;
            }

            _child = _child.sibling;
          }

          if (!didFindChild) {
            throw new Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');
          }
        }
      }

      if (a.alternate !== b) {
        throw new Error("Return fibers should always be each others' alternates. " + 'This error is likely caused by a bug in React. Please file an issue.');
      }
    } // If the root is not a host container, we're in a disconnected tree. I.e.
    // unmounted.


    if (a.tag !== HostRoot) {
      throw new Error('Unable to find node on an unmounted component.');
    }

    if (a.stateNode.current === a) {
      // We've determined that A is the current branch.
      return fiber;
    } // Otherwise B has to be current branch.


    return alternate;
  } // END copied code


  function prepareViewAttributeSource(id, path) {
    if (isMostRecentlyInspectedElement(id)) {
      window.$attribute = Object(utils["j" /* getInObject */])(mostRecentlyInspectedElement, path);
    }
  }

  function prepareViewElementSource(id) {
    var fiber = idToArbitraryFiberMap.get(id);

    if (fiber == null) {
      console.warn("Could not find Fiber with id \"".concat(id, "\""));
      return;
    }

    var elementType = fiber.elementType,
        tag = fiber.tag,
        type = fiber.type;

    switch (tag) {
      case ClassComponent:
      case IncompleteClassComponent:
      case IndeterminateComponent:
      case FunctionComponent:
        global.$type = type;
        break;

      case ForwardRef:
        global.$type = type.render;
        break;

      case MemoComponent:
      case SimpleMemoComponent:
        global.$type = elementType != null && elementType.type != null ? elementType.type : type;
        break;

      default:
        global.$type = null;
        break;
    }
  }

  function fiberToSerializedElement(fiber) {
    return {
      displayName: getDisplayNameForFiber(fiber) || 'Anonymous',
      id: getFiberIDThrows(fiber),
      key: fiber.key,
      type: getElementTypeForFiber(fiber)
    };
  }

  function getOwnersList(id) {
    var fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber == null) {
      return null;
    }

    var _debugOwner = fiber._debugOwner;
    var owners = [fiberToSerializedElement(fiber)];

    if (_debugOwner) {
      var owner = _debugOwner;

      while (owner !== null) {
        owners.unshift(fiberToSerializedElement(owner));
        owner = owner._debugOwner || null;
      }
    }

    return owners;
  } // Fast path props lookup for React Native style editor.
  // Could use inspectElementRaw() but that would require shallow rendering hooks components,
  // and could also mess with memoization.


  function getInstanceAndStyle(id) {
    var instance = null;
    var style = null;
    var fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber !== null) {
      instance = fiber.stateNode;

      if (fiber.memoizedProps !== null) {
        style = fiber.memoizedProps.style;
      }
    }

    return {
      instance: instance,
      style: style
    };
  }

  function isErrorBoundary(fiber) {
    var tag = fiber.tag,
        type = fiber.type;

    switch (tag) {
      case ClassComponent:
      case IncompleteClassComponent:
        var instance = fiber.stateNode;
        return typeof type.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function';

      default:
        return false;
    }
  }

  function getNearestErrorBoundaryID(fiber) {
    var parent = fiber.return;

    while (parent !== null) {
      if (isErrorBoundary(parent)) {
        return getFiberIDUnsafe(parent);
      }

      parent = parent.return;
    }

    return null;
  }

  function inspectElementRaw(id) {
    var fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber == null) {
      return null;
    }

    var _debugOwner = fiber._debugOwner,
        _debugSource = fiber._debugSource,
        stateNode = fiber.stateNode,
        key = fiber.key,
        memoizedProps = fiber.memoizedProps,
        memoizedState = fiber.memoizedState,
        dependencies = fiber.dependencies,
        tag = fiber.tag,
        type = fiber.type;
    var elementType = getElementTypeForFiber(fiber);
    var usesHooks = (tag === FunctionComponent || tag === SimpleMemoComponent || tag === ForwardRef) && (!!memoizedState || !!dependencies); // TODO Show custom UI for Cache like we do for Suspense
    // For now, just hide state data entirely since it's not meant to be inspected.

    var showState = !usesHooks && tag !== CacheComponent;
    var typeSymbol = getTypeSymbol(type);
    var canViewSource = false;
    var context = null;

    if (tag === ClassComponent || tag === FunctionComponent || tag === IncompleteClassComponent || tag === IndeterminateComponent || tag === MemoComponent || tag === ForwardRef || tag === SimpleMemoComponent) {
      canViewSource = true;

      if (stateNode && stateNode.context != null) {
        // Don't show an empty context object for class components that don't use the context API.
        var shouldHideContext = elementType === types["e" /* ElementTypeClass */] && !(type.contextTypes || type.contextType);

        if (!shouldHideContext) {
          context = stateNode.context;
        }
      }
    } else if (typeSymbol === ReactSymbols["c" /* CONTEXT_NUMBER */] || typeSymbol === ReactSymbols["d" /* CONTEXT_SYMBOL_STRING */]) {
      // 16.3-16.5 read from "type" because the Consumer is the actual context object.
      // 16.6+ should read from "type._context" because Consumer can be different (in DEV).
      // NOTE Keep in sync with getDisplayNameForFiber()
      var consumerResolvedContext = type._context || type; // Global context value.

      context = consumerResolvedContext._currentValue || null; // Look for overridden value.

      var _current = fiber.return;

      while (_current !== null) {
        var currentType = _current.type;
        var currentTypeSymbol = getTypeSymbol(currentType);

        if (currentTypeSymbol === ReactSymbols["n" /* PROVIDER_NUMBER */] || currentTypeSymbol === ReactSymbols["o" /* PROVIDER_SYMBOL_STRING */]) {
          // 16.3.0 exposed the context object as "context"
          // PR #12501 changed it to "_context" for 16.3.1+
          // NOTE Keep in sync with getDisplayNameForFiber()
          var providerResolvedContext = currentType._context || currentType.context;

          if (providerResolvedContext === consumerResolvedContext) {
            context = _current.memoizedProps.value;
            break;
          }
        }

        _current = _current.return;
      }
    }

    var hasLegacyContext = false;

    if (context !== null) {
      hasLegacyContext = !!type.contextTypes; // To simplify hydration and display logic for context, wrap in a value object.
      // Otherwise simple values (e.g. strings, booleans) become harder to handle.

      context = {
        value: context
      };
    }

    var owners = null;

    if (_debugOwner) {
      owners = [];
      var owner = _debugOwner;

      while (owner !== null) {
        owners.push(fiberToSerializedElement(owner));
        owner = owner._debugOwner || null;
      }
    }

    var isTimedOutSuspense = tag === SuspenseComponent && memoizedState !== null;
    var hooks = null;

    if (usesHooks) {
      var originalConsoleMethods = {}; // Temporarily disable all console logging before re-running the hook.

      for (var method in console) {
        try {
          originalConsoleMethods[method] = console[method]; // $FlowFixMe[prop-missing]

          console[method] = function () {};
        } catch (error) {}
      }

      try {
        hooks = Object(react_debug_tools["inspectHooksOfFiber"])(fiber, renderer.currentDispatcherRef, true // Include source location info for hooks
        );
      } finally {
        // Restore original console functionality.
        for (var _method in originalConsoleMethods) {
          try {
            // $FlowFixMe[prop-missing]
            console[_method] = originalConsoleMethods[_method];
          } catch (error) {}
        }
      }
    }

    var rootType = null;
    var current = fiber;

    while (current.return !== null) {
      current = current.return;
    }

    var fiberRoot = current.stateNode;

    if (fiberRoot != null && fiberRoot._debugRootType !== null) {
      rootType = fiberRoot._debugRootType;
    }

    var errors = fiberIDToErrorsMap.get(id) || new Map();
    var warnings = fiberIDToWarningsMap.get(id) || new Map();
    var isErrored = false;
    var targetErrorBoundaryID;

    if (isErrorBoundary(fiber)) {
      // if the current inspected element is an error boundary,
      // either that we want to use it to toggle off error state
      // or that we allow to force error state on it if it's within another
      // error boundary
      //
      // TODO: This flag is a leaked implementation detail. Once we start
      // releasing DevTools in lockstep with React, we should import a function
      // from the reconciler instead.
      var DidCapture = 128;
      isErrored = (fiber.flags & DidCapture) !== 0 || forceErrorForFiberIDs.get(id) === true;
      targetErrorBoundaryID = isErrored ? id : getNearestErrorBoundaryID(fiber);
    } else {
      targetErrorBoundaryID = getNearestErrorBoundaryID(fiber);
    }

    var plugins = {
      stylex: null
    };

    if (DevToolsFeatureFlags_core_oss["b" /* enableStyleXFeatures */]) {
      if (memoizedProps.hasOwnProperty('xstyle')) {
        plugins.stylex = getStyleXData(memoizedProps.xstyle);
      }
    }

    return {
      id: id,
      // Does the current renderer support editable hooks and function props?
      canEditHooks: typeof overrideHookState === 'function',
      canEditFunctionProps: typeof overrideProps === 'function',
      // Does the current renderer support advanced editing interface?
      canEditHooksAndDeletePaths: typeof overrideHookStateDeletePath === 'function',
      canEditHooksAndRenamePaths: typeof overrideHookStateRenamePath === 'function',
      canEditFunctionPropsDeletePaths: typeof overridePropsDeletePath === 'function',
      canEditFunctionPropsRenamePaths: typeof overridePropsRenamePath === 'function',
      canToggleError: supportsTogglingError && targetErrorBoundaryID != null,
      // Is this error boundary in error state.
      isErrored: isErrored,
      targetErrorBoundaryID: targetErrorBoundaryID,
      canToggleSuspense: supportsTogglingSuspense && ( // If it's showing the real content, we can always flip fallback.
      !isTimedOutSuspense || // If it's showing fallback because we previously forced it to,
      // allow toggling it back to remove the fallback override.
      forceFallbackForSuspenseIDs.has(id)),
      // Can view component source location.
      canViewSource: canViewSource,
      // Does the component have legacy context attached to it.
      hasLegacyContext: hasLegacyContext,
      key: key != null ? key : null,
      displayName: getDisplayNameForFiber(fiber),
      type: elementType,
      // Inspectable properties.
      // TODO Review sanitization approach for the below inspectable values.
      context: context,
      hooks: hooks,
      props: memoizedProps,
      state: showState ? memoizedState : null,
      errors: Array.from(errors.entries()),
      warnings: Array.from(warnings.entries()),
      // List of owners
      owners: owners,
      // Location of component in source code.
      source: _debugSource || null,
      rootType: rootType,
      rendererPackageName: renderer.rendererPackageName,
      rendererVersion: renderer.version,
      plugins: plugins
    };
  }

  var mostRecentlyInspectedElement = null;
  var hasElementUpdatedSinceLastInspected = false;
  var currentlyInspectedPaths = {};

  function isMostRecentlyInspectedElement(id) {
    return mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === id;
  }

  function isMostRecentlyInspectedElementCurrent(id) {
    return isMostRecentlyInspectedElement(id) && !hasElementUpdatedSinceLastInspected;
  } // Track the intersection of currently inspected paths,
  // so that we can send their data along if the element is re-rendered.


  function mergeInspectedPaths(path) {
    var current = currentlyInspectedPaths;
    path.forEach(function (key) {
      if (!current[key]) {
        current[key] = {};
      }

      current = current[key];
    });
  }

  function createIsPathAllowed(key, secondaryCategory) {
    // This function helps prevent previously-inspected paths from being dehydrated in updates.
    // This is important to avoid a bad user experience where expanded toggles collapse on update.
    return function isPathAllowed(path) {
      switch (secondaryCategory) {
        case 'hooks':
          if (path.length === 1) {
            // Never dehydrate the "hooks" object at the top levels.
            return true;
          }

          if (path[path.length - 2] === 'hookSource' && path[path.length - 1] === 'fileName') {
            // It's important to preserve the full file name (URL) for hook sources
            // in case the user has enabled the named hooks feature.
            // Otherwise the frontend may end up with a partial URL which it can't load.
            return true;
          }

          if (path[path.length - 1] === 'subHooks' || path[path.length - 2] === 'subHooks') {
            // Dehydrating the 'subHooks' property makes the HooksTree UI a lot more complicated,
            // so it's easiest for now if we just don't break on this boundary.
            // We can always dehydrate a level deeper (in the value object).
            return true;
          }

          break;

        default:
          break;
      }

      var current = key === null ? currentlyInspectedPaths : currentlyInspectedPaths[key];

      if (!current) {
        return false;
      }

      for (var i = 0; i < path.length; i++) {
        current = current[path[i]];

        if (!current) {
          return false;
        }
      }

      return true;
    };
  }

  function updateSelectedElement(inspectedElement) {
    var hooks = inspectedElement.hooks,
        id = inspectedElement.id,
        props = inspectedElement.props;
    var fiber = idToArbitraryFiberMap.get(id);

    if (fiber == null) {
      console.warn("Could not find Fiber with id \"".concat(id, "\""));
      return;
    }

    var elementType = fiber.elementType,
        stateNode = fiber.stateNode,
        tag = fiber.tag,
        type = fiber.type;

    switch (tag) {
      case ClassComponent:
      case IncompleteClassComponent:
      case IndeterminateComponent:
        global.$r = stateNode;
        break;

      case FunctionComponent:
        global.$r = {
          hooks: hooks,
          props: props,
          type: type
        };
        break;

      case ForwardRef:
        global.$r = {
          hooks: hooks,
          props: props,
          type: type.render
        };
        break;

      case MemoComponent:
      case SimpleMemoComponent:
        global.$r = {
          hooks: hooks,
          props: props,
          type: elementType != null && elementType.type != null ? elementType.type : type
        };
        break;

      default:
        global.$r = null;
        break;
    }
  }

  function storeAsGlobal(id, path, count) {
    if (isMostRecentlyInspectedElement(id)) {
      var value = Object(utils["j" /* getInObject */])(mostRecentlyInspectedElement, path);
      var key = "$reactTemp".concat(count);
      window[key] = value;
      console.log(key);
      console.log(value);
    }
  }

  function getSerializedElementValueByPath(id, path) {
    if (isMostRecentlyInspectedElement(id)) {
      var valueToCopy = Object(utils["j" /* getInObject */])(mostRecentlyInspectedElement, path);
      return Object(backend_utils["l" /* serializeToString */])(valueToCopy);
    }
  }

  function inspectElement(requestID, id, path, forceFullData) {
    if (path !== null) {
      mergeInspectedPaths(path);
    }

    if (isMostRecentlyInspectedElement(id) && !forceFullData) {
      if (!hasElementUpdatedSinceLastInspected) {
        if (path !== null) {
          var secondaryCategory = null;

          if (path[0] === 'hooks') {
            secondaryCategory = 'hooks';
          } // If this element has not been updated since it was last inspected,
          // we can just return the subset of data in the newly-inspected path.


          return {
            id: id,
            responseID: requestID,
            type: 'hydrated-path',
            path: path,
            value: Object(backend_utils["a" /* cleanForBridge */])(Object(utils["j" /* getInObject */])(mostRecentlyInspectedElement, path), createIsPathAllowed(null, secondaryCategory), path)
          };
        } else {
          // If this element has not been updated since it was last inspected, we don't need to return it.
          // Instead we can just return the ID to indicate that it has not changed.
          return {
            id: id,
            responseID: requestID,
            type: 'no-change'
          };
        }
      }
    } else {
      currentlyInspectedPaths = {};
    }

    hasElementUpdatedSinceLastInspected = false;

    try {
      mostRecentlyInspectedElement = inspectElementRaw(id);
    } catch (error) {
      // the error name is synced with ReactDebugHooks
      if (error.name === 'ReactDebugToolsRenderError') {
        var message = 'Error rendering inspected element.';
        var stack; // Log error & cause for user to debug

        console.error(message + '\n\n', error);

        if (error.cause != null) {
          var _fiber4 = findCurrentFiberUsingSlowPathById(id);

          var componentName = _fiber4 != null ? getDisplayNameForFiber(_fiber4) : null;
          console.error('React DevTools encountered an error while trying to inspect hooks. ' + 'This is most likely caused by an error in current inspected component' + (componentName != null ? ": \"".concat(componentName, "\".") : '.') + '\nThe error thrown in the component is: \n\n', error.cause);

          if (error.cause instanceof Error) {
            message = error.cause.message || message;
            stack = error.cause.stack;
          }
        }

        return {
          type: 'error',
          errorType: 'user',
          id: id,
          responseID: requestID,
          message: message,
          stack: stack
        };
      } // the error name is synced with ReactDebugHooks


      if (error.name === 'ReactDebugToolsUnsupportedHookError') {
        return {
          type: 'error',
          errorType: 'unknown-hook',
          id: id,
          responseID: requestID,
          message: 'Unsupported hook in the react-debug-tools package: ' + error.message
        };
      } // Log Uncaught Error


      console.error('Error inspecting element.\n\n', error);
      return {
        type: 'error',
        errorType: 'uncaught',
        id: id,
        responseID: requestID,
        message: error.message,
        stack: error.stack
      };
    }

    if (mostRecentlyInspectedElement === null) {
      return {
        id: id,
        responseID: requestID,
        type: 'not-found'
      };
    } // Any time an inspected element has an update,
    // we should update the selected $r value as wel.
    // Do this before dehydration (cleanForBridge).


    updateSelectedElement(mostRecentlyInspectedElement); // Clone before cleaning so that we preserve the full data.
    // This will enable us to send patches without re-inspecting if hydrated paths are requested.
    // (Reducing how often we shallow-render is a better DX for function components that use hooks.)

    var cleanedInspectedElement = _objectSpread({}, mostRecentlyInspectedElement); // $FlowFixMe[prop-missing] found when upgrading Flow


    cleanedInspectedElement.context = Object(backend_utils["a" /* cleanForBridge */])(cleanedInspectedElement.context, createIsPathAllowed('context', null)); // $FlowFixMe[prop-missing] found when upgrading Flow

    cleanedInspectedElement.hooks = Object(backend_utils["a" /* cleanForBridge */])(cleanedInspectedElement.hooks, createIsPathAllowed('hooks', 'hooks')); // $FlowFixMe[prop-missing] found when upgrading Flow

    cleanedInspectedElement.props = Object(backend_utils["a" /* cleanForBridge */])(cleanedInspectedElement.props, createIsPathAllowed('props', null)); // $FlowFixMe[prop-missing] found when upgrading Flow

    cleanedInspectedElement.state = Object(backend_utils["a" /* cleanForBridge */])(cleanedInspectedElement.state, createIsPathAllowed('state', null));
    return {
      id: id,
      responseID: requestID,
      type: 'full-data',
      // $FlowFixMe[prop-missing] found when upgrading Flow
      value: cleanedInspectedElement
    };
  }

  function logElementToConsole(id) {
    var result = isMostRecentlyInspectedElementCurrent(id) ? mostRecentlyInspectedElement : inspectElementRaw(id);

    if (result === null) {
      console.warn("Could not find Fiber with id \"".concat(id, "\""));
      return;
    }

    var supportsGroup = typeof console.groupCollapsed === 'function';

    if (supportsGroup) {
      console.groupCollapsed("[Click to expand] %c<".concat(result.displayName || 'Component', " />"), // --dom-tag-name-color is the CSS variable Chrome styles HTML elements with in the console.
      'color: var(--dom-tag-name-color); font-weight: normal;');
    }

    if (result.props !== null) {
      console.log('Props:', result.props);
    }

    if (result.state !== null) {
      console.log('State:', result.state);
    }

    if (result.hooks !== null) {
      console.log('Hooks:', result.hooks);
    }

    var nativeNodes = findNativeNodesForFiberID(id);

    if (nativeNodes !== null) {
      console.log('Nodes:', nativeNodes);
    }

    if (result.source !== null) {
      console.log('Location:', result.source);
    }

    if (window.chrome || /firefox/i.test(navigator.userAgent)) {
      console.log('Right-click any value to save it as a global variable for further inspection.');
    }

    if (supportsGroup) {
      console.groupEnd();
    }
  }

  function deletePath(type, id, hookID, path) {
    var fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber !== null) {
      var instance = fiber.stateNode;

      switch (type) {
        case 'context':
          // To simplify hydration and display of primitive context values (e.g. number, string)
          // the inspectElement() method wraps context in a {value: ...} object.
          // We need to remove the first part of the path (the "value") before continuing.
          path = path.slice(1);

          switch (fiber.tag) {
            case ClassComponent:
              if (path.length === 0) {// Simple context value (noop)
              } else {
                Object(utils["c" /* deletePathInObject */])(instance.context, path);
              }

              instance.forceUpdate();
              break;

            case FunctionComponent:
              // Function components using legacy context are not editable
              // because there's no instance on which to create a cloned, mutated context.
              break;
          }

          break;

        case 'hooks':
          if (typeof overrideHookStateDeletePath === 'function') {
            overrideHookStateDeletePath(fiber, hookID, path);
          }

          break;

        case 'props':
          if (instance === null) {
            if (typeof overridePropsDeletePath === 'function') {
              overridePropsDeletePath(fiber, path);
            }
          } else {
            fiber.pendingProps = Object(backend_utils["b" /* copyWithDelete */])(instance.props, path);
            instance.forceUpdate();
          }

          break;

        case 'state':
          Object(utils["c" /* deletePathInObject */])(instance.state, path);
          instance.forceUpdate();
          break;
      }
    }
  }

  function renamePath(type, id, hookID, oldPath, newPath) {
    var fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber !== null) {
      var instance = fiber.stateNode;

      switch (type) {
        case 'context':
          // To simplify hydration and display of primitive context values (e.g. number, string)
          // the inspectElement() method wraps context in a {value: ...} object.
          // We need to remove the first part of the path (the "value") before continuing.
          oldPath = oldPath.slice(1);
          newPath = newPath.slice(1);

          switch (fiber.tag) {
            case ClassComponent:
              if (oldPath.length === 0) {// Simple context value (noop)
              } else {
                Object(utils["n" /* renamePathInObject */])(instance.context, oldPath, newPath);
              }

              instance.forceUpdate();
              break;

            case FunctionComponent:
              // Function components using legacy context are not editable
              // because there's no instance on which to create a cloned, mutated context.
              break;
          }

          break;

        case 'hooks':
          if (typeof overrideHookStateRenamePath === 'function') {
            overrideHookStateRenamePath(fiber, hookID, oldPath, newPath);
          }

          break;

        case 'props':
          if (instance === null) {
            if (typeof overridePropsRenamePath === 'function') {
              overridePropsRenamePath(fiber, oldPath, newPath);
            }
          } else {
            fiber.pendingProps = Object(backend_utils["c" /* copyWithRename */])(instance.props, oldPath, newPath);
            instance.forceUpdate();
          }

          break;

        case 'state':
          Object(utils["n" /* renamePathInObject */])(instance.state, oldPath, newPath);
          instance.forceUpdate();
          break;
      }
    }
  }

  function overrideValueAtPath(type, id, hookID, path, value) {
    var fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber !== null) {
      var instance = fiber.stateNode;

      switch (type) {
        case 'context':
          // To simplify hydration and display of primitive context values (e.g. number, string)
          // the inspectElement() method wraps context in a {value: ...} object.
          // We need to remove the first part of the path (the "value") before continuing.
          path = path.slice(1);

          switch (fiber.tag) {
            case ClassComponent:
              if (path.length === 0) {
                // Simple context value
                instance.context = value;
              } else {
                Object(utils["o" /* setInObject */])(instance.context, path, value);
              }

              instance.forceUpdate();
              break;

            case FunctionComponent:
              // Function components using legacy context are not editable
              // because there's no instance on which to create a cloned, mutated context.
              break;
          }

          break;

        case 'hooks':
          if (typeof overrideHookState === 'function') {
            overrideHookState(fiber, hookID, path, value);
          }

          break;

        case 'props':
          switch (fiber.tag) {
            case ClassComponent:
              fiber.pendingProps = Object(backend_utils["d" /* copyWithSet */])(instance.props, path, value);
              instance.forceUpdate();
              break;

            default:
              if (typeof overrideProps === 'function') {
                overrideProps(fiber, path, value);
              }

              break;
          }

          break;

        case 'state':
          switch (fiber.tag) {
            case ClassComponent:
              Object(utils["o" /* setInObject */])(instance.state, path, value);
              instance.forceUpdate();
              break;
          }

          break;
      }
    }
  }

  var currentCommitProfilingMetadata = null;
  var displayNamesByRootID = null;
  var idToContextsMap = null;
  var initialTreeBaseDurationsMap = null;
  var initialIDToRootMap = null;
  var isProfiling = false;
  var profilingStartTime = 0;
  var recordChangeDescriptions = false;
  var rootToCommitProfilingMetadataMap = null;

  function getProfilingData() {
    var dataForRoots = [];

    if (rootToCommitProfilingMetadataMap === null) {
      throw Error('getProfilingData() called before any profiling data was recorded');
    }

    rootToCommitProfilingMetadataMap.forEach(function (commitProfilingMetadata, rootID) {
      var commitData = [];
      var initialTreeBaseDurations = [];
      var displayName = displayNamesByRootID !== null && displayNamesByRootID.get(rootID) || 'Unknown';

      if (initialTreeBaseDurationsMap != null) {
        initialTreeBaseDurationsMap.forEach(function (treeBaseDuration, id) {
          if (initialIDToRootMap != null && initialIDToRootMap.get(id) === rootID) {
            // We don't need to convert milliseconds to microseconds in this case,
            // because the profiling summary is JSON serialized.
            initialTreeBaseDurations.push([id, treeBaseDuration]);
          }
        });
      }

      commitProfilingMetadata.forEach(function (commitProfilingData, commitIndex) {
        var changeDescriptions = commitProfilingData.changeDescriptions,
            durations = commitProfilingData.durations,
            effectDuration = commitProfilingData.effectDuration,
            maxActualDuration = commitProfilingData.maxActualDuration,
            passiveEffectDuration = commitProfilingData.passiveEffectDuration,
            priorityLevel = commitProfilingData.priorityLevel,
            commitTime = commitProfilingData.commitTime,
            updaters = commitProfilingData.updaters;
        var fiberActualDurations = [];
        var fiberSelfDurations = [];

        for (var i = 0; i < durations.length; i += 3) {
          var fiberID = durations[i];
          fiberActualDurations.push([fiberID, durations[i + 1]]);
          fiberSelfDurations.push([fiberID, durations[i + 2]]);
        }

        commitData.push({
          changeDescriptions: changeDescriptions !== null ? Array.from(changeDescriptions.entries()) : null,
          duration: maxActualDuration,
          effectDuration: effectDuration,
          fiberActualDurations: fiberActualDurations,
          fiberSelfDurations: fiberSelfDurations,
          passiveEffectDuration: passiveEffectDuration,
          priorityLevel: priorityLevel,
          timestamp: commitTime,
          updaters: updaters
        });
      });
      dataForRoots.push({
        commitData: commitData,
        displayName: displayName,
        initialTreeBaseDurations: initialTreeBaseDurations,
        rootID: rootID
      });
    });
    var timelineData = null;

    if (typeof getTimelineData === 'function') {
      var currentTimelineData = getTimelineData();

      if (currentTimelineData) {
        var batchUIDToMeasuresMap = currentTimelineData.batchUIDToMeasuresMap,
            internalModuleSourceToRanges = currentTimelineData.internalModuleSourceToRanges,
            laneToLabelMap = currentTimelineData.laneToLabelMap,
            laneToReactMeasureMap = currentTimelineData.laneToReactMeasureMap,
            rest = _objectWithoutProperties(currentTimelineData, ["batchUIDToMeasuresMap", "internalModuleSourceToRanges", "laneToLabelMap", "laneToReactMeasureMap"]);

        timelineData = _objectSpread(_objectSpread({}, rest), {}, {
          // Most of the data is safe to parse as-is,
          // but we need to convert the nested Arrays back to Maps.
          // Most of the data is safe to serialize as-is,
          // but we need to convert the Maps to nested Arrays.
          batchUIDToMeasuresKeyValueArray: Array.from(batchUIDToMeasuresMap.entries()),
          internalModuleSourceToRanges: Array.from(internalModuleSourceToRanges.entries()),
          laneToLabelKeyValueArray: Array.from(laneToLabelMap.entries()),
          laneToReactMeasureKeyValueArray: Array.from(laneToReactMeasureMap.entries())
        });
      }
    }

    return {
      dataForRoots: dataForRoots,
      rendererID: rendererID,
      timelineData: timelineData
    };
  }

  function startProfiling(shouldRecordChangeDescriptions) {
    if (isProfiling) {
      return;
    }

    recordChangeDescriptions = shouldRecordChangeDescriptions; // Capture initial values as of the time profiling starts.
    // It's important we snapshot both the durations and the id-to-root map,
    // since either of these may change during the profiling session
    // (e.g. when a fiber is re-rendered or when a fiber gets removed).

    displayNamesByRootID = new Map();
    initialTreeBaseDurationsMap = new Map(idToTreeBaseDurationMap);
    initialIDToRootMap = new Map(idToRootMap);
    idToContextsMap = new Map();
    hook.getFiberRoots(rendererID).forEach(function (root) {
      var rootID = getFiberIDThrows(root.current);
      displayNamesByRootID.set(rootID, getDisplayNameForRoot(root.current));

      if (shouldRecordChangeDescriptions) {
        // Record all contexts at the time profiling is started.
        // Fibers only store the current context value,
        // so we need to track them separately in order to determine changed keys.
        crawlToInitializeContextsMap(root.current);
      }
    });
    isProfiling = true;
    profilingStartTime = renderer_getCurrentTime();
    rootToCommitProfilingMetadataMap = new Map();

    if (toggleProfilingStatus !== null) {
      toggleProfilingStatus(true);
    }
  }

  function stopProfiling() {
    isProfiling = false;
    recordChangeDescriptions = false;

    if (toggleProfilingStatus !== null) {
      toggleProfilingStatus(false);
    }
  } // Automatically start profiling so that we don't miss timing info from initial "mount".


  if (Object(storage["c" /* sessionStorageGetItem */])(constants["k" /* SESSION_STORAGE_RELOAD_AND_PROFILE_KEY */]) === 'true') {
    startProfiling(Object(storage["c" /* sessionStorageGetItem */])(constants["j" /* SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY */]) === 'true');
  } // React will switch between these implementations depending on whether
  // we have any manually suspended/errored-out Fibers or not.


  function shouldErrorFiberAlwaysNull() {
    return null;
  } // Map of id and its force error status: true (error), false (toggled off),
  // null (do nothing)


  var forceErrorForFiberIDs = new Map();

  function shouldErrorFiberAccordingToMap(fiber) {
    if (typeof setErrorHandler !== 'function') {
      throw new Error('Expected overrideError() to not get called for earlier React versions.');
    }

    var id = getFiberIDUnsafe(fiber);

    if (id === null) {
      return null;
    }

    var status = null;

    if (forceErrorForFiberIDs.has(id)) {
      status = forceErrorForFiberIDs.get(id);

      if (status === false) {
        // TRICKY overrideError adds entries to this Map,
        // so ideally it would be the method that clears them too,
        // but that would break the functionality of the feature,
        // since DevTools needs to tell React to act differently than it normally would
        // (don't just re-render the failed boundary, but reset its errored state too).
        // So we can only clear it after telling React to reset the state.
        // Technically this is premature and we should schedule it for later,
        // since the render could always fail without committing the updated error boundary,
        // but since this is a DEV-only feature, the simplicity is worth the trade off.
        forceErrorForFiberIDs.delete(id);

        if (forceErrorForFiberIDs.size === 0) {
          // Last override is gone. Switch React back to fast path.
          setErrorHandler(shouldErrorFiberAlwaysNull);
        }
      }
    }

    return status;
  }

  function overrideError(id, forceError) {
    if (typeof setErrorHandler !== 'function' || typeof scheduleUpdate !== 'function') {
      throw new Error('Expected overrideError() to not get called for earlier React versions.');
    }

    forceErrorForFiberIDs.set(id, forceError);

    if (forceErrorForFiberIDs.size === 1) {
      // First override is added. Switch React to slower path.
      setErrorHandler(shouldErrorFiberAccordingToMap);
    }

    var fiber = idToArbitraryFiberMap.get(id);

    if (fiber != null) {
      scheduleUpdate(fiber);
    }
  }

  function shouldSuspendFiberAlwaysFalse() {
    return false;
  }

  var forceFallbackForSuspenseIDs = new Set();

  function shouldSuspendFiberAccordingToSet(fiber) {
    var maybeID = getFiberIDUnsafe(fiber);
    return maybeID !== null && forceFallbackForSuspenseIDs.has(maybeID);
  }

  function overrideSuspense(id, forceFallback) {
    if (typeof setSuspenseHandler !== 'function' || typeof scheduleUpdate !== 'function') {
      throw new Error('Expected overrideSuspense() to not get called for earlier React versions.');
    }

    if (forceFallback) {
      forceFallbackForSuspenseIDs.add(id);

      if (forceFallbackForSuspenseIDs.size === 1) {
        // First override is added. Switch React to slower path.
        setSuspenseHandler(shouldSuspendFiberAccordingToSet);
      }
    } else {
      forceFallbackForSuspenseIDs.delete(id);

      if (forceFallbackForSuspenseIDs.size === 0) {
        // Last override is gone. Switch React back to fast path.
        setSuspenseHandler(shouldSuspendFiberAlwaysFalse);
      }
    }

    var fiber = idToArbitraryFiberMap.get(id);

    if (fiber != null) {
      scheduleUpdate(fiber);
    }
  } // Remember if we're trying to restore the selection after reload.
  // In that case, we'll do some extra checks for matching mounts.


  var trackedPath = null;
  var trackedPathMatchFiber = null;
  var trackedPathMatchDepth = -1;
  var mightBeOnTrackedPath = false;

  function setTrackedPath(path) {
    if (path === null) {
      trackedPathMatchFiber = null;
      trackedPathMatchDepth = -1;
      mightBeOnTrackedPath = false;
    }

    trackedPath = path;
  } // We call this before traversing a new mount.
  // It remembers whether this Fiber is the next best match for tracked path.
  // The return value signals whether we should keep matching siblings or not.


  function updateTrackedPathStateBeforeMount(fiber) {
    if (trackedPath === null || !mightBeOnTrackedPath) {
      // Fast path: there's nothing to track so do nothing and ignore siblings.
      return false;
    }

    var returnFiber = fiber.return;
    var returnAlternate = returnFiber !== null ? returnFiber.alternate : null; // By now we know there's some selection to restore, and this is a new Fiber.
    // Is this newly mounted Fiber a direct child of the current best match?
    // (This will also be true for new roots if we haven't matched anything yet.)

    if (trackedPathMatchFiber === returnFiber || trackedPathMatchFiber === returnAlternate && returnAlternate !== null) {
      // Is this the next Fiber we should select? Let's compare the frames.
      var actualFrame = getPathFrame(fiber); // $FlowFixMe[incompatible-use] found when upgrading Flow

      var expectedFrame = trackedPath[trackedPathMatchDepth + 1];

      if (expectedFrame === undefined) {
        throw new Error('Expected to see a frame at the next depth.');
      }

      if (actualFrame.index === expectedFrame.index && actualFrame.key === expectedFrame.key && actualFrame.displayName === expectedFrame.displayName) {
        // We have our next match.
        trackedPathMatchFiber = fiber;
        trackedPathMatchDepth++; // Are we out of frames to match?
        // $FlowFixMe[incompatible-use] found when upgrading Flow

        if (trackedPathMatchDepth === trackedPath.length - 1) {
          // There's nothing that can possibly match afterwards.
          // Don't check the children.
          mightBeOnTrackedPath = false;
        } else {
          // Check the children, as they might reveal the next match.
          mightBeOnTrackedPath = true;
        } // In either case, since we have a match, we don't need
        // to check the siblings. They'll never match.


        return false;
      }
    } // This Fiber's parent is on the path, but this Fiber itself isn't.
    // There's no need to check its children--they won't be on the path either.


    mightBeOnTrackedPath = false; // However, one of its siblings may be on the path so keep searching.

    return true;
  }

  function updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath) {
    // updateTrackedPathStateBeforeMount() told us whether to match siblings.
    // Now that we're entering siblings, let's use that information.
    mightBeOnTrackedPath = mightSiblingsBeOnTrackedPath;
  } // Roots don't have a real persistent identity.
  // A root's "pseudo key" is "childDisplayName:indexWithThatName".
  // For example, "App:0" or, in case of similar roots, "Story:0", "Story:1", etc.
  // We will use this to try to disambiguate roots when restoring selection between reloads.


  var rootPseudoKeys = new Map();
  var rootDisplayNameCounter = new Map();

  function setRootPseudoKey(id, fiber) {
    var name = getDisplayNameForRoot(fiber);
    var counter = rootDisplayNameCounter.get(name) || 0;
    rootDisplayNameCounter.set(name, counter + 1);
    var pseudoKey = "".concat(name, ":").concat(counter);
    rootPseudoKeys.set(id, pseudoKey);
  }

  function removeRootPseudoKey(id) {
    var pseudoKey = rootPseudoKeys.get(id);

    if (pseudoKey === undefined) {
      throw new Error('Expected root pseudo key to be known.');
    }

    var name = pseudoKey.slice(0, pseudoKey.lastIndexOf(':'));
    var counter = rootDisplayNameCounter.get(name);

    if (counter === undefined) {
      throw new Error('Expected counter to be known.');
    }

    if (counter > 1) {
      rootDisplayNameCounter.set(name, counter - 1);
    } else {
      rootDisplayNameCounter.delete(name);
    }

    rootPseudoKeys.delete(id);
  }

  function getDisplayNameForRoot(fiber) {
    var preferredDisplayName = null;
    var fallbackDisplayName = null;
    var child = fiber.child; // Go at most three levels deep into direct children
    // while searching for a child that has a displayName.

    for (var i = 0; i < 3; i++) {
      if (child === null) {
        break;
      }

      var displayName = getDisplayNameForFiber(child);

      if (displayName !== null) {
        // Prefer display names that we get from user-defined components.
        // We want to avoid using e.g. 'Suspense' unless we find nothing else.
        if (typeof child.type === 'function') {
          // There's a few user-defined tags, but we'll prefer the ones
          // that are usually explicitly named (function or class components).
          preferredDisplayName = displayName;
        } else if (fallbackDisplayName === null) {
          fallbackDisplayName = displayName;
        }
      }

      if (preferredDisplayName !== null) {
        break;
      }

      child = child.child;
    }

    return preferredDisplayName || fallbackDisplayName || 'Anonymous';
  }

  function getPathFrame(fiber) {
    var key = fiber.key;
    var displayName = getDisplayNameForFiber(fiber);
    var index = fiber.index;

    switch (fiber.tag) {
      case HostRoot:
        // Roots don't have a real displayName, index, or key.
        // Instead, we'll use the pseudo key (childDisplayName:indexWithThatName).
        var id = getFiberIDThrows(fiber);
        var pseudoKey = rootPseudoKeys.get(id);

        if (pseudoKey === undefined) {
          throw new Error('Expected mounted root to have known pseudo key.');
        }

        displayName = pseudoKey;
        break;

      case HostComponent:
        displayName = fiber.type;
        break;

      default:
        break;
    }

    return {
      displayName: displayName,
      key: key,
      index: index
    };
  } // Produces a serializable representation that does a best effort
  // of identifying a particular Fiber between page reloads.
  // The return path will contain Fibers that are "invisible" to the store
  // because their keys and indexes are important to restoring the selection.


  function getPathForElement(id) {
    var fiber = idToArbitraryFiberMap.get(id);

    if (fiber == null) {
      return null;
    }

    var keyPath = [];

    while (fiber !== null) {
      // $FlowFixMe[incompatible-call] found when upgrading Flow
      keyPath.push(getPathFrame(fiber)); // $FlowFixMe[incompatible-use] found when upgrading Flow

      fiber = fiber.return;
    }

    keyPath.reverse();
    return keyPath;
  }

  function getBestMatchForTrackedPath() {
    if (trackedPath === null) {
      // Nothing to match.
      return null;
    }

    if (trackedPathMatchFiber === null) {
      // We didn't find anything.
      return null;
    } // Find the closest Fiber store is aware of.


    var fiber = trackedPathMatchFiber;

    while (fiber !== null && shouldFilterFiber(fiber)) {
      fiber = fiber.return;
    }

    if (fiber === null) {
      return null;
    }

    return {
      id: getFiberIDThrows(fiber),
      // $FlowFixMe[incompatible-use] found when upgrading Flow
      isFullMatch: trackedPathMatchDepth === trackedPath.length - 1
    };
  }

  var formatPriorityLevel = function formatPriorityLevel(priorityLevel) {
    if (priorityLevel == null) {
      return 'Unknown';
    }

    switch (priorityLevel) {
      case ImmediatePriority:
        return 'Immediate';

      case UserBlockingPriority:
        return 'User-Blocking';

      case NormalPriority:
        return 'Normal';

      case LowPriority:
        return 'Low';

      case IdlePriority:
        return 'Idle';

      case NoPriority:
      default:
        return 'Unknown';
    }
  };

  function setTraceUpdatesEnabled(isEnabled) {
    traceUpdatesEnabled = isEnabled;
  }

  return {
    cleanup: cleanup,
    clearErrorsAndWarnings: clearErrorsAndWarnings,
    clearErrorsForFiberID: clearErrorsForFiberID,
    clearWarningsForFiberID: clearWarningsForFiberID,
    getSerializedElementValueByPath: getSerializedElementValueByPath,
    deletePath: deletePath,
    findNativeNodesForFiberID: findNativeNodesForFiberID,
    flushInitialOperations: flushInitialOperations,
    getBestMatchForTrackedPath: getBestMatchForTrackedPath,
    getDisplayNameForFiberID: getDisplayNameForFiberID,
    getFiberForNative: getFiberForNative,
    getFiberIDForNative: getFiberIDForNative,
    getInstanceAndStyle: getInstanceAndStyle,
    getOwnersList: getOwnersList,
    getPathForElement: getPathForElement,
    getProfilingData: getProfilingData,
    handleCommitFiberRoot: handleCommitFiberRoot,
    handleCommitFiberUnmount: handleCommitFiberUnmount,
    handlePostCommitFiberRoot: handlePostCommitFiberRoot,
    inspectElement: inspectElement,
    logElementToConsole: logElementToConsole,
    patchConsoleForStrictMode: backend_console["d" /* patchForStrictMode */],
    prepareViewAttributeSource: prepareViewAttributeSource,
    prepareViewElementSource: prepareViewElementSource,
    overrideError: overrideError,
    overrideSuspense: overrideSuspense,
    overrideValueAtPath: overrideValueAtPath,
    renamePath: renamePath,
    renderer: renderer,
    setTraceUpdatesEnabled: setTraceUpdatesEnabled,
    setTrackedPath: setTrackedPath,
    startProfiling: startProfiling,
    stopProfiling: stopProfiling,
    storeAsGlobal: storeAsGlobal,
    unpatchConsoleForStrictMode: backend_console["f" /* unpatchForStrictMode */],
    updateComponentFilters: updateComponentFilters
  };
}

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ describeFiber; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ getStackByFiberInDevAndProd; });

// EXTERNAL MODULE: ../react-devtools-shared/src/backend/ReactSymbols.js
var ReactSymbols = __webpack_require__(3);

// CONCATENATED MODULE: ../react-devtools-shared/src/backend/DevToolsConsolePatching.js
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// This is a DevTools fork of shared/ConsolePatchingDev.
// The shared console patching code is DEV-only.
// We can't use it since DevTools only ships production builds.
// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  if (disabledDepth === 0) {
    /* eslint-disable react-internal/no-production-logging */
    prevLog = console.log;
    prevInfo = console.info;
    prevWarn = console.warn;
    prevError = console.error;
    prevGroup = console.group;
    prevGroupCollapsed = console.groupCollapsed;
    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

    var props = {
      configurable: true,
      enumerable: true,
      value: disabledLog,
      writable: true
    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.

    Object.defineProperties(console, {
      info: props,
      log: props,
      warn: props,
      error: props,
      group: props,
      groupCollapsed: props,
      groupEnd: props
    });
    /* eslint-enable react-internal/no-production-logging */
  }

  disabledDepth++;
}
function reenableLogs() {
  disabledDepth--;

  if (disabledDepth === 0) {
    /* eslint-disable react-internal/no-production-logging */
    var props = {
      configurable: true,
      enumerable: true,
      writable: true
    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.

    Object.defineProperties(console, {
      log: _objectSpread(_objectSpread({}, props), {}, {
        value: prevLog
      }),
      info: _objectSpread(_objectSpread({}, props), {}, {
        value: prevInfo
      }),
      warn: _objectSpread(_objectSpread({}, props), {}, {
        value: prevWarn
      }),
      error: _objectSpread(_objectSpread({}, props), {}, {
        value: prevError
      }),
      group: _objectSpread(_objectSpread({}, props), {}, {
        value: prevGroup
      }),
      groupCollapsed: _objectSpread(_objectSpread({}, props), {}, {
        value: prevGroupCollapsed
      }),
      groupEnd: _objectSpread(_objectSpread({}, props), {}, {
        value: prevGroupEnd
      })
    });
    /* eslint-enable react-internal/no-production-logging */
  }

  if (disabledDepth < 0) {
    console.error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
  }
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/DevToolsComponentStackFrame.js
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// This is a DevTools fork of ReactComponentStackFrame.
// This fork enables DevTools to use the same "native" component stack format,
// while still maintaining support for multiple renderer versions
// (which use different values for ReactTypeOfWork).
 // The shared console patching code is DEV-only.
// We can't use it since DevTools only ships production builds.


var prefix;
function describeBuiltInComponentFrame(name, ownerFn) {
  if (prefix === undefined) {
    // Extract the VM specific prefix used by each line.
    try {
      throw Error();
    } catch (x) {
      var match = x.stack.trim().match(/\n( *(at )?)/);
      prefix = match && match[1] || '';
    }
  } // We use the prefix to ensure our stacks line up with native stack frames.


  return '\n' + prefix + name;
}
var reentry = false;
var componentFrameCache;

if (false) { var PossiblyWeakMap; }

function describeNativeComponentFrame(fn, construct, currentDispatcherRef) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  if (false) { var frame; }

  var control;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.

  Error.prepareStackTrace = undefined;
  reentry = true; // Override the dispatcher so effects scheduled by this shallow render are thrown away.
  //
  // Note that unlike the code this was forked from (in ReactComponentStackFrame)
  // DevTools should override the dispatcher even when DevTools is compiled in production mode,
  // because the app itself may be in development mode and log errors/warnings.

  var previousDispatcher = currentDispatcherRef.current;
  currentDispatcherRef.current = null;
  disableLogs();

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function Fake() {
        throw Error();
      }; // $FlowFixMe[prop-missing]


      Object.defineProperty(Fake.prototype, 'props', {
        set: function set() {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        } // $FlowFixMe[prop-missing] found when upgrading Flow


        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                if (false) {} // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;
    Error.prepareStackTrace = previousPrepareStackTrace;
    currentDispatcherRef.current = previousDispatcher;
    reenableLogs();
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  if (false) {}

  return syntheticFrame;
}
function describeClassComponentFrame(ctor, ownerFn, currentDispatcherRef) {
  return describeNativeComponentFrame(ctor, true, currentDispatcherRef);
}
function describeFunctionComponentFrame(fn, ownerFn, currentDispatcherRef) {
  return describeNativeComponentFrame(fn, false, currentDispatcherRef);
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, ownerFn, currentDispatcherRef) {
  if (true) {
    return '';
  }

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    return describeNativeComponentFrame(type, shouldConstruct(type), currentDispatcherRef);
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type, ownerFn);
  }

  switch (type) {
    case ReactSymbols["w" /* SUSPENSE_NUMBER */]:
    case ReactSymbols["x" /* SUSPENSE_SYMBOL_STRING */]:
      return describeBuiltInComponentFrame('Suspense', ownerFn);

    case ReactSymbols["u" /* SUSPENSE_LIST_NUMBER */]:
    case ReactSymbols["v" /* SUSPENSE_LIST_SYMBOL_STRING */]:
      return describeBuiltInComponentFrame('SuspenseList', ownerFn);
  }

  if (_typeof(type) === 'object') {
    switch (type.$$typeof) {
      case ReactSymbols["f" /* FORWARD_REF_NUMBER */]:
      case ReactSymbols["g" /* FORWARD_REF_SYMBOL_STRING */]:
        return describeFunctionComponentFrame(type.render, ownerFn, currentDispatcherRef);

      case ReactSymbols["j" /* MEMO_NUMBER */]:
      case ReactSymbols["k" /* MEMO_SYMBOL_STRING */]:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn, currentDispatcherRef);

      case ReactSymbols["h" /* LAZY_NUMBER */]:
      case ReactSymbols["i" /* LAZY_SYMBOL_STRING */]:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn, currentDispatcherRef);
          } catch (x) {}
        }
    }
  }

  return '';
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/DevToolsFiberComponentStack.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// This is a DevTools fork of ReactFiberComponentStack.
// This fork enables DevTools to use the same "native" component stack format,
// while still maintaining support for multiple renderer versions
// (which use different values for ReactTypeOfWork).

function describeFiber(workTagMap, workInProgress, currentDispatcherRef) {
  var HostComponent = workTagMap.HostComponent,
      LazyComponent = workTagMap.LazyComponent,
      SuspenseComponent = workTagMap.SuspenseComponent,
      SuspenseListComponent = workTagMap.SuspenseListComponent,
      FunctionComponent = workTagMap.FunctionComponent,
      IndeterminateComponent = workTagMap.IndeterminateComponent,
      SimpleMemoComponent = workTagMap.SimpleMemoComponent,
      ForwardRef = workTagMap.ForwardRef,
      ClassComponent = workTagMap.ClassComponent;
  var owner =  false ? undefined : null;

  switch (workInProgress.tag) {
    case HostComponent:
      return describeBuiltInComponentFrame(workInProgress.type, owner);

    case LazyComponent:
      return describeBuiltInComponentFrame('Lazy', owner);

    case SuspenseComponent:
      return describeBuiltInComponentFrame('Suspense', owner);

    case SuspenseListComponent:
      return describeBuiltInComponentFrame('SuspenseList', owner);

    case FunctionComponent:
    case IndeterminateComponent:
    case SimpleMemoComponent:
      return describeFunctionComponentFrame(workInProgress.type, owner, currentDispatcherRef);

    case ForwardRef:
      return describeFunctionComponentFrame(workInProgress.type.render, owner, currentDispatcherRef);

    case ClassComponent:
      return describeClassComponentFrame(workInProgress.type, owner, currentDispatcherRef);

    default:
      return '';
  }
}
function getStackByFiberInDevAndProd(workTagMap, workInProgress, currentDispatcherRef) {
  try {
    var info = '';
    var node = workInProgress;

    do {
      info += describeFiber(workTagMap, node, currentDispatcherRef); // $FlowFixMe[incompatible-type] we bail out when we get a null

      node = node.return;
    } while (node);

    return info;
  } catch (x) {
    return '\nError generating stack: ' + x.message + '\n' + x.stack;
  }
}

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export REACT_ELEMENT_TYPE */
/* unused harmony export REACT_PORTAL_TYPE */
/* unused harmony export REACT_FRAGMENT_TYPE */
/* unused harmony export REACT_STRICT_MODE_TYPE */
/* unused harmony export REACT_PROFILER_TYPE */
/* unused harmony export REACT_PROVIDER_TYPE */
/* unused harmony export REACT_CONTEXT_TYPE */
/* unused harmony export REACT_SERVER_CONTEXT_TYPE */
/* unused harmony export REACT_FORWARD_REF_TYPE */
/* unused harmony export REACT_SUSPENSE_TYPE */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return REACT_SUSPENSE_LIST_TYPE; });
/* unused harmony export REACT_MEMO_TYPE */
/* unused harmony export REACT_LAZY_TYPE */
/* unused harmony export REACT_SCOPE_TYPE */
/* unused harmony export REACT_DEBUG_TRACING_MODE_TYPE */
/* unused harmony export REACT_OFFSCREEN_TYPE */
/* unused harmony export REACT_LEGACY_HIDDEN_TYPE */
/* unused harmony export REACT_CACHE_TYPE */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return REACT_TRACING_MARKER_TYPE; });
/* unused harmony export REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED */
/* unused harmony export REACT_MEMO_CACHE_SENTINEL */
/* unused harmony export getIteratorFn */
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types.
var REACT_ELEMENT_TYPE = Symbol.for('react.element');
var REACT_PORTAL_TYPE = Symbol.for('react.portal');
var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
var REACT_CONTEXT_TYPE = Symbol.for('react.context');
var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
var REACT_MEMO_TYPE = Symbol.for('react.memo');
var REACT_LAZY_TYPE = Symbol.for('react.lazy');
var REACT_SCOPE_TYPE = Symbol.for('react.scope');
var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for('react.debug_trace_mode');
var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
var REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden');
var REACT_CACHE_TYPE = Symbol.for('react.cache');
var REACT_TRACING_MARKER_TYPE = Symbol.for('react.tracing_marker');
var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');
var REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');
var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || _typeof(maybeIterable) !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

/***/ }),
/* 16 */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // A linked list to keep track of recently-used-ness

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Yallist = __webpack_require__(20);

var MAX = Symbol('max');
var LENGTH = Symbol('length');
var LENGTH_CALCULATOR = Symbol('lengthCalculator');
var ALLOW_STALE = Symbol('allowStale');
var MAX_AGE = Symbol('maxAge');
var DISPOSE = Symbol('dispose');
var NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
var LRU_LIST = Symbol('lruList');
var CACHE = Symbol('cache');
var UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');

var naiveLength = function naiveLength() {
  return 1;
}; // lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.


var LRUCache = /*#__PURE__*/function () {
  function LRUCache(options) {
    _classCallCheck(this, LRUCache);

    if (typeof options === 'number') options = {
      max: options
    };
    if (!options) options = {};
    if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number'); // Kind of weird to have a default max of Infinity, but oh well.

    var max = this[MAX] = options.max || Infinity;
    var lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== 'function' ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  } // resize the cache when the max changes.


  _createClass(LRUCache, [{
    key: "rforEach",
    value: function rforEach(fn, thisp) {
      thisp = thisp || this;

      for (var walker = this[LRU_LIST].tail; walker !== null;) {
        var prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
  }, {
    key: "forEach",
    value: function forEach(fn, thisp) {
      thisp = thisp || this;

      for (var walker = this[LRU_LIST].head; walker !== null;) {
        var next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
  }, {
    key: "keys",
    value: function keys() {
      return this[LRU_LIST].toArray().map(function (k) {
        return k.key;
      });
    }
  }, {
    key: "values",
    value: function values() {
      return this[LRU_LIST].toArray().map(function (k) {
        return k.value;
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      var _this = this;

      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach(function (hit) {
          return _this[DISPOSE](hit.key, hit.value);
        });
      }

      this[CACHE] = new Map(); // hash of items by key

      this[LRU_LIST] = new Yallist(); // list of items in order of use recency

      this[LENGTH] = 0; // length of items in the list
    }
  }, {
    key: "dump",
    value: function dump() {
      var _this2 = this;

      return this[LRU_LIST].map(function (hit) {
        return isStale(_this2, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        };
      }).toArray().filter(function (h) {
        return h;
      });
    }
  }, {
    key: "dumpLru",
    value: function dumpLru() {
      return this[LRU_LIST];
    }
  }, {
    key: "set",
    value: function set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');
      var now = maxAge ? Date.now() : 0;
      var len = this[LENGTH_CALCULATOR](value, key);

      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          _del(this, this[CACHE].get(key));

          return false;
        }

        var node = this[CACHE].get(key);
        var item = node.value; // dispose of the old one before overwriting
        // split out into 2 ifs for better coverage tracking

        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);
        }

        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }

      var hit = new Entry(key, value, len, now, maxAge); // oversized objects fall out of cache automatically.

      if (hit.length > this[MAX]) {
        if (this[DISPOSE]) this[DISPOSE](key, value);
        return false;
      }

      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    }
  }, {
    key: "has",
    value: function has(key) {
      if (!this[CACHE].has(key)) return false;
      var hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
  }, {
    key: "get",
    value: function get(key) {
      return _get(this, key, true);
    }
  }, {
    key: "peek",
    value: function peek(key) {
      return _get(this, key, false);
    }
  }, {
    key: "pop",
    value: function pop() {
      var node = this[LRU_LIST].tail;
      if (!node) return null;

      _del(this, node);

      return node.value;
    }
  }, {
    key: "del",
    value: function del(key) {
      _del(this, this[CACHE].get(key));
    }
  }, {
    key: "load",
    value: function load(arr) {
      // reset the cache
      this.reset();
      var now = Date.now(); // A previous serialized cache has the most recent items first

      for (var l = arr.length - 1; l >= 0; l--) {
        var hit = arr[l];
        var expiresAt = hit.e || 0;
        if (expiresAt === 0) // the item was created without expiration in a non aged cache
          this.set(hit.k, hit.v);else {
          var maxAge = expiresAt - now; // dont add already expired items

          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
  }, {
    key: "prune",
    value: function prune() {
      var _this3 = this;

      this[CACHE].forEach(function (value, key) {
        return _get(_this3, key, false);
      });
    }
  }, {
    key: "max",
    set: function set(mL) {
      if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');
      this[MAX] = mL || Infinity;
      trim(this);
    },
    get: function get() {
      return this[MAX];
    }
  }, {
    key: "allowStale",
    set: function set(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    },
    get: function get() {
      return this[ALLOW_STALE];
    }
  }, {
    key: "maxAge",
    set: function set(mA) {
      if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');
      this[MAX_AGE] = mA;
      trim(this);
    },
    get: function get() {
      return this[MAX_AGE];
    } // resize the cache when the lengthCalculator changes.

  }, {
    key: "lengthCalculator",
    set: function set(lC) {
      var _this4 = this;

      if (typeof lC !== 'function') lC = naiveLength;

      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach(function (hit) {
          hit.length = _this4[LENGTH_CALCULATOR](hit.value, hit.key);
          _this4[LENGTH] += hit.length;
        });
      }

      trim(this);
    },
    get: function get() {
      return this[LENGTH_CALCULATOR];
    }
  }, {
    key: "length",
    get: function get() {
      return this[LENGTH];
    }
  }, {
    key: "itemCount",
    get: function get() {
      return this[LRU_LIST].length;
    }
  }]);

  return LRUCache;
}();

var _get = function _get(self, key, doUse) {
  var node = self[CACHE].get(key);

  if (node) {
    var hit = node.value;

    if (isStale(self, hit)) {
      _del(self, node);

      if (!self[ALLOW_STALE]) return undefined;
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
        self[LRU_LIST].unshiftNode(node);
      }
    }

    return hit.value;
  }
};

var isStale = function isStale(self, hit) {
  if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;
  var diff = Date.now() - hit.now;
  return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
};

var trim = function trim(self) {
  if (self[LENGTH] > self[MAX]) {
    for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      var prev = walker.prev;

      _del(self, walker);

      walker = prev;
    }
  }
};

var _del = function _del(self, node) {
  if (node) {
    var hit = node.value;
    if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);
    self[LENGTH] -= hit.length;
    self[CACHE].delete(hit.key);
    self[LRU_LIST].removeNode(node);
  }
};

var Entry = function Entry(key, value, length, now, maxAge) {
  _classCallCheck(this, Entry);

  this.key = key;
  this.value = value;
  this.length = length;
  this.now = now;
  this.maxAge = maxAge || 0;
};

var forEachStep = function forEachStep(self, fn, node, thisp) {
  var hit = node.value;

  if (isStale(self, hit)) {
    _del(self, node);

    if (!self[ALLOW_STALE]) hit = undefined;
  }

  if (hit) fn.call(thisp, hit.value, hit.key, self);
};

module.exports = LRUCache;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(23);
} else {}

/***/ }),
/* 19 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Yallist;
Yallist.Node = Node;
Yallist.create = Yallist;

function Yallist(list) {
  var self = this;

  if (!(self instanceof Yallist)) {
    self = new Yallist();
  }

  self.tail = null;
  self.head = null;
  self.length = 0;

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i]);
    }
  }

  return self;
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list');
  }

  var next = node.next;
  var prev = node.prev;

  if (next) {
    next.prev = prev;
  }

  if (prev) {
    prev.next = next;
  }

  if (node === this.head) {
    this.head = next;
  }

  if (node === this.tail) {
    this.tail = prev;
  }

  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return;
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var head = this.head;
  node.list = this;
  node.next = head;

  if (head) {
    head.prev = node;
  }

  this.head = node;

  if (!this.tail) {
    this.tail = node;
  }

  this.length++;
};

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return;
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var tail = this.tail;
  node.list = this;
  node.prev = tail;

  if (tail) {
    tail.next = node;
  }

  this.tail = node;

  if (!this.head) {
    this.head = node;
  }

  this.length++;
};

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i]);
  }

  return this.length;
};

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i]);
  }

  return this.length;
};

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined;
  }

  var res = this.tail.value;
  this.tail = this.tail.prev;

  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }

  this.length--;
  return res;
};

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined;
  }

  var res = this.head.value;
  this.head = this.head.next;

  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }

  this.length--;
  return res;
};

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this;

  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this;

  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next;
  }

  if (i === n && walker !== null) {
    return walker.value;
  }
};

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev;
  }

  if (i === n && walker !== null) {
    return walker.value;
  }
};

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist();

  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }

  return res;
};

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist();

  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }

  return res;
};

Yallist.prototype.reduce = function (fn, initial) {
  var acc;
  var walker = this.head;

  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }

  return acc;
};

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc;
  var walker = this.tail;

  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }

  return acc;
};

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length);

  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }

  return arr;
};

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length);

  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }

  return arr;
};

Yallist.prototype.slice = function (from, to) {
  to = to || this.length;

  if (to < 0) {
    to += this.length;
  }

  from = from || 0;

  if (from < 0) {
    from += this.length;
  }

  var ret = new Yallist();

  if (to < from || to < 0) {
    return ret;
  }

  if (from < 0) {
    from = 0;
  }

  if (to > this.length) {
    to = this.length;
  }

  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next;
  }

  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }

  return ret;
};

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length;

  if (to < 0) {
    to += this.length;
  }

  from = from || 0;

  if (from < 0) {
    from += this.length;
  }

  var ret = new Yallist();

  if (to < from || to < 0) {
    return ret;
  }

  if (from < 0) {
    from = 0;
  }

  if (to > this.length) {
    to = this.length;
  }

  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }

  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value);
  }

  return ret;
};

Yallist.prototype.splice = function (start, deleteCount
/*, ...nodes */
) {
  if (start > this.length) {
    start = this.length - 1;
  }

  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }

  var ret = [];

  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }

  if (walker === null) {
    walker = this.tail;
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }

  for (var i = 2; i < arguments.length; i++) {
    walker = insert(this, walker, arguments[i]);
  }

  return ret;
};

Yallist.prototype.reverse = function () {
  var head = this.head;
  var tail = this.tail;

  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }

  this.head = tail;
  this.tail = head;
  return this;
};

function insert(self, node, value) {
  var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);

  if (inserted.next === null) {
    self.tail = inserted;
  }

  if (inserted.prev === null) {
    self.head = inserted;
  }

  self.length++;
  return inserted;
}

function push(self, item) {
  self.tail = new Node(item, self.tail, null, self);

  if (!self.head) {
    self.head = self.tail;
  }

  self.length++;
}

function unshift(self, item) {
  self.head = new Node(item, null, self.head, self);

  if (!self.tail) {
    self.tail = self.head;
  }

  self.length++;
}

function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }

  this.list = list;
  this.value = value;

  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }

  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}

try {
  // add if support for Symbol.iterator is present
  __webpack_require__(21)(Yallist);
} catch (er) {}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    var walker;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            walker = this.head;

          case 1:
            if (!walker) {
              _context.next = 7;
              break;
            }

            _context.next = 4;
            return walker.value;

          case 4:
            walker = walker.next;
            _context.next = 1;
            break;

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  });
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var b = Symbol.for("react.element"),
    c = Symbol.for("react.portal"),
    d = Symbol.for("react.fragment"),
    e = Symbol.for("react.strict_mode"),
    f = Symbol.for("react.profiler"),
    g = Symbol.for("react.provider"),
    h = Symbol.for("react.context"),
    k = Symbol.for("react.server_context"),
    l = Symbol.for("react.forward_ref"),
    m = Symbol.for("react.suspense"),
    n = Symbol.for("react.suspense_list"),
    p = Symbol.for("react.memo"),
    q = Symbol.for("react.lazy"),
    t = Symbol.for("react.offscreen"),
    u = Symbol.for("react.cache"),
    v = Symbol.for("react.client.reference");

function w(a) {
  if ("object" === _typeof(a) && null !== a) {
    var r = a.$$typeof;

    switch (r) {
      case b:
        switch (a = a.type, a) {
          case d:
          case f:
          case e:
          case m:
          case n:
            return a;

          default:
            switch (a = a && a.$$typeof, a) {
              case k:
              case h:
              case l:
              case q:
              case p:
              case g:
                return a;

              default:
                return r;
            }

        }

      case c:
        return r;
    }
  }
}

exports.ContextConsumer = h;
exports.ContextProvider = g;
exports.Element = b;
exports.ForwardRef = l;
exports.Fragment = d;
exports.Lazy = q;
exports.Memo = p;
exports.Portal = c;
exports.Profiler = f;
exports.StrictMode = e;
exports.Suspense = m;
exports.SuspenseList = n;

exports.isAsyncMode = function () {
  return !1;
};

exports.isConcurrentMode = function () {
  return !1;
};

exports.isContextConsumer = function (a) {
  return w(a) === h;
};

exports.isContextProvider = function (a) {
  return w(a) === g;
};

exports.isElement = function (a) {
  return "object" === _typeof(a) && null !== a && a.$$typeof === b;
};

exports.isForwardRef = function (a) {
  return w(a) === l;
};

exports.isFragment = function (a) {
  return w(a) === d;
};

exports.isLazy = function (a) {
  return w(a) === q;
};

exports.isMemo = function (a) {
  return w(a) === p;
};

exports.isPortal = function (a) {
  return w(a) === c;
};

exports.isProfiler = function (a) {
  return w(a) === f;
};

exports.isStrictMode = function (a) {
  return w(a) === e;
};

exports.isSuspense = function (a) {
  return w(a) === m;
};

exports.isSuspenseList = function (a) {
  return w(a) === n;
};

exports.isValidElementType = function (a) {
  return "string" === typeof a || "function" === typeof a || a === d || a === f || a === e || a === m || a === n || a === t || a === u || "object" === _typeof(a) && null !== a && (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l || a.$$typeof === v || void 0 !== a.getModuleId) ? !0 : !1;
};

exports.typeOf = w;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @license React
 * react-debug-tools.production.min.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var h = __webpack_require__(24),
    p = __webpack_require__(26),
    q = Object.assign,
    w = p.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    x = [],
    y = null;

function z() {
  if (null === y) {
    var a = new Map();

    try {
      A.useContext({
        _currentValue: null
      }), A.useState(null), A.useReducer(function (c) {
        return c;
      }, null), A.useRef(null), "function" === typeof A.useCacheRefresh && A.useCacheRefresh(), A.useLayoutEffect(function () {}), A.useInsertionEffect(function () {}), A.useEffect(function () {}), A.useImperativeHandle(void 0, function () {
        return null;
      }), A.useDebugValue(null), A.useCallback(function () {}), A.useMemo(function () {
        return null;
      });
    } finally {
      var b = x;
      x = [];
    }

    for (var e = 0; e < b.length; e++) {
      var g = b[e];
      a.set(g.primitive, h.parse(g.stackError));
    }

    y = a;
  }

  return y;
}

var B = null;

function C() {
  var a = B;
  null !== a && (B = a.next);
  return a;
}

var A = {
  readContext: function readContext(a) {
    return a._currentValue;
  },
  useCacheRefresh: function useCacheRefresh() {
    var a = C();
    x.push({
      primitive: "CacheRefresh",
      stackError: Error(),
      value: null !== a ? a.memoizedState : function () {}
    });
    return function () {};
  },
  useCallback: function useCallback(a) {
    var b = C();
    x.push({
      primitive: "Callback",
      stackError: Error(),
      value: null !== b ? b.memoizedState[0] : a
    });
    return a;
  },
  useContext: function useContext(a) {
    x.push({
      primitive: "Context",
      stackError: Error(),
      value: a._currentValue
    });
    return a._currentValue;
  },
  useEffect: function useEffect(a) {
    C();
    x.push({
      primitive: "Effect",
      stackError: Error(),
      value: a
    });
  },
  useImperativeHandle: function useImperativeHandle(a) {
    C();
    var b = void 0;
    null !== a && "object" === _typeof(a) && (b = a.current);
    x.push({
      primitive: "ImperativeHandle",
      stackError: Error(),
      value: b
    });
  },
  useDebugValue: function useDebugValue(a, b) {
    x.push({
      primitive: "DebugValue",
      stackError: Error(),
      value: "function" === typeof b ? b(a) : a
    });
  },
  useLayoutEffect: function useLayoutEffect(a) {
    C();
    x.push({
      primitive: "LayoutEffect",
      stackError: Error(),
      value: a
    });
  },
  useInsertionEffect: function useInsertionEffect(a) {
    C();
    x.push({
      primitive: "InsertionEffect",
      stackError: Error(),
      value: a
    });
  },
  useMemo: function useMemo(a) {
    var b = C();
    a = null !== b ? b.memoizedState[0] : a();
    x.push({
      primitive: "Memo",
      stackError: Error(),
      value: a
    });
    return a;
  },
  useReducer: function useReducer(a, b, e) {
    a = C();
    b = null !== a ? a.memoizedState : void 0 !== e ? e(b) : b;
    x.push({
      primitive: "Reducer",
      stackError: Error(),
      value: b
    });
    return [b, function () {}];
  },
  useRef: function useRef(a) {
    var b = C();
    a = null !== b ? b.memoizedState : {
      current: a
    };
    x.push({
      primitive: "Ref",
      stackError: Error(),
      value: a.current
    });
    return a;
  },
  useState: function useState(a) {
    var b = C();
    a = null !== b ? b.memoizedState : "function" === typeof a ? a() : a;
    x.push({
      primitive: "State",
      stackError: Error(),
      value: a
    });
    return [a, function () {}];
  },
  useTransition: function useTransition() {
    C();
    C();
    x.push({
      primitive: "Transition",
      stackError: Error(),
      value: void 0
    });
    return [!1, function () {}];
  },
  useMutableSource: function useMutableSource(a, b) {
    C();
    C();
    C();
    C();
    a = b(a._source);
    x.push({
      primitive: "MutableSource",
      stackError: Error(),
      value: a
    });
    return a;
  },
  useSyncExternalStore: function useSyncExternalStore(a, b) {
    C();
    C();
    a = b();
    x.push({
      primitive: "SyncExternalStore",
      stackError: Error(),
      value: a
    });
    return a;
  },
  useDeferredValue: function useDeferredValue(a) {
    var b = C();
    x.push({
      primitive: "DeferredValue",
      stackError: Error(),
      value: null !== b ? b.memoizedState : a
    });
    return a;
  },
  useId: function useId() {
    var a = C();
    a = null !== a ? a.memoizedState : "";
    x.push({
      primitive: "Id",
      stackError: Error(),
      value: a
    });
    return a;
  }
},
    D = {
  get: function get(a, b) {
    if (a.hasOwnProperty(b)) return a[b];
    a = Error("Missing method in Dispatcher: " + b);
    a.name = "ReactDebugToolsUnsupportedHookError";
    throw a;
  }
},
    E = "undefined" === typeof Proxy ? A : new Proxy(A, D),
    F = 0;

function G(a, b, e) {
  var g = b[e].source,
      c = 0;

  a: for (; c < a.length; c++) {
    if (a[c].source === g) {
      for (var k = e + 1, r = c + 1; k < b.length && r < a.length; k++, r++) {
        if (a[r].source !== b[k].source) continue a;
      }

      return c;
    }
  }

  return -1;
}

function H(a, b) {
  if (!a) return !1;
  b = "use" + b;
  return a.length < b.length ? !1 : a.lastIndexOf(b) === a.length - b.length;
}

function I(a, b, e) {
  for (var g = [], c = null, k = g, r = 0, t = [], v = 0; v < b.length; v++) {
    var u = b[v];
    var d = a;
    var l = h.parse(u.stackError);

    b: {
      var m = l,
          n = G(m, d, F);
      if (-1 !== n) d = n;else {
        for (var f = 0; f < d.length && 5 > f; f++) {
          if (n = G(m, d, f), -1 !== n) {
            F = f;
            d = n;
            break b;
          }
        }

        d = -1;
      }
    }

    b: {
      m = l;
      n = z().get(u.primitive);
      if (void 0 !== n) for (f = 0; f < n.length && f < m.length; f++) {
        if (n[f].source !== m[f].source) {
          f < m.length - 1 && H(m[f].functionName, u.primitive) && f++;
          f < m.length - 1 && H(m[f].functionName, u.primitive) && f++;
          m = f;
          break b;
        }
      }
      m = -1;
    }

    l = -1 === d || -1 === m || 2 > d - m ? null : l.slice(m, d - 1);

    if (null !== l) {
      d = 0;

      if (null !== c) {
        for (; d < l.length && d < c.length && l[l.length - d - 1].source === c[c.length - d - 1].source;) {
          d++;
        }

        for (c = c.length - 1; c > d; c--) {
          k = t.pop();
        }
      }

      for (c = l.length - d - 1; 1 <= c; c--) {
        d = [], m = l[c], (n = l[c - 1].functionName) ? (f = n.lastIndexOf("."), -1 === f && (f = 0), "use" === n.slice(f, f + 3) && (f += 3), n = n.slice(f)) : n = "", n = {
          id: null,
          isStateEditable: !1,
          name: n,
          value: void 0,
          subHooks: d
        }, e && (n.hookSource = {
          lineNumber: m.lineNumber,
          columnNumber: m.columnNumber,
          functionName: m.functionName,
          fileName: m.fileName
        }), k.push(n), t.push(k), k = d;
      }

      c = l;
    }

    d = u.primitive;
    u = {
      id: "Context" === d || "DebugValue" === d ? null : r++,
      isStateEditable: "Reducer" === d || "State" === d,
      name: d,
      value: u.value,
      subHooks: []
    };
    e && (d = {
      lineNumber: null,
      functionName: null,
      fileName: null,
      columnNumber: null
    }, l && 1 <= l.length && (l = l[0], d.lineNumber = l.lineNumber, d.functionName = l.functionName, d.fileName = l.fileName, d.columnNumber = l.columnNumber), u.hookSource = d);
    k.push(u);
  }

  J(g, null);
  return g;
}

function J(a, b) {
  for (var e = [], g = 0; g < a.length; g++) {
    var c = a[g];
    "DebugValue" === c.name && 0 === c.subHooks.length ? (a.splice(g, 1), g--, e.push(c)) : J(c.subHooks, c);
  }

  null !== b && (1 === e.length ? b.value = e[0].value : 1 < e.length && (b.value = e.map(function (k) {
    return k.value;
  })));
}

function K(a) {
  if (a instanceof Error && "ReactDebugToolsUnsupportedHookError" === a.name) throw a;
  var b = Error("Error rendering inspected component", {
    cause: a
  });
  b.name = "ReactDebugToolsRenderError";
  b.cause = a;
  throw b;
}

function L(a, b, e) {
  var g = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : !1;
  null == e && (e = w.ReactCurrentDispatcher);
  var c = e.current;
  e.current = E;

  try {
    var k = Error();
    a(b);
  } catch (t) {
    K(t);
  } finally {
    var r = x;
    x = [];
    e.current = c;
  }

  c = h.parse(k);
  return I(c, r, g);
}

function M(a) {
  a.forEach(function (b, e) {
    return e._currentValue = b;
  });
}

exports.inspectHooks = L;

exports.inspectHooksOfFiber = function (a, b) {
  var e = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : !1;
  null == b && (b = w.ReactCurrentDispatcher);
  if (0 !== a.tag && 15 !== a.tag && 11 !== a.tag) throw Error("Unknown Fiber. Needs to be a function component to inspect hooks.");
  z();
  var g = a.type,
      c = a.memoizedProps;

  if (g !== a.elementType && g && g.defaultProps) {
    c = q({}, c);
    var k = g.defaultProps;

    for (r in k) {
      void 0 === c[r] && (c[r] = k[r]);
    }
  }

  B = a.memoizedState;
  var r = new Map();

  try {
    for (k = a; k;) {
      if (10 === k.tag) {
        var t = k.type._context;
        r.has(t) || (r.set(t, t._currentValue), t._currentValue = k.memoizedProps.value);
      }

      k = k.return;
    }

    if (11 === a.tag) {
      var v = g.render;
      g = c;
      var u = a.ref;
      t = b;
      var d = t.current;
      t.current = E;

      try {
        var l = Error();
        v(g, u);
      } catch (f) {
        K(f);
      } finally {
        var m = x;
        x = [];
        t.current = d;
      }

      var n = h.parse(l);
      return I(n, m, e);
    }

    return L(g, c, b, e);
  } finally {
    B = null, M(r);
  }
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (root, factory) {
  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

  /* istanbul ignore next */

  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(25)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function ErrorStackParser(StackFrame) {
  'use strict';

  var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
  var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
  var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;
  return {
    /**
     * Given an Error object, extract the most information from it.
     *
     * @param {Error} error object
     * @return {Array} of StackFrames
     */
    parse: function ErrorStackParser$$parse(error) {
      if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
        return this.parseOpera(error);
      } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
        return this.parseV8OrIE(error);
      } else if (error.stack) {
        return this.parseFFOrSafari(error);
      } else {
        throw new Error('Cannot parse given Error object');
      }
    },
    // Separate line and column numbers from a string of the form: (URI:Line:Column)
    extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
      // Fail-fast but return locations like "(native)"
      if (urlLike.indexOf(':') === -1) {
        return [urlLike];
      }

      var regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
      var parts = regExp.exec(urlLike.replace(/[()]/g, ''));
      return [parts[1], parts[2] || undefined, parts[3] || undefined];
    },
    parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
      var filtered = error.stack.split('\n').filter(function (line) {
        return !!line.match(CHROME_IE_STACK_REGEXP);
      }, this);
      return filtered.map(function (line) {
        if (line.indexOf('(eval ') > -1) {
          // Throw away eval information until we implement stacktrace.js/stackframe#8
          line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^()]*)|(\),.*$)/g, '');
        }

        var sanitizedLine = line.replace(/^\s+/, '').replace(/\(eval code/g, '('); // capture and preseve the parenthesized location "(/foo/my bar.js:12:87)" in
        // case it has spaces in it, as the string is split on \s+ later on

        var location = sanitizedLine.match(/ (\((.+):(\d+):(\d+)\)$)/); // remove the parenthesized location from the line, if it was matched

        sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;
        var tokens = sanitizedLine.split(/\s+/).slice(1); // if a location was matched, pass it to extractLocation() otherwise pop the last token

        var locationParts = this.extractLocation(location ? location[1] : tokens.pop());
        var functionName = tokens.join(' ') || undefined;
        var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];
        return new StackFrame({
          functionName: functionName,
          fileName: fileName,
          lineNumber: locationParts[1],
          columnNumber: locationParts[2],
          source: line
        });
      }, this);
    },
    parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
      var filtered = error.stack.split('\n').filter(function (line) {
        return !line.match(SAFARI_NATIVE_CODE_REGEXP);
      }, this);
      return filtered.map(function (line) {
        // Throw away eval information until we implement stacktrace.js/stackframe#8
        if (line.indexOf(' > eval') > -1) {
          line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ':$1');
        }

        if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
          // Safari eval frames only have function names and nothing else
          return new StackFrame({
            functionName: line
          });
        } else {
          var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
          var matches = line.match(functionNameRegex);
          var functionName = matches && matches[1] ? matches[1] : undefined;
          var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));
          return new StackFrame({
            functionName: functionName,
            fileName: locationParts[0],
            lineNumber: locationParts[1],
            columnNumber: locationParts[2],
            source: line
          });
        }
      }, this);
    },
    parseOpera: function ErrorStackParser$$parseOpera(e) {
      if (!e.stacktrace || e.message.indexOf('\n') > -1 && e.message.split('\n').length > e.stacktrace.split('\n').length) {
        return this.parseOpera9(e);
      } else if (!e.stack) {
        return this.parseOpera10(e);
      } else {
        return this.parseOpera11(e);
      }
    },
    parseOpera9: function ErrorStackParser$$parseOpera9(e) {
      var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
      var lines = e.message.split('\n');
      var result = [];

      for (var i = 2, len = lines.length; i < len; i += 2) {
        var match = lineRE.exec(lines[i]);

        if (match) {
          result.push(new StackFrame({
            fileName: match[2],
            lineNumber: match[1],
            source: lines[i]
          }));
        }
      }

      return result;
    },
    parseOpera10: function ErrorStackParser$$parseOpera10(e) {
      var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
      var lines = e.stacktrace.split('\n');
      var result = [];

      for (var i = 0, len = lines.length; i < len; i += 2) {
        var match = lineRE.exec(lines[i]);

        if (match) {
          result.push(new StackFrame({
            functionName: match[3] || undefined,
            fileName: match[2],
            lineNumber: match[1],
            source: lines[i]
          }));
        }
      }

      return result;
    },
    // Opera 10.65+ Error.stack very similar to FF/Safari
    parseOpera11: function ErrorStackParser$$parseOpera11(error) {
      var filtered = error.stack.split('\n').filter(function (line) {
        return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
      }, this);
      return filtered.map(function (line) {
        var tokens = line.split('@');
        var locationParts = this.extractLocation(tokens.pop());
        var functionCall = tokens.shift() || '';
        var functionName = functionCall.replace(/<anonymous function(: (\w+))?>/, '$2').replace(/\([^)]*\)/g, '') || undefined;
        var argsRaw;

        if (functionCall.match(/\(([^)]*)\)/)) {
          argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, '$1');
        }

        var args = argsRaw === undefined || argsRaw === '[arguments not available]' ? undefined : argsRaw.split(',');
        return new StackFrame({
          functionName: functionName,
          args: args,
          fileName: locationParts[0],
          lineNumber: locationParts[1],
          columnNumber: locationParts[2],
          source: line
        });
      }, this);
    }
  };
});

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (root, factory) {
  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

  /* istanbul ignore next */

  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function () {
  'use strict';

  function _isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }

  function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
  }

  function _getter(p) {
    return function () {
      return this[p];
    };
  }

  var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
  var numericProps = ['columnNumber', 'lineNumber'];
  var stringProps = ['fileName', 'functionName', 'source'];
  var arrayProps = ['args'];
  var props = booleanProps.concat(numericProps, stringProps, arrayProps);

  function StackFrame(obj) {
    if (!obj) return;

    for (var i = 0; i < props.length; i++) {
      if (obj[props[i]] !== undefined) {
        this['set' + _capitalize(props[i])](obj[props[i]]);
      }
    }
  }

  StackFrame.prototype = {
    getArgs: function getArgs() {
      return this.args;
    },
    setArgs: function setArgs(v) {
      if (Object.prototype.toString.call(v) !== '[object Array]') {
        throw new TypeError('Args must be an Array');
      }

      this.args = v;
    },
    getEvalOrigin: function getEvalOrigin() {
      return this.evalOrigin;
    },
    setEvalOrigin: function setEvalOrigin(v) {
      if (v instanceof StackFrame) {
        this.evalOrigin = v;
      } else if (v instanceof Object) {
        this.evalOrigin = new StackFrame(v);
      } else {
        throw new TypeError('Eval Origin must be an Object or StackFrame');
      }
    },
    toString: function toString() {
      var fileName = this.getFileName() || '';
      var lineNumber = this.getLineNumber() || '';
      var columnNumber = this.getColumnNumber() || '';
      var functionName = this.getFunctionName() || '';

      if (this.getIsEval()) {
        if (fileName) {
          return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
        }

        return '[eval]:' + lineNumber + ':' + columnNumber;
      }

      if (functionName) {
        return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
      }

      return fileName + ':' + lineNumber + ':' + columnNumber;
    }
  };

  StackFrame.fromString = function StackFrame$$fromString(str) {
    var argsStartIndex = str.indexOf('(');
    var argsEndIndex = str.lastIndexOf(')');
    var functionName = str.substring(0, argsStartIndex);
    var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');
    var locationString = str.substring(argsEndIndex + 1);

    if (locationString.indexOf('@') === 0) {
      var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, '');
      var fileName = parts[1];
      var lineNumber = parts[2];
      var columnNumber = parts[3];
    }

    return new StackFrame({
      functionName: functionName,
      args: args || undefined,
      fileName: fileName,
      lineNumber: lineNumber || undefined,
      columnNumber: columnNumber || undefined
    });
  };

  for (var i = 0; i < booleanProps.length; i++) {
    StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);

    StackFrame.prototype['set' + _capitalize(booleanProps[i])] = function (p) {
      return function (v) {
        this[p] = Boolean(v);
      };
    }(booleanProps[i]);
  }

  for (var j = 0; j < numericProps.length; j++) {
    StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);

    StackFrame.prototype['set' + _capitalize(numericProps[j])] = function (p) {
      return function (v) {
        if (!_isNumber(v)) {
          throw new TypeError(p + ' must be a Number');
        }

        this[p] = Number(v);
      };
    }(numericProps[j]);
  }

  for (var k = 0; k < stringProps.length; k++) {
    StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);

    StackFrame.prototype['set' + _capitalize(stringProps[k])] = function (p) {
      return function (v) {
        this[p] = String(v);
      };
    }(stringProps[k]);
  }

  return StackFrame;
});

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(27);
} else {}

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var l = Symbol.for("react.element"),
    n = Symbol.for("react.portal"),
    p = Symbol.for("react.fragment"),
    q = Symbol.for("react.strict_mode"),
    r = Symbol.for("react.profiler"),
    t = Symbol.for("react.provider"),
    u = Symbol.for("react.context"),
    v = Symbol.for("react.server_context"),
    w = Symbol.for("react.forward_ref"),
    x = Symbol.for("react.suspense"),
    y = Symbol.for("react.suspense_list"),
    z = Symbol.for("react.memo"),
    A = Symbol.for("react.lazy"),
    aa = Symbol.for("react.debug_trace_mode"),
    ba = Symbol.for("react.offscreen"),
    ca = Symbol.for("react.cache"),
    B = Symbol.for("react.default_value"),
    C = Symbol.iterator;

function da(a) {
  if (null === a || "object" !== _typeof(a)) return null;
  a = C && a[C] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}

var D = {
  isMounted: function isMounted() {
    return !1;
  },
  enqueueForceUpdate: function enqueueForceUpdate() {},
  enqueueReplaceState: function enqueueReplaceState() {},
  enqueueSetState: function enqueueSetState() {}
},
    E = Object.assign,
    F = {};

function G(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = F;
  this.updater = c || D;
}

G.prototype.isReactComponent = {};

G.prototype.setState = function (a, b) {
  if ("object" !== _typeof(a) && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b, "setState");
};

G.prototype.forceUpdate = function (a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};

function H() {}

H.prototype = G.prototype;

function I(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = F;
  this.updater = c || D;
}

var J = I.prototype = new H();
J.constructor = I;
E(J, G.prototype);
J.isPureReactComponent = !0;
var K = Array.isArray,
    L = Object.prototype.hasOwnProperty,
    M = {
  current: null
},
    N = {
  key: !0,
  ref: !0,
  __self: !0,
  __source: !0
};

function O(a, b, c) {
  var d,
      e = {},
      f = null,
      g = null;
  if (null != b) for (d in void 0 !== b.ref && (g = b.ref), void 0 !== b.key && (f = "" + b.key), b) {
    L.call(b, d) && !N.hasOwnProperty(d) && (e[d] = b[d]);
  }
  var h = arguments.length - 2;
  if (1 === h) e.children = c;else if (1 < h) {
    for (var k = Array(h), m = 0; m < h; m++) {
      k[m] = arguments[m + 2];
    }

    e.children = k;
  }
  if (a && a.defaultProps) for (d in h = a.defaultProps, h) {
    void 0 === e[d] && (e[d] = h[d]);
  }
  return {
    $$typeof: l,
    type: a,
    key: f,
    ref: g,
    props: e,
    _owner: M.current
  };
}

function ea(a, b) {
  return {
    $$typeof: l,
    type: a.type,
    key: b,
    ref: a.ref,
    props: a.props,
    _owner: a._owner
  };
}

function P(a) {
  return "object" === _typeof(a) && null !== a && a.$$typeof === l;
}

function escape(a) {
  var b = {
    "=": "=0",
    ":": "=2"
  };
  return "$" + a.replace(/[=:]/g, function (c) {
    return b[c];
  });
}

var Q = /\/+/g;

function R(a, b) {
  return "object" === _typeof(a) && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
}

function S(a, b, c, d, e) {
  var f = _typeof(a);

  if ("undefined" === f || "boolean" === f) a = null;
  var g = !1;
  if (null === a) g = !0;else switch (f) {
    case "string":
    case "number":
      g = !0;
      break;

    case "object":
      switch (a.$$typeof) {
        case l:
        case n:
          g = !0;
      }

  }
  if (g) return g = a, e = e(g), a = "" === d ? "." + R(g, 0) : d, K(e) ? (c = "", null != a && (c = a.replace(Q, "$&/") + "/"), S(e, b, c, "", function (m) {
    return m;
  })) : null != e && (P(e) && (e = ea(e, c + (!e.key || g && g.key === e.key ? "" : ("" + e.key).replace(Q, "$&/") + "/") + a)), b.push(e)), 1;
  g = 0;
  d = "" === d ? "." : d + ":";
  if (K(a)) for (var h = 0; h < a.length; h++) {
    f = a[h];
    var k = d + R(f, h);
    g += S(f, b, c, k, e);
  } else if (k = da(a), "function" === typeof k) for (a = k.call(a), h = 0; !(f = a.next()).done;) {
    f = f.value, k = d + R(f, h++), g += S(f, b, c, k, e);
  } else if ("object" === f) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
  return g;
}

function T(a, b, c) {
  if (null == a) return a;
  var d = [],
      e = 0;
  S(a, d, "", "", function (f) {
    return b.call(c, f, e++);
  });
  return d;
}

function fa(a) {
  if (-1 === a._status) {
    var b = a._result;
    b = b();
    b.then(function (c) {
      if (0 === a._status || -1 === a._status) a._status = 1, a._result = c;
    }, function (c) {
      if (0 === a._status || -1 === a._status) a._status = 2, a._result = c;
    });
    -1 === a._status && (a._status = 0, a._result = b);
  }

  if (1 === a._status) return a._result.default;
  throw a._result;
}

var U = {
  current: null
};

function ha() {
  return new WeakMap();
}

function V() {
  return {
    s: 0,
    v: void 0,
    o: null,
    p: null
  };
}

var W = {
  current: null
},
    X = {
  transition: null
},
    Y = {
  ReactCurrentDispatcher: W,
  ReactCurrentCache: U,
  ReactCurrentBatchConfig: X,
  ReactCurrentOwner: M,
  ContextRegistry: {}
},
    Z = Y.ContextRegistry;
exports.Children = {
  map: T,
  forEach: function forEach(a, b, c) {
    T(a, function () {
      b.apply(this, arguments);
    }, c);
  },
  count: function count(a) {
    var b = 0;
    T(a, function () {
      b++;
    });
    return b;
  },
  toArray: function toArray(a) {
    return T(a, function (b) {
      return b;
    }) || [];
  },
  only: function only(a) {
    if (!P(a)) throw Error("React.Children.only expected to receive a single React element child.");
    return a;
  }
};
exports.Component = G;
exports.Fragment = p;
exports.Profiler = r;
exports.PureComponent = I;
exports.StrictMode = q;
exports.Suspense = x;
exports.SuspenseList = y;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Y;

exports.cache = function (a) {
  return function () {
    var b = U.current;
    if (!b) return a.apply(null, arguments);
    var c = b.getCacheForType(ha);
    b = c.get(a);
    void 0 === b && (b = V(), c.set(a, b));
    c = 0;

    for (var d = arguments.length; c < d; c++) {
      var e = arguments[c];

      if ("function" === typeof e || "object" === _typeof(e) && null !== e) {
        var f = b.o;
        null === f && (b.o = f = new WeakMap());
        b = f.get(e);
        void 0 === b && (b = V(), f.set(e, b));
      } else f = b.p, null === f && (b.p = f = new Map()), b = f.get(e), void 0 === b && (b = V(), f.set(e, b));
    }

    if (1 === b.s) return b.v;
    if (2 === b.s) throw b.v;

    try {
      var g = a.apply(null, arguments);
      c = b;
      c.s = 1;
      return c.v = g;
    } catch (h) {
      throw g = b, g.s = 2, g.v = h, h;
    }
  };
};

exports.cloneElement = function (a, b, c) {
  if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d = E({}, a.props),
      e = a.key,
      f = a.ref,
      g = a._owner;

  if (null != b) {
    void 0 !== b.ref && (f = b.ref, g = M.current);
    void 0 !== b.key && (e = "" + b.key);
    if (a.type && a.type.defaultProps) var h = a.type.defaultProps;

    for (k in b) {
      L.call(b, k) && !N.hasOwnProperty(k) && (d[k] = void 0 === b[k] && void 0 !== h ? h[k] : b[k]);
    }
  }

  var k = arguments.length - 2;
  if (1 === k) d.children = c;else if (1 < k) {
    h = Array(k);

    for (var m = 0; m < k; m++) {
      h[m] = arguments[m + 2];
    }

    d.children = h;
  }
  return {
    $$typeof: l,
    type: a.type,
    key: e,
    ref: f,
    props: d,
    _owner: g
  };
};

exports.createContext = function (a) {
  a = {
    $$typeof: u,
    _currentValue: a,
    _currentValue2: a,
    _threadCount: 0,
    Provider: null,
    Consumer: null,
    _defaultValue: null,
    _globalName: null
  };
  a.Provider = {
    $$typeof: t,
    _context: a
  };
  return a.Consumer = a;
};

exports.createElement = O;

exports.createFactory = function (a) {
  var b = O.bind(null, a);
  b.type = a;
  return b;
};

exports.createRef = function () {
  return {
    current: null
  };
};

exports.createServerContext = function (a, b) {
  var c = !0;

  if (!Z[a]) {
    c = !1;
    var d = {
      $$typeof: v,
      _currentValue: b,
      _currentValue2: b,
      _defaultValue: b,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _globalName: a
    };
    d.Provider = {
      $$typeof: t,
      _context: d
    };
    Z[a] = d;
  }

  d = Z[a];
  if (d._defaultValue === B) d._defaultValue = b, d._currentValue === B && (d._currentValue = b), d._currentValue2 === B && (d._currentValue2 = b);else if (c) throw Error("ServerContext: " + a + " already defined");
  return d;
};

exports.experimental_useEffectEvent = function (a) {
  return W.current.useEffectEvent(a);
};

exports.forwardRef = function (a) {
  return {
    $$typeof: w,
    render: a
  };
};

exports.isValidElement = P;

exports.lazy = function (a) {
  return {
    $$typeof: A,
    _payload: {
      _status: -1,
      _result: a
    },
    _init: fa
  };
};

exports.memo = function (a, b) {
  return {
    $$typeof: z,
    type: a,
    compare: void 0 === b ? null : b
  };
};

exports.startTransition = function (a) {
  var b = X.transition;
  X.transition = {};

  try {
    a();
  } finally {
    X.transition = b;
  }
};

exports.unstable_Cache = ca;
exports.unstable_DebugTracingMode = aa;
exports.unstable_Offscreen = ba;

exports.unstable_act = function () {
  throw Error("act(...) is not supported in production builds of React.");
};

exports.unstable_getCacheForType = function (a) {
  var b = U.current;
  return b ? b.getCacheForType(a) : a();
};

exports.unstable_getCacheSignal = function () {
  var a = U.current;
  return a ? a.getCacheSignal() : (a = new AbortController(), a.abort(Error("This CacheSignal was requested outside React which means that it is immediately aborted.")), a.signal);
};

exports.unstable_useCacheRefresh = function () {
  return W.current.useCacheRefresh();
};

exports.unstable_useMemoCache = function (a) {
  return W.current.useMemoCache(a);
};

exports.use = function (a) {
  return W.current.use(a);
};

exports.useCallback = function (a, b) {
  return W.current.useCallback(a, b);
};

exports.useContext = function (a) {
  return W.current.useContext(a);
};

exports.useDebugValue = function () {};

exports.useDeferredValue = function (a) {
  return W.current.useDeferredValue(a);
};

exports.useEffect = function (a, b) {
  return W.current.useEffect(a, b);
};

exports.useId = function () {
  return W.current.useId();
};

exports.useImperativeHandle = function (a, b, c) {
  return W.current.useImperativeHandle(a, b, c);
};

exports.useInsertionEffect = function (a, b) {
  return W.current.useInsertionEffect(a, b);
};

exports.useLayoutEffect = function (a, b) {
  return W.current.useLayoutEffect(a, b);
};

exports.useMemo = function (a, b) {
  return W.current.useMemo(a, b);
};

exports.useReducer = function (a, b, c) {
  return W.current.useReducer(a, b, c);
};

exports.useRef = function (a) {
  return W.current.useRef(a);
};

exports.useState = function (a) {
  return W.current.useState(a);
};

exports.useSyncExternalStore = function (a, b, c) {
  return W.current.useSyncExternalStore(a, b, c);
};

exports.useTransition = function () {
  return W.current.useTransition();
};

exports.version = "18.3.0-experimental-7f8c501f6-20230420";

/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "connectToDevTools", function() { return /* binding */ connectToDevTools; });

// CONCATENATED MODULE: ../react-devtools-shared/src/events.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var EventEmitter = /*#__PURE__*/function () {
  function EventEmitter() {
    _classCallCheck(this, EventEmitter);

    _defineProperty(this, "listenersMap", new Map());
  }

  _createClass(EventEmitter, [{
    key: "addListener",
    value: function addListener(event, listener) {
      var listeners = this.listenersMap.get(event);

      if (listeners === undefined) {
        this.listenersMap.set(event, [listener]);
      } else {
        var index = listeners.indexOf(listener);

        if (index < 0) {
          listeners.push(listener);
        }
      }
    }
  }, {
    key: "emit",
    value: function emit(event) {
      var listeners = this.listenersMap.get(event);

      if (listeners !== undefined) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        if (listeners.length === 1) {
          // No need to clone or try/catch
          var listener = listeners[0];
          listener.apply(null, args);
        } else {
          var didThrow = false;
          var caughtError = null;
          var clonedListeners = Array.from(listeners);

          for (var i = 0; i < clonedListeners.length; i++) {
            var _listener = clonedListeners[i];

            try {
              _listener.apply(null, args);
            } catch (error) {
              if (caughtError === null) {
                didThrow = true;
                caughtError = error;
              }
            }
          }

          if (didThrow) {
            throw caughtError;
          }
        }
      }
    }
  }, {
    key: "removeAllListeners",
    value: function removeAllListeners() {
      this.listenersMap.clear();
    }
  }, {
    key: "removeListener",
    value: function removeListener(event, listener) {
      var listeners = this.listenersMap.get(event);

      if (listeners !== undefined) {
        var index = listeners.indexOf(listener);

        if (index >= 0) {
          listeners.splice(index, 1);
        }
      }
    }
  }]);

  return EventEmitter;
}();


// EXTERNAL MODULE: /Users/hoxy/repos/react/node_modules/lodash.throttle/index.js
var lodash_throttle = __webpack_require__(12);
var lodash_throttle_default = /*#__PURE__*/__webpack_require__.n(lodash_throttle);

// EXTERNAL MODULE: ../react-devtools-shared/src/constants.js
var constants = __webpack_require__(2);

// EXTERNAL MODULE: ../react-devtools-shared/src/storage.js
var storage = __webpack_require__(5);

// CONCATENATED MODULE: /Users/hoxy/repos/react/node_modules/memoize-one/esm/index.js
var simpleIsEqual = function simpleIsEqual(a, b) {
  return a === b;
};

/* harmony default export */ var esm = (function (resultFn) {
  var isEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : simpleIsEqual;
  var lastThis = void 0;
  var lastArgs = [];
  var lastResult = void 0;
  var calledOnce = false;

  var isNewArgEqualToLast = function isNewArgEqualToLast(newArg, index) {
    return isEqual(newArg, lastArgs[index]);
  };

  var result = function result() {
    for (var _len = arguments.length, newArgs = Array(_len), _key = 0; _key < _len; _key++) {
      newArgs[_key] = arguments[_key];
    }

    if (calledOnce && lastThis === this && newArgs.length === lastArgs.length && newArgs.every(isNewArgEqualToLast)) {
      return lastResult;
    }

    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    lastResult = resultFn.apply(this, newArgs);
    return lastResult;
  };

  return result;
});
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/utils.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// Get the window object for the document that a node belongs to,
// or return null if it cannot be found (node not attached to DOM,
// etc).
function getOwnerWindow(node) {
  if (!node.ownerDocument) {
    return null;
  }

  return node.ownerDocument.defaultView;
} // Get the iframe containing a node, or return null if it cannot
// be found (node not within iframe, etc).

function getOwnerIframe(node) {
  var nodeWindow = getOwnerWindow(node);

  if (nodeWindow) {
    return nodeWindow.frameElement;
  }

  return null;
} // Get a bounding client rect for a node, with an
// offset added to compensate for its border.

function getBoundingClientRectWithBorderOffset(node) {
  var dimensions = getElementDimensions(node);
  return mergeRectOffsets([node.getBoundingClientRect(), {
    top: dimensions.borderTop,
    left: dimensions.borderLeft,
    bottom: dimensions.borderBottom,
    right: dimensions.borderRight,
    // This width and height won't get used by mergeRectOffsets (since this
    // is not the first rect in the array), but we set them so that this
    // object type checks as a ClientRect.
    width: 0,
    height: 0
  }]);
} // Add together the top, left, bottom, and right properties of
// each ClientRect, but keep the width and height of the first one.

function mergeRectOffsets(rects) {
  return rects.reduce(function (previousRect, rect) {
    if (previousRect == null) {
      return rect;
    }

    return {
      top: previousRect.top + rect.top,
      left: previousRect.left + rect.left,
      width: previousRect.width,
      height: previousRect.height,
      bottom: previousRect.bottom + rect.bottom,
      right: previousRect.right + rect.right
    };
  });
} // Calculate a boundingClientRect for a node relative to boundaryWindow,
// taking into account any offsets caused by intermediate iframes.

function getNestedBoundingClientRect(node, boundaryWindow) {
  var ownerIframe = getOwnerIframe(node);

  if (ownerIframe && ownerIframe !== boundaryWindow) {
    var rects = [node.getBoundingClientRect()];
    var currentIframe = ownerIframe;
    var onlyOneMore = false;

    while (currentIframe) {
      var rect = getBoundingClientRectWithBorderOffset(currentIframe);
      rects.push(rect);
      currentIframe = getOwnerIframe(currentIframe);

      if (onlyOneMore) {
        break;
      } // We don't want to calculate iframe offsets upwards beyond
      // the iframe containing the boundaryWindow, but we
      // need to calculate the offset relative to the boundaryWindow.


      if (currentIframe && getOwnerWindow(currentIframe) === boundaryWindow) {
        onlyOneMore = true;
      }
    }

    return mergeRectOffsets(rects);
  } else {
    return node.getBoundingClientRect();
  }
}
function getElementDimensions(domElement) {
  var calculatedStyle = window.getComputedStyle(domElement);
  return {
    borderLeft: parseInt(calculatedStyle.borderLeftWidth, 10),
    borderRight: parseInt(calculatedStyle.borderRightWidth, 10),
    borderTop: parseInt(calculatedStyle.borderTopWidth, 10),
    borderBottom: parseInt(calculatedStyle.borderBottomWidth, 10),
    marginLeft: parseInt(calculatedStyle.marginLeft, 10),
    marginRight: parseInt(calculatedStyle.marginRight, 10),
    marginTop: parseInt(calculatedStyle.marginTop, 10),
    marginBottom: parseInt(calculatedStyle.marginBottom, 10),
    paddingLeft: parseInt(calculatedStyle.paddingLeft, 10),
    paddingRight: parseInt(calculatedStyle.paddingRight, 10),
    paddingTop: parseInt(calculatedStyle.paddingTop, 10),
    paddingBottom: parseInt(calculatedStyle.paddingBottom, 10)
  };
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/Highlighter/Overlay.js
function Overlay_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Overlay_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Overlay_createClass(Constructor, protoProps, staticProps) { if (protoProps) Overlay_defineProperties(Constructor.prototype, protoProps); if (staticProps) Overlay_defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var Overlay_assign = Object.assign; // Note that the Overlay components are not affected by the active Theme,
// because they highlight elements in the main Chrome window (outside of devtools).
// The colors below were chosen to roughly match those used by Chrome devtools.

var OverlayRect = /*#__PURE__*/function () {
  function OverlayRect(doc, container) {
    Overlay_classCallCheck(this, OverlayRect);

    this.node = doc.createElement('div');
    this.border = doc.createElement('div');
    this.padding = doc.createElement('div');
    this.content = doc.createElement('div');
    this.border.style.borderColor = overlayStyles.border;
    this.padding.style.borderColor = overlayStyles.padding;
    this.content.style.backgroundColor = overlayStyles.background;
    Overlay_assign(this.node.style, {
      borderColor: overlayStyles.margin,
      pointerEvents: 'none',
      position: 'fixed'
    });
    this.node.style.zIndex = '10000000';
    this.node.appendChild(this.border);
    this.border.appendChild(this.padding);
    this.padding.appendChild(this.content);
    container.appendChild(this.node);
  }

  Overlay_createClass(OverlayRect, [{
    key: "remove",
    value: function remove() {
      if (this.node.parentNode) {
        this.node.parentNode.removeChild(this.node);
      }
    }
  }, {
    key: "update",
    value: function update(box, dims) {
      boxWrap(dims, 'margin', this.node);
      boxWrap(dims, 'border', this.border);
      boxWrap(dims, 'padding', this.padding);
      Overlay_assign(this.content.style, {
        height: box.height - dims.borderTop - dims.borderBottom - dims.paddingTop - dims.paddingBottom + 'px',
        width: box.width - dims.borderLeft - dims.borderRight - dims.paddingLeft - dims.paddingRight + 'px'
      });
      Overlay_assign(this.node.style, {
        top: box.top - dims.marginTop + 'px',
        left: box.left - dims.marginLeft + 'px'
      });
    }
  }]);

  return OverlayRect;
}();

var OverlayTip = /*#__PURE__*/function () {
  function OverlayTip(doc, container) {
    Overlay_classCallCheck(this, OverlayTip);

    this.tip = doc.createElement('div');
    Overlay_assign(this.tip.style, {
      display: 'flex',
      flexFlow: 'row nowrap',
      backgroundColor: '#333740',
      borderRadius: '2px',
      fontFamily: '"SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace',
      fontWeight: 'bold',
      padding: '3px 5px',
      pointerEvents: 'none',
      position: 'fixed',
      fontSize: '12px',
      whiteSpace: 'nowrap'
    });
    this.nameSpan = doc.createElement('span');
    this.tip.appendChild(this.nameSpan);
    Overlay_assign(this.nameSpan.style, {
      color: '#ee78e6',
      borderRight: '1px solid #aaaaaa',
      paddingRight: '0.5rem',
      marginRight: '0.5rem'
    });
    this.dimSpan = doc.createElement('span');
    this.tip.appendChild(this.dimSpan);
    Overlay_assign(this.dimSpan.style, {
      color: '#d7d7d7'
    });
    this.tip.style.zIndex = '10000000';
    container.appendChild(this.tip);
  }

  Overlay_createClass(OverlayTip, [{
    key: "remove",
    value: function remove() {
      if (this.tip.parentNode) {
        this.tip.parentNode.removeChild(this.tip);
      }
    }
  }, {
    key: "updateText",
    value: function updateText(name, width, height) {
      this.nameSpan.textContent = name;
      this.dimSpan.textContent = Math.round(width) + 'px × ' + Math.round(height) + 'px';
    }
  }, {
    key: "updatePosition",
    value: function updatePosition(dims, bounds) {
      var tipRect = this.tip.getBoundingClientRect();
      var tipPos = findTipPos(dims, bounds, {
        width: tipRect.width,
        height: tipRect.height
      });
      Overlay_assign(this.tip.style, tipPos.style);
    }
  }]);

  return OverlayTip;
}();

var Overlay_Overlay = /*#__PURE__*/function () {
  function Overlay(agent) {
    Overlay_classCallCheck(this, Overlay);

    // Find the root window, because overlays are positioned relative to it.
    var currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
    this.window = currentWindow; // When opened in shells/dev, the tooltip should be bound by the app iframe, not by the topmost window.

    var tipBoundsWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
    this.tipBoundsWindow = tipBoundsWindow;
    var doc = currentWindow.document;
    this.container = doc.createElement('div');
    this.container.style.zIndex = '10000000';
    this.tip = new OverlayTip(doc, this.container);
    this.rects = [];
    this.agent = agent;
    doc.body.appendChild(this.container);
  }

  Overlay_createClass(Overlay, [{
    key: "remove",
    value: function remove() {
      this.tip.remove();
      this.rects.forEach(function (rect) {
        rect.remove();
      });
      this.rects.length = 0;

      if (this.container.parentNode) {
        this.container.parentNode.removeChild(this.container);
      }
    }
  }, {
    key: "inspect",
    value: function inspect(nodes, name) {
      var _this = this;

      // We can't get the size of text nodes or comment nodes. React as of v15
      // heavily uses comment nodes to delimit text.
      var elements = nodes.filter(function (node) {
        return node.nodeType === Node.ELEMENT_NODE;
      });

      while (this.rects.length > elements.length) {
        var rect = this.rects.pop();
        rect.remove();
      }

      if (elements.length === 0) {
        return;
      }

      while (this.rects.length < elements.length) {
        this.rects.push(new OverlayRect(this.window.document, this.container));
      }

      var outerBox = {
        top: Number.POSITIVE_INFINITY,
        right: Number.NEGATIVE_INFINITY,
        bottom: Number.NEGATIVE_INFINITY,
        left: Number.POSITIVE_INFINITY
      };
      elements.forEach(function (element, index) {
        var box = getNestedBoundingClientRect(element, _this.window);
        var dims = getElementDimensions(element);
        outerBox.top = Math.min(outerBox.top, box.top - dims.marginTop);
        outerBox.right = Math.max(outerBox.right, box.left + box.width + dims.marginRight);
        outerBox.bottom = Math.max(outerBox.bottom, box.top + box.height + dims.marginBottom);
        outerBox.left = Math.min(outerBox.left, box.left - dims.marginLeft);
        var rect = _this.rects[index];
        rect.update(box, dims);
      });

      if (!name) {
        name = elements[0].nodeName.toLowerCase();
        var node = elements[0];
        var rendererInterface = this.agent.getBestMatchingRendererInterface(node);

        if (rendererInterface) {
          var id = rendererInterface.getFiberIDForNative(node, true);

          if (id) {
            var ownerName = rendererInterface.getDisplayNameForFiberID(id, true);

            if (ownerName) {
              name += ' (in ' + ownerName + ')';
            }
          }
        }
      }

      this.tip.updateText(name, outerBox.right - outerBox.left, outerBox.bottom - outerBox.top);
      var tipBounds = getNestedBoundingClientRect(this.tipBoundsWindow.document.documentElement, this.window);
      this.tip.updatePosition({
        top: outerBox.top,
        left: outerBox.left,
        height: outerBox.bottom - outerBox.top,
        width: outerBox.right - outerBox.left
      }, {
        top: tipBounds.top + this.tipBoundsWindow.scrollY,
        left: tipBounds.left + this.tipBoundsWindow.scrollX,
        height: this.tipBoundsWindow.innerHeight,
        width: this.tipBoundsWindow.innerWidth
      });
    }
  }]);

  return Overlay;
}();



function findTipPos(dims, bounds, tipSize) {
  var tipHeight = Math.max(tipSize.height, 20);
  var tipWidth = Math.max(tipSize.width, 60);
  var margin = 5;
  var top;

  if (dims.top + dims.height + tipHeight <= bounds.top + bounds.height) {
    if (dims.top + dims.height < bounds.top + 0) {
      top = bounds.top + margin;
    } else {
      top = dims.top + dims.height + margin;
    }
  } else if (dims.top - tipHeight <= bounds.top + bounds.height) {
    if (dims.top - tipHeight - margin < bounds.top + margin) {
      top = bounds.top + margin;
    } else {
      top = dims.top - tipHeight - margin;
    }
  } else {
    top = bounds.top + bounds.height - tipHeight - margin;
  }

  var left = dims.left + margin;

  if (dims.left < bounds.left) {
    left = bounds.left + margin;
  }

  if (dims.left + tipWidth > bounds.left + bounds.width) {
    left = bounds.left + bounds.width - tipWidth - margin;
  }

  top += 'px';
  left += 'px';
  return {
    style: {
      top: top,
      left: left
    }
  };
}

function boxWrap(dims, what, node) {
  Overlay_assign(node.style, {
    borderTopWidth: dims[what + 'Top'] + 'px',
    borderLeftWidth: dims[what + 'Left'] + 'px',
    borderRightWidth: dims[what + 'Right'] + 'px',
    borderBottomWidth: dims[what + 'Bottom'] + 'px',
    borderStyle: 'solid'
  });
}

var overlayStyles = {
  background: 'rgba(120, 170, 210, 0.7)',
  padding: 'rgba(77, 200, 0, 0.3)',
  margin: 'rgba(255, 155, 0, 0.3)',
  border: 'rgba(255, 200, 50, 0.3)'
};
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/Highlighter/Highlighter.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var SHOW_DURATION = 2000;
var timeoutID = null;
var overlay = null;
function hideOverlay(agent) {
  if (window.document == null) {
    agent.emit('hideNativeHighlight');
    return;
  }

  timeoutID = null;

  if (overlay !== null) {
    overlay.remove();
    overlay = null;
  }
}
function showOverlay(elements, componentName, agent, hideAfterTimeout) {
  if (window.document == null) {
    if (elements != null && elements[0] != null) {
      agent.emit('showNativeHighlight', elements[0]);
    }

    return;
  }

  if (timeoutID !== null) {
    clearTimeout(timeoutID);
  }

  if (elements == null) {
    return;
  }

  if (overlay === null) {
    overlay = new Overlay_Overlay(agent);
  }

  overlay.inspect(elements, componentName);

  if (hideAfterTimeout) {
    timeoutID = setTimeout(function () {
      return hideOverlay(agent);
    }, SHOW_DURATION);
  }
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/Highlighter/index.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */




// This plug-in provides in-page highlighting of the selected element.
// It is used by the browser extension and the standalone DevTools shell (when connected to a browser).
// It is not currently the mechanism used to highlight React Native views.
// That is done by the React Native Inspector component.
var iframesListeningTo = new Set();
function setupHighlighter(bridge, agent) {
  bridge.addListener('clearNativeElementHighlight', clearNativeElementHighlight);
  bridge.addListener('highlightNativeElement', highlightNativeElement);
  bridge.addListener('shutdown', stopInspectingNative);
  bridge.addListener('startInspectingNative', startInspectingNative);
  bridge.addListener('stopInspectingNative', stopInspectingNative);

  function startInspectingNative() {
    registerListenersOnWindow(window);
  }

  function registerListenersOnWindow(window) {
    // This plug-in may run in non-DOM environments (e.g. React Native).
    if (window && typeof window.addEventListener === 'function') {
      window.addEventListener('click', onClick, true);
      window.addEventListener('mousedown', onMouseEvent, true);
      window.addEventListener('mouseover', onMouseEvent, true);
      window.addEventListener('mouseup', onMouseEvent, true);
      window.addEventListener('pointerdown', onPointerDown, true);
      window.addEventListener('pointerover', onPointerOver, true);
      window.addEventListener('pointerup', onPointerUp, true);
    } else {
      agent.emit('startInspectingNative');
    }
  }

  function stopInspectingNative() {
    hideOverlay(agent);
    removeListenersOnWindow(window);
    iframesListeningTo.forEach(function (frame) {
      try {
        removeListenersOnWindow(frame.contentWindow);
      } catch (error) {// This can error when the iframe is on a cross-origin.
      }
    });
    iframesListeningTo = new Set();
  }

  function removeListenersOnWindow(window) {
    // This plug-in may run in non-DOM environments (e.g. React Native).
    if (window && typeof window.removeEventListener === 'function') {
      window.removeEventListener('click', onClick, true);
      window.removeEventListener('mousedown', onMouseEvent, true);
      window.removeEventListener('mouseover', onMouseEvent, true);
      window.removeEventListener('mouseup', onMouseEvent, true);
      window.removeEventListener('pointerdown', onPointerDown, true);
      window.removeEventListener('pointerover', onPointerOver, true);
      window.removeEventListener('pointerup', onPointerUp, true);
    } else {
      agent.emit('stopInspectingNative');
    }
  }

  function clearNativeElementHighlight() {
    hideOverlay(agent);
  }

  function highlightNativeElement(_ref) {
    var displayName = _ref.displayName,
        hideAfterTimeout = _ref.hideAfterTimeout,
        id = _ref.id,
        openNativeElementsPanel = _ref.openNativeElementsPanel,
        rendererID = _ref.rendererID,
        scrollIntoView = _ref.scrollIntoView;
    var renderer = agent.rendererInterfaces[rendererID];

    if (renderer == null) {
      console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
    }

    var nodes = null;

    if (renderer != null) {
      nodes = renderer.findNativeNodesForFiberID(id);
    }

    if (nodes != null && nodes[0] != null) {
      var node = nodes[0]; // $FlowFixMe[method-unbinding]

      if (scrollIntoView && typeof node.scrollIntoView === 'function') {
        // If the node isn't visible show it before highlighting it.
        // We may want to reconsider this; it might be a little disruptive.
        node.scrollIntoView({
          block: 'nearest',
          inline: 'nearest'
        });
      }

      showOverlay(nodes, displayName, agent, hideAfterTimeout);

      if (openNativeElementsPanel) {
        window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0 = node;
        bridge.send('syncSelectionToNativeElementsPanel');
      }
    } else {
      hideOverlay(agent);
    }
  }

  function onClick(event) {
    event.preventDefault();
    event.stopPropagation();
    stopInspectingNative();
    bridge.send('stopInspectingNative', true);
  }

  function onMouseEvent(event) {
    event.preventDefault();
    event.stopPropagation();
  }

  function onPointerDown(event) {
    event.preventDefault();
    event.stopPropagation();
    selectFiberForNode(event.target);
  }

  function onPointerOver(event) {
    event.preventDefault();
    event.stopPropagation();
    var target = event.target;

    if (target.tagName === 'IFRAME') {
      var iframe = target;

      try {
        if (!iframesListeningTo.has(iframe)) {
          var _window = iframe.contentWindow;
          registerListenersOnWindow(_window);
          iframesListeningTo.add(iframe);
        }
      } catch (error) {// This can error when the iframe is on a cross-origin.
      }
    } // Don't pass the name explicitly.
    // It will be inferred from DOM tag and Fiber owner.


    showOverlay([target], null, agent, false);
    selectFiberForNode(target);
  }

  function onPointerUp(event) {
    event.preventDefault();
    event.stopPropagation();
  }

  var selectFiberForNode = lodash_throttle_default()(esm(function (node) {
    var id = agent.getIDForNode(node);

    if (id !== null) {
      bridge.send('selectFiber', id);
    }
  }), 200, // Don't change the selection in the very first 200ms
  // because those are usually unintentional as you lift the cursor.
  {
    leading: false
  });
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/TraceUpdates/canvas.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var OUTLINE_COLOR = '#f0f0f0'; // Note these colors are in sync with DevTools Profiler chart colors.

var COLORS = ['#37afa9', '#63b19e', '#80b393', '#97b488', '#abb67d', '#beb771', '#cfb965', '#dfba57', '#efbb49', '#febc38'];
var canvas = null;
function draw(nodeToData, agent) {
  if (window.document == null) {
    var nodesToDraw = [];
    iterateNodes(nodeToData, function (_, color, node) {
      nodesToDraw.push({
        node: node,
        color: color
      });
    });
    agent.emit('drawTraceUpdates', nodesToDraw);
    return;
  }

  if (canvas === null) {
    initialize();
  }

  var canvasFlow = canvas;
  canvasFlow.width = window.innerWidth;
  canvasFlow.height = window.innerHeight;
  var context = canvasFlow.getContext('2d');
  context.clearRect(0, 0, canvasFlow.width, canvasFlow.height);
  iterateNodes(nodeToData, function (rect, color) {
    if (rect !== null) {
      drawBorder(context, rect, color);
    }
  });
}

function iterateNodes(nodeToData, execute) {
  nodeToData.forEach(function (_ref, node) {
    var count = _ref.count,
        rect = _ref.rect;
    var colorIndex = Math.min(COLORS.length - 1, count - 1);
    var color = COLORS[colorIndex];
    execute(rect, color, node);
  });
}

function drawBorder(context, rect, color) {
  var height = rect.height,
      left = rect.left,
      top = rect.top,
      width = rect.width; // outline

  context.lineWidth = 1;
  context.strokeStyle = OUTLINE_COLOR;
  context.strokeRect(left - 1, top - 1, width + 2, height + 2); // inset

  context.lineWidth = 1;
  context.strokeStyle = OUTLINE_COLOR;
  context.strokeRect(left + 1, top + 1, width - 1, height - 1);
  context.strokeStyle = color;
  context.setLineDash([0]); // border

  context.lineWidth = 1;
  context.strokeRect(left, top, width - 1, height - 1);
  context.setLineDash([0]);
}

function destroy(agent) {
  if (window.document == null) {
    agent.emit('disableTraceUpdates');
    return;
  }

  if (canvas !== null) {
    if (canvas.parentNode != null) {
      canvas.parentNode.removeChild(canvas);
    }

    canvas = null;
  }
}

function initialize() {
  canvas = window.document.createElement('canvas');
  canvas.style.cssText = "\n    xx-background-color: red;\n    xx-opacity: 0.5;\n    bottom: 0;\n    left: 0;\n    pointer-events: none;\n    position: fixed;\n    right: 0;\n    top: 0;\n    z-index: 1000000000;\n  ";
  var root = window.document.documentElement;
  root.insertBefore(canvas, root.firstChild);
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/TraceUpdates/index.js
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */



// How long the rect should be shown for?
var DISPLAY_DURATION = 250; // What's the longest we are willing to show the overlay for?
// This can be important if we're getting a flurry of events (e.g. scroll update).

var MAX_DISPLAY_DURATION = 3000; // How long should a rect be considered valid for?

var REMEASUREMENT_AFTER_DURATION = 250; // Some environments (e.g. React Native / Hermes) don't support the performance API yet.

var getCurrentTime = // $FlowFixMe[method-unbinding]
(typeof performance === "undefined" ? "undefined" : _typeof(performance)) === 'object' && typeof performance.now === 'function' ? function () {
  return performance.now();
} : function () {
  return Date.now();
};
var nodeToData = new Map();
var TraceUpdates_agent = null;
var drawAnimationFrameID = null;
var isEnabled = false;
var redrawTimeoutID = null;
function TraceUpdates_initialize(injectedAgent) {
  TraceUpdates_agent = injectedAgent;
  TraceUpdates_agent.addListener('traceUpdates', traceUpdates);
}
function toggleEnabled(value) {
  isEnabled = value;

  if (!isEnabled) {
    nodeToData.clear();

    if (drawAnimationFrameID !== null) {
      cancelAnimationFrame(drawAnimationFrameID);
      drawAnimationFrameID = null;
    }

    if (redrawTimeoutID !== null) {
      clearTimeout(redrawTimeoutID);
      redrawTimeoutID = null;
    }

    destroy(TraceUpdates_agent);
  }
}

function traceUpdates(nodes) {
  if (!isEnabled) {
    return;
  }

  nodes.forEach(function (node) {
    var data = nodeToData.get(node);
    var now = getCurrentTime();
    var lastMeasuredAt = data != null ? data.lastMeasuredAt : 0;
    var rect = data != null ? data.rect : null;

    if (rect === null || lastMeasuredAt + REMEASUREMENT_AFTER_DURATION < now) {
      lastMeasuredAt = now;
      rect = measureNode(node);
    }

    nodeToData.set(node, {
      count: data != null ? data.count + 1 : 1,
      expirationTime: data != null ? Math.min(now + MAX_DISPLAY_DURATION, data.expirationTime + DISPLAY_DURATION) : now + DISPLAY_DURATION,
      lastMeasuredAt: lastMeasuredAt,
      rect: rect
    });
  });

  if (redrawTimeoutID !== null) {
    clearTimeout(redrawTimeoutID);
    redrawTimeoutID = null;
  }

  if (drawAnimationFrameID === null) {
    drawAnimationFrameID = requestAnimationFrame(prepareToDraw);
  }
}

function prepareToDraw() {
  drawAnimationFrameID = null;
  redrawTimeoutID = null;
  var now = getCurrentTime();
  var earliestExpiration = Number.MAX_VALUE; // Remove any items that have already expired.

  nodeToData.forEach(function (data, node) {
    if (data.expirationTime < now) {
      nodeToData.delete(node);
    } else {
      earliestExpiration = Math.min(earliestExpiration, data.expirationTime);
    }
  });
  draw(nodeToData, TraceUpdates_agent);

  if (earliestExpiration !== Number.MAX_VALUE) {
    redrawTimeoutID = setTimeout(prepareToDraw, earliestExpiration - now);
  }
}

function measureNode(node) {
  if (!node || typeof node.getBoundingClientRect !== 'function') {
    return null;
  }

  var currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
  return getNestedBoundingClientRect(node, currentWindow);
}
// EXTERNAL MODULE: ../react-devtools-shared/src/backend/console.js
var backend_console = __webpack_require__(8);

// CONCATENATED MODULE: ../react-devtools-shared/src/bridge.js
function bridge_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { bridge_typeof = function _typeof(obj) { return typeof obj; }; } else { bridge_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return bridge_typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function bridge_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function bridge_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function bridge_createClass(Constructor, protoProps, staticProps) { if (protoProps) bridge_defineProperties(Constructor.prototype, protoProps); if (staticProps) bridge_defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (bridge_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function bridge_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var BATCH_DURATION = 100; // This message specifies the version of the DevTools protocol currently supported by the backend,
// as well as the earliest NPM version (e.g. "4.13.0") that protocol is supported by on the frontend.
// This enables an older frontend to display an upgrade message to users for a newer, unsupported backend.

// Bump protocol version whenever a backwards breaking change is made
// in the messages sent between BackendBridge and FrontendBridge.
// This mapping is embedded in both frontend and backend builds.
//
// The backend protocol will always be the latest entry in the BRIDGE_PROTOCOL array.
//
// When an older frontend connects to a newer backend,
// the backend can send the minNpmVersion and the frontend can display an NPM upgrade prompt.
//
// When a newer frontend connects with an older protocol version,
// the frontend can use the embedded minNpmVersion/maxNpmVersion values to display a downgrade prompt.
var BRIDGE_PROTOCOL = [// This version technically never existed,
// but a backwards breaking change was added in 4.11,
// so the safest guess to downgrade the frontend would be to version 4.10.
{
  version: 0,
  minNpmVersion: '"<4.11.0"',
  maxNpmVersion: '"<4.11.0"'
}, // Versions 4.11.x – 4.12.x contained the backwards breaking change,
// but we didn't add the "fix" of checking the protocol version until 4.13,
// so we don't recommend downgrading to 4.11 or 4.12.
{
  version: 1,
  minNpmVersion: '4.13.0',
  maxNpmVersion: '4.21.0'
}, // Version 2 adds a StrictMode-enabled and supports-StrictMode bits to add-root operation.
{
  version: 2,
  minNpmVersion: '4.22.0',
  maxNpmVersion: null
}];
var currentBridgeProtocol = BRIDGE_PROTOCOL[BRIDGE_PROTOCOL.length - 1];

var Bridge = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Bridge, _EventEmitter);

  var _super = _createSuper(Bridge);

  function Bridge(wall) {
    var _this;

    bridge_classCallCheck(this, Bridge);

    _this = _super.call(this);

    bridge_defineProperty(_assertThisInitialized(_this), "_isShutdown", false);

    bridge_defineProperty(_assertThisInitialized(_this), "_messageQueue", []);

    bridge_defineProperty(_assertThisInitialized(_this), "_timeoutID", null);

    bridge_defineProperty(_assertThisInitialized(_this), "_wallUnlisten", null);

    bridge_defineProperty(_assertThisInitialized(_this), "_flush", function () {
      // This method is used after the bridge is marked as destroyed in shutdown sequence,
      // so we do not bail out if the bridge marked as destroyed.
      // It is a private method that the bridge ensures is only called at the right times.
      if (_this._timeoutID !== null) {
        clearTimeout(_this._timeoutID);
        _this._timeoutID = null;
      }

      if (_this._messageQueue.length) {
        for (var i = 0; i < _this._messageQueue.length; i += 2) {
          var _this$_wall;

          (_this$_wall = _this._wall).send.apply(_this$_wall, [_this._messageQueue[i]].concat(_toConsumableArray(_this._messageQueue[i + 1])));
        }

        _this._messageQueue.length = 0; // Check again for queued messages in BATCH_DURATION ms. This will keep
        // flushing in a loop as long as messages continue to be added. Once no
        // more are, the timer expires.

        _this._timeoutID = setTimeout(_this._flush, BATCH_DURATION);
      }
    });

    bridge_defineProperty(_assertThisInitialized(_this), "overrideValueAtPath", function (_ref) {
      var id = _ref.id,
          path = _ref.path,
          rendererID = _ref.rendererID,
          type = _ref.type,
          value = _ref.value;

      switch (type) {
        case 'context':
          _this.send('overrideContext', {
            id: id,
            path: path,
            rendererID: rendererID,
            wasForwarded: true,
            value: value
          });

          break;

        case 'hooks':
          _this.send('overrideHookState', {
            id: id,
            path: path,
            rendererID: rendererID,
            wasForwarded: true,
            value: value
          });

          break;

        case 'props':
          _this.send('overrideProps', {
            id: id,
            path: path,
            rendererID: rendererID,
            wasForwarded: true,
            value: value
          });

          break;

        case 'state':
          _this.send('overrideState', {
            id: id,
            path: path,
            rendererID: rendererID,
            wasForwarded: true,
            value: value
          });

          break;
      }
    });

    _this._wall = wall;
    _this._wallUnlisten = wall.listen(function (message) {
      if (message && message.event) {
        _assertThisInitialized(_this).emit(message.event, message.payload);
      }
    }) || null; // Temporarily support older standalone front-ends sending commands to newer embedded backends.
    // We do this because React Native embeds the React DevTools backend,
    // but cannot control which version of the frontend users use.

    _this.addListener('overrideValueAtPath', _this.overrideValueAtPath);

    return _this;
  } // Listening directly to the wall isn't advised.
  // It can be used to listen for legacy (v3) messages (since they use a different format).


  bridge_createClass(Bridge, [{
    key: "send",
    value: function send(event) {
      if (this._isShutdown) {
        console.warn("Cannot send message \"".concat(event, "\" through a Bridge that has been shutdown."));
        return;
      } // When we receive a message:
      // - we add it to our queue of messages to be sent
      // - if there hasn't been a message recently, we set a timer for 0 ms in
      //   the future, allowing all messages created in the same tick to be sent
      //   together
      // - if there *has* been a message flushed in the last BATCH_DURATION ms
      //   (or we're waiting for our setTimeout-0 to fire), then _timeoutID will
      //   be set, and we'll simply add to the queue and wait for that


      for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        payload[_key - 1] = arguments[_key];
      }

      this._messageQueue.push(event, payload);

      if (!this._timeoutID) {
        this._timeoutID = setTimeout(this._flush, 0);
      }
    }
  }, {
    key: "shutdown",
    value: function shutdown() {
      if (this._isShutdown) {
        console.warn('Bridge was already shutdown.');
        return;
      } // Queue the shutdown outgoing message for subscribers.


      this.send('shutdown'); // Mark this bridge as destroyed, i.e. disable its public API.

      this._isShutdown = true; // Disable the API inherited from EventEmitter that can add more listeners and send more messages.
      // $FlowFixMe[cannot-write] This property is not writable.

      this.addListener = function () {}; // $FlowFixMe[cannot-write] This property is not writable.


      this.emit = function () {}; // NOTE: There's also EventEmitter API like `on` and `prependListener` that we didn't add to our Flow type of EventEmitter.
      // Unsubscribe this bridge incoming message listeners to be sure, and so they don't have to do that.


      this.removeAllListeners(); // Stop accepting and emitting incoming messages from the wall.

      var wallUnlisten = this._wallUnlisten;

      if (wallUnlisten) {
        wallUnlisten();
      } // Synchronously flush all queued outgoing messages.
      // At this step the subscribers' code may run in this call stack.


      do {
        this._flush();
      } while (this._messageQueue.length); // Make sure once again that there is no dangling timer.


      if (this._timeoutID !== null) {
        clearTimeout(this._timeoutID);
        this._timeoutID = null;
      }
    }
  }, {
    key: "wall",
    get: function get() {
      return this._wall;
    }
  }]);

  return Bridge;
}(EventEmitter);

/* harmony default export */ var src_bridge = (Bridge);
// EXTERNAL MODULE: ../react-devtools-shared/src/backend/utils.js + 1 modules
var utils = __webpack_require__(4);

// CONCATENATED MODULE: ../react-devtools-shared/src/backend/agent.js
function agent_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { agent_typeof = function _typeof(obj) { return typeof obj; }; } else { agent_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return agent_typeof(obj); }

function agent_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function agent_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function agent_createClass(Constructor, protoProps, staticProps) { if (protoProps) agent_defineProperties(Constructor.prototype, protoProps); if (staticProps) agent_defineProperties(Constructor, staticProps); return Constructor; }

function agent_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) agent_setPrototypeOf(subClass, superClass); }

function agent_setPrototypeOf(o, p) { agent_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return agent_setPrototypeOf(o, p); }

function agent_createSuper(Derived) { var hasNativeReflectConstruct = agent_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = agent_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = agent_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return agent_possibleConstructorReturn(this, result); }; }

function agent_possibleConstructorReturn(self, call) { if (call && (agent_typeof(call) === "object" || typeof call === "function")) { return call; } return agent_assertThisInitialized(self); }

function agent_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function agent_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function agent_getPrototypeOf(o) { agent_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return agent_getPrototypeOf(o); }

function agent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */










var agent_debug = function debug(methodName) {
  if (constants["s" /* __DEBUG__ */]) {
    var _console;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    (_console = console).log.apply(_console, ["%cAgent %c".concat(methodName), 'color: purple; font-weight: bold;', 'font-weight: bold;'].concat(args));
  }
};

var agent_Agent = /*#__PURE__*/function (_EventEmitter) {
  agent_inherits(Agent, _EventEmitter);

  var _super = agent_createSuper(Agent);

  function Agent(bridge) {
    var _this;

    agent_classCallCheck(this, Agent);

    _this = _super.call(this);

    agent_defineProperty(agent_assertThisInitialized(_this), "_isProfiling", false);

    agent_defineProperty(agent_assertThisInitialized(_this), "_recordChangeDescriptions", false);

    agent_defineProperty(agent_assertThisInitialized(_this), "_rendererInterfaces", {});

    agent_defineProperty(agent_assertThisInitialized(_this), "_persistedSelection", null);

    agent_defineProperty(agent_assertThisInitialized(_this), "_persistedSelectionMatch", null);

    agent_defineProperty(agent_assertThisInitialized(_this), "_traceUpdatesEnabled", false);

    agent_defineProperty(agent_assertThisInitialized(_this), "clearErrorsAndWarnings", function (_ref) {
      var rendererID = _ref.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\""));
      } else {
        renderer.clearErrorsAndWarnings();
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "clearErrorsForFiberID", function (_ref2) {
      var id = _ref2.id,
          rendererID = _ref2.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\""));
      } else {
        renderer.clearErrorsForFiberID(id);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "clearWarningsForFiberID", function (_ref3) {
      var id = _ref3.id,
          rendererID = _ref3.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\""));
      } else {
        renderer.clearWarningsForFiberID(id);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "copyElementPath", function (_ref4) {
      var id = _ref4.id,
          path = _ref4.path,
          rendererID = _ref4.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        var value = renderer.getSerializedElementValueByPath(id, path);

        if (value != null) {
          _this._bridge.send('saveToClipboard', value);
        } else {
          console.warn("Unable to obtain serialized value for element \"".concat(id, "\""));
        }
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "deletePath", function (_ref5) {
      var hookID = _ref5.hookID,
          id = _ref5.id,
          path = _ref5.path,
          rendererID = _ref5.rendererID,
          type = _ref5.type;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.deletePath(type, id, hookID, path);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "getBackendVersion", function () {
      var version = "4.27.6-7f8c501f6";

      if (version) {
        _this._bridge.send('backendVersion', version);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "getBridgeProtocol", function () {
      _this._bridge.send('bridgeProtocol', currentBridgeProtocol);
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "getProfilingData", function (_ref6) {
      var rendererID = _ref6.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\""));
      }

      _this._bridge.send('profilingData', renderer.getProfilingData());
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "getProfilingStatus", function () {
      _this._bridge.send('profilingStatus', _this._isProfiling);
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "getOwnersList", function (_ref7) {
      var id = _ref7.id,
          rendererID = _ref7.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        var owners = renderer.getOwnersList(id);

        _this._bridge.send('ownersList', {
          id: id,
          owners: owners
        });
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "inspectElement", function (_ref8) {
      var forceFullData = _ref8.forceFullData,
          id = _ref8.id,
          path = _ref8.path,
          rendererID = _ref8.rendererID,
          requestID = _ref8.requestID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        _this._bridge.send('inspectedElement', renderer.inspectElement(requestID, id, path, forceFullData)); // When user selects an element, stop trying to restore the selection,
        // and instead remember the current selection for the next reload.


        if (_this._persistedSelectionMatch === null || _this._persistedSelectionMatch.id !== id) {
          _this._persistedSelection = null;
          _this._persistedSelectionMatch = null;
          renderer.setTrackedPath(null);

          _this._throttledPersistSelection(rendererID, id);
        } // TODO: If there was a way to change the selected DOM element
        // in native Elements tab without forcing a switch to it, we'd do it here.
        // For now, it doesn't seem like there is a way to do that:
        // https://github.com/bvaughn/react-devtools-experimental/issues/102
        // (Setting $0 doesn't work, and calling inspect() switches the tab.)

      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "logElementToConsole", function (_ref9) {
      var id = _ref9.id,
          rendererID = _ref9.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.logElementToConsole(id);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "overrideError", function (_ref10) {
      var id = _ref10.id,
          rendererID = _ref10.rendererID,
          forceError = _ref10.forceError;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.overrideError(id, forceError);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "overrideSuspense", function (_ref11) {
      var id = _ref11.id,
          rendererID = _ref11.rendererID,
          forceFallback = _ref11.forceFallback;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.overrideSuspense(id, forceFallback);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "overrideValueAtPath", function (_ref12) {
      var hookID = _ref12.hookID,
          id = _ref12.id,
          path = _ref12.path,
          rendererID = _ref12.rendererID,
          type = _ref12.type,
          value = _ref12.value;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.overrideValueAtPath(type, id, hookID, path, value);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "overrideContext", function (_ref13) {
      var id = _ref13.id,
          path = _ref13.path,
          rendererID = _ref13.rendererID,
          wasForwarded = _ref13.wasForwarded,
          value = _ref13.value;

      // Don't forward a message that's already been forwarded by the front-end Bridge.
      // We only need to process the override command once!
      if (!wasForwarded) {
        _this.overrideValueAtPath({
          id: id,
          path: path,
          rendererID: rendererID,
          type: 'context',
          value: value
        });
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "overrideHookState", function (_ref14) {
      var id = _ref14.id,
          hookID = _ref14.hookID,
          path = _ref14.path,
          rendererID = _ref14.rendererID,
          wasForwarded = _ref14.wasForwarded,
          value = _ref14.value;

      // Don't forward a message that's already been forwarded by the front-end Bridge.
      // We only need to process the override command once!
      if (!wasForwarded) {
        _this.overrideValueAtPath({
          id: id,
          path: path,
          rendererID: rendererID,
          type: 'hooks',
          value: value
        });
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "overrideProps", function (_ref15) {
      var id = _ref15.id,
          path = _ref15.path,
          rendererID = _ref15.rendererID,
          wasForwarded = _ref15.wasForwarded,
          value = _ref15.value;

      // Don't forward a message that's already been forwarded by the front-end Bridge.
      // We only need to process the override command once!
      if (!wasForwarded) {
        _this.overrideValueAtPath({
          id: id,
          path: path,
          rendererID: rendererID,
          type: 'props',
          value: value
        });
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "overrideState", function (_ref16) {
      var id = _ref16.id,
          path = _ref16.path,
          rendererID = _ref16.rendererID,
          wasForwarded = _ref16.wasForwarded,
          value = _ref16.value;

      // Don't forward a message that's already been forwarded by the front-end Bridge.
      // We only need to process the override command once!
      if (!wasForwarded) {
        _this.overrideValueAtPath({
          id: id,
          path: path,
          rendererID: rendererID,
          type: 'state',
          value: value
        });
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "reloadAndProfile", function (recordChangeDescriptions) {
      Object(storage["e" /* sessionStorageSetItem */])(constants["k" /* SESSION_STORAGE_RELOAD_AND_PROFILE_KEY */], 'true');
      Object(storage["e" /* sessionStorageSetItem */])(constants["j" /* SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY */], recordChangeDescriptions ? 'true' : 'false'); // This code path should only be hit if the shell has explicitly told the Store that it supports profiling.
      // In that case, the shell must also listen for this specific message to know when it needs to reload the app.
      // The agent can't do this in a way that is renderer agnostic.

      _this._bridge.send('reloadAppForProfiling');
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "renamePath", function (_ref17) {
      var hookID = _ref17.hookID,
          id = _ref17.id,
          newPath = _ref17.newPath,
          oldPath = _ref17.oldPath,
          rendererID = _ref17.rendererID,
          type = _ref17.type;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.renamePath(type, id, hookID, oldPath, newPath);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "setTraceUpdatesEnabled", function (traceUpdatesEnabled) {
      _this._traceUpdatesEnabled = traceUpdatesEnabled;
      toggleEnabled(traceUpdatesEnabled);

      for (var rendererID in _this._rendererInterfaces) {
        var renderer = _this._rendererInterfaces[rendererID];
        renderer.setTraceUpdatesEnabled(traceUpdatesEnabled);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "syncSelectionFromNativeElementsPanel", function () {
      var target = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0;

      if (target == null) {
        return;
      }

      _this.selectNode(target);
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "shutdown", function () {
      // Clean up the overlay if visible, and associated events.
      _this.emit('shutdown');
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "startProfiling", function (recordChangeDescriptions) {
      _this._recordChangeDescriptions = recordChangeDescriptions;
      _this._isProfiling = true;

      for (var rendererID in _this._rendererInterfaces) {
        var renderer = _this._rendererInterfaces[rendererID];
        renderer.startProfiling(recordChangeDescriptions);
      }

      _this._bridge.send('profilingStatus', _this._isProfiling);
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "stopProfiling", function () {
      _this._isProfiling = false;
      _this._recordChangeDescriptions = false;

      for (var rendererID in _this._rendererInterfaces) {
        var renderer = _this._rendererInterfaces[rendererID];
        renderer.stopProfiling();
      }

      _this._bridge.send('profilingStatus', _this._isProfiling);
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "stopInspectingNative", function (selected) {
      _this._bridge.send('stopInspectingNative', selected);
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "storeAsGlobal", function (_ref18) {
      var count = _ref18.count,
          id = _ref18.id,
          path = _ref18.path,
          rendererID = _ref18.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.storeAsGlobal(id, path, count);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "updateConsolePatchSettings", function (_ref19) {
      var appendComponentStack = _ref19.appendComponentStack,
          breakOnConsoleErrors = _ref19.breakOnConsoleErrors,
          showInlineWarningsAndErrors = _ref19.showInlineWarningsAndErrors,
          hideConsoleLogsInStrictMode = _ref19.hideConsoleLogsInStrictMode,
          browserTheme = _ref19.browserTheme;
      // If the frontend preferences have changed,
      // or in the case of React Native- if the backend is just finding out the preferences-
      // then reinstall the console overrides.
      // It's safe to call `patchConsole` multiple times.
      Object(backend_console["b" /* patch */])({
        appendComponentStack: appendComponentStack,
        breakOnConsoleErrors: breakOnConsoleErrors,
        showInlineWarningsAndErrors: showInlineWarningsAndErrors,
        hideConsoleLogsInStrictMode: hideConsoleLogsInStrictMode,
        browserTheme: browserTheme
      });
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "updateComponentFilters", function (componentFilters) {
      for (var rendererID in _this._rendererInterfaces) {
        var renderer = _this._rendererInterfaces[rendererID];
        renderer.updateComponentFilters(componentFilters);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "viewAttributeSource", function (_ref20) {
      var id = _ref20.id,
          path = _ref20.path,
          rendererID = _ref20.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.prepareViewAttributeSource(id, path);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "viewElementSource", function (_ref21) {
      var id = _ref21.id,
          rendererID = _ref21.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.prepareViewElementSource(id);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "onTraceUpdates", function (nodes) {
      _this.emit('traceUpdates', nodes);
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "onFastRefreshScheduled", function () {
      if (constants["s" /* __DEBUG__ */]) {
        agent_debug('onFastRefreshScheduled');
      }

      _this._bridge.send('fastRefreshScheduled');
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "onHookOperations", function (operations) {
      if (constants["s" /* __DEBUG__ */]) {
        agent_debug('onHookOperations', "(".concat(operations.length, ") [").concat(operations.join(', '), "]"));
      } // TODO:
      // The chrome.runtime does not currently support transferables; it forces JSON serialization.
      // See bug https://bugs.chromium.org/p/chromium/issues/detail?id=927134
      //
      // Regarding transferables, the postMessage doc states:
      // If the ownership of an object is transferred, it becomes unusable (neutered)
      // in the context it was sent from and becomes available only to the worker it was sent to.
      //
      // Even though Chrome is eventually JSON serializing the array buffer,
      // using the transferable approach also sometimes causes it to throw:
      //   DOMException: Failed to execute 'postMessage' on 'Window': ArrayBuffer at index 0 is already neutered.
      //
      // See bug https://github.com/bvaughn/react-devtools-experimental/issues/25
      //
      // The Store has a fallback in place that parses the message as JSON if the type isn't an array.
      // For now the simplest fix seems to be to not transfer the array.
      // This will negatively impact performance on Firefox so it's unfortunate,
      // but until we're able to fix the Chrome error mentioned above, it seems necessary.
      //
      // this._bridge.send('operations', operations, [operations.buffer]);


      _this._bridge.send('operations', operations);

      if (_this._persistedSelection !== null) {
        var rendererID = operations[0];

        if (_this._persistedSelection.rendererID === rendererID) {
          // Check if we can select a deeper match for the persisted selection.
          var renderer = _this._rendererInterfaces[rendererID];

          if (renderer == null) {
            console.warn("Invalid renderer id \"".concat(rendererID, "\""));
          } else {
            var prevMatch = _this._persistedSelectionMatch;
            var nextMatch = renderer.getBestMatchForTrackedPath();
            _this._persistedSelectionMatch = nextMatch;
            var prevMatchID = prevMatch !== null ? prevMatch.id : null;
            var nextMatchID = nextMatch !== null ? nextMatch.id : null;

            if (prevMatchID !== nextMatchID) {
              if (nextMatchID !== null) {
                // We moved forward, unlocking a deeper node.
                _this._bridge.send('selectFiber', nextMatchID);
              }
            }

            if (nextMatch !== null && nextMatch.isFullMatch) {
              // We've just unlocked the innermost selected node.
              // There's no point tracking it further.
              _this._persistedSelection = null;
              _this._persistedSelectionMatch = null;
              renderer.setTrackedPath(null);
            }
          }
        }
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "_throttledPersistSelection", lodash_throttle_default()(function (rendererID, id) {
      // This is throttled, so both renderer and selected ID
      // might not be available by the time we read them.
      // This is why we need the defensive checks here.
      var renderer = _this._rendererInterfaces[rendererID];
      var path = renderer != null ? renderer.getPathForElement(id) : null;

      if (path !== null) {
        Object(storage["e" /* sessionStorageSetItem */])(constants["i" /* SESSION_STORAGE_LAST_SELECTION_KEY */], JSON.stringify({
          rendererID: rendererID,
          path: path
        }));
      } else {
        Object(storage["d" /* sessionStorageRemoveItem */])(constants["i" /* SESSION_STORAGE_LAST_SELECTION_KEY */]);
      }
    }, 1000));

    if (Object(storage["c" /* sessionStorageGetItem */])(constants["k" /* SESSION_STORAGE_RELOAD_AND_PROFILE_KEY */]) === 'true') {
      _this._recordChangeDescriptions = Object(storage["c" /* sessionStorageGetItem */])(constants["j" /* SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY */]) === 'true';
      _this._isProfiling = true;
      Object(storage["d" /* sessionStorageRemoveItem */])(constants["j" /* SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY */]);
      Object(storage["d" /* sessionStorageRemoveItem */])(constants["k" /* SESSION_STORAGE_RELOAD_AND_PROFILE_KEY */]);
    }

    var persistedSelectionString = Object(storage["c" /* sessionStorageGetItem */])(constants["i" /* SESSION_STORAGE_LAST_SELECTION_KEY */]);

    if (persistedSelectionString != null) {
      _this._persistedSelection = JSON.parse(persistedSelectionString);
    }

    _this._bridge = bridge;
    bridge.addListener('clearErrorsAndWarnings', _this.clearErrorsAndWarnings);
    bridge.addListener('clearErrorsForFiberID', _this.clearErrorsForFiberID);
    bridge.addListener('clearWarningsForFiberID', _this.clearWarningsForFiberID);
    bridge.addListener('copyElementPath', _this.copyElementPath);
    bridge.addListener('deletePath', _this.deletePath);
    bridge.addListener('getBackendVersion', _this.getBackendVersion);
    bridge.addListener('getBridgeProtocol', _this.getBridgeProtocol);
    bridge.addListener('getProfilingData', _this.getProfilingData);
    bridge.addListener('getProfilingStatus', _this.getProfilingStatus);
    bridge.addListener('getOwnersList', _this.getOwnersList);
    bridge.addListener('inspectElement', _this.inspectElement);
    bridge.addListener('logElementToConsole', _this.logElementToConsole);
    bridge.addListener('overrideError', _this.overrideError);
    bridge.addListener('overrideSuspense', _this.overrideSuspense);
    bridge.addListener('overrideValueAtPath', _this.overrideValueAtPath);
    bridge.addListener('reloadAndProfile', _this.reloadAndProfile);
    bridge.addListener('renamePath', _this.renamePath);
    bridge.addListener('setTraceUpdatesEnabled', _this.setTraceUpdatesEnabled);
    bridge.addListener('startProfiling', _this.startProfiling);
    bridge.addListener('stopProfiling', _this.stopProfiling);
    bridge.addListener('storeAsGlobal', _this.storeAsGlobal);
    bridge.addListener('syncSelectionFromNativeElementsPanel', _this.syncSelectionFromNativeElementsPanel);
    bridge.addListener('shutdown', _this.shutdown);
    bridge.addListener('updateConsolePatchSettings', _this.updateConsolePatchSettings);
    bridge.addListener('updateComponentFilters', _this.updateComponentFilters);
    bridge.addListener('viewAttributeSource', _this.viewAttributeSource);
    bridge.addListener('viewElementSource', _this.viewElementSource); // Temporarily support older standalone front-ends sending commands to newer embedded backends.
    // We do this because React Native embeds the React DevTools backend,
    // but cannot control which version of the frontend users use.

    bridge.addListener('overrideContext', _this.overrideContext);
    bridge.addListener('overrideHookState', _this.overrideHookState);
    bridge.addListener('overrideProps', _this.overrideProps);
    bridge.addListener('overrideState', _this.overrideState);

    if (_this._isProfiling) {
      bridge.send('profilingStatus', true);
    } // Send the Bridge protocol and backend versions, after initialization, in case the frontend has already requested it.
    // The Store may be instantiated beore the agent.


    var _version = "4.27.6-7f8c501f6";

    if (_version) {
      _this._bridge.send('backendVersion', _version);
    }

    _this._bridge.send('bridgeProtocol', currentBridgeProtocol); // Notify the frontend if the backend supports the Storage API (e.g. localStorage).
    // If not, features like reload-and-profile will not work correctly and must be disabled.


    var isBackendStorageAPISupported = false;

    try {
      localStorage.getItem('test');
      isBackendStorageAPISupported = true;
    } catch (error) {}

    bridge.send('isBackendStorageAPISupported', isBackendStorageAPISupported);
    bridge.send('isSynchronousXHRSupported', Object(utils["k" /* isSynchronousXHRSupported */])());
    setupHighlighter(bridge, agent_assertThisInitialized(_this));
    TraceUpdates_initialize(agent_assertThisInitialized(_this));
    return _this;
  }

  agent_createClass(Agent, [{
    key: "getInstanceAndStyle",
    value: function getInstanceAndStyle(_ref22) {
      var id = _ref22.id,
          rendererID = _ref22.rendererID;
      var renderer = this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\""));
        return null;
      }

      return renderer.getInstanceAndStyle(id);
    }
  }, {
    key: "getBestMatchingRendererInterface",
    value: function getBestMatchingRendererInterface(node) {
      var bestMatch = null;

      for (var rendererID in this._rendererInterfaces) {
        var renderer = this._rendererInterfaces[rendererID];
        var fiber = renderer.getFiberForNative(node);

        if (fiber !== null) {
          // check if fiber.stateNode is matching the original hostInstance
          if (fiber.stateNode === node) {
            return renderer;
          } else if (bestMatch === null) {
            bestMatch = renderer;
          }
        }
      } // if an exact match is not found, return the first valid renderer as fallback


      return bestMatch;
    }
  }, {
    key: "getIDForNode",
    value: function getIDForNode(node) {
      var rendererInterface = this.getBestMatchingRendererInterface(node);

      if (rendererInterface != null) {
        try {
          return rendererInterface.getFiberIDForNative(node, true);
        } catch (error) {// Some old React versions might throw if they can't find a match.
          // If so we should ignore it...
        }
      }

      return null;
    }
  }, {
    key: "selectNode",
    value: function selectNode(target) {
      var id = this.getIDForNode(target);

      if (id !== null) {
        this._bridge.send('selectFiber', id);
      }
    }
  }, {
    key: "setRendererInterface",
    value: function setRendererInterface(rendererID, rendererInterface) {
      this._rendererInterfaces[rendererID] = rendererInterface;

      if (this._isProfiling) {
        rendererInterface.startProfiling(this._recordChangeDescriptions);
      }

      rendererInterface.setTraceUpdatesEnabled(this._traceUpdatesEnabled); // When the renderer is attached, we need to tell it whether
      // we remember the previous selection that we'd like to restore.
      // It'll start tracking mounts for matches to the last selection path.

      var selection = this._persistedSelection;

      if (selection !== null && selection.rendererID === rendererID) {
        rendererInterface.setTrackedPath(selection.path);
      }
    }
  }, {
    key: "onUnsupportedRenderer",
    value: function onUnsupportedRenderer(rendererID) {
      this._bridge.send('unsupportedRendererVersion', rendererID);
    }
  }, {
    key: "rendererInterfaces",
    get: function get() {
      return this._rendererInterfaces;
    }
  }]);

  return Agent;
}(EventEmitter);


// CONCATENATED MODULE: ../react-devtools-shared/src/hook.js
function hook_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { hook_typeof = function _typeof(obj) { return typeof obj; }; } else { hook_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return hook_typeof(obj); }

function hook_toConsumableArray(arr) { return hook_arrayWithoutHoles(arr) || hook_iterableToArray(arr) || hook_unsupportedIterableToArray(arr) || hook_nonIterableSpread(); }

function hook_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function hook_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return hook_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return hook_arrayLikeToArray(o, minLen); }

function hook_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function hook_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return hook_arrayLikeToArray(arr); }

function hook_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Install the hook on window, which is an event emitter.
 * Note: this global hook __REACT_DEVTOOLS_GLOBAL_HOOK__ is a de facto public API.
 * It's especially important to avoid creating direct dependency on the DevTools Backend.
 * That's why we still inline the whole event emitter implementation,
 * the string format implementation, and part of the console implementation here.
 *
 * 
 */
function installHook(target) {
  if (target.hasOwnProperty('__REACT_DEVTOOLS_GLOBAL_HOOK__')) {
    return null;
  }

  var targetConsole = console;
  var targetConsoleMethods = {};

  for (var method in console) {
    targetConsoleMethods[method] = console[method];
  }

  function dangerous_setTargetConsoleForTesting(targetConsoleForTesting) {
    targetConsole = targetConsoleForTesting;
    targetConsoleMethods = {};

    for (var _method in targetConsole) {
      targetConsoleMethods[_method] = console[_method];
    }
  }

  function detectReactBuildType(renderer) {
    try {
      if (typeof renderer.version === 'string') {
        // React DOM Fiber (16+)
        if (renderer.bundleType > 0) {
          // This is not a production build.
          // We are currently only using 0 (PROD) and 1 (DEV)
          // but might add 2 (PROFILE) in the future.
          return 'development';
        } // React 16 uses flat bundles. If we report the bundle as production
        // version, it means we also minified and envified it ourselves.


        return 'production'; // Note: There is still a risk that the CommonJS entry point has not
        // been envified or uglified. In this case the user would have *both*
        // development and production bundle, but only the prod one would run.
        // This would be really bad. We have a separate check for this because
        // it happens *outside* of the renderer injection. See `checkDCE` below.
      } // $FlowFixMe[method-unbinding]


      var _toString = Function.prototype.toString;

      if (renderer.Mount && renderer.Mount._renderNewRootComponent) {
        // React DOM Stack
        var renderRootCode = _toString.call(renderer.Mount._renderNewRootComponent); // Filter out bad results (if that is even possible):


        if (renderRootCode.indexOf('function') !== 0) {
          // Hope for the best if we're not sure.
          return 'production';
        } // Check for React DOM Stack < 15.1.0 in development.
        // If it contains "storedMeasure" call, it's wrapped in ReactPerf (DEV only).
        // This would be true even if it's minified, as method name still matches.


        if (renderRootCode.indexOf('storedMeasure') !== -1) {
          return 'development';
        } // For other versions (and configurations) it's not so easy.
        // Let's quickly exclude proper production builds.
        // If it contains a warning message, it's either a DEV build,
        // or an PROD build without proper dead code elimination.


        if (renderRootCode.indexOf('should be a pure function') !== -1) {
          // Now how do we tell a DEV build from a bad PROD build?
          // If we see NODE_ENV, we're going to assume this is a dev build
          // because most likely it is referring to an empty shim.
          if (renderRootCode.indexOf('NODE_ENV') !== -1) {
            return 'development';
          } // If we see "development", we're dealing with an envified DEV build
          // (such as the official React DEV UMD).


          if (renderRootCode.indexOf('development') !== -1) {
            return 'development';
          } // I've seen process.env.NODE_ENV !== 'production' being smartly
          // replaced by `true` in DEV by Webpack. I don't know how that
          // works but we can safely guard against it because `true` was
          // never used in the function source since it was written.


          if (renderRootCode.indexOf('true') !== -1) {
            return 'development';
          } // By now either it is a production build that has not been minified,
          // or (worse) this is a minified development build using non-standard
          // environment (e.g. "staging"). We're going to look at whether
          // the function argument name is mangled:


          if ( // 0.13 to 15
          renderRootCode.indexOf('nextElement') !== -1 || // 0.12
          renderRootCode.indexOf('nextComponent') !== -1) {
            // We can't be certain whether this is a development build or not,
            // but it is definitely unminified.
            return 'unminified';
          } else {
            // This is likely a minified development build.
            return 'development';
          }
        } // By now we know that it's envified and dead code elimination worked,
        // but what if it's still not minified? (Is this even possible?)
        // Let's check matches for the first argument name.


        if ( // 0.13 to 15
        renderRootCode.indexOf('nextElement') !== -1 || // 0.12
        renderRootCode.indexOf('nextComponent') !== -1) {
          return 'unminified';
        } // Seems like we're using the production version.
        // However, the branch above is Stack-only so this is 15 or earlier.


        return 'outdated';
      }
    } catch (err) {// Weird environments may exist.
      // This code needs a higher fault tolerance
      // because it runs even with closed DevTools.
      // TODO: should we catch errors in all injected code, and not just this part?
    }

    return 'production';
  }

  function checkDCE(fn) {
    // This runs for production versions of React.
    // Needs to be super safe.
    try {
      // $FlowFixMe[method-unbinding]
      var _toString2 = Function.prototype.toString;

      var code = _toString2.call(fn); // This is a string embedded in the passed function under DEV-only
      // condition. However the function executes only in PROD. Therefore,
      // if we see it, dead code elimination did not work.


      if (code.indexOf('^_^') > -1) {
        // Remember to report during next injection.
        hasDetectedBadDCE = true; // Bonus: throw an exception hoping that it gets picked up by a reporting system.
        // Not synchronously so that it doesn't break the calling code.

        setTimeout(function () {
          throw new Error('React is running in production mode, but dead code ' + 'elimination has not been applied. Read how to correctly ' + 'configure React for production: ' + 'https://reactjs.org/link/perf-use-production-build');
        });
      }
    } catch (err) {}
  } // NOTE: KEEP IN SYNC with src/backend/utils.js


  function formatWithStyles(inputArgs, style) {
    if (inputArgs === undefined || inputArgs === null || inputArgs.length === 0 || // Matches any of %c but not %%c
    typeof inputArgs[0] === 'string' && inputArgs[0].match(/([^%]|^)(%c)/g) || style === undefined) {
      return inputArgs;
    } // Matches any of %(o|O|d|i|s|f), but not %%(o|O|d|i|s|f)


    var REGEXP = /([^%]|^)((%%)*)(%([oOdisf]))/g;

    if (typeof inputArgs[0] === 'string' && inputArgs[0].match(REGEXP)) {
      return ["%c".concat(inputArgs[0]), style].concat(hook_toConsumableArray(inputArgs.slice(1)));
    } else {
      var firstArg = inputArgs.reduce(function (formatStr, elem, i) {
        if (i > 0) {
          formatStr += ' ';
        }

        switch (hook_typeof(elem)) {
          case 'string':
          case 'boolean':
          case 'symbol':
            return formatStr += '%s';

          case 'number':
            var formatting = Number.isInteger(elem) ? '%i' : '%f';
            return formatStr += formatting;

          default:
            return formatStr += '%o';
        }
      }, '%c');
      return [firstArg, style].concat(hook_toConsumableArray(inputArgs));
    }
  }

  var unpatchFn = null; // NOTE: KEEP IN SYNC with src/backend/console.js:patchForStrictMode
  // This function hides or dims console logs during the initial double renderer
  // in Strict Mode. We need this function because during initial render,
  // React and DevTools are connecting and the renderer interface isn't avaiable
  // and we want to be able to have consistent logging behavior for double logs
  // during the initial renderer.

  function patchConsoleForInitialRenderInStrictMode(_ref) {
    var hideConsoleLogsInStrictMode = _ref.hideConsoleLogsInStrictMode,
        browserTheme = _ref.browserTheme;
    var overrideConsoleMethods = ['error', 'group', 'groupCollapsed', 'info', 'log', 'trace', 'warn'];

    if (unpatchFn !== null) {
      // Don't patch twice.
      return;
    }

    var originalConsoleMethods = {};

    unpatchFn = function unpatchFn() {
      for (var _method2 in originalConsoleMethods) {
        try {
          targetConsole[_method2] = originalConsoleMethods[_method2];
        } catch (error) {}
      }
    };

    overrideConsoleMethods.forEach(function (method) {
      try {
        var originalMethod = originalConsoleMethods[method] = targetConsole[method].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ ? targetConsole[method].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ : targetConsole[method];

        var overrideMethod = function overrideMethod() {
          if (!hideConsoleLogsInStrictMode) {
            // Dim the text color of the double logs if we're not
            // hiding them.
            var color;

            switch (method) {
              case 'warn':
                color = browserTheme === 'light' ? "rgba(250, 180, 50, 0.75)" : "rgba(250, 180, 50, 0.5)";
                break;

              case 'error':
                color = browserTheme === 'light' ? "rgba(250, 123, 130, 0.75)" : "rgba(250, 123, 130, 0.5)";
                break;

              case 'log':
              default:
                color = browserTheme === 'light' ? "rgba(125, 125, 125, 0.75)" : "rgba(125, 125, 125, 0.5)";
                break;
            }

            if (color) {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              originalMethod.apply(void 0, hook_toConsumableArray(formatWithStyles(args, "color: ".concat(color))));
            } else {
              throw Error('Console color is not defined');
            }
          }
        };

        overrideMethod.__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ = originalMethod;
        originalMethod.__REACT_DEVTOOLS_STRICT_MODE_OVERRIDE_METHOD__ = overrideMethod;
        targetConsole[method] = overrideMethod;
      } catch (error) {}
    });
  } // NOTE: KEEP IN SYNC with src/backend/console.js:unpatchForStrictMode


  function unpatchConsoleForInitialRenderInStrictMode() {
    if (unpatchFn !== null) {
      unpatchFn();
      unpatchFn = null;
    }
  }

  var uidCounter = 0;

  function inject(renderer) {
    var id = ++uidCounter;
    renderers.set(id, renderer);
    var reactBuildType = hasDetectedBadDCE ? 'deadcode' : detectReactBuildType(renderer); // Patching the console enables DevTools to do a few useful things:
    // * Append component stacks to warnings and error messages
    // * Disabling or marking logs during a double render in Strict Mode
    // * Disable logging during re-renders to inspect hooks (see inspectHooksOfFiber)
    //
    // Allow patching console early (during injection) to
    // provide developers with components stacks even if they don't run DevTools.

    if (target.hasOwnProperty('__REACT_DEVTOOLS_CONSOLE_FUNCTIONS__')) {
      var _target$__REACT_DEVTO = target.__REACT_DEVTOOLS_CONSOLE_FUNCTIONS__,
          registerRendererWithConsole = _target$__REACT_DEVTO.registerRendererWithConsole,
          patchConsoleUsingWindowValues = _target$__REACT_DEVTO.patchConsoleUsingWindowValues;

      if (typeof registerRendererWithConsole === 'function' && typeof patchConsoleUsingWindowValues === 'function') {
        registerRendererWithConsole(renderer);
        patchConsoleUsingWindowValues();
      }
    } // If we have just reloaded to profile, we need to inject the renderer interface before the app loads.
    // Otherwise the renderer won't yet exist and we can skip this step.


    var attach = target.__REACT_DEVTOOLS_ATTACH__;

    if (typeof attach === 'function') {
      var rendererInterface = attach(hook, id, renderer, target);
      hook.rendererInterfaces.set(id, rendererInterface);
    }

    hook.emit('renderer', {
      id: id,
      renderer: renderer,
      reactBuildType: reactBuildType
    });
    return id;
  }

  var hasDetectedBadDCE = false;

  function sub(event, fn) {
    hook.on(event, fn);
    return function () {
      return hook.off(event, fn);
    };
  }

  function on(event, fn) {
    if (!listeners[event]) {
      listeners[event] = [];
    }

    listeners[event].push(fn);
  }

  function off(event, fn) {
    if (!listeners[event]) {
      return;
    }

    var index = listeners[event].indexOf(fn);

    if (index !== -1) {
      listeners[event].splice(index, 1);
    }

    if (!listeners[event].length) {
      delete listeners[event];
    }
  }

  function emit(event, data) {
    if (listeners[event]) {
      listeners[event].map(function (fn) {
        return fn(data);
      });
    }
  }

  function getFiberRoots(rendererID) {
    var roots = fiberRoots;

    if (!roots[rendererID]) {
      roots[rendererID] = new Set();
    }

    return roots[rendererID];
  }

  function onCommitFiberUnmount(rendererID, fiber) {
    var rendererInterface = rendererInterfaces.get(rendererID);

    if (rendererInterface != null) {
      rendererInterface.handleCommitFiberUnmount(fiber);
    }
  }

  function onCommitFiberRoot(rendererID, root, priorityLevel) {
    var mountedRoots = hook.getFiberRoots(rendererID);
    var current = root.current;
    var isKnownRoot = mountedRoots.has(root);
    var isUnmounting = current.memoizedState == null || current.memoizedState.element == null; // Keep track of mounted roots so we can hydrate when DevTools connect.

    if (!isKnownRoot && !isUnmounting) {
      mountedRoots.add(root);
    } else if (isKnownRoot && isUnmounting) {
      mountedRoots.delete(root);
    }

    var rendererInterface = rendererInterfaces.get(rendererID);

    if (rendererInterface != null) {
      rendererInterface.handleCommitFiberRoot(root, priorityLevel);
    }
  }

  function onPostCommitFiberRoot(rendererID, root) {
    var rendererInterface = rendererInterfaces.get(rendererID);

    if (rendererInterface != null) {
      rendererInterface.handlePostCommitFiberRoot(root);
    }
  }

  function setStrictMode(rendererID, isStrictMode) {
    var rendererInterface = rendererInterfaces.get(rendererID);

    if (rendererInterface != null) {
      if (isStrictMode) {
        rendererInterface.patchConsoleForStrictMode();
      } else {
        rendererInterface.unpatchConsoleForStrictMode();
      }
    } else {
      // This should only happen during initial render in the extension before DevTools
      // finishes its handshake with the injected renderer
      if (isStrictMode) {
        var hideConsoleLogsInStrictMode = window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__ === true;
        var browserTheme = window.__REACT_DEVTOOLS_BROWSER_THEME__;
        patchConsoleForInitialRenderInStrictMode({
          hideConsoleLogsInStrictMode: hideConsoleLogsInStrictMode,
          browserTheme: browserTheme
        });
      } else {
        unpatchConsoleForInitialRenderInStrictMode();
      }
    }
  }

  var openModuleRangesStack = [];
  var moduleRanges = [];

  function getTopStackFrameString(error) {
    var frames = error.stack.split('\n');
    var frame = frames.length > 1 ? frames[1] : null;
    return frame;
  }

  function getInternalModuleRanges() {
    return moduleRanges;
  }

  function registerInternalModuleStart(error) {
    var startStackFrame = getTopStackFrameString(error);

    if (startStackFrame !== null) {
      openModuleRangesStack.push(startStackFrame);
    }
  }

  function registerInternalModuleStop(error) {
    if (openModuleRangesStack.length > 0) {
      var startStackFrame = openModuleRangesStack.pop();
      var stopStackFrame = getTopStackFrameString(error);

      if (stopStackFrame !== null) {
        moduleRanges.push([startStackFrame, stopStackFrame]);
      }
    }
  } // TODO: More meaningful names for "rendererInterfaces" and "renderers".


  var fiberRoots = {};
  var rendererInterfaces = new Map();
  var listeners = {};
  var renderers = new Map();
  var backends = new Map();
  var hook = {
    rendererInterfaces: rendererInterfaces,
    listeners: listeners,
    backends: backends,
    // Fast Refresh for web relies on this.
    renderers: renderers,
    emit: emit,
    getFiberRoots: getFiberRoots,
    inject: inject,
    on: on,
    off: off,
    sub: sub,
    // This is a legacy flag.
    // React v16 checks the hook for this to ensure DevTools is new enough.
    supportsFiber: true,
    // React calls these methods.
    checkDCE: checkDCE,
    onCommitFiberUnmount: onCommitFiberUnmount,
    onCommitFiberRoot: onCommitFiberRoot,
    onPostCommitFiberRoot: onPostCommitFiberRoot,
    setStrictMode: setStrictMode,
    // Schedule Profiler runtime helpers.
    // These internal React modules to report their own boundaries
    // which in turn enables the profiler to dim or filter internal frames.
    getInternalModuleRanges: getInternalModuleRanges,
    registerInternalModuleStart: registerInternalModuleStart,
    registerInternalModuleStop: registerInternalModuleStop
  };

  if (false) {}

  Object.defineProperty(target, '__REACT_DEVTOOLS_GLOBAL_HOOK__', {
    // This property needs to be configurable for the test environment,
    // else we won't be able to delete and recreate it between tests.
    configurable: false,
    enumerable: false,
    get: function get() {
      return hook;
    }
  });
  return hook;
}
// EXTERNAL MODULE: ../react-devtools-shared/src/backend/renderer.js + 6 modules
var backend_renderer = __webpack_require__(13);

// EXTERNAL MODULE: ../react-devtools-shared/src/types.js
var types = __webpack_require__(1);

// EXTERNAL MODULE: ../react-devtools-shared/src/utils.js
var src_utils = __webpack_require__(0);

// CONCATENATED MODULE: ../react-devtools-shared/src/backend/legacy/utils.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function decorate(object, attr, fn) {
  var old = object[attr]; // $FlowFixMe[missing-this-annot] webpack config needs to be updated to allow `this` type annotations

  object[attr] = function (instance) {
    return fn.call(this, old, arguments);
  };

  return old;
}
function decorateMany(source, fns) {
  var olds = {};

  for (var name in fns) {
    olds[name] = decorate(source, name, fns[name]);
  }

  return olds;
}
function restoreMany(source, olds) {
  for (var name in olds) {
    source[name] = olds[name];
  }
} // $FlowFixMe[missing-this-annot] webpack config needs to be updated to allow `this` type annotations

function forceUpdate(instance) {
  if (typeof instance.forceUpdate === 'function') {
    instance.forceUpdate();
  } else if (instance.updater != null && typeof instance.updater.enqueueForceUpdate === 'function') {
    instance.updater.enqueueForceUpdate(this, function () {}, 'forceUpdate');
  }
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/legacy/renderer.js
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { renderer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function renderer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function renderer_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { renderer_typeof = function _typeof(obj) { return typeof obj; }; } else { renderer_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return renderer_typeof(obj); }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */







function getData(internalInstance) {
  var displayName = null;
  var key = null; // != used deliberately here to catch undefined and null

  if (internalInstance._currentElement != null) {
    if (internalInstance._currentElement.key) {
      key = String(internalInstance._currentElement.key);
    }

    var elementType = internalInstance._currentElement.type;

    if (typeof elementType === 'string') {
      displayName = elementType;
    } else if (typeof elementType === 'function') {
      displayName = Object(src_utils["h" /* getDisplayName */])(elementType);
    }
  }

  return {
    displayName: displayName,
    key: key
  };
}

function getElementType(internalInstance) {
  // != used deliberately here to catch undefined and null
  if (internalInstance._currentElement != null) {
    var elementType = internalInstance._currentElement.type;

    if (typeof elementType === 'function') {
      var publicInstance = internalInstance.getPublicInstance();

      if (publicInstance !== null) {
        return types["e" /* ElementTypeClass */];
      } else {
        return types["h" /* ElementTypeFunction */];
      }
    } else if (typeof elementType === 'string') {
      return types["i" /* ElementTypeHostComponent */];
    }
  }

  return types["k" /* ElementTypeOtherOrUnknown */];
}

function getChildren(internalInstance) {
  var children = []; // If the parent is a native node without rendered children, but with
  // multiple string children, then the `element` that gets passed in here is
  // a plain value -- a string or number.

  if (renderer_typeof(internalInstance) !== 'object') {// No children
  } else if (internalInstance._currentElement === null || internalInstance._currentElement === false) {// No children
  } else if (internalInstance._renderedComponent) {
    var child = internalInstance._renderedComponent;

    if (getElementType(child) !== types["k" /* ElementTypeOtherOrUnknown */]) {
      children.push(child);
    }
  } else if (internalInstance._renderedChildren) {
    var renderedChildren = internalInstance._renderedChildren;

    for (var name in renderedChildren) {
      var _child = renderedChildren[name];

      if (getElementType(_child) !== types["k" /* ElementTypeOtherOrUnknown */]) {
        children.push(_child);
      }
    }
  } // Note: we skip the case where children are just strings or numbers
  // because the new DevTools skips over host text nodes anyway.


  return children;
}

function attach(hook, rendererID, renderer, global) {
  var idToInternalInstanceMap = new Map();
  var internalInstanceToIDMap = new WeakMap();
  var internalInstanceToRootIDMap = new WeakMap();
  var getInternalIDForNative = null;
  var findNativeNodeForInternalID;

  var getFiberForNative = function getFiberForNative(node) {
    // Not implemented.
    return null;
  };

  if (renderer.ComponentTree) {
    getInternalIDForNative = function getInternalIDForNative(node, findNearestUnfilteredAncestor) {
      var internalInstance = renderer.ComponentTree.getClosestInstanceFromNode(node);
      return internalInstanceToIDMap.get(internalInstance) || null;
    };

    findNativeNodeForInternalID = function findNativeNodeForInternalID(id) {
      var internalInstance = idToInternalInstanceMap.get(id);
      return renderer.ComponentTree.getNodeFromInstance(internalInstance);
    };

    getFiberForNative = function getFiberForNative(node) {
      return renderer.ComponentTree.getClosestInstanceFromNode(node);
    };
  } else if (renderer.Mount.getID && renderer.Mount.getNode) {
    getInternalIDForNative = function getInternalIDForNative(node, findNearestUnfilteredAncestor) {
      // Not implemented.
      return null;
    };

    findNativeNodeForInternalID = function findNativeNodeForInternalID(id) {
      // Not implemented.
      return null;
    };
  }

  function getDisplayNameForFiberID(id) {
    var internalInstance = idToInternalInstanceMap.get(id);
    return internalInstance ? getData(internalInstance).displayName : null;
  }

  function getID(internalInstance) {
    if (renderer_typeof(internalInstance) !== 'object' || internalInstance === null) {
      throw new Error('Invalid internal instance: ' + internalInstance);
    }

    if (!internalInstanceToIDMap.has(internalInstance)) {
      var _id = Object(src_utils["k" /* getUID */])();

      internalInstanceToIDMap.set(internalInstance, _id);
      idToInternalInstanceMap.set(_id, internalInstance);
    }

    return internalInstanceToIDMap.get(internalInstance);
  }

  function areEqualArrays(a, b) {
    if (a.length !== b.length) {
      return false;
    }

    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }

    return true;
  } // This is shared mutable state that lets us keep track of where we are.


  var parentIDStack = [];
  var oldReconcilerMethods = null;

  if (renderer.Reconciler) {
    // React 15
    oldReconcilerMethods = decorateMany(renderer.Reconciler, {
      mountComponent: function mountComponent(fn, args) {
        var internalInstance = args[0];
        var hostContainerInfo = args[3];

        if (getElementType(internalInstance) === types["k" /* ElementTypeOtherOrUnknown */]) {
          // $FlowFixMe[object-this-reference] found when upgrading Flow
          return fn.apply(this, args);
        }

        if (hostContainerInfo._topLevelWrapper === undefined) {
          // SSR
          // $FlowFixMe[object-this-reference] found when upgrading Flow
          return fn.apply(this, args);
        }

        var id = getID(internalInstance); // Push the operation.

        var parentID = parentIDStack.length > 0 ? parentIDStack[parentIDStack.length - 1] : 0;
        recordMount(internalInstance, id, parentID);
        parentIDStack.push(id); // Remember the root.

        internalInstanceToRootIDMap.set(internalInstance, getID(hostContainerInfo._topLevelWrapper));

        try {
          // $FlowFixMe[object-this-reference] found when upgrading Flow
          var result = fn.apply(this, args);
          parentIDStack.pop();
          return result;
        } catch (err) {
          // $FlowFixMe[incompatible-type] found when upgrading Flow
          parentIDStack = [];
          throw err;
        } finally {
          if (parentIDStack.length === 0) {
            var rootID = internalInstanceToRootIDMap.get(internalInstance);

            if (rootID === undefined) {
              throw new Error('Expected to find root ID.');
            }

            flushPendingEvents(rootID);
          }
        }
      },
      performUpdateIfNecessary: function performUpdateIfNecessary(fn, args) {
        var internalInstance = args[0];

        if (getElementType(internalInstance) === types["k" /* ElementTypeOtherOrUnknown */]) {
          // $FlowFixMe[object-this-reference] found when upgrading Flow
          return fn.apply(this, args);
        }

        var id = getID(internalInstance);
        parentIDStack.push(id);
        var prevChildren = getChildren(internalInstance);

        try {
          // $FlowFixMe[object-this-reference] found when upgrading Flow
          var result = fn.apply(this, args);
          var nextChildren = getChildren(internalInstance);

          if (!areEqualArrays(prevChildren, nextChildren)) {
            // Push the operation
            recordReorder(internalInstance, id, nextChildren);
          }

          parentIDStack.pop();
          return result;
        } catch (err) {
          // $FlowFixMe[incompatible-type] found when upgrading Flow
          parentIDStack = [];
          throw err;
        } finally {
          if (parentIDStack.length === 0) {
            var rootID = internalInstanceToRootIDMap.get(internalInstance);

            if (rootID === undefined) {
              throw new Error('Expected to find root ID.');
            }

            flushPendingEvents(rootID);
          }
        }
      },
      receiveComponent: function receiveComponent(fn, args) {
        var internalInstance = args[0];

        if (getElementType(internalInstance) === types["k" /* ElementTypeOtherOrUnknown */]) {
          // $FlowFixMe[object-this-reference] found when upgrading Flow
          return fn.apply(this, args);
        }

        var id = getID(internalInstance);
        parentIDStack.push(id);
        var prevChildren = getChildren(internalInstance);

        try {
          // $FlowFixMe[object-this-reference] found when upgrading Flow
          var result = fn.apply(this, args);
          var nextChildren = getChildren(internalInstance);

          if (!areEqualArrays(prevChildren, nextChildren)) {
            // Push the operation
            recordReorder(internalInstance, id, nextChildren);
          }

          parentIDStack.pop();
          return result;
        } catch (err) {
          // $FlowFixMe[incompatible-type] found when upgrading Flow
          parentIDStack = [];
          throw err;
        } finally {
          if (parentIDStack.length === 0) {
            var rootID = internalInstanceToRootIDMap.get(internalInstance);

            if (rootID === undefined) {
              throw new Error('Expected to find root ID.');
            }

            flushPendingEvents(rootID);
          }
        }
      },
      unmountComponent: function unmountComponent(fn, args) {
        var internalInstance = args[0];

        if (getElementType(internalInstance) === types["k" /* ElementTypeOtherOrUnknown */]) {
          // $FlowFixMe[object-this-reference] found when upgrading Flow
          return fn.apply(this, args);
        }

        var id = getID(internalInstance);
        parentIDStack.push(id);

        try {
          // $FlowFixMe[object-this-reference] found when upgrading Flow
          var result = fn.apply(this, args);
          parentIDStack.pop(); // Push the operation.

          recordUnmount(internalInstance, id);
          return result;
        } catch (err) {
          // $FlowFixMe[incompatible-type] found when upgrading Flow
          parentIDStack = [];
          throw err;
        } finally {
          if (parentIDStack.length === 0) {
            var rootID = internalInstanceToRootIDMap.get(internalInstance);

            if (rootID === undefined) {
              throw new Error('Expected to find root ID.');
            }

            flushPendingEvents(rootID);
          }
        }
      }
    });
  }

  function cleanup() {
    if (oldReconcilerMethods !== null) {
      if (renderer.Component) {
        restoreMany(renderer.Component.Mixin, oldReconcilerMethods);
      } else {
        restoreMany(renderer.Reconciler, oldReconcilerMethods);
      }
    }

    oldReconcilerMethods = null;
  }

  function recordMount(internalInstance, id, parentID) {
    var isRoot = parentID === 0;

    if (constants["s" /* __DEBUG__ */]) {
      console.log('%crecordMount()', 'color: green; font-weight: bold;', id, getData(internalInstance).displayName);
    }

    if (isRoot) {
      // TODO Is this right? For all versions?
      var hasOwnerMetadata = internalInstance._currentElement != null && internalInstance._currentElement._owner != null;
      pushOperation(constants["l" /* TREE_OPERATION_ADD */]);
      pushOperation(id);
      pushOperation(types["m" /* ElementTypeRoot */]);
      pushOperation(0); // StrictMode compliant?

      pushOperation(0); // Profiling flag

      pushOperation(0); // StrictMode supported?

      pushOperation(hasOwnerMetadata ? 1 : 0);
    } else {
      var type = getElementType(internalInstance);

      var _getData = getData(internalInstance),
          displayName = _getData.displayName,
          key = _getData.key;

      var ownerID = internalInstance._currentElement != null && internalInstance._currentElement._owner != null ? getID(internalInstance._currentElement._owner) : 0;
      var displayNameStringID = getStringID(displayName);
      var keyStringID = getStringID(key);
      pushOperation(constants["l" /* TREE_OPERATION_ADD */]);
      pushOperation(id);
      pushOperation(type);
      pushOperation(parentID);
      pushOperation(ownerID);
      pushOperation(displayNameStringID);
      pushOperation(keyStringID);
    }
  }

  function recordReorder(internalInstance, id, nextChildren) {
    pushOperation(constants["o" /* TREE_OPERATION_REORDER_CHILDREN */]);
    pushOperation(id);
    var nextChildIDs = nextChildren.map(getID);
    pushOperation(nextChildIDs.length);

    for (var i = 0; i < nextChildIDs.length; i++) {
      pushOperation(nextChildIDs[i]);
    }
  }

  function recordUnmount(internalInstance, id) {
    pendingUnmountedIDs.push(id);
    idToInternalInstanceMap.delete(id);
  }

  function crawlAndRecordInitialMounts(id, parentID, rootID) {
    if (constants["s" /* __DEBUG__ */]) {
      console.group('crawlAndRecordInitialMounts() id:', id);
    }

    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance != null) {
      internalInstanceToRootIDMap.set(internalInstance, rootID);
      recordMount(internalInstance, id, parentID);
      getChildren(internalInstance).forEach(function (child) {
        return crawlAndRecordInitialMounts(getID(child), id, rootID);
      });
    }

    if (constants["s" /* __DEBUG__ */]) {
      console.groupEnd();
    }
  }

  function flushInitialOperations() {
    // Crawl roots though and register any nodes that mounted before we were injected.
    var roots = renderer.Mount._instancesByReactRootID || renderer.Mount._instancesByContainerID;

    for (var key in roots) {
      var internalInstance = roots[key];

      var _id2 = getID(internalInstance);

      crawlAndRecordInitialMounts(_id2, 0, _id2);
      flushPendingEvents(_id2);
    }
  }

  var pendingOperations = [];
  var pendingStringTable = new Map();
  var pendingUnmountedIDs = [];
  var pendingStringTableLength = 0;
  var pendingUnmountedRootID = null;

  function flushPendingEvents(rootID) {
    if (pendingOperations.length === 0 && pendingUnmountedIDs.length === 0 && pendingUnmountedRootID === null) {
      return;
    }

    var numUnmountIDs = pendingUnmountedIDs.length + (pendingUnmountedRootID === null ? 0 : 1);
    var operations = new Array( // Identify which renderer this update is coming from.
    2 + // [rendererID, rootFiberID]
    // How big is the string table?
    1 + // [stringTableLength]
    // Then goes the actual string table.
    pendingStringTableLength + ( // All unmounts are batched in a single message.
    // [TREE_OPERATION_REMOVE, removedIDLength, ...ids]
    numUnmountIDs > 0 ? 2 + numUnmountIDs : 0) + // Mount operations
    pendingOperations.length); // Identify which renderer this update is coming from.
    // This enables roots to be mapped to renderers,
    // Which in turn enables fiber properations, states, and hooks to be inspected.

    var i = 0;
    operations[i++] = rendererID;
    operations[i++] = rootID; // Now fill in the string table.
    // [stringTableLength, str1Length, ...str1, str2Length, ...str2, ...]

    operations[i++] = pendingStringTableLength;
    pendingStringTable.forEach(function (value, key) {
      operations[i++] = key.length;
      var encodedKey = Object(src_utils["p" /* utfEncodeString */])(key);

      for (var j = 0; j < encodedKey.length; j++) {
        operations[i + j] = encodedKey[j];
      }

      i += key.length;
    });

    if (numUnmountIDs > 0) {
      // All unmounts except roots are batched in a single message.
      operations[i++] = constants["m" /* TREE_OPERATION_REMOVE */]; // The first number is how many unmounted IDs we're gonna send.

      operations[i++] = numUnmountIDs; // Fill in the unmounts

      for (var j = 0; j < pendingUnmountedIDs.length; j++) {
        operations[i++] = pendingUnmountedIDs[j];
      } // The root ID should always be unmounted last.


      if (pendingUnmountedRootID !== null) {
        operations[i] = pendingUnmountedRootID;
        i++;
      }
    } // Fill in the rest of the operations.


    for (var _j = 0; _j < pendingOperations.length; _j++) {
      operations[i + _j] = pendingOperations[_j];
    }

    i += pendingOperations.length;

    if (constants["s" /* __DEBUG__ */]) {
      Object(src_utils["m" /* printOperationsArray */])(operations);
    } // If we've already connected to the frontend, just pass the operations through.


    hook.emit('operations', operations);
    pendingOperations.length = 0;
    pendingUnmountedIDs = [];
    pendingUnmountedRootID = null;
    pendingStringTable.clear();
    pendingStringTableLength = 0;
  }

  function pushOperation(op) {
    if (false) {}

    pendingOperations.push(op);
  }

  function getStringID(str) {
    if (str === null) {
      return 0;
    }

    var existingID = pendingStringTable.get(str);

    if (existingID !== undefined) {
      return existingID;
    }

    var stringID = pendingStringTable.size + 1;
    pendingStringTable.set(str, stringID); // The string table total length needs to account
    // both for the string length, and for the array item
    // that contains the length itself. Hence + 1.

    pendingStringTableLength += str.length + 1;
    return stringID;
  }

  var currentlyInspectedElementID = null;
  var currentlyInspectedPaths = {}; // Track the intersection of currently inspected paths,
  // so that we can send their data along if the element is re-rendered.

  function mergeInspectedPaths(path) {
    var current = currentlyInspectedPaths;
    path.forEach(function (key) {
      if (!current[key]) {
        current[key] = {};
      }

      current = current[key];
    });
  }

  function createIsPathAllowed(key) {
    // This function helps prevent previously-inspected paths from being dehydrated in updates.
    // This is important to avoid a bad user experience where expanded toggles collapse on update.
    return function isPathAllowed(path) {
      var current = currentlyInspectedPaths[key];

      if (!current) {
        return false;
      }

      for (var i = 0; i < path.length; i++) {
        current = current[path[i]];

        if (!current) {
          return false;
        }
      }

      return true;
    };
  } // Fast path props lookup for React Native style editor.


  function getInstanceAndStyle(id) {
    var instance = null;
    var style = null;
    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance != null) {
      instance = internalInstance._instance || null;
      var element = internalInstance._currentElement;

      if (element != null && element.props != null) {
        style = element.props.style || null;
      }
    }

    return {
      instance: instance,
      style: style
    };
  }

  function updateSelectedElement(id) {
    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance == null) {
      console.warn("Could not find instance with id \"".concat(id, "\""));
      return;
    }

    switch (getElementType(internalInstance)) {
      case types["e" /* ElementTypeClass */]:
        global.$r = internalInstance._instance;
        break;

      case types["h" /* ElementTypeFunction */]:
        var element = internalInstance._currentElement;

        if (element == null) {
          console.warn("Could not find element with id \"".concat(id, "\""));
          return;
        }

        global.$r = {
          props: element.props,
          type: element.type
        };
        break;

      default:
        global.$r = null;
        break;
    }
  }

  function storeAsGlobal(id, path, count) {
    var inspectedElement = inspectElementRaw(id);

    if (inspectedElement !== null) {
      var value = Object(src_utils["j" /* getInObject */])(inspectedElement, path);
      var key = "$reactTemp".concat(count);
      window[key] = value;
      console.log(key);
      console.log(value);
    }
  }

  function getSerializedElementValueByPath(id, path) {
    var inspectedElement = inspectElementRaw(id);

    if (inspectedElement !== null) {
      var valueToCopy = Object(src_utils["j" /* getInObject */])(inspectedElement, path);
      return Object(utils["l" /* serializeToString */])(valueToCopy);
    }
  }

  function inspectElement(requestID, id, path, forceFullData) {
    if (forceFullData || currentlyInspectedElementID !== id) {
      currentlyInspectedElementID = id;
      currentlyInspectedPaths = {};
    }

    var inspectedElement = inspectElementRaw(id);

    if (inspectedElement === null) {
      return {
        id: id,
        responseID: requestID,
        type: 'not-found'
      };
    }

    if (path !== null) {
      mergeInspectedPaths(path);
    } // Any time an inspected element has an update,
    // we should update the selected $r value as wel.
    // Do this before dehydration (cleanForBridge).


    updateSelectedElement(id);
    inspectedElement.context = Object(utils["a" /* cleanForBridge */])(inspectedElement.context, createIsPathAllowed('context'));
    inspectedElement.props = Object(utils["a" /* cleanForBridge */])(inspectedElement.props, createIsPathAllowed('props'));
    inspectedElement.state = Object(utils["a" /* cleanForBridge */])(inspectedElement.state, createIsPathAllowed('state'));
    return {
      id: id,
      responseID: requestID,
      type: 'full-data',
      value: inspectedElement
    };
  }

  function inspectElementRaw(id) {
    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance == null) {
      return null;
    }

    var _getData2 = getData(internalInstance),
        displayName = _getData2.displayName,
        key = _getData2.key;

    var type = getElementType(internalInstance);
    var context = null;
    var owners = null;
    var props = null;
    var state = null;
    var source = null;
    var element = internalInstance._currentElement;

    if (element !== null) {
      props = element.props;
      source = element._source != null ? element._source : null;
      var owner = element._owner;

      if (owner) {
        owners = [];

        while (owner != null) {
          owners.push({
            displayName: getData(owner).displayName || 'Unknown',
            id: getID(owner),
            key: element.key,
            type: getElementType(owner)
          });

          if (owner._currentElement) {
            owner = owner._currentElement._owner;
          }
        }
      }
    }

    var publicInstance = internalInstance._instance;

    if (publicInstance != null) {
      context = publicInstance.context || null;
      state = publicInstance.state || null;
    } // Not implemented


    var errors = [];
    var warnings = [];
    return {
      id: id,
      // Does the current renderer support editable hooks and function props?
      canEditHooks: false,
      canEditFunctionProps: false,
      // Does the current renderer support advanced editing interface?
      canEditHooksAndDeletePaths: false,
      canEditHooksAndRenamePaths: false,
      canEditFunctionPropsDeletePaths: false,
      canEditFunctionPropsRenamePaths: false,
      // Toggle error boundary did not exist in legacy versions
      canToggleError: false,
      isErrored: false,
      targetErrorBoundaryID: null,
      // Suspense did not exist in legacy versions
      canToggleSuspense: false,
      // Can view component source location.
      canViewSource: type === types["e" /* ElementTypeClass */] || type === types["h" /* ElementTypeFunction */],
      // Only legacy context exists in legacy versions.
      hasLegacyContext: true,
      displayName: displayName,
      type: type,
      key: key != null ? key : null,
      // Inspectable properties.
      context: context,
      hooks: null,
      props: props,
      state: state,
      errors: errors,
      warnings: warnings,
      // List of owners
      owners: owners,
      // Location of component in source code.
      source: source,
      rootType: null,
      rendererPackageName: null,
      rendererVersion: null,
      plugins: {
        stylex: null
      }
    };
  }

  function logElementToConsole(id) {
    var result = inspectElementRaw(id);

    if (result === null) {
      console.warn("Could not find element with id \"".concat(id, "\""));
      return;
    }

    var supportsGroup = typeof console.groupCollapsed === 'function';

    if (supportsGroup) {
      console.groupCollapsed("[Click to expand] %c<".concat(result.displayName || 'Component', " />"), // --dom-tag-name-color is the CSS variable Chrome styles HTML elements with in the console.
      'color: var(--dom-tag-name-color); font-weight: normal;');
    }

    if (result.props !== null) {
      console.log('Props:', result.props);
    }

    if (result.state !== null) {
      console.log('State:', result.state);
    }

    if (result.context !== null) {
      console.log('Context:', result.context);
    }

    var nativeNode = findNativeNodeForInternalID(id);

    if (nativeNode !== null) {
      console.log('Node:', nativeNode);
    }

    if (window.chrome || /firefox/i.test(navigator.userAgent)) {
      console.log('Right-click any value to save it as a global variable for further inspection.');
    }

    if (supportsGroup) {
      console.groupEnd();
    }
  }

  function prepareViewAttributeSource(id, path) {
    var inspectedElement = inspectElementRaw(id);

    if (inspectedElement !== null) {
      window.$attribute = Object(src_utils["j" /* getInObject */])(inspectedElement, path);
    }
  }

  function prepareViewElementSource(id) {
    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance == null) {
      console.warn("Could not find instance with id \"".concat(id, "\""));
      return;
    }

    var element = internalInstance._currentElement;

    if (element == null) {
      console.warn("Could not find element with id \"".concat(id, "\""));
      return;
    }

    global.$type = element.type;
  }

  function deletePath(type, id, hookID, path) {
    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance != null) {
      var publicInstance = internalInstance._instance;

      if (publicInstance != null) {
        switch (type) {
          case 'context':
            Object(src_utils["c" /* deletePathInObject */])(publicInstance.context, path);
            forceUpdate(publicInstance);
            break;

          case 'hooks':
            throw new Error('Hooks not supported by this renderer');

          case 'props':
            var element = internalInstance._currentElement;
            internalInstance._currentElement = _objectSpread(_objectSpread({}, element), {}, {
              props: Object(utils["b" /* copyWithDelete */])(element.props, path)
            });
            forceUpdate(publicInstance);
            break;

          case 'state':
            Object(src_utils["c" /* deletePathInObject */])(publicInstance.state, path);
            forceUpdate(publicInstance);
            break;
        }
      }
    }
  }

  function renamePath(type, id, hookID, oldPath, newPath) {
    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance != null) {
      var publicInstance = internalInstance._instance;

      if (publicInstance != null) {
        switch (type) {
          case 'context':
            Object(src_utils["n" /* renamePathInObject */])(publicInstance.context, oldPath, newPath);
            forceUpdate(publicInstance);
            break;

          case 'hooks':
            throw new Error('Hooks not supported by this renderer');

          case 'props':
            var element = internalInstance._currentElement;
            internalInstance._currentElement = _objectSpread(_objectSpread({}, element), {}, {
              props: Object(utils["c" /* copyWithRename */])(element.props, oldPath, newPath)
            });
            forceUpdate(publicInstance);
            break;

          case 'state':
            Object(src_utils["n" /* renamePathInObject */])(publicInstance.state, oldPath, newPath);
            forceUpdate(publicInstance);
            break;
        }
      }
    }
  }

  function overrideValueAtPath(type, id, hookID, path, value) {
    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance != null) {
      var publicInstance = internalInstance._instance;

      if (publicInstance != null) {
        switch (type) {
          case 'context':
            Object(src_utils["o" /* setInObject */])(publicInstance.context, path, value);
            forceUpdate(publicInstance);
            break;

          case 'hooks':
            throw new Error('Hooks not supported by this renderer');

          case 'props':
            var element = internalInstance._currentElement;
            internalInstance._currentElement = _objectSpread(_objectSpread({}, element), {}, {
              props: Object(utils["d" /* copyWithSet */])(element.props, path, value)
            });
            forceUpdate(publicInstance);
            break;

          case 'state':
            Object(src_utils["o" /* setInObject */])(publicInstance.state, path, value);
            forceUpdate(publicInstance);
            break;
        }
      }
    }
  } // v16+ only features


  var getProfilingData = function getProfilingData() {
    throw new Error('getProfilingData not supported by this renderer');
  };

  var handleCommitFiberRoot = function handleCommitFiberRoot() {
    throw new Error('handleCommitFiberRoot not supported by this renderer');
  };

  var handleCommitFiberUnmount = function handleCommitFiberUnmount() {
    throw new Error('handleCommitFiberUnmount not supported by this renderer');
  };

  var handlePostCommitFiberRoot = function handlePostCommitFiberRoot() {
    throw new Error('handlePostCommitFiberRoot not supported by this renderer');
  };

  var overrideError = function overrideError() {
    throw new Error('overrideError not supported by this renderer');
  };

  var overrideSuspense = function overrideSuspense() {
    throw new Error('overrideSuspense not supported by this renderer');
  };

  var startProfiling = function startProfiling() {// Do not throw, since this would break a multi-root scenario where v15 and v16 were both present.
  };

  var stopProfiling = function stopProfiling() {// Do not throw, since this would break a multi-root scenario where v15 and v16 were both present.
  };

  function getBestMatchForTrackedPath() {
    // Not implemented.
    return null;
  }

  function getPathForElement(id) {
    // Not implemented.
    return null;
  }

  function updateComponentFilters(componentFilters) {// Not implemented.
  }

  function setTraceUpdatesEnabled(enabled) {// Not implemented.
  }

  function setTrackedPath(path) {// Not implemented.
  }

  function getOwnersList(id) {
    // Not implemented.
    return null;
  }

  function clearErrorsAndWarnings() {// Not implemented
  }

  function clearErrorsForFiberID(id) {// Not implemented
  }

  function clearWarningsForFiberID(id) {// Not implemented
  }

  function patchConsoleForStrictMode() {}

  function unpatchConsoleForStrictMode() {}

  return {
    clearErrorsAndWarnings: clearErrorsAndWarnings,
    clearErrorsForFiberID: clearErrorsForFiberID,
    clearWarningsForFiberID: clearWarningsForFiberID,
    cleanup: cleanup,
    getSerializedElementValueByPath: getSerializedElementValueByPath,
    deletePath: deletePath,
    flushInitialOperations: flushInitialOperations,
    getBestMatchForTrackedPath: getBestMatchForTrackedPath,
    getDisplayNameForFiberID: getDisplayNameForFiberID,
    getFiberForNative: getFiberForNative,
    getFiberIDForNative: getInternalIDForNative,
    getInstanceAndStyle: getInstanceAndStyle,
    findNativeNodesForFiberID: function findNativeNodesForFiberID(id) {
      var nativeNode = findNativeNodeForInternalID(id);
      return nativeNode == null ? null : [nativeNode];
    },
    getOwnersList: getOwnersList,
    getPathForElement: getPathForElement,
    getProfilingData: getProfilingData,
    handleCommitFiberRoot: handleCommitFiberRoot,
    handleCommitFiberUnmount: handleCommitFiberUnmount,
    handlePostCommitFiberRoot: handlePostCommitFiberRoot,
    inspectElement: inspectElement,
    logElementToConsole: logElementToConsole,
    overrideError: overrideError,
    overrideSuspense: overrideSuspense,
    overrideValueAtPath: overrideValueAtPath,
    renamePath: renamePath,
    patchConsoleForStrictMode: patchConsoleForStrictMode,
    prepareViewAttributeSource: prepareViewAttributeSource,
    prepareViewElementSource: prepareViewElementSource,
    renderer: renderer,
    setTraceUpdatesEnabled: setTraceUpdatesEnabled,
    setTrackedPath: setTrackedPath,
    startProfiling: startProfiling,
    stopProfiling: stopProfiling,
    storeAsGlobal: storeAsGlobal,
    unpatchConsoleForStrictMode: unpatchConsoleForStrictMode,
    updateComponentFilters: updateComponentFilters
  };
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/index.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */





// this is the backend that is compactible with all older React versions
function isMatchingRender(version) {
  return !Object(utils["j" /* hasAssignedBackend */])(version);
}

function initBackend(hook, agent, global) {
  if (hook == null) {
    // DevTools didn't get injected into this page (maybe b'c of the contentType).
    return function () {};
  }

  var subs = [hook.sub('renderer-attached', function (_ref) {
    var id = _ref.id,
        renderer = _ref.renderer,
        rendererInterface = _ref.rendererInterface;
    agent.setRendererInterface(id, rendererInterface); // Now that the Store and the renderer interface are connected,
    // it's time to flush the pending operation codes to the frontend.

    rendererInterface.flushInitialOperations();
  }), hook.sub('unsupported-renderer-version', function (id) {
    agent.onUnsupportedRenderer(id);
  }), hook.sub('fastRefreshScheduled', agent.onFastRefreshScheduled), hook.sub('operations', agent.onHookOperations), hook.sub('traceUpdates', agent.onTraceUpdates) // TODO Add additional subscriptions required for profiling mode
  ];

  var attachRenderer = function attachRenderer(id, renderer) {
    // skip if already attached
    if (renderer.attached) {
      return;
    } // only attach if the renderer is compatible with the current version of the backend


    if (!isMatchingRender(renderer.reconcilerVersion || renderer.version)) {
      return;
    }

    var rendererInterface = hook.rendererInterfaces.get(id); // Inject any not-yet-injected renderers (if we didn't reload-and-profile)

    if (rendererInterface == null) {
      if (typeof renderer.findFiberByHostInstance === 'function') {
        // react-reconciler v16+
        rendererInterface = Object(backend_renderer["a" /* attach */])(hook, id, renderer, global);
      } else if (renderer.ComponentTree) {
        // react-dom v15
        rendererInterface = attach(hook, id, renderer, global);
      } else {// Older react-dom or other unsupported renderer version
      }

      if (rendererInterface != null) {
        hook.rendererInterfaces.set(id, rendererInterface);
      }
    } // Notify the DevTools frontend about new renderers.
    // This includes any that were attached early (via __REACT_DEVTOOLS_ATTACH__).


    if (rendererInterface != null) {
      hook.emit('renderer-attached', {
        id: id,
        renderer: renderer,
        rendererInterface: rendererInterface
      });
    } else {
      hook.emit('unsupported-renderer-version', id);
    }

    renderer.attached = true;
  }; // Connect renderers that have already injected themselves.


  hook.renderers.forEach(function (renderer, id) {
    attachRenderer(id, renderer);
  }); // Connect any new renderers that injected themselves.

  subs.push(hook.sub('renderer', function (_ref2) {
    var id = _ref2.id,
        renderer = _ref2.renderer;
    attachRenderer(id, renderer);
  }));
  hook.emit('react-devtools', agent);
  hook.reactDevtoolsAgent = agent;

  var onAgentShutdown = function onAgentShutdown() {
    subs.forEach(function (fn) {
      return fn();
    });
    hook.rendererInterfaces.forEach(function (rendererInterface) {
      rendererInterface.cleanup();
    });
    hook.reactDevtoolsAgent = null;
  };

  agent.addListener('shutdown', onAgentShutdown);
  subs.push(function () {
    agent.removeListener('shutdown', onAgentShutdown);
  });
  return function () {
    subs.forEach(function (fn) {
      return fn();
    });
  };
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/NativeStyleEditor/resolveBoxStyle.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * This mirrors react-native/Libraries/Inspector/resolveBoxStyle.js (but without RTL support).
 *
 * Resolve a style property into it's component parts, e.g.
 *
 * resolveBoxStyle('margin', {margin: 5, marginBottom: 10})
 * -> {top: 5, left: 5, right: 5, bottom: 10}
 */
function resolveBoxStyle(prefix, style) {
  var hasParts = false;
  var result = {
    bottom: 0,
    left: 0,
    right: 0,
    top: 0
  };
  var styleForAll = style[prefix];

  if (styleForAll != null) {
    // eslint-disable-next-line no-for-of-loops/no-for-of-loops
    for (var _i = 0, _Object$keys = Object.keys(result); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      result[key] = styleForAll;
    }

    hasParts = true;
  }

  var styleForHorizontal = style[prefix + 'Horizontal'];

  if (styleForHorizontal != null) {
    result.left = styleForHorizontal;
    result.right = styleForHorizontal;
    hasParts = true;
  } else {
    var styleForLeft = style[prefix + 'Left'];

    if (styleForLeft != null) {
      result.left = styleForLeft;
      hasParts = true;
    }

    var styleForRight = style[prefix + 'Right'];

    if (styleForRight != null) {
      result.right = styleForRight;
      hasParts = true;
    }

    var styleForEnd = style[prefix + 'End'];

    if (styleForEnd != null) {
      // TODO RTL support
      result.right = styleForEnd;
      hasParts = true;
    }

    var styleForStart = style[prefix + 'Start'];

    if (styleForStart != null) {
      // TODO RTL support
      result.left = styleForStart;
      hasParts = true;
    }
  }

  var styleForVertical = style[prefix + 'Vertical'];

  if (styleForVertical != null) {
    result.bottom = styleForVertical;
    result.top = styleForVertical;
    hasParts = true;
  } else {
    var styleForBottom = style[prefix + 'Bottom'];

    if (styleForBottom != null) {
      result.bottom = styleForBottom;
      hasParts = true;
    }

    var styleForTop = style[prefix + 'Top'];

    if (styleForTop != null) {
      result.top = styleForTop;
      hasParts = true;
    }
  }

  return hasParts ? result : null;
}
// EXTERNAL MODULE: ../react-devtools-shared/src/isArray.js
var isArray = __webpack_require__(6);

// CONCATENATED MODULE: ../react-devtools-shared/src/backend/NativeStyleEditor/setupNativeStyleEditor.js
function setupNativeStyleEditor_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { setupNativeStyleEditor_typeof = function _typeof(obj) { return typeof obj; }; } else { setupNativeStyleEditor_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return setupNativeStyleEditor_typeof(obj); }

function setupNativeStyleEditor_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */



function setupNativeStyleEditor(bridge, agent, resolveNativeStyle, validAttributes) {
  bridge.addListener('NativeStyleEditor_measure', function (_ref) {
    var id = _ref.id,
        rendererID = _ref.rendererID;
    measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);
  });
  bridge.addListener('NativeStyleEditor_renameAttribute', function (_ref2) {
    var id = _ref2.id,
        rendererID = _ref2.rendererID,
        oldName = _ref2.oldName,
        newName = _ref2.newName,
        value = _ref2.value;
    renameStyle(agent, id, rendererID, oldName, newName, value);
    setTimeout(function () {
      return measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);
    });
  });
  bridge.addListener('NativeStyleEditor_setValue', function (_ref3) {
    var id = _ref3.id,
        rendererID = _ref3.rendererID,
        name = _ref3.name,
        value = _ref3.value;
    setStyle(agent, id, rendererID, name, value);
    setTimeout(function () {
      return measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);
    });
  });
  bridge.send('isNativeStyleEditorSupported', {
    isSupported: true,
    validAttributes: validAttributes
  });
}
var EMPTY_BOX_STYLE = {
  top: 0,
  left: 0,
  right: 0,
  bottom: 0
};
var componentIDToStyleOverrides = new Map();

function measureStyle(agent, bridge, resolveNativeStyle, id, rendererID) {
  var data = agent.getInstanceAndStyle({
    id: id,
    rendererID: rendererID
  });

  if (!data || !data.style) {
    bridge.send('NativeStyleEditor_styleAndLayout', {
      id: id,
      layout: null,
      style: null
    });
    return;
  }

  var instance = data.instance,
      style = data.style;
  var resolvedStyle = resolveNativeStyle(style); // If it's a host component we edited before, amend styles.

  var styleOverrides = componentIDToStyleOverrides.get(id);

  if (styleOverrides != null) {
    resolvedStyle = Object.assign({}, resolvedStyle, styleOverrides);
  }

  if (!instance || typeof instance.measure !== 'function') {
    bridge.send('NativeStyleEditor_styleAndLayout', {
      id: id,
      layout: null,
      style: resolvedStyle || null
    });
    return;
  }

  instance.measure(function (x, y, width, height, left, top) {
    // RN Android sometimes returns undefined here. Don't send measurements in this case.
    // https://github.com/jhen0409/react-native-debugger/issues/84#issuecomment-304611817
    if (typeof x !== 'number') {
      bridge.send('NativeStyleEditor_styleAndLayout', {
        id: id,
        layout: null,
        style: resolvedStyle || null
      });
      return;
    }

    var margin = resolvedStyle != null && resolveBoxStyle('margin', resolvedStyle) || EMPTY_BOX_STYLE;
    var padding = resolvedStyle != null && resolveBoxStyle('padding', resolvedStyle) || EMPTY_BOX_STYLE;
    bridge.send('NativeStyleEditor_styleAndLayout', {
      id: id,
      layout: {
        x: x,
        y: y,
        width: width,
        height: height,
        left: left,
        top: top,
        margin: margin,
        padding: padding
      },
      style: resolvedStyle || null
    });
  });
}

function shallowClone(object) {
  var cloned = {};

  for (var n in object) {
    cloned[n] = object[n];
  }

  return cloned;
}

function renameStyle(agent, id, rendererID, oldName, newName, value) {
  var _ref4;

  var data = agent.getInstanceAndStyle({
    id: id,
    rendererID: rendererID
  });

  if (!data || !data.style) {
    return;
  }

  var instance = data.instance,
      style = data.style;
  var newStyle = newName ? (_ref4 = {}, setupNativeStyleEditor_defineProperty(_ref4, oldName, undefined), setupNativeStyleEditor_defineProperty(_ref4, newName, value), _ref4) : setupNativeStyleEditor_defineProperty({}, oldName, undefined);
  var customStyle; // TODO It would be nice if the renderer interface abstracted this away somehow.

  if (instance !== null && typeof instance.setNativeProps === 'function') {
    // In the case of a host component, we need to use setNativeProps().
    // Remember to "correct" resolved styles when we read them next time.
    var styleOverrides = componentIDToStyleOverrides.get(id);

    if (!styleOverrides) {
      componentIDToStyleOverrides.set(id, newStyle);
    } else {
      Object.assign(styleOverrides, newStyle);
    } // TODO Fabric does not support setNativeProps; chat with Sebastian or Eli


    instance.setNativeProps({
      style: newStyle
    });
  } else if (Object(isArray["a" /* default */])(style)) {
    var lastIndex = style.length - 1;

    if (setupNativeStyleEditor_typeof(style[lastIndex]) === 'object' && !Object(isArray["a" /* default */])(style[lastIndex])) {
      customStyle = shallowClone(style[lastIndex]);
      delete customStyle[oldName];

      if (newName) {
        customStyle[newName] = value;
      } else {
        customStyle[oldName] = undefined;
      }

      agent.overrideValueAtPath({
        type: 'props',
        id: id,
        rendererID: rendererID,
        path: ['style', lastIndex],
        value: customStyle
      });
    } else {
      agent.overrideValueAtPath({
        type: 'props',
        id: id,
        rendererID: rendererID,
        path: ['style'],
        value: style.concat([newStyle])
      });
    }
  } else if (setupNativeStyleEditor_typeof(style) === 'object') {
    customStyle = shallowClone(style);
    delete customStyle[oldName];

    if (newName) {
      customStyle[newName] = value;
    } else {
      customStyle[oldName] = undefined;
    }

    agent.overrideValueAtPath({
      type: 'props',
      id: id,
      rendererID: rendererID,
      path: ['style'],
      value: customStyle
    });
  } else {
    agent.overrideValueAtPath({
      type: 'props',
      id: id,
      rendererID: rendererID,
      path: ['style'],
      value: [style, newStyle]
    });
  }

  agent.emit('hideNativeHighlight');
}

function setStyle(agent, id, rendererID, name, value) {
  var data = agent.getInstanceAndStyle({
    id: id,
    rendererID: rendererID
  });

  if (!data || !data.style) {
    return;
  }

  var instance = data.instance,
      style = data.style;

  var newStyle = setupNativeStyleEditor_defineProperty({}, name, value); // TODO It would be nice if the renderer interface abstracted this away somehow.


  if (instance !== null && typeof instance.setNativeProps === 'function') {
    // In the case of a host component, we need to use setNativeProps().
    // Remember to "correct" resolved styles when we read them next time.
    var styleOverrides = componentIDToStyleOverrides.get(id);

    if (!styleOverrides) {
      componentIDToStyleOverrides.set(id, newStyle);
    } else {
      Object.assign(styleOverrides, newStyle);
    } // TODO Fabric does not support setNativeProps; chat with Sebastian or Eli


    instance.setNativeProps({
      style: newStyle
    });
  } else if (Object(isArray["a" /* default */])(style)) {
    var lastLength = style.length - 1;

    if (setupNativeStyleEditor_typeof(style[lastLength]) === 'object' && !Object(isArray["a" /* default */])(style[lastLength])) {
      agent.overrideValueAtPath({
        type: 'props',
        id: id,
        rendererID: rendererID,
        path: ['style', lastLength, name],
        value: value
      });
    } else {
      agent.overrideValueAtPath({
        type: 'props',
        id: id,
        rendererID: rendererID,
        path: ['style'],
        value: style.concat([newStyle])
      });
    }
  } else {
    agent.overrideValueAtPath({
      type: 'props',
      id: id,
      rendererID: rendererID,
      path: ['style'],
      value: [style, newStyle]
    });
  }

  agent.emit('hideNativeHighlight');
}
// CONCATENATED MODULE: ./src/cachedSettings.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

 // Note: all keys should be optional in this type, because users can use newer
// versions of React DevTools with older versions of React Native, and the object
// provided by React Native may not include all of this type's fields.

function initializeUsingCachedSettings(devToolsSettingsManager) {
  initializeConsolePatchSettings(devToolsSettingsManager);
}

function initializeConsolePatchSettings(devToolsSettingsManager) {
  if (devToolsSettingsManager.getConsolePatchSettings == null) {
    return;
  }

  var consolePatchSettingsString = devToolsSettingsManager.getConsolePatchSettings();

  if (consolePatchSettingsString == null) {
    return;
  }

  var parsedConsolePatchSettings = parseConsolePatchSettings(consolePatchSettingsString);

  if (parsedConsolePatchSettings == null) {
    return;
  }

  Object(backend_console["g" /* writeConsolePatchSettingsToWindow */])(parsedConsolePatchSettings);
}

function parseConsolePatchSettings(consolePatchSettingsString) {
  var _castBool, _castBool2, _castBool3, _castBool4, _castBrowserTheme;

  var parsedValue = JSON.parse(consolePatchSettingsString !== null && consolePatchSettingsString !== void 0 ? consolePatchSettingsString : '{}');
  var appendComponentStack = parsedValue.appendComponentStack,
      breakOnConsoleErrors = parsedValue.breakOnConsoleErrors,
      showInlineWarningsAndErrors = parsedValue.showInlineWarningsAndErrors,
      hideConsoleLogsInStrictMode = parsedValue.hideConsoleLogsInStrictMode,
      browserTheme = parsedValue.browserTheme;
  return {
    appendComponentStack: (_castBool = Object(src_utils["a" /* castBool */])(appendComponentStack)) !== null && _castBool !== void 0 ? _castBool : true,
    breakOnConsoleErrors: (_castBool2 = Object(src_utils["a" /* castBool */])(breakOnConsoleErrors)) !== null && _castBool2 !== void 0 ? _castBool2 : false,
    showInlineWarningsAndErrors: (_castBool3 = Object(src_utils["a" /* castBool */])(showInlineWarningsAndErrors)) !== null && _castBool3 !== void 0 ? _castBool3 : true,
    hideConsoleLogsInStrictMode: (_castBool4 = Object(src_utils["a" /* castBool */])(hideConsoleLogsInStrictMode)) !== null && _castBool4 !== void 0 ? _castBool4 : false,
    browserTheme: (_castBrowserTheme = Object(src_utils["b" /* castBrowserTheme */])(browserTheme)) !== null && _castBrowserTheme !== void 0 ? _castBrowserTheme : 'dark'
  };
}

function cacheConsolePatchSettings(devToolsSettingsManager, value) {
  if (devToolsSettingsManager.setConsolePatchSettings == null) {
    return;
  }

  devToolsSettingsManager.setConsolePatchSettings(JSON.stringify(value));
}
// CONCATENATED MODULE: ./src/backend.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */









// Install a global variable to allow patching console early (during injection).
// This provides React Native developers with components stacks even if they don't run DevTools.
Object(backend_console["a" /* installConsoleFunctionsToWindow */])();
installHook(window);
var backend_hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
var savedComponentFilters = Object(src_utils["g" /* getDefaultComponentFilters */])();

function backend_debug(methodName) {
  if (constants["s" /* __DEBUG__ */]) {
    var _console;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    (_console = console).log.apply(_console, ["%c[core/backend] %c".concat(methodName), 'color: teal; font-weight: bold;', 'font-weight: bold;'].concat(args));
  }
}

function connectToDevTools(options) {
  if (backend_hook == null) {
    // DevTools didn't get injected into this page (maybe b'c of the contentType).
    return;
  }

  var _ref = options || {},
      _ref$host = _ref.host,
      host = _ref$host === void 0 ? 'localhost' : _ref$host,
      nativeStyleEditorValidAttributes = _ref.nativeStyleEditorValidAttributes,
      _ref$useHttps = _ref.useHttps,
      useHttps = _ref$useHttps === void 0 ? false : _ref$useHttps,
      _ref$port = _ref.port,
      port = _ref$port === void 0 ? 8097 : _ref$port,
      websocket = _ref.websocket,
      _ref$resolveRNStyle = _ref.resolveRNStyle,
      resolveRNStyle = _ref$resolveRNStyle === void 0 ? null : _ref$resolveRNStyle,
      _ref$retryConnectionD = _ref.retryConnectionDelay,
      retryConnectionDelay = _ref$retryConnectionD === void 0 ? 2000 : _ref$retryConnectionD,
      _ref$isAppActive = _ref.isAppActive,
      isAppActive = _ref$isAppActive === void 0 ? function () {
    return true;
  } : _ref$isAppActive,
      devToolsSettingsManager = _ref.devToolsSettingsManager;

  var protocol = useHttps ? 'wss' : 'ws';
  var retryTimeoutID = null;

  function scheduleRetry() {
    if (retryTimeoutID === null) {
      // Two seconds because RN had issues with quick retries.
      retryTimeoutID = setTimeout(function () {
        return connectToDevTools(options);
      }, retryConnectionDelay);
    }
  }

  if (devToolsSettingsManager != null) {
    try {
      initializeUsingCachedSettings(devToolsSettingsManager);
    } catch (e) {
      // If we call a method on devToolsSettingsManager that throws, or if
      // is invalid data read out, don't throw and don't interrupt initialization
      console.error(e);
    }
  }

  if (!isAppActive()) {
    // If the app is in background, maybe retry later.
    // Don't actually attempt to connect until we're in foreground.
    scheduleRetry();
    return;
  }

  var bridge = null;
  var messageListeners = [];
  var uri = protocol + '://' + host + ':' + port; // If existing websocket is passed, use it.
  // This is necessary to support our custom integrations.
  // See D6251744.

  var ws = websocket ? websocket : new window.WebSocket(uri);
  ws.onclose = handleClose;
  ws.onerror = handleFailed;
  ws.onmessage = handleMessage;

  ws.onopen = function () {
    bridge = new src_bridge({
      listen: function listen(fn) {
        messageListeners.push(fn);
        return function () {
          var index = messageListeners.indexOf(fn);

          if (index >= 0) {
            messageListeners.splice(index, 1);
          }
        };
      },
      send: function send(event, payload, transferable) {
        if (ws.readyState === ws.OPEN) {
          if (constants["s" /* __DEBUG__ */]) {
            backend_debug('wall.send()', event, payload);
          }

          ws.send(JSON.stringify({
            event: event,
            payload: payload
          }));
        } else {
          if (constants["s" /* __DEBUG__ */]) {
            backend_debug('wall.send()', 'Shutting down bridge because of closed WebSocket connection');
          }

          if (bridge !== null) {
            bridge.shutdown();
          }

          scheduleRetry();
        }
      }
    });
    bridge.addListener('updateComponentFilters', function (componentFilters) {
      // Save filter changes in memory, in case DevTools is reloaded.
      // In that case, the renderer will already be using the updated values.
      // We'll lose these in between backend reloads but that can't be helped.
      savedComponentFilters = componentFilters;
    });

    if (devToolsSettingsManager != null && bridge != null) {
      bridge.addListener('updateConsolePatchSettings', function (consolePatchSettings) {
        return cacheConsolePatchSettings(devToolsSettingsManager, consolePatchSettings);
      });
    } // The renderer interface doesn't read saved component filters directly,
    // because they are generally stored in localStorage within the context of the extension.
    // Because of this it relies on the extension to pass filters.
    // In the case of the standalone DevTools being used with a website,
    // saved filters are injected along with the backend script tag so we shouldn't override them here.
    // This injection strategy doesn't work for React Native though.
    // Ideally the backend would save the filters itself, but RN doesn't provide a sync storage solution.
    // So for now we just fall back to using the default filters...


    if (window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ == null) {
      // $FlowFixMe[incompatible-use] found when upgrading Flow
      bridge.send('overrideComponentFilters', savedComponentFilters);
    } // TODO (npm-packages) Warn if "isBackendStorageAPISupported"
    // $FlowFixMe[incompatible-call] found when upgrading Flow


    var agent = new agent_Agent(bridge);
    agent.addListener('shutdown', function () {
      // If we received 'shutdown' from `agent`, we assume the `bridge` is already shutting down,
      // and that caused the 'shutdown' event on the `agent`, so we don't need to call `bridge.shutdown()` here.
      backend_hook.emit('shutdown');
    });
    initBackend(backend_hook, agent, window); // Setup React Native style editor if the environment supports it.

    if (resolveRNStyle != null || backend_hook.resolveRNStyle != null) {
      setupNativeStyleEditor( // $FlowFixMe[incompatible-call] found when upgrading Flow
      bridge, agent, resolveRNStyle || backend_hook.resolveRNStyle, nativeStyleEditorValidAttributes || backend_hook.nativeStyleEditorValidAttributes || null);
    } else {
      // Otherwise listen to detect if the environment later supports it.
      // For example, Flipper does not eagerly inject these values.
      // Instead it relies on the React Native Inspector to lazily inject them.
      var lazyResolveRNStyle;
      var lazyNativeStyleEditorValidAttributes;

      var initAfterTick = function initAfterTick() {
        if (bridge !== null) {
          setupNativeStyleEditor(bridge, agent, lazyResolveRNStyle, lazyNativeStyleEditorValidAttributes);
        }
      };

      if (!backend_hook.hasOwnProperty('resolveRNStyle')) {
        Object.defineProperty(backend_hook, 'resolveRNStyle', {
          enumerable: false,
          get: function get() {
            return lazyResolveRNStyle;
          },
          set: function set(value) {
            lazyResolveRNStyle = value;
            initAfterTick();
          }
        });
      }

      if (!backend_hook.hasOwnProperty('nativeStyleEditorValidAttributes')) {
        Object.defineProperty(backend_hook, 'nativeStyleEditorValidAttributes', {
          enumerable: false,
          get: function get() {
            return lazyNativeStyleEditorValidAttributes;
          },
          set: function set(value) {
            lazyNativeStyleEditorValidAttributes = value;
            initAfterTick();
          }
        });
      }
    }
  };

  function handleClose() {
    if (constants["s" /* __DEBUG__ */]) {
      backend_debug('WebSocket.onclose');
    }

    if (bridge !== null) {
      bridge.emit('shutdown');
    }

    scheduleRetry();
  }

  function handleFailed() {
    if (constants["s" /* __DEBUG__ */]) {
      backend_debug('WebSocket.onerror');
    }

    scheduleRetry();
  }

  function handleMessage(event) {
    var data;

    try {
      if (typeof event.data === 'string') {
        data = JSON.parse(event.data);

        if (constants["s" /* __DEBUG__ */]) {
          backend_debug('WebSocket.onmessage', data);
        }
      } else {
        throw Error();
      }
    } catch (e) {
      console.error('[React DevTools] Failed to parse JSON: ' + event.data);
      return;
    }

    messageListeners.forEach(function (fn) {
      try {
        fn(data);
      } catch (error) {
        // jsc doesn't play so well with tracebacks that go into eval'd code,
        // so the stack trace here will stop at the `(0,eval)()` call. Getting the
        // message that caused the error is the best we can do for now.
        console.log('[React DevTools] Error calling listener', data);
        console.log('error:', error);
        throw error;
      }
    });
  }
}

/***/ })
/******/ ]);
});
//# sourceMappingURL=backend.js.map
      };
    };
  }
  }
}, {package:"react-devtools>react-devtools-core",file:"node_modules\\react-devtools-core\\dist\\backend.js",}],
["C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\react-devtools\\index.js", {"react-devtools-core/backend":"C:\\Users\\forth\\Desktop\\metamaskclone\\metamask-extension-develop\\node_modules\\react-devtools-core\\backend.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: C:%5CUsers%5Cforth%5CDesktop%5Cmetamaskclone%5Cmetamask-extension-develop%5Cnode_modules%5Creact-devtools%5Cindex.js
      return function (require, module, exports) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 */

const {connectToDevTools} = require('react-devtools-core/backend');

// Connect immediately with default options.
// If you need more control, use `react-devtools-core` directly instead of `react-devtools`.
connectToDevTools();

      };
    };
  }
  }
}, {package:"react-devtools",file:"node_modules\\react-devtools\\index.js",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvaXBWNEV4dGVuZGVkLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9pcFY2LmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9qc29uLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9qc29uVmFsdWUuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2xldHJlYy5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvbG9yZW0uanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L21hcFRvQ29uc3RhbnQuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L21heFNhZmVJbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9tYXhTYWZlTmF0LmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9tZW1vLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9taXhlZENhc2UuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L25hdC5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9vbmVvZi5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvb3B0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9yZWNvcmQuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L3NjaGVkdWxlci5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvc2h1ZmZsZWRTdWJhcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvc3BhcnNlQXJyYXkuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L3N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvc3RyaW5nMTZiaXRzLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9zdHJpbmdPZi5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvc3ViYXJyYXkuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L3R1cGxlLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS91aW50MTZBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvdWludDMyQXJyYXkuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L3VpbnQ4QXJyYXkuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L3VpbnQ4Q2xhbXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS91bmljb2RlLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS91bmljb2RlSnNvbi5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvdW5pY29kZUpzb25WYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvdW5pY29kZVN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvdW5pcXVlQXJyYXkuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L3V1aWQuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L3V1aWRWLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS93ZWJBdXRob3JpdHkuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L3dlYkZyYWdtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvd2ViUXVlcnlQYXJhbWV0ZXJzLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS93ZWJTZWdtZW50LmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS93ZWJVcmwuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQXJiaXRyYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL1ZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL21vZGVsL01vZGVsUnVubmVyLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL21vZGVsL1JlcGxheVBhdGguanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svbW9kZWwvY29tbWFuZHMvQ29tbWFuZFdyYXBwZXIuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svbW9kZWwvY29tbWFuZHMvQ29tbWFuZHNJdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9tb2RlbC9jb21tYW5kcy9TY2hlZHVsZWRDb21tYW5kLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3ByZWNvbmRpdGlvbi9QcmUuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcHJlY29uZGl0aW9uL1ByZWNvbmRpdGlvbkZhaWx1cmUuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcHJvcGVydHkvQXN5bmNQcm9wZXJ0eS5nZW5lcmljLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3Byb3BlcnR5L0FzeW5jUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcHJvcGVydHkvSVJhd1Byb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3Byb3BlcnR5L0lnbm9yZUVxdWFsVmFsdWVzUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcHJvcGVydHkvUHJvcGVydHkuZ2VuZXJpYy5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9wcm9wZXJ0eS9Qcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9wcm9wZXJ0eS9Ta2lwQWZ0ZXJQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9wcm9wZXJ0eS9UaW1lb3V0UHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcHJvcGVydHkvVW5iaWFzZWRQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9ydW5uZXIvRGVjb3JhdGVQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9ydW5uZXIvUnVubmVyLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3J1bm5lci9SdW5uZXJJdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9ydW5uZXIvU2FtcGxlci5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9ydW5uZXIvU291cmNlVmFsdWVzSXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcnVubmVyL1Rvc3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9ydW5uZXIvY29uZmlndXJhdGlvbi9HbG9iYWxQYXJhbWV0ZXJzLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3J1bm5lci9jb25maWd1cmF0aW9uL1F1YWxpZmllZFBhcmFtZXRlcnMuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcnVubmVyL2NvbmZpZ3VyYXRpb24vVmVyYm9zaXR5TGV2ZWwuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcnVubmVyL3JlcG9ydGVyL0V4ZWN1dGlvblN0YXR1cy5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9ydW5uZXIvcmVwb3J0ZXIvUnVuRXhlY3V0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3J1bm5lci91dGlscy9QYXRoV2Fsa2VyLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3J1bm5lci91dGlscy9SdW5EZXRhaWxzRm9ybWF0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3N5bWJvbHMuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvZmFzdC1jaGVjay1kZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2Zhc3QtY2hlY2suanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvcmFuZG9tL2dlbmVyYXRvci9SYW5kb20uanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvc3RyZWFtL0xhenlJdGVyYWJsZUl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL3N0cmVhbS9TdHJlYW0uanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvc3RyZWFtL1N0cmVhbUhlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvdXRpbHMvaGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi91dGlscy9zdHJpbmdpZnkuanMiLCJub2RlX21vZHVsZXMvZm9jdXMtbG9jay9kaXN0L2VzNS9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvZm9jdXMtbG9jay9kaXN0L2VzNS9mb2N1c0luc2lkZS5qcyIsIm5vZGVfbW9kdWxlcy9mb2N1cy1sb2NrL2Rpc3QvZXM1L2ZvY3VzSXNIaWRkZW4uanMiLCJub2RlX21vZHVsZXMvZm9jdXMtbG9jay9kaXN0L2VzNS9mb2N1c01lcmdlLmpzIiwibm9kZV9tb2R1bGVzL2ZvY3VzLWxvY2svZGlzdC9lczUvZm9jdXNhYmxlcy5qcyIsIm5vZGVfbW9kdWxlcy9mb2N1cy1sb2NrL2Rpc3QvZXM1L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ZvY3VzLWxvY2svZGlzdC9lczUvc2V0Rm9jdXMuanMiLCJub2RlX21vZHVsZXMvZm9jdXMtbG9jay9kaXN0L2VzNS9zaWJsaW5nLmpzIiwibm9kZV9tb2R1bGVzL2ZvY3VzLWxvY2svZGlzdC9lczUvc29sdmVyLmpzIiwibm9kZV9tb2R1bGVzL2ZvY3VzLWxvY2svZGlzdC9lczUvdGFiSG9vay5qcyIsIm5vZGVfbW9kdWxlcy9mb2N1cy1sb2NrL2Rpc3QvZXM1L3V0aWxzL0RPTXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2ZvY3VzLWxvY2svZGlzdC9lczUvdXRpbHMvYWxsLWFmZmVjdGVkLmpzIiwibm9kZV9tb2R1bGVzL2ZvY3VzLWxvY2svZGlzdC9lczUvdXRpbHMvYXJyYXkuanMiLCJub2RlX21vZHVsZXMvZm9jdXMtbG9jay9kaXN0L2VzNS91dGlscy9hdXRvLWZvY3VzLmpzIiwibm9kZV9tb2R1bGVzL2ZvY3VzLWxvY2svZGlzdC9lczUvdXRpbHMvY29ycmVjdEZvY3VzLmpzIiwibm9kZV9tb2R1bGVzL2ZvY3VzLWxvY2svZGlzdC9lczUvdXRpbHMvZmlyc3RGb2N1cy5qcyIsIm5vZGVfbW9kdWxlcy9mb2N1cy1sb2NrL2Rpc3QvZXM1L3V0aWxzL2dldEFjdGl2ZUVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvZm9jdXMtbG9jay9kaXN0L2VzNS91dGlscy9pcy5qcyIsIm5vZGVfbW9kdWxlcy9mb2N1cy1sb2NrL2Rpc3QvZXM1L3V0aWxzL3BhcmVudGluZy5qcyIsIm5vZGVfbW9kdWxlcy9mb2N1cy1sb2NrL2Rpc3QvZXM1L3V0aWxzL3NhZmUuanMiLCJub2RlX21vZHVsZXMvZm9jdXMtbG9jay9kaXN0L2VzNS91dGlscy90YWJPcmRlci5qcyIsIm5vZGVfbW9kdWxlcy9mb2N1cy1sb2NrL2Rpc3QvZXM1L3V0aWxzL3RhYlV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2ZvY3VzLWxvY2svZGlzdC9lczUvdXRpbHMvdGFiYmFibGVzLmpzIiwibm9kZV9tb2R1bGVzL2ZvcmVhY2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbXBsZW1lbnRhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Z1bmN0aW9ucy1oYXZlLW5hbWVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Z1c2UuanMvZGlzdC9mdXNlLmpzIiwibm9kZV9tb2R1bGVzL2dldC1pbnRyaW5zaWMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2V0LXBhcmFtcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2lkZW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvaW52ZXJ0LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvbG9va0F0LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvbXVsdGlwbHkuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9wZXJzcGVjdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3JvdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL3RyYW5zZm9ybU1hdDQuanMiLCJub2RlX21vZHVsZXMvZ3VkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hhcy1wcm9wZXJ0eS1kZXNjcmlwdG9ycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtcHJvdG8vaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMiLCJub2RlX21vZHVsZXMvaGFzLXRvc3RyaW5ndGFnL3NoYW1zLmpzIiwibm9kZV9tb2R1bGVzL2hhcy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGVhZGVyLWNhc2UvaGVhZGVyLWNhc2UuanMiLCJub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvZGlzdC9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy5janMuanMiLCJub2RlX21vZHVsZXMvaHlwaGVuYXRlLXN0eWxlLW5hbWUvaW5kZXguY2pzLmpzIiwibm9kZV9tb2R1bGVzL2lzLWFyZ3VtZW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1kYXRlLW9iamVjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1kb20vaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtaW4tYnJvd3Nlci9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWxvd2VyLWNhc2UvaXMtbG93ZXItY2FzZS5qcyIsIm5vZGVfbW9kdWxlcy9pcy1vYmplY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtcmVnZXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtdXBwZXItY2FzZS9pcy11cHBlci1jYXNlLmpzIiwibm9kZV9tb2R1bGVzL2lzLXdpbmRvdy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc2FuL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzYW4vbGliL2N5Y2xlLmpzIiwibm9kZV9tb2R1bGVzL2pzYW4vbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzYW4vbGliL3BhdGgtZ2V0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzYW4vbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2pzb24tcG9pbnRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc3MtcGx1Z2luLWNhbWVsLWNhc2UvZGlzdC9qc3MtcGx1Z2luLWNhbWVsLWNhc2UuY2pzLmpzIiwibm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tZGVmYXVsdC11bml0L2Rpc3QvanNzLXBsdWdpbi1kZWZhdWx0LXVuaXQuY2pzLmpzIiwibm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tZ2xvYmFsL2Rpc3QvanNzLXBsdWdpbi1nbG9iYWwuY2pzLmpzIiwibm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tbmVzdGVkL2Rpc3QvanNzLXBsdWdpbi1uZXN0ZWQuY2pzLmpzIiwibm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tcHJvcHMtc29ydC9kaXN0L2pzcy1wbHVnaW4tcHJvcHMtc29ydC5janMuanMiLCJub2RlX21vZHVsZXMvanNzLXBsdWdpbi1ydWxlLXZhbHVlLWZ1bmN0aW9uL2Rpc3QvanNzLXBsdWdpbi1ydWxlLXZhbHVlLWZ1bmN0aW9uLmNqcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3MtcGx1Z2luLXZlbmRvci1wcmVmaXhlci9kaXN0L2pzcy1wbHVnaW4tdmVuZG9yLXByZWZpeGVyLmNqcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvZGlzdC9qc3MuY2pzLmpzIiwibm9kZV9tb2R1bGVzL2xpbmtlZC1saXN0L19zb3VyY2UvbGlua2VkLWxpc3QuanMiLCJub2RlX21vZHVsZXMvbGlua2VkLWxpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9jYWxlLWN1cnJlbmN5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvY2FsZS1jdXJyZW5jeS9tYXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcHBseS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5QWdncmVnYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5SW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUluY2x1ZGVzV2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBZ2dyZWdhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZURpZmZlcmVuY2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGaW5kSW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmxhdHRlbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJbmRleE9mLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmFOLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlc3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU3VtLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuaXEuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVBZ2dyZWdhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUVhY2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc0ZsYXR0ZW5hYmxlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlclJlc3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3Nob3J0T3V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaWN0SW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvY29uc3RhbnQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2RpZmZlcmVuY2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2VzY2FwZVJlZ0V4cC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQm9vbGVhbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNFcXVhbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNOdW1iZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzUGxhaW5PYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9ub29wLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9wYXJ0aXRpb24uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3N1bS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdW5pb24uanMiLCJub2RlX21vZHVsZXMvbG93ZXItY2FzZS1maXJzdC9sb3dlci1jYXNlLWZpcnN0LmpzIiwibm9kZV9tb2R1bGVzL2xvd2VyLWNhc2UvbG93ZXItY2FzZS5qcyIsIm5vZGVfbW9kdWxlcy9tZXJzZW5uZS10d2lzdGVyL3NyYy9tZXJzZW5uZS10d2lzdGVyLmpzIiwibm9kZV9tb2R1bGVzL21pbmktY3JlYXRlLXJlYWN0LWNvbnRleHQvZGlzdC9janMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXVsdGloYXNoZXMvbm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWhhc2hlcy9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy9iYXNlMTYuanMiLCJub2RlX21vZHVsZXMvbXVsdGloYXNoZXMvbm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvYmFzZTMyLmpzIiwibm9kZV9tb2R1bGVzL211bHRpaGFzaGVzL25vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2Jhc2U2NC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWhhc2hlcy9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvbXVsdGloYXNoZXMvbm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXVsdGloYXNoZXMvc3JjL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWhhc2hlcy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbmFub2lkL25vbi1zZWN1cmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbm8tY2FzZS9uby1jYXNlLmpzIiwibm9kZV9tb2R1bGVzL25vLWNhc2UvdmVuZG9yL2NhbWVsLWNhc2UtcmVnZXhwLmpzIiwibm9kZV9tb2R1bGVzL25vLWNhc2UvdmVuZG9yL2NhbWVsLWNhc2UtdXBwZXItcmVnZXhwLmpzIiwibm9kZV9tb2R1bGVzL25vLWNhc2UvdmVuZG9yL25vbi13b3JkLXJlZ2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWludGVydmFsLXRyZWUvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL25vZmlsdGVyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QtaXMvaW1wbGVtZW50YXRpb24uanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWlzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC1pcy9wb2x5ZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QtaXMvc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pbXBsZW1lbnRhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pc0FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9vcy1icm93c2VyaWZ5L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcGFyYW0tY2FzZS9wYXJhbS1jYXNlLmpzIiwibm9kZV9tb2R1bGVzL3Bhc2NhbC1jYXNlL3Bhc2NhbC1jYXNlLmpzIiwibm9kZV9tb2R1bGVzL3BhdGgtY2FzZS9wYXRoLWNhc2UuanMiLCJub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcG9wcGVyLmpzL2Rpc3QvdW1kL3BvcHBlci5qcyIsIm5vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwibm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzIiwibm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9oYXMuanMiLCJub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9kaXN0cmlidXRpb24vVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvZGlzdHJpYnV0aW9uL1VuaWZvcm1CaWdJbnREaXN0cmlidXRpb24uanMiLCJub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9kaXN0cmlidXRpb24vVW5pZm9ybUludERpc3RyaWJ1dGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2Rpc3RyaWJ1dGlvbi9VbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24uanMiLCJub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9kaXN0cmlidXRpb24vVW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2Rpc3RyaWJ1dGlvbi9VbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvZGlzdHJpYnV0aW9uL2ludGVybmFscy9BcnJheUludC5qcyIsIm5vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2Rpc3RyaWJ1dGlvbi9pbnRlcm5hbHMvVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uSW50ZXJuYWwuanMiLCJub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9kaXN0cmlidXRpb24vaW50ZXJuYWxzL1Vuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbC5qcyIsIm5vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2dlbmVyYXRvci9MaW5lYXJDb25ncnVlbnRpYWwuanMiLCJub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9nZW5lcmF0b3IvTWVyc2VubmVUd2lzdGVyLmpzIiwibm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvZ2VuZXJhdG9yL1JhbmRvbUdlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2dlbmVyYXRvci9Yb3JTaGlmdC5qcyIsIm5vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2dlbmVyYXRvci9Yb3JvU2hpcm8uanMiLCJub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9wdXJlLXJhbmQtZGVmYXVsdC5qcyIsIm5vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL3B1cmUtcmFuZC5qcyIsIm5vZGVfbW9kdWxlcy9xci5qcy9saWIvOEJpdEJ5dGUuanMiLCJub2RlX21vZHVsZXMvcXIuanMvbGliL0JpdEJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9xci5qcy9saWIvRXJyb3JDb3JyZWN0TGV2ZWwuanMiLCJub2RlX21vZHVsZXMvcXIuanMvbGliL1BvbHlub21pYWwuanMiLCJub2RlX21vZHVsZXMvcXIuanMvbGliL1FSQ29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xci5qcy9saWIvUlNCbG9jay5qcyIsIm5vZGVfbW9kdWxlcy9xci5qcy9saWIvbWF0aC5qcyIsIm5vZGVfbW9kdWxlcy9xci5qcy9saWIvbW9kZS5qcyIsIm5vZGVfbW9kdWxlcy9xci5qcy9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9xcmNvZGUtZ2VuZXJhdG9yL3FyY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xcmNvZGUucmVhY3QvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWNsaWVudHNpZGUtZWZmZWN0L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kZXZ0b29scy1jb3JlL2JhY2tlbmQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZGV2dG9vbHMtY29yZS9kaXN0L2JhY2tlbmQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZGV2dG9vbHMvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDak5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ2xRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1pBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbFlBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFnQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4Q0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0RBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNEQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ25zQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN0MUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMWFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcGpGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbG1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdGJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5ZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwRkE7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3aWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoidWktMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pcFY0RXh0ZW5kZWQgPSB2b2lkIDA7XG5jb25zdCBvbmVvZl8xID0gcmVxdWlyZShcIi4vb25lb2ZcIik7XG5jb25zdCB0dXBsZV8xID0gcmVxdWlyZShcIi4vdHVwbGVcIik7XG5jb25zdCBTdHJpbmdpZmllZE5hdEFyYml0cmFyeUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvYnVpbGRlcnMvU3RyaW5naWZpZWROYXRBcmJpdHJhcnlCdWlsZGVyXCIpO1xuZnVuY3Rpb24gZG90Sm9pbmVyTWFwcGVyKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5qb2luKCcuJyk7XG59XG5mdW5jdGlvbiBkb3RKb2luZXJVbm1hcHBlcih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5zcGxpdCgnLicpO1xufVxuZnVuY3Rpb24gaXBWNEV4dGVuZGVkKCkge1xuICAgIHJldHVybiAoMCwgb25lb2ZfMS5vbmVvZikoKDAsIHR1cGxlXzEudHVwbGUpKCgwLCBTdHJpbmdpZmllZE5hdEFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5KSgyNTUpLCAoMCwgU3RyaW5naWZpZWROYXRBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRTdHJpbmdpZmllZE5hdEFyYml0cmFyeSkoMjU1KSwgKDAsIFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkU3RyaW5naWZpZWROYXRBcmJpdHJhcnkpKDI1NSksICgwLCBTdHJpbmdpZmllZE5hdEFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5KSgyNTUpKS5tYXAoZG90Sm9pbmVyTWFwcGVyLCBkb3RKb2luZXJVbm1hcHBlciksICgwLCB0dXBsZV8xLnR1cGxlKSgoMCwgU3RyaW5naWZpZWROYXRBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRTdHJpbmdpZmllZE5hdEFyYml0cmFyeSkoMjU1KSwgKDAsIFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkU3RyaW5naWZpZWROYXRBcmJpdHJhcnkpKDI1NSksICgwLCBTdHJpbmdpZmllZE5hdEFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5KSg2NTUzNSkpLm1hcChkb3RKb2luZXJNYXBwZXIsIGRvdEpvaW5lclVubWFwcGVyKSwgKDAsIHR1cGxlXzEudHVwbGUpKCgwLCBTdHJpbmdpZmllZE5hdEFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5KSgyNTUpLCAoMCwgU3RyaW5naWZpZWROYXRBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRTdHJpbmdpZmllZE5hdEFyYml0cmFyeSkoMTY3NzcyMTUpKS5tYXAoZG90Sm9pbmVyTWFwcGVyLCBkb3RKb2luZXJVbm1hcHBlciksICgwLCBTdHJpbmdpZmllZE5hdEFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5KSg0Mjk0OTY3Mjk1KSk7XG59XG5leHBvcnRzLmlwVjRFeHRlbmRlZCA9IGlwVjRFeHRlbmRlZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pcFY2ID0gdm9pZCAwO1xuY29uc3QgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FycmF5XCIpO1xuY29uc3Qgb25lb2ZfMSA9IHJlcXVpcmUoXCIuL29uZW9mXCIpO1xuY29uc3QgaGV4YVN0cmluZ18xID0gcmVxdWlyZShcIi4vaGV4YVN0cmluZ1wiKTtcbmNvbnN0IHR1cGxlXzEgPSByZXF1aXJlKFwiLi90dXBsZVwiKTtcbmNvbnN0IGlwVjRfMSA9IHJlcXVpcmUoXCIuL2lwVjRcIik7XG5jb25zdCBFbnRpdGllc1RvSVB2Nl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9tYXBwZXJzL0VudGl0aWVzVG9JUHY2XCIpO1xuZnVuY3Rpb24gaDE2c1RvbDMyTWFwcGVyKFthLCBiXSkge1xuICAgIHJldHVybiBgJHthfToke2J9YDtcbn1cbmZ1bmN0aW9uIGgxNnNUb2wzMlVubWFwcGVyKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJyk7XG4gICAgaWYgKCF2YWx1ZS5pbmNsdWRlcygnOicpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUnKTtcbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoJzonLCAyKTtcbn1cbmZ1bmN0aW9uIGlwVjYoKSB7XG4gICAgY29uc3QgaDE2QXJiID0gKDAsIGhleGFTdHJpbmdfMS5oZXhhU3RyaW5nKSh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA0LCBzaXplOiAnbWF4JyB9KTtcbiAgICBjb25zdCBsczMyQXJiID0gKDAsIG9uZW9mXzEub25lb2YpKCgwLCB0dXBsZV8xLnR1cGxlKShoMTZBcmIsIGgxNkFyYikubWFwKGgxNnNUb2wzMk1hcHBlciwgaDE2c1RvbDMyVW5tYXBwZXIpLCAoMCwgaXBWNF8xLmlwVjQpKCkpO1xuICAgIHJldHVybiAoMCwgb25lb2ZfMS5vbmVvZikoKDAsIHR1cGxlXzEudHVwbGUpKCgwLCBhcnJheV8xLmFycmF5KShoMTZBcmIsIHsgbWluTGVuZ3RoOiA2LCBtYXhMZW5ndGg6IDYsIHNpemU6ICdtYXgnIH0pLCBsczMyQXJiKS5tYXAoRW50aXRpZXNUb0lQdjZfMS5mdWxseVNwZWNpZmllZE1hcHBlciwgRW50aXRpZXNUb0lQdjZfMS5mdWxseVNwZWNpZmllZFVubWFwcGVyKSwgKDAsIHR1cGxlXzEudHVwbGUpKCgwLCBhcnJheV8xLmFycmF5KShoMTZBcmIsIHsgbWluTGVuZ3RoOiA1LCBtYXhMZW5ndGg6IDUsIHNpemU6ICdtYXgnIH0pLCBsczMyQXJiKS5tYXAoRW50aXRpZXNUb0lQdjZfMS5vbmx5VHJhaWxpbmdNYXBwZXIsIEVudGl0aWVzVG9JUHY2XzEub25seVRyYWlsaW5nVW5tYXBwZXIpLCAoMCwgdHVwbGVfMS50dXBsZSkoKDAsIGFycmF5XzEuYXJyYXkpKGgxNkFyYiwgeyBtaW5MZW5ndGg6IDAsIG1heExlbmd0aDogMSwgc2l6ZTogJ21heCcgfSksICgwLCBhcnJheV8xLmFycmF5KShoMTZBcmIsIHsgbWluTGVuZ3RoOiA0LCBtYXhMZW5ndGg6IDQsIHNpemU6ICdtYXgnIH0pLCBsczMyQXJiKS5tYXAoRW50aXRpZXNUb0lQdjZfMS5tdWx0aVRyYWlsaW5nTWFwcGVyLCBFbnRpdGllc1RvSVB2Nl8xLm11bHRpVHJhaWxpbmdVbm1hcHBlciksICgwLCB0dXBsZV8xLnR1cGxlKSgoMCwgYXJyYXlfMS5hcnJheSkoaDE2QXJiLCB7IG1pbkxlbmd0aDogMCwgbWF4TGVuZ3RoOiAyLCBzaXplOiAnbWF4JyB9KSwgKDAsIGFycmF5XzEuYXJyYXkpKGgxNkFyYiwgeyBtaW5MZW5ndGg6IDMsIG1heExlbmd0aDogMywgc2l6ZTogJ21heCcgfSksIGxzMzJBcmIpLm1hcChFbnRpdGllc1RvSVB2Nl8xLm11bHRpVHJhaWxpbmdNYXBwZXIsIEVudGl0aWVzVG9JUHY2XzEubXVsdGlUcmFpbGluZ1VubWFwcGVyKSwgKDAsIHR1cGxlXzEudHVwbGUpKCgwLCBhcnJheV8xLmFycmF5KShoMTZBcmIsIHsgbWluTGVuZ3RoOiAwLCBtYXhMZW5ndGg6IDMsIHNpemU6ICdtYXgnIH0pLCAoMCwgYXJyYXlfMS5hcnJheSkoaDE2QXJiLCB7IG1pbkxlbmd0aDogMiwgbWF4TGVuZ3RoOiAyLCBzaXplOiAnbWF4JyB9KSwgbHMzMkFyYikubWFwKEVudGl0aWVzVG9JUHY2XzEubXVsdGlUcmFpbGluZ01hcHBlciwgRW50aXRpZXNUb0lQdjZfMS5tdWx0aVRyYWlsaW5nVW5tYXBwZXIpLCAoMCwgdHVwbGVfMS50dXBsZSkoKDAsIGFycmF5XzEuYXJyYXkpKGgxNkFyYiwgeyBtaW5MZW5ndGg6IDAsIG1heExlbmd0aDogNCwgc2l6ZTogJ21heCcgfSksIGgxNkFyYiwgbHMzMkFyYikubWFwKEVudGl0aWVzVG9JUHY2XzEubXVsdGlUcmFpbGluZ01hcHBlck9uZSwgRW50aXRpZXNUb0lQdjZfMS5tdWx0aVRyYWlsaW5nVW5tYXBwZXJPbmUpLCAoMCwgdHVwbGVfMS50dXBsZSkoKDAsIGFycmF5XzEuYXJyYXkpKGgxNkFyYiwgeyBtaW5MZW5ndGg6IDAsIG1heExlbmd0aDogNSwgc2l6ZTogJ21heCcgfSksIGxzMzJBcmIpLm1hcChFbnRpdGllc1RvSVB2Nl8xLnNpbmdsZVRyYWlsaW5nTWFwcGVyLCBFbnRpdGllc1RvSVB2Nl8xLnNpbmdsZVRyYWlsaW5nVW5tYXBwZXIpLCAoMCwgdHVwbGVfMS50dXBsZSkoKDAsIGFycmF5XzEuYXJyYXkpKGgxNkFyYiwgeyBtaW5MZW5ndGg6IDAsIG1heExlbmd0aDogNiwgc2l6ZTogJ21heCcgfSksIGgxNkFyYikubWFwKEVudGl0aWVzVG9JUHY2XzEuc2luZ2xlVHJhaWxpbmdNYXBwZXIsIEVudGl0aWVzVG9JUHY2XzEuc2luZ2xlVHJhaWxpbmdVbm1hcHBlciksICgwLCB0dXBsZV8xLnR1cGxlKSgoMCwgYXJyYXlfMS5hcnJheSkoaDE2QXJiLCB7IG1pbkxlbmd0aDogMCwgbWF4TGVuZ3RoOiA3LCBzaXplOiAnbWF4JyB9KSkubWFwKEVudGl0aWVzVG9JUHY2XzEubm9UcmFpbGluZ01hcHBlciwgRW50aXRpZXNUb0lQdjZfMS5ub1RyYWlsaW5nVW5tYXBwZXIpKTtcbn1cbmV4cG9ydHMuaXBWNiA9IGlwVjY7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuanNvbiA9IHZvaWQgMDtcbmNvbnN0IGpzb25WYWx1ZV8xID0gcmVxdWlyZShcIi4vanNvblZhbHVlXCIpO1xuZnVuY3Rpb24ganNvbihjb25zdHJhaW50cyA9IHt9KSB7XG4gICAgY29uc3QgYXJiID0gKDAsIGpzb25WYWx1ZV8xLmpzb25WYWx1ZSkoY29uc3RyYWludHMpO1xuICAgIHJldHVybiBhcmIubWFwKEpTT04uc3RyaW5naWZ5KTtcbn1cbmV4cG9ydHMuanNvbiA9IGpzb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuanNvblZhbHVlID0gdm9pZCAwO1xuY29uc3Qgc3RyaW5nXzEgPSByZXF1aXJlKFwiLi9zdHJpbmdcIik7XG5jb25zdCBKc29uQ29uc3RyYWludHNCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2hlbHBlcnMvSnNvbkNvbnN0cmFpbnRzQnVpbGRlclwiKTtcbmNvbnN0IGFueXRoaW5nXzEgPSByZXF1aXJlKFwiLi9hbnl0aGluZ1wiKTtcbmZ1bmN0aW9uIGpzb25WYWx1ZShjb25zdHJhaW50cyA9IHt9KSB7XG4gICAgcmV0dXJuICgwLCBhbnl0aGluZ18xLmFueXRoaW5nKSgoMCwgSnNvbkNvbnN0cmFpbnRzQnVpbGRlcl8xLmpzb25Db25zdHJhaW50c0J1aWxkZXIpKCgwLCBzdHJpbmdfMS5zdHJpbmcpKCksIGNvbnN0cmFpbnRzKSk7XG59XG5leHBvcnRzLmpzb25WYWx1ZSA9IGpzb25WYWx1ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sZXRyZWMgPSB2b2lkIDA7XG5jb25zdCBMYXp5QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL0xhenlBcmJpdHJhcnlcIik7XG5mdW5jdGlvbiBsZXRyZWMoYnVpbGRlcikge1xuICAgIGNvbnN0IGxhenlBcmJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCB0aWUgPSAoa2V5KSA9PiB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxhenlBcmJzLCBrZXkpKSB7XG4gICAgICAgICAgICBsYXp5QXJic1trZXldID0gbmV3IExhenlBcmJpdHJhcnlfMS5MYXp5QXJiaXRyYXJ5KFN0cmluZyhrZXkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGF6eUFyYnNba2V5XTtcbiAgICB9O1xuICAgIGNvbnN0IHN0cmljdEFyYnMgPSBidWlsZGVyKHRpZSk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc3RyaWN0QXJicykge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdHJpY3RBcmJzLCBrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXp5QXRLZXkgPSBsYXp5QXJic1trZXldO1xuICAgICAgICBjb25zdCBsYXp5QXJiID0gbGF6eUF0S2V5ICE9PSB1bmRlZmluZWQgPyBsYXp5QXRLZXkgOiBuZXcgTGF6eUFyYml0cmFyeV8xLkxhenlBcmJpdHJhcnkoa2V5KTtcbiAgICAgICAgbGF6eUFyYi51bmRlcmx5aW5nID0gc3RyaWN0QXJic1trZXldO1xuICAgICAgICBsYXp5QXJic1trZXldID0gbGF6eUFyYjtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmljdEFyYnM7XG59XG5leHBvcnRzLmxldHJlYyA9IGxldHJlYztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sb3JlbSA9IHZvaWQgMDtcbmNvbnN0IGFycmF5XzEgPSByZXF1aXJlKFwiLi9hcnJheVwiKTtcbmNvbnN0IGNvbnN0YW50XzEgPSByZXF1aXJlKFwiLi9jb25zdGFudFwiKTtcbmNvbnN0IG9uZW9mXzEgPSByZXF1aXJlKFwiLi9vbmVvZlwiKTtcbmNvbnN0IFdvcmRzVG9Mb3JlbV8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9tYXBwZXJzL1dvcmRzVG9Mb3JlbVwiKTtcbmNvbnN0IGggPSAodiwgdykgPT4ge1xuICAgIHJldHVybiB7IGFyYml0cmFyeTogKDAsIGNvbnN0YW50XzEuY29uc3RhbnQpKHYpLCB3ZWlnaHQ6IHcgfTtcbn07XG5mdW5jdGlvbiBsb3JlbVdvcmQoKSB7XG4gICAgcmV0dXJuICgwLCBvbmVvZl8xLm9uZW9mKShoKCdub24nLCA2KSwgaCgnYWRpcGlzY2luZycsIDUpLCBoKCdsaWd1bGEnLCA1KSwgaCgnZW5pbScsIDUpLCBoKCdwZWxsZW50ZXNxdWUnLCA1KSwgaCgnaW4nLCA1KSwgaCgnYXVndWUnLCA1KSwgaCgnZXQnLCA1KSwgaCgnbnVsbGEnLCA1KSwgaCgnbG9yZW0nLCA0KSwgaCgnc2l0JywgNCksIGgoJ3NlZCcsIDQpLCBoKCdkaWFtJywgNCksIGgoJ2Zlcm1lbnR1bScsIDQpLCBoKCd1dCcsIDQpLCBoKCdldScsIDQpLCBoKCdhbGlxdWFtJywgNCksIGgoJ21hdXJpcycsIDQpLCBoKCd2aXRhZScsIDQpLCBoKCdmZWxpcycsIDQpLCBoKCdpcHN1bScsIDMpLCBoKCdkb2xvcicsIDMpLCBoKCdhbWV0LCcsIDMpLCBoKCdlbGl0JywgMyksIGgoJ2V1aXNtb2QnLCAzKSwgaCgnbWknLCAzKSwgaCgnb3JjaScsIDMpLCBoKCdlcmF0JywgMyksIGgoJ3ByYWVzZW50JywgMyksIGgoJ2VnZXN0YXMnLCAzKSwgaCgnbGVvJywgMyksIGgoJ3ZlbCcsIDMpLCBoKCdzYXBpZW4nLCAzKSwgaCgnaW50ZWdlcicsIDMpLCBoKCdjdXJhYml0dXInLCAzKSwgaCgnY29udmFsbGlzJywgMyksIGgoJ3B1cnVzJywgMyksIGgoJ3Jpc3VzJywgMiksIGgoJ3N1c3BlbmRpc3NlJywgMiksIGgoJ2xlY3R1cycsIDIpLCBoKCduZWMsJywgMiksIGgoJ3VsdHJpY2llcycsIDIpLCBoKCdzZWQsJywgMiksIGgoJ2NyYXMnLCAyKSwgaCgnZWxlbWVudHVtJywgMiksIGgoJ3VsdHJpY2VzJywgMiksIGgoJ21hZWNlbmFzJywgMiksIGgoJ21hc3NhLCcsIDIpLCBoKCd2YXJpdXMnLCAyKSwgaCgnYSwnLCAyKSwgaCgnc2VtcGVyJywgMiksIGgoJ3Byb2luJywgMiksIGgoJ25lYycsIDIpLCBoKCduaXNsJywgMiksIGgoJ2FtZXQnLCAyKSwgaCgnZHVpcycsIDIpLCBoKCdjb25ndWUnLCAyKSwgaCgnbGliZXJvJywgMiksIGgoJ3Zlc3RpYnVsdW0nLCAyKSwgaCgncGVkZScsIDIpLCBoKCdibGFuZGl0JywgMiksIGgoJ3NvZGFsZXMnLCAyKSwgaCgnYW50ZScsIDIpLCBoKCduaWJoJywgMiksIGgoJ2FjJywgMiksIGgoJ2FlbmVhbicsIDIpLCBoKCdtYXNzYScsIDIpLCBoKCdzdXNjaXBpdCcsIDIpLCBoKCdzb2xsaWNpdHVkaW4nLCAyKSwgaCgnZnVzY2UnLCAyKSwgaCgndGVtcHVzJywgMiksIGgoJ2FsaXF1YW0sJywgMiksIGgoJ251bmMnLCAyKSwgaCgndWxsYW1jb3JwZXInLCAyKSwgaCgncmhvbmN1cycsIDIpLCBoKCdtZXR1cycsIDIpLCBoKCdmYXVjaWJ1cywnLCAyKSwgaCgnanVzdG8nLCAyKSwgaCgnbWFnbmEnLCAyKSwgaCgnYXQnLCAyKSwgaCgndGluY2lkdW50JywgMiksIGgoJ2NvbnNlY3RldHVyJywgMSksIGgoJ3RvcnRvciwnLCAxKSwgaCgnZGlnbmlzc2ltJywgMSksIGgoJ2Nvbmd1ZSwnLCAxKSwgaCgnbm9uLCcsIDEpLCBoKCdwb3J0dGl0b3IsJywgMSksIGgoJ25vbnVtbXknLCAxKSwgaCgnbW9sZXN0aWUsJywgMSksIGgoJ2VzdCcsIDEpLCBoKCdlbGVpZmVuZCcsIDEpLCBoKCdtaSwnLCAxKSwgaCgnYXJjdScsIDEpLCBoKCdzY2VsZXJpc3F1ZScsIDEpLCBoKCd2aXRhZSwnLCAxKSwgaCgnY29uc2VxdWF0JywgMSksIGgoJ2luLCcsIDEpLCBoKCdwcmV0aXVtJywgMSksIGgoJ3ZvbHV0cGF0JywgMSksIGgoJ3BoYXJldHJhJywgMSksIGgoJ3RlbXBvcicsIDEpLCBoKCdiaWJlbmR1bScsIDEpLCBoKCdvZGlvJywgMSksIGgoJ2R1aScsIDEpLCBoKCdwcmltaXMnLCAxKSwgaCgnZmF1Y2lidXMnLCAxKSwgaCgnbHVjdHVzJywgMSksIGgoJ3Bvc3VlcmUnLCAxKSwgaCgnY3ViaWxpYScsIDEpLCBoKCdjdXJhZSwnLCAxKSwgaCgnaGVuZHJlcml0JywgMSksIGgoJ3ZlbGl0JywgMSksIGgoJ21hdXJpcywnLCAxKSwgaCgnZ3JhdmlkYScsIDEpLCBoKCdvcm5hcmUnLCAxKSwgaCgndXQsJywgMSksIGgoJ3B1bHZpbmFyJywgMSksIGgoJ3Zhcml1cywnLCAxKSwgaCgndHVycGlzJywgMSksIGgoJ25pYmgsJywgMSksIGgoJ2Vyb3MnLCAxKSwgaCgnaWQnLCAxKSwgaCgnYWxpcXVldCcsIDEpLCBoKCdxdWlzJywgMSksIGgoJ2xvYm9ydGlzJywgMSksIGgoJ2NvbnNlY3RldHVlcicsIDEpLCBoKCdtb3JiaScsIDEpLCBoKCd2ZWhpY3VsYScsIDEpLCBoKCd0b3J0b3InLCAxKSwgaCgndGVsbHVzLCcsIDEpLCBoKCdpZCwnLCAxKSwgaCgnZXUsJywgMSksIGgoJ3F1YW0nLCAxKSwgaCgnZmV1Z2lhdCwnLCAxKSwgaCgncG9zdWVyZSwnLCAxKSwgaCgnaWFjdWxpcycsIDEpLCBoKCdsZWN0dXMsJywgMSksIGgoJ3RyaXN0aXF1ZScsIDEpLCBoKCdtb2xsaXMsJywgMSksIGgoJ25pc2wsJywgMSksIGgoJ3Z1bHB1dGF0ZScsIDEpLCBoKCdzZW0nLCAxKSwgaCgndml2YW11cycsIDEpLCBoKCdwbGFjZXJhdCcsIDEpLCBoKCdpbXBlcmRpZXQnLCAxKSwgaCgnY3Vyc3VzJywgMSksIGgoJ3J1dHJ1bScsIDEpLCBoKCdpYWN1bGlzLCcsIDEpLCBoKCdhdWd1ZSwnLCAxKSwgaCgnbGFjdXMnLCAxKSk7XG59XG5mdW5jdGlvbiBsb3JlbShjb25zdHJhaW50cyA9IHt9KSB7XG4gICAgY29uc3QgeyBtYXhDb3VudCwgbW9kZSA9ICd3b3JkcycsIHNpemUgfSA9IGNvbnN0cmFpbnRzO1xuICAgIGlmIChtYXhDb3VudCAhPT0gdW5kZWZpbmVkICYmIG1heENvdW50IDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvcmVtIGhhcyB0byBwcm9kdWNlIGF0IGxlYXN0IG9uZSB3b3JkL3NlbnRlbmNlYCk7XG4gICAgfVxuICAgIGNvbnN0IHdvcmRBcmJpdHJhcnkgPSBsb3JlbVdvcmQoKTtcbiAgICBpZiAobW9kZSA9PT0gJ3NlbnRlbmNlcycpIHtcbiAgICAgICAgY29uc3Qgc2VudGVuY2UgPSAoMCwgYXJyYXlfMS5hcnJheSkod29yZEFyYml0cmFyeSwgeyBtaW5MZW5ndGg6IDEsIHNpemU6ICdzbWFsbCcgfSkubWFwKFdvcmRzVG9Mb3JlbV8xLndvcmRzVG9TZW50ZW5jZU1hcHBlciwgKDAsIFdvcmRzVG9Mb3JlbV8xLndvcmRzVG9TZW50ZW5jZVVubWFwcGVyRm9yKSh3b3JkQXJiaXRyYXJ5KSk7XG4gICAgICAgIHJldHVybiAoMCwgYXJyYXlfMS5hcnJheSkoc2VudGVuY2UsIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IG1heENvdW50LCBzaXplIH0pLm1hcChXb3Jkc1RvTG9yZW1fMS5zZW50ZW5jZXNUb1BhcmFncmFwaE1hcHBlciwgV29yZHNUb0xvcmVtXzEuc2VudGVuY2VzVG9QYXJhZ3JhcGhVbm1hcHBlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKDAsIGFycmF5XzEuYXJyYXkpKHdvcmRBcmJpdHJhcnksIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IG1heENvdW50LCBzaXplIH0pLm1hcChXb3Jkc1RvTG9yZW1fMS53b3Jkc1RvSm9pbmVkU3RyaW5nTWFwcGVyLCAoMCwgV29yZHNUb0xvcmVtXzEud29yZHNUb0pvaW5lZFN0cmluZ1VubWFwcGVyRm9yKSh3b3JkQXJiaXRyYXJ5KSk7XG4gICAgfVxufVxuZXhwb3J0cy5sb3JlbSA9IGxvcmVtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1hcFRvQ29uc3RhbnQgPSB2b2lkIDA7XG5jb25zdCBuYXRfMSA9IHJlcXVpcmUoXCIuL25hdFwiKTtcbmNvbnN0IEluZGV4VG9NYXBwZWRDb25zdGFudF8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9tYXBwZXJzL0luZGV4VG9NYXBwZWRDb25zdGFudFwiKTtcbmZ1bmN0aW9uIGNvbXB1dGVOdW1DaG9pY2VzKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5sZW5ndGggPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZmMubWFwVG9Db25zdGFudCBleHBlY3RzIGF0IGxlYXN0IG9uZSBvcHRpb25gKTtcbiAgICBsZXQgbnVtQ2hvaWNlcyA9IDA7XG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4ICE9PSBvcHRpb25zLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnNbaWR4XS5udW0gPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmYy5tYXBUb0NvbnN0YW50IGV4cGVjdHMgYWxsIG9wdGlvbnMgdG8gaGF2ZSBhIG51bWJlciBvZiBlbnRyaWVzIGdyZWF0ZXIgb3IgZXF1YWwgdG8gemVyb2ApO1xuICAgICAgICBudW1DaG9pY2VzICs9IG9wdGlvbnNbaWR4XS5udW07XG4gICAgfVxuICAgIGlmIChudW1DaG9pY2VzID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZjLm1hcFRvQ29uc3RhbnQgZXhwZWN0cyBhdCBsZWFzdCBvbmUgY2hvaWNlIGFtb25nIG9wdGlvbnNgKTtcbiAgICByZXR1cm4gbnVtQ2hvaWNlcztcbn1cbmZ1bmN0aW9uIG1hcFRvQ29uc3RhbnQoLi4uZW50cmllcykge1xuICAgIGNvbnN0IG51bUNob2ljZXMgPSBjb21wdXRlTnVtQ2hvaWNlcyhlbnRyaWVzKTtcbiAgICByZXR1cm4gKDAsIG5hdF8xLm5hdCkoeyBtYXg6IG51bUNob2ljZXMgLSAxIH0pLm1hcCgoMCwgSW5kZXhUb01hcHBlZENvbnN0YW50XzEuaW5kZXhUb01hcHBlZENvbnN0YW50TWFwcGVyRm9yKShlbnRyaWVzKSwgKDAsIEluZGV4VG9NYXBwZWRDb25zdGFudF8xLmluZGV4VG9NYXBwZWRDb25zdGFudFVubWFwcGVyRm9yKShlbnRyaWVzKSk7XG59XG5leHBvcnRzLm1hcFRvQ29uc3RhbnQgPSBtYXBUb0NvbnN0YW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1heFNhZmVJbnRlZ2VyID0gdm9pZCAwO1xuY29uc3QgSW50ZWdlckFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9JbnRlZ2VyQXJiaXRyYXJ5XCIpO1xuZnVuY3Rpb24gbWF4U2FmZUludGVnZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBJbnRlZ2VyQXJiaXRyYXJ5XzEuSW50ZWdlckFyYml0cmFyeShOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xufVxuZXhwb3J0cy5tYXhTYWZlSW50ZWdlciA9IG1heFNhZmVJbnRlZ2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1heFNhZmVOYXQgPSB2b2lkIDA7XG5jb25zdCBJbnRlZ2VyQXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL0ludGVnZXJBcmJpdHJhcnlcIik7XG5mdW5jdGlvbiBtYXhTYWZlTmF0KCkge1xuICAgIHJldHVybiBuZXcgSW50ZWdlckFyYml0cmFyeV8xLkludGVnZXJBcmJpdHJhcnkoMCwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xufVxuZXhwb3J0cy5tYXhTYWZlTmF0ID0gbWF4U2FmZU5hdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tZW1vID0gdm9pZCAwO1xubGV0IGNvbnRleHRSZW1haW5pbmdEZXB0aCA9IDEwO1xuZnVuY3Rpb24gbWVtbyhidWlsZGVyKSB7XG4gICAgY29uc3QgcHJldmlvdXMgPSB7fTtcbiAgICByZXR1cm4gKChtYXhEZXB0aCkgPT4ge1xuICAgICAgICBjb25zdCBuID0gbWF4RGVwdGggIT09IHVuZGVmaW5lZCA/IG1heERlcHRoIDogY29udGV4dFJlbWFpbmluZ0RlcHRoO1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcmV2aW91cywgbikpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBjb250ZXh0UmVtYWluaW5nRGVwdGg7XG4gICAgICAgICAgICBjb250ZXh0UmVtYWluaW5nRGVwdGggPSBuIC0gMTtcbiAgICAgICAgICAgIHByZXZpb3VzW25dID0gYnVpbGRlcihuKTtcbiAgICAgICAgICAgIGNvbnRleHRSZW1haW5pbmdEZXB0aCA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXZpb3VzW25dO1xuICAgIH0pO1xufVxuZXhwb3J0cy5tZW1vID0gbWVtbztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5taXhlZENhc2UgPSB2b2lkIDA7XG5jb25zdCBNaXhlZENhc2VBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvTWl4ZWRDYXNlQXJiaXRyYXJ5XCIpO1xuZnVuY3Rpb24gZGVmYXVsdFRvZ2dsZUNhc2UocmF3Q2hhcikge1xuICAgIGNvbnN0IHVwcGVyID0gcmF3Q2hhci50b1VwcGVyQ2FzZSgpO1xuICAgIGlmICh1cHBlciAhPT0gcmF3Q2hhcilcbiAgICAgICAgcmV0dXJuIHVwcGVyO1xuICAgIHJldHVybiByYXdDaGFyLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBtaXhlZENhc2Uoc3RyaW5nQXJiLCBjb25zdHJhaW50cykge1xuICAgIGlmICh0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1peGVkQ2FzZSByZXF1aXJlcyBCaWdJbnQgc3VwcG9ydGApO1xuICAgIH1cbiAgICBjb25zdCB0b2dnbGVDYXNlID0gKGNvbnN0cmFpbnRzICYmIGNvbnN0cmFpbnRzLnRvZ2dsZUNhc2UpIHx8IGRlZmF1bHRUb2dnbGVDYXNlO1xuICAgIGNvbnN0IHVudG9nZ2xlQWxsID0gY29uc3RyYWludHMgJiYgY29uc3RyYWludHMudW50b2dnbGVBbGw7XG4gICAgcmV0dXJuIG5ldyBNaXhlZENhc2VBcmJpdHJhcnlfMS5NaXhlZENhc2VBcmJpdHJhcnkoc3RyaW5nQXJiLCB0b2dnbGVDYXNlLCB1bnRvZ2dsZUFsbCk7XG59XG5leHBvcnRzLm1peGVkQ2FzZSA9IG1peGVkQ2FzZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5uYXQgPSB2b2lkIDA7XG5jb25zdCBJbnRlZ2VyQXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL0ludGVnZXJBcmJpdHJhcnlcIik7XG5mdW5jdGlvbiBuYXQoYXJnKSB7XG4gICAgY29uc3QgbWF4ID0gdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgPyBhcmcgOiBhcmcgJiYgYXJnLm1heCAhPT0gdW5kZWZpbmVkID8gYXJnLm1heCA6IDB4N2ZmZmZmZmY7XG4gICAgaWYgKG1heCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYy5uYXQgdmFsdWUgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwJyk7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmMubmF0IG1heGltdW0gdmFsdWUgc2hvdWxkIGJlIGFuIGludGVnZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBJbnRlZ2VyQXJiaXRyYXJ5XzEuSW50ZWdlckFyYml0cmFyeSgwLCBtYXgpO1xufVxuZXhwb3J0cy5uYXQgPSBuYXQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub2JqZWN0ID0gdm9pZCAwO1xuY29uc3QgZGljdGlvbmFyeV8xID0gcmVxdWlyZShcIi4vZGljdGlvbmFyeVwiKTtcbmNvbnN0IEFueUFyYml0cmFyeUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvYnVpbGRlcnMvQW55QXJiaXRyYXJ5QnVpbGRlclwiKTtcbmNvbnN0IFF1YWxpZmllZE9iamVjdENvbnN0cmFpbnRzXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2hlbHBlcnMvUXVhbGlmaWVkT2JqZWN0Q29uc3RyYWludHNcIik7XG5mdW5jdGlvbiBvYmplY3RJbnRlcm5hbChjb25zdHJhaW50cykge1xuICAgIHJldHVybiAoMCwgZGljdGlvbmFyeV8xLmRpY3Rpb25hcnkpKGNvbnN0cmFpbnRzLmtleSwgKDAsIEFueUFyYml0cmFyeUJ1aWxkZXJfMS5hbnlBcmJpdHJhcnlCdWlsZGVyKShjb25zdHJhaW50cyksIHtcbiAgICAgICAgbWF4S2V5czogY29uc3RyYWludHMubWF4S2V5cyxcbiAgICAgICAgc2l6ZTogY29uc3RyYWludHMuc2l6ZSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG9iamVjdChjb25zdHJhaW50cykge1xuICAgIHJldHVybiBvYmplY3RJbnRlcm5hbCgoMCwgUXVhbGlmaWVkT2JqZWN0Q29uc3RyYWludHNfMS50b1F1YWxpZmllZE9iamVjdENvbnN0cmFpbnRzKShjb25zdHJhaW50cykpO1xufVxuZXhwb3J0cy5vYmplY3QgPSBvYmplY3Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub25lb2YgPSB2b2lkIDA7XG5jb25zdCBBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9BcmJpdHJhcnlcIik7XG5jb25zdCBGcmVxdWVuY3lBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvRnJlcXVlbmN5QXJiaXRyYXJ5XCIpO1xuZnVuY3Rpb24gaXNPbmVPZkNvbnRyYWludHMocGFyYW0pIHtcbiAgICByZXR1cm4gKHBhcmFtICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHBhcmFtID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAhKCdnZW5lcmF0ZScgaW4gcGFyYW0pICYmXG4gICAgICAgICEoJ2FyYml0cmFyeScgaW4gcGFyYW0pICYmXG4gICAgICAgICEoJ3dlaWdodCcgaW4gcGFyYW0pKTtcbn1cbmZ1bmN0aW9uIHRvV2VpZ2h0ZWRBcmJpdHJhcnkobWF5YmVXZWlnaHRlZEFyYml0cmFyeSkge1xuICAgIGlmICgoMCwgQXJiaXRyYXJ5XzEuaXNBcmJpdHJhcnkpKG1heWJlV2VpZ2h0ZWRBcmJpdHJhcnkpKSB7XG4gICAgICAgIHJldHVybiB7IGFyYml0cmFyeTogbWF5YmVXZWlnaHRlZEFyYml0cmFyeSwgd2VpZ2h0OiAxIH07XG4gICAgfVxuICAgIHJldHVybiBtYXliZVdlaWdodGVkQXJiaXRyYXJ5O1xufVxuZnVuY3Rpb24gb25lb2YoLi4uYXJncykge1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gYXJnc1swXTtcbiAgICBpZiAoaXNPbmVPZkNvbnRyYWludHMoY29uc3RyYWludHMpKSB7XG4gICAgICAgIGNvbnN0IHdlaWdodGVkQXJicyA9IGFyZ3Muc2xpY2UoMSkubWFwKHRvV2VpZ2h0ZWRBcmJpdHJhcnkpO1xuICAgICAgICByZXR1cm4gRnJlcXVlbmN5QXJiaXRyYXJ5XzEuRnJlcXVlbmN5QXJiaXRyYXJ5LmZyb20od2VpZ2h0ZWRBcmJzLCBjb25zdHJhaW50cywgJ2ZjLm9uZW9mJyk7XG4gICAgfVxuICAgIGNvbnN0IHdlaWdodGVkQXJicyA9IGFyZ3MubWFwKHRvV2VpZ2h0ZWRBcmJpdHJhcnkpO1xuICAgIHJldHVybiBGcmVxdWVuY3lBcmJpdHJhcnlfMS5GcmVxdWVuY3lBcmJpdHJhcnkuZnJvbSh3ZWlnaHRlZEFyYnMsIHt9LCAnZmMub25lb2YnKTtcbn1cbmV4cG9ydHMub25lb2YgPSBvbmVvZjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vcHRpb24gPSB2b2lkIDA7XG5jb25zdCBjb25zdGFudF8xID0gcmVxdWlyZShcIi4vY29uc3RhbnRcIik7XG5jb25zdCBGcmVxdWVuY3lBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvRnJlcXVlbmN5QXJiaXRyYXJ5XCIpO1xuZnVuY3Rpb24gb3B0aW9uKGFyYiwgY29uc3RyYWludHMgPSB7fSkge1xuICAgIGNvbnN0IGZyZXEgPSBjb25zdHJhaW50cy5mcmVxID09IG51bGwgPyA1IDogY29uc3RyYWludHMuZnJlcTtcbiAgICBjb25zdCBuaWxWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25zdHJhaW50cywgJ25pbCcpID8gY29uc3RyYWludHMubmlsIDogbnVsbDtcbiAgICBjb25zdCBuaWxBcmIgPSAoMCwgY29uc3RhbnRfMS5jb25zdGFudCkobmlsVmFsdWUpO1xuICAgIGNvbnN0IHdlaWdodGVkQXJicyA9IFtcbiAgICAgICAgeyBhcmJpdHJhcnk6IG5pbEFyYiwgd2VpZ2h0OiAxLCBmYWxsYmFja1ZhbHVlOiB7IGRlZmF1bHQ6IG5pbFZhbHVlIH0gfSxcbiAgICAgICAgeyBhcmJpdHJhcnk6IGFyYiwgd2VpZ2h0OiBmcmVxIH0sXG4gICAgXTtcbiAgICBjb25zdCBmcmVxdWVuY3lDb25zdHJhaW50cyA9IHtcbiAgICAgICAgd2l0aENyb3NzU2hyaW5rOiB0cnVlLFxuICAgICAgICBkZXB0aFNpemU6IGNvbnN0cmFpbnRzLmRlcHRoU2l6ZSxcbiAgICAgICAgbWF4RGVwdGg6IGNvbnN0cmFpbnRzLm1heERlcHRoLFxuICAgICAgICBkZXB0aElkZW50aWZpZXI6IGNvbnN0cmFpbnRzLmRlcHRoSWRlbnRpZmllcixcbiAgICB9O1xuICAgIHJldHVybiBGcmVxdWVuY3lBcmJpdHJhcnlfMS5GcmVxdWVuY3lBcmJpdHJhcnkuZnJvbSh3ZWlnaHRlZEFyYnMsIGZyZXF1ZW5jeUNvbnN0cmFpbnRzLCAnZmMub3B0aW9uJyk7XG59XG5leHBvcnRzLm9wdGlvbiA9IG9wdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWNvcmQgPSB2b2lkIDA7XG5jb25zdCBQYXJ0aWFsUmVjb3JkQXJiaXRyYXJ5QnVpbGRlcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9idWlsZGVycy9QYXJ0aWFsUmVjb3JkQXJiaXRyYXJ5QnVpbGRlclwiKTtcbmZ1bmN0aW9uIHJlY29yZChyZWNvcmRNb2RlbCwgY29uc3RyYWludHMpIHtcbiAgICBpZiAoY29uc3RyYWludHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gKDAsIFBhcnRpYWxSZWNvcmRBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRQYXJ0aWFsUmVjb3JkQXJiaXRyYXJ5KShyZWNvcmRNb2RlbCwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgaWYgKCd3aXRoRGVsZXRlZEtleXMnIGluIGNvbnN0cmFpbnRzICYmICdyZXF1aXJlZEtleXMnIGluIGNvbnN0cmFpbnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcmVxdWlyZWRLZXlzIGFuZCB3aXRoRGVsZXRlZEtleXMgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXIgaW4gZmMucmVjb3JkYCk7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVpcmVEZWxldGVkS2V5cyA9ICgncmVxdWlyZWRLZXlzJyBpbiBjb25zdHJhaW50cyAmJiBjb25zdHJhaW50cy5yZXF1aXJlZEtleXMgIT09IHVuZGVmaW5lZCkgfHxcbiAgICAgICAgKCd3aXRoRGVsZXRlZEtleXMnIGluIGNvbnN0cmFpbnRzICYmICEhY29uc3RyYWludHMud2l0aERlbGV0ZWRLZXlzKTtcbiAgICBpZiAoIXJlcXVpcmVEZWxldGVkS2V5cykge1xuICAgICAgICByZXR1cm4gKDAsIFBhcnRpYWxSZWNvcmRBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRQYXJ0aWFsUmVjb3JkQXJiaXRyYXJ5KShyZWNvcmRNb2RlbCwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWlyZWRLZXlzID0gKCdyZXF1aXJlZEtleXMnIGluIGNvbnN0cmFpbnRzID8gY29uc3RyYWludHMucmVxdWlyZWRLZXlzIDogdW5kZWZpbmVkKSB8fCBbXTtcbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggIT09IHJlcXVpcmVkS2V5cy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHJlY29yZE1vZGVsLCByZXF1aXJlZEtleXNbaWR4XSk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcmVxdWlyZWRLZXlzIGNhbm5vdCByZWZlcmVuY2Uga2V5cyB0aGF0IGhhdmUgbm90IGJlZW4gZGVmaW5lZCBpbiByZWNvcmRNb2RlbGApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlcXVpcmVkS2V5cyBjYW5ub3QgcmVmZXJlbmNlIGtleXMgdGhhdCBoYXZlIGFyZSBlbnVtZXJhYmxlIGluIHJlY29yZE1vZGVsYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICgwLCBQYXJ0aWFsUmVjb3JkQXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkUGFydGlhbFJlY29yZEFyYml0cmFyeSkocmVjb3JkTW9kZWwsIHJlcXVpcmVkS2V5cyk7XG59XG5leHBvcnRzLnJlY29yZCA9IHJlY29yZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zY2hlZHVsZXJGb3IgPSBleHBvcnRzLnNjaGVkdWxlciA9IHZvaWQgMDtcbmNvbnN0IEJ1aWxkU2NoZWR1bGVyRm9yXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2hlbHBlcnMvQnVpbGRTY2hlZHVsZXJGb3JcIik7XG5jb25zdCBTY2hlZHVsZXJBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvU2NoZWR1bGVyQXJiaXRyYXJ5XCIpO1xuZnVuY3Rpb24gc2NoZWR1bGVyKGNvbnN0cmFpbnRzKSB7XG4gICAgY29uc3QgeyBhY3QgPSAoZikgPT4gZigpIH0gPSBjb25zdHJhaW50cyB8fCB7fTtcbiAgICByZXR1cm4gbmV3IFNjaGVkdWxlckFyYml0cmFyeV8xLlNjaGVkdWxlckFyYml0cmFyeShhY3QpO1xufVxuZXhwb3J0cy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG5mdW5jdGlvbiBzY2hlZHVsZXJGb3IoY3VzdG9tT3JkZXJpbmdPckNvbnN0cmFpbnRzLCBjb25zdHJhaW50c09yVW5kZWZpbmVkKSB7XG4gICAgY29uc3QgeyBhY3QgPSAoZikgPT4gZigpIH0gPSBBcnJheS5pc0FycmF5KGN1c3RvbU9yZGVyaW5nT3JDb25zdHJhaW50cylcbiAgICAgICAgPyBjb25zdHJhaW50c09yVW5kZWZpbmVkIHx8IHt9XG4gICAgICAgIDogY3VzdG9tT3JkZXJpbmdPckNvbnN0cmFpbnRzIHx8IHt9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KGN1c3RvbU9yZGVyaW5nT3JDb25zdHJhaW50cykpIHtcbiAgICAgICAgcmV0dXJuICgwLCBCdWlsZFNjaGVkdWxlckZvcl8xLmJ1aWxkU2NoZWR1bGVyRm9yKShhY3QsIGN1c3RvbU9yZGVyaW5nT3JDb25zdHJhaW50cyk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoX3N0cnMsIC4uLm9yZGVyaW5nKSB7XG4gICAgICAgIHJldHVybiAoMCwgQnVpbGRTY2hlZHVsZXJGb3JfMS5idWlsZFNjaGVkdWxlckZvcikoYWN0LCBvcmRlcmluZyk7XG4gICAgfTtcbn1cbmV4cG9ydHMuc2NoZWR1bGVyRm9yID0gc2NoZWR1bGVyRm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNodWZmbGVkU3ViYXJyYXkgPSB2b2lkIDA7XG5jb25zdCBTdWJhcnJheUFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9TdWJhcnJheUFyYml0cmFyeVwiKTtcbmZ1bmN0aW9uIHNodWZmbGVkU3ViYXJyYXkob3JpZ2luYWxBcnJheSwgY29uc3RyYWludHMgPSB7fSkge1xuICAgIGNvbnN0IHsgbWluTGVuZ3RoID0gMCwgbWF4TGVuZ3RoID0gb3JpZ2luYWxBcnJheS5sZW5ndGggfSA9IGNvbnN0cmFpbnRzO1xuICAgIHJldHVybiBuZXcgU3ViYXJyYXlBcmJpdHJhcnlfMS5TdWJhcnJheUFyYml0cmFyeShvcmlnaW5hbEFycmF5LCBmYWxzZSwgbWluTGVuZ3RoLCBtYXhMZW5ndGgpO1xufVxuZXhwb3J0cy5zaHVmZmxlZFN1YmFycmF5ID0gc2h1ZmZsZWRTdWJhcnJheTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zcGFyc2VBcnJheSA9IHZvaWQgMDtcbmNvbnN0IHR1cGxlXzEgPSByZXF1aXJlKFwiLi90dXBsZVwiKTtcbmNvbnN0IHVuaXF1ZUFycmF5XzEgPSByZXF1aXJlKFwiLi91bmlxdWVBcnJheVwiKTtcbmNvbnN0IFJlc3RyaWN0ZWRJbnRlZ2VyQXJiaXRyYXJ5QnVpbGRlcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9idWlsZGVycy9SZXN0cmljdGVkSW50ZWdlckFyYml0cmFyeUJ1aWxkZXJcIik7XG5jb25zdCBNYXhMZW5ndGhGcm9tTWluTGVuZ3RoXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2hlbHBlcnMvTWF4TGVuZ3RoRnJvbU1pbkxlbmd0aFwiKTtcbmZ1bmN0aW9uIGV4dHJhY3RNYXhJbmRleChpbmRleGVzQW5kVmFsdWVzKSB7XG4gICAgbGV0IG1heEluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCAhPT0gaW5kZXhlc0FuZFZhbHVlcy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgbWF4SW5kZXggPSBNYXRoLm1heChtYXhJbmRleCwgaW5kZXhlc0FuZFZhbHVlc1tpbmRleF1bMF0pO1xuICAgIH1cbiAgICByZXR1cm4gbWF4SW5kZXg7XG59XG5mdW5jdGlvbiBhcnJheUZyb21JdGVtcyhsZW5ndGgsIGluZGV4ZXNBbmRWYWx1ZXMpIHtcbiAgICBjb25zdCBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCAhPT0gaW5kZXhlc0FuZFZhbHVlcy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgY29uc3QgaXQgPSBpbmRleGVzQW5kVmFsdWVzW2luZGV4XTtcbiAgICAgICAgaWYgKGl0WzBdIDwgbGVuZ3RoKVxuICAgICAgICAgICAgYXJyYXlbaXRbMF1dID0gaXRbMV07XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmZ1bmN0aW9uIHNwYXJzZUFycmF5KGFyYiwgY29uc3RyYWludHMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSwgbWluTnVtRWxlbWVudHMgPSAwLCBtYXhMZW5ndGggPSBNYXhMZW5ndGhGcm9tTWluTGVuZ3RoXzEuTWF4TGVuZ3RoVXBwZXJCb3VuZCwgbWF4TnVtRWxlbWVudHMgPSBtYXhMZW5ndGgsIG5vVHJhaWxpbmdIb2xlLCBkZXB0aElkZW50aWZpZXIsIH0gPSBjb25zdHJhaW50cztcbiAgICBjb25zdCBtYXhHZW5lcmF0ZWROdW1FbGVtZW50cyA9ICgwLCBNYXhMZW5ndGhGcm9tTWluTGVuZ3RoXzEubWF4R2VuZXJhdGVkTGVuZ3RoRnJvbVNpemVGb3JBcmJpdHJhcnkpKHNpemUsIG1pbk51bUVsZW1lbnRzLCBtYXhOdW1FbGVtZW50cywgY29uc3RyYWludHMubWF4TnVtRWxlbWVudHMgIT09IHVuZGVmaW5lZCk7XG4gICAgY29uc3QgbWF4R2VuZXJhdGVkTGVuZ3RoID0gKDAsIE1heExlbmd0aEZyb21NaW5MZW5ndGhfMS5tYXhHZW5lcmF0ZWRMZW5ndGhGcm9tU2l6ZUZvckFyYml0cmFyeSkoc2l6ZSwgbWF4R2VuZXJhdGVkTnVtRWxlbWVudHMsIG1heExlbmd0aCwgY29uc3RyYWludHMubWF4TGVuZ3RoICE9PSB1bmRlZmluZWQpO1xuICAgIGlmIChtaW5OdW1FbGVtZW50cyA+IG1heExlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBtaW5pbWFsIG51bWJlciBvZiBub24taG9sZSBlbGVtZW50cyBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gdGhlIG1heGltYWwgbGVuZ3RoIG9mIHRoZSBhcnJheWApO1xuICAgIH1cbiAgICBpZiAobWluTnVtRWxlbWVudHMgPiBtYXhOdW1FbGVtZW50cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBtaW5pbWFsIG51bWJlciBvZiBub24taG9sZSBlbGVtZW50cyBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gdGhlIG1heGltYWwgbnVtYmVyIG9mIG5vbi1ob2xlc2ApO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHRlZE1heE51bUVsZW1lbnRzID0gTWF0aC5taW4obWF4TnVtRWxlbWVudHMsIG1heExlbmd0aCk7XG4gICAgY29uc3QgcmVzdWx0ZWRTaXplTWF4TnVtRWxlbWVudHMgPSBjb25zdHJhaW50cy5tYXhOdW1FbGVtZW50cyAhPT0gdW5kZWZpbmVkIHx8IHNpemUgIT09IHVuZGVmaW5lZCA/IHNpemUgOiAnPSc7XG4gICAgY29uc3QgbWF4R2VuZXJhdGVkSW5kZXhBdXRob3JpemVkID0gTWF0aC5tYXgobWF4R2VuZXJhdGVkTGVuZ3RoIC0gMSwgMCk7XG4gICAgY29uc3QgbWF4SW5kZXhBdXRob3JpemVkID0gTWF0aC5tYXgobWF4TGVuZ3RoIC0gMSwgMCk7XG4gICAgY29uc3Qgc3BhcnNlQXJyYXlOb1RyYWlsaW5nSG9sZSA9ICgwLCB1bmlxdWVBcnJheV8xLnVuaXF1ZUFycmF5KSgoMCwgdHVwbGVfMS50dXBsZSkoKDAsIFJlc3RyaWN0ZWRJbnRlZ2VyQXJiaXRyYXJ5QnVpbGRlcl8xLnJlc3RyaWN0ZWRJbnRlZ2VyQXJiaXRyYXJ5QnVpbGRlcikoMCwgbWF4R2VuZXJhdGVkSW5kZXhBdXRob3JpemVkLCBtYXhJbmRleEF1dGhvcml6ZWQpLCBhcmIpLCB7XG4gICAgICAgIHNpemU6IHJlc3VsdGVkU2l6ZU1heE51bUVsZW1lbnRzLFxuICAgICAgICBtaW5MZW5ndGg6IG1pbk51bUVsZW1lbnRzLFxuICAgICAgICBtYXhMZW5ndGg6IHJlc3VsdGVkTWF4TnVtRWxlbWVudHMsXG4gICAgICAgIHNlbGVjdG9yOiAoaXRlbSkgPT4gaXRlbVswXSxcbiAgICAgICAgZGVwdGhJZGVudGlmaWVyLFxuICAgIH0pLm1hcCgoaXRlbXMpID0+IHtcbiAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gZXh0cmFjdE1heEluZGV4KGl0ZW1zKTtcbiAgICAgICAgcmV0dXJuIGFycmF5RnJvbUl0ZW1zKGxhc3RJbmRleCArIDEsIGl0ZW1zKTtcbiAgICB9LCAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkIGVudHJ5IHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9UcmFpbGluZ0hvbGUgJiYgdmFsdWUubGVuZ3RoICE9PSAwICYmICEodmFsdWUubGVuZ3RoIC0gMSBpbiB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdHJhaWxpbmcgaG9sZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyh2YWx1ZSkubWFwKChlbnRyeSkgPT4gW051bWJlcihlbnRyeVswXSksIGVudHJ5WzFdXSk7XG4gICAgfSk7XG4gICAgaWYgKG5vVHJhaWxpbmdIb2xlIHx8IG1heExlbmd0aCA9PT0gbWluTnVtRWxlbWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHNwYXJzZUFycmF5Tm9UcmFpbGluZ0hvbGU7XG4gICAgfVxuICAgIHJldHVybiAoMCwgdHVwbGVfMS50dXBsZSkoc3BhcnNlQXJyYXlOb1RyYWlsaW5nSG9sZSwgKDAsIFJlc3RyaWN0ZWRJbnRlZ2VyQXJiaXRyYXJ5QnVpbGRlcl8xLnJlc3RyaWN0ZWRJbnRlZ2VyQXJiaXRyYXJ5QnVpbGRlcikobWluTnVtRWxlbWVudHMsIG1heEdlbmVyYXRlZExlbmd0aCwgbWF4TGVuZ3RoKSkubWFwKChkYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHNwYXJzZSA9IGRhdGFbMF07XG4gICAgICAgIGNvbnN0IHRhcmdldExlbmd0aCA9IGRhdGFbMV07XG4gICAgICAgIGlmIChzcGFyc2UubGVuZ3RoID49IHRhcmdldExlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHNwYXJzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb25nZXJTcGFyc2UgPSBzcGFyc2Uuc2xpY2UoKTtcbiAgICAgICAgbG9uZ2VyU3BhcnNlLmxlbmd0aCA9IHRhcmdldExlbmd0aDtcbiAgICAgICAgcmV0dXJuIGxvbmdlclNwYXJzZTtcbiAgICB9LCAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkIGVudHJ5IHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3ZhbHVlLCB2YWx1ZS5sZW5ndGhdO1xuICAgIH0pO1xufVxuZXhwb3J0cy5zcGFyc2VBcnJheSA9IHNwYXJzZUFycmF5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN0cmluZyA9IHZvaWQgMDtcbmNvbnN0IGFycmF5XzEgPSByZXF1aXJlKFwiLi9hcnJheVwiKTtcbmNvbnN0IGNoYXJfMSA9IHJlcXVpcmUoXCIuL2NoYXJcIik7XG5jb25zdCBDb2RlUG9pbnRzVG9TdHJpbmdfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvbWFwcGVycy9Db2RlUG9pbnRzVG9TdHJpbmdcIik7XG5jb25zdCBTbGljZXNGb3JTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2hlbHBlcnMvU2xpY2VzRm9yU3RyaW5nQnVpbGRlclwiKTtcbmZ1bmN0aW9uIHN0cmluZyhjb25zdHJhaW50cyA9IHt9KSB7XG4gICAgY29uc3QgY2hhckFyYml0cmFyeSA9ICgwLCBjaGFyXzEuY2hhcikoKTtcbiAgICBjb25zdCBleHBlcmltZW50YWxDdXN0b21TbGljZXMgPSAoMCwgU2xpY2VzRm9yU3RyaW5nQnVpbGRlcl8xLmNyZWF0ZVNsaWNlc0ZvclN0cmluZykoY2hhckFyYml0cmFyeSwgQ29kZVBvaW50c1RvU3RyaW5nXzEuY29kZVBvaW50c1RvU3RyaW5nVW5tYXBwZXIpO1xuICAgIGNvbnN0IGVucmljaGVkQ29uc3RyYWludHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbnN0cmFpbnRzKSwgeyBleHBlcmltZW50YWxDdXN0b21TbGljZXMgfSk7XG4gICAgcmV0dXJuICgwLCBhcnJheV8xLmFycmF5KShjaGFyQXJiaXRyYXJ5LCBlbnJpY2hlZENvbnN0cmFpbnRzKS5tYXAoQ29kZVBvaW50c1RvU3RyaW5nXzEuY29kZVBvaW50c1RvU3RyaW5nTWFwcGVyLCBDb2RlUG9pbnRzVG9TdHJpbmdfMS5jb2RlUG9pbnRzVG9TdHJpbmdVbm1hcHBlcik7XG59XG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdHJpbmcxNmJpdHMgPSB2b2lkIDA7XG5jb25zdCBhcnJheV8xID0gcmVxdWlyZShcIi4vYXJyYXlcIik7XG5jb25zdCBjaGFyMTZiaXRzXzEgPSByZXF1aXJlKFwiLi9jaGFyMTZiaXRzXCIpO1xuY29uc3QgQ2hhcnNUb1N0cmluZ18xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9tYXBwZXJzL0NoYXJzVG9TdHJpbmdcIik7XG5jb25zdCBTbGljZXNGb3JTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2hlbHBlcnMvU2xpY2VzRm9yU3RyaW5nQnVpbGRlclwiKTtcbmZ1bmN0aW9uIHN0cmluZzE2Yml0cyhjb25zdHJhaW50cyA9IHt9KSB7XG4gICAgY29uc3QgY2hhckFyYml0cmFyeSA9ICgwLCBjaGFyMTZiaXRzXzEuY2hhcjE2Yml0cykoKTtcbiAgICBjb25zdCBleHBlcmltZW50YWxDdXN0b21TbGljZXMgPSAoMCwgU2xpY2VzRm9yU3RyaW5nQnVpbGRlcl8xLmNyZWF0ZVNsaWNlc0ZvclN0cmluZykoY2hhckFyYml0cmFyeSwgQ2hhcnNUb1N0cmluZ18xLmNoYXJzVG9TdHJpbmdVbm1hcHBlcik7XG4gICAgY29uc3QgZW5yaWNoZWRDb25zdHJhaW50cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uc3RyYWludHMpLCB7IGV4cGVyaW1lbnRhbEN1c3RvbVNsaWNlcyB9KTtcbiAgICByZXR1cm4gKDAsIGFycmF5XzEuYXJyYXkpKGNoYXJBcmJpdHJhcnksIGVucmljaGVkQ29uc3RyYWludHMpLm1hcChDaGFyc1RvU3RyaW5nXzEuY2hhcnNUb1N0cmluZ01hcHBlciwgQ2hhcnNUb1N0cmluZ18xLmNoYXJzVG9TdHJpbmdVbm1hcHBlcik7XG59XG5leHBvcnRzLnN0cmluZzE2Yml0cyA9IHN0cmluZzE2Yml0cztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdHJpbmdPZiA9IHZvaWQgMDtcbmNvbnN0IGFycmF5XzEgPSByZXF1aXJlKFwiLi9hcnJheVwiKTtcbmNvbnN0IFBhdHRlcm5zVG9TdHJpbmdfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvbWFwcGVycy9QYXR0ZXJuc1RvU3RyaW5nXCIpO1xuY29uc3QgU2xpY2VzRm9yU3RyaW5nQnVpbGRlcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9oZWxwZXJzL1NsaWNlc0ZvclN0cmluZ0J1aWxkZXJcIik7XG5mdW5jdGlvbiBzdHJpbmdPZihjaGFyQXJiLCBjb25zdHJhaW50cyA9IHt9KSB7XG4gICAgY29uc3QgdW5tYXBwZXIgPSAoMCwgUGF0dGVybnNUb1N0cmluZ18xLnBhdHRlcm5zVG9TdHJpbmdVbm1hcHBlckZvcikoY2hhckFyYiwgY29uc3RyYWludHMpO1xuICAgIGNvbnN0IGV4cGVyaW1lbnRhbEN1c3RvbVNsaWNlcyA9ICgwLCBTbGljZXNGb3JTdHJpbmdCdWlsZGVyXzEuY3JlYXRlU2xpY2VzRm9yU3RyaW5nKShjaGFyQXJiLCB1bm1hcHBlcik7XG4gICAgY29uc3QgZW5yaWNoZWRDb25zdHJhaW50cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uc3RyYWludHMpLCB7IGV4cGVyaW1lbnRhbEN1c3RvbVNsaWNlcyB9KTtcbiAgICByZXR1cm4gKDAsIGFycmF5XzEuYXJyYXkpKGNoYXJBcmIsIGVucmljaGVkQ29uc3RyYWludHMpLm1hcChQYXR0ZXJuc1RvU3RyaW5nXzEucGF0dGVybnNUb1N0cmluZ01hcHBlciwgdW5tYXBwZXIpO1xufVxuZXhwb3J0cy5zdHJpbmdPZiA9IHN0cmluZ09mO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN1YmFycmF5ID0gdm9pZCAwO1xuY29uc3QgU3ViYXJyYXlBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvU3ViYXJyYXlBcmJpdHJhcnlcIik7XG5mdW5jdGlvbiBzdWJhcnJheShvcmlnaW5hbEFycmF5LCBjb25zdHJhaW50cyA9IHt9KSB7XG4gICAgY29uc3QgeyBtaW5MZW5ndGggPSAwLCBtYXhMZW5ndGggPSBvcmlnaW5hbEFycmF5Lmxlbmd0aCB9ID0gY29uc3RyYWludHM7XG4gICAgcmV0dXJuIG5ldyBTdWJhcnJheUFyYml0cmFyeV8xLlN1YmFycmF5QXJiaXRyYXJ5KG9yaWdpbmFsQXJyYXksIHRydWUsIG1pbkxlbmd0aCwgbWF4TGVuZ3RoKTtcbn1cbmV4cG9ydHMuc3ViYXJyYXkgPSBzdWJhcnJheTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50dXBsZSA9IHZvaWQgMDtcbmNvbnN0IFR1cGxlQXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL1R1cGxlQXJiaXRyYXJ5XCIpO1xuZnVuY3Rpb24gdHVwbGUoLi4uYXJicykge1xuICAgIHJldHVybiBuZXcgVHVwbGVBcmJpdHJhcnlfMS5UdXBsZUFyYml0cmFyeShhcmJzKTtcbn1cbmV4cG9ydHMudHVwbGUgPSB0dXBsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51aW50MTZBcnJheSA9IHZvaWQgMDtcbmNvbnN0IGludGVnZXJfMSA9IHJlcXVpcmUoXCIuL2ludGVnZXJcIik7XG5jb25zdCBUeXBlZEludEFycmF5QXJiaXRyYXJ5QnVpbGRlcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9idWlsZGVycy9UeXBlZEludEFycmF5QXJiaXRyYXJ5QnVpbGRlclwiKTtcbmZ1bmN0aW9uIHVpbnQxNkFycmF5KGNvbnN0cmFpbnRzID0ge30pIHtcbiAgICByZXR1cm4gKDAsIFR5cGVkSW50QXJyYXlBcmJpdHJhcnlCdWlsZGVyXzEudHlwZWRJbnRBcnJheUFyYml0cmFyeUFyYml0cmFyeUJ1aWxkZXIpKGNvbnN0cmFpbnRzLCAwLCA2NTUzNSwgVWludDE2QXJyYXksIGludGVnZXJfMS5pbnRlZ2VyKTtcbn1cbmV4cG9ydHMudWludDE2QXJyYXkgPSB1aW50MTZBcnJheTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51aW50MzJBcnJheSA9IHZvaWQgMDtcbmNvbnN0IGludGVnZXJfMSA9IHJlcXVpcmUoXCIuL2ludGVnZXJcIik7XG5jb25zdCBUeXBlZEludEFycmF5QXJiaXRyYXJ5QnVpbGRlcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9idWlsZGVycy9UeXBlZEludEFycmF5QXJiaXRyYXJ5QnVpbGRlclwiKTtcbmZ1bmN0aW9uIHVpbnQzMkFycmF5KGNvbnN0cmFpbnRzID0ge30pIHtcbiAgICByZXR1cm4gKDAsIFR5cGVkSW50QXJyYXlBcmJpdHJhcnlCdWlsZGVyXzEudHlwZWRJbnRBcnJheUFyYml0cmFyeUFyYml0cmFyeUJ1aWxkZXIpKGNvbnN0cmFpbnRzLCAwLCAweGZmZmZmZmZmLCBVaW50MzJBcnJheSwgaW50ZWdlcl8xLmludGVnZXIpO1xufVxuZXhwb3J0cy51aW50MzJBcnJheSA9IHVpbnQzMkFycmF5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVpbnQ4QXJyYXkgPSB2b2lkIDA7XG5jb25zdCBpbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi9pbnRlZ2VyXCIpO1xuY29uc3QgVHlwZWRJbnRBcnJheUFyYml0cmFyeUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvYnVpbGRlcnMvVHlwZWRJbnRBcnJheUFyYml0cmFyeUJ1aWxkZXJcIik7XG5mdW5jdGlvbiB1aW50OEFycmF5KGNvbnN0cmFpbnRzID0ge30pIHtcbiAgICByZXR1cm4gKDAsIFR5cGVkSW50QXJyYXlBcmJpdHJhcnlCdWlsZGVyXzEudHlwZWRJbnRBcnJheUFyYml0cmFyeUFyYml0cmFyeUJ1aWxkZXIpKGNvbnN0cmFpbnRzLCAwLCAyNTUsIFVpbnQ4QXJyYXksIGludGVnZXJfMS5pbnRlZ2VyKTtcbn1cbmV4cG9ydHMudWludDhBcnJheSA9IHVpbnQ4QXJyYXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudWludDhDbGFtcGVkQXJyYXkgPSB2b2lkIDA7XG5jb25zdCBpbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi9pbnRlZ2VyXCIpO1xuY29uc3QgVHlwZWRJbnRBcnJheUFyYml0cmFyeUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvYnVpbGRlcnMvVHlwZWRJbnRBcnJheUFyYml0cmFyeUJ1aWxkZXJcIik7XG5mdW5jdGlvbiB1aW50OENsYW1wZWRBcnJheShjb25zdHJhaW50cyA9IHt9KSB7XG4gICAgcmV0dXJuICgwLCBUeXBlZEludEFycmF5QXJiaXRyYXJ5QnVpbGRlcl8xLnR5cGVkSW50QXJyYXlBcmJpdHJhcnlBcmJpdHJhcnlCdWlsZGVyKShjb25zdHJhaW50cywgMCwgMjU1LCBVaW50OENsYW1wZWRBcnJheSwgaW50ZWdlcl8xLmludGVnZXIpO1xufVxuZXhwb3J0cy51aW50OENsYW1wZWRBcnJheSA9IHVpbnQ4Q2xhbXBlZEFycmF5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVuaWNvZGUgPSB2b2lkIDA7XG5jb25zdCBDaGFyYWN0ZXJBcmJpdHJhcnlCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2J1aWxkZXJzL0NoYXJhY3RlckFyYml0cmFyeUJ1aWxkZXJcIik7XG5jb25zdCBJbmRleFRvUHJpbnRhYmxlSW5kZXhfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvbWFwcGVycy9JbmRleFRvUHJpbnRhYmxlSW5kZXhcIik7XG5jb25zdCBnYXBTaXplID0gMHhkZmZmICsgMSAtIDB4ZDgwMDtcbmZ1bmN0aW9uIHVuaWNvZGVNYXBwZXIodikge1xuICAgIGlmICh2IDwgMHhkODAwKVxuICAgICAgICByZXR1cm4gKDAsIEluZGV4VG9QcmludGFibGVJbmRleF8xLmluZGV4VG9QcmludGFibGVJbmRleE1hcHBlcikodik7XG4gICAgcmV0dXJuIHYgKyBnYXBTaXplO1xufVxuZnVuY3Rpb24gdW5pY29kZVVubWFwcGVyKHYpIHtcbiAgICBpZiAodiA8IDB4ZDgwMClcbiAgICAgICAgcmV0dXJuICgwLCBJbmRleFRvUHJpbnRhYmxlSW5kZXhfMS5pbmRleFRvUHJpbnRhYmxlSW5kZXhVbm1hcHBlcikodik7XG4gICAgaWYgKHYgPD0gMHhkZmZmKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIHYgLSBnYXBTaXplO1xufVxuZnVuY3Rpb24gdW5pY29kZSgpIHtcbiAgICByZXR1cm4gKDAsIENoYXJhY3RlckFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZENoYXJhY3RlckFyYml0cmFyeSkoMHgwMDAwLCAweGZmZmYgLSBnYXBTaXplLCB1bmljb2RlTWFwcGVyLCB1bmljb2RlVW5tYXBwZXIpO1xufVxuZXhwb3J0cy51bmljb2RlID0gdW5pY29kZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51bmljb2RlSnNvbiA9IHZvaWQgMDtcbmNvbnN0IHVuaWNvZGVKc29uVmFsdWVfMSA9IHJlcXVpcmUoXCIuL3VuaWNvZGVKc29uVmFsdWVcIik7XG5mdW5jdGlvbiB1bmljb2RlSnNvbihjb25zdHJhaW50cyA9IHt9KSB7XG4gICAgY29uc3QgYXJiID0gKDAsIHVuaWNvZGVKc29uVmFsdWVfMS51bmljb2RlSnNvblZhbHVlKShjb25zdHJhaW50cyk7XG4gICAgcmV0dXJuIGFyYi5tYXAoSlNPTi5zdHJpbmdpZnkpO1xufVxuZXhwb3J0cy51bmljb2RlSnNvbiA9IHVuaWNvZGVKc29uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVuaWNvZGVKc29uVmFsdWUgPSB2b2lkIDA7XG5jb25zdCB1bmljb2RlU3RyaW5nXzEgPSByZXF1aXJlKFwiLi91bmljb2RlU3RyaW5nXCIpO1xuY29uc3QgSnNvbkNvbnN0cmFpbnRzQnVpbGRlcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9oZWxwZXJzL0pzb25Db25zdHJhaW50c0J1aWxkZXJcIik7XG5jb25zdCBhbnl0aGluZ18xID0gcmVxdWlyZShcIi4vYW55dGhpbmdcIik7XG5mdW5jdGlvbiB1bmljb2RlSnNvblZhbHVlKGNvbnN0cmFpbnRzID0ge30pIHtcbiAgICByZXR1cm4gKDAsIGFueXRoaW5nXzEuYW55dGhpbmcpKCgwLCBKc29uQ29uc3RyYWludHNCdWlsZGVyXzEuanNvbkNvbnN0cmFpbnRzQnVpbGRlcikoKDAsIHVuaWNvZGVTdHJpbmdfMS51bmljb2RlU3RyaW5nKSgpLCBjb25zdHJhaW50cykpO1xufVxuZXhwb3J0cy51bmljb2RlSnNvblZhbHVlID0gdW5pY29kZUpzb25WYWx1ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51bmljb2RlU3RyaW5nID0gdm9pZCAwO1xuY29uc3QgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FycmF5XCIpO1xuY29uc3QgdW5pY29kZV8xID0gcmVxdWlyZShcIi4vdW5pY29kZVwiKTtcbmNvbnN0IENvZGVQb2ludHNUb1N0cmluZ18xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9tYXBwZXJzL0NvZGVQb2ludHNUb1N0cmluZ1wiKTtcbmNvbnN0IFNsaWNlc0ZvclN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvaGVscGVycy9TbGljZXNGb3JTdHJpbmdCdWlsZGVyXCIpO1xuZnVuY3Rpb24gdW5pY29kZVN0cmluZyhjb25zdHJhaW50cyA9IHt9KSB7XG4gICAgY29uc3QgY2hhckFyYml0cmFyeSA9ICgwLCB1bmljb2RlXzEudW5pY29kZSkoKTtcbiAgICBjb25zdCBleHBlcmltZW50YWxDdXN0b21TbGljZXMgPSAoMCwgU2xpY2VzRm9yU3RyaW5nQnVpbGRlcl8xLmNyZWF0ZVNsaWNlc0ZvclN0cmluZykoY2hhckFyYml0cmFyeSwgQ29kZVBvaW50c1RvU3RyaW5nXzEuY29kZVBvaW50c1RvU3RyaW5nVW5tYXBwZXIpO1xuICAgIGNvbnN0IGVucmljaGVkQ29uc3RyYWludHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbnN0cmFpbnRzKSwgeyBleHBlcmltZW50YWxDdXN0b21TbGljZXMgfSk7XG4gICAgcmV0dXJuICgwLCBhcnJheV8xLmFycmF5KShjaGFyQXJiaXRyYXJ5LCBlbnJpY2hlZENvbnN0cmFpbnRzKS5tYXAoQ29kZVBvaW50c1RvU3RyaW5nXzEuY29kZVBvaW50c1RvU3RyaW5nTWFwcGVyLCBDb2RlUG9pbnRzVG9TdHJpbmdfMS5jb2RlUG9pbnRzVG9TdHJpbmdVbm1hcHBlcik7XG59XG5leHBvcnRzLnVuaWNvZGVTdHJpbmcgPSB1bmljb2RlU3RyaW5nO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVuaXF1ZUFycmF5ID0gdm9pZCAwO1xuY29uc3QgQXJyYXlBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvQXJyYXlBcmJpdHJhcnlcIik7XG5jb25zdCBNYXhMZW5ndGhGcm9tTWluTGVuZ3RoXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2hlbHBlcnMvTWF4TGVuZ3RoRnJvbU1pbkxlbmd0aFwiKTtcbmNvbnN0IEN1c3RvbUVxdWFsU2V0XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2hlbHBlcnMvQ3VzdG9tRXF1YWxTZXRcIik7XG5jb25zdCBTdHJpY3RseUVxdWFsU2V0XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2hlbHBlcnMvU3RyaWN0bHlFcXVhbFNldFwiKTtcbmNvbnN0IFNhbWVWYWx1ZVNldF8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9oZWxwZXJzL1NhbWVWYWx1ZVNldFwiKTtcbmNvbnN0IFNhbWVWYWx1ZVplcm9TZXRfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvaGVscGVycy9TYW1lVmFsdWVaZXJvU2V0XCIpO1xuZnVuY3Rpb24gYnVpbGRVbmlxdWVBcnJheVNldEJ1aWxkZXIoY29uc3RyYWludHMpIHtcbiAgICBpZiAodHlwZW9mIGNvbnN0cmFpbnRzLmNvbXBhcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzLnNlbGVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBhcmF0b3IgPSBjb25zdHJhaW50cy5jb21wYXJhdG9yO1xuICAgICAgICAgICAgY29uc3QgaXNFcXVhbEZvckJ1aWxkZXIgPSAobmV4dEEsIG5leHRCKSA9PiBjb21wYXJhdG9yKG5leHRBLnZhbHVlXywgbmV4dEIudmFsdWVfKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBuZXcgQ3VzdG9tRXF1YWxTZXRfMS5DdXN0b21FcXVhbFNldChpc0VxdWFsRm9yQnVpbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcGFyYXRvciA9IGNvbnN0cmFpbnRzLmNvbXBhcmF0b3I7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gY29uc3RyYWludHMuc2VsZWN0b3I7XG4gICAgICAgIGNvbnN0IHJlZmluZWRTZWxlY3RvciA9IChuZXh0KSA9PiBzZWxlY3RvcihuZXh0LnZhbHVlXyk7XG4gICAgICAgIGNvbnN0IGlzRXF1YWxGb3JCdWlsZGVyID0gKG5leHRBLCBuZXh0QikgPT4gY29tcGFyYXRvcihyZWZpbmVkU2VsZWN0b3IobmV4dEEpLCByZWZpbmVkU2VsZWN0b3IobmV4dEIpKTtcbiAgICAgICAgcmV0dXJuICgpID0+IG5ldyBDdXN0b21FcXVhbFNldF8xLkN1c3RvbUVxdWFsU2V0KGlzRXF1YWxGb3JCdWlsZGVyKTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBjb25zdHJhaW50cy5zZWxlY3RvciB8fCAoKHYpID0+IHYpO1xuICAgIGNvbnN0IHJlZmluZWRTZWxlY3RvciA9IChuZXh0KSA9PiBzZWxlY3RvcihuZXh0LnZhbHVlXyk7XG4gICAgc3dpdGNoIChjb25zdHJhaW50cy5jb21wYXJhdG9yKSB7XG4gICAgICAgIGNhc2UgJ0lzU3RyaWN0bHlFcXVhbCc6XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gbmV3IFN0cmljdGx5RXF1YWxTZXRfMS5TdHJpY3RseUVxdWFsU2V0KHJlZmluZWRTZWxlY3Rvcik7XG4gICAgICAgIGNhc2UgJ1NhbWVWYWx1ZVplcm8nOlxuICAgICAgICAgICAgcmV0dXJuICgpID0+IG5ldyBTYW1lVmFsdWVaZXJvU2V0XzEuU2FtZVZhbHVlWmVyb1NldChyZWZpbmVkU2VsZWN0b3IpO1xuICAgICAgICBjYXNlICdTYW1lVmFsdWUnOlxuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBuZXcgU2FtZVZhbHVlU2V0XzEuU2FtZVZhbHVlU2V0KHJlZmluZWRTZWxlY3Rvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gdW5pcXVlQXJyYXkoYXJiLCBjb25zdHJhaW50cyA9IHt9KSB7XG4gICAgY29uc3QgbWluTGVuZ3RoID0gY29uc3RyYWludHMubWluTGVuZ3RoICE9PSB1bmRlZmluZWQgPyBjb25zdHJhaW50cy5taW5MZW5ndGggOiAwO1xuICAgIGNvbnN0IG1heExlbmd0aCA9IGNvbnN0cmFpbnRzLm1heExlbmd0aCAhPT0gdW5kZWZpbmVkID8gY29uc3RyYWludHMubWF4TGVuZ3RoIDogTWF4TGVuZ3RoRnJvbU1pbkxlbmd0aF8xLk1heExlbmd0aFVwcGVyQm91bmQ7XG4gICAgY29uc3QgbWF4R2VuZXJhdGVkTGVuZ3RoID0gKDAsIE1heExlbmd0aEZyb21NaW5MZW5ndGhfMS5tYXhHZW5lcmF0ZWRMZW5ndGhGcm9tU2l6ZUZvckFyYml0cmFyeSkoY29uc3RyYWludHMuc2l6ZSwgbWluTGVuZ3RoLCBtYXhMZW5ndGgsIGNvbnN0cmFpbnRzLm1heExlbmd0aCAhPT0gdW5kZWZpbmVkKTtcbiAgICBjb25zdCBkZXB0aElkZW50aWZpZXIgPSBjb25zdHJhaW50cy5kZXB0aElkZW50aWZpZXI7XG4gICAgY29uc3Qgc2V0QnVpbGRlciA9IGJ1aWxkVW5pcXVlQXJyYXlTZXRCdWlsZGVyKGNvbnN0cmFpbnRzKTtcbiAgICBjb25zdCBhcnJheUFyYiA9IG5ldyBBcnJheUFyYml0cmFyeV8xLkFycmF5QXJiaXRyYXJ5KGFyYiwgbWluTGVuZ3RoLCBtYXhHZW5lcmF0ZWRMZW5ndGgsIG1heExlbmd0aCwgZGVwdGhJZGVudGlmaWVyLCBzZXRCdWlsZGVyLCBbXSk7XG4gICAgaWYgKG1pbkxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIGFycmF5QXJiO1xuICAgIHJldHVybiBhcnJheUFyYi5maWx0ZXIoKHRhYikgPT4gdGFiLmxlbmd0aCA+PSBtaW5MZW5ndGgpO1xufVxuZXhwb3J0cy51bmlxdWVBcnJheSA9IHVuaXF1ZUFycmF5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnV1aWQgPSB2b2lkIDA7XG5jb25zdCB0dXBsZV8xID0gcmVxdWlyZShcIi4vdHVwbGVcIik7XG5jb25zdCBQYWRkZWROdW1iZXJBcmJpdHJhcnlCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2J1aWxkZXJzL1BhZGRlZE51bWJlckFyYml0cmFyeUJ1aWxkZXJcIik7XG5jb25zdCBQYWRkZWRFaWdodHNUb1V1aWRfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvbWFwcGVycy9QYWRkZWRFaWdodHNUb1V1aWRcIik7XG5mdW5jdGlvbiB1dWlkKCkge1xuICAgIGNvbnN0IHBhZGRlZCA9ICgwLCBQYWRkZWROdW1iZXJBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRQYWRkZWROdW1iZXJBcmJpdHJhcnkpKDAsIDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHNlY29uZFBhZGRlZCA9ICgwLCBQYWRkZWROdW1iZXJBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRQYWRkZWROdW1iZXJBcmJpdHJhcnkpKDB4MTAwMDAwMDAsIDB4NWZmZmZmZmYpO1xuICAgIGNvbnN0IHRoaXJkUGFkZGVkID0gKDAsIFBhZGRlZE51bWJlckFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZFBhZGRlZE51bWJlckFyYml0cmFyeSkoMHg4MDAwMDAwMCwgMHhiZmZmZmZmZik7XG4gICAgcmV0dXJuICgwLCB0dXBsZV8xLnR1cGxlKShwYWRkZWQsIHNlY29uZFBhZGRlZCwgdGhpcmRQYWRkZWQsIHBhZGRlZCkubWFwKFBhZGRlZEVpZ2h0c1RvVXVpZF8xLnBhZGRlZEVpZ2h0c1RvVXVpZE1hcHBlciwgUGFkZGVkRWlnaHRzVG9VdWlkXzEucGFkZGVkRWlnaHRzVG9VdWlkVW5tYXBwZXIpO1xufVxuZXhwb3J0cy51dWlkID0gdXVpZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51dWlkViA9IHZvaWQgMDtcbmNvbnN0IHR1cGxlXzEgPSByZXF1aXJlKFwiLi90dXBsZVwiKTtcbmNvbnN0IFBhZGRlZE51bWJlckFyYml0cmFyeUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvYnVpbGRlcnMvUGFkZGVkTnVtYmVyQXJiaXRyYXJ5QnVpbGRlclwiKTtcbmNvbnN0IFBhZGRlZEVpZ2h0c1RvVXVpZF8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9tYXBwZXJzL1BhZGRlZEVpZ2h0c1RvVXVpZFwiKTtcbmZ1bmN0aW9uIHV1aWRWKHZlcnNpb25OdW1iZXIpIHtcbiAgICBjb25zdCBwYWRkZWQgPSAoMCwgUGFkZGVkTnVtYmVyQXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkUGFkZGVkTnVtYmVyQXJiaXRyYXJ5KSgwLCAweGZmZmZmZmZmKTtcbiAgICBjb25zdCBvZmZzZXRTZWNvbmQgPSB2ZXJzaW9uTnVtYmVyICogMHgxMDAwMDAwMDtcbiAgICBjb25zdCBzZWNvbmRQYWRkZWQgPSAoMCwgUGFkZGVkTnVtYmVyQXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkUGFkZGVkTnVtYmVyQXJiaXRyYXJ5KShvZmZzZXRTZWNvbmQsIG9mZnNldFNlY29uZCArIDB4MGZmZmZmZmYpO1xuICAgIGNvbnN0IHRoaXJkUGFkZGVkID0gKDAsIFBhZGRlZE51bWJlckFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZFBhZGRlZE51bWJlckFyYml0cmFyeSkoMHg4MDAwMDAwMCwgMHhiZmZmZmZmZik7XG4gICAgcmV0dXJuICgwLCB0dXBsZV8xLnR1cGxlKShwYWRkZWQsIHNlY29uZFBhZGRlZCwgdGhpcmRQYWRkZWQsIHBhZGRlZCkubWFwKFBhZGRlZEVpZ2h0c1RvVXVpZF8xLnBhZGRlZEVpZ2h0c1RvVXVpZE1hcHBlciwgUGFkZGVkRWlnaHRzVG9VdWlkXzEucGFkZGVkRWlnaHRzVG9VdWlkVW5tYXBwZXIpO1xufVxuZXhwb3J0cy51dWlkViA9IHV1aWRWO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndlYkF1dGhvcml0eSA9IHZvaWQgMDtcbmNvbnN0IENoYXJhY3RlclJhbmdlQXJiaXRyYXJ5QnVpbGRlcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9idWlsZGVycy9DaGFyYWN0ZXJSYW5nZUFyYml0cmFyeUJ1aWxkZXJcIik7XG5jb25zdCBjb25zdGFudF8xID0gcmVxdWlyZShcIi4vY29uc3RhbnRcIik7XG5jb25zdCBkb21haW5fMSA9IHJlcXVpcmUoXCIuL2RvbWFpblwiKTtcbmNvbnN0IGlwVjRfMSA9IHJlcXVpcmUoXCIuL2lwVjRcIik7XG5jb25zdCBpcFY0RXh0ZW5kZWRfMSA9IHJlcXVpcmUoXCIuL2lwVjRFeHRlbmRlZFwiKTtcbmNvbnN0IGlwVjZfMSA9IHJlcXVpcmUoXCIuL2lwVjZcIik7XG5jb25zdCBuYXRfMSA9IHJlcXVpcmUoXCIuL25hdFwiKTtcbmNvbnN0IG9uZW9mXzEgPSByZXF1aXJlKFwiLi9vbmVvZlwiKTtcbmNvbnN0IG9wdGlvbl8xID0gcmVxdWlyZShcIi4vb3B0aW9uXCIpO1xuY29uc3Qgc3RyaW5nT2ZfMSA9IHJlcXVpcmUoXCIuL3N0cmluZ09mXCIpO1xuY29uc3QgdHVwbGVfMSA9IHJlcXVpcmUoXCIuL3R1cGxlXCIpO1xuZnVuY3Rpb24gaG9zdFVzZXJJbmZvKHNpemUpIHtcbiAgICBjb25zdCBvdGhlcnMgPSBbJy0nLCAnLicsICdfJywgJ34nLCAnIScsICckJywgJyYnLCBcIidcIiwgJygnLCAnKScsICcqJywgJysnLCAnLCcsICc7JywgJz0nLCAnOiddO1xuICAgIHJldHVybiAoMCwgc3RyaW5nT2ZfMS5zdHJpbmdPZikoKDAsIENoYXJhY3RlclJhbmdlQXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkQWxwaGFOdW1lcmljUGVyY2VudEFyYml0cmFyeSkob3RoZXJzKSwgeyBzaXplIH0pO1xufVxuZnVuY3Rpb24gdXNlckhvc3RQb3J0TWFwcGVyKFt1LCBoLCBwXSkge1xuICAgIHJldHVybiAodSA9PT0gbnVsbCA/ICcnIDogYCR7dX1AYCkgKyBoICsgKHAgPT09IG51bGwgPyAnJyA6IGA6JHtwfWApO1xufVxuZnVuY3Rpb24gdXNlckhvc3RQb3J0VW5tYXBwZXIodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IGF0UG9zaXRpb24gPSB2YWx1ZS5pbmRleE9mKCdAJyk7XG4gICAgY29uc3QgdXNlciA9IGF0UG9zaXRpb24gIT09IC0xID8gdmFsdWUuc3Vic3RyaW5nKDAsIGF0UG9zaXRpb24pIDogbnVsbDtcbiAgICBjb25zdCBwb3J0UmVnZXggPSAvOihcXGQrKSQvO1xuICAgIGNvbnN0IG0gPSBwb3J0UmVnZXguZXhlYyh2YWx1ZSk7XG4gICAgY29uc3QgcG9ydCA9IG0gIT09IG51bGwgPyBOdW1iZXIobVsxXSkgOiBudWxsO1xuICAgIGNvbnN0IGhvc3QgPSBtICE9PSBudWxsID8gdmFsdWUuc3Vic3RyaW5nKGF0UG9zaXRpb24gKyAxLCB2YWx1ZS5sZW5ndGggLSBtWzFdLmxlbmd0aCAtIDEpIDogdmFsdWUuc3Vic3RyaW5nKGF0UG9zaXRpb24gKyAxKTtcbiAgICByZXR1cm4gW3VzZXIsIGhvc3QsIHBvcnRdO1xufVxuZnVuY3Rpb24gYnJhY2tldGVkTWFwcGVyKHMpIHtcbiAgICByZXR1cm4gYFske3N9XWA7XG59XG5mdW5jdGlvbiBicmFja2V0ZWRVbm1hcHBlcih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8IHZhbHVlWzBdICE9PSAnWycgfHwgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gIT09ICddJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcoMSwgdmFsdWUubGVuZ3RoIC0gMSk7XG59XG5mdW5jdGlvbiB3ZWJBdXRob3JpdHkoY29uc3RyYWludHMpIHtcbiAgICBjb25zdCBjID0gY29uc3RyYWludHMgfHwge307XG4gICAgY29uc3Qgc2l6ZSA9IGMuc2l6ZTtcbiAgICBjb25zdCBob3N0bmFtZUFyYnMgPSBbKDAsIGRvbWFpbl8xLmRvbWFpbikoeyBzaXplIH0pXVxuICAgICAgICAuY29uY2F0KGMud2l0aElQdjQgPT09IHRydWUgPyBbKDAsIGlwVjRfMS5pcFY0KSgpXSA6IFtdKVxuICAgICAgICAuY29uY2F0KGMud2l0aElQdjYgPT09IHRydWUgPyBbKDAsIGlwVjZfMS5pcFY2KSgpLm1hcChicmFja2V0ZWRNYXBwZXIsIGJyYWNrZXRlZFVubWFwcGVyKV0gOiBbXSlcbiAgICAgICAgLmNvbmNhdChjLndpdGhJUHY0RXh0ZW5kZWQgPT09IHRydWUgPyBbKDAsIGlwVjRFeHRlbmRlZF8xLmlwVjRFeHRlbmRlZCkoKV0gOiBbXSk7XG4gICAgcmV0dXJuICgwLCB0dXBsZV8xLnR1cGxlKShjLndpdGhVc2VySW5mbyA9PT0gdHJ1ZSA/ICgwLCBvcHRpb25fMS5vcHRpb24pKGhvc3RVc2VySW5mbyhzaXplKSkgOiAoMCwgY29uc3RhbnRfMS5jb25zdGFudCkobnVsbCksICgwLCBvbmVvZl8xLm9uZW9mKSguLi5ob3N0bmFtZUFyYnMpLCBjLndpdGhQb3J0ID09PSB0cnVlID8gKDAsIG9wdGlvbl8xLm9wdGlvbikoKDAsIG5hdF8xLm5hdCkoNjU1MzUpKSA6ICgwLCBjb25zdGFudF8xLmNvbnN0YW50KShudWxsKSkubWFwKHVzZXJIb3N0UG9ydE1hcHBlciwgdXNlckhvc3RQb3J0VW5tYXBwZXIpO1xufVxuZXhwb3J0cy53ZWJBdXRob3JpdHkgPSB3ZWJBdXRob3JpdHk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMud2ViRnJhZ21lbnRzID0gdm9pZCAwO1xuY29uc3QgVXJpUXVlcnlPckZyYWdtZW50QXJiaXRyYXJ5QnVpbGRlcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9idWlsZGVycy9VcmlRdWVyeU9yRnJhZ21lbnRBcmJpdHJhcnlCdWlsZGVyXCIpO1xuZnVuY3Rpb24gd2ViRnJhZ21lbnRzKGNvbnN0cmFpbnRzID0ge30pIHtcbiAgICByZXR1cm4gKDAsIFVyaVF1ZXJ5T3JGcmFnbWVudEFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZFVyaVF1ZXJ5T3JGcmFnbWVudEFyYml0cmFyeSkoY29uc3RyYWludHMuc2l6ZSk7XG59XG5leHBvcnRzLndlYkZyYWdtZW50cyA9IHdlYkZyYWdtZW50cztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy53ZWJRdWVyeVBhcmFtZXRlcnMgPSB2b2lkIDA7XG5jb25zdCBVcmlRdWVyeU9yRnJhZ21lbnRBcmJpdHJhcnlCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2J1aWxkZXJzL1VyaVF1ZXJ5T3JGcmFnbWVudEFyYml0cmFyeUJ1aWxkZXJcIik7XG5mdW5jdGlvbiB3ZWJRdWVyeVBhcmFtZXRlcnMoY29uc3RyYWludHMgPSB7fSkge1xuICAgIHJldHVybiAoMCwgVXJpUXVlcnlPckZyYWdtZW50QXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkVXJpUXVlcnlPckZyYWdtZW50QXJiaXRyYXJ5KShjb25zdHJhaW50cy5zaXplKTtcbn1cbmV4cG9ydHMud2ViUXVlcnlQYXJhbWV0ZXJzID0gd2ViUXVlcnlQYXJhbWV0ZXJzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndlYlNlZ21lbnQgPSB2b2lkIDA7XG5jb25zdCBDaGFyYWN0ZXJSYW5nZUFyYml0cmFyeUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvYnVpbGRlcnMvQ2hhcmFjdGVyUmFuZ2VBcmJpdHJhcnlCdWlsZGVyXCIpO1xuY29uc3Qgc3RyaW5nT2ZfMSA9IHJlcXVpcmUoXCIuL3N0cmluZ09mXCIpO1xuZnVuY3Rpb24gd2ViU2VnbWVudChjb25zdHJhaW50cyA9IHt9KSB7XG4gICAgY29uc3Qgb3RoZXJzID0gWyctJywgJy4nLCAnXycsICd+JywgJyEnLCAnJCcsICcmJywgXCInXCIsICcoJywgJyknLCAnKicsICcrJywgJywnLCAnOycsICc9JywgJzonLCAnQCddO1xuICAgIHJldHVybiAoMCwgc3RyaW5nT2ZfMS5zdHJpbmdPZikoKDAsIENoYXJhY3RlclJhbmdlQXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkQWxwaGFOdW1lcmljUGVyY2VudEFyYml0cmFyeSkob3RoZXJzKSwgeyBzaXplOiBjb25zdHJhaW50cy5zaXplIH0pO1xufVxuZXhwb3J0cy53ZWJTZWdtZW50ID0gd2ViU2VnbWVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy53ZWJVcmwgPSB2b2lkIDA7XG5jb25zdCBjb25zdGFudEZyb21fMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50RnJvbVwiKTtcbmNvbnN0IGNvbnN0YW50XzEgPSByZXF1aXJlKFwiLi9jb25zdGFudFwiKTtcbmNvbnN0IG9wdGlvbl8xID0gcmVxdWlyZShcIi4vb3B0aW9uXCIpO1xuY29uc3QgdHVwbGVfMSA9IHJlcXVpcmUoXCIuL3R1cGxlXCIpO1xuY29uc3Qgd2ViUXVlcnlQYXJhbWV0ZXJzXzEgPSByZXF1aXJlKFwiLi93ZWJRdWVyeVBhcmFtZXRlcnNcIik7XG5jb25zdCB3ZWJGcmFnbWVudHNfMSA9IHJlcXVpcmUoXCIuL3dlYkZyYWdtZW50c1wiKTtcbmNvbnN0IHdlYkF1dGhvcml0eV8xID0gcmVxdWlyZShcIi4vd2ViQXV0aG9yaXR5XCIpO1xuY29uc3QgUGFydHNUb1VybF8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9tYXBwZXJzL1BhcnRzVG9VcmxcIik7XG5jb25zdCBNYXhMZW5ndGhGcm9tTWluTGVuZ3RoXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2hlbHBlcnMvTWF4TGVuZ3RoRnJvbU1pbkxlbmd0aFwiKTtcbmNvbnN0IFVyaVBhdGhBcmJpdHJhcnlCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2J1aWxkZXJzL1VyaVBhdGhBcmJpdHJhcnlCdWlsZGVyXCIpO1xuZnVuY3Rpb24gd2ViVXJsKGNvbnN0cmFpbnRzKSB7XG4gICAgY29uc3QgYyA9IGNvbnN0cmFpbnRzIHx8IHt9O1xuICAgIGNvbnN0IHJlc29sdmVkU2l6ZSA9ICgwLCBNYXhMZW5ndGhGcm9tTWluTGVuZ3RoXzEucmVzb2x2ZVNpemUpKGMuc2l6ZSk7XG4gICAgY29uc3QgcmVzb2x2ZWRBdXRob3JpdHlTZXR0aW5nc1NpemUgPSBjLmF1dGhvcml0eVNldHRpbmdzICE9PSB1bmRlZmluZWQgJiYgYy5hdXRob3JpdHlTZXR0aW5ncy5zaXplICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyAoMCwgTWF4TGVuZ3RoRnJvbU1pbkxlbmd0aF8xLnJlbGF0aXZlU2l6ZVRvU2l6ZSkoYy5hdXRob3JpdHlTZXR0aW5ncy5zaXplLCByZXNvbHZlZFNpemUpXG4gICAgICAgIDogcmVzb2x2ZWRTaXplO1xuICAgIGNvbnN0IHJlc29sdmVkQXV0aG9yaXR5U2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGMuYXV0aG9yaXR5U2V0dGluZ3MpLCB7IHNpemU6IHJlc29sdmVkQXV0aG9yaXR5U2V0dGluZ3NTaXplIH0pO1xuICAgIGNvbnN0IHZhbGlkU2NoZW1lcyA9IGMudmFsaWRTY2hlbWVzIHx8IFsnaHR0cCcsICdodHRwcyddO1xuICAgIGNvbnN0IHNjaGVtZUFyYiA9ICgwLCBjb25zdGFudEZyb21fMS5jb25zdGFudEZyb20pKC4uLnZhbGlkU2NoZW1lcyk7XG4gICAgY29uc3QgYXV0aG9yaXR5QXJiID0gKDAsIHdlYkF1dGhvcml0eV8xLndlYkF1dGhvcml0eSkocmVzb2x2ZWRBdXRob3JpdHlTZXR0aW5ncyk7XG4gICAgY29uc3QgcGF0aEFyYiA9ICgwLCBVcmlQYXRoQXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkVXJpUGF0aEFyYml0cmFyeSkocmVzb2x2ZWRTaXplKTtcbiAgICByZXR1cm4gKDAsIHR1cGxlXzEudHVwbGUpKHNjaGVtZUFyYiwgYXV0aG9yaXR5QXJiLCBwYXRoQXJiLCBjLndpdGhRdWVyeVBhcmFtZXRlcnMgPT09IHRydWUgPyAoMCwgb3B0aW9uXzEub3B0aW9uKSgoMCwgd2ViUXVlcnlQYXJhbWV0ZXJzXzEud2ViUXVlcnlQYXJhbWV0ZXJzKSh7IHNpemU6IHJlc29sdmVkU2l6ZSB9KSkgOiAoMCwgY29uc3RhbnRfMS5jb25zdGFudCkobnVsbCksIGMud2l0aEZyYWdtZW50cyA9PT0gdHJ1ZSA/ICgwLCBvcHRpb25fMS5vcHRpb24pKCgwLCB3ZWJGcmFnbWVudHNfMS53ZWJGcmFnbWVudHMpKHsgc2l6ZTogcmVzb2x2ZWRTaXplIH0pKSA6ICgwLCBjb25zdGFudF8xLmNvbnN0YW50KShudWxsKSkubWFwKFBhcnRzVG9VcmxfMS5wYXJ0c1RvVXJsTWFwcGVyLCBQYXJ0c1RvVXJsXzEucGFydHNUb1VybFVubWFwcGVyKTtcbn1cbmV4cG9ydHMud2ViVXJsID0gd2ViVXJsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzc2VydElzQXJiaXRyYXJ5ID0gZXhwb3J0cy5pc0FyYml0cmFyeSA9IGV4cG9ydHMuQXJiaXRyYXJ5ID0gdm9pZCAwO1xuY29uc3QgU3RyZWFtXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vc3RyZWFtL1N0cmVhbVwiKTtcbmNvbnN0IHN5bWJvbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9zeW1ib2xzXCIpO1xuY29uc3QgVmFsdWVfMSA9IHJlcXVpcmUoXCIuL1ZhbHVlXCIpO1xuY2xhc3MgQXJiaXRyYXJ5IHtcbiAgICBmaWx0ZXIocmVmaW5lbWVudCkge1xuICAgICAgICByZXR1cm4gbmV3IEZpbHRlckFyYml0cmFyeSh0aGlzLCByZWZpbmVtZW50KTtcbiAgICB9XG4gICAgbWFwKG1hcHBlciwgdW5tYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXBBcmJpdHJhcnkodGhpcywgbWFwcGVyLCB1bm1hcHBlcik7XG4gICAgfVxuICAgIGNoYWluKGNoYWluZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFpbkFyYml0cmFyeSh0aGlzLCBjaGFpbmVyKTtcbiAgICB9XG4gICAgbm9TaHJpbmsoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9TaHJpbmtBcmJpdHJhcnkodGhpcyk7XG4gICAgfVxuICAgIG5vQmlhcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb0JpYXNBcmJpdHJhcnkodGhpcyk7XG4gICAgfVxufVxuZXhwb3J0cy5BcmJpdHJhcnkgPSBBcmJpdHJhcnk7XG5jbGFzcyBDaGFpbkFyYml0cmFyeSBleHRlbmRzIEFyYml0cmFyeSB7XG4gICAgY29uc3RydWN0b3IoYXJiLCBjaGFpbmVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXJiID0gYXJiO1xuICAgICAgICB0aGlzLmNoYWluZXIgPSBjaGFpbmVyO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZE1ybmcgPSBtcm5nLmNsb25lKCk7XG4gICAgICAgIGNvbnN0IHNyYyA9IHRoaXMuYXJiLmdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpO1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUNoYWluZXIoc3JjLCBtcm5nLCBjbG9uZWRNcm5nLCBiaWFzRmFjdG9yKTtcbiAgICB9XG4gICAgY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzaHJpbmsodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTYWZlQ29udGV4dChjb250ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuICghY29udGV4dC5zdG9wcGVkRm9yT3JpZ2luYWxcbiAgICAgICAgICAgICAgICA/IHRoaXMuYXJiXG4gICAgICAgICAgICAgICAgICAgIC5zaHJpbmsoY29udGV4dC5vcmlnaW5hbFZhbHVlLCBjb250ZXh0Lm9yaWdpbmFsQ29udGV4dClcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgodikgPT4gdGhpcy52YWx1ZUNoYWluZXIodiwgY29udGV4dC5jbG9uZWRNcm5nLmNsb25lKCksIGNvbnRleHQuY2xvbmVkTXJuZywgY29udGV4dC5vcmlnaW5hbEJpYXMpKVxuICAgICAgICAgICAgICAgIDogU3RyZWFtXzEuU3RyZWFtLm5pbCgpKS5qb2luKGNvbnRleHQuY2hhaW5lZEFyYml0cmFyeS5zaHJpbmsodmFsdWUsIGNvbnRleHQuY2hhaW5lZENvbnRleHQpLm1hcCgoZHN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Q29udGV4dCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29udGV4dCksIHsgY2hhaW5lZENvbnRleHQ6IGRzdC5jb250ZXh0LCBzdG9wcGVkRm9yT3JpZ2luYWw6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZV8xLlZhbHVlKGRzdC52YWx1ZV8sIG5ld0NvbnRleHQpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJlYW1fMS5TdHJlYW0ubmlsKCk7XG4gICAgfVxuICAgIHZhbHVlQ2hhaW5lcih2LCBnZW5lcmF0ZU1ybmcsIGNsb25lZE1ybmcsIGJpYXNGYWN0b3IpIHtcbiAgICAgICAgY29uc3QgY2hhaW5lZEFyYml0cmFyeSA9IHRoaXMuY2hhaW5lcih2LnZhbHVlXyk7XG4gICAgICAgIGNvbnN0IGRzdCA9IGNoYWluZWRBcmJpdHJhcnkuZ2VuZXJhdGUoZ2VuZXJhdGVNcm5nLCBiaWFzRmFjdG9yKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsQmlhczogYmlhc0ZhY3RvcixcbiAgICAgICAgICAgIG9yaWdpbmFsVmFsdWU6IHYudmFsdWVfLFxuICAgICAgICAgICAgb3JpZ2luYWxDb250ZXh0OiB2LmNvbnRleHQsXG4gICAgICAgICAgICBzdG9wcGVkRm9yT3JpZ2luYWw6IGZhbHNlLFxuICAgICAgICAgICAgY2hhaW5lZEFyYml0cmFyeSxcbiAgICAgICAgICAgIGNoYWluZWRDb250ZXh0OiBkc3QuY29udGV4dCxcbiAgICAgICAgICAgIGNsb25lZE1ybmcsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWVfMS5WYWx1ZShkc3QudmFsdWVfLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaXNTYWZlQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAoY29udGV4dCAhPSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICdvcmlnaW5hbEJpYXMnIGluIGNvbnRleHQgJiZcbiAgICAgICAgICAgICdvcmlnaW5hbFZhbHVlJyBpbiBjb250ZXh0ICYmXG4gICAgICAgICAgICAnb3JpZ2luYWxDb250ZXh0JyBpbiBjb250ZXh0ICYmXG4gICAgICAgICAgICAnc3RvcHBlZEZvck9yaWdpbmFsJyBpbiBjb250ZXh0ICYmXG4gICAgICAgICAgICAnY2hhaW5lZEFyYml0cmFyeScgaW4gY29udGV4dCAmJlxuICAgICAgICAgICAgJ2NoYWluZWRDb250ZXh0JyBpbiBjb250ZXh0ICYmXG4gICAgICAgICAgICAnY2xvbmVkTXJuZycgaW4gY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgTWFwQXJiaXRyYXJ5IGV4dGVuZHMgQXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmIsIG1hcHBlciwgdW5tYXBwZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcmIgPSBhcmI7XG4gICAgICAgIHRoaXMubWFwcGVyID0gbWFwcGVyO1xuICAgICAgICB0aGlzLnVubWFwcGVyID0gdW5tYXBwZXI7XG4gICAgICAgIHRoaXMuYmluZFZhbHVlTWFwcGVyID0gdGhpcy52YWx1ZU1hcHBlci5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKSB7XG4gICAgICAgIGNvbnN0IGcgPSB0aGlzLmFyYi5nZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVNYXBwZXIoZyk7XG4gICAgfVxuICAgIGNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnVubWFwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5tYXBwZWQgPSB0aGlzLnVubWFwcGVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcmIuY2FuU2hyaW5rV2l0aG91dENvbnRleHQodW5tYXBwZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzaHJpbmsodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTYWZlQ29udGV4dChjb250ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJiLnNocmluayhjb250ZXh0Lm9yaWdpbmFsVmFsdWUsIGNvbnRleHQub3JpZ2luYWxDb250ZXh0KS5tYXAodGhpcy5iaW5kVmFsdWVNYXBwZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVubWFwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHVubWFwcGVkID0gdGhpcy51bm1hcHBlcih2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcmIuc2hyaW5rKHVubWFwcGVkLCB1bmRlZmluZWQpLm1hcCh0aGlzLmJpbmRWYWx1ZU1hcHBlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmVhbV8xLlN0cmVhbS5uaWwoKTtcbiAgICB9XG4gICAgbWFwcGVyV2l0aENsb25lSWZOZWVkZWQodikge1xuICAgICAgICBjb25zdCBzb3VyY2VWYWx1ZSA9IHYudmFsdWU7XG4gICAgICAgIGNvbnN0IG1hcHBlZFZhbHVlID0gdGhpcy5tYXBwZXIoc291cmNlVmFsdWUpO1xuICAgICAgICBpZiAodi5oYXNUb0JlQ2xvbmVkICYmXG4gICAgICAgICAgICAoKHR5cGVvZiBtYXBwZWRWYWx1ZSA9PT0gJ29iamVjdCcgJiYgbWFwcGVkVmFsdWUgIT09IG51bGwpIHx8IHR5cGVvZiBtYXBwZWRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykgJiZcbiAgICAgICAgICAgIE9iamVjdC5pc0V4dGVuc2libGUobWFwcGVkVmFsdWUpICYmXG4gICAgICAgICAgICAhKDAsIHN5bWJvbHNfMS5oYXNDbG9uZU1ldGhvZCkobWFwcGVkVmFsdWUpKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWFwcGVkVmFsdWUsIHN5bWJvbHNfMS5jbG9uZU1ldGhvZCwgeyBnZXQ6ICgpID0+ICgpID0+IHRoaXMubWFwcGVyV2l0aENsb25lSWZOZWVkZWQodilbMF0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFttYXBwZWRWYWx1ZSwgc291cmNlVmFsdWVdO1xuICAgIH1cbiAgICB2YWx1ZU1hcHBlcih2KSB7XG4gICAgICAgIGNvbnN0IFttYXBwZWRWYWx1ZSwgc291cmNlVmFsdWVdID0gdGhpcy5tYXBwZXJXaXRoQ2xvbmVJZk5lZWRlZCh2KTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHsgb3JpZ2luYWxWYWx1ZTogc291cmNlVmFsdWUsIG9yaWdpbmFsQ29udGV4dDogdi5jb250ZXh0IH07XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWVfMS5WYWx1ZShtYXBwZWRWYWx1ZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGlzU2FmZUNvbnRleHQoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gKGNvbnRleHQgIT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbnRleHQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAnb3JpZ2luYWxWYWx1ZScgaW4gY29udGV4dCAmJlxuICAgICAgICAgICAgJ29yaWdpbmFsQ29udGV4dCcgaW4gY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgRmlsdGVyQXJiaXRyYXJ5IGV4dGVuZHMgQXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmIsIHJlZmluZW1lbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcmIgPSBhcmI7XG4gICAgICAgIHRoaXMucmVmaW5lbWVudCA9IHJlZmluZW1lbnQ7XG4gICAgICAgIHRoaXMuYmluZFJlZmluZW1lbnRPblZhbHVlID0gdGhpcy5yZWZpbmVtZW50T25WYWx1ZS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBnID0gdGhpcy5hcmIuZ2VuZXJhdGUobXJuZywgYmlhc0ZhY3Rvcik7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWZpbmVtZW50T25WYWx1ZShnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyYi5jYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZSkgJiYgdGhpcy5yZWZpbmVtZW50KHZhbHVlKTtcbiAgICB9XG4gICAgc2hyaW5rKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyYi5zaHJpbmsodmFsdWUsIGNvbnRleHQpLmZpbHRlcih0aGlzLmJpbmRSZWZpbmVtZW50T25WYWx1ZSk7XG4gICAgfVxuICAgIHJlZmluZW1lbnRPblZhbHVlKHYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmaW5lbWVudCh2LnZhbHVlKTtcbiAgICB9XG59XG5jbGFzcyBOb1Nocmlua0FyYml0cmFyeSBleHRlbmRzIEFyYml0cmFyeSB7XG4gICAgY29uc3RydWN0b3IoYXJiKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXJiID0gYXJiO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyYi5nZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKTtcbiAgICB9XG4gICAgY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJiLmNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlKTtcbiAgICB9XG4gICAgc2hyaW5rKF92YWx1ZSwgX2NvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFN0cmVhbV8xLlN0cmVhbS5uaWwoKTtcbiAgICB9XG4gICAgbm9TaHJpbmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmNsYXNzIE5vQmlhc0FyYml0cmFyeSBleHRlbmRzIEFyYml0cmFyeSB7XG4gICAgY29uc3RydWN0b3IoYXJiKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXJiID0gYXJiO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBfYmlhc0ZhY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmIuZ2VuZXJhdGUobXJuZywgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJiLmNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlKTtcbiAgICB9XG4gICAgc2hyaW5rKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyYi5zaHJpbmsodmFsdWUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBub0JpYXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQXJiaXRyYXJ5KGluc3RhbmNlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgaW5zdGFuY2UgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGluc3RhbmNlICE9PSBudWxsICYmXG4gICAgICAgICdnZW5lcmF0ZScgaW4gaW5zdGFuY2UgJiZcbiAgICAgICAgJ3NocmluaycgaW4gaW5zdGFuY2UgJiZcbiAgICAgICAgJ2NhblNocmlua1dpdGhvdXRDb250ZXh0JyBpbiBpbnN0YW5jZSk7XG59XG5leHBvcnRzLmlzQXJiaXRyYXJ5ID0gaXNBcmJpdHJhcnk7XG5mdW5jdGlvbiBhc3NlcnRJc0FyYml0cmFyeShpbnN0YW5jZSkge1xuICAgIGlmICghaXNBcmJpdHJhcnkoaW5zdGFuY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB2YWx1ZSByZWNlaXZlZDogbm90IGFuIGluc3RhbmNlIG9mIEFyYml0cmFyeScpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0SXNBcmJpdHJhcnkgPSBhc3NlcnRJc0FyYml0cmFyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYWx1ZSA9IHZvaWQgMDtcbmNvbnN0IHN5bWJvbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9zeW1ib2xzXCIpO1xuY2xhc3MgVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlXywgY29udGV4dCwgY3VzdG9tR2V0VmFsdWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy52YWx1ZV8gPSB2YWx1ZV87XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuaGFzVG9CZUNsb25lZCA9IGN1c3RvbUdldFZhbHVlICE9PSB1bmRlZmluZWQgfHwgKDAsIHN5bWJvbHNfMS5oYXNDbG9uZU1ldGhvZCkodmFsdWVfKTtcbiAgICAgICAgdGhpcy5yZWFkT25jZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5oYXNUb0JlQ2xvbmVkKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3ZhbHVlJywgeyBnZXQ6IGN1c3RvbUdldFZhbHVlICE9PSB1bmRlZmluZWQgPyBjdXN0b21HZXRWYWx1ZSA6IHRoaXMuZ2V0VmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWVfO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFZhbHVlKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNUb0JlQ2xvbmVkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVhZE9uY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRPbmNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZV87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZV9bc3ltYm9sc18xLmNsb25lTWV0aG9kXSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlXztcbiAgICB9XG59XG5leHBvcnRzLlZhbHVlID0gVmFsdWU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2NoZWR1bGVkTW9kZWxSdW4gPSBleHBvcnRzLmFzeW5jTW9kZWxSdW4gPSBleHBvcnRzLm1vZGVsUnVuID0gdm9pZCAwO1xuY29uc3QgU2NoZWR1bGVkQ29tbWFuZF8xID0gcmVxdWlyZShcIi4vY29tbWFuZHMvU2NoZWR1bGVkQ29tbWFuZFwiKTtcbmNvbnN0IGdlbmVyaWNNb2RlbFJ1biA9IChzLCBjbWRzLCBpbml0aWFsVmFsdWUsIHJ1bkNtZCwgdGhlbikgPT4ge1xuICAgIHJldHVybiBzLnRoZW4oKG8pID0+IHtcbiAgICAgICAgY29uc3QgeyBtb2RlbCwgcmVhbCB9ID0gbztcbiAgICAgICAgbGV0IHN0YXRlID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY21kcykge1xuICAgICAgICAgICAgc3RhdGUgPSB0aGVuKHN0YXRlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bkNtZChjLCBtb2RlbCwgcmVhbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSk7XG59O1xuY29uc3QgaW50ZXJuYWxNb2RlbFJ1biA9IChzLCBjbWRzKSA9PiB7XG4gICAgY29uc3QgdGhlbiA9IChfcCwgYykgPT4gYygpO1xuICAgIGNvbnN0IHNldHVwUHJvZHVjZXIgPSB7XG4gICAgICAgIHRoZW46IChmdW4pID0+IHtcbiAgICAgICAgICAgIGZ1bihzKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGNvbnN0IHJ1blN5bmMgPSAoY21kLCBtLCByKSA9PiB7XG4gICAgICAgIGlmIChjbWQuY2hlY2sobSkpXG4gICAgICAgICAgICBjbWQucnVuKG0sIHIpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgcmV0dXJuIGdlbmVyaWNNb2RlbFJ1bihzZXR1cFByb2R1Y2VyLCBjbWRzLCB1bmRlZmluZWQsIHJ1blN5bmMsIHRoZW4pO1xufTtcbmNvbnN0IGlzQXN5bmNTZXR1cCA9IChzKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiBzLnRoZW4gPT09ICdmdW5jdGlvbic7XG59O1xuY29uc3QgaW50ZXJuYWxBc3luY01vZGVsUnVuID0gYXN5bmMgKHMsIGNtZHMsIGRlZmF1bHRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkpID0+IHtcbiAgICBjb25zdCB0aGVuID0gKHAsIGMpID0+IHAudGhlbihjKTtcbiAgICBjb25zdCBzZXR1cFByb2R1Y2VyID0ge1xuICAgICAgICB0aGVuOiAoZnVuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvdXQgPSBzKCk7XG4gICAgICAgICAgICBpZiAoaXNBc3luY1NldHVwKG91dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dC50aGVuKGZ1bik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bihvdXQpO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgY29uc3QgcnVuQXN5bmMgPSBhc3luYyAoY21kLCBtLCByKSA9PiB7XG4gICAgICAgIGlmIChhd2FpdCBjbWQuY2hlY2sobSkpXG4gICAgICAgICAgICBhd2FpdCBjbWQucnVuKG0sIHIpO1xuICAgIH07XG4gICAgcmV0dXJuIGF3YWl0IGdlbmVyaWNNb2RlbFJ1bihzZXR1cFByb2R1Y2VyLCBjbWRzLCBkZWZhdWx0UHJvbWlzZSwgcnVuQXN5bmMsIHRoZW4pO1xufTtcbmZ1bmN0aW9uIG1vZGVsUnVuKHMsIGNtZHMpIHtcbiAgICBpbnRlcm5hbE1vZGVsUnVuKHMsIGNtZHMpO1xufVxuZXhwb3J0cy5tb2RlbFJ1biA9IG1vZGVsUnVuO1xuYXN5bmMgZnVuY3Rpb24gYXN5bmNNb2RlbFJ1bihzLCBjbWRzKSB7XG4gICAgYXdhaXQgaW50ZXJuYWxBc3luY01vZGVsUnVuKHMsIGNtZHMpO1xufVxuZXhwb3J0cy5hc3luY01vZGVsUnVuID0gYXN5bmNNb2RlbFJ1bjtcbmFzeW5jIGZ1bmN0aW9uIHNjaGVkdWxlZE1vZGVsUnVuKHNjaGVkdWxlciwgcywgY21kcykge1xuICAgIGNvbnN0IHNjaGVkdWxlZENvbW1hbmRzID0gKDAsIFNjaGVkdWxlZENvbW1hbmRfMS5zY2hlZHVsZUNvbW1hbmRzKShzY2hlZHVsZXIsIGNtZHMpO1xuICAgIGNvbnN0IG91dCA9IGludGVybmFsQXN5bmNNb2RlbFJ1bihzLCBzY2hlZHVsZWRDb21tYW5kcywgc2NoZWR1bGVyLnNjaGVkdWxlKFByb21pc2UucmVzb2x2ZSgpLCAnc3RhcnRNb2RlbCcpKTtcbiAgICBhd2FpdCBzY2hlZHVsZXIud2FpdEFsbCgpO1xuICAgIGF3YWl0IG91dDtcbn1cbmV4cG9ydHMuc2NoZWR1bGVkTW9kZWxSdW4gPSBzY2hlZHVsZWRNb2RlbFJ1bjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZXBsYXlQYXRoID0gdm9pZCAwO1xuY2xhc3MgUmVwbGF5UGF0aCB7XG4gICAgc3RhdGljIHBhcnNlKHJlcGxheVBhdGhTdHIpIHtcbiAgICAgICAgY29uc3QgW3NlcmlhbGl6ZWRDb3VudCwgc2VyaWFsaXplZENoYW5nZXNdID0gcmVwbGF5UGF0aFN0ci5zcGxpdCgnOicpO1xuICAgICAgICBjb25zdCBjb3VudHMgPSB0aGlzLnBhcnNlQ291bnRzKHNlcmlhbGl6ZWRDb3VudCk7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLnBhcnNlQ2hhbmdlcyhzZXJpYWxpemVkQ2hhbmdlcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2NjdXJlbmNlcyhjb3VudHMsIGNoYW5nZXMpO1xuICAgIH1cbiAgICBzdGF0aWMgc3RyaW5naWZ5KHJlcGxheVBhdGgpIHtcbiAgICAgICAgY29uc3Qgb2NjdXJlbmNlcyA9IHRoaXMuY291bnRPY2N1cmVuY2VzKHJlcGxheVBhdGgpO1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkQ291bnQgPSB0aGlzLnN0cmluZ2lmeUNvdW50cyhvY2N1cmVuY2VzKTtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZENoYW5nZXMgPSB0aGlzLnN0cmluZ2lmeUNoYW5nZXMob2NjdXJlbmNlcyk7XG4gICAgICAgIHJldHVybiBgJHtzZXJpYWxpemVkQ291bnR9OiR7c2VyaWFsaXplZENoYW5nZXN9YDtcbiAgICB9XG4gICAgc3RhdGljIGludFRvQjY0KG4pIHtcbiAgICAgICAgaWYgKG4gPCAyNilcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG4gKyA2NSk7XG4gICAgICAgIGlmIChuIDwgNTIpXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuICsgOTcgLSAyNik7XG4gICAgICAgIGlmIChuIDwgNjIpXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuICsgNDggLSA1Mik7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG4gPT09IDYyID8gNDMgOiA0Nyk7XG4gICAgfVxuICAgIHN0YXRpYyBiNjRUb0ludChjKSB7XG4gICAgICAgIGlmIChjID49ICdhJylcbiAgICAgICAgICAgIHJldHVybiBjLmNoYXJDb2RlQXQoMCkgLSA5NyArIDI2O1xuICAgICAgICBpZiAoYyA+PSAnQScpXG4gICAgICAgICAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApIC0gNjU7XG4gICAgICAgIGlmIChjID49ICcwJylcbiAgICAgICAgICAgIHJldHVybiBjLmNoYXJDb2RlQXQoMCkgLSA0OCArIDUyO1xuICAgICAgICByZXR1cm4gYyA9PT0gJysnID8gNjIgOiA2MztcbiAgICB9XG4gICAgc3RhdGljIGNvdW50T2NjdXJlbmNlcyhyZXBsYXlQYXRoKSB7XG4gICAgICAgIHJldHVybiByZXBsYXlQYXRoLnJlZHVjZSgoY291bnRzLCBjdXIpID0+IHtcbiAgICAgICAgICAgIGlmIChjb3VudHMubGVuZ3RoID09PSAwIHx8IGNvdW50c1tjb3VudHMubGVuZ3RoIC0gMV0uY291bnQgPT09IDY0IHx8IGNvdW50c1tjb3VudHMubGVuZ3RoIC0gMV0udmFsdWUgIT09IGN1cilcbiAgICAgICAgICAgICAgICBjb3VudHMucHVzaCh7IHZhbHVlOiBjdXIsIGNvdW50OiAxIH0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvdW50c1tjb3VudHMubGVuZ3RoIC0gMV0uY291bnQgKz0gMTtcbiAgICAgICAgICAgIHJldHVybiBjb3VudHM7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlT2NjdXJlbmNlcyhjb3VudHMsIGNoYW5nZXMpIHtcbiAgICAgICAgY29uc3QgcmVwbGF5UGF0aCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggIT09IGNvdW50cy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IGNvdW50c1tpZHhdO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjaGFuZ2VzW2lkeF07XG4gICAgICAgICAgICBmb3IgKGxldCBudW0gPSAwOyBudW0gIT09IGNvdW50OyArK251bSlcbiAgICAgICAgICAgICAgICByZXBsYXlQYXRoLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXBsYXlQYXRoO1xuICAgIH1cbiAgICBzdGF0aWMgc3RyaW5naWZ5Q2hhbmdlcyhvY2N1cmVuY2VzKSB7XG4gICAgICAgIGxldCBzZXJpYWxpemVkQ2hhbmdlcyA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBvY2N1cmVuY2VzLmxlbmd0aDsgaWR4ICs9IDYpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZXNJbnQgPSBvY2N1cmVuY2VzXG4gICAgICAgICAgICAgICAgLnNsaWNlKGlkeCwgaWR4ICsgNilcbiAgICAgICAgICAgICAgICAucmVkdWNlUmlnaHQoKHByZXYsIGN1cikgPT4gcHJldiAqIDIgKyAoY3VyLnZhbHVlID8gMSA6IDApLCAwKTtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRDaGFuZ2VzICs9IHRoaXMuaW50VG9CNjQoY2hhbmdlc0ludCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWRDaGFuZ2VzO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2VDaGFuZ2VzKHNlcmlhbGl6ZWRDaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZXNJbnQgPSBzZXJpYWxpemVkQ2hhbmdlcy5zcGxpdCgnJykubWFwKChjKSA9PiB0aGlzLmI2NFRvSW50KGMpKTtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggIT09IGNoYW5nZXNJbnQubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSBjaGFuZ2VzSW50W2lkeF07XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gMDsgbiAhPT0gNjsgKytuLCBjdXJyZW50ID4+PSAxKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGN1cnJlbnQgJSAyID09PSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlcztcbiAgICB9XG4gICAgc3RhdGljIHN0cmluZ2lmeUNvdW50cyhvY2N1cmVuY2VzKSB7XG4gICAgICAgIHJldHVybiBvY2N1cmVuY2VzLm1hcCgoeyBjb3VudCB9KSA9PiB0aGlzLmludFRvQjY0KGNvdW50IC0gMSkpLmpvaW4oJycpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2VDb3VudHMoc2VyaWFsaXplZENvdW50KSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkQ291bnQuc3BsaXQoJycpLm1hcCgoYykgPT4gdGhpcy5iNjRUb0ludChjKSArIDEpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVwbGF5UGF0aCA9IFJlcGxheVBhdGg7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tbWFuZFdyYXBwZXIgPSB2b2lkIDA7XG5jb25zdCBzdHJpbmdpZnlfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9zdHJpbmdpZnlcIik7XG5jb25zdCBzeW1ib2xzXzEgPSByZXF1aXJlKFwiLi4vLi4vc3ltYm9sc1wiKTtcbmNsYXNzIENvbW1hbmRXcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjbWQpIHtcbiAgICAgICAgdGhpcy5jbWQgPSBjbWQ7XG4gICAgICAgIHRoaXMuaGFzUmFuID0gZmFsc2U7XG4gICAgICAgIGlmICgoMCwgc3RyaW5naWZ5XzEuaGFzVG9TdHJpbmdNZXRob2QpKGNtZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZCA9IGNtZFtzdHJpbmdpZnlfMS50b1N0cmluZ01ldGhvZF07XG4gICAgICAgICAgICB0aGlzW3N0cmluZ2lmeV8xLnRvU3RyaW5nTWV0aG9kXSA9IGZ1bmN0aW9uIHRvU3RyaW5nTWV0aG9kKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QuY2FsbChjbWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIHN0cmluZ2lmeV8xLmhhc0FzeW5jVG9TdHJpbmdNZXRob2QpKGNtZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZCA9IGNtZFtzdHJpbmdpZnlfMS5hc3luY1RvU3RyaW5nTWV0aG9kXTtcbiAgICAgICAgICAgIHRoaXNbc3RyaW5naWZ5XzEuYXN5bmNUb1N0cmluZ01ldGhvZF0gPSBmdW5jdGlvbiBhc3luY1RvU3RyaW5nTWV0aG9kKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QuY2FsbChjbWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVjayhtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNtZC5jaGVjayhtKTtcbiAgICB9XG4gICAgcnVuKG0sIHIpIHtcbiAgICAgICAgdGhpcy5oYXNSYW4gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5jbWQucnVuKG0sIHIpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgaWYgKCgwLCBzeW1ib2xzXzEuaGFzQ2xvbmVNZXRob2QpKHRoaXMuY21kKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tbWFuZFdyYXBwZXIodGhpcy5jbWRbc3ltYm9sc18xLmNsb25lTWV0aG9kXSgpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21tYW5kV3JhcHBlcih0aGlzLmNtZCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbWQudG9TdHJpbmcoKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbW1hbmRXcmFwcGVyID0gQ29tbWFuZFdyYXBwZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tbWFuZHNJdGVyYWJsZSA9IHZvaWQgMDtcbmNvbnN0IHN5bWJvbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9zeW1ib2xzXCIpO1xuY2xhc3MgQ29tbWFuZHNJdGVyYWJsZSB7XG4gICAgY29uc3RydWN0b3IoY29tbWFuZHMsIG1ldGFkYXRhRm9yUmVwbGF5KSB7XG4gICAgICAgIHRoaXMuY29tbWFuZHMgPSBjb21tYW5kcztcbiAgICAgICAgdGhpcy5tZXRhZGF0YUZvclJlcGxheSA9IG1ldGFkYXRhRm9yUmVwbGF5O1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tbWFuZHNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICBbc3ltYm9sc18xLmNsb25lTWV0aG9kXSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21tYW5kc0l0ZXJhYmxlKHRoaXMuY29tbWFuZHMubWFwKChjKSA9PiBjLmNsb25lKCkpLCB0aGlzLm1ldGFkYXRhRm9yUmVwbGF5KTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRDb21tYW5kcyA9IHRoaXMuY29tbWFuZHNcbiAgICAgICAgICAgIC5maWx0ZXIoKGMpID0+IGMuaGFzUmFuKVxuICAgICAgICAgICAgLm1hcCgoYykgPT4gYy50b1N0cmluZygpKVxuICAgICAgICAgICAgLmpvaW4oJywnKTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhRm9yUmVwbGF5KCk7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YS5sZW5ndGggIT09IDAgPyBgJHtzZXJpYWxpemVkQ29tbWFuZHN9IC8qJHttZXRhZGF0YX0qL2AgOiBzZXJpYWxpemVkQ29tbWFuZHM7XG4gICAgfVxufVxuZXhwb3J0cy5Db21tYW5kc0l0ZXJhYmxlID0gQ29tbWFuZHNJdGVyYWJsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zY2hlZHVsZUNvbW1hbmRzID0gZXhwb3J0cy5TY2hlZHVsZWRDb21tYW5kID0gdm9pZCAwO1xuY2xhc3MgU2NoZWR1bGVkQ29tbWFuZCB7XG4gICAgY29uc3RydWN0b3IocywgY21kKSB7XG4gICAgICAgIHRoaXMucyA9IHM7XG4gICAgICAgIHRoaXMuY21kID0gY21kO1xuICAgIH1cbiAgICBhc3luYyBjaGVjayhtKSB7XG4gICAgICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgICAgIGxldCBjaGVja1Bhc3NlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCB0aGlzLnMuc2NoZWR1bGVTZXF1ZW5jZShbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGFiZWw6IGBjaGVja0Ake3RoaXMuY21kLnRvU3RyaW5nKCl9YCxcbiAgICAgICAgICAgICAgICBidWlsZGVyOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja1Bhc3NlZCA9IGF3YWl0IFByb21pc2UucmVzb2x2ZSh0aGlzLmNtZC5jaGVjayhtKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSkudGFzaztcbiAgICAgICAgaWYgKHN0YXR1cy5mYXVsdHkpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGVja1Bhc3NlZDtcbiAgICB9XG4gICAgYXN5bmMgcnVuKG0sIHIpIHtcbiAgICAgICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgdGhpcy5zLnNjaGVkdWxlU2VxdWVuY2UoW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxhYmVsOiBgcnVuQCR7dGhpcy5jbWQudG9TdHJpbmcoKX1gLFxuICAgICAgICAgICAgICAgIGJ1aWxkZXI6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY21kLnJ1bihtLCByKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKS50YXNrO1xuICAgICAgICBpZiAoc3RhdHVzLmZhdWx0eSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlNjaGVkdWxlZENvbW1hbmQgPSBTY2hlZHVsZWRDb21tYW5kO1xuY29uc3Qgc2NoZWR1bGVDb21tYW5kcyA9IGZ1bmN0aW9uKiAocywgY21kcykge1xuICAgIGZvciAoY29uc3QgY21kIG9mIGNtZHMpIHtcbiAgICAgICAgeWllbGQgbmV3IFNjaGVkdWxlZENvbW1hbmQocywgY21kKTtcbiAgICB9XG59O1xuZXhwb3J0cy5zY2hlZHVsZUNvbW1hbmRzID0gc2NoZWR1bGVDb21tYW5kcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wcmUgPSB2b2lkIDA7XG5jb25zdCBQcmVjb25kaXRpb25GYWlsdXJlXzEgPSByZXF1aXJlKFwiLi9QcmVjb25kaXRpb25GYWlsdXJlXCIpO1xuZnVuY3Rpb24gcHJlKGV4cGVjdFRydXRoeSkge1xuICAgIGlmICghZXhwZWN0VHJ1dGh5KSB7XG4gICAgICAgIHRocm93IG5ldyBQcmVjb25kaXRpb25GYWlsdXJlXzEuUHJlY29uZGl0aW9uRmFpbHVyZSgpO1xuICAgIH1cbn1cbmV4cG9ydHMucHJlID0gcHJlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByZWNvbmRpdGlvbkZhaWx1cmUgPSB2b2lkIDA7XG5jbGFzcyBQcmVjb25kaXRpb25GYWlsdXJlIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGludGVycnVwdEV4ZWN1dGlvbiA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaW50ZXJydXB0RXhlY3V0aW9uID0gaW50ZXJydXB0RXhlY3V0aW9uO1xuICAgICAgICB0aGlzLmZvb3RwcmludCA9IFByZWNvbmRpdGlvbkZhaWx1cmUuU2hhcmVkRm9vdFByaW50O1xuICAgIH1cbiAgICBzdGF0aWMgaXNGYWlsdXJlKGVycikge1xuICAgICAgICByZXR1cm4gZXJyICE9IG51bGwgJiYgZXJyLmZvb3RwcmludCA9PT0gUHJlY29uZGl0aW9uRmFpbHVyZS5TaGFyZWRGb290UHJpbnQ7XG4gICAgfVxufVxuZXhwb3J0cy5QcmVjb25kaXRpb25GYWlsdXJlID0gUHJlY29uZGl0aW9uRmFpbHVyZTtcblByZWNvbmRpdGlvbkZhaWx1cmUuU2hhcmVkRm9vdFByaW50ID0gU3ltYm9sKCdmYXN0LWNoZWNrL1ByZWNvbmRpdGlvbkZhaWx1cmUnKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc3luY1Byb3BlcnR5ID0gdm9pZCAwO1xuY29uc3QgUHJlY29uZGl0aW9uRmFpbHVyZV8xID0gcmVxdWlyZShcIi4uL3ByZWNvbmRpdGlvbi9QcmVjb25kaXRpb25GYWlsdXJlXCIpO1xuY29uc3QgSVJhd1Byb3BlcnR5XzEgPSByZXF1aXJlKFwiLi9JUmF3UHJvcGVydHlcIik7XG5jb25zdCBHbG9iYWxQYXJhbWV0ZXJzXzEgPSByZXF1aXJlKFwiLi4vcnVubmVyL2NvbmZpZ3VyYXRpb24vR2xvYmFsUGFyYW1ldGVyc1wiKTtcbmNvbnN0IFN0cmVhbV8xID0gcmVxdWlyZShcIi4uLy4uL3N0cmVhbS9TdHJlYW1cIik7XG5jb25zdCBOb1VuZGVmaW5lZEFzQ29udGV4dF8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9faW50ZXJuYWxzL2hlbHBlcnMvTm9VbmRlZmluZWRBc0NvbnRleHRcIik7XG5jbGFzcyBBc3luY1Byb3BlcnR5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmIsIHByZWRpY2F0ZSkge1xuICAgICAgICB0aGlzLmFyYiA9IGFyYjtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIGNvbnN0IHsgYXN5bmNCZWZvcmVFYWNoLCBhc3luY0FmdGVyRWFjaCwgYmVmb3JlRWFjaCwgYWZ0ZXJFYWNoIH0gPSAoMCwgR2xvYmFsUGFyYW1ldGVyc18xLnJlYWRDb25maWd1cmVHbG9iYWwpKCkgfHwge307XG4gICAgICAgIGlmIChhc3luY0JlZm9yZUVhY2ggIT09IHVuZGVmaW5lZCAmJiBiZWZvcmVFYWNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdHbG9iYWwgXCJhc3luY0JlZm9yZUVhY2hcIiBhbmQgXCJiZWZvcmVFYWNoXCIgcGFyYW1ldGVycyBjYW5cXCd0IGJlIHNldCBhdCB0aGUgc2FtZSB0aW1lIHdoZW4gcnVubmluZyBhc3luYyBwcm9wZXJ0aWVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFzeW5jQWZ0ZXJFYWNoICE9PSB1bmRlZmluZWQgJiYgYWZ0ZXJFYWNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdHbG9iYWwgXCJhc3luY0FmdGVyRWFjaFwiIGFuZCBcImFmdGVyRWFjaFwiIHBhcmFtZXRlcnMgY2FuXFwndCBiZSBzZXQgYXQgdGhlIHNhbWUgdGltZSB3aGVuIHJ1bm5pbmcgYXN5bmMgcHJvcGVydGllcycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmVmb3JlRWFjaEhvb2sgPSBhc3luY0JlZm9yZUVhY2ggfHwgYmVmb3JlRWFjaCB8fCBBc3luY1Byb3BlcnR5LmR1bW15SG9vaztcbiAgICAgICAgdGhpcy5hZnRlckVhY2hIb29rID0gYXN5bmNBZnRlckVhY2ggfHwgYWZ0ZXJFYWNoIHx8IEFzeW5jUHJvcGVydHkuZHVtbXlIb29rO1xuICAgIH1cbiAgICBpc0FzeW5jKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2VuZXJhdGUobXJuZywgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmFyYi5nZW5lcmF0ZShtcm5nLCBydW5JZCAhPSBudWxsID8gKDAsIElSYXdQcm9wZXJ0eV8xLnJ1bklkVG9GcmVxdWVuY3kpKHJ1bklkKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiAoMCwgTm9VbmRlZmluZWRBc0NvbnRleHRfMS5ub1VuZGVmaW5lZEFzQ29udGV4dCkodmFsdWUpO1xuICAgIH1cbiAgICBzaHJpbmsodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlLmNvbnRleHQgPT09IHVuZGVmaW5lZCAmJiAhdGhpcy5hcmIuY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWUudmFsdWVfKSkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmVhbV8xLlN0cmVhbS5uaWwoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzYWZlQ29udGV4dCA9IHZhbHVlLmNvbnRleHQgIT09IE5vVW5kZWZpbmVkQXNDb250ZXh0XzEuVW5kZWZpbmVkQ29udGV4dFBsYWNlaG9sZGVyID8gdmFsdWUuY29udGV4dCA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJiLnNocmluayh2YWx1ZS52YWx1ZV8sIHNhZmVDb250ZXh0KS5tYXAoTm9VbmRlZmluZWRBc0NvbnRleHRfMS5ub1VuZGVmaW5lZEFzQ29udGV4dCk7XG4gICAgfVxuICAgIGFzeW5jIHJ1bih2KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuYmVmb3JlRWFjaEhvb2soKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHRoaXMucHJlZGljYXRlKHYpO1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dCA9PSBudWxsIHx8IG91dHB1dCA9PT0gdHJ1ZVxuICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgIDogeyBlcnJvcjogdW5kZWZpbmVkLCBlcnJvck1lc3NhZ2U6ICdQcm9wZXJ0eSBmYWlsZWQgYnkgcmV0dXJuaW5nIGZhbHNlJyB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChQcmVjb25kaXRpb25GYWlsdXJlXzEuUHJlY29uZGl0aW9uRmFpbHVyZS5pc0ZhaWx1cmUoZXJyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yICYmIGVyci5zdGFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBlcnIsIGVycm9yTWVzc2FnZTogYCR7ZXJyfVxcblxcblN0YWNrIHRyYWNlOiAke2Vyci5zdGFja31gIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogZXJyLCBlcnJvck1lc3NhZ2U6IFN0cmluZyhlcnIpIH07XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFmdGVyRWFjaEhvb2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiZWZvcmVFYWNoKGhvb2tGdW5jdGlvbikge1xuICAgICAgICBjb25zdCBwcmV2aW91c0JlZm9yZUVhY2hIb29rID0gdGhpcy5iZWZvcmVFYWNoSG9vaztcbiAgICAgICAgdGhpcy5iZWZvcmVFYWNoSG9vayA9ICgpID0+IGhvb2tGdW5jdGlvbihwcmV2aW91c0JlZm9yZUVhY2hIb29rKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFmdGVyRWFjaChob29rRnVuY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNBZnRlckVhY2hIb29rID0gdGhpcy5hZnRlckVhY2hIb29rO1xuICAgICAgICB0aGlzLmFmdGVyRWFjaEhvb2sgPSAoKSA9PiBob29rRnVuY3Rpb24ocHJldmlvdXNBZnRlckVhY2hIb29rKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5Bc3luY1Byb3BlcnR5ID0gQXN5bmNQcm9wZXJ0eTtcbkFzeW5jUHJvcGVydHkuZHVtbXlIb29rID0gKCkgPT4geyB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzeW5jUHJvcGVydHkgPSB2b2lkIDA7XG5jb25zdCBBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuLi9hcmJpdHJhcnkvZGVmaW5pdGlvbi9BcmJpdHJhcnlcIik7XG5jb25zdCB0dXBsZV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS90dXBsZVwiKTtcbmNvbnN0IEFzeW5jUHJvcGVydHlfZ2VuZXJpY18xID0gcmVxdWlyZShcIi4vQXN5bmNQcm9wZXJ0eS5nZW5lcmljXCIpO1xuY29uc3QgQWx3YXlzU2hyaW5rYWJsZUFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9faW50ZXJuYWxzL0Fsd2F5c1Nocmlua2FibGVBcmJpdHJhcnlcIik7XG5mdW5jdGlvbiBhc3luY1Byb3BlcnR5KC4uLmFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXN5bmNQcm9wZXJ0eSBleHBlY3RzIGF0IGxlYXN0IHR3byBwYXJhbWV0ZXJzJyk7XG4gICAgfVxuICAgIGNvbnN0IGFyYnMgPSBhcmdzLnNsaWNlKDAsIGFyZ3MubGVuZ3RoIC0gMSk7XG4gICAgY29uc3QgcCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICBhcmJzLmZvckVhY2goQXJiaXRyYXJ5XzEuYXNzZXJ0SXNBcmJpdHJhcnkpO1xuICAgIGNvbnN0IG1hcHBlZEFyYnMgPSBhcmJzLm1hcCgoYXJiKSA9PiBuZXcgQWx3YXlzU2hyaW5rYWJsZUFyYml0cmFyeV8xLkFsd2F5c1Nocmlua2FibGVBcmJpdHJhcnkoYXJiKSk7XG4gICAgcmV0dXJuIG5ldyBBc3luY1Byb3BlcnR5X2dlbmVyaWNfMS5Bc3luY1Byb3BlcnR5KCgwLCB0dXBsZV8xLnR1cGxlKSguLi5tYXBwZWRBcmJzKSwgKHQpID0+IHAoLi4udCkpO1xufVxuZXhwb3J0cy5hc3luY1Byb3BlcnR5ID0gYXN5bmNQcm9wZXJ0eTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ydW5JZFRvRnJlcXVlbmN5ID0gdm9pZCAwO1xuY29uc3QgcnVuSWRUb0ZyZXF1ZW5jeSA9IChydW5JZCkgPT4gMiArIE1hdGguZmxvb3IoTWF0aC5sb2cocnVuSWQgKyAxKSAvIE1hdGgubG9nKDEwKSk7XG5leHBvcnRzLnJ1bklkVG9GcmVxdWVuY3kgPSBydW5JZFRvRnJlcXVlbmN5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklnbm9yZUVxdWFsVmFsdWVzUHJvcGVydHkgPSB2b2lkIDA7XG5jb25zdCBzdHJpbmdpZnlfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9zdHJpbmdpZnlcIik7XG5jb25zdCBQcmVjb25kaXRpb25GYWlsdXJlXzEgPSByZXF1aXJlKFwiLi4vcHJlY29uZGl0aW9uL1ByZWNvbmRpdGlvbkZhaWx1cmVcIik7XG5mdW5jdGlvbiBmcm9tU3luY0NhY2hlZChjYWNoZWRWYWx1ZSkge1xuICAgIHJldHVybiBjYWNoZWRWYWx1ZSA9PT0gbnVsbCA/IG5ldyBQcmVjb25kaXRpb25GYWlsdXJlXzEuUHJlY29uZGl0aW9uRmFpbHVyZSgpIDogY2FjaGVkVmFsdWU7XG59XG5mdW5jdGlvbiBmcm9tQ2FjaGVkKC4uLmRhdGEpIHtcbiAgICBpZiAoZGF0YVsxXSlcbiAgICAgICAgcmV0dXJuIGRhdGFbMF0udGhlbihmcm9tU3luY0NhY2hlZCk7XG4gICAgcmV0dXJuIGZyb21TeW5jQ2FjaGVkKGRhdGFbMF0pO1xufVxuZnVuY3Rpb24gZnJvbUNhY2hlZFVuc2FmZShjYWNoZWRWYWx1ZSwgaXNBc3luYykge1xuICAgIHJldHVybiBmcm9tQ2FjaGVkKGNhY2hlZFZhbHVlLCBpc0FzeW5jKTtcbn1cbmNsYXNzIElnbm9yZUVxdWFsVmFsdWVzUHJvcGVydHkge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5LCBza2lwUnVucykge1xuICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICAgIHRoaXMuc2tpcFJ1bnMgPSBza2lwUnVucztcbiAgICAgICAgdGhpcy5jb3ZlcmVkQ2FzZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGlzQXN5bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnR5LmlzQXN5bmMoKTtcbiAgICB9XG4gICAgZ2VuZXJhdGUobXJuZywgcnVuSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkuZ2VuZXJhdGUobXJuZywgcnVuSWQpO1xuICAgIH1cbiAgICBzaHJpbmsodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkuc2hyaW5rKHZhbHVlKTtcbiAgICB9XG4gICAgcnVuKHYpIHtcbiAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRWYWx1ZSA9ICgwLCBzdHJpbmdpZnlfMS5zdHJpbmdpZnkpKHYpO1xuICAgICAgICBpZiAodGhpcy5jb3ZlcmVkQ2FzZXMuaGFzKHN0cmluZ2lmaWVkVmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0T3V0cHV0ID0gdGhpcy5jb3ZlcmVkQ2FzZXMuZ2V0KHN0cmluZ2lmaWVkVmFsdWUpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNraXBSdW5zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RPdXRwdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJvbUNhY2hlZFVuc2FmZShsYXN0T3V0cHV0LCB0aGlzLnByb3BlcnR5LmlzQXN5bmMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3V0ID0gdGhpcy5wcm9wZXJ0eS5ydW4odik7XG4gICAgICAgIHRoaXMuY292ZXJlZENhc2VzLnNldChzdHJpbmdpZmllZFZhbHVlLCBvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbn1cbmV4cG9ydHMuSWdub3JlRXF1YWxWYWx1ZXNQcm9wZXJ0eSA9IElnbm9yZUVxdWFsVmFsdWVzUHJvcGVydHk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJvcGVydHkgPSB2b2lkIDA7XG5jb25zdCBQcmVjb25kaXRpb25GYWlsdXJlXzEgPSByZXF1aXJlKFwiLi4vcHJlY29uZGl0aW9uL1ByZWNvbmRpdGlvbkZhaWx1cmVcIik7XG5jb25zdCBJUmF3UHJvcGVydHlfMSA9IHJlcXVpcmUoXCIuL0lSYXdQcm9wZXJ0eVwiKTtcbmNvbnN0IEdsb2JhbFBhcmFtZXRlcnNfMSA9IHJlcXVpcmUoXCIuLi9ydW5uZXIvY29uZmlndXJhdGlvbi9HbG9iYWxQYXJhbWV0ZXJzXCIpO1xuY29uc3QgU3RyZWFtXzEgPSByZXF1aXJlKFwiLi4vLi4vc3RyZWFtL1N0cmVhbVwiKTtcbmNvbnN0IE5vVW5kZWZpbmVkQXNDb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L19pbnRlcm5hbHMvaGVscGVycy9Ob1VuZGVmaW5lZEFzQ29udGV4dFwiKTtcbmNsYXNzIFByb3BlcnR5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmIsIHByZWRpY2F0ZSkge1xuICAgICAgICB0aGlzLmFyYiA9IGFyYjtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIGNvbnN0IHsgYmVmb3JlRWFjaCA9IFByb3BlcnR5LmR1bW15SG9vaywgYWZ0ZXJFYWNoID0gUHJvcGVydHkuZHVtbXlIb29rLCBhc3luY0JlZm9yZUVhY2gsIGFzeW5jQWZ0ZXJFYWNoLCB9ID0gKDAsIEdsb2JhbFBhcmFtZXRlcnNfMS5yZWFkQ29uZmlndXJlR2xvYmFsKSgpIHx8IHt9O1xuICAgICAgICBpZiAoYXN5bmNCZWZvcmVFYWNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdcImFzeW5jQmVmb3JlRWFjaFwiIGNhblxcJ3QgYmUgc2V0IHdoZW4gcnVubmluZyBzeW5jaHJvbm91cyBwcm9wZXJ0aWVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFzeW5jQWZ0ZXJFYWNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdcImFzeW5jQWZ0ZXJFYWNoXCIgY2FuXFwndCBiZSBzZXQgd2hlbiBydW5uaW5nIHN5bmNocm9ub3VzIHByb3BlcnRpZXMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJlZm9yZUVhY2hIb29rID0gYmVmb3JlRWFjaDtcbiAgICAgICAgdGhpcy5hZnRlckVhY2hIb29rID0gYWZ0ZXJFYWNoO1xuICAgIH1cbiAgICBpc0FzeW5jKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5hcmIuZ2VuZXJhdGUobXJuZywgcnVuSWQgIT0gbnVsbCA/ICgwLCBJUmF3UHJvcGVydHlfMS5ydW5JZFRvRnJlcXVlbmN5KShydW5JZCkgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gKDAsIE5vVW5kZWZpbmVkQXNDb250ZXh0XzEubm9VbmRlZmluZWRBc0NvbnRleHQpKHZhbHVlKTtcbiAgICB9XG4gICAgc2hyaW5rKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZS5jb250ZXh0ID09PSB1bmRlZmluZWQgJiYgIXRoaXMuYXJiLmNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlLnZhbHVlXykpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJlYW1fMS5TdHJlYW0ubmlsKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2FmZUNvbnRleHQgPSB2YWx1ZS5jb250ZXh0ICE9PSBOb1VuZGVmaW5lZEFzQ29udGV4dF8xLlVuZGVmaW5lZENvbnRleHRQbGFjZWhvbGRlciA/IHZhbHVlLmNvbnRleHQgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0aGlzLmFyYi5zaHJpbmsodmFsdWUudmFsdWVfLCBzYWZlQ29udGV4dCkubWFwKE5vVW5kZWZpbmVkQXNDb250ZXh0XzEubm9VbmRlZmluZWRBc0NvbnRleHQpO1xuICAgIH1cbiAgICBydW4odikge1xuICAgICAgICB0aGlzLmJlZm9yZUVhY2hIb29rKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSB0aGlzLnByZWRpY2F0ZSh2KTtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQgPT0gbnVsbCB8fCBvdXRwdXQgPT09IHRydWVcbiAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICA6IHsgZXJyb3I6IHVuZGVmaW5lZCwgZXJyb3JNZXNzYWdlOiAnUHJvcGVydHkgZmFpbGVkIGJ5IHJldHVybmluZyBmYWxzZScgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoUHJlY29uZGl0aW9uRmFpbHVyZV8xLlByZWNvbmRpdGlvbkZhaWx1cmUuaXNGYWlsdXJlKGVycikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnIuc3RhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogZXJyLCBlcnJvck1lc3NhZ2U6IGAke2Vycn1cXG5cXG5TdGFjayB0cmFjZTogJHtlcnIuc3RhY2t9YCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGVyciwgZXJyb3JNZXNzYWdlOiBTdHJpbmcoZXJyKSB9O1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5hZnRlckVhY2hIb29rKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmVmb3JlRWFjaChob29rRnVuY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNCZWZvcmVFYWNoSG9vayA9IHRoaXMuYmVmb3JlRWFjaEhvb2s7XG4gICAgICAgIHRoaXMuYmVmb3JlRWFjaEhvb2sgPSAoKSA9PiBob29rRnVuY3Rpb24ocHJldmlvdXNCZWZvcmVFYWNoSG9vayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZnRlckVhY2goaG9va0Z1bmN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzQWZ0ZXJFYWNoSG9vayA9IHRoaXMuYWZ0ZXJFYWNoSG9vaztcbiAgICAgICAgdGhpcy5hZnRlckVhY2hIb29rID0gKCkgPT4gaG9va0Z1bmN0aW9uKHByZXZpb3VzQWZ0ZXJFYWNoSG9vayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvcGVydHkgPSBQcm9wZXJ0eTtcblByb3BlcnR5LmR1bW15SG9vayA9ICgpID0+IHsgfTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wcm9wZXJ0eSA9IHZvaWQgMDtcbmNvbnN0IEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4uL2FyYml0cmFyeS9kZWZpbml0aW9uL0FyYml0cmFyeVwiKTtcbmNvbnN0IHR1cGxlXzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L3R1cGxlXCIpO1xuY29uc3QgUHJvcGVydHlfZ2VuZXJpY18xID0gcmVxdWlyZShcIi4vUHJvcGVydHkuZ2VuZXJpY1wiKTtcbmNvbnN0IEFsd2F5c1Nocmlua2FibGVBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvX2ludGVybmFscy9BbHdheXNTaHJpbmthYmxlQXJiaXRyYXJ5XCIpO1xuZnVuY3Rpb24gcHJvcGVydHkoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9wZXJ0eSBleHBlY3RzIGF0IGxlYXN0IHR3byBwYXJhbWV0ZXJzJyk7XG4gICAgfVxuICAgIGNvbnN0IGFyYnMgPSBhcmdzLnNsaWNlKDAsIGFyZ3MubGVuZ3RoIC0gMSk7XG4gICAgY29uc3QgcCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICBhcmJzLmZvckVhY2goQXJiaXRyYXJ5XzEuYXNzZXJ0SXNBcmJpdHJhcnkpO1xuICAgIGNvbnN0IG1hcHBlZEFyYnMgPSBhcmJzLm1hcCgoYXJiKSA9PiBuZXcgQWx3YXlzU2hyaW5rYWJsZUFyYml0cmFyeV8xLkFsd2F5c1Nocmlua2FibGVBcmJpdHJhcnkoYXJiKSk7XG4gICAgcmV0dXJuIG5ldyBQcm9wZXJ0eV9nZW5lcmljXzEuUHJvcGVydHkoKDAsIHR1cGxlXzEudHVwbGUpKC4uLm1hcHBlZEFyYnMpLCAodCkgPT4gcCguLi50KSk7XG59XG5leHBvcnRzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2tpcEFmdGVyUHJvcGVydHkgPSB2b2lkIDA7XG5jb25zdCBQcmVjb25kaXRpb25GYWlsdXJlXzEgPSByZXF1aXJlKFwiLi4vcHJlY29uZGl0aW9uL1ByZWNvbmRpdGlvbkZhaWx1cmVcIik7XG5jbGFzcyBTa2lwQWZ0ZXJQcm9wZXJ0eSB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHksIGdldFRpbWUsIHRpbWVMaW1pdCwgaW50ZXJydXB0RXhlY3V0aW9uKSB7XG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgdGhpcy5nZXRUaW1lID0gZ2V0VGltZTtcbiAgICAgICAgdGhpcy5pbnRlcnJ1cHRFeGVjdXRpb24gPSBpbnRlcnJ1cHRFeGVjdXRpb247XG4gICAgICAgIHRoaXMuc2tpcEFmdGVyVGltZSA9IHRoaXMuZ2V0VGltZSgpICsgdGltZUxpbWl0O1xuICAgIH1cbiAgICBpc0FzeW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eS5pc0FzeW5jKCk7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIHJ1bklkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnR5LmdlbmVyYXRlKG1ybmcsIHJ1bklkKTtcbiAgICB9XG4gICAgc2hyaW5rKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnR5LnNocmluayh2YWx1ZSk7XG4gICAgfVxuICAgIHJ1bih2KSB7XG4gICAgICAgIGlmICh0aGlzLmdldFRpbWUoKSA+PSB0aGlzLnNraXBBZnRlclRpbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZWNvbmRpdGlvbkZhaWx1cmUgPSBuZXcgUHJlY29uZGl0aW9uRmFpbHVyZV8xLlByZWNvbmRpdGlvbkZhaWx1cmUodGhpcy5pbnRlcnJ1cHRFeGVjdXRpb24pO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNBc3luYygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcmVjb25kaXRpb25GYWlsdXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVjb25kaXRpb25GYWlsdXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnR5LnJ1bih2KTtcbiAgICB9XG59XG5leHBvcnRzLlNraXBBZnRlclByb3BlcnR5ID0gU2tpcEFmdGVyUHJvcGVydHk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVGltZW91dFByb3BlcnR5ID0gdm9pZCAwO1xuY29uc3QgdGltZW91dEFmdGVyID0gKHRpbWVNcykgPT4ge1xuICAgIGxldCB0aW1lb3V0SGFuZGxlID0gbnVsbDtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgdGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSh7IGVycm9yOiB1bmRlZmluZWQsIGVycm9yTWVzc2FnZTogYFByb3BlcnR5IHRpbWVvdXQ6IGV4Y2VlZGVkIGxpbWl0IG9mICR7dGltZU1zfSBtaWxsaXNlY29uZHNgIH0pO1xuICAgICAgICB9LCB0aW1lTXMpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNsZWFyOiAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dEhhbmRsZSksXG4gICAgICAgIHByb21pc2UsXG4gICAgfTtcbn07XG5jbGFzcyBUaW1lb3V0UHJvcGVydHkge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5LCB0aW1lTXMpIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgICAgICB0aGlzLnRpbWVNcyA9IHRpbWVNcztcbiAgICB9XG4gICAgaXNBc3luYygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIHJ1bklkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnR5LmdlbmVyYXRlKG1ybmcsIHJ1bklkKTtcbiAgICB9XG4gICAgc2hyaW5rKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnR5LnNocmluayh2YWx1ZSk7XG4gICAgfVxuICAgIGFzeW5jIHJ1bih2KSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aW1lb3V0QWZ0ZXIodGhpcy50aW1lTXMpO1xuICAgICAgICBjb25zdCBwcm9wUnVuID0gUHJvbWlzZS5yYWNlKFt0aGlzLnByb3BlcnR5LnJ1bih2KSwgdC5wcm9taXNlXSk7XG4gICAgICAgIHByb3BSdW4udGhlbih0LmNsZWFyLCB0LmNsZWFyKTtcbiAgICAgICAgcmV0dXJuIHByb3BSdW47XG4gICAgfVxufVxuZXhwb3J0cy5UaW1lb3V0UHJvcGVydHkgPSBUaW1lb3V0UHJvcGVydHk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVW5iaWFzZWRQcm9wZXJ0eSA9IHZvaWQgMDtcbmNsYXNzIFVuYmlhc2VkUHJvcGVydHkge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICB9XG4gICAgaXNBc3luYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkuaXNBc3luYygpO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBfcnVuSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkuZ2VuZXJhdGUobXJuZywgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgc2hyaW5rKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnR5LnNocmluayh2YWx1ZSk7XG4gICAgfVxuICAgIHJ1bih2KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnR5LnJ1bih2KTtcbiAgICB9XG59XG5leHBvcnRzLlVuYmlhc2VkUHJvcGVydHkgPSBVbmJpYXNlZFByb3BlcnR5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29yYXRlUHJvcGVydHkgPSB2b2lkIDA7XG5jb25zdCBTa2lwQWZ0ZXJQcm9wZXJ0eV8xID0gcmVxdWlyZShcIi4uL3Byb3BlcnR5L1NraXBBZnRlclByb3BlcnR5XCIpO1xuY29uc3QgVGltZW91dFByb3BlcnR5XzEgPSByZXF1aXJlKFwiLi4vcHJvcGVydHkvVGltZW91dFByb3BlcnR5XCIpO1xuY29uc3QgVW5iaWFzZWRQcm9wZXJ0eV8xID0gcmVxdWlyZShcIi4uL3Byb3BlcnR5L1VuYmlhc2VkUHJvcGVydHlcIik7XG5jb25zdCBJZ25vcmVFcXVhbFZhbHVlc1Byb3BlcnR5XzEgPSByZXF1aXJlKFwiLi4vcHJvcGVydHkvSWdub3JlRXF1YWxWYWx1ZXNQcm9wZXJ0eVwiKTtcbmZ1bmN0aW9uIGRlY29yYXRlUHJvcGVydHkocmF3UHJvcGVydHksIHFQYXJhbXMpIHtcbiAgICBsZXQgcHJvcCA9IHJhd1Byb3BlcnR5O1xuICAgIGlmIChyYXdQcm9wZXJ0eS5pc0FzeW5jKCkgJiYgcVBhcmFtcy50aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgcHJvcCA9IG5ldyBUaW1lb3V0UHJvcGVydHlfMS5UaW1lb3V0UHJvcGVydHkocHJvcCwgcVBhcmFtcy50aW1lb3V0KTtcbiAgICB9XG4gICAgaWYgKHFQYXJhbXMudW5iaWFzZWQpIHtcbiAgICAgICAgcHJvcCA9IG5ldyBVbmJpYXNlZFByb3BlcnR5XzEuVW5iaWFzZWRQcm9wZXJ0eShwcm9wKTtcbiAgICB9XG4gICAgaWYgKHFQYXJhbXMuc2tpcEFsbEFmdGVyVGltZUxpbWl0ICE9IG51bGwpIHtcbiAgICAgICAgcHJvcCA9IG5ldyBTa2lwQWZ0ZXJQcm9wZXJ0eV8xLlNraXBBZnRlclByb3BlcnR5KHByb3AsIERhdGUubm93LCBxUGFyYW1zLnNraXBBbGxBZnRlclRpbWVMaW1pdCwgZmFsc2UpO1xuICAgIH1cbiAgICBpZiAocVBhcmFtcy5pbnRlcnJ1cHRBZnRlclRpbWVMaW1pdCAhPSBudWxsKSB7XG4gICAgICAgIHByb3AgPSBuZXcgU2tpcEFmdGVyUHJvcGVydHlfMS5Ta2lwQWZ0ZXJQcm9wZXJ0eShwcm9wLCBEYXRlLm5vdywgcVBhcmFtcy5pbnRlcnJ1cHRBZnRlclRpbWVMaW1pdCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChxUGFyYW1zLnNraXBFcXVhbFZhbHVlcykge1xuICAgICAgICBwcm9wID0gbmV3IElnbm9yZUVxdWFsVmFsdWVzUHJvcGVydHlfMS5JZ25vcmVFcXVhbFZhbHVlc1Byb3BlcnR5KHByb3AsIHRydWUpO1xuICAgIH1cbiAgICBpZiAocVBhcmFtcy5pZ25vcmVFcXVhbFZhbHVlcykge1xuICAgICAgICBwcm9wID0gbmV3IElnbm9yZUVxdWFsVmFsdWVzUHJvcGVydHlfMS5JZ25vcmVFcXVhbFZhbHVlc1Byb3BlcnR5KHByb3AsIGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3A7XG59XG5leHBvcnRzLmRlY29yYXRlUHJvcGVydHkgPSBkZWNvcmF0ZVByb3BlcnR5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzc2VydCA9IGV4cG9ydHMuY2hlY2sgPSB2b2lkIDA7XG5jb25zdCBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi8uLi9zdHJlYW0vU3RyZWFtXCIpO1xuY29uc3QgR2xvYmFsUGFyYW1ldGVyc18xID0gcmVxdWlyZShcIi4vY29uZmlndXJhdGlvbi9HbG9iYWxQYXJhbWV0ZXJzXCIpO1xuY29uc3QgUXVhbGlmaWVkUGFyYW1ldGVyc18xID0gcmVxdWlyZShcIi4vY29uZmlndXJhdGlvbi9RdWFsaWZpZWRQYXJhbWV0ZXJzXCIpO1xuY29uc3QgRGVjb3JhdGVQcm9wZXJ0eV8xID0gcmVxdWlyZShcIi4vRGVjb3JhdGVQcm9wZXJ0eVwiKTtcbmNvbnN0IFJ1bm5lckl0ZXJhdG9yXzEgPSByZXF1aXJlKFwiLi9SdW5uZXJJdGVyYXRvclwiKTtcbmNvbnN0IFNvdXJjZVZhbHVlc0l0ZXJhdG9yXzEgPSByZXF1aXJlKFwiLi9Tb3VyY2VWYWx1ZXNJdGVyYXRvclwiKTtcbmNvbnN0IFRvc3Nlcl8xID0gcmVxdWlyZShcIi4vVG9zc2VyXCIpO1xuY29uc3QgUGF0aFdhbGtlcl8xID0gcmVxdWlyZShcIi4vdXRpbHMvUGF0aFdhbGtlclwiKTtcbmNvbnN0IFJ1bkRldGFpbHNGb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL1J1bkRldGFpbHNGb3JtYXR0ZXJcIik7XG5mdW5jdGlvbiBydW5JdChwcm9wZXJ0eSwgc2hyaW5rLCBzb3VyY2VWYWx1ZXMsIHZlcmJvc2UsIGludGVycnVwdGVkQXNGYWlsdXJlKSB7XG4gICAgY29uc3QgcnVubmVyID0gbmV3IFJ1bm5lckl0ZXJhdG9yXzEuUnVubmVySXRlcmF0b3Ioc291cmNlVmFsdWVzLCBzaHJpbmssIHZlcmJvc2UsIGludGVycnVwdGVkQXNGYWlsdXJlKTtcbiAgICBmb3IgKGNvbnN0IHYgb2YgcnVubmVyKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IHByb3BlcnR5LnJ1bih2KTtcbiAgICAgICAgcnVubmVyLmhhbmRsZVJlc3VsdChvdXQpO1xuICAgIH1cbiAgICByZXR1cm4gcnVubmVyLnJ1bkV4ZWN1dGlvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFzeW5jUnVuSXQocHJvcGVydHksIHNocmluaywgc291cmNlVmFsdWVzLCB2ZXJib3NlLCBpbnRlcnJ1cHRlZEFzRmFpbHVyZSkge1xuICAgIGNvbnN0IHJ1bm5lciA9IG5ldyBSdW5uZXJJdGVyYXRvcl8xLlJ1bm5lckl0ZXJhdG9yKHNvdXJjZVZhbHVlcywgc2hyaW5rLCB2ZXJib3NlLCBpbnRlcnJ1cHRlZEFzRmFpbHVyZSk7XG4gICAgZm9yIChjb25zdCB2IG9mIHJ1bm5lcikge1xuICAgICAgICBjb25zdCBvdXQgPSBhd2FpdCBwcm9wZXJ0eS5ydW4odik7XG4gICAgICAgIHJ1bm5lci5oYW5kbGVSZXN1bHQob3V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bm5lci5ydW5FeGVjdXRpb247XG59XG5mdW5jdGlvbiBydW5uZXJQYXRoV2Fsa2VyKHZhbHVlUHJvZHVjZXJzLCBzaHJpbmssIHBhdGgpIHtcbiAgICBjb25zdCBwYXRoUG9pbnRzID0gcGF0aC5zcGxpdCgnOicpO1xuICAgIGNvbnN0IHBhdGhTdHJlYW0gPSAoMCwgU3RyZWFtXzEuc3RyZWFtKSh2YWx1ZVByb2R1Y2VycylcbiAgICAgICAgLmRyb3AocGF0aFBvaW50cy5sZW5ndGggPiAwID8gK3BhdGhQb2ludHNbMF0gOiAwKVxuICAgICAgICAubWFwKChwcm9kdWNlcikgPT4gcHJvZHVjZXIoKSk7XG4gICAgY29uc3QgYWRhcHRlZFBhdGggPSBbJzAnLCAuLi5wYXRoUG9pbnRzLnNsaWNlKDEpXS5qb2luKCc6Jyk7XG4gICAgcmV0dXJuICgwLCBTdHJlYW1fMS5zdHJlYW0pKCgwLCBQYXRoV2Fsa2VyXzEucGF0aFdhbGspKGFkYXB0ZWRQYXRoLCBwYXRoU3RyZWFtLCBzaHJpbmspKS5tYXAoKHYpID0+ICgpID0+IHYpO1xufVxuZnVuY3Rpb24gYnVpbGRJbml0aWFsVmFsdWVzKHZhbHVlUHJvZHVjZXJzLCBzaHJpbmssIHFQYXJhbXMpIHtcbiAgICBpZiAocVBhcmFtcy5wYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gKDAsIFN0cmVhbV8xLnN0cmVhbSkodmFsdWVQcm9kdWNlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gcnVubmVyUGF0aFdhbGtlcih2YWx1ZVByb2R1Y2Vycywgc2hyaW5rLCBxUGFyYW1zLnBhdGgpO1xufVxuZnVuY3Rpb24gY2hlY2socmF3UHJvcGVydHksIHBhcmFtcykge1xuICAgIGlmIChyYXdQcm9wZXJ0eSA9PSBudWxsIHx8IHJhd1Byb3BlcnR5LmdlbmVyYXRlID09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcm9wZXJ0eSBlbmNvdW50ZXJlZCwgcGxlYXNlIHVzZSBhIHZhbGlkIHByb3BlcnR5Jyk7XG4gICAgaWYgKHJhd1Byb3BlcnR5LnJ1biA9PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvcGVydHkgZW5jb3VudGVyZWQsIHBsZWFzZSB1c2UgYSB2YWxpZCBwcm9wZXJ0eSBub3QgYW4gYXJiaXRyYXJ5Jyk7XG4gICAgY29uc3QgcVBhcmFtcyA9IFF1YWxpZmllZFBhcmFtZXRlcnNfMS5RdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoMCwgR2xvYmFsUGFyYW1ldGVyc18xLnJlYWRDb25maWd1cmVHbG9iYWwpKCkpLCBwYXJhbXMpKTtcbiAgICBpZiAocVBhcmFtcy5yZXBvcnRlciAhPT0gbnVsbCAmJiBxUGFyYW1zLmFzeW5jUmVwb3J0ZXIgIT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXJhbWV0ZXJzIGVuY291bnRlcmVkLCByZXBvcnRlciBhbmQgYXN5bmNSZXBvcnRlciBjYW5ub3QgYmUgc3BlY2lmaWVkIHRvZ2V0aGVyJyk7XG4gICAgaWYgKHFQYXJhbXMuYXN5bmNSZXBvcnRlciAhPT0gbnVsbCAmJiAhcmF3UHJvcGVydHkuaXNBc3luYygpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVycyBlbmNvdW50ZXJlZCwgb25seSBhc3luY1Byb3BlcnR5IGNhbiBiZSB1c2VkIHdoZW4gYXN5bmNSZXBvcnRlciBzcGVjaWZpZWQnKTtcbiAgICBjb25zdCBwcm9wZXJ0eSA9ICgwLCBEZWNvcmF0ZVByb3BlcnR5XzEuZGVjb3JhdGVQcm9wZXJ0eSkocmF3UHJvcGVydHksIHFQYXJhbXMpO1xuICAgIGNvbnN0IGdlbmVyYXRvciA9ICgwLCBUb3NzZXJfMS50b3NzKShwcm9wZXJ0eSwgcVBhcmFtcy5zZWVkLCBxUGFyYW1zLnJhbmRvbVR5cGUsIHFQYXJhbXMuZXhhbXBsZXMpO1xuICAgIGNvbnN0IG1heEluaXRpYWxJdGVyYXRpb25zID0gcVBhcmFtcy5wYXRoLmluZGV4T2YoJzonKSA9PT0gLTEgPyBxUGFyYW1zLm51bVJ1bnMgOiAtMTtcbiAgICBjb25zdCBtYXhTa2lwcyA9IHFQYXJhbXMubnVtUnVucyAqIHFQYXJhbXMubWF4U2tpcHNQZXJSdW47XG4gICAgY29uc3Qgc2hyaW5rID0gcHJvcGVydHkuc2hyaW5rLmJpbmQocHJvcGVydHkpO1xuICAgIGNvbnN0IGluaXRpYWxWYWx1ZXMgPSBidWlsZEluaXRpYWxWYWx1ZXMoZ2VuZXJhdG9yLCBzaHJpbmssIHFQYXJhbXMpO1xuICAgIGNvbnN0IHNvdXJjZVZhbHVlcyA9IG5ldyBTb3VyY2VWYWx1ZXNJdGVyYXRvcl8xLlNvdXJjZVZhbHVlc0l0ZXJhdG9yKGluaXRpYWxWYWx1ZXMsIG1heEluaXRpYWxJdGVyYXRpb25zLCBtYXhTa2lwcyk7XG4gICAgY29uc3QgZmluYWxTaHJpbmsgPSAhcVBhcmFtcy5lbmRPbkZhaWx1cmUgPyBzaHJpbmsgOiBTdHJlYW1fMS5TdHJlYW0ubmlsO1xuICAgIHJldHVybiBwcm9wZXJ0eS5pc0FzeW5jKClcbiAgICAgICAgPyBhc3luY1J1bkl0KHByb3BlcnR5LCBmaW5hbFNocmluaywgc291cmNlVmFsdWVzLCBxUGFyYW1zLnZlcmJvc2UsIHFQYXJhbXMubWFya0ludGVycnVwdEFzRmFpbHVyZSkudGhlbigoZSkgPT4gZS50b1J1bkRldGFpbHMocVBhcmFtcy5zZWVkLCBxUGFyYW1zLnBhdGgsIG1heFNraXBzLCBxUGFyYW1zKSlcbiAgICAgICAgOiBydW5JdChwcm9wZXJ0eSwgZmluYWxTaHJpbmssIHNvdXJjZVZhbHVlcywgcVBhcmFtcy52ZXJib3NlLCBxUGFyYW1zLm1hcmtJbnRlcnJ1cHRBc0ZhaWx1cmUpLnRvUnVuRGV0YWlscyhxUGFyYW1zLnNlZWQsIHFQYXJhbXMucGF0aCwgbWF4U2tpcHMsIHFQYXJhbXMpO1xufVxuZXhwb3J0cy5jaGVjayA9IGNoZWNrO1xuZnVuY3Rpb24gYXNzZXJ0KHByb3BlcnR5LCBwYXJhbXMpIHtcbiAgICBjb25zdCBvdXQgPSBjaGVjayhwcm9wZXJ0eSwgcGFyYW1zKTtcbiAgICBpZiAocHJvcGVydHkuaXNBc3luYygpKVxuICAgICAgICByZXR1cm4gb3V0LnRoZW4oUnVuRGV0YWlsc0Zvcm1hdHRlcl8xLmFzeW5jUmVwb3J0UnVuRGV0YWlscyk7XG4gICAgZWxzZVxuICAgICAgICAoMCwgUnVuRGV0YWlsc0Zvcm1hdHRlcl8xLnJlcG9ydFJ1bkRldGFpbHMpKG91dCk7XG59XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SdW5uZXJJdGVyYXRvciA9IHZvaWQgMDtcbmNvbnN0IFByZWNvbmRpdGlvbkZhaWx1cmVfMSA9IHJlcXVpcmUoXCIuLi9wcmVjb25kaXRpb24vUHJlY29uZGl0aW9uRmFpbHVyZVwiKTtcbmNvbnN0IFJ1bkV4ZWN1dGlvbl8xID0gcmVxdWlyZShcIi4vcmVwb3J0ZXIvUnVuRXhlY3V0aW9uXCIpO1xuY2xhc3MgUnVubmVySXRlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZVZhbHVlcywgc2hyaW5rLCB2ZXJib3NlLCBpbnRlcnJ1cHRlZEFzRmFpbHVyZSkge1xuICAgICAgICB0aGlzLnNvdXJjZVZhbHVlcyA9IHNvdXJjZVZhbHVlcztcbiAgICAgICAgdGhpcy5zaHJpbmsgPSBzaHJpbms7XG4gICAgICAgIHRoaXMucnVuRXhlY3V0aW9uID0gbmV3IFJ1bkV4ZWN1dGlvbl8xLlJ1bkV4ZWN1dGlvbih2ZXJib3NlLCBpbnRlcnJ1cHRlZEFzRmFpbHVyZSk7XG4gICAgICAgIHRoaXMuY3VycmVudElkeCA9IC0xO1xuICAgICAgICB0aGlzLm5leHRWYWx1ZXMgPSBzb3VyY2VWYWx1ZXM7XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gdGhpcy5uZXh0VmFsdWVzLm5leHQoKTtcbiAgICAgICAgaWYgKG5leHRWYWx1ZS5kb25lIHx8IHRoaXMucnVuRXhlY3V0aW9uLmludGVycnVwdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBuZXh0VmFsdWUudmFsdWU7XG4gICAgICAgICsrdGhpcy5jdXJyZW50SWR4O1xuICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG5leHRWYWx1ZS52YWx1ZS52YWx1ZV8gfTtcbiAgICB9XG4gICAgaGFuZGxlUmVzdWx0KHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgIVByZWNvbmRpdGlvbkZhaWx1cmVfMS5QcmVjb25kaXRpb25GYWlsdXJlLmlzRmFpbHVyZShyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bkV4ZWN1dGlvbi5mYWlsKHRoaXMuY3VycmVudFZhbHVlLnZhbHVlXywgdGhpcy5jdXJyZW50SWR4LCByZXN1bHQpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50SWR4ID0gLTE7XG4gICAgICAgICAgICB0aGlzLm5leHRWYWx1ZXMgPSB0aGlzLnNocmluayh0aGlzLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghcmVzdWx0LmludGVycnVwdEV4ZWN1dGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucnVuRXhlY3V0aW9uLnNraXAodGhpcy5jdXJyZW50VmFsdWUudmFsdWVfKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZVZhbHVlcy5za2lwcGVkT25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bkV4ZWN1dGlvbi5pbnRlcnJ1cHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucnVuRXhlY3V0aW9uLnN1Y2Nlc3ModGhpcy5jdXJyZW50VmFsdWUudmFsdWVfKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUnVubmVySXRlcmF0b3IgPSBSdW5uZXJJdGVyYXRvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdGF0aXN0aWNzID0gZXhwb3J0cy5zYW1wbGUgPSB2b2lkIDA7XG5jb25zdCBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi8uLi9zdHJlYW0vU3RyZWFtXCIpO1xuY29uc3QgUHJvcGVydHlfZ2VuZXJpY18xID0gcmVxdWlyZShcIi4uL3Byb3BlcnR5L1Byb3BlcnR5LmdlbmVyaWNcIik7XG5jb25zdCBVbmJpYXNlZFByb3BlcnR5XzEgPSByZXF1aXJlKFwiLi4vcHJvcGVydHkvVW5iaWFzZWRQcm9wZXJ0eVwiKTtcbmNvbnN0IEdsb2JhbFBhcmFtZXRlcnNfMSA9IHJlcXVpcmUoXCIuL2NvbmZpZ3VyYXRpb24vR2xvYmFsUGFyYW1ldGVyc1wiKTtcbmNvbnN0IFF1YWxpZmllZFBhcmFtZXRlcnNfMSA9IHJlcXVpcmUoXCIuL2NvbmZpZ3VyYXRpb24vUXVhbGlmaWVkUGFyYW1ldGVyc1wiKTtcbmNvbnN0IFRvc3Nlcl8xID0gcmVxdWlyZShcIi4vVG9zc2VyXCIpO1xuY29uc3QgUGF0aFdhbGtlcl8xID0gcmVxdWlyZShcIi4vdXRpbHMvUGF0aFdhbGtlclwiKTtcbmZ1bmN0aW9uIHRvUHJvcGVydHkoZ2VuZXJhdG9yLCBxUGFyYW1zKSB7XG4gICAgY29uc3QgcHJvcCA9ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZ2VuZXJhdG9yLCAnaXNBc3luYycpXG4gICAgICAgID8gbmV3IFByb3BlcnR5X2dlbmVyaWNfMS5Qcm9wZXJ0eShnZW5lcmF0b3IsICgpID0+IHRydWUpXG4gICAgICAgIDogZ2VuZXJhdG9yO1xuICAgIHJldHVybiBxUGFyYW1zLnVuYmlhc2VkID09PSB0cnVlID8gbmV3IFVuYmlhc2VkUHJvcGVydHlfMS5VbmJpYXNlZFByb3BlcnR5KHByb3ApIDogcHJvcDtcbn1cbmZ1bmN0aW9uIHN0cmVhbVNhbXBsZShnZW5lcmF0b3IsIHBhcmFtcykge1xuICAgIGNvbnN0IGV4dGVuZGVkUGFyYW1zID0gdHlwZW9mIHBhcmFtcyA9PT0gJ251bWJlcidcbiAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgwLCBHbG9iYWxQYXJhbWV0ZXJzXzEucmVhZENvbmZpZ3VyZUdsb2JhbCkoKSksIHsgbnVtUnVuczogcGFyYW1zIH0pIDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoMCwgR2xvYmFsUGFyYW1ldGVyc18xLnJlYWRDb25maWd1cmVHbG9iYWwpKCkpLCBwYXJhbXMpO1xuICAgIGNvbnN0IHFQYXJhbXMgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzXzEuUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkKGV4dGVuZGVkUGFyYW1zKTtcbiAgICBjb25zdCBuZXh0UHJvcGVydHkgPSB0b1Byb3BlcnR5KGdlbmVyYXRvciwgcVBhcmFtcyk7XG4gICAgY29uc3Qgc2hyaW5rID0gbmV4dFByb3BlcnR5LnNocmluay5iaW5kKG5leHRQcm9wZXJ0eSk7XG4gICAgY29uc3QgdG9zc2VkVmFsdWVzID0gKDAsIFN0cmVhbV8xLnN0cmVhbSkoKDAsIFRvc3Nlcl8xLnRvc3MpKG5leHRQcm9wZXJ0eSwgcVBhcmFtcy5zZWVkLCBxUGFyYW1zLnJhbmRvbVR5cGUsIHFQYXJhbXMuZXhhbXBsZXMpKTtcbiAgICBpZiAocVBhcmFtcy5wYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdG9zc2VkVmFsdWVzLnRha2UocVBhcmFtcy5udW1SdW5zKS5tYXAoKHMpID0+IHMoKS52YWx1ZV8pO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIFN0cmVhbV8xLnN0cmVhbSkoKDAsIFBhdGhXYWxrZXJfMS5wYXRoV2FsaykocVBhcmFtcy5wYXRoLCB0b3NzZWRWYWx1ZXMubWFwKChzKSA9PiBzKCkpLCBzaHJpbmspKVxuICAgICAgICAudGFrZShxUGFyYW1zLm51bVJ1bnMpXG4gICAgICAgIC5tYXAoKHMpID0+IHMudmFsdWVfKTtcbn1cbmZ1bmN0aW9uIHNhbXBsZShnZW5lcmF0b3IsIHBhcmFtcykge1xuICAgIHJldHVybiBbLi4uc3RyZWFtU2FtcGxlKGdlbmVyYXRvciwgcGFyYW1zKV07XG59XG5leHBvcnRzLnNhbXBsZSA9IHNhbXBsZTtcbmZ1bmN0aW9uIHJvdW5kMihuKSB7XG4gICAgcmV0dXJuIChNYXRoLnJvdW5kKG4gKiAxMDApIC8gMTAwKS50b0ZpeGVkKDIpO1xufVxuZnVuY3Rpb24gc3RhdGlzdGljcyhnZW5lcmF0b3IsIGNsYXNzaWZ5LCBwYXJhbXMpIHtcbiAgICBjb25zdCBleHRlbmRlZFBhcmFtcyA9IHR5cGVvZiBwYXJhbXMgPT09ICdudW1iZXInXG4gICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoMCwgR2xvYmFsUGFyYW1ldGVyc18xLnJlYWRDb25maWd1cmVHbG9iYWwpKCkpLCB7IG51bVJ1bnM6IHBhcmFtcyB9KSA6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKDAsIEdsb2JhbFBhcmFtZXRlcnNfMS5yZWFkQ29uZmlndXJlR2xvYmFsKSgpKSwgcGFyYW1zKTtcbiAgICBjb25zdCBxUGFyYW1zID0gUXVhbGlmaWVkUGFyYW1ldGVyc18xLlF1YWxpZmllZFBhcmFtZXRlcnMucmVhZChleHRlbmRlZFBhcmFtcyk7XG4gICAgY29uc3QgcmVjb3JkZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGcgb2Ygc3RyZWFtU2FtcGxlKGdlbmVyYXRvciwgcGFyYW1zKSkge1xuICAgICAgICBjb25zdCBvdXQgPSBjbGFzc2lmeShnKTtcbiAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IEFycmF5LmlzQXJyYXkob3V0KSA/IG91dCA6IFtvdXRdO1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY2F0ZWdvcmllcykge1xuICAgICAgICAgICAgcmVjb3JkZWRbY10gPSAocmVjb3JkZWRbY10gfHwgMCkgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBPYmplY3QuZW50cmllcyhyZWNvcmRlZClcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKVxuICAgICAgICAubWFwKChpKSA9PiBbaVswXSwgYCR7cm91bmQyKChpWzFdICogMTAwLjApIC8gcVBhcmFtcy5udW1SdW5zKX0lYF0pO1xuICAgIGNvbnN0IGxvbmdlc3ROYW1lID0gZGF0YS5tYXAoKGkpID0+IGlbMF0ubGVuZ3RoKS5yZWR1Y2UoKHAsIGMpID0+IE1hdGgubWF4KHAsIGMpLCAwKTtcbiAgICBjb25zdCBsb25nZXN0UGVyY2VudCA9IGRhdGEubWFwKChpKSA9PiBpWzFdLmxlbmd0aCkucmVkdWNlKChwLCBjKSA9PiBNYXRoLm1heChwLCBjKSwgMCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGRhdGEpIHtcbiAgICAgICAgcVBhcmFtcy5sb2dnZXIoYCR7aXRlbVswXS5wYWRFbmQobG9uZ2VzdE5hbWUsICcuJyl9Li4ke2l0ZW1bMV0ucGFkU3RhcnQobG9uZ2VzdFBlcmNlbnQsICcuJyl9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5zdGF0aXN0aWNzID0gc3RhdGlzdGljcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Tb3VyY2VWYWx1ZXNJdGVyYXRvciA9IHZvaWQgMDtcbmNsYXNzIFNvdXJjZVZhbHVlc0l0ZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0aWFsVmFsdWVzLCBtYXhJbml0aWFsSXRlcmF0aW9ucywgcmVtYWluaW5nU2tpcHMpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVzID0gaW5pdGlhbFZhbHVlcztcbiAgICAgICAgdGhpcy5tYXhJbml0aWFsSXRlcmF0aW9ucyA9IG1heEluaXRpYWxJdGVyYXRpb25zO1xuICAgICAgICB0aGlzLnJlbWFpbmluZ1NraXBzID0gcmVtYWluaW5nU2tpcHM7XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5tYXhJbml0aWFsSXRlcmF0aW9ucyAhPT0gLTEgJiYgdGhpcy5yZW1haW5pbmdTa2lwcyA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gdGhpcy5pbml0aWFsVmFsdWVzLm5leHQoKTtcbiAgICAgICAgICAgIGlmICghbi5kb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBuLnZhbHVlKCksIGRvbmU6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbiAgICBza2lwcGVkT25lKCkge1xuICAgICAgICAtLXRoaXMucmVtYWluaW5nU2tpcHM7XG4gICAgICAgICsrdGhpcy5tYXhJbml0aWFsSXRlcmF0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLlNvdXJjZVZhbHVlc0l0ZXJhdG9yID0gU291cmNlVmFsdWVzSXRlcmF0b3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9zcyA9IHZvaWQgMDtcbmNvbnN0IHB1cmVfcmFuZF8xID0gcmVxdWlyZShcInB1cmUtcmFuZFwiKTtcbmNvbnN0IFJhbmRvbV8xID0gcmVxdWlyZShcIi4uLy4uL3JhbmRvbS9nZW5lcmF0b3IvUmFuZG9tXCIpO1xuY29uc3QgVmFsdWVfMSA9IHJlcXVpcmUoXCIuLi9hcmJpdHJhcnkvZGVmaW5pdGlvbi9WYWx1ZVwiKTtcbmZ1bmN0aW9uIGxhenlHZW5lcmF0ZShnZW5lcmF0b3IsIHJuZywgaWR4KSB7XG4gICAgcmV0dXJuICgpID0+IGdlbmVyYXRvci5nZW5lcmF0ZShuZXcgUmFuZG9tXzEuUmFuZG9tKHJuZyksIGlkeCk7XG59XG5mdW5jdGlvbiogdG9zcyhnZW5lcmF0b3IsIHNlZWQsIHJhbmRvbSwgZXhhbXBsZXMpIHtcbiAgICB5aWVsZCogZXhhbXBsZXMubWFwKChlKSA9PiAoKSA9PiBuZXcgVmFsdWVfMS5WYWx1ZShlLCB1bmRlZmluZWQpKTtcbiAgICBsZXQgaWR4ID0gMDtcbiAgICBsZXQgcm5nID0gcmFuZG9tKHNlZWQpO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgcm5nID0gcm5nLmp1bXAgPyBybmcuanVtcCgpIDogKDAsIHB1cmVfcmFuZF8xLnNraXBOKShybmcsIDQyKTtcbiAgICAgICAgeWllbGQgbGF6eUdlbmVyYXRlKGdlbmVyYXRvciwgcm5nLCBpZHgrKyk7XG4gICAgfVxufVxuZXhwb3J0cy50b3NzID0gdG9zcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXNldENvbmZpZ3VyZUdsb2JhbCA9IGV4cG9ydHMucmVhZENvbmZpZ3VyZUdsb2JhbCA9IGV4cG9ydHMuY29uZmlndXJlR2xvYmFsID0gdm9pZCAwO1xubGV0IGdsb2JhbFBhcmFtZXRlcnMgPSB7fTtcbmZ1bmN0aW9uIGNvbmZpZ3VyZUdsb2JhbChwYXJhbWV0ZXJzKSB7XG4gICAgZ2xvYmFsUGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG59XG5leHBvcnRzLmNvbmZpZ3VyZUdsb2JhbCA9IGNvbmZpZ3VyZUdsb2JhbDtcbmZ1bmN0aW9uIHJlYWRDb25maWd1cmVHbG9iYWwoKSB7XG4gICAgcmV0dXJuIGdsb2JhbFBhcmFtZXRlcnM7XG59XG5leHBvcnRzLnJlYWRDb25maWd1cmVHbG9iYWwgPSByZWFkQ29uZmlndXJlR2xvYmFsO1xuZnVuY3Rpb24gcmVzZXRDb25maWd1cmVHbG9iYWwoKSB7XG4gICAgZ2xvYmFsUGFyYW1ldGVycyA9IHt9O1xufVxuZXhwb3J0cy5yZXNldENvbmZpZ3VyZUdsb2JhbCA9IHJlc2V0Q29uZmlndXJlR2xvYmFsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlF1YWxpZmllZFBhcmFtZXRlcnMgPSB2b2lkIDA7XG5jb25zdCBwdXJlX3JhbmRfMSA9IHJlcXVpcmUoXCJwdXJlLXJhbmRcIik7XG5jb25zdCBWZXJib3NpdHlMZXZlbF8xID0gcmVxdWlyZShcIi4vVmVyYm9zaXR5TGV2ZWxcIik7XG5jbGFzcyBRdWFsaWZpZWRQYXJhbWV0ZXJzIHtcbiAgICBjb25zdHJ1Y3RvcihvcCkge1xuICAgICAgICBjb25zdCBwID0gb3AgfHwge307XG4gICAgICAgIHRoaXMuc2VlZCA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZFNlZWQocCk7XG4gICAgICAgIHRoaXMucmFuZG9tVHlwZSA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZFJhbmRvbVR5cGUocCk7XG4gICAgICAgIHRoaXMubnVtUnVucyA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZE51bVJ1bnMocCk7XG4gICAgICAgIHRoaXMudmVyYm9zZSA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZFZlcmJvc2UocCk7XG4gICAgICAgIHRoaXMubWF4U2tpcHNQZXJSdW4gPSBRdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRPckRlZmF1bHQocCwgJ21heFNraXBzUGVyUnVuJywgMTAwKTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkT3JEZWZhdWx0KHAsICd0aW1lb3V0JywgbnVsbCk7XG4gICAgICAgIHRoaXMuc2tpcEFsbEFmdGVyVGltZUxpbWl0ID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkT3JEZWZhdWx0KHAsICdza2lwQWxsQWZ0ZXJUaW1lTGltaXQnLCBudWxsKTtcbiAgICAgICAgdGhpcy5pbnRlcnJ1cHRBZnRlclRpbWVMaW1pdCA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZE9yRGVmYXVsdChwLCAnaW50ZXJydXB0QWZ0ZXJUaW1lTGltaXQnLCBudWxsKTtcbiAgICAgICAgdGhpcy5tYXJrSW50ZXJydXB0QXNGYWlsdXJlID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkQm9vbGVhbihwLCAnbWFya0ludGVycnVwdEFzRmFpbHVyZScpO1xuICAgICAgICB0aGlzLnNraXBFcXVhbFZhbHVlcyA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZEJvb2xlYW4ocCwgJ3NraXBFcXVhbFZhbHVlcycpO1xuICAgICAgICB0aGlzLmlnbm9yZUVxdWFsVmFsdWVzID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkQm9vbGVhbihwLCAnaWdub3JlRXF1YWxWYWx1ZXMnKTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRPckRlZmF1bHQocCwgJ2xvZ2dlcicsICh2KSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh2KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGF0aCA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZE9yRGVmYXVsdChwLCAncGF0aCcsICcnKTtcbiAgICAgICAgdGhpcy51bmJpYXNlZCA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZEJvb2xlYW4ocCwgJ3VuYmlhc2VkJyk7XG4gICAgICAgIHRoaXMuZXhhbXBsZXMgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRPckRlZmF1bHQocCwgJ2V4YW1wbGVzJywgW10pO1xuICAgICAgICB0aGlzLmVuZE9uRmFpbHVyZSA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZEJvb2xlYW4ocCwgJ2VuZE9uRmFpbHVyZScpO1xuICAgICAgICB0aGlzLnJlcG9ydGVyID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkT3JEZWZhdWx0KHAsICdyZXBvcnRlcicsIG51bGwpO1xuICAgICAgICB0aGlzLmFzeW5jUmVwb3J0ZXIgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRPckRlZmF1bHQocCwgJ2FzeW5jUmVwb3J0ZXInLCBudWxsKTtcbiAgICB9XG4gICAgdG9QYXJhbWV0ZXJzKCkge1xuICAgICAgICBjb25zdCBvclVuZGVmaW5lZCA9ICh2YWx1ZSkgPT4gKHZhbHVlICE9PSBudWxsID8gdmFsdWUgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VlZDogdGhpcy5zZWVkLFxuICAgICAgICAgICAgcmFuZG9tVHlwZTogdGhpcy5yYW5kb21UeXBlLFxuICAgICAgICAgICAgbnVtUnVuczogdGhpcy5udW1SdW5zLFxuICAgICAgICAgICAgbWF4U2tpcHNQZXJSdW46IHRoaXMubWF4U2tpcHNQZXJSdW4sXG4gICAgICAgICAgICB0aW1lb3V0OiBvclVuZGVmaW5lZCh0aGlzLnRpbWVvdXQpLFxuICAgICAgICAgICAgc2tpcEFsbEFmdGVyVGltZUxpbWl0OiBvclVuZGVmaW5lZCh0aGlzLnNraXBBbGxBZnRlclRpbWVMaW1pdCksXG4gICAgICAgICAgICBpbnRlcnJ1cHRBZnRlclRpbWVMaW1pdDogb3JVbmRlZmluZWQodGhpcy5pbnRlcnJ1cHRBZnRlclRpbWVMaW1pdCksXG4gICAgICAgICAgICBtYXJrSW50ZXJydXB0QXNGYWlsdXJlOiB0aGlzLm1hcmtJbnRlcnJ1cHRBc0ZhaWx1cmUsXG4gICAgICAgICAgICBza2lwRXF1YWxWYWx1ZXM6IHRoaXMuc2tpcEVxdWFsVmFsdWVzLFxuICAgICAgICAgICAgaWdub3JlRXF1YWxWYWx1ZXM6IHRoaXMuaWdub3JlRXF1YWxWYWx1ZXMsXG4gICAgICAgICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICAgICAgICBsb2dnZXI6IHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgdW5iaWFzZWQ6IHRoaXMudW5iaWFzZWQsXG4gICAgICAgICAgICB2ZXJib3NlOiB0aGlzLnZlcmJvc2UsXG4gICAgICAgICAgICBleGFtcGxlczogdGhpcy5leGFtcGxlcyxcbiAgICAgICAgICAgIGVuZE9uRmFpbHVyZTogdGhpcy5lbmRPbkZhaWx1cmUsXG4gICAgICAgICAgICByZXBvcnRlcjogb3JVbmRlZmluZWQodGhpcy5yZXBvcnRlciksXG4gICAgICAgICAgICBhc3luY1JlcG9ydGVyOiBvclVuZGVmaW5lZCh0aGlzLmFzeW5jUmVwb3J0ZXIpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgcmVhZChvcCkge1xuICAgICAgICByZXR1cm4gbmV3IFF1YWxpZmllZFBhcmFtZXRlcnMob3ApO1xuICAgIH1cbn1cbmV4cG9ydHMuUXVhbGlmaWVkUGFyYW1ldGVycyA9IFF1YWxpZmllZFBhcmFtZXRlcnM7XG5RdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRTZWVkID0gKHApID0+IHtcbiAgICBpZiAocC5zZWVkID09IG51bGwpXG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIF4gKE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMCk7XG4gICAgY29uc3Qgc2VlZDMyID0gcC5zZWVkIHwgMDtcbiAgICBpZiAocC5zZWVkID09PSBzZWVkMzIpXG4gICAgICAgIHJldHVybiBzZWVkMzI7XG4gICAgY29uc3QgZ2FwID0gcC5zZWVkIC0gc2VlZDMyO1xuICAgIHJldHVybiBzZWVkMzIgXiAoZ2FwICogMHgxMDAwMDAwMDApO1xufTtcblF1YWxpZmllZFBhcmFtZXRlcnMucmVhZFJhbmRvbVR5cGUgPSAocCkgPT4ge1xuICAgIGlmIChwLnJhbmRvbVR5cGUgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHB1cmVfcmFuZF8xLmRlZmF1bHQueG9yc2hpZnQxMjhwbHVzO1xuICAgIGlmICh0eXBlb2YgcC5yYW5kb21UeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICBzd2l0Y2ggKHAucmFuZG9tVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbWVyc2VubmUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwdXJlX3JhbmRfMS5kZWZhdWx0Lm1lcnNlbm5lO1xuICAgICAgICAgICAgY2FzZSAnY29uZ3J1ZW50aWFsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcHVyZV9yYW5kXzEuZGVmYXVsdC5jb25ncnVlbnRpYWw7XG4gICAgICAgICAgICBjYXNlICdjb25ncnVlbnRpYWwzMic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1cmVfcmFuZF8xLmRlZmF1bHQuY29uZ3J1ZW50aWFsMzI7XG4gICAgICAgICAgICBjYXNlICd4b3JzaGlmdDEyOHBsdXMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwdXJlX3JhbmRfMS5kZWZhdWx0LnhvcnNoaWZ0MTI4cGx1cztcbiAgICAgICAgICAgIGNhc2UgJ3hvcm9zaGlybzEyOHBsdXMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwdXJlX3JhbmRfMS5kZWZhdWx0Lnhvcm9zaGlybzEyOHBsdXM7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByYW5kb20gc3BlY2lmaWVkOiAnJHtwLnJhbmRvbVR5cGV9J2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwLnJhbmRvbVR5cGU7XG59O1xuUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkTnVtUnVucyA9IChwKSA9PiB7XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlID0gMTAwO1xuICAgIGlmIChwLm51bVJ1bnMgIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHAubnVtUnVucztcbiAgICBpZiAocC5udW1fcnVucyAhPSBudWxsKVxuICAgICAgICByZXR1cm4gcC5udW1fcnVucztcbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xufTtcblF1YWxpZmllZFBhcmFtZXRlcnMucmVhZFZlcmJvc2UgPSAocCkgPT4ge1xuICAgIGlmIChwLnZlcmJvc2UgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFZlcmJvc2l0eUxldmVsXzEuVmVyYm9zaXR5TGV2ZWwuTm9uZTtcbiAgICBpZiAodHlwZW9mIHAudmVyYm9zZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBwLnZlcmJvc2UgPT09IHRydWUgPyBWZXJib3NpdHlMZXZlbF8xLlZlcmJvc2l0eUxldmVsLlZlcmJvc2UgOiBWZXJib3NpdHlMZXZlbF8xLlZlcmJvc2l0eUxldmVsLk5vbmU7XG4gICAgfVxuICAgIGlmIChwLnZlcmJvc2UgPD0gVmVyYm9zaXR5TGV2ZWxfMS5WZXJib3NpdHlMZXZlbC5Ob25lKSB7XG4gICAgICAgIHJldHVybiBWZXJib3NpdHlMZXZlbF8xLlZlcmJvc2l0eUxldmVsLk5vbmU7XG4gICAgfVxuICAgIGlmIChwLnZlcmJvc2UgPj0gVmVyYm9zaXR5TGV2ZWxfMS5WZXJib3NpdHlMZXZlbC5WZXJ5VmVyYm9zZSkge1xuICAgICAgICByZXR1cm4gVmVyYm9zaXR5TGV2ZWxfMS5WZXJib3NpdHlMZXZlbC5WZXJ5VmVyYm9zZTtcbiAgICB9XG4gICAgcmV0dXJuIHAudmVyYm9zZSB8IDA7XG59O1xuUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkQm9vbGVhbiA9IChwLCBrZXkpID0+IHBba2V5XSA9PT0gdHJ1ZTtcblF1YWxpZmllZFBhcmFtZXRlcnMucmVhZE9yRGVmYXVsdCA9IChwLCBrZXksIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gcFtrZXldO1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZlcmJvc2l0eUxldmVsID0gdm9pZCAwO1xudmFyIFZlcmJvc2l0eUxldmVsO1xuKGZ1bmN0aW9uIChWZXJib3NpdHlMZXZlbCkge1xuICAgIFZlcmJvc2l0eUxldmVsW1ZlcmJvc2l0eUxldmVsW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgVmVyYm9zaXR5TGV2ZWxbVmVyYm9zaXR5TGV2ZWxbXCJWZXJib3NlXCJdID0gMV0gPSBcIlZlcmJvc2VcIjtcbiAgICBWZXJib3NpdHlMZXZlbFtWZXJib3NpdHlMZXZlbFtcIlZlcnlWZXJib3NlXCJdID0gMl0gPSBcIlZlcnlWZXJib3NlXCI7XG59KShWZXJib3NpdHlMZXZlbCA9IGV4cG9ydHMuVmVyYm9zaXR5TGV2ZWwgfHwgKGV4cG9ydHMuVmVyYm9zaXR5TGV2ZWwgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV4ZWN1dGlvblN0YXR1cyA9IHZvaWQgMDtcbnZhciBFeGVjdXRpb25TdGF0dXM7XG4oZnVuY3Rpb24gKEV4ZWN1dGlvblN0YXR1cykge1xuICAgIEV4ZWN1dGlvblN0YXR1c1tFeGVjdXRpb25TdGF0dXNbXCJTdWNjZXNzXCJdID0gMF0gPSBcIlN1Y2Nlc3NcIjtcbiAgICBFeGVjdXRpb25TdGF0dXNbRXhlY3V0aW9uU3RhdHVzW1wiU2tpcHBlZFwiXSA9IC0xXSA9IFwiU2tpcHBlZFwiO1xuICAgIEV4ZWN1dGlvblN0YXR1c1tFeGVjdXRpb25TdGF0dXNbXCJGYWlsdXJlXCJdID0gMV0gPSBcIkZhaWx1cmVcIjtcbn0pKEV4ZWN1dGlvblN0YXR1cyA9IGV4cG9ydHMuRXhlY3V0aW9uU3RhdHVzIHx8IChleHBvcnRzLkV4ZWN1dGlvblN0YXR1cyA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUnVuRXhlY3V0aW9uID0gdm9pZCAwO1xuY29uc3QgVmVyYm9zaXR5TGV2ZWxfMSA9IHJlcXVpcmUoXCIuLi9jb25maWd1cmF0aW9uL1ZlcmJvc2l0eUxldmVsXCIpO1xuY29uc3QgRXhlY3V0aW9uU3RhdHVzXzEgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25TdGF0dXNcIik7XG5jbGFzcyBSdW5FeGVjdXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHZlcmJvc2l0eSwgaW50ZXJydXB0ZWRBc0ZhaWx1cmUpIHtcbiAgICAgICAgdGhpcy52ZXJib3NpdHkgPSB2ZXJib3NpdHk7XG4gICAgICAgIHRoaXMuaW50ZXJydXB0ZWRBc0ZhaWx1cmUgPSBpbnRlcnJ1cHRlZEFzRmFpbHVyZTtcbiAgICAgICAgdGhpcy5pc1N1Y2Nlc3MgPSAoKSA9PiB0aGlzLnBhdGhUb0ZhaWx1cmUgPT0gbnVsbDtcbiAgICAgICAgdGhpcy5maXJzdEZhaWx1cmUgPSAoKSA9PiAodGhpcy5wYXRoVG9GYWlsdXJlID8gK3RoaXMucGF0aFRvRmFpbHVyZS5zcGxpdCgnOicpWzBdIDogLTEpO1xuICAgICAgICB0aGlzLm51bVNocmlua3MgPSAoKSA9PiAodGhpcy5wYXRoVG9GYWlsdXJlID8gdGhpcy5wYXRoVG9GYWlsdXJlLnNwbGl0KCc6JykubGVuZ3RoIC0gMSA6IDApO1xuICAgICAgICB0aGlzLnJvb3RFeGVjdXRpb25UcmVlcyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbEV4ZWN1dGlvblRyZWVzID0gdGhpcy5yb290RXhlY3V0aW9uVHJlZXM7XG4gICAgICAgIHRoaXMuZmFpbHVyZSA9IG51bGw7XG4gICAgICAgIHRoaXMubnVtU2tpcHMgPSAwO1xuICAgICAgICB0aGlzLm51bVN1Y2Nlc3NlcyA9IDA7XG4gICAgICAgIHRoaXMuaW50ZXJydXB0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgYXBwZW5kRXhlY3V0aW9uVHJlZShzdGF0dXMsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUcmVlID0geyBzdGF0dXMsIHZhbHVlLCBjaGlsZHJlbjogW10gfTtcbiAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWxFeGVjdXRpb25UcmVlcy5wdXNoKGN1cnJlbnRUcmVlKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRUcmVlO1xuICAgIH1cbiAgICBmYWlsKHZhbHVlLCBpZCwgZmFpbHVyZSkge1xuICAgICAgICBpZiAodGhpcy52ZXJib3NpdHkgPj0gVmVyYm9zaXR5TGV2ZWxfMS5WZXJib3NpdHlMZXZlbC5WZXJib3NlKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VHJlZSA9IHRoaXMuYXBwZW5kRXhlY3V0aW9uVHJlZShFeGVjdXRpb25TdGF0dXNfMS5FeGVjdXRpb25TdGF0dXMuRmFpbHVyZSwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWxFeGVjdXRpb25UcmVlcyA9IGN1cnJlbnRUcmVlLmNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhdGhUb0ZhaWx1cmUgPT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMucGF0aFRvRmFpbHVyZSA9IGAke2lkfWA7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucGF0aFRvRmFpbHVyZSArPSBgOiR7aWR9YDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmZhaWx1cmUgPSBmYWlsdXJlO1xuICAgIH1cbiAgICBza2lwKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnZlcmJvc2l0eSA+PSBWZXJib3NpdHlMZXZlbF8xLlZlcmJvc2l0eUxldmVsLlZlcnlWZXJib3NlKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZEV4ZWN1dGlvblRyZWUoRXhlY3V0aW9uU3RhdHVzXzEuRXhlY3V0aW9uU3RhdHVzLlNraXBwZWQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXRoVG9GYWlsdXJlID09IG51bGwpIHtcbiAgICAgICAgICAgICsrdGhpcy5udW1Ta2lwcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWNjZXNzKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnZlcmJvc2l0eSA+PSBWZXJib3NpdHlMZXZlbF8xLlZlcmJvc2l0eUxldmVsLlZlcnlWZXJib3NlKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZEV4ZWN1dGlvblRyZWUoRXhlY3V0aW9uU3RhdHVzXzEuRXhlY3V0aW9uU3RhdHVzLlN1Y2Nlc3MsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXRoVG9GYWlsdXJlID09IG51bGwpIHtcbiAgICAgICAgICAgICsrdGhpcy5udW1TdWNjZXNzZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW50ZXJydXB0KCkge1xuICAgICAgICB0aGlzLmludGVycnVwdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZXh0cmFjdEZhaWx1cmVzKCkge1xuICAgICAgICBpZiAodGhpcy5pc1N1Y2Nlc3MoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZhaWx1cmVzID0gW107XG4gICAgICAgIGxldCBjdXJzb3IgPSB0aGlzLnJvb3RFeGVjdXRpb25UcmVlcztcbiAgICAgICAgd2hpbGUgKGN1cnNvci5sZW5ndGggPiAwICYmIGN1cnNvcltjdXJzb3IubGVuZ3RoIC0gMV0uc3RhdHVzID09PSBFeGVjdXRpb25TdGF0dXNfMS5FeGVjdXRpb25TdGF0dXMuRmFpbHVyZSkge1xuICAgICAgICAgICAgY29uc3QgZmFpbHVyZVRyZWUgPSBjdXJzb3JbY3Vyc29yLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgZmFpbHVyZXMucHVzaChmYWlsdXJlVHJlZS52YWx1ZSk7XG4gICAgICAgICAgICBjdXJzb3IgPSBmYWlsdXJlVHJlZS5jaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFpbHVyZXM7XG4gICAgfVxuICAgIHRvUnVuRGV0YWlscyhzZWVkLCBiYXNlUGF0aCwgbWF4U2tpcHMsIHFQYXJhbXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3VjY2VzcygpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZhaWxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnRlcnJ1cHRlZDogdGhpcy5pbnRlcnJ1cHRlZCxcbiAgICAgICAgICAgICAgICBudW1SdW5zOiB0aGlzLmZpcnN0RmFpbHVyZSgpICsgMSAtIHRoaXMubnVtU2tpcHMsXG4gICAgICAgICAgICAgICAgbnVtU2tpcHM6IHRoaXMubnVtU2tpcHMsXG4gICAgICAgICAgICAgICAgbnVtU2hyaW5rczogdGhpcy5udW1TaHJpbmtzKCksXG4gICAgICAgICAgICAgICAgc2VlZCxcbiAgICAgICAgICAgICAgICBjb3VudGVyZXhhbXBsZTogdGhpcy52YWx1ZSxcbiAgICAgICAgICAgICAgICBjb3VudGVyZXhhbXBsZVBhdGg6IFJ1bkV4ZWN1dGlvbi5tZXJnZVBhdGhzKGJhc2VQYXRoLCB0aGlzLnBhdGhUb0ZhaWx1cmUpLFxuICAgICAgICAgICAgICAgIGVycm9yOiB0aGlzLmZhaWx1cmUuZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgICAgIGVycm9ySW5zdGFuY2U6IHRoaXMuZmFpbHVyZS5lcnJvcixcbiAgICAgICAgICAgICAgICBmYWlsdXJlczogdGhpcy5leHRyYWN0RmFpbHVyZXMoKSxcbiAgICAgICAgICAgICAgICBleGVjdXRpb25TdW1tYXJ5OiB0aGlzLnJvb3RFeGVjdXRpb25UcmVlcyxcbiAgICAgICAgICAgICAgICB2ZXJib3NlOiB0aGlzLnZlcmJvc2l0eSxcbiAgICAgICAgICAgICAgICBydW5Db25maWd1cmF0aW9uOiBxUGFyYW1zLnRvUGFyYW1ldGVycygpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmYWlsZWQgPSB0aGlzLm51bVNraXBzID4gbWF4U2tpcHMgfHwgKHRoaXMuaW50ZXJydXB0ZWQgJiYgdGhpcy5pbnRlcnJ1cHRlZEFzRmFpbHVyZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmYWlsZWQsXG4gICAgICAgICAgICBpbnRlcnJ1cHRlZDogdGhpcy5pbnRlcnJ1cHRlZCxcbiAgICAgICAgICAgIG51bVJ1bnM6IHRoaXMubnVtU3VjY2Vzc2VzLFxuICAgICAgICAgICAgbnVtU2tpcHM6IHRoaXMubnVtU2tpcHMsXG4gICAgICAgICAgICBudW1TaHJpbmtzOiAwLFxuICAgICAgICAgICAgc2VlZCxcbiAgICAgICAgICAgIGNvdW50ZXJleGFtcGxlOiBudWxsLFxuICAgICAgICAgICAgY291bnRlcmV4YW1wbGVQYXRoOiBudWxsLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICBlcnJvckluc3RhbmNlOiBudWxsLFxuICAgICAgICAgICAgZmFpbHVyZXM6IFtdLFxuICAgICAgICAgICAgZXhlY3V0aW9uU3VtbWFyeTogdGhpcy5yb290RXhlY3V0aW9uVHJlZXMsXG4gICAgICAgICAgICB2ZXJib3NlOiB0aGlzLnZlcmJvc2l0eSxcbiAgICAgICAgICAgIHJ1bkNvbmZpZ3VyYXRpb246IHFQYXJhbXMudG9QYXJhbWV0ZXJzKCksXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5SdW5FeGVjdXRpb24gPSBSdW5FeGVjdXRpb247XG5SdW5FeGVjdXRpb24ubWVyZ2VQYXRocyA9IChvZmZzZXRQYXRoLCBwYXRoKSA9PiB7XG4gICAgaWYgKG9mZnNldFBhdGgubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICBjb25zdCBvZmZzZXRJdGVtcyA9IG9mZnNldFBhdGguc3BsaXQoJzonKTtcbiAgICBjb25zdCByZW1haW5pbmdJdGVtcyA9IHBhdGguc3BsaXQoJzonKTtcbiAgICBjb25zdCBtaWRkbGUgPSArb2Zmc2V0SXRlbXNbb2Zmc2V0SXRlbXMubGVuZ3RoIC0gMV0gKyArcmVtYWluaW5nSXRlbXNbMF07XG4gICAgcmV0dXJuIFsuLi5vZmZzZXRJdGVtcy5zbGljZSgwLCBvZmZzZXRJdGVtcy5sZW5ndGggLSAxKSwgYCR7bWlkZGxlfWAsIC4uLnJlbWFpbmluZ0l0ZW1zLnNsaWNlKDEpXS5qb2luKCc6Jyk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhdGhXYWxrID0gdm9pZCAwO1xuY29uc3QgU3RyZWFtXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vc3RyZWFtL1N0cmVhbVwiKTtcbmZ1bmN0aW9uIHBhdGhXYWxrKHBhdGgsIGluaXRpYWxWYWx1ZXMsIHNocmluaykge1xuICAgIGxldCB2YWx1ZXMgPSAoMCwgU3RyZWFtXzEuc3RyZWFtKShpbml0aWFsVmFsdWVzKTtcbiAgICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoJzonKS5tYXAoKHRleHQpID0+ICt0ZXh0KTtcbiAgICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIGlmICghc2VnbWVudHMuZXZlcnkoKHYpID0+ICFOdW1iZXIuaXNOYU4odikpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHJlcGxheSwgZ290IGludmFsaWQgcGF0aD0ke3BhdGh9YCk7XG4gICAgfVxuICAgIHZhbHVlcyA9IHZhbHVlcy5kcm9wKHNlZ21lbnRzWzBdKTtcbiAgICBmb3IgKGNvbnN0IHMgb2Ygc2VnbWVudHMuc2xpY2UoMSkpIHtcbiAgICAgICAgY29uc3QgdmFsdWVUb1NocmluayA9IHZhbHVlcy5nZXROdGhPckxhc3QoMCk7XG4gICAgICAgIGlmICh2YWx1ZVRvU2hyaW5rID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHJlcGxheSwgZ290IHdyb25nIHBhdGg9JHtwYXRofWApO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlcyA9IHNocmluayh2YWx1ZVRvU2hyaW5rKS5kcm9wKHMpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuZXhwb3J0cy5wYXRoV2FsayA9IHBhdGhXYWxrO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzeW5jRGVmYXVsdFJlcG9ydE1lc3NhZ2UgPSBleHBvcnRzLmRlZmF1bHRSZXBvcnRNZXNzYWdlID0gZXhwb3J0cy5hc3luY1JlcG9ydFJ1bkRldGFpbHMgPSBleHBvcnRzLnJlcG9ydFJ1bkRldGFpbHMgPSB2b2lkIDA7XG5jb25zdCBzdHJpbmdpZnlfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9zdHJpbmdpZnlcIik7XG5jb25zdCBWZXJib3NpdHlMZXZlbF8xID0gcmVxdWlyZShcIi4uL2NvbmZpZ3VyYXRpb24vVmVyYm9zaXR5TGV2ZWxcIik7XG5jb25zdCBFeGVjdXRpb25TdGF0dXNfMSA9IHJlcXVpcmUoXCIuLi9yZXBvcnRlci9FeGVjdXRpb25TdGF0dXNcIik7XG5mdW5jdGlvbiBmb3JtYXRIaW50cyhoaW50cykge1xuICAgIGlmIChoaW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGBIaW50OiAke2hpbnRzWzBdfWA7XG4gICAgfVxuICAgIHJldHVybiBoaW50cy5tYXAoKGgsIGlkeCkgPT4gYEhpbnQgKCR7aWR4ICsgMX0pOiAke2h9YCkuam9pbignXFxuJyk7XG59XG5mdW5jdGlvbiBmb3JtYXRGYWlsdXJlcyhmYWlsdXJlcywgc3RyaW5naWZ5T25lKSB7XG4gICAgcmV0dXJuIGBFbmNvdW50ZXJlZCBmYWlsdXJlcyB3ZXJlOlxcbi0gJHtmYWlsdXJlcy5tYXAoc3RyaW5naWZ5T25lKS5qb2luKCdcXG4tICcpfWA7XG59XG5mdW5jdGlvbiBmb3JtYXRFeGVjdXRpb25TdW1tYXJ5KGV4ZWN1dGlvblRyZWVzLCBzdHJpbmdpZnlPbmUpIHtcbiAgICBjb25zdCBzdW1tYXJ5TGluZXMgPSBbXTtcbiAgICBjb25zdCByZW1haW5pbmdUcmVlc0FuZERlcHRoID0gW107XG4gICAgZm9yIChjb25zdCB0cmVlIG9mIGV4ZWN1dGlvblRyZWVzLnNsaWNlKCkucmV2ZXJzZSgpKSB7XG4gICAgICAgIHJlbWFpbmluZ1RyZWVzQW5kRGVwdGgucHVzaCh7IGRlcHRoOiAxLCB0cmVlIH0pO1xuICAgIH1cbiAgICB3aGlsZSAocmVtYWluaW5nVHJlZXNBbmREZXB0aC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgY29uc3QgY3VycmVudFRyZWVBbmREZXB0aCA9IHJlbWFpbmluZ1RyZWVzQW5kRGVwdGgucG9wKCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUcmVlID0gY3VycmVudFRyZWVBbmREZXB0aC50cmVlO1xuICAgICAgICBjb25zdCBjdXJyZW50RGVwdGggPSBjdXJyZW50VHJlZUFuZERlcHRoLmRlcHRoO1xuICAgICAgICBjb25zdCBzdGF0dXNJY29uID0gY3VycmVudFRyZWUuc3RhdHVzID09PSBFeGVjdXRpb25TdGF0dXNfMS5FeGVjdXRpb25TdGF0dXMuU3VjY2Vzc1xuICAgICAgICAgICAgPyAnXFx4MWJbMzJtXFx1MjIxQVxceDFiWzBtJ1xuICAgICAgICAgICAgOiBjdXJyZW50VHJlZS5zdGF0dXMgPT09IEV4ZWN1dGlvblN0YXR1c18xLkV4ZWN1dGlvblN0YXR1cy5GYWlsdXJlXG4gICAgICAgICAgICAgICAgPyAnXFx4MWJbMzFtXFx4RDdcXHgxYlswbSdcbiAgICAgICAgICAgICAgICA6ICdcXHgxYlszM20hXFx4MWJbMG0nO1xuICAgICAgICBjb25zdCBsZWZ0UGFkZGluZyA9IEFycmF5KGN1cnJlbnREZXB0aCkuam9pbignLiAnKTtcbiAgICAgICAgc3VtbWFyeUxpbmVzLnB1c2goYCR7bGVmdFBhZGRpbmd9JHtzdGF0dXNJY29ufSAke3N0cmluZ2lmeU9uZShjdXJyZW50VHJlZS52YWx1ZSl9YCk7XG4gICAgICAgIGZvciAoY29uc3QgdHJlZSBvZiBjdXJyZW50VHJlZS5jaGlsZHJlbi5zbGljZSgpLnJldmVyc2UoKSkge1xuICAgICAgICAgICAgcmVtYWluaW5nVHJlZXNBbmREZXB0aC5wdXNoKHsgZGVwdGg6IGN1cnJlbnREZXB0aCArIDEsIHRyZWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGBFeGVjdXRpb24gc3VtbWFyeTpcXG4ke3N1bW1hcnlMaW5lcy5qb2luKCdcXG4nKX1gO1xufVxuZnVuY3Rpb24gcHJlRm9ybWF0VG9vTWFueVNraXBwZWQob3V0LCBzdHJpbmdpZnlPbmUpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYEZhaWxlZCB0byBydW4gcHJvcGVydHksIHRvbyBtYW55IHByZS1jb25kaXRpb24gZmFpbHVyZXMgZW5jb3VudGVyZWRcXG57IHNlZWQ6ICR7b3V0LnNlZWR9IH1cXG5cXG5SYW4gJHtvdXQubnVtUnVuc30gdGltZShzKVxcblNraXBwZWQgJHtvdXQubnVtU2tpcHN9IHRpbWUocylgO1xuICAgIGxldCBkZXRhaWxzID0gbnVsbDtcbiAgICBjb25zdCBoaW50cyA9IFtcbiAgICAgICAgJ1RyeSB0byByZWR1Y2UgdGhlIG51bWJlciBvZiByZWplY3RlZCB2YWx1ZXMgYnkgY29tYmluaW5nIG1hcCwgZmxhdE1hcCBhbmQgYnVpbHQtaW4gYXJiaXRyYXJpZXMnLFxuICAgICAgICAnSW5jcmVhc2UgZmFpbHVyZSB0b2xlcmFuY2UgYnkgc2V0dGluZyBtYXhTa2lwc1BlclJ1biB0byBhbiBoaWdoZXIgdmFsdWUnLFxuICAgIF07XG4gICAgaWYgKG91dC52ZXJib3NlID49IFZlcmJvc2l0eUxldmVsXzEuVmVyYm9zaXR5TGV2ZWwuVmVyeVZlcmJvc2UpIHtcbiAgICAgICAgZGV0YWlscyA9IGZvcm1hdEV4ZWN1dGlvblN1bW1hcnkob3V0LmV4ZWN1dGlvblN1bW1hcnksIHN0cmluZ2lmeU9uZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBoaW50cy5wdXNoKCdFbmFibGUgdmVyYm9zZSBtb2RlIGF0IGxldmVsIFZlcnlWZXJib3NlIGluIG9yZGVyIHRvIGNoZWNrIGFsbCBnZW5lcmF0ZWQgdmFsdWVzIGFuZCB0aGVpciBhc3NvY2lhdGVkIHN0YXR1cycpO1xuICAgIH1cbiAgICByZXR1cm4geyBtZXNzYWdlLCBkZXRhaWxzLCBoaW50cyB9O1xufVxuZnVuY3Rpb24gcHJlRm9ybWF0RmFpbHVyZShvdXQsIHN0cmluZ2lmeU9uZSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgUHJvcGVydHkgZmFpbGVkIGFmdGVyICR7b3V0Lm51bVJ1bnN9IHRlc3RzXFxueyBzZWVkOiAke291dC5zZWVkfSwgcGF0aDogXCIke291dC5jb3VudGVyZXhhbXBsZVBhdGh9XCIsIGVuZE9uRmFpbHVyZTogdHJ1ZSB9XFxuQ291bnRlcmV4YW1wbGU6ICR7c3RyaW5naWZ5T25lKG91dC5jb3VudGVyZXhhbXBsZSl9XFxuU2hydW5rICR7b3V0Lm51bVNocmlua3N9IHRpbWUocylcXG5Hb3QgZXJyb3I6ICR7b3V0LmVycm9yfWA7XG4gICAgbGV0IGRldGFpbHMgPSBudWxsO1xuICAgIGNvbnN0IGhpbnRzID0gW107XG4gICAgaWYgKG91dC52ZXJib3NlID49IFZlcmJvc2l0eUxldmVsXzEuVmVyYm9zaXR5TGV2ZWwuVmVyeVZlcmJvc2UpIHtcbiAgICAgICAgZGV0YWlscyA9IGZvcm1hdEV4ZWN1dGlvblN1bW1hcnkob3V0LmV4ZWN1dGlvblN1bW1hcnksIHN0cmluZ2lmeU9uZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG91dC52ZXJib3NlID09PSBWZXJib3NpdHlMZXZlbF8xLlZlcmJvc2l0eUxldmVsLlZlcmJvc2UpIHtcbiAgICAgICAgZGV0YWlscyA9IGZvcm1hdEZhaWx1cmVzKG91dC5mYWlsdXJlcywgc3RyaW5naWZ5T25lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGhpbnRzLnB1c2goJ0VuYWJsZSB2ZXJib3NlIG1vZGUgaW4gb3JkZXIgdG8gaGF2ZSB0aGUgbGlzdCBvZiBhbGwgZmFpbGluZyB2YWx1ZXMgZW5jb3VudGVyZWQgZHVyaW5nIHRoZSBydW4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWVzc2FnZSwgZGV0YWlscywgaGludHMgfTtcbn1cbmZ1bmN0aW9uIHByZUZvcm1hdEVhcmx5SW50ZXJydXB0ZWQob3V0LCBzdHJpbmdpZnlPbmUpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYFByb3BlcnR5IGludGVycnVwdGVkIGFmdGVyICR7b3V0Lm51bVJ1bnN9IHRlc3RzXFxueyBzZWVkOiAke291dC5zZWVkfSB9YDtcbiAgICBsZXQgZGV0YWlscyA9IG51bGw7XG4gICAgY29uc3QgaGludHMgPSBbXTtcbiAgICBpZiAob3V0LnZlcmJvc2UgPj0gVmVyYm9zaXR5TGV2ZWxfMS5WZXJib3NpdHlMZXZlbC5WZXJ5VmVyYm9zZSkge1xuICAgICAgICBkZXRhaWxzID0gZm9ybWF0RXhlY3V0aW9uU3VtbWFyeShvdXQuZXhlY3V0aW9uU3VtbWFyeSwgc3RyaW5naWZ5T25lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGhpbnRzLnB1c2goJ0VuYWJsZSB2ZXJib3NlIG1vZGUgYXQgbGV2ZWwgVmVyeVZlcmJvc2UgaW4gb3JkZXIgdG8gY2hlY2sgYWxsIGdlbmVyYXRlZCB2YWx1ZXMgYW5kIHRoZWlyIGFzc29jaWF0ZWQgc3RhdHVzJyk7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2UsIGRldGFpbHMsIGhpbnRzIH07XG59XG5mdW5jdGlvbiBkZWZhdWx0UmVwb3J0TWVzc2FnZUludGVybmFsKG91dCwgc3RyaW5naWZ5T25lKSB7XG4gICAgaWYgKCFvdXQuZmFpbGVkKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgeyBtZXNzYWdlLCBkZXRhaWxzLCBoaW50cyB9ID0gb3V0LmNvdW50ZXJleGFtcGxlUGF0aCA9PT0gbnVsbFxuICAgICAgICA/IG91dC5pbnRlcnJ1cHRlZFxuICAgICAgICAgICAgPyBwcmVGb3JtYXRFYXJseUludGVycnVwdGVkKG91dCwgc3RyaW5naWZ5T25lKVxuICAgICAgICAgICAgOiBwcmVGb3JtYXRUb29NYW55U2tpcHBlZChvdXQsIHN0cmluZ2lmeU9uZSlcbiAgICAgICAgOiBwcmVGb3JtYXRGYWlsdXJlKG91dCwgc3RyaW5naWZ5T25lKTtcbiAgICBsZXQgZXJyb3JNZXNzYWdlID0gbWVzc2FnZTtcbiAgICBpZiAoZGV0YWlscyAhPSBudWxsKVxuICAgICAgICBlcnJvck1lc3NhZ2UgKz0gYFxcblxcbiR7ZGV0YWlsc31gO1xuICAgIGlmIChoaW50cy5sZW5ndGggPiAwKVxuICAgICAgICBlcnJvck1lc3NhZ2UgKz0gYFxcblxcbiR7Zm9ybWF0SGludHMoaGludHMpfWA7XG4gICAgcmV0dXJuIGVycm9yTWVzc2FnZTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRSZXBvcnRNZXNzYWdlKG91dCkge1xuICAgIHJldHVybiBkZWZhdWx0UmVwb3J0TWVzc2FnZUludGVybmFsKG91dCwgc3RyaW5naWZ5XzEuc3RyaW5naWZ5KTtcbn1cbmV4cG9ydHMuZGVmYXVsdFJlcG9ydE1lc3NhZ2UgPSBkZWZhdWx0UmVwb3J0TWVzc2FnZTtcbmFzeW5jIGZ1bmN0aW9uIGFzeW5jRGVmYXVsdFJlcG9ydE1lc3NhZ2Uob3V0KSB7XG4gICAgY29uc3QgcGVuZGluZ1N0cmluZ2lmaWVkcyA9IFtdO1xuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeU9uZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBzdHJpbmdpZmllZCA9ICgwLCBzdHJpbmdpZnlfMS5wb3NzaWJseUFzeW5jU3RyaW5naWZ5KSh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyaW5naWZpZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZpZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGVuZGluZ1N0cmluZ2lmaWVkcy5wdXNoKFByb21pc2UuYWxsKFt2YWx1ZSwgc3RyaW5naWZpZWRdKSk7XG4gICAgICAgIHJldHVybiAnXFx1MjAyNic7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0VHJ5TWVzc2FnZSA9IGRlZmF1bHRSZXBvcnRNZXNzYWdlSW50ZXJuYWwob3V0LCBzdHJpbmdpZnlPbmUpO1xuICAgIGlmIChwZW5kaW5nU3RyaW5naWZpZWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmlyc3RUcnlNZXNzYWdlO1xuICAgIH1cbiAgICBjb25zdCByZWdpc3RlcmVkVmFsdWVzID0gbmV3IE1hcChhd2FpdCBQcm9taXNlLmFsbChwZW5kaW5nU3RyaW5naWZpZWRzKSk7XG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5U2Vjb25kKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGFzeW5jU3RyaW5naWZpZWRJZlJlZ2lzdGVyZWQgPSByZWdpc3RlcmVkVmFsdWVzLmdldCh2YWx1ZSk7XG4gICAgICAgIGlmIChhc3luY1N0cmluZ2lmaWVkSWZSZWdpc3RlcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3luY1N0cmluZ2lmaWVkSWZSZWdpc3RlcmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgc3RyaW5naWZ5XzEuc3RyaW5naWZ5KSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0UmVwb3J0TWVzc2FnZUludGVybmFsKG91dCwgc3RyaW5naWZ5U2Vjb25kKTtcbn1cbmV4cG9ydHMuYXN5bmNEZWZhdWx0UmVwb3J0TWVzc2FnZSA9IGFzeW5jRGVmYXVsdFJlcG9ydE1lc3NhZ2U7XG5mdW5jdGlvbiB0aHJvd0lmRmFpbGVkKG91dCkge1xuICAgIGlmICghb3V0LmZhaWxlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHRocm93IG5ldyBFcnJvcihkZWZhdWx0UmVwb3J0TWVzc2FnZShvdXQpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFzeW5jVGhyb3dJZkZhaWxlZChvdXQpIHtcbiAgICBpZiAoIW91dC5mYWlsZWQpXG4gICAgICAgIHJldHVybjtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYXdhaXQgYXN5bmNEZWZhdWx0UmVwb3J0TWVzc2FnZShvdXQpKTtcbn1cbmZ1bmN0aW9uIHJlcG9ydFJ1bkRldGFpbHMob3V0KSB7XG4gICAgaWYgKG91dC5ydW5Db25maWd1cmF0aW9uLmFzeW5jUmVwb3J0ZXIpXG4gICAgICAgIHJldHVybiBvdXQucnVuQ29uZmlndXJhdGlvbi5hc3luY1JlcG9ydGVyKG91dCk7XG4gICAgZWxzZSBpZiAob3V0LnJ1bkNvbmZpZ3VyYXRpb24ucmVwb3J0ZXIpXG4gICAgICAgIHJldHVybiBvdXQucnVuQ29uZmlndXJhdGlvbi5yZXBvcnRlcihvdXQpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHRocm93SWZGYWlsZWQob3V0KTtcbn1cbmV4cG9ydHMucmVwb3J0UnVuRGV0YWlscyA9IHJlcG9ydFJ1bkRldGFpbHM7XG5hc3luYyBmdW5jdGlvbiBhc3luY1JlcG9ydFJ1bkRldGFpbHMob3V0KSB7XG4gICAgaWYgKG91dC5ydW5Db25maWd1cmF0aW9uLmFzeW5jUmVwb3J0ZXIpXG4gICAgICAgIHJldHVybiBvdXQucnVuQ29uZmlndXJhdGlvbi5hc3luY1JlcG9ydGVyKG91dCk7XG4gICAgZWxzZSBpZiAob3V0LnJ1bkNvbmZpZ3VyYXRpb24ucmVwb3J0ZXIpXG4gICAgICAgIHJldHVybiBvdXQucnVuQ29uZmlndXJhdGlvbi5yZXBvcnRlcihvdXQpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGFzeW5jVGhyb3dJZkZhaWxlZChvdXQpO1xufVxuZXhwb3J0cy5hc3luY1JlcG9ydFJ1bkRldGFpbHMgPSBhc3luY1JlcG9ydFJ1bkRldGFpbHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2xvbmVJZk5lZWRlZCA9IGV4cG9ydHMuaGFzQ2xvbmVNZXRob2QgPSBleHBvcnRzLmNsb25lTWV0aG9kID0gdm9pZCAwO1xuZXhwb3J0cy5jbG9uZU1ldGhvZCA9IFN5bWJvbCgnZmFzdC1jaGVjay9jbG9uZU1ldGhvZCcpO1xuZnVuY3Rpb24gaGFzQ2xvbmVNZXRob2QoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gKGluc3RhbmNlICE9PSBudWxsICYmXG4gICAgICAgICh0eXBlb2YgaW5zdGFuY2UgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBpbnN0YW5jZSA9PT0gJ2Z1bmN0aW9uJykgJiZcbiAgICAgICAgZXhwb3J0cy5jbG9uZU1ldGhvZCBpbiBpbnN0YW5jZSAmJlxuICAgICAgICB0eXBlb2YgaW5zdGFuY2VbZXhwb3J0cy5jbG9uZU1ldGhvZF0gPT09ICdmdW5jdGlvbicpO1xufVxuZXhwb3J0cy5oYXNDbG9uZU1ldGhvZCA9IGhhc0Nsb25lTWV0aG9kO1xuZnVuY3Rpb24gY2xvbmVJZk5lZWRlZChpbnN0YW5jZSkge1xuICAgIHJldHVybiBoYXNDbG9uZU1ldGhvZChpbnN0YW5jZSkgPyBpbnN0YW5jZVtleHBvcnRzLmNsb25lTWV0aG9kXSgpIDogaW5zdGFuY2U7XG59XG5leHBvcnRzLmNsb25lSWZOZWVkZWQgPSBjbG9uZUlmTmVlZGVkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNwYXJzZUFycmF5ID0gZXhwb3J0cy5hcnJheSA9IGV4cG9ydHMuc3ViYXJyYXkgPSBleHBvcnRzLnNodWZmbGVkU3ViYXJyYXkgPSBleHBvcnRzLmNsb25lID0gZXhwb3J0cy5vbmVvZiA9IGV4cG9ydHMub3B0aW9uID0gZXhwb3J0cy5tYXBUb0NvbnN0YW50ID0gZXhwb3J0cy5jb25zdGFudEZyb20gPSBleHBvcnRzLmNvbnN0YW50ID0gZXhwb3J0cy5sb3JlbSA9IGV4cG9ydHMuYmFzZTY0U3RyaW5nID0gZXhwb3J0cy5oZXhhU3RyaW5nID0gZXhwb3J0cy5mdWxsVW5pY29kZVN0cmluZyA9IGV4cG9ydHMudW5pY29kZVN0cmluZyA9IGV4cG9ydHMuc3RyaW5nT2YgPSBleHBvcnRzLnN0cmluZzE2Yml0cyA9IGV4cG9ydHMuYXNjaWlTdHJpbmcgPSBleHBvcnRzLnN0cmluZyA9IGV4cG9ydHMubWl4ZWRDYXNlID0gZXhwb3J0cy5iYXNlNjQgPSBleHBvcnRzLmhleGEgPSBleHBvcnRzLmZ1bGxVbmljb2RlID0gZXhwb3J0cy51bmljb2RlID0gZXhwb3J0cy5jaGFyMTZiaXRzID0gZXhwb3J0cy5hc2NpaSA9IGV4cG9ydHMuY2hhciA9IGV4cG9ydHMuYmlnVWludCA9IGV4cG9ydHMuYmlnSW50ID0gZXhwb3J0cy5iaWdVaW50TiA9IGV4cG9ydHMuYmlnSW50TiA9IGV4cG9ydHMubWF4U2FmZU5hdCA9IGV4cG9ydHMubWF4U2FmZUludGVnZXIgPSBleHBvcnRzLm5hdCA9IGV4cG9ydHMuaW50ZWdlciA9IGV4cG9ydHMuZG91YmxlID0gZXhwb3J0cy5mbG9hdCA9IGV4cG9ydHMuZmFsc3kgPSBleHBvcnRzLmJvb2xlYW4gPSBleHBvcnRzLmFzeW5jUHJvcGVydHkgPSBleHBvcnRzLnByb3BlcnR5ID0gZXhwb3J0cy5QcmVjb25kaXRpb25GYWlsdXJlID0gZXhwb3J0cy5wcmUgPSBleHBvcnRzLmFzc2VydCA9IGV4cG9ydHMuY2hlY2sgPSBleHBvcnRzLnN0YXRpc3RpY3MgPSBleHBvcnRzLnNhbXBsZSA9IGV4cG9ydHMuX19jb21taXRIYXNoID0gZXhwb3J0cy5fX3ZlcnNpb24gPSBleHBvcnRzLl9fdHlwZSA9IHZvaWQgMDtcbmV4cG9ydHMuY2xvbmVNZXRob2QgPSBleHBvcnRzLlZhbHVlID0gZXhwb3J0cy5BcmJpdHJhcnkgPSBleHBvcnRzLnNjaGVkdWxlckZvciA9IGV4cG9ydHMuc2NoZWR1bGVyID0gZXhwb3J0cy5jb21tYW5kcyA9IGV4cG9ydHMuc2NoZWR1bGVkTW9kZWxSdW4gPSBleHBvcnRzLm1vZGVsUnVuID0gZXhwb3J0cy5hc3luY01vZGVsUnVuID0gZXhwb3J0cy5iaWdVaW50NjRBcnJheSA9IGV4cG9ydHMuYmlnSW50NjRBcnJheSA9IGV4cG9ydHMuZmxvYXQ2NEFycmF5ID0gZXhwb3J0cy5mbG9hdDMyQXJyYXkgPSBleHBvcnRzLnVpbnQzMkFycmF5ID0gZXhwb3J0cy5pbnQzMkFycmF5ID0gZXhwb3J0cy51aW50MTZBcnJheSA9IGV4cG9ydHMuaW50MTZBcnJheSA9IGV4cG9ydHMudWludDhDbGFtcGVkQXJyYXkgPSBleHBvcnRzLnVpbnQ4QXJyYXkgPSBleHBvcnRzLmludDhBcnJheSA9IGV4cG9ydHMudXVpZFYgPSBleHBvcnRzLnV1aWQgPSBleHBvcnRzLmVtYWlsQWRkcmVzcyA9IGV4cG9ydHMud2ViVXJsID0gZXhwb3J0cy53ZWJRdWVyeVBhcmFtZXRlcnMgPSBleHBvcnRzLndlYkZyYWdtZW50cyA9IGV4cG9ydHMud2ViU2VnbWVudCA9IGV4cG9ydHMud2ViQXV0aG9yaXR5ID0gZXhwb3J0cy5kb21haW4gPSBleHBvcnRzLmlwVjYgPSBleHBvcnRzLmlwVjRFeHRlbmRlZCA9IGV4cG9ydHMuaXBWNCA9IGV4cG9ydHMuZGF0ZSA9IGV4cG9ydHMuY29udGV4dCA9IGV4cG9ydHMuZnVuYyA9IGV4cG9ydHMuY29tcGFyZUZ1bmMgPSBleHBvcnRzLmNvbXBhcmVCb29sZWFuRnVuYyA9IGV4cG9ydHMubWVtbyA9IGV4cG9ydHMubGV0cmVjID0gZXhwb3J0cy51bmljb2RlSnNvblZhbHVlID0gZXhwb3J0cy51bmljb2RlSnNvbiA9IGV4cG9ydHMuanNvblZhbHVlID0gZXhwb3J0cy5qc29uID0gZXhwb3J0cy5vYmplY3QgPSBleHBvcnRzLmFueXRoaW5nID0gZXhwb3J0cy5kaWN0aW9uYXJ5ID0gZXhwb3J0cy5yZWNvcmQgPSBleHBvcnRzLnR1cGxlID0gZXhwb3J0cy51bmlxdWVBcnJheSA9IGV4cG9ydHMuaW5maW5pdGVTdHJlYW0gPSB2b2lkIDA7XG5leHBvcnRzLmNyZWF0ZURlcHRoSWRlbnRpZmllciA9IGV4cG9ydHMuc3RyZWFtID0gZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzLlJhbmRvbSA9IGV4cG9ydHMuRXhlY3V0aW9uU3RhdHVzID0gZXhwb3J0cy5yZXNldENvbmZpZ3VyZUdsb2JhbCA9IGV4cG9ydHMucmVhZENvbmZpZ3VyZUdsb2JhbCA9IGV4cG9ydHMuY29uZmlndXJlR2xvYmFsID0gZXhwb3J0cy5WZXJib3NpdHlMZXZlbCA9IGV4cG9ydHMuaGFzaCA9IGV4cG9ydHMuYXN5bmNEZWZhdWx0UmVwb3J0TWVzc2FnZSA9IGV4cG9ydHMuZGVmYXVsdFJlcG9ydE1lc3NhZ2UgPSBleHBvcnRzLmFzeW5jU3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLmdldERlcHRoQ29udGV4dEZvciA9IGV4cG9ydHMuaGFzQXN5bmNUb1N0cmluZ01ldGhvZCA9IGV4cG9ydHMuYXN5bmNUb1N0cmluZ01ldGhvZCA9IGV4cG9ydHMuaGFzVG9TdHJpbmdNZXRob2QgPSBleHBvcnRzLnRvU3RyaW5nTWV0aG9kID0gZXhwb3J0cy5oYXNDbG9uZU1ldGhvZCA9IGV4cG9ydHMuY2xvbmVJZk5lZWRlZCA9IHZvaWQgMDtcbmNvbnN0IFByZV8xID0gcmVxdWlyZShcIi4vY2hlY2svcHJlY29uZGl0aW9uL1ByZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInByZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJlXzEucHJlOyB9IH0pO1xuY29uc3QgQXN5bmNQcm9wZXJ0eV8xID0gcmVxdWlyZShcIi4vY2hlY2svcHJvcGVydHkvQXN5bmNQcm9wZXJ0eVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzeW5jUHJvcGVydHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFzeW5jUHJvcGVydHlfMS5hc3luY1Byb3BlcnR5OyB9IH0pO1xuY29uc3QgUHJvcGVydHlfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL3Byb3BlcnR5L1Byb3BlcnR5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicHJvcGVydHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb3BlcnR5XzEucHJvcGVydHk7IH0gfSk7XG5jb25zdCBSdW5uZXJfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL3J1bm5lci9SdW5uZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3NlcnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJ1bm5lcl8xLmFzc2VydDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNoZWNrXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBSdW5uZXJfMS5jaGVjazsgfSB9KTtcbmNvbnN0IFNhbXBsZXJfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL3J1bm5lci9TYW1wbGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2FtcGxlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBTYW1wbGVyXzEuc2FtcGxlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RhdGlzdGljc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU2FtcGxlcl8xLnN0YXRpc3RpY3M7IH0gfSk7XG5jb25zdCBhcnJheV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2FycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFycmF5XzEuYXJyYXk7IH0gfSk7XG5jb25zdCBiaWdJbnRfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9iaWdJbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJiaWdJbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpZ0ludF8xLmJpZ0ludDsgfSB9KTtcbmNvbnN0IGJpZ0ludE5fMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9iaWdJbnROXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYmlnSW50TlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlnSW50Tl8xLmJpZ0ludE47IH0gfSk7XG5jb25zdCBiaWdVaW50XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvYmlnVWludFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJpZ1VpbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpZ1VpbnRfMS5iaWdVaW50OyB9IH0pO1xuY29uc3QgYmlnVWludE5fMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9iaWdVaW50TlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJpZ1VpbnROXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaWdVaW50Tl8xLmJpZ1VpbnROOyB9IH0pO1xuY29uc3QgYm9vbGVhbl8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2Jvb2xlYW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJib29sZWFuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBib29sZWFuXzEuYm9vbGVhbjsgfSB9KTtcbmNvbnN0IGZhbHN5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvZmFsc3lcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmYWxzeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc3lfMS5mYWxzeTsgfSB9KTtcbmNvbnN0IGFzY2lpXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvYXNjaWlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc2NpaVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXNjaWlfMS5hc2NpaTsgfSB9KTtcbmNvbnN0IGJhc2U2NF8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2Jhc2U2NFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJhc2U2NFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZTY0XzEuYmFzZTY0OyB9IH0pO1xuY29uc3QgY2hhcl8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2NoYXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjaGFyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFyXzEuY2hhcjsgfSB9KTtcbmNvbnN0IGNoYXIxNmJpdHNfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9jaGFyMTZiaXRzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2hhcjE2Yml0c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hhcjE2Yml0c18xLmNoYXIxNmJpdHM7IH0gfSk7XG5jb25zdCBmdWxsVW5pY29kZV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2Z1bGxVbmljb2RlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZnVsbFVuaWNvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bGxVbmljb2RlXzEuZnVsbFVuaWNvZGU7IH0gfSk7XG5jb25zdCBoZXhhXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvaGV4YVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhleGFcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhleGFfMS5oZXhhOyB9IH0pO1xuY29uc3QgdW5pY29kZV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3VuaWNvZGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1bmljb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmljb2RlXzEudW5pY29kZTsgfSB9KTtcbmNvbnN0IGNvbnN0YW50XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvY29uc3RhbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25zdGFudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRfMS5jb25zdGFudDsgfSB9KTtcbmNvbnN0IGNvbnN0YW50RnJvbV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2NvbnN0YW50RnJvbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbnN0YW50RnJvbVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRGcm9tXzEuY29uc3RhbnRGcm9tOyB9IH0pO1xuY29uc3QgY29udGV4dF8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2NvbnRleHRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb250ZXh0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb250ZXh0XzEuY29udGV4dDsgfSB9KTtcbmNvbnN0IGRhdGVfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9kYXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGF0ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGF0ZV8xLmRhdGU7IH0gfSk7XG5jb25zdCBjbG9uZV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2Nsb25lXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2xvbmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsb25lXzEuY2xvbmU7IH0gfSk7XG5jb25zdCBkaWN0aW9uYXJ5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvZGljdGlvbmFyeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRpY3Rpb25hcnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpY3Rpb25hcnlfMS5kaWN0aW9uYXJ5OyB9IH0pO1xuY29uc3QgZW1haWxBZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvZW1haWxBZGRyZXNzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW1haWxBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbWFpbEFkZHJlc3NfMS5lbWFpbEFkZHJlc3M7IH0gfSk7XG5jb25zdCBkb3VibGVfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9kb3VibGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkb3VibGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvdWJsZV8xLmRvdWJsZTsgfSB9KTtcbmNvbnN0IGZsb2F0XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvZmxvYXRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmbG9hdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmxvYXRfMS5mbG9hdDsgfSB9KTtcbmNvbnN0IGNvbXBhcmVCb29sZWFuRnVuY18xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2NvbXBhcmVCb29sZWFuRnVuY1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbXBhcmVCb29sZWFuRnVuY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcGFyZUJvb2xlYW5GdW5jXzEuY29tcGFyZUJvb2xlYW5GdW5jOyB9IH0pO1xuY29uc3QgY29tcGFyZUZ1bmNfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9jb21wYXJlRnVuY1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbXBhcmVGdW5jXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wYXJlRnVuY18xLmNvbXBhcmVGdW5jOyB9IH0pO1xuY29uc3QgZnVuY18xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2Z1bmNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmdW5jXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jXzEuZnVuYzsgfSB9KTtcbmNvbnN0IGRvbWFpbl8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2RvbWFpblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRvbWFpblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9tYWluXzEuZG9tYWluOyB9IH0pO1xuY29uc3QgaW50ZWdlcl8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2ludGVnZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbnRlZ2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlZ2VyXzEuaW50ZWdlcjsgfSB9KTtcbmNvbnN0IG1heFNhZmVJbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvbWF4U2FmZUludGVnZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYXhTYWZlSW50ZWdlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF4U2FmZUludGVnZXJfMS5tYXhTYWZlSW50ZWdlcjsgfSB9KTtcbmNvbnN0IG1heFNhZmVOYXRfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9tYXhTYWZlTmF0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWF4U2FmZU5hdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF4U2FmZU5hdF8xLm1heFNhZmVOYXQ7IH0gfSk7XG5jb25zdCBuYXRfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9uYXRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuYXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hdF8xLm5hdDsgfSB9KTtcbmNvbnN0IGlwVjRfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9pcFY0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXBWNFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXBWNF8xLmlwVjQ7IH0gfSk7XG5jb25zdCBpcFY0RXh0ZW5kZWRfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9pcFY0RXh0ZW5kZWRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpcFY0RXh0ZW5kZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlwVjRFeHRlbmRlZF8xLmlwVjRFeHRlbmRlZDsgfSB9KTtcbmNvbnN0IGlwVjZfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9pcFY2XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXBWNlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXBWNl8xLmlwVjY7IH0gfSk7XG5jb25zdCBsZXRyZWNfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9sZXRyZWNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsZXRyZWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxldHJlY18xLmxldHJlYzsgfSB9KTtcbmNvbnN0IGxvcmVtXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvbG9yZW1cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsb3JlbVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9yZW1fMS5sb3JlbTsgfSB9KTtcbmNvbnN0IG1hcFRvQ29uc3RhbnRfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9tYXBUb0NvbnN0YW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFwVG9Db25zdGFudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFwVG9Db25zdGFudF8xLm1hcFRvQ29uc3RhbnQ7IH0gfSk7XG5jb25zdCBtZW1vXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvbWVtb1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1lbW9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lbW9fMS5tZW1vOyB9IH0pO1xuY29uc3QgbWl4ZWRDYXNlXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvbWl4ZWRDYXNlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWl4ZWRDYXNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtaXhlZENhc2VfMS5taXhlZENhc2U7IH0gfSk7XG5jb25zdCBvYmplY3RfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9vYmplY3RcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJvYmplY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9iamVjdF8xLm9iamVjdDsgfSB9KTtcbmNvbnN0IGpzb25fMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9qc29uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwianNvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ganNvbl8xLmpzb247IH0gfSk7XG5jb25zdCBhbnl0aGluZ18xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2FueXRoaW5nXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYW55dGhpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFueXRoaW5nXzEuYW55dGhpbmc7IH0gfSk7XG5jb25zdCB1bmljb2RlSnNvblZhbHVlXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvdW5pY29kZUpzb25WYWx1ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVuaWNvZGVKc29uVmFsdWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaWNvZGVKc29uVmFsdWVfMS51bmljb2RlSnNvblZhbHVlOyB9IH0pO1xuY29uc3QganNvblZhbHVlXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvanNvblZhbHVlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwianNvblZhbHVlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc29uVmFsdWVfMS5qc29uVmFsdWU7IH0gfSk7XG5jb25zdCB1bmljb2RlSnNvbl8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3VuaWNvZGVKc29uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidW5pY29kZUpzb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaWNvZGVKc29uXzEudW5pY29kZUpzb247IH0gfSk7XG5jb25zdCBvbmVvZl8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L29uZW9mXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwib25lb2ZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9uZW9mXzEub25lb2Y7IH0gfSk7XG5jb25zdCBvcHRpb25fMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9vcHRpb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJvcHRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9wdGlvbl8xLm9wdGlvbjsgfSB9KTtcbmNvbnN0IHJlY29yZF8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3JlY29yZFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlY29yZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVjb3JkXzEucmVjb3JkOyB9IH0pO1xuY29uc3QgdW5pcXVlQXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS91bmlxdWVBcnJheVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVuaXF1ZUFycmF5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmlxdWVBcnJheV8xLnVuaXF1ZUFycmF5OyB9IH0pO1xuY29uc3QgaW5maW5pdGVTdHJlYW1fMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9pbmZpbml0ZVN0cmVhbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImluZmluaXRlU3RyZWFtXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmZpbml0ZVN0cmVhbV8xLmluZmluaXRlU3RyZWFtOyB9IH0pO1xuY29uc3QgYXNjaWlTdHJpbmdfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9hc2NpaVN0cmluZ1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzY2lpU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhc2NpaVN0cmluZ18xLmFzY2lpU3RyaW5nOyB9IH0pO1xuY29uc3QgYmFzZTY0U3RyaW5nXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvYmFzZTY0U3RyaW5nXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYmFzZTY0U3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlNjRTdHJpbmdfMS5iYXNlNjRTdHJpbmc7IH0gfSk7XG5jb25zdCBmdWxsVW5pY29kZVN0cmluZ18xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2Z1bGxVbmljb2RlU3RyaW5nXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZnVsbFVuaWNvZGVTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bGxVbmljb2RlU3RyaW5nXzEuZnVsbFVuaWNvZGVTdHJpbmc7IH0gfSk7XG5jb25zdCBoZXhhU3RyaW5nXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvaGV4YVN0cmluZ1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhleGFTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhleGFTdHJpbmdfMS5oZXhhU3RyaW5nOyB9IH0pO1xuY29uc3Qgc3RyaW5nXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvc3RyaW5nXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdfMS5zdHJpbmc7IH0gfSk7XG5jb25zdCBzdHJpbmcxNmJpdHNfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9zdHJpbmcxNmJpdHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpbmcxNmJpdHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZzE2Yml0c18xLnN0cmluZzE2Yml0czsgfSB9KTtcbmNvbnN0IHN0cmluZ09mXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvc3RyaW5nT2ZcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpbmdPZlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyaW5nT2ZfMS5zdHJpbmdPZjsgfSB9KTtcbmNvbnN0IHVuaWNvZGVTdHJpbmdfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS91bmljb2RlU3RyaW5nXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidW5pY29kZVN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pY29kZVN0cmluZ18xLnVuaWNvZGVTdHJpbmc7IH0gfSk7XG5jb25zdCBzdWJhcnJheV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3N1YmFycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3ViYXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YmFycmF5XzEuc3ViYXJyYXk7IH0gfSk7XG5jb25zdCBzaHVmZmxlZFN1YmFycmF5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvc2h1ZmZsZWRTdWJhcnJheVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNodWZmbGVkU3ViYXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNodWZmbGVkU3ViYXJyYXlfMS5zaHVmZmxlZFN1YmFycmF5OyB9IH0pO1xuY29uc3QgdHVwbGVfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS90dXBsZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInR1cGxlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0dXBsZV8xLnR1cGxlOyB9IH0pO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3V1aWRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1dWlkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dWlkXzEudXVpZDsgfSB9KTtcbmNvbnN0IHV1aWRWXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvdXVpZFZcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1dWlkVlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXVpZFZfMS51dWlkVjsgfSB9KTtcbmNvbnN0IHdlYkF1dGhvcml0eV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3dlYkF1dGhvcml0eVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndlYkF1dGhvcml0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2ViQXV0aG9yaXR5XzEud2ViQXV0aG9yaXR5OyB9IH0pO1xuY29uc3Qgd2ViRnJhZ21lbnRzXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvd2ViRnJhZ21lbnRzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwid2ViRnJhZ21lbnRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3ZWJGcmFnbWVudHNfMS53ZWJGcmFnbWVudHM7IH0gfSk7XG5jb25zdCB3ZWJRdWVyeVBhcmFtZXRlcnNfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS93ZWJRdWVyeVBhcmFtZXRlcnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ3ZWJRdWVyeVBhcmFtZXRlcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdlYlF1ZXJ5UGFyYW1ldGVyc18xLndlYlF1ZXJ5UGFyYW1ldGVyczsgfSB9KTtcbmNvbnN0IHdlYlNlZ21lbnRfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS93ZWJTZWdtZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwid2ViU2VnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2ViU2VnbWVudF8xLndlYlNlZ21lbnQ7IH0gfSk7XG5jb25zdCB3ZWJVcmxfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS93ZWJVcmxcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ3ZWJVcmxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdlYlVybF8xLndlYlVybDsgfSB9KTtcbmNvbnN0IGNvbW1hbmRzXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvY29tbWFuZHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb21tYW5kc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tbWFuZHNfMS5jb21tYW5kczsgfSB9KTtcbmNvbnN0IE1vZGVsUnVubmVyXzEgPSByZXF1aXJlKFwiLi9jaGVjay9tb2RlbC9Nb2RlbFJ1bm5lclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzeW5jTW9kZWxSdW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vZGVsUnVubmVyXzEuYXN5bmNNb2RlbFJ1bjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1vZGVsUnVuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2RlbFJ1bm5lcl8xLm1vZGVsUnVuOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2NoZWR1bGVkTW9kZWxSdW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vZGVsUnVubmVyXzEuc2NoZWR1bGVkTW9kZWxSdW47IH0gfSk7XG5jb25zdCBSYW5kb21fMSA9IHJlcXVpcmUoXCIuL3JhbmRvbS9nZW5lcmF0b3IvUmFuZG9tXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmFuZG9tXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBSYW5kb21fMS5SYW5kb207IH0gfSk7XG5jb25zdCBHbG9iYWxQYXJhbWV0ZXJzXzEgPSByZXF1aXJlKFwiLi9jaGVjay9ydW5uZXIvY29uZmlndXJhdGlvbi9HbG9iYWxQYXJhbWV0ZXJzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uZmlndXJlR2xvYmFsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBHbG9iYWxQYXJhbWV0ZXJzXzEuY29uZmlndXJlR2xvYmFsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVhZENvbmZpZ3VyZUdsb2JhbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gR2xvYmFsUGFyYW1ldGVyc18xLnJlYWRDb25maWd1cmVHbG9iYWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZXNldENvbmZpZ3VyZUdsb2JhbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gR2xvYmFsUGFyYW1ldGVyc18xLnJlc2V0Q29uZmlndXJlR2xvYmFsOyB9IH0pO1xuY29uc3QgVmVyYm9zaXR5TGV2ZWxfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL3J1bm5lci9jb25maWd1cmF0aW9uL1ZlcmJvc2l0eUxldmVsXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmVyYm9zaXR5TGV2ZWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFZlcmJvc2l0eUxldmVsXzEuVmVyYm9zaXR5TGV2ZWw7IH0gfSk7XG5jb25zdCBFeGVjdXRpb25TdGF0dXNfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL3J1bm5lci9yZXBvcnRlci9FeGVjdXRpb25TdGF0dXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFeGVjdXRpb25TdGF0dXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEV4ZWN1dGlvblN0YXR1c18xLkV4ZWN1dGlvblN0YXR1czsgfSB9KTtcbmNvbnN0IHN5bWJvbHNfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL3N5bWJvbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjbG9uZU1ldGhvZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3ltYm9sc18xLmNsb25lTWV0aG9kOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2xvbmVJZk5lZWRlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3ltYm9sc18xLmNsb25lSWZOZWVkZWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoYXNDbG9uZU1ldGhvZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3ltYm9sc18xLmhhc0Nsb25lTWV0aG9kOyB9IH0pO1xuY29uc3QgU3RyZWFtXzEgPSByZXF1aXJlKFwiLi9zdHJlYW0vU3RyZWFtXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RyZWFtXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBTdHJlYW1fMS5TdHJlYW07IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJlYW1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0cmVhbV8xLnN0cmVhbTsgfSB9KTtcbmNvbnN0IGhhc2hfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2hhc2hcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoYXNoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNoXzEuaGFzaDsgfSB9KTtcbmNvbnN0IHN0cmluZ2lmeV8xID0gcmVxdWlyZShcIi4vdXRpbHMvc3RyaW5naWZ5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdpZnlfMS5zdHJpbmdpZnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3luY1N0cmluZ2lmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyaW5naWZ5XzEuYXN5bmNTdHJpbmdpZnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1N0cmluZ01ldGhvZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyaW5naWZ5XzEudG9TdHJpbmdNZXRob2Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoYXNUb1N0cmluZ01ldGhvZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyaW5naWZ5XzEuaGFzVG9TdHJpbmdNZXRob2Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3luY1RvU3RyaW5nTWV0aG9kXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdpZnlfMS5hc3luY1RvU3RyaW5nTWV0aG9kOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGFzQXN5bmNUb1N0cmluZ01ldGhvZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyaW5naWZ5XzEuaGFzQXN5bmNUb1N0cmluZ01ldGhvZDsgfSB9KTtcbmNvbnN0IHNjaGVkdWxlcl8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3NjaGVkdWxlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNjaGVkdWxlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NoZWR1bGVyXzEuc2NoZWR1bGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2NoZWR1bGVyRm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY2hlZHVsZXJfMS5zY2hlZHVsZXJGb3I7IH0gfSk7XG5jb25zdCBSdW5EZXRhaWxzRm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi9jaGVjay9ydW5uZXIvdXRpbHMvUnVuRGV0YWlsc0Zvcm1hdHRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRSZXBvcnRNZXNzYWdlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBSdW5EZXRhaWxzRm9ybWF0dGVyXzEuZGVmYXVsdFJlcG9ydE1lc3NhZ2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3luY0RlZmF1bHRSZXBvcnRNZXNzYWdlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBSdW5EZXRhaWxzRm9ybWF0dGVyXzEuYXN5bmNEZWZhdWx0UmVwb3J0TWVzc2FnZTsgfSB9KTtcbmNvbnN0IFByZWNvbmRpdGlvbkZhaWx1cmVfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL3ByZWNvbmRpdGlvbi9QcmVjb25kaXRpb25GYWlsdXJlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJlY29uZGl0aW9uRmFpbHVyZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJlY29uZGl0aW9uRmFpbHVyZV8xLlByZWNvbmRpdGlvbkZhaWx1cmU7IH0gfSk7XG5jb25zdCBpbnQ4QXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9pbnQ4QXJyYXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbnQ4QXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludDhBcnJheV8xLmludDhBcnJheTsgfSB9KTtcbmNvbnN0IGludDE2QXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9pbnQxNkFycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW50MTZBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50MTZBcnJheV8xLmludDE2QXJyYXk7IH0gfSk7XG5jb25zdCBpbnQzMkFycmF5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvaW50MzJBcnJheVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImludDMyQXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludDMyQXJyYXlfMS5pbnQzMkFycmF5OyB9IH0pO1xuY29uc3QgdWludDhBcnJheV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3VpbnQ4QXJyYXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1aW50OEFycmF5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1aW50OEFycmF5XzEudWludDhBcnJheTsgfSB9KTtcbmNvbnN0IHVpbnQ4Q2xhbXBlZEFycmF5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvdWludDhDbGFtcGVkQXJyYXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1aW50OENsYW1wZWRBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdWludDhDbGFtcGVkQXJyYXlfMS51aW50OENsYW1wZWRBcnJheTsgfSB9KTtcbmNvbnN0IHVpbnQxNkFycmF5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvdWludDE2QXJyYXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1aW50MTZBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdWludDE2QXJyYXlfMS51aW50MTZBcnJheTsgfSB9KTtcbmNvbnN0IHVpbnQzMkFycmF5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvdWludDMyQXJyYXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1aW50MzJBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdWludDMyQXJyYXlfMS51aW50MzJBcnJheTsgfSB9KTtcbmNvbnN0IGZsb2F0MzJBcnJheV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2Zsb2F0MzJBcnJheVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZsb2F0MzJBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmxvYXQzMkFycmF5XzEuZmxvYXQzMkFycmF5OyB9IH0pO1xuY29uc3QgZmxvYXQ2NEFycmF5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvZmxvYXQ2NEFycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZmxvYXQ2NEFycmF5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmbG9hdDY0QXJyYXlfMS5mbG9hdDY0QXJyYXk7IH0gfSk7XG5jb25zdCBzcGFyc2VBcnJheV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3NwYXJzZUFycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3BhcnNlQXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNwYXJzZUFycmF5XzEuc3BhcnNlQXJyYXk7IH0gfSk7XG5jb25zdCBBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0FyYml0cmFyeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFyYml0cmFyeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJiaXRyYXJ5XzEuQXJiaXRyYXJ5OyB9IH0pO1xuY29uc3QgVmFsdWVfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL1ZhbHVlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmFsdWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFZhbHVlXzEuVmFsdWU7IH0gfSk7XG5jb25zdCBEZXB0aENvbnRleHRfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9faW50ZXJuYWxzL2hlbHBlcnMvRGVwdGhDb250ZXh0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlRGVwdGhJZGVudGlmaWVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBEZXB0aENvbnRleHRfMS5jcmVhdGVEZXB0aElkZW50aWZpZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXREZXB0aENvbnRleHRGb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERlcHRoQ29udGV4dF8xLmdldERlcHRoQ29udGV4dEZvcjsgfSB9KTtcbmNvbnN0IGJpZ0ludDY0QXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9iaWdJbnQ2NEFycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYmlnSW50NjRBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlnSW50NjRBcnJheV8xLmJpZ0ludDY0QXJyYXk7IH0gfSk7XG5jb25zdCBiaWdVaW50NjRBcnJheV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2JpZ1VpbnQ2NEFycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYmlnVWludDY0QXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpZ1VpbnQ2NEFycmF5XzEuYmlnVWludDY0QXJyYXk7IH0gfSk7XG5jb25zdCBfX3R5cGUgPSAnY29tbW9uanMnO1xuZXhwb3J0cy5fX3R5cGUgPSBfX3R5cGU7XG5jb25zdCBfX3ZlcnNpb24gPSAnMy4xLjEnO1xuZXhwb3J0cy5fX3ZlcnNpb24gPSBfX3ZlcnNpb247XG5jb25zdCBfX2NvbW1pdEhhc2ggPSAnMzVhYzc3NWQzYTIzNTNhOTQ1OGIxNDI2YzJhYzk3Mzk3Yjk5Y2RiZCc7XG5leHBvcnRzLl9fY29tbWl0SGFzaCA9IF9fY29tbWl0SGFzaDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBmYyA9IHJlcXVpcmUoXCIuL2Zhc3QtY2hlY2stZGVmYXVsdFwiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZjO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Zhc3QtY2hlY2stZGVmYXVsdFwiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmFuZG9tID0gdm9pZCAwO1xuY29uc3QgcHVyZV9yYW5kXzEgPSByZXF1aXJlKFwicHVyZS1yYW5kXCIpO1xuY2xhc3MgUmFuZG9tIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2VSbmcpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFJuZyA9IHNvdXJjZVJuZy5jbG9uZSgpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5kb20odGhpcy5pbnRlcm5hbFJuZyk7XG4gICAgfVxuICAgIG5leHQoYml0cykge1xuICAgICAgICByZXR1cm4gKDAsIHB1cmVfcmFuZF8xLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb24pKDAsICgxIDw8IGJpdHMpIC0gMSwgdGhpcy5pbnRlcm5hbFJuZyk7XG4gICAgfVxuICAgIG5leHRCb29sZWFuKCkge1xuICAgICAgICByZXR1cm4gKDAsIHB1cmVfcmFuZF8xLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb24pKDAsIDEsIHRoaXMuaW50ZXJuYWxSbmcpID09IDE7XG4gICAgfVxuICAgIG5leHRJbnQobWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBwdXJlX3JhbmRfMS51bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uKShtaW4gPT0gbnVsbCA/IFJhbmRvbS5NSU5fSU5UIDogbWluLCBtYXggPT0gbnVsbCA/IFJhbmRvbS5NQVhfSU5UIDogbWF4LCB0aGlzLmludGVybmFsUm5nKTtcbiAgICB9XG4gICAgbmV4dEJpZ0ludChtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gKDAsIHB1cmVfcmFuZF8xLnVuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24pKG1pbiwgbWF4LCB0aGlzLmludGVybmFsUm5nKTtcbiAgICB9XG4gICAgbmV4dEFycmF5SW50KG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiAoMCwgcHVyZV9yYW5kXzEudW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uKShtaW4sIG1heCwgdGhpcy5pbnRlcm5hbFJuZyk7XG4gICAgfVxuICAgIG5leHREb3VibGUoKSB7XG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLm5leHQoMjYpO1xuICAgICAgICBjb25zdCBiID0gdGhpcy5uZXh0KDI3KTtcbiAgICAgICAgcmV0dXJuIChhICogUmFuZG9tLkRCTF9GQUNUT1IgKyBiKSAqIFJhbmRvbS5EQkxfRElWSVNPUjtcbiAgICB9XG59XG5leHBvcnRzLlJhbmRvbSA9IFJhbmRvbTtcblJhbmRvbS5NSU5fSU5UID0gMHg4MDAwMDAwMCB8IDA7XG5SYW5kb20uTUFYX0lOVCA9IDB4N2ZmZmZmZmYgfCAwO1xuUmFuZG9tLkRCTF9GQUNUT1IgPSBNYXRoLnBvdygyLCAyNyk7XG5SYW5kb20uREJMX0RJVklTT1IgPSBNYXRoLnBvdygyLCAtNTMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1ha2VMYXp5ID0gdm9pZCAwO1xuY2xhc3MgTGF6eUl0ZXJhYmxlSXRlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHByb2R1Y2VyKSB7XG4gICAgICAgIHRoaXMucHJvZHVjZXIgPSBwcm9kdWNlcjtcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIGlmICh0aGlzLml0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXQgPSB0aGlzLnByb2R1Y2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaXQ7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLml0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXQgPSB0aGlzLnByb2R1Y2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaXQubmV4dCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1ha2VMYXp5KHByb2R1Y2VyKSB7XG4gICAgcmV0dXJuIG5ldyBMYXp5SXRlcmFibGVJdGVyYXRvcihwcm9kdWNlcik7XG59XG5leHBvcnRzLm1ha2VMYXp5ID0gbWFrZUxhenk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3RyZWFtID0gZXhwb3J0cy5TdHJlYW0gPSB2b2lkIDA7XG5jb25zdCBTdHJlYW1IZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9TdHJlYW1IZWxwZXJzXCIpO1xuY2xhc3MgU3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcihnKSB7XG4gICAgICAgIHRoaXMuZyA9IGc7XG4gICAgfVxuICAgIHN0YXRpYyBuaWwoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKCgwLCBTdHJlYW1IZWxwZXJzXzEubmlsSGVscGVyKSgpKTtcbiAgICB9XG4gICAgc3RhdGljIG9mKC4uLmVsZW1lbnRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKGVsZW1lbnRzW1N5bWJvbC5pdGVyYXRvcl0oKSk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmcubmV4dCgpO1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZztcbiAgICB9XG4gICAgbWFwKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0oKDAsIFN0cmVhbUhlbHBlcnNfMS5tYXBIZWxwZXIpKHRoaXMuZywgZikpO1xuICAgIH1cbiAgICBmbGF0TWFwKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0oKDAsIFN0cmVhbUhlbHBlcnNfMS5mbGF0TWFwSGVscGVyKSh0aGlzLmcsIGYpKTtcbiAgICB9XG4gICAgZHJvcFdoaWxlKGYpIHtcbiAgICAgICAgbGV0IGZvdW5kRWxpZ2libGUgPSBmYWxzZTtcbiAgICAgICAgZnVuY3Rpb24qIGhlbHBlcih2KSB7XG4gICAgICAgICAgICBpZiAoZm91bmRFbGlnaWJsZSB8fCAhZih2KSkge1xuICAgICAgICAgICAgICAgIGZvdW5kRWxpZ2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHlpZWxkIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhdE1hcChoZWxwZXIpO1xuICAgIH1cbiAgICBkcm9wKG4pIHtcbiAgICAgICAgbGV0IGlkeCA9IDA7XG4gICAgICAgIGZ1bmN0aW9uIGhlbHBlcigpIHtcbiAgICAgICAgICAgIHJldHVybiBpZHgrKyA8IG47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZHJvcFdoaWxlKGhlbHBlcik7XG4gICAgfVxuICAgIHRha2VXaGlsZShmKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKCgwLCBTdHJlYW1IZWxwZXJzXzEudGFrZVdoaWxlSGVscGVyKSh0aGlzLmcsIGYpKTtcbiAgICB9XG4gICAgdGFrZShuKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKCgwLCBTdHJlYW1IZWxwZXJzXzEudGFrZU5IZWxwZXIpKHRoaXMuZywgbikpO1xuICAgIH1cbiAgICBmaWx0ZXIoZikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbSgoMCwgU3RyZWFtSGVscGVyc18xLmZpbHRlckhlbHBlcikodGhpcy5nLCBmKSk7XG4gICAgfVxuICAgIGV2ZXJ5KGYpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHRoaXMuZykge1xuICAgICAgICAgICAgaWYgKCFmKHYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBoYXMoZikge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdGhpcy5nKSB7XG4gICAgICAgICAgICBpZiAoZih2KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgdl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtmYWxzZSwgbnVsbF07XG4gICAgfVxuICAgIGpvaW4oLi4ub3RoZXJzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKCgwLCBTdHJlYW1IZWxwZXJzXzEuam9pbkhlbHBlcikodGhpcy5nLCBvdGhlcnMpKTtcbiAgICB9XG4gICAgZ2V0TnRoT3JMYXN0KG50aCkge1xuICAgICAgICBsZXQgcmVtYWluaW5nID0gbnRoO1xuICAgICAgICBsZXQgbGFzdCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiB0aGlzLmcpIHtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmctLSA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIGxhc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXN0O1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyZWFtID0gU3RyZWFtO1xuZnVuY3Rpb24gc3RyZWFtKGcpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbShnKTtcbn1cbmV4cG9ydHMuc3RyZWFtID0gc3RyZWFtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmpvaW5IZWxwZXIgPSBleHBvcnRzLnRha2VXaGlsZUhlbHBlciA9IGV4cG9ydHMudGFrZU5IZWxwZXIgPSBleHBvcnRzLmZpbHRlckhlbHBlciA9IGV4cG9ydHMuZmxhdE1hcEhlbHBlciA9IGV4cG9ydHMubWFwSGVscGVyID0gZXhwb3J0cy5uaWxIZWxwZXIgPSB2b2lkIDA7XG5jbGFzcyBOaWwge1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbmV4dCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyB2YWx1ZSwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn1cbk5pbC5uaWwgPSBuZXcgTmlsKCk7XG5mdW5jdGlvbiBuaWxIZWxwZXIoKSB7XG4gICAgcmV0dXJuIE5pbC5uaWw7XG59XG5leHBvcnRzLm5pbEhlbHBlciA9IG5pbEhlbHBlcjtcbmZ1bmN0aW9uKiBtYXBIZWxwZXIoZywgZikge1xuICAgIGZvciAoY29uc3QgdiBvZiBnKSB7XG4gICAgICAgIHlpZWxkIGYodik7XG4gICAgfVxufVxuZXhwb3J0cy5tYXBIZWxwZXIgPSBtYXBIZWxwZXI7XG5mdW5jdGlvbiogZmxhdE1hcEhlbHBlcihnLCBmKSB7XG4gICAgZm9yIChjb25zdCB2IG9mIGcpIHtcbiAgICAgICAgeWllbGQqIGYodik7XG4gICAgfVxufVxuZXhwb3J0cy5mbGF0TWFwSGVscGVyID0gZmxhdE1hcEhlbHBlcjtcbmZ1bmN0aW9uKiBmaWx0ZXJIZWxwZXIoZywgZikge1xuICAgIGZvciAoY29uc3QgdiBvZiBnKSB7XG4gICAgICAgIGlmIChmKHYpKSB7XG4gICAgICAgICAgICB5aWVsZCB2O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5maWx0ZXJIZWxwZXIgPSBmaWx0ZXJIZWxwZXI7XG5mdW5jdGlvbiogdGFrZU5IZWxwZXIoZywgbikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IGN1ciA9IGcubmV4dCgpO1xuICAgICAgICBpZiAoY3VyLmRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIGN1ci52YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLnRha2VOSGVscGVyID0gdGFrZU5IZWxwZXI7XG5mdW5jdGlvbiogdGFrZVdoaWxlSGVscGVyKGcsIGYpIHtcbiAgICBsZXQgY3VyID0gZy5uZXh0KCk7XG4gICAgd2hpbGUgKCFjdXIuZG9uZSAmJiBmKGN1ci52YWx1ZSkpIHtcbiAgICAgICAgeWllbGQgY3VyLnZhbHVlO1xuICAgICAgICBjdXIgPSBnLm5leHQoKTtcbiAgICB9XG59XG5leHBvcnRzLnRha2VXaGlsZUhlbHBlciA9IHRha2VXaGlsZUhlbHBlcjtcbmZ1bmN0aW9uKiBqb2luSGVscGVyKGcsIG90aGVycykge1xuICAgIGZvciAobGV0IGN1ciA9IGcubmV4dCgpOyAhY3VyLmRvbmU7IGN1ciA9IGcubmV4dCgpKSB7XG4gICAgICAgIHlpZWxkIGN1ci52YWx1ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBzIG9mIG90aGVycykge1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBzLm5leHQoKTsgIWN1ci5kb25lOyBjdXIgPSBzLm5leHQoKSkge1xuICAgICAgICAgICAgeWllbGQgY3VyLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5qb2luSGVscGVyID0gam9pbkhlbHBlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYXNoID0gdm9pZCAwO1xuY29uc3QgY3JjMzJUYWJsZSA9IFtcbiAgICAweDAwMDAwMDAwLCAweDc3MDczMDk2LCAweGVlMGU2MTJjLCAweDk5MDk1MWJhLCAweDA3NmRjNDE5LCAweDcwNmFmNDhmLCAweGU5NjNhNTM1LCAweDllNjQ5NWEzLCAweDBlZGI4ODMyLFxuICAgIDB4NzlkY2I4YTQsIDB4ZTBkNWU5MWUsIDB4OTdkMmQ5ODgsIDB4MDliNjRjMmIsIDB4N2ViMTdjYmQsIDB4ZTdiODJkMDcsIDB4OTBiZjFkOTEsIDB4MWRiNzEwNjQsIDB4NmFiMDIwZjIsXG4gICAgMHhmM2I5NzE0OCwgMHg4NGJlNDFkZSwgMHgxYWRhZDQ3ZCwgMHg2ZGRkZTRlYiwgMHhmNGQ0YjU1MSwgMHg4M2QzODVjNywgMHgxMzZjOTg1NiwgMHg2NDZiYThjMCwgMHhmZDYyZjk3YSxcbiAgICAweDhhNjVjOWVjLCAweDE0MDE1YzRmLCAweDYzMDY2Y2Q5LCAweGZhMGYzZDYzLCAweDhkMDgwZGY1LCAweDNiNmUyMGM4LCAweDRjNjkxMDVlLCAweGQ1NjA0MWU0LCAweGEyNjc3MTcyLFxuICAgIDB4M2MwM2U0ZDEsIDB4NGIwNGQ0NDcsIDB4ZDIwZDg1ZmQsIDB4YTUwYWI1NmIsIDB4MzViNWE4ZmEsIDB4NDJiMjk4NmMsIDB4ZGJiYmM5ZDYsIDB4YWNiY2Y5NDAsIDB4MzJkODZjZTMsXG4gICAgMHg0NWRmNWM3NSwgMHhkY2Q2MGRjZiwgMHhhYmQxM2Q1OSwgMHgyNmQ5MzBhYywgMHg1MWRlMDAzYSwgMHhjOGQ3NTE4MCwgMHhiZmQwNjExNiwgMHgyMWI0ZjRiNSwgMHg1NmIzYzQyMyxcbiAgICAweGNmYmE5NTk5LCAweGI4YmRhNTBmLCAweDI4MDJiODllLCAweDVmMDU4ODA4LCAweGM2MGNkOWIyLCAweGIxMGJlOTI0LCAweDJmNmY3Yzg3LCAweDU4Njg0YzExLCAweGMxNjExZGFiLFxuICAgIDB4YjY2NjJkM2QsIDB4NzZkYzQxOTAsIDB4MDFkYjcxMDYsIDB4OThkMjIwYmMsIDB4ZWZkNTEwMmEsIDB4NzFiMTg1ODksIDB4MDZiNmI1MWYsIDB4OWZiZmU0YTUsIDB4ZThiOGQ0MzMsXG4gICAgMHg3ODA3YzlhMiwgMHgwZjAwZjkzNCwgMHg5NjA5YTg4ZSwgMHhlMTBlOTgxOCwgMHg3ZjZhMGRiYiwgMHgwODZkM2QyZCwgMHg5MTY0NmM5NywgMHhlNjYzNWMwMSwgMHg2YjZiNTFmNCxcbiAgICAweDFjNmM2MTYyLCAweDg1NjUzMGQ4LCAweGYyNjIwMDRlLCAweDZjMDY5NWVkLCAweDFiMDFhNTdiLCAweDgyMDhmNGMxLCAweGY1MGZjNDU3LCAweDY1YjBkOWM2LCAweDEyYjdlOTUwLFxuICAgIDB4OGJiZWI4ZWEsIDB4ZmNiOTg4N2MsIDB4NjJkZDFkZGYsIDB4MTVkYTJkNDksIDB4OGNkMzdjZjMsIDB4ZmJkNDRjNjUsIDB4NGRiMjYxNTgsIDB4M2FiNTUxY2UsIDB4YTNiYzAwNzQsXG4gICAgMHhkNGJiMzBlMiwgMHg0YWRmYTU0MSwgMHgzZGQ4OTVkNywgMHhhNGQxYzQ2ZCwgMHhkM2Q2ZjRmYiwgMHg0MzY5ZTk2YSwgMHgzNDZlZDlmYywgMHhhZDY3ODg0NiwgMHhkYTYwYjhkMCxcbiAgICAweDQ0MDQyZDczLCAweDMzMDMxZGU1LCAweGFhMGE0YzVmLCAweGRkMGQ3Y2M5LCAweDUwMDU3MTNjLCAweDI3MDI0MWFhLCAweGJlMGIxMDEwLCAweGM5MGMyMDg2LCAweDU3NjhiNTI1LFxuICAgIDB4MjA2Zjg1YjMsIDB4Yjk2NmQ0MDksIDB4Y2U2MWU0OWYsIDB4NWVkZWY5MGUsIDB4MjlkOWM5OTgsIDB4YjBkMDk4MjIsIDB4YzdkN2E4YjQsIDB4NTliMzNkMTcsIDB4MmViNDBkODEsXG4gICAgMHhiN2JkNWMzYiwgMHhjMGJhNmNhZCwgMHhlZGI4ODMyMCwgMHg5YWJmYjNiNiwgMHgwM2I2ZTIwYywgMHg3NGIxZDI5YSwgMHhlYWQ1NDczOSwgMHg5ZGQyNzdhZiwgMHgwNGRiMjYxNSxcbiAgICAweDczZGMxNjgzLCAweGUzNjMwYjEyLCAweDk0NjQzYjg0LCAweDBkNmQ2YTNlLCAweDdhNmE1YWE4LCAweGU0MGVjZjBiLCAweDkzMDlmZjlkLCAweDBhMDBhZTI3LCAweDdkMDc5ZWIxLFxuICAgIDB4ZjAwZjkzNDQsIDB4ODcwOGEzZDIsIDB4MWUwMWYyNjgsIDB4NjkwNmMyZmUsIDB4Zjc2MjU3NWQsIDB4ODA2NTY3Y2IsIDB4MTk2YzM2NzEsIDB4NmU2YjA2ZTcsIDB4ZmVkNDFiNzYsXG4gICAgMHg4OWQzMmJlMCwgMHgxMGRhN2E1YSwgMHg2N2RkNGFjYywgMHhmOWI5ZGY2ZiwgMHg4ZWJlZWZmOSwgMHgxN2I3YmU0MywgMHg2MGIwOGVkNSwgMHhkNmQ2YTNlOCwgMHhhMWQxOTM3ZSxcbiAgICAweDM4ZDhjMmM0LCAweDRmZGZmMjUyLCAweGQxYmI2N2YxLCAweGE2YmM1NzY3LCAweDNmYjUwNmRkLCAweDQ4YjIzNjRiLCAweGQ4MGQyYmRhLCAweGFmMGExYjRjLCAweDM2MDM0YWY2LFxuICAgIDB4NDEwNDdhNjAsIDB4ZGY2MGVmYzMsIDB4YTg2N2RmNTUsIDB4MzE2ZThlZWYsIDB4NDY2OWJlNzksIDB4Y2I2MWIzOGMsIDB4YmM2NjgzMWEsIDB4MjU2ZmQyYTAsIDB4NTI2OGUyMzYsXG4gICAgMHhjYzBjNzc5NSwgMHhiYjBiNDcwMywgMHgyMjAyMTZiOSwgMHg1NTA1MjYyZiwgMHhjNWJhM2JiZSwgMHhiMmJkMGIyOCwgMHgyYmI0NWE5MiwgMHg1Y2IzNmEwNCwgMHhjMmQ3ZmZhNyxcbiAgICAweGI1ZDBjZjMxLCAweDJjZDk5ZThiLCAweDViZGVhZTFkLCAweDliNjRjMmIwLCAweGVjNjNmMjI2LCAweDc1NmFhMzljLCAweDAyNmQ5MzBhLCAweDljMDkwNmE5LCAweGViMGUzNjNmLFxuICAgIDB4NzIwNzY3ODUsIDB4MDUwMDU3MTMsIDB4OTViZjRhODIsIDB4ZTJiODdhMTQsIDB4N2JiMTJiYWUsIDB4MGNiNjFiMzgsIDB4OTJkMjhlOWIsIDB4ZTVkNWJlMGQsIDB4N2NkY2VmYjcsXG4gICAgMHgwYmRiZGYyMSwgMHg4NmQzZDJkNCwgMHhmMWQ0ZTI0MiwgMHg2OGRkYjNmOCwgMHgxZmRhODM2ZSwgMHg4MWJlMTZjZCwgMHhmNmI5MjY1YiwgMHg2ZmIwNzdlMSwgMHgxOGI3NDc3NyxcbiAgICAweDg4MDg1YWU2LCAweGZmMGY2YTcwLCAweDY2MDYzYmNhLCAweDExMDEwYjVjLCAweDhmNjU5ZWZmLCAweGY4NjJhZTY5LCAweDYxNmJmZmQzLCAweDE2NmNjZjQ1LCAweGEwMGFlMjc4LFxuICAgIDB4ZDcwZGQyZWUsIDB4NGUwNDgzNTQsIDB4MzkwM2IzYzIsIDB4YTc2NzI2NjEsIDB4ZDA2MDE2ZjcsIDB4NDk2OTQ3NGQsIDB4M2U2ZTc3ZGIsIDB4YWVkMTZhNGEsIDB4ZDlkNjVhZGMsXG4gICAgMHg0MGRmMGI2NiwgMHgzN2Q4M2JmMCwgMHhhOWJjYWU1MywgMHhkZWJiOWVjNSwgMHg0N2IyY2Y3ZiwgMHgzMGI1ZmZlOSwgMHhiZGJkZjIxYywgMHhjYWJhYzI4YSwgMHg1M2IzOTMzMCxcbiAgICAweDI0YjRhM2E2LCAweGJhZDAzNjA1LCAweGNkZDcwNjkzLCAweDU0ZGU1NzI5LCAweDIzZDk2N2JmLCAweGIzNjY3YTJlLCAweGM0NjE0YWI4LCAweDVkNjgxYjAyLCAweDJhNmYyYjk0LFxuICAgIDB4YjQwYmJlMzcsIDB4YzMwYzhlYTEsIDB4NWEwNWRmMWIsIDB4MmQwMmVmOGQsXG5dO1xuZnVuY3Rpb24gaGFzaChyZXByKSB7XG4gICAgbGV0IGNyYyA9IDB4ZmZmZmZmZmY7XG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgcmVwci5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgIGNvbnN0IGMgPSByZXByLmNoYXJDb2RlQXQoaWR4KTtcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICBjcmMgPSBjcmMzMlRhYmxlWyhjcmMgJiAweGZmKSBeIGNdIF4gKGNyYyA+PiA4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIGNyYyA9IGNyYzMyVGFibGVbKGNyYyAmIDB4ZmYpIF4gKDE5MiB8ICgoYyA+PiA2KSAmIDMxKSldIF4gKGNyYyA+PiA4KTtcbiAgICAgICAgICAgIGNyYyA9IGNyYzMyVGFibGVbKGNyYyAmIDB4ZmYpIF4gKDEyOCB8IChjICYgNjMpKV0gXiAoY3JjID4+IDgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPj0gMHhkODAwICYmIGMgPCAweGUwMDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNOZXh0ID0gcmVwci5jaGFyQ29kZUF0KCsraWR4KTtcbiAgICAgICAgICAgIGlmIChjID49IDB4ZGMwMCB8fCBjTmV4dCA8IDB4ZGMwMCB8fCBjTmV4dCA+IDB4ZGZmZiB8fCBOdW1iZXIuaXNOYU4oY05leHQpKSB7XG4gICAgICAgICAgICAgICAgaWR4IC09IDE7XG4gICAgICAgICAgICAgICAgY3JjID0gY3JjMzJUYWJsZVsoY3JjICYgMHhmZikgXiAweGVmXSBeIChjcmMgPj4gOCk7XG4gICAgICAgICAgICAgICAgY3JjID0gY3JjMzJUYWJsZVsoY3JjICYgMHhmZikgXiAweGJmXSBeIChjcmMgPj4gOCk7XG4gICAgICAgICAgICAgICAgY3JjID0gY3JjMzJUYWJsZVsoY3JjICYgMHhmZikgXiAweGJkXSBeIChjcmMgPj4gOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjMSA9IChjICYgMTAyMykgKyA2NDtcbiAgICAgICAgICAgICAgICBjb25zdCBjMiA9IGNOZXh0ICYgMTAyMztcbiAgICAgICAgICAgICAgICBjcmMgPSBjcmMzMlRhYmxlWyhjcmMgJiAweGZmKSBeICgyNDAgfCAoKGMxID4+IDgpICYgNykpXSBeIChjcmMgPj4gOCk7XG4gICAgICAgICAgICAgICAgY3JjID0gY3JjMzJUYWJsZVsoY3JjICYgMHhmZikgXiAoMTI4IHwgKChjMSA+PiAyKSAmIDYzKSldIF4gKGNyYyA+PiA4KTtcbiAgICAgICAgICAgICAgICBjcmMgPSBjcmMzMlRhYmxlWyhjcmMgJiAweGZmKSBeICgxMjggfCAoKGMyID4+IDYpICYgMTUpIHwgKChjMSAmIDMpIDw8IDQpKV0gXiAoY3JjID4+IDgpO1xuICAgICAgICAgICAgICAgIGNyYyA9IGNyYzMyVGFibGVbKGNyYyAmIDB4ZmYpIF4gKDEyOCB8IChjMiAmIDYzKSldIF4gKGNyYyA+PiA4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNyYyA9IGNyYzMyVGFibGVbKGNyYyAmIDB4ZmYpIF4gKDIyNCB8ICgoYyA+PiAxMikgJiAxNSkpXSBeIChjcmMgPj4gOCk7XG4gICAgICAgICAgICBjcmMgPSBjcmMzMlRhYmxlWyhjcmMgJiAweGZmKSBeICgxMjggfCAoKGMgPj4gNikgJiA2MykpXSBeIChjcmMgPj4gOCk7XG4gICAgICAgICAgICBjcmMgPSBjcmMzMlRhYmxlWyhjcmMgJiAweGZmKSBeICgxMjggfCAoYyAmIDYzKSldIF4gKGNyYyA+PiA4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKGNyYyB8IDApICsgMHg4MDAwMDAwMDtcbn1cbmV4cG9ydHMuaGFzaCA9IGhhc2g7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXN5bmNTdHJpbmdpZnkgPSBleHBvcnRzLnBvc3NpYmx5QXN5bmNTdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5SW50ZXJuYWwgPSBleHBvcnRzLmhhc0FzeW5jVG9TdHJpbmdNZXRob2QgPSBleHBvcnRzLmFzeW5jVG9TdHJpbmdNZXRob2QgPSBleHBvcnRzLmhhc1RvU3RyaW5nTWV0aG9kID0gZXhwb3J0cy50b1N0cmluZ01ldGhvZCA9IHZvaWQgMDtcbmV4cG9ydHMudG9TdHJpbmdNZXRob2QgPSBTeW1ib2woJ2Zhc3QtY2hlY2svdG9TdHJpbmdNZXRob2QnKTtcbmZ1bmN0aW9uIGhhc1RvU3RyaW5nTWV0aG9kKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIChpbnN0YW5jZSAhPT0gbnVsbCAmJlxuICAgICAgICAodHlwZW9mIGluc3RhbmNlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgaW5zdGFuY2UgPT09ICdmdW5jdGlvbicpICYmXG4gICAgICAgIGV4cG9ydHMudG9TdHJpbmdNZXRob2QgaW4gaW5zdGFuY2UgJiZcbiAgICAgICAgdHlwZW9mIGluc3RhbmNlW2V4cG9ydHMudG9TdHJpbmdNZXRob2RdID09PSAnZnVuY3Rpb24nKTtcbn1cbmV4cG9ydHMuaGFzVG9TdHJpbmdNZXRob2QgPSBoYXNUb1N0cmluZ01ldGhvZDtcbmV4cG9ydHMuYXN5bmNUb1N0cmluZ01ldGhvZCA9IFN5bWJvbCgnZmFzdC1jaGVjay9hc3luY1RvU3RyaW5nTWV0aG9kJyk7XG5mdW5jdGlvbiBoYXNBc3luY1RvU3RyaW5nTWV0aG9kKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIChpbnN0YW5jZSAhPT0gbnVsbCAmJlxuICAgICAgICAodHlwZW9mIGluc3RhbmNlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgaW5zdGFuY2UgPT09ICdmdW5jdGlvbicpICYmXG4gICAgICAgIGV4cG9ydHMuYXN5bmNUb1N0cmluZ01ldGhvZCBpbiBpbnN0YW5jZSAmJlxuICAgICAgICB0eXBlb2YgaW5zdGFuY2VbZXhwb3J0cy5hc3luY1RvU3RyaW5nTWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5leHBvcnRzLmhhc0FzeW5jVG9TdHJpbmdNZXRob2QgPSBoYXNBc3luY1RvU3RyaW5nTWV0aG9kO1xuY29uc3QgZmluZFN5bWJvbE5hbWVSZWdleCA9IC9eU3ltYm9sXFwoKC4qKVxcKSQvO1xuZnVuY3Rpb24gZ2V0U3ltYm9sRGVzY3JpcHRpb24ocykge1xuICAgIGlmIChzLmRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBzLmRlc2NyaXB0aW9uO1xuICAgIGNvbnN0IG0gPSBmaW5kU3ltYm9sTmFtZVJlZ2V4LmV4ZWMoU3RyaW5nKHMpKTtcbiAgICByZXR1cm4gbSAmJiBtWzFdLmxlbmd0aCA/IG1bMV0gOiBudWxsO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5TnVtYmVyKG51bVZhbHVlKSB7XG4gICAgc3dpdGNoIChudW1WYWx1ZSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gMSAvIG51bVZhbHVlID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPyAnLTAnIDogJzAnO1xuICAgICAgICBjYXNlIE51bWJlci5ORUdBVElWRV9JTkZJTklUWTpcbiAgICAgICAgICAgIHJldHVybiAnTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZJztcbiAgICAgICAgY2FzZSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk6XG4gICAgICAgICAgICByZXR1cm4gJ051bWJlci5QT1NJVElWRV9JTkZJTklUWSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVtVmFsdWUgPT09IG51bVZhbHVlID8gU3RyaW5nKG51bVZhbHVlKSA6ICdOdW1iZXIuTmFOJztcbiAgICB9XG59XG5mdW5jdGlvbiBpc1NwYXJzZUFycmF5KGFycikge1xuICAgIGxldCBwcmV2aW91c051bWJlcmVkSW5kZXggPSAtMTtcbiAgICBmb3IgKGNvbnN0IGluZGV4IGluIGFycikge1xuICAgICAgICBjb25zdCBudW1iZXJlZEluZGV4ID0gTnVtYmVyKGluZGV4KTtcbiAgICAgICAgaWYgKG51bWJlcmVkSW5kZXggIT09IHByZXZpb3VzTnVtYmVyZWRJbmRleCArIDEpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcHJldmlvdXNOdW1iZXJlZEluZGV4ID0gbnVtYmVyZWRJbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIHByZXZpb3VzTnVtYmVyZWRJbmRleCArIDEgIT09IGFyci5sZW5ndGg7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlJbnRlcm5hbCh2YWx1ZSwgcHJldmlvdXNWYWx1ZXMsIGdldEFzeW5jQ29udGVudCkge1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZXMgPSBwcmV2aW91c1ZhbHVlcy5jb25jYXQoW3ZhbHVlXSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHByZXZpb3VzVmFsdWVzLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuICdbY3ljbGljXSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc0FzeW5jVG9TdHJpbmdNZXRob2QodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBnZXRBc3luY0NvbnRlbnQodmFsdWUpO1xuICAgICAgICBpZiAoY29udGVudC5zdGF0ZSA9PT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50LnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNUb1N0cmluZ01ldGhvZCh2YWx1ZSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVtleHBvcnRzLnRvU3RyaW5nTWV0aG9kXSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSAnW29iamVjdCBBcnJheV0nOiB7XG4gICAgICAgICAgICBjb25zdCBhcnIgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChhcnIubGVuZ3RoID49IDUwICYmIGlzU3BhcnNlQXJyYXkoYXJyKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzc2lnbm1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBpbiBhcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oTnVtYmVyKGluZGV4KSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ25tZW50cy5wdXNoKGAke2luZGV4fToke3N0cmluZ2lmeUludGVybmFsKGFycltpbmRleF0sIGN1cnJlbnRWYWx1ZXMsIGdldEFzeW5jQ29udGVudCl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhc3NpZ25tZW50cy5sZW5ndGggIT09IDBcbiAgICAgICAgICAgICAgICAgICAgPyBgT2JqZWN0LmFzc2lnbihBcnJheSgke2Fyci5sZW5ndGh9KSx7JHthc3NpZ25tZW50cy5qb2luKCcsJyl9fSlgXG4gICAgICAgICAgICAgICAgICAgIDogYEFycmF5KCR7YXJyLmxlbmd0aH0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkQXJyYXkgPSBhcnIubWFwKCh2KSA9PiBzdHJpbmdpZnlJbnRlcm5hbCh2LCBjdXJyZW50VmFsdWVzLCBnZXRBc3luY0NvbnRlbnQpKS5qb2luKCcsJyk7XG4gICAgICAgICAgICByZXR1cm4gYXJyLmxlbmd0aCA9PT0gMCB8fCBhcnIubGVuZ3RoIC0gMSBpbiBhcnIgPyBgWyR7c3RyaW5naWZpZWRBcnJheX1dYCA6IGBbJHtzdHJpbmdpZmllZEFycmF5fSxdYDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdbb2JqZWN0IEJpZ0ludF0nOlxuICAgICAgICAgICAgcmV0dXJuIGAke3ZhbHVlfW5gO1xuICAgICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IGBuZXcgQm9vbGVhbigke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0pYDtcbiAgICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6IHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuaXNOYU4oZC5nZXRUaW1lKCkpID8gYG5ldyBEYXRlKE5hTilgIDogYG5ldyBEYXRlKCR7SlNPTi5zdHJpbmdpZnkoZC50b0lTT1N0cmluZygpKX0pYDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdbb2JqZWN0IE1hcF0nOlxuICAgICAgICAgICAgcmV0dXJuIGBuZXcgTWFwKCR7c3RyaW5naWZ5SW50ZXJuYWwoQXJyYXkuZnJvbSh2YWx1ZSksIGN1cnJlbnRWYWx1ZXMsIGdldEFzeW5jQ29udGVudCl9KWA7XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgTnVsbF0nOlxuICAgICAgICAgICAgcmV0dXJuIGBudWxsYDtcbiAgICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gc3RyaW5naWZ5TnVtYmVyKHZhbHVlKSA6IGBuZXcgTnVtYmVyKCR7c3RyaW5naWZ5TnVtYmVyKE51bWJlcih2YWx1ZSkpfSlgO1xuICAgICAgICBjYXNlICdbb2JqZWN0IE9iamVjdF0nOiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvU3RyaW5nQWNjZXNzb3IgPSB2YWx1ZS50b1N0cmluZztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvU3RyaW5nQWNjZXNzb3IgPT09ICdmdW5jdGlvbicgJiYgdG9TdHJpbmdBY2Nlc3NvciAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbb2JqZWN0IE9iamVjdF0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWFwcGVyID0gKGspID0+IGAke2sgPT09ICdfX3Byb3RvX18nXG4gICAgICAgICAgICAgICAgPyAnW1wiX19wcm90b19fXCJdJ1xuICAgICAgICAgICAgICAgIDogdHlwZW9mIGsgPT09ICdzeW1ib2wnXG4gICAgICAgICAgICAgICAgICAgID8gYFske3N0cmluZ2lmeUludGVybmFsKGssIGN1cnJlbnRWYWx1ZXMsIGdldEFzeW5jQ29udGVudCl9XWBcbiAgICAgICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShrKX06JHtzdHJpbmdpZnlJbnRlcm5hbCh2YWx1ZVtrXSwgY3VycmVudFZhbHVlcywgZ2V0QXN5bmNDb250ZW50KX1gO1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRQcm9wZXJ0aWVzID0gW1xuICAgICAgICAgICAgICAgIC4uLk9iamVjdC5rZXlzKHZhbHVlKS5tYXAobWFwcGVyKSxcbiAgICAgICAgICAgICAgICAuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAobWFwcGVyKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCByYXdSZXByID0gJ3snICsgc3RyaW5naWZpZWRQcm9wZXJ0aWVzLmpvaW4oJywnKSArICd9JztcbiAgICAgICAgICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhd1JlcHIgPT09ICd7fScgPyAnT2JqZWN0LmNyZWF0ZShudWxsKScgOiBgT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCR7cmF3UmVwcn0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByYXdSZXByO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgU2V0XSc6XG4gICAgICAgICAgICByZXR1cm4gYG5ldyBTZXQoJHtzdHJpbmdpZnlJbnRlcm5hbChBcnJheS5mcm9tKHZhbHVlKSwgY3VycmVudFZhbHVlcywgZ2V0QXN5bmNDb250ZW50KX0pYDtcbiAgICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogYG5ldyBTdHJpbmcoJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9KWA7XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgU3ltYm9sXSc6IHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChTeW1ib2wua2V5Rm9yKHMpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYFN5bWJvbC5mb3IoJHtKU09OLnN0cmluZ2lmeShTeW1ib2wua2V5Rm9yKHMpKX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlc2MgPSBnZXRTeW1ib2xEZXNjcmlwdGlvbihzKTtcbiAgICAgICAgICAgIGlmIChkZXNjID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdTeW1ib2woKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBrbm93blN5bWJvbCA9IGRlc2Muc3RhcnRzV2l0aCgnU3ltYm9sLicpICYmIFN5bWJvbFtkZXNjLnN1YnN0cmluZyg3KV07XG4gICAgICAgICAgICByZXR1cm4gcyA9PT0ga25vd25TeW1ib2wgPyBkZXNjIDogYFN5bWJvbCgke0pTT04uc3RyaW5naWZ5KGRlc2MpfSlgO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgUHJvbWlzZV0nOiB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlQ29udGVudCA9IGdldEFzeW5jQ29udGVudCh2YWx1ZSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHByb21pc2VDb250ZW50LnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZnVsZmlsbGVkJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBQcm9taXNlLnJlc29sdmUoJHtzdHJpbmdpZnlJbnRlcm5hbChwcm9taXNlQ29udGVudC52YWx1ZSwgY3VycmVudFZhbHVlcywgZ2V0QXN5bmNDb250ZW50KX0pYDtcbiAgICAgICAgICAgICAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgUHJvbWlzZS5yZWplY3QoJHtzdHJpbmdpZnlJbnRlcm5hbChwcm9taXNlQ29udGVudC52YWx1ZSwgY3VycmVudFZhbHVlcywgZ2V0QXN5bmNDb250ZW50KX0pYDtcbiAgICAgICAgICAgICAgICBjYXNlICdwZW5kaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBuZXcgUHJvbWlzZSgoKSA9PiB7LypwZW5kaW5nKi99KWA7XG4gICAgICAgICAgICAgICAgY2FzZSAndW5rbm93bic6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBuZXcgUHJvbWlzZSgoKSA9PiB7Lyp1bmtub3duKi99KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnW29iamVjdCBFcnJvcl0nOlxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYG5ldyBFcnJvcigke3N0cmluZ2lmeUludGVybmFsKHZhbHVlLm1lc3NhZ2UsIGN1cnJlbnRWYWx1ZXMsIGdldEFzeW5jQ29udGVudCl9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnW29iamVjdCBVbmRlZmluZWRdJzpcbiAgICAgICAgICAgIHJldHVybiBgdW5kZWZpbmVkYDtcbiAgICAgICAgY2FzZSAnW29iamVjdCBJbnQ4QXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBVaW50OEFycmF5XSc6XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBJbnQxNkFycmF5XSc6XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgVWludDE2QXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBJbnQzMkFycmF5XSc6XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgVWludDMyQXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBGbG9hdDMyQXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBGbG9hdDY0QXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBCaWdJbnQ2NEFycmF5XSc6XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgQmlnVWludDY0QXJyYXldJzoge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBCdWZmZXIuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgQnVmZmVyLmZyb20oJHtzdHJpbmdpZnlJbnRlcm5hbChBcnJheS5mcm9tKHZhbHVlLnZhbHVlcygpKSwgY3VycmVudFZhbHVlcywgZ2V0QXN5bmNDb250ZW50KX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IHZhbHVlUHJvdG90eXBlICYmIHZhbHVlUHJvdG90eXBlLmNvbnN0cnVjdG9yICYmIHZhbHVlUHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZEFycmF5ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzRnJvbVR5cGVkQXJyID0gdHlwZWRBcnJheS52YWx1ZXMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7Y2xhc3NOYW1lfS5mcm9tKCR7c3RyaW5naWZ5SW50ZXJuYWwoQXJyYXkuZnJvbSh2YWx1ZXNGcm9tVHlwZWRBcnIpLCBjdXJyZW50VmFsdWVzLCBnZXRBc3luY0NvbnRlbnQpfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLnN0cmluZ2lmeUludGVybmFsID0gc3RyaW5naWZ5SW50ZXJuYWw7XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5SW50ZXJuYWwodmFsdWUsIFtdLCAoKSA9PiAoeyBzdGF0ZTogJ3Vua25vd24nLCB2YWx1ZTogdW5kZWZpbmVkIH0pKTtcbn1cbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuZnVuY3Rpb24gcG9zc2libHlBc3luY1N0cmluZ2lmeSh2YWx1ZSkge1xuICAgIGNvbnN0IHN0aWxsUGVuZGluZ01hcmtlciA9IFN5bWJvbCgpO1xuICAgIGNvbnN0IHBlbmRpbmdQcm9taXNlc0ZvckNhY2hlID0gW107XG4gICAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gY3JlYXRlRGVsYXkwKCkge1xuICAgICAgICBsZXQgaGFuZGxlSWQgPSBudWxsO1xuICAgICAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlSWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaGFuZGxlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkZWxheSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZUlkID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHN0aWxsUGVuZGluZ01hcmtlcik7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGRlbGF5LCBjYW5jZWwgfTtcbiAgICB9XG4gICAgY29uc3QgdW5rbm93blN0YXRlID0geyBzdGF0ZTogJ3Vua25vd24nLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgY29uc3QgZ2V0QXN5bmNDb250ZW50ID0gZnVuY3Rpb24gZ2V0QXN5bmNDb250ZW50KGRhdGEpIHtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBkYXRhO1xuICAgICAgICBpZiAoY2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVsYXkwID0gY3JlYXRlRGVsYXkwKCk7XG4gICAgICAgIGNvbnN0IHAgPSBleHBvcnRzLmFzeW5jVG9TdHJpbmdNZXRob2QgaW4gZGF0YVxuICAgICAgICAgICAgPyBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IGRhdGFbZXhwb3J0cy5hc3luY1RvU3RyaW5nTWV0aG9kXSgpKVxuICAgICAgICAgICAgOiBkYXRhO1xuICAgICAgICBwLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgIHBlbmRpbmdQcm9taXNlc0ZvckNhY2hlLnB1c2goUHJvbWlzZS5yYWNlKFtwLCBkZWxheTAuZGVsYXldKS50aGVuKChzdWNjZXNzVmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzVmFsdWUgPT09IHN0aWxsUGVuZGluZ01hcmtlcilcbiAgICAgICAgICAgICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIHsgc3RhdGU6ICdwZW5kaW5nJywgdmFsdWU6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIHsgc3RhdGU6ICdmdWxmaWxsZWQnLCB2YWx1ZTogc3VjY2Vzc1ZhbHVlIH0pO1xuICAgICAgICAgICAgZGVsYXkwLmNhbmNlbCgpO1xuICAgICAgICB9LCAoZXJyb3JWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgY2FjaGUuc2V0KGNhY2hlS2V5LCB7IHN0YXRlOiAncmVqZWN0ZWQnLCB2YWx1ZTogZXJyb3JWYWx1ZSB9KTtcbiAgICAgICAgICAgIGRlbGF5MC5jYW5jZWwoKTtcbiAgICAgICAgfSkpO1xuICAgICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIHVua25vd25TdGF0ZSk7XG4gICAgICAgIHJldHVybiB1bmtub3duU3RhdGU7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBsb29wKCkge1xuICAgICAgICBjb25zdCBzdHJpbmdpZmllZFZhbHVlID0gc3RyaW5naWZ5SW50ZXJuYWwodmFsdWUsIFtdLCBnZXRBc3luY0NvbnRlbnQpO1xuICAgICAgICBpZiAocGVuZGluZ1Byb21pc2VzRm9yQ2FjaGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZpZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZ1Byb21pc2VzRm9yQ2FjaGUuc3BsaWNlKDApKS50aGVuKGxvb3ApO1xuICAgIH1cbiAgICByZXR1cm4gbG9vcCgpO1xufVxuZXhwb3J0cy5wb3NzaWJseUFzeW5jU3RyaW5naWZ5ID0gcG9zc2libHlBc3luY1N0cmluZ2lmeTtcbmFzeW5jIGZ1bmN0aW9uIGFzeW5jU3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwb3NzaWJseUFzeW5jU3RyaW5naWZ5KHZhbHVlKSk7XG59XG5leHBvcnRzLmFzeW5jU3RyaW5naWZ5ID0gYXN5bmNTdHJpbmdpZnk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRk9DVVNfTk9fQVVUT0ZPQ1VTID0gZXhwb3J0cy5GT0NVU19BVVRPID0gZXhwb3J0cy5GT0NVU19BTExPVyA9IGV4cG9ydHMuRk9DVVNfRElTQUJMRUQgPSBleHBvcnRzLkZPQ1VTX0dST1VQID0gdm9pZCAwO1xuLyoqXG4gKiBkZWZpbmVzIGEgZm9jdXMgZ3JvdXBcbiAqL1xuZXhwb3J0cy5GT0NVU19HUk9VUCA9ICdkYXRhLWZvY3VzLWxvY2snO1xuLyoqXG4gKiBkaXNhYmxlcyBlbGVtZW50IGRpc2NvdmVyeSBpbnNpZGUgYSBncm91cCBtYXJrZWQgYnkga2V5XG4gKi9cbmV4cG9ydHMuRk9DVVNfRElTQUJMRUQgPSAnZGF0YS1mb2N1cy1sb2NrLWRpc2FibGVkJztcbi8qKlxuICogYWxsb3dzIHVuY29udHJvbGxlZCBmb2N1cyB3aXRoaW4gdGhlIG1hcmtlZCBhcmVhLCBlZmZlY3RpdmVseSBkaXNhYmxpbmcgZm9jdXMgbG9jayBmb3IgaXQncyBjb250ZW50XG4gKi9cbmV4cG9ydHMuRk9DVVNfQUxMT1cgPSAnZGF0YS1uby1mb2N1cy1sb2NrJztcbi8qKlxuICogaW5zdHJ1Y3RzIGF1dG9mb2N1cyBlbmdpbmUgdG8gcGljayBkZWZhdWx0IGF1dG9mb2N1cyBpbnNpZGUgYSBnaXZlbiBub2RlXG4gKiBjYW4gYmUgc2V0IG9uIHRoZSBlbGVtZW50IG9yIGNvbnRhaW5lclxuICovXG5leHBvcnRzLkZPQ1VTX0FVVE8gPSAnZGF0YS1hdXRvZm9jdXMtaW5zaWRlJztcbi8qKlxuICogaW5zdHJ1Y3RzIGF1dG9mb2N1cyB0byBpZ25vcmUgZWxlbWVudHMgd2l0aGluIGEgZ2l2ZW4gbm9kZVxuICogY2FuIGJlIHNldCBvbiB0aGUgZWxlbWVudCBvciBjb250YWluZXJcbiAqL1xuZXhwb3J0cy5GT0NVU19OT19BVVRPRk9DVVMgPSAnZGF0YS1uby1hdXRvZm9jdXMnO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvY3VzSW5zaWRlID0gdm9pZCAwO1xudmFyIERPTXV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlscy9ET011dGlsc1wiKTtcbnZhciBhbGxfYWZmZWN0ZWRfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2FsbC1hZmZlY3RlZFwiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcIi4vdXRpbHMvYXJyYXlcIik7XG52YXIgZ2V0QWN0aXZlRWxlbWVudF8xID0gcmVxdWlyZShcIi4vdXRpbHMvZ2V0QWN0aXZlRWxlbWVudFwiKTtcbnZhciBmb2N1c0luRnJhbWUgPSBmdW5jdGlvbiAoZnJhbWUsIGFjdGl2ZUVsZW1lbnQpIHsgcmV0dXJuIGZyYW1lID09PSBhY3RpdmVFbGVtZW50OyB9O1xudmFyIGZvY3VzSW5zaWRlSWZyYW1lID0gZnVuY3Rpb24gKHRvcE5vZGUsIGFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm4gQm9vbGVhbigoMCwgYXJyYXlfMS50b0FycmF5KSh0b3BOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lmcmFtZScpKS5zb21lKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBmb2N1c0luRnJhbWUobm9kZSwgYWN0aXZlRWxlbWVudCk7IH0pKTtcbn07XG4vKipcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlLCBpZiB0aGUgY3VycmVudCBmb2N1cyBpcyBpbnNpZGUgZ2l2ZW4gbm9kZSBvciBub2Rlc1xuICovXG52YXIgZm9jdXNJbnNpZGUgPSBmdW5jdGlvbiAodG9wTm9kZSwgYWN0aXZlRWxlbWVudCkge1xuICAgIC8vIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudCAmJiBnZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQgPT09IHZvaWQgMCkgeyBhY3RpdmVFbGVtZW50ID0gKDAsIGdldEFjdGl2ZUVsZW1lbnRfMS5nZXRBY3RpdmVFbGVtZW50KSgoMCwgYXJyYXlfMS5nZXRGaXJzdCkodG9wTm9kZSkub3duZXJEb2N1bWVudCk7IH1cbiAgICBpZiAoIWFjdGl2ZUVsZW1lbnQgfHwgKGFjdGl2ZUVsZW1lbnQuZGF0YXNldCAmJiBhY3RpdmVFbGVtZW50LmRhdGFzZXQuZm9jdXNHdWFyZCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGFsbF9hZmZlY3RlZF8xLmdldEFsbEFmZmVjdGVkTm9kZXMpKHRvcE5vZGUpLnNvbWUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICgwLCBET011dGlsc18xLmNvbnRhaW5zKShub2RlLCBhY3RpdmVFbGVtZW50KSB8fCBmb2N1c0luc2lkZUlmcmFtZShub2RlLCBhY3RpdmVFbGVtZW50KTtcbiAgICB9KTtcbn07XG5leHBvcnRzLmZvY3VzSW5zaWRlID0gZm9jdXNJbnNpZGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZm9jdXNJc0hpZGRlbiA9IHZvaWQgMDtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbnZhciBET011dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHMvRE9NdXRpbHNcIik7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2FycmF5XCIpO1xudmFyIGdldEFjdGl2ZUVsZW1lbnRfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2dldEFjdGl2ZUVsZW1lbnRcIik7XG4vKipcbiAqIGZvY3VzIGlzIGhpZGRlbiBGUk9NIHRoZSBmb2N1cy1sb2NrXG4gKiBpZSBjb250YWluZWQgaW5zaWRlIGEgbm9kZSBmb2N1cy1sb2NrIHNoYWxsIGlnbm9yZVxuICogQHJldHVybnMge2Jvb2xlYW59IGZvY3VzIGlzIGN1cnJlbnRseSBpcyBpbiBcImFsbG93XCIgYXJlYVxuICovXG52YXIgZm9jdXNJc0hpZGRlbiA9IGZ1bmN0aW9uIChpbkRvY3VtZW50KSB7XG4gICAgaWYgKGluRG9jdW1lbnQgPT09IHZvaWQgMCkgeyBpbkRvY3VtZW50ID0gZG9jdW1lbnQ7IH1cbiAgICB2YXIgYWN0aXZlRWxlbWVudCA9ICgwLCBnZXRBY3RpdmVFbGVtZW50XzEuZ2V0QWN0aXZlRWxlbWVudCkoaW5Eb2N1bWVudCk7XG4gICAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gdGhpcyBkb2VzIG5vdCBzdXBwb3J0IHNldHRpbmcgRk9DVVNfQUxMT1cgd2l0aGluIHNoYWRvdyBkb21cbiAgICByZXR1cm4gKDAsIGFycmF5XzEudG9BcnJheSkoaW5Eb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW1wiLmNvbmNhdChjb25zdGFudHNfMS5GT0NVU19BTExPVywgXCJdXCIpKSkuc29tZShmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gKDAsIERPTXV0aWxzXzEuY29udGFpbnMpKG5vZGUsIGFjdGl2ZUVsZW1lbnQpOyB9KTtcbn07XG5leHBvcnRzLmZvY3VzSXNIaWRkZW4gPSBmb2N1c0lzSGlkZGVuO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEZvY3VzTWVyZ2UgPSB2b2lkIDA7XG52YXIgc29sdmVyXzEgPSByZXF1aXJlKFwiLi9zb2x2ZXJcIik7XG52YXIgRE9NdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL0RPTXV0aWxzXCIpO1xudmFyIGFsbF9hZmZlY3RlZF8xID0gcmVxdWlyZShcIi4vdXRpbHMvYWxsLWFmZmVjdGVkXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiLi91dGlscy9hcnJheVwiKTtcbnZhciBhdXRvX2ZvY3VzXzEgPSByZXF1aXJlKFwiLi91dGlscy9hdXRvLWZvY3VzXCIpO1xudmFyIGdldEFjdGl2ZUVsZW1lbnRfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2dldEFjdGl2ZUVsZW1lbnRcIik7XG52YXIgaXNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2lzXCIpO1xudmFyIHBhcmVudGluZ18xID0gcmVxdWlyZShcIi4vdXRpbHMvcGFyZW50aW5nXCIpO1xudmFyIHJlb3JkZXJOb2RlcyA9IGZ1bmN0aW9uIChzcmNOb2RlcywgZHN0Tm9kZXMpIHtcbiAgICB2YXIgcmVtYXAgPSBuZXcgTWFwKCk7XG4gICAgLy8gbm8gU2V0KGRzdE5vZGVzKSBmb3IgSUUxMSA6KFxuICAgIGRzdE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGVudGl0eSkgeyByZXR1cm4gcmVtYXAuc2V0KGVudGl0eS5ub2RlLCBlbnRpdHkpOyB9KTtcbiAgICAvLyByZW1hcCB0byBkc3ROb2Rlc1xuICAgIHJldHVybiBzcmNOb2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHJlbWFwLmdldChub2RlKTsgfSkuZmlsdGVyKGlzXzEuaXNEZWZpbmVkKTtcbn07XG4vKipcbiAqIGdpdmVuIHRvcCBub2RlKHMpIGFuZCB0aGUgbGFzdCBhY3RpdmUgZWxlbWVudCByZXR1cm4gdGhlIGVsZW1lbnQgdG8gYmUgZm9jdXNlZCBuZXh0XG4gKiBAcGFyYW0gdG9wTm9kZVxuICogQHBhcmFtIGxhc3ROb2RlXG4gKi9cbnZhciBnZXRGb2N1c01lcmdlID0gZnVuY3Rpb24gKHRvcE5vZGUsIGxhc3ROb2RlKSB7XG4gICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSAoMCwgZ2V0QWN0aXZlRWxlbWVudF8xLmdldEFjdGl2ZUVsZW1lbnQpKCgwLCBhcnJheV8xLmFzQXJyYXkpKHRvcE5vZGUpLmxlbmd0aCA+IDAgPyBkb2N1bWVudCA6ICgwLCBhcnJheV8xLmdldEZpcnN0KSh0b3BOb2RlKS5vd25lckRvY3VtZW50KTtcbiAgICB2YXIgZW50cmllcyA9ICgwLCBhbGxfYWZmZWN0ZWRfMS5nZXRBbGxBZmZlY3RlZE5vZGVzKSh0b3BOb2RlKS5maWx0ZXIoaXNfMS5pc05vdEFHdWFyZCk7XG4gICAgdmFyIGNvbW1vblBhcmVudCA9ICgwLCBwYXJlbnRpbmdfMS5nZXRUb3BDb21tb25QYXJlbnQpKGFjdGl2ZUVsZW1lbnQgfHwgdG9wTm9kZSwgdG9wTm9kZSwgZW50cmllcyk7XG4gICAgdmFyIHZpc2liaWxpdHlDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB2YXIgYW55Rm9jdXNhYmxlID0gKDAsIERPTXV0aWxzXzEuZ2V0QWxsVGFiYmFibGVOb2RlcykoZW50cmllcywgdmlzaWJpbGl0eUNhY2hlKTtcbiAgICB2YXIgaW5uZXJFbGVtZW50cyA9ICgwLCBET011dGlsc18xLmdldFRhYmJhYmxlTm9kZXMpKGVudHJpZXMsIHZpc2liaWxpdHlDYWNoZSkuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiAoMCwgaXNfMS5pc05vdEFHdWFyZCkobm9kZSk7XG4gICAgfSk7XG4gICAgaWYgKCFpbm5lckVsZW1lbnRzWzBdKSB7XG4gICAgICAgIGlubmVyRWxlbWVudHMgPSBhbnlGb2N1c2FibGU7XG4gICAgICAgIGlmICghaW5uZXJFbGVtZW50c1swXSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgb3V0ZXJOb2RlcyA9ICgwLCBET011dGlsc18xLmdldEFsbFRhYmJhYmxlTm9kZXMpKFtjb21tb25QYXJlbnRdLCB2aXNpYmlsaXR5Q2FjaGUpLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcbiAgICB2YXIgb3JkZXJlZElubmVyRWxlbWVudHMgPSByZW9yZGVyTm9kZXMob3V0ZXJOb2RlcywgaW5uZXJFbGVtZW50cyk7XG4gICAgdmFyIGlubmVyTm9kZXMgPSBvcmRlcmVkSW5uZXJFbGVtZW50cy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gICAgdmFyIG5ld0lkID0gKDAsIHNvbHZlcl8xLm5ld0ZvY3VzKShpbm5lck5vZGVzLCBvdXRlck5vZGVzLCBhY3RpdmVFbGVtZW50LCBsYXN0Tm9kZSk7XG4gICAgaWYgKG5ld0lkID09PSBzb2x2ZXJfMS5ORVdfRk9DVVMpIHtcbiAgICAgICAgdmFyIGZvY3VzTm9kZSA9ICgwLCBhdXRvX2ZvY3VzXzEucGlja0F1dG9mb2N1cykoYW55Rm9jdXNhYmxlLCBpbm5lck5vZGVzLCAoMCwgcGFyZW50aW5nXzEuYWxsUGFyZW50QXV0b2ZvY3VzYWJsZXMpKGVudHJpZXMsIHZpc2liaWxpdHlDYWNoZSkpO1xuICAgICAgICBpZiAoZm9jdXNOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiBmb2N1c05vZGUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignZm9jdXMtbG9jazogY2Fubm90IGZpbmQgYW55IG5vZGUgdG8gbW92ZSBmb2N1cyBpbnRvJyk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChuZXdJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXdJZDtcbiAgICB9XG4gICAgcmV0dXJuIG9yZGVyZWRJbm5lckVsZW1lbnRzW25ld0lkXTtcbn07XG5leHBvcnRzLmdldEZvY3VzTWVyZ2UgPSBnZXRGb2N1c01lcmdlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEZvY3VzYWJsZUluID0gZXhwb3J0cy5nZXRGb2N1c2FibGVkSW4gPSB2b2lkIDA7XG52YXIgRE9NdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL0RPTXV0aWxzXCIpO1xudmFyIGFsbF9hZmZlY3RlZF8xID0gcmVxdWlyZShcIi4vdXRpbHMvYWxsLWFmZmVjdGVkXCIpO1xudmFyIGlzXzEgPSByZXF1aXJlKFwiLi91dGlscy9pc1wiKTtcbnZhciBwYXJlbnRpbmdfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL3BhcmVudGluZ1wiKTtcbi8qKlxuICogcmV0dXJuIGxpc3Qgb2YgZm9jdXNhYmxlIGVsZW1lbnRzIGluc2lkZSBhIGdpdmVuIHRvcCBub2RlXG4gKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rIGdldEZvY3VzYWJsZUlufS4gWWVwLCB0aGVyZSBpcyB0eXBvIGluIHRoZSBmdW5jdGlvbiBuYW1lXG4gKi9cbnZhciBnZXRGb2N1c2FibGVkSW4gPSBmdW5jdGlvbiAodG9wTm9kZSkge1xuICAgIHZhciBlbnRyaWVzID0gKDAsIGFsbF9hZmZlY3RlZF8xLmdldEFsbEFmZmVjdGVkTm9kZXMpKHRvcE5vZGUpLmZpbHRlcihpc18xLmlzTm90QUd1YXJkKTtcbiAgICB2YXIgY29tbW9uUGFyZW50ID0gKDAsIHBhcmVudGluZ18xLmdldFRvcENvbW1vblBhcmVudCkodG9wTm9kZSwgdG9wTm9kZSwgZW50cmllcyk7XG4gICAgdmFyIHZpc2liaWxpdHlDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB2YXIgb3V0ZXJOb2RlcyA9ICgwLCBET011dGlsc18xLmdldFRhYmJhYmxlTm9kZXMpKFtjb21tb25QYXJlbnRdLCB2aXNpYmlsaXR5Q2FjaGUsIHRydWUpO1xuICAgIHZhciBpbm5lckVsZW1lbnRzID0gKDAsIERPTXV0aWxzXzEuZ2V0VGFiYmFibGVOb2RlcykoZW50cmllcywgdmlzaWJpbGl0eUNhY2hlKVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiAoMCwgaXNfMS5pc05vdEFHdWFyZCkobm9kZSk7XG4gICAgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0ZXJOb2Rlcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZSwgaW5kZXggPSBfYS5pbmRleDtcbiAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgbG9ja0l0ZW06IGlubmVyRWxlbWVudHMuaW5kZXhPZihub2RlKSA+PSAwLFxuICAgICAgICAgICAgZ3VhcmQ6ICgwLCBpc18xLmlzR3VhcmQpKG5vZGUpLFxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5leHBvcnRzLmdldEZvY3VzYWJsZWRJbiA9IGdldEZvY3VzYWJsZWRJbjtcbi8qKlxuICogcmV0dXJuIGxpc3Qgb2YgZm9jdXNhYmxlIGVsZW1lbnRzIGluc2lkZSBhIGdpdmVuIHRvcCBub2RlXG4gKi9cbmV4cG9ydHMuZ2V0Rm9jdXNhYmxlSW4gPSBleHBvcnRzLmdldEZvY3VzYWJsZWRJbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRBY3RpdmVFbGVtZW50ID0gZXhwb3J0cy5mb2N1c1ByZXZFbGVtZW50ID0gZXhwb3J0cy5mb2N1c05leHRFbGVtZW50ID0gZXhwb3J0cy5nZXRBbGxBZmZlY3RlZE5vZGVzID0gZXhwb3J0cy5jb25zdGFudHMgPSBleHBvcnRzLmdldEZvY3VzYWJsZWRJbiA9IGV4cG9ydHMuZ2V0Rm9jdXNhYmxlSW4gPSBleHBvcnRzLmZvY3VzTWVyZ2UgPSBleHBvcnRzLmZvY3VzSXNIaWRkZW4gPSBleHBvcnRzLmZvY3VzSW5zaWRlID0gZXhwb3J0cy50YWJIb29rID0gdm9pZCAwO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY29uc3RhbnRzID0gKDAsIHRzbGliXzEuX19pbXBvcnRTdGFyKShyZXF1aXJlKFwiLi9jb25zdGFudHNcIikpO1xuZXhwb3J0cy5jb25zdGFudHMgPSBjb25zdGFudHM7XG52YXIgZm9jdXNJbnNpZGVfMSA9IHJlcXVpcmUoXCIuL2ZvY3VzSW5zaWRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZm9jdXNJbnNpZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZvY3VzSW5zaWRlXzEuZm9jdXNJbnNpZGU7IH0gfSk7XG52YXIgZm9jdXNJc0hpZGRlbl8xID0gcmVxdWlyZShcIi4vZm9jdXNJc0hpZGRlblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZvY3VzSXNIaWRkZW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZvY3VzSXNIaWRkZW5fMS5mb2N1c0lzSGlkZGVuOyB9IH0pO1xudmFyIGZvY3VzTWVyZ2VfMSA9IHJlcXVpcmUoXCIuL2ZvY3VzTWVyZ2VcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmb2N1c01lcmdlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmb2N1c01lcmdlXzEuZ2V0Rm9jdXNNZXJnZTsgfSB9KTtcbnZhciBmb2N1c2FibGVzXzEgPSByZXF1aXJlKFwiLi9mb2N1c2FibGVzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Rm9jdXNhYmxlZEluXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmb2N1c2FibGVzXzEuZ2V0Rm9jdXNhYmxlZEluOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Rm9jdXNhYmxlSW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZvY3VzYWJsZXNfMS5nZXRGb2N1c2FibGVJbjsgfSB9KTtcbnZhciBzZXRGb2N1c18xID0gcmVxdWlyZShcIi4vc2V0Rm9jdXNcIik7XG52YXIgc2libGluZ18xID0gcmVxdWlyZShcIi4vc2libGluZ1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZvY3VzTmV4dEVsZW1lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNpYmxpbmdfMS5mb2N1c05leHRFbGVtZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZm9jdXNQcmV2RWxlbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2libGluZ18xLmZvY3VzUHJldkVsZW1lbnQ7IH0gfSk7XG52YXIgdGFiSG9va18xID0gKDAsIHRzbGliXzEuX19pbXBvcnREZWZhdWx0KShyZXF1aXJlKFwiLi90YWJIb29rXCIpKTtcbmV4cG9ydHMudGFiSG9vayA9IHRhYkhvb2tfMS5kZWZhdWx0O1xudmFyIGFsbF9hZmZlY3RlZF8xID0gcmVxdWlyZShcIi4vdXRpbHMvYWxsLWFmZmVjdGVkXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0QWxsQWZmZWN0ZWROb2Rlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWxsX2FmZmVjdGVkXzEuZ2V0QWxsQWZmZWN0ZWROb2RlczsgfSB9KTtcbnZhciBnZXRBY3RpdmVFbGVtZW50XzEgPSByZXF1aXJlKFwiLi91dGlscy9nZXRBY3RpdmVFbGVtZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0QWN0aXZlRWxlbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0QWN0aXZlRWxlbWVudF8xLmdldEFjdGl2ZUVsZW1lbnQ7IH0gfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBzZXRGb2N1c18xLnNldEZvY3VzO1xuLy9cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXRGb2N1cyA9IGV4cG9ydHMuZm9jdXNPbiA9IHZvaWQgMDtcbnZhciBmb2N1c01lcmdlXzEgPSByZXF1aXJlKFwiLi9mb2N1c01lcmdlXCIpO1xudmFyIGZvY3VzT24gPSBmdW5jdGlvbiAodGFyZ2V0LCBmb2N1c09wdGlvbnMpIHtcbiAgICBpZiAoJ2ZvY3VzJyBpbiB0YXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0LmZvY3VzKGZvY3VzT3B0aW9ucyk7XG4gICAgfVxuICAgIGlmICgnY29udGVudFdpbmRvdycgaW4gdGFyZ2V0ICYmIHRhcmdldC5jb250ZW50V2luZG93KSB7XG4gICAgICAgIHRhcmdldC5jb250ZW50V2luZG93LmZvY3VzKCk7XG4gICAgfVxufTtcbmV4cG9ydHMuZm9jdXNPbiA9IGZvY3VzT247XG52YXIgZ3VhcmRDb3VudCA9IDA7XG52YXIgbG9ja0Rpc2FibGVkID0gZmFsc2U7XG4vKipcbiAqIFNldHMgZm9jdXMgYXQgYSBnaXZlbiBub2RlLiBUaGUgbGFzdCBmb2N1c2VkIGVsZW1lbnQgd2lsbCBoZWxwIHRvIGRldGVybWluZSB3aGljaCBlbGVtZW50KGZpcnN0IG9yIGxhc3QpIHNob3VsZCBiZSBmb2N1c2VkLlxuICogSFRNTCBtYXJrZXJzIChzZWUge0BsaW5rIF9faW1wb3J0X18oJy4vY29uc3RhbnRzJykuRk9DVVNfQVVUT30gY29uc3RhbnRzKSBjYW4gY29udHJvbCBhdXRvZm9jdXNcbiAqIEBwYXJhbSB0b3BOb2RlXG4gKiBAcGFyYW0gbGFzdE5vZGVcbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbnZhciBzZXRGb2N1cyA9IGZ1bmN0aW9uICh0b3BOb2RlLCBsYXN0Tm9kZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIGZvY3VzYWJsZSA9ICgwLCBmb2N1c01lcmdlXzEuZ2V0Rm9jdXNNZXJnZSkodG9wTm9kZSwgbGFzdE5vZGUpO1xuICAgIGlmIChsb2NrRGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZm9jdXNhYmxlKSB7XG4gICAgICAgIGlmIChndWFyZENvdW50ID4gMikge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZvY3VzTG9jazogZm9jdXMtZmlnaHRpbmcgZGV0ZWN0ZWQuIE9ubHkgb25lIGZvY3VzIG1hbmFnZW1lbnQgc3lzdGVtIGNvdWxkIGJlIGFjdGl2ZS4gJyArXG4gICAgICAgICAgICAgICAgJ1NlZSBodHRwczovL2dpdGh1Yi5jb20vdGhlS2FzaGV5L2ZvY3VzLWxvY2svI2ZvY3VzLWZpZ2h0aW5nJyk7XG4gICAgICAgICAgICBsb2NrRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbG9ja0Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBndWFyZENvdW50Kys7XG4gICAgICAgICgwLCBleHBvcnRzLmZvY3VzT24pKGZvY3VzYWJsZS5ub2RlLCBvcHRpb25zLmZvY3VzT3B0aW9ucyk7XG4gICAgICAgIGd1YXJkQ291bnQtLTtcbiAgICB9XG59O1xuZXhwb3J0cy5zZXRGb2N1cyA9IHNldEZvY3VzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvY3VzUHJldkVsZW1lbnQgPSBleHBvcnRzLmZvY3VzTmV4dEVsZW1lbnQgPSB2b2lkIDA7XG52YXIgc2V0Rm9jdXNfMSA9IHJlcXVpcmUoXCIuL3NldEZvY3VzXCIpO1xudmFyIERPTXV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlscy9ET011dGlsc1wiKTtcbnZhciBnZXRSZWxhdGl2ZUZvY3VzYWJsZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzY29wZSkge1xuICAgIGlmICghZWxlbWVudCB8fCAhc2NvcGUgfHwgISgwLCBET011dGlsc18xLmNvbnRhaW5zKShzY29wZSwgZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICB2YXIgZm9jdXNhYmxlcyA9ICgwLCBET011dGlsc18xLmdldFRhYmJhYmxlTm9kZXMpKFtzY29wZV0sIG5ldyBNYXAoKSk7XG4gICAgdmFyIGN1cnJlbnQgPSBmb2N1c2FibGVzLmZpbmRJbmRleChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICByZXR1cm4gbm9kZSA9PT0gZWxlbWVudDtcbiAgICB9KTtcbiAgICBpZiAoY3VycmVudCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwcmV2OiBmb2N1c2FibGVzW2N1cnJlbnQgLSAxXSxcbiAgICAgICAgbmV4dDogZm9jdXNhYmxlc1tjdXJyZW50ICsgMV0sXG4gICAgICAgIGZpcnN0OiBmb2N1c2FibGVzWzBdLFxuICAgICAgICBsYXN0OiBmb2N1c2FibGVzW2ZvY3VzYWJsZXMubGVuZ3RoIC0gMV0sXG4gICAgfTtcbn07XG52YXIgZGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgc2NvcGU6IGRvY3VtZW50LmJvZHksXG4gICAgICAgIGN5Y2xlOiB0cnVlLFxuICAgIH0sIG9wdGlvbnMpO1xufTtcbi8qKlxuICogZm9jdXNlcyBuZXh0IGVsZW1lbnQgaW4gdGhlIHRhYi1vcmRlclxuICogQHBhcmFtIGJhc2VFbGVtZW50IC0gY29tbW9uIHBhcmVudCB0byBzY29wZSBhY3RpdmUgZWxlbWVudCBzZWFyY2ggb3IgdGFiIGN5Y2xlIG9yZGVyXG4gKiBAcGFyYW0ge0ZvY3VzTmV4dE9wdGlvbnN9IFtvcHRpb25zXSAtIGZvY3VzIG9wdGlvbnNcbiAqL1xudmFyIGZvY3VzTmV4dEVsZW1lbnQgPSBmdW5jdGlvbiAoYmFzZUVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IGRlZmF1bHRPcHRpb25zKG9wdGlvbnMpLCBzY29wZSA9IF9hLnNjb3BlLCBjeWNsZSA9IF9hLmN5Y2xlO1xuICAgIHZhciBfYiA9IGdldFJlbGF0aXZlRm9jdXNhYmxlKGJhc2VFbGVtZW50LCBzY29wZSksIG5leHQgPSBfYi5uZXh0LCBmaXJzdCA9IF9iLmZpcnN0O1xuICAgIHZhciBuZXdUYXJnZXQgPSBuZXh0IHx8IChjeWNsZSAmJiBmaXJzdCk7XG4gICAgaWYgKG5ld1RhcmdldCkge1xuICAgICAgICAoMCwgc2V0Rm9jdXNfMS5mb2N1c09uKShuZXdUYXJnZXQubm9kZSwgb3B0aW9ucy5mb2N1c09wdGlvbnMpO1xuICAgIH1cbn07XG5leHBvcnRzLmZvY3VzTmV4dEVsZW1lbnQgPSBmb2N1c05leHRFbGVtZW50O1xuLyoqXG4gKiBmb2N1c2VzIHByZXYgZWxlbWVudCBpbiB0aGUgdGFiIG9yZGVyXG4gKiBAcGFyYW0gYmFzZUVsZW1lbnQgLSBjb21tb24gcGFyZW50IHRvIHNjb3BlIGFjdGl2ZSBlbGVtZW50IHNlYXJjaCBvciB0YWIgY3ljbGUgb3JkZXJcbiAqIEBwYXJhbSB7Rm9jdXNOZXh0T3B0aW9uc30gW29wdGlvbnNdIC0gZm9jdXMgb3B0aW9uc1xuICovXG52YXIgZm9jdXNQcmV2RWxlbWVudCA9IGZ1bmN0aW9uIChiYXNlRWxlbWVudCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIF9hID0gZGVmYXVsdE9wdGlvbnMob3B0aW9ucyksIHNjb3BlID0gX2Euc2NvcGUsIGN5Y2xlID0gX2EuY3ljbGU7XG4gICAgdmFyIF9iID0gZ2V0UmVsYXRpdmVGb2N1c2FibGUoYmFzZUVsZW1lbnQsIHNjb3BlKSwgcHJldiA9IF9iLnByZXYsIGxhc3QgPSBfYi5sYXN0O1xuICAgIHZhciBuZXdUYXJnZXQgPSBwcmV2IHx8IChjeWNsZSAmJiBsYXN0KTtcbiAgICBpZiAobmV3VGFyZ2V0KSB7XG4gICAgICAgICgwLCBzZXRGb2N1c18xLmZvY3VzT24pKG5ld1RhcmdldC5ub2RlLCBvcHRpb25zLmZvY3VzT3B0aW9ucyk7XG4gICAgfVxufTtcbmV4cG9ydHMuZm9jdXNQcmV2RWxlbWVudCA9IGZvY3VzUHJldkVsZW1lbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubmV3Rm9jdXMgPSBleHBvcnRzLk5FV19GT0NVUyA9IHZvaWQgMDtcbnZhciBjb3JyZWN0Rm9jdXNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NvcnJlY3RGb2N1c1wiKTtcbnZhciBmaXJzdEZvY3VzXzEgPSByZXF1aXJlKFwiLi91dGlscy9maXJzdEZvY3VzXCIpO1xudmFyIGlzXzEgPSByZXF1aXJlKFwiLi91dGlscy9pc1wiKTtcbmV4cG9ydHMuTkVXX0ZPQ1VTID0gJ05FV19GT0NVUyc7XG4vKipcbiAqIE1haW4gc29sdmVyIGZvciB0aGUgXCJmaW5kIG5leHQgZm9jdXNcIiBxdWVzdGlvblxuICogQHBhcmFtIGlubmVyTm9kZXNcbiAqIEBwYXJhbSBvdXRlck5vZGVzXG4gKiBAcGFyYW0gYWN0aXZlRWxlbWVudFxuICogQHBhcmFtIGxhc3ROb2RlXG4gKiBAcmV0dXJucyB7bnVtYmVyfHN0cmluZ3x1bmRlZmluZWR8Kn1cbiAqL1xudmFyIG5ld0ZvY3VzID0gZnVuY3Rpb24gKGlubmVyTm9kZXMsIG91dGVyTm9kZXMsIGFjdGl2ZUVsZW1lbnQsIGxhc3ROb2RlKSB7XG4gICAgdmFyIGNudCA9IGlubmVyTm9kZXMubGVuZ3RoO1xuICAgIHZhciBmaXJzdEZvY3VzID0gaW5uZXJOb2Rlc1swXTtcbiAgICB2YXIgbGFzdEZvY3VzID0gaW5uZXJOb2Rlc1tjbnQgLSAxXTtcbiAgICB2YXIgaXNPbkd1YXJkID0gKDAsIGlzXzEuaXNHdWFyZCkoYWN0aXZlRWxlbWVudCk7XG4gICAgLy8gZm9jdXMgaXMgaW5zaWRlXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgaW5uZXJOb2Rlcy5pbmRleE9mKGFjdGl2ZUVsZW1lbnQpID49IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIGFjdGl2ZUluZGV4ID0gYWN0aXZlRWxlbWVudCAhPT0gdW5kZWZpbmVkID8gb3V0ZXJOb2Rlcy5pbmRleE9mKGFjdGl2ZUVsZW1lbnQpIDogLTE7XG4gICAgdmFyIGxhc3RJbmRleCA9IGxhc3ROb2RlID8gb3V0ZXJOb2Rlcy5pbmRleE9mKGxhc3ROb2RlKSA6IGFjdGl2ZUluZGV4O1xuICAgIHZhciBsYXN0Tm9kZUluc2lkZSA9IGxhc3ROb2RlID8gaW5uZXJOb2Rlcy5pbmRleE9mKGxhc3ROb2RlKSA6IC0xO1xuICAgIHZhciBpbmRleERpZmYgPSBhY3RpdmVJbmRleCAtIGxhc3RJbmRleDtcbiAgICB2YXIgZmlyc3ROb2RlSW5kZXggPSBvdXRlck5vZGVzLmluZGV4T2YoZmlyc3RGb2N1cyk7XG4gICAgdmFyIGxhc3ROb2RlSW5kZXggPSBvdXRlck5vZGVzLmluZGV4T2YobGFzdEZvY3VzKTtcbiAgICB2YXIgY29ycmVjdGVkTm9kZXMgPSAoMCwgY29ycmVjdEZvY3VzXzEuY29ycmVjdE5vZGVzKShvdXRlck5vZGVzKTtcbiAgICB2YXIgY29ycmVjdGVkSW5kZXggPSBhY3RpdmVFbGVtZW50ICE9PSB1bmRlZmluZWQgPyBjb3JyZWN0ZWROb2Rlcy5pbmRleE9mKGFjdGl2ZUVsZW1lbnQpIDogLTE7XG4gICAgdmFyIGNvcnJlY3RlZEluZGV4RGlmZiA9IGNvcnJlY3RlZEluZGV4IC0gKGxhc3ROb2RlID8gY29ycmVjdGVkTm9kZXMuaW5kZXhPZihsYXN0Tm9kZSkgOiBhY3RpdmVJbmRleCk7XG4gICAgdmFyIHJldHVybkZpcnN0Tm9kZSA9ICgwLCBmaXJzdEZvY3VzXzEucGlja0ZvY3VzYWJsZSkoaW5uZXJOb2RlcywgMCk7XG4gICAgdmFyIHJldHVybkxhc3ROb2RlID0gKDAsIGZpcnN0Rm9jdXNfMS5waWNrRm9jdXNhYmxlKShpbm5lck5vZGVzLCBjbnQgLSAxKTtcbiAgICAvLyBuZXcgZm9jdXNcbiAgICBpZiAoYWN0aXZlSW5kZXggPT09IC0xIHx8IGxhc3ROb2RlSW5zaWRlID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5ORVdfRk9DVVM7XG4gICAgfVxuICAgIC8vIG9sZCBmb2N1c1xuICAgIGlmICghaW5kZXhEaWZmICYmIGxhc3ROb2RlSW5zaWRlID49IDApIHtcbiAgICAgICAgcmV0dXJuIGxhc3ROb2RlSW5zaWRlO1xuICAgIH1cbiAgICAvLyBmaXJzdCBlbGVtZW50XG4gICAgaWYgKGFjdGl2ZUluZGV4IDw9IGZpcnN0Tm9kZUluZGV4ICYmIGlzT25HdWFyZCAmJiBNYXRoLmFicyhpbmRleERpZmYpID4gMSkge1xuICAgICAgICByZXR1cm4gcmV0dXJuTGFzdE5vZGU7XG4gICAgfVxuICAgIC8vIGxhc3QgZWxlbWVudFxuICAgIGlmIChhY3RpdmVJbmRleCA+PSBsYXN0Tm9kZUluZGV4ICYmIGlzT25HdWFyZCAmJiBNYXRoLmFicyhpbmRleERpZmYpID4gMSkge1xuICAgICAgICByZXR1cm4gcmV0dXJuRmlyc3ROb2RlO1xuICAgIH1cbiAgICAvLyBqdW1wIG91dCwgYnV0IG5vdCBvbiB0aGUgZ3VhcmRcbiAgICBpZiAoaW5kZXhEaWZmICYmIE1hdGguYWJzKGNvcnJlY3RlZEluZGV4RGlmZikgPiAxKSB7XG4gICAgICAgIHJldHVybiBsYXN0Tm9kZUluc2lkZTtcbiAgICB9XG4gICAgLy8gZm9jdXMgYWJvdmUgbG9ja1xuICAgIGlmIChhY3RpdmVJbmRleCA8PSBmaXJzdE5vZGVJbmRleCkge1xuICAgICAgICByZXR1cm4gcmV0dXJuTGFzdE5vZGU7XG4gICAgfVxuICAgIC8vIGZvY3VzIGJlbG93IGxvY2tcbiAgICBpZiAoYWN0aXZlSW5kZXggPiBsYXN0Tm9kZUluZGV4KSB7XG4gICAgICAgIHJldHVybiByZXR1cm5GaXJzdE5vZGU7XG4gICAgfVxuICAgIC8vIGluZGV4IGlzIGluc2lkZSB0YWIgb3JkZXIsIGJ1dCBvdXRzaWRlIExvY2tcbiAgICBpZiAoaW5kZXhEaWZmKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhpbmRleERpZmYpID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhc3ROb2RlSW5zaWRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY250ICsgbGFzdE5vZGVJbnNpZGUgKyBpbmRleERpZmYpICUgY250O1xuICAgIH1cbiAgICAvLyBkbyBub3RoaW5nXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5leHBvcnRzLm5ld0ZvY3VzID0gbmV3Rm9jdXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIGVzbGludC1kaXNhYmxlICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBkZXByZWNhdGVkIGRvZXMgbm90aGluZ1xuICovXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgYXR0YWNoOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgZGV0YWNoOiBmdW5jdGlvbiAoKSB7IH0sXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnRhaW5zID0gZXhwb3J0cy5wYXJlbnRBdXRvZm9jdXNhYmxlcyA9IGV4cG9ydHMuZ2V0QWxsVGFiYmFibGVOb2RlcyA9IGV4cG9ydHMuZ2V0VGFiYmFibGVOb2RlcyA9IGV4cG9ydHMuZmlsdGVyQXV0b0ZvY3VzYWJsZSA9IGV4cG9ydHMuZmlsdGVyRm9jdXNhYmxlID0gdm9pZCAwO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiLi9hcnJheVwiKTtcbnZhciBpc18xID0gcmVxdWlyZShcIi4vaXNcIik7XG52YXIgdGFiT3JkZXJfMSA9IHJlcXVpcmUoXCIuL3RhYk9yZGVyXCIpO1xudmFyIHRhYlV0aWxzXzEgPSByZXF1aXJlKFwiLi90YWJVdGlsc1wiKTtcbi8qKlxuICogZ2l2ZW4gbGlzdCBvZiBmb2N1c2FibGUgZWxlbWVudHMga2VlcHMgdGhlIG9uZXMgdXNlciBjYW4gaW50ZXJhY3Qgd2l0aFxuICogQHBhcmFtIG5vZGVzXG4gKiBAcGFyYW0gdmlzaWJpbGl0eUNhY2hlXG4gKi9cbnZhciBmaWx0ZXJGb2N1c2FibGUgPSBmdW5jdGlvbiAobm9kZXMsIHZpc2liaWxpdHlDYWNoZSkge1xuICAgIHJldHVybiAoMCwgYXJyYXlfMS50b0FycmF5KShub2RlcylcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gKDAsIGlzXzEuaXNWaXNpYmxlQ2FjaGVkKSh2aXNpYmlsaXR5Q2FjaGUsIG5vZGUpOyB9KVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiAoMCwgaXNfMS5ub3RIaWRkZW5JbnB1dCkobm9kZSk7IH0pO1xufTtcbmV4cG9ydHMuZmlsdGVyRm9jdXNhYmxlID0gZmlsdGVyRm9jdXNhYmxlO1xudmFyIGZpbHRlckF1dG9Gb2N1c2FibGUgPSBmdW5jdGlvbiAobm9kZXMsIGNhY2hlKSB7XG4gICAgaWYgKGNhY2hlID09PSB2b2lkIDApIHsgY2FjaGUgPSBuZXcgTWFwKCk7IH1cbiAgICByZXR1cm4gKDAsIGFycmF5XzEudG9BcnJheSkobm9kZXMpLmZpbHRlcihmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gKDAsIGlzXzEuaXNBdXRvRm9jdXNBbGxvd2VkQ2FjaGVkKShjYWNoZSwgbm9kZSk7IH0pO1xufTtcbmV4cG9ydHMuZmlsdGVyQXV0b0ZvY3VzYWJsZSA9IGZpbHRlckF1dG9Gb2N1c2FibGU7XG4vKipcbiAqIG9ubHkgdGFiYmFibGUgb25lc1xuICogKGJ1dCB3aXRoIGd1YXJkcyB3aGljaCB3b3VsZCBiZSBpZ25vcmVkKVxuICovXG52YXIgZ2V0VGFiYmFibGVOb2RlcyA9IGZ1bmN0aW9uICh0b3BOb2RlcywgdmlzaWJpbGl0eUNhY2hlLCB3aXRoR3VhcmRzKSB7XG4gICAgcmV0dXJuICgwLCB0YWJPcmRlcl8xLm9yZGVyQnlUYWJJbmRleCkoKDAsIGV4cG9ydHMuZmlsdGVyRm9jdXNhYmxlKSgoMCwgdGFiVXRpbHNfMS5nZXRGb2N1c2FibGVzKSh0b3BOb2Rlcywgd2l0aEd1YXJkcyksIHZpc2liaWxpdHlDYWNoZSksIHRydWUsIHdpdGhHdWFyZHMpO1xufTtcbmV4cG9ydHMuZ2V0VGFiYmFibGVOb2RlcyA9IGdldFRhYmJhYmxlTm9kZXM7XG4vKipcbiAqIGFjdHVhbGx5IGFueXRoaW5nIFwiZm9jdXNhYmxlXCIsIG5vdCBvbmx5IHRhYmJhYmxlXG4gKiAod2l0aG91dCBndWFyZHMsIGFzIGxvbmcgYXMgdGhleSBhcmUgbm90IGV4cGVjdGVkIHRvIGJlIGZvY3VzZWQpXG4gKi9cbnZhciBnZXRBbGxUYWJiYWJsZU5vZGVzID0gZnVuY3Rpb24gKHRvcE5vZGVzLCB2aXNpYmlsaXR5Q2FjaGUpIHtcbiAgICByZXR1cm4gKDAsIHRhYk9yZGVyXzEub3JkZXJCeVRhYkluZGV4KSgoMCwgZXhwb3J0cy5maWx0ZXJGb2N1c2FibGUpKCgwLCB0YWJVdGlsc18xLmdldEZvY3VzYWJsZXMpKHRvcE5vZGVzKSwgdmlzaWJpbGl0eUNhY2hlKSwgZmFsc2UpO1xufTtcbmV4cG9ydHMuZ2V0QWxsVGFiYmFibGVOb2RlcyA9IGdldEFsbFRhYmJhYmxlTm9kZXM7XG4vKipcbiAqIHJldHVybiBsaXN0IG9mIG5vZGVzIHdoaWNoIGFyZSBleHBlY3RlZCB0byBiZSBhdXRvLWZvY3VzZWRcbiAqIEBwYXJhbSB0b3BOb2RlXG4gKiBAcGFyYW0gdmlzaWJpbGl0eUNhY2hlXG4gKi9cbnZhciBwYXJlbnRBdXRvZm9jdXNhYmxlcyA9IGZ1bmN0aW9uICh0b3BOb2RlLCB2aXNpYmlsaXR5Q2FjaGUpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuZmlsdGVyRm9jdXNhYmxlKSgoMCwgdGFiVXRpbHNfMS5nZXRQYXJlbnRBdXRvZm9jdXNhYmxlcykodG9wTm9kZSksIHZpc2liaWxpdHlDYWNoZSk7XG59O1xuZXhwb3J0cy5wYXJlbnRBdXRvZm9jdXNhYmxlcyA9IHBhcmVudEF1dG9mb2N1c2FibGVzO1xuLypcbiAqIERldGVybWluZXMgaWYgZWxlbWVudCBpcyBjb250YWluZWQgaW4gc2NvcGUsIGluY2x1ZGluZyBuZXN0ZWQgc2hhZG93IERPTXNcbiAqL1xudmFyIGNvbnRhaW5zID0gZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50KSB7XG4gICAgaWYgKHNjb3BlLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLmNvbnRhaW5zKShzY29wZS5zaGFkb3dSb290LCBlbGVtZW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc2NvcGUpLmNvbnRhaW5zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihzY29wZSkuY29udGFpbnMuY2FsbChzY29wZSwgZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgYXJyYXlfMS50b0FycmF5KShzY29wZS5jaGlsZHJlbikuc29tZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlmcmFtZUJvZHkgPSAoX2EgPSBjaGlsZC5jb250ZW50RG9jdW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ib2R5O1xuICAgICAgICAgICAgICAgIGlmIChpZnJhbWVCb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5jb250YWlucykoaWZyYW1lQm9keSwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5jb250YWlucykoY2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuZXhwb3J0cy5jb250YWlucyA9IGNvbnRhaW5zO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEFsbEFmZmVjdGVkTm9kZXMgPSB2b2lkIDA7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiLi9hcnJheVwiKTtcbi8qKlxuICogaW4gY2FzZSBvZiBtdWx0aXBsZSBub2RlcyBuZXN0ZWQgaW5zaWRlIGVhY2ggb3RoZXJcbiAqIGtlZXBzIG9ubHkgdG9wIG9uZXNcbiAqIHRoaXMgaXMgTyhubG9nbilcbiAqIEBwYXJhbSBub2Rlc1xuICogQHJldHVybnMgeyp9XG4gKi9cbnZhciBmaWx0ZXJOZXN0ZWQgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgICB2YXIgY29udGFpbmVkID0gbmV3IFNldCgpO1xuICAgIHZhciBsID0gbm9kZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IGw7IGogKz0gMSkge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gbm9kZXNbaV0uY29tcGFyZURvY3VtZW50UG9zaXRpb24obm9kZXNbal0pO1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAgICAgICAgICAgaWYgKChwb3NpdGlvbiAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZKSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb250YWluZWQuYWRkKGopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChwb3NpdGlvbiAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTlMpID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lZC5hZGQoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzLmZpbHRlcihmdW5jdGlvbiAoXywgaW5kZXgpIHsgcmV0dXJuICFjb250YWluZWQuaGFzKGluZGV4KTsgfSk7XG59O1xuLyoqXG4gKiBmaW5kcyB0b3AgbW9zdCBwYXJlbnQgZm9yIGEgbm9kZVxuICogQHBhcmFtIG5vZGVcbiAqIEByZXR1cm5zIHsqfVxuICovXG52YXIgZ2V0VG9wUGFyZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlID8gZ2V0VG9wUGFyZW50KG5vZGUucGFyZW50Tm9kZSkgOiBub2RlO1xufTtcbi8qKlxuICogcmV0dXJucyBhbGwgXCJmb2N1cyBjb250YWluZXJzXCIgaW5zaWRlIGEgZ2l2ZW4gbm9kZVxuICogQHBhcmFtIG5vZGVcbiAqIEByZXR1cm5zIHtUfVxuICovXG52YXIgZ2V0QWxsQWZmZWN0ZWROb2RlcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIG5vZGVzID0gKDAsIGFycmF5XzEuYXNBcnJheSkobm9kZSk7XG4gICAgcmV0dXJuIG5vZGVzLmZpbHRlcihCb29sZWFuKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3VycmVudE5vZGUpIHtcbiAgICAgICAgdmFyIGdyb3VwID0gY3VycmVudE5vZGUuZ2V0QXR0cmlidXRlKGNvbnN0YW50c18xLkZPQ1VTX0dST1VQKTtcbiAgICAgICAgYWNjLnB1c2guYXBwbHkoYWNjLCAoZ3JvdXBcbiAgICAgICAgICAgID8gZmlsdGVyTmVzdGVkKCgwLCBhcnJheV8xLnRvQXJyYXkpKGdldFRvcFBhcmVudChjdXJyZW50Tm9kZSkucXVlcnlTZWxlY3RvckFsbChcIltcIi5jb25jYXQoY29uc3RhbnRzXzEuRk9DVVNfR1JPVVAsIFwiPVxcXCJcIikuY29uY2F0KGdyb3VwLCBcIlxcXCJdOm5vdChbXCIpLmNvbmNhdChjb25zdGFudHNfMS5GT0NVU19ESVNBQkxFRCwgXCI9XFxcImRpc2FibGVkXFxcIl0pXCIpKSkpXG4gICAgICAgICAgICA6IFtjdXJyZW50Tm9kZV0pKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG59O1xuZXhwb3J0cy5nZXRBbGxBZmZlY3RlZE5vZGVzID0gZ2V0QWxsQWZmZWN0ZWROb2RlcztcbiIsIlwidXNlIHN0cmljdFwiO1xuLypcbklFMTEgc3VwcG9ydFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEZpcnN0ID0gZXhwb3J0cy5hc0FycmF5ID0gZXhwb3J0cy50b0FycmF5ID0gdm9pZCAwO1xudmFyIHRvQXJyYXkgPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciByZXQgPSBBcnJheShhLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJldFtpXSA9IGFbaV07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuZXhwb3J0cy50b0FycmF5ID0gdG9BcnJheTtcbnZhciBhc0FycmF5ID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIChBcnJheS5pc0FycmF5KGEpID8gYSA6IFthXSk7IH07XG5leHBvcnRzLmFzQXJyYXkgPSBhc0FycmF5O1xudmFyIGdldEZpcnN0ID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIChBcnJheS5pc0FycmF5KGEpID8gYVswXSA6IGEpOyB9O1xuZXhwb3J0cy5nZXRGaXJzdCA9IGdldEZpcnN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBpY2tBdXRvZm9jdXMgPSB2b2lkIDA7XG52YXIgRE9NdXRpbHNfMSA9IHJlcXVpcmUoXCIuL0RPTXV0aWxzXCIpO1xudmFyIGZpcnN0Rm9jdXNfMSA9IHJlcXVpcmUoXCIuL2ZpcnN0Rm9jdXNcIik7XG52YXIgaXNfMSA9IHJlcXVpcmUoXCIuL2lzXCIpO1xudmFyIGZpbmRBdXRvRm9jdXNlZCA9IGZ1bmN0aW9uIChhdXRvRm9jdXNhYmxlcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBhdXRvZm9jdXMgPSAoX2EgPSAoMCwgaXNfMS5nZXREYXRhc2V0KShub2RlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1dG9mb2N1cztcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBub2RlLmF1dG9mb2N1cyB8fFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIChhdXRvZm9jdXMgIT09IHVuZGVmaW5lZCAmJiBhdXRvZm9jdXMgIT09ICdmYWxzZScpIHx8XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgYXV0b0ZvY3VzYWJsZXMuaW5kZXhPZihub2RlKSA+PSAwKTtcbiAgICB9O1xufTtcbnZhciBwaWNrQXV0b2ZvY3VzID0gZnVuY3Rpb24gKG5vZGVzSW5kZXhlcywgb3JkZXJlZE5vZGVzLCBncm91cHMpIHtcbiAgICB2YXIgbm9kZXMgPSBub2Rlc0luZGV4ZXMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICAgIHZhciBhdXRvRm9jdXNhYmxlID0gKDAsIERPTXV0aWxzXzEuZmlsdGVyQXV0b0ZvY3VzYWJsZSkobm9kZXMuZmlsdGVyKGZpbmRBdXRvRm9jdXNlZChncm91cHMpKSk7XG4gICAgaWYgKGF1dG9Gb2N1c2FibGUgJiYgYXV0b0ZvY3VzYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBmaXJzdEZvY3VzXzEucGlja0ZpcnN0Rm9jdXMpKGF1dG9Gb2N1c2FibGUpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGZpcnN0Rm9jdXNfMS5waWNrRmlyc3RGb2N1cykoKDAsIERPTXV0aWxzXzEuZmlsdGVyQXV0b0ZvY3VzYWJsZSkob3JkZXJlZE5vZGVzKSk7XG59O1xuZXhwb3J0cy5waWNrQXV0b2ZvY3VzID0gcGlja0F1dG9mb2N1cztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb3JyZWN0Tm9kZXMgPSBleHBvcnRzLmNvcnJlY3ROb2RlID0gdm9pZCAwO1xudmFyIGlzXzEgPSByZXF1aXJlKFwiLi9pc1wiKTtcbnZhciBmaW5kU2VsZWN0ZWRSYWRpbyA9IGZ1bmN0aW9uIChub2RlLCBub2Rlcykge1xuICAgIHJldHVybiBub2Rlc1xuICAgICAgICAuZmlsdGVyKGlzXzEuaXNSYWRpb0VsZW1lbnQpXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5uYW1lID09PSBub2RlLm5hbWU7IH0pXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5jaGVja2VkOyB9KVswXSB8fCBub2RlO1xufTtcbnZhciBjb3JyZWN0Tm9kZSA9IGZ1bmN0aW9uIChub2RlLCBub2Rlcykge1xuICAgIGlmICgoMCwgaXNfMS5pc1JhZGlvRWxlbWVudCkobm9kZSkgJiYgbm9kZS5uYW1lKSB7XG4gICAgICAgIHJldHVybiBmaW5kU2VsZWN0ZWRSYWRpbyhub2RlLCBub2Rlcyk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufTtcbmV4cG9ydHMuY29ycmVjdE5vZGUgPSBjb3JyZWN0Tm9kZTtcbi8qKlxuICogZ2l2aW5nIGEgc2V0IG9mIHJhZGlvIGlucHV0cyBrZWVwcyBvbmx5IHNlbGVjdGVkICh0YWJiYWJsZSkgb25lc1xuICogQHBhcmFtIG5vZGVzXG4gKi9cbnZhciBjb3JyZWN0Tm9kZXMgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAvLyBJRTExIGhhcyBubyBTZXQoYXJyYXkpIGNvbnN0cnVjdG9yXG4gICAgdmFyIHJlc3VsdFNldCA9IG5ldyBTZXQoKTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiByZXN1bHRTZXQuYWRkKCgwLCBleHBvcnRzLmNvcnJlY3ROb2RlKShub2RlLCBub2RlcykpOyB9KTtcbiAgICAvLyB1c2luZyBmaWx0ZXIgdG8gc3VwcG9ydCBJRTExXG4gICAgcmV0dXJuIG5vZGVzLmZpbHRlcihmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gcmVzdWx0U2V0Lmhhcyhub2RlKTsgfSk7XG59O1xuZXhwb3J0cy5jb3JyZWN0Tm9kZXMgPSBjb3JyZWN0Tm9kZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGlja0ZvY3VzYWJsZSA9IGV4cG9ydHMucGlja0ZpcnN0Rm9jdXMgPSB2b2lkIDA7XG52YXIgY29ycmVjdEZvY3VzXzEgPSByZXF1aXJlKFwiLi9jb3JyZWN0Rm9jdXNcIik7XG52YXIgcGlja0ZpcnN0Rm9jdXMgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgICBpZiAobm9kZXNbMF0gJiYgbm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm4gKDAsIGNvcnJlY3RGb2N1c18xLmNvcnJlY3ROb2RlKShub2Rlc1swXSwgbm9kZXMpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXNbMF07XG59O1xuZXhwb3J0cy5waWNrRmlyc3RGb2N1cyA9IHBpY2tGaXJzdEZvY3VzO1xudmFyIHBpY2tGb2N1c2FibGUgPSBmdW5jdGlvbiAobm9kZXMsIGluZGV4KSB7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVzLmluZGV4T2YoKDAsIGNvcnJlY3RGb2N1c18xLmNvcnJlY3ROb2RlKShub2Rlc1tpbmRleF0sIG5vZGVzKSk7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbn07XG5leHBvcnRzLnBpY2tGb2N1c2FibGUgPSBwaWNrRm9jdXNhYmxlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEFjdGl2ZUVsZW1lbnQgPSB2b2lkIDA7XG4vKipcbiAqIHJldHVybnMgYWN0aXZlIGVsZW1lbnQgZnJvbSBkb2N1bWVudCBvciBmcm9tIG5lc3RlZCBzaGFkb3dkb21zXG4gKi9cbnZhciBzYWZlXzEgPSByZXF1aXJlKFwiLi9zYWZlXCIpO1xudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSBmdW5jdGlvbiAoaW5Eb2N1bWVudCkge1xuICAgIGlmIChpbkRvY3VtZW50ID09PSB2b2lkIDApIHsgaW5Eb2N1bWVudCA9IGRvY3VtZW50OyB9XG4gICAgaWYgKCFpbkRvY3VtZW50IHx8ICFpbkRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBpbkRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgcmV0dXJuIChhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3RcbiAgICAgICAgPyAoMCwgZXhwb3J0cy5nZXRBY3RpdmVFbGVtZW50KShhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QpXG4gICAgICAgIDogYWN0aXZlRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJRnJhbWVFbGVtZW50ICYmICgwLCBzYWZlXzEuc2FmZVByb2JlKShmdW5jdGlvbiAoKSB7IHJldHVybiBhY3RpdmVFbGVtZW50LmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7IH0pXG4gICAgICAgICAgICA/ICgwLCBleHBvcnRzLmdldEFjdGl2ZUVsZW1lbnQpKGFjdGl2ZUVsZW1lbnQuY29udGVudFdpbmRvdy5kb2N1bWVudClcbiAgICAgICAgICAgIDogYWN0aXZlRWxlbWVudCk7XG59O1xuZXhwb3J0cy5nZXRBY3RpdmVFbGVtZW50ID0gZ2V0QWN0aXZlRWxlbWVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0RlZmluZWQgPSBleHBvcnRzLmlzTm90QUd1YXJkID0gZXhwb3J0cy5pc0d1YXJkID0gZXhwb3J0cy5pc0F1dG9Gb2N1c0FsbG93ZWQgPSBleHBvcnRzLm5vdEhpZGRlbklucHV0ID0gZXhwb3J0cy5pc1JhZGlvRWxlbWVudCA9IGV4cG9ydHMuaXNIVE1MSW5wdXRFbGVtZW50ID0gZXhwb3J0cy5pc0hUTUxCdXR0b25FbGVtZW50ID0gZXhwb3J0cy5nZXREYXRhc2V0ID0gZXhwb3J0cy5pc0F1dG9Gb2N1c0FsbG93ZWRDYWNoZWQgPSBleHBvcnRzLmlzVmlzaWJsZUNhY2hlZCA9IHZvaWQgMDtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG52YXIgaXNFbGVtZW50SGlkZGVuID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAvLyB3ZSBjYW4gbWVhc3VyZSBvbmx5IFwiZWxlbWVudHNcIlxuICAgIC8vIGNvbnNpZGVyIG90aGVycyBhcyBcInZpc2libGVcIlxuICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCk7XG4gICAgaWYgKCFjb21wdXRlZFN0eWxlIHx8ICFjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpID09PSAnbm9uZScgfHwgY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCd2aXNpYmlsaXR5JykgPT09ICdoaWRkZW4nKTtcbn07XG52YXIgZ2V0UGFyZW50Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgLy8gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSBjYW4gYWxzbyBwb2ludCBvbiBTaGFkb3dSb290LiBJbiB0aGlzIGNhc2UgLmhvc3Qgd2lsbCBwb2ludCBvbiB0aGUgbmV4dCBub2RlXG4gICAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZSAmJiBub2RlLnBhcmVudE5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERVxuICAgICAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaG9zdFxuICAgICAgICA6IG5vZGUucGFyZW50Tm9kZTtcbn07XG52YXIgaXNUb3BOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIG5vZGUgPT09IGRvY3VtZW50IHx8IChub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfTk9ERSk7XG59O1xudmFyIGlzVmlzaWJsZVVuY2FjaGVkID0gZnVuY3Rpb24gKG5vZGUsIGNoZWNrUGFyZW50KSB7XG4gICAgcmV0dXJuICFub2RlIHx8IGlzVG9wTm9kZShub2RlKSB8fCAoIWlzRWxlbWVudEhpZGRlbihub2RlKSAmJiBjaGVja1BhcmVudChnZXRQYXJlbnROb2RlKG5vZGUpKSk7XG59O1xudmFyIGlzVmlzaWJsZUNhY2hlZCA9IGZ1bmN0aW9uICh2aXNpYmlsaXR5Q2FjaGUsIG5vZGUpIHtcbiAgICB2YXIgY2FjaGVkID0gdmlzaWJpbGl0eUNhY2hlLmdldChub2RlKTtcbiAgICBpZiAoY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGlzVmlzaWJsZVVuY2FjaGVkKG5vZGUsIGV4cG9ydHMuaXNWaXNpYmxlQ2FjaGVkLmJpbmQodW5kZWZpbmVkLCB2aXNpYmlsaXR5Q2FjaGUpKTtcbiAgICB2aXNpYmlsaXR5Q2FjaGUuc2V0KG5vZGUsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLmlzVmlzaWJsZUNhY2hlZCA9IGlzVmlzaWJsZUNhY2hlZDtcbnZhciBpc0F1dG9Gb2N1c0FsbG93ZWRVbmNhY2hlZCA9IGZ1bmN0aW9uIChub2RlLCBjaGVja1BhcmVudCkge1xuICAgIHJldHVybiBub2RlICYmICFpc1RvcE5vZGUobm9kZSkgPyAoKDAsIGV4cG9ydHMuaXNBdXRvRm9jdXNBbGxvd2VkKShub2RlKSA/IGNoZWNrUGFyZW50KGdldFBhcmVudE5vZGUobm9kZSkpIDogZmFsc2UpIDogdHJ1ZTtcbn07XG52YXIgaXNBdXRvRm9jdXNBbGxvd2VkQ2FjaGVkID0gZnVuY3Rpb24gKGNhY2hlLCBub2RlKSB7XG4gICAgdmFyIGNhY2hlZCA9IGNhY2hlLmdldChub2RlKTtcbiAgICBpZiAoY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGlzQXV0b0ZvY3VzQWxsb3dlZFVuY2FjaGVkKG5vZGUsIGV4cG9ydHMuaXNBdXRvRm9jdXNBbGxvd2VkQ2FjaGVkLmJpbmQodW5kZWZpbmVkLCBjYWNoZSkpO1xuICAgIGNhY2hlLnNldChub2RlLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5pc0F1dG9Gb2N1c0FsbG93ZWRDYWNoZWQgPSBpc0F1dG9Gb2N1c0FsbG93ZWRDYWNoZWQ7XG52YXIgZ2V0RGF0YXNldCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBub2RlLmRhdGFzZXQ7XG59O1xuZXhwb3J0cy5nZXREYXRhc2V0ID0gZ2V0RGF0YXNldDtcbnZhciBpc0hUTUxCdXR0b25FbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gJ0JVVFRPTic7IH07XG5leHBvcnRzLmlzSFRNTEJ1dHRvbkVsZW1lbnQgPSBpc0hUTUxCdXR0b25FbGVtZW50O1xudmFyIGlzSFRNTElucHV0RWxlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnRhZ05hbWUgPT09ICdJTlBVVCc7IH07XG5leHBvcnRzLmlzSFRNTElucHV0RWxlbWVudCA9IGlzSFRNTElucHV0RWxlbWVudDtcbnZhciBpc1JhZGlvRWxlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmlzSFRNTElucHV0RWxlbWVudCkobm9kZSkgJiYgbm9kZS50eXBlID09PSAncmFkaW8nO1xufTtcbmV4cG9ydHMuaXNSYWRpb0VsZW1lbnQgPSBpc1JhZGlvRWxlbWVudDtcbnZhciBub3RIaWRkZW5JbnB1dCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuICEoKCgwLCBleHBvcnRzLmlzSFRNTElucHV0RWxlbWVudCkobm9kZSkgfHwgKDAsIGV4cG9ydHMuaXNIVE1MQnV0dG9uRWxlbWVudCkobm9kZSkpICYmIChub2RlLnR5cGUgPT09ICdoaWRkZW4nIHx8IG5vZGUuZGlzYWJsZWQpKTtcbn07XG5leHBvcnRzLm5vdEhpZGRlbklucHV0ID0gbm90SGlkZGVuSW5wdXQ7XG52YXIgaXNBdXRvRm9jdXNBbGxvd2VkID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgYXR0cmlidXRlID0gbm9kZS5nZXRBdHRyaWJ1dGUoY29uc3RhbnRzXzEuRk9DVVNfTk9fQVVUT0ZPQ1VTKTtcbiAgICByZXR1cm4gIVt0cnVlLCAndHJ1ZScsICcnXS5pbmNsdWRlcyhhdHRyaWJ1dGUpO1xufTtcbmV4cG9ydHMuaXNBdXRvRm9jdXNBbGxvd2VkID0gaXNBdXRvRm9jdXNBbGxvd2VkO1xudmFyIGlzR3VhcmQgPSBmdW5jdGlvbiAobm9kZSkgeyB2YXIgX2E7IHJldHVybiBCb29sZWFuKG5vZGUgJiYgKChfYSA9ICgwLCBleHBvcnRzLmdldERhdGFzZXQpKG5vZGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9jdXNHdWFyZCkpOyB9O1xuZXhwb3J0cy5pc0d1YXJkID0gaXNHdWFyZDtcbnZhciBpc05vdEFHdWFyZCA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiAhKDAsIGV4cG9ydHMuaXNHdWFyZCkobm9kZSk7IH07XG5leHBvcnRzLmlzTm90QUd1YXJkID0gaXNOb3RBR3VhcmQ7XG52YXIgaXNEZWZpbmVkID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIEJvb2xlYW4oeCk7IH07XG5leHBvcnRzLmlzRGVmaW5lZCA9IGlzRGVmaW5lZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hbGxQYXJlbnRBdXRvZm9jdXNhYmxlcyA9IGV4cG9ydHMuZ2V0VG9wQ29tbW9uUGFyZW50ID0gZXhwb3J0cy5nZXRDb21tb25QYXJlbnQgPSB2b2lkIDA7XG52YXIgRE9NdXRpbHNfMSA9IHJlcXVpcmUoXCIuL0RPTXV0aWxzXCIpO1xudmFyIERPTXV0aWxzXzIgPSByZXF1aXJlKFwiLi9ET011dGlsc1wiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcIi4vYXJyYXlcIik7XG52YXIgZ2V0UGFyZW50cyA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnRzKSB7XG4gICAgaWYgKHBhcmVudHMgPT09IHZvaWQgMCkgeyBwYXJlbnRzID0gW107IH1cbiAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBnZXRQYXJlbnRzKG5vZGUucGFyZW50Tm9kZS5ob3N0IHx8IG5vZGUucGFyZW50Tm9kZSwgcGFyZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRzO1xufTtcbi8qKlxuICogZmluZHMgYSBwYXJlbnQgZm9yIGJvdGggbm9kZUEgYW5kIG5vZGVCXG4gKiBAcGFyYW0gbm9kZUFcbiAqIEBwYXJhbSBub2RlQlxuICogQHJldHVybnMge2Jvb2xlYW58Kn1cbiAqL1xudmFyIGdldENvbW1vblBhcmVudCA9IGZ1bmN0aW9uIChub2RlQSwgbm9kZUIpIHtcbiAgICB2YXIgcGFyZW50c0EgPSBnZXRQYXJlbnRzKG5vZGVBKTtcbiAgICB2YXIgcGFyZW50c0IgPSBnZXRQYXJlbnRzKG5vZGVCKTtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6cHJlZmVyLWZvci1vZlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50c0EubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnRzQVtpXTtcbiAgICAgICAgaWYgKHBhcmVudHNCLmluZGV4T2YoY3VycmVudFBhcmVudCkgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmV4cG9ydHMuZ2V0Q29tbW9uUGFyZW50ID0gZ2V0Q29tbW9uUGFyZW50O1xudmFyIGdldFRvcENvbW1vblBhcmVudCA9IGZ1bmN0aW9uIChiYXNlQWN0aXZlRWxlbWVudCwgbGVmdEVudHJ5LCByaWdodEVudHJpZXMpIHtcbiAgICB2YXIgYWN0aXZlRWxlbWVudHMgPSAoMCwgYXJyYXlfMS5hc0FycmF5KShiYXNlQWN0aXZlRWxlbWVudCk7XG4gICAgdmFyIGxlZnRFbnRyaWVzID0gKDAsIGFycmF5XzEuYXNBcnJheSkobGVmdEVudHJ5KTtcbiAgICB2YXIgYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnRzWzBdO1xuICAgIHZhciB0b3BDb21tb24gPSBmYWxzZTtcbiAgICBsZWZ0RW50cmllcy5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgdG9wQ29tbW9uID0gKDAsIGV4cG9ydHMuZ2V0Q29tbW9uUGFyZW50KSh0b3BDb21tb24gfHwgZW50cnksIGVudHJ5KSB8fCB0b3BDb21tb247XG4gICAgICAgIHJpZ2h0RW50cmllcy5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChmdW5jdGlvbiAoc3ViRW50cnkpIHtcbiAgICAgICAgICAgIHZhciBjb21tb24gPSAoMCwgZXhwb3J0cy5nZXRDb21tb25QYXJlbnQpKGFjdGl2ZUVsZW1lbnQsIHN1YkVudHJ5KTtcbiAgICAgICAgICAgIGlmIChjb21tb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRvcENvbW1vbiB8fCAoMCwgRE9NdXRpbHNfMi5jb250YWlucykoY29tbW9uLCB0b3BDb21tb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcENvbW1vbiA9IGNvbW1vbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcENvbW1vbiA9ICgwLCBleHBvcnRzLmdldENvbW1vblBhcmVudCkoY29tbW9uLCB0b3BDb21tb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gVE9ETzogYWRkIGFzc2VydCBoZXJlP1xuICAgIHJldHVybiB0b3BDb21tb247XG59O1xuZXhwb3J0cy5nZXRUb3BDb21tb25QYXJlbnQgPSBnZXRUb3BDb21tb25QYXJlbnQ7XG4vKipcbiAqIHJldHVybiBsaXN0IG9mIG5vZGVzIHdoaWNoIGFyZSBleHBlY3RlZCB0byBiZSBhdXRvZm9jdXNlZCBpbnNpZGUgYSBnaXZlbiB0b3Agbm9kZXNcbiAqIEBwYXJhbSBlbnRyaWVzXG4gKiBAcGFyYW0gdmlzaWJpbGl0eUNhY2hlXG4gKi9cbnZhciBhbGxQYXJlbnRBdXRvZm9jdXNhYmxlcyA9IGZ1bmN0aW9uIChlbnRyaWVzLCB2aXNpYmlsaXR5Q2FjaGUpIHtcbiAgICByZXR1cm4gZW50cmllcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgbm9kZSkgeyByZXR1cm4gYWNjLmNvbmNhdCgoMCwgRE9NdXRpbHNfMS5wYXJlbnRBdXRvZm9jdXNhYmxlcykobm9kZSwgdmlzaWJpbGl0eUNhY2hlKSk7IH0sIFtdKTtcbn07XG5leHBvcnRzLmFsbFBhcmVudEF1dG9mb2N1c2FibGVzID0gYWxsUGFyZW50QXV0b2ZvY3VzYWJsZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2FmZVByb2JlID0gdm9pZCAwO1xudmFyIHNhZmVQcm9iZSA9IGZ1bmN0aW9uIChjYikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYigpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5leHBvcnRzLnNhZmVQcm9iZSA9IHNhZmVQcm9iZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vcmRlckJ5VGFiSW5kZXggPSBleHBvcnRzLnRhYlNvcnQgPSB2b2lkIDA7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FycmF5XCIpO1xudmFyIHRhYlNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciB0YWJEaWZmID0gYS50YWJJbmRleCAtIGIudGFiSW5kZXg7XG4gICAgdmFyIGluZGV4RGlmZiA9IGEuaW5kZXggLSBiLmluZGV4O1xuICAgIGlmICh0YWJEaWZmKSB7XG4gICAgICAgIGlmICghYS50YWJJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFiLnRhYkluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhYkRpZmYgfHwgaW5kZXhEaWZmO1xufTtcbmV4cG9ydHMudGFiU29ydCA9IHRhYlNvcnQ7XG52YXIgb3JkZXJCeVRhYkluZGV4ID0gZnVuY3Rpb24gKG5vZGVzLCBmaWx0ZXJOZWdhdGl2ZSwga2VlcEd1YXJkcykge1xuICAgIHJldHVybiAoMCwgYXJyYXlfMS50b0FycmF5KShub2RlcylcbiAgICAgICAgLm1hcChmdW5jdGlvbiAobm9kZSwgaW5kZXgpIHsgcmV0dXJuICh7XG4gICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgdGFiSW5kZXg6IGtlZXBHdWFyZHMgJiYgbm9kZS50YWJJbmRleCA9PT0gLTEgPyAoKG5vZGUuZGF0YXNldCB8fCB7fSkuZm9jdXNHdWFyZCA/IDAgOiAtMSkgOiBub2RlLnRhYkluZGV4LFxuICAgIH0pOyB9KVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiAhZmlsdGVyTmVnYXRpdmUgfHwgZGF0YS50YWJJbmRleCA+PSAwOyB9KVxuICAgICAgICAuc29ydChleHBvcnRzLnRhYlNvcnQpO1xufTtcbmV4cG9ydHMub3JkZXJCeVRhYkluZGV4ID0gb3JkZXJCeVRhYkluZGV4O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFBhcmVudEF1dG9mb2N1c2FibGVzID0gZXhwb3J0cy5nZXRGb2N1c2FibGVzID0gdm9pZCAwO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcIi4vYXJyYXlcIik7XG52YXIgdGFiYmFibGVzXzEgPSByZXF1aXJlKFwiLi90YWJiYWJsZXNcIik7XG52YXIgcXVlcnlUYWJiYWJsZXMgPSB0YWJiYWJsZXNfMS50YWJiYWJsZXMuam9pbignLCcpO1xudmFyIHF1ZXJ5R3VhcmRUYWJiYWJsZXMgPSBcIlwiLmNvbmNhdChxdWVyeVRhYmJhYmxlcywgXCIsIFtkYXRhLWZvY3VzLWd1YXJkXVwiKTtcbnZhciBnZXRGb2N1c2FibGVzV2l0aFNoYWRvd0RvbSA9IGZ1bmN0aW9uIChwYXJlbnQsIHdpdGhHdWFyZHMpIHtcbiAgICByZXR1cm4gKDAsIGFycmF5XzEudG9BcnJheSkoKHBhcmVudC5zaGFkb3dSb290IHx8IHBhcmVudCkuY2hpbGRyZW4pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjaGlsZCkge1xuICAgICAgICByZXR1cm4gYWNjLmNvbmNhdChjaGlsZC5tYXRjaGVzKHdpdGhHdWFyZHMgPyBxdWVyeUd1YXJkVGFiYmFibGVzIDogcXVlcnlUYWJiYWJsZXMpID8gW2NoaWxkXSA6IFtdLCBnZXRGb2N1c2FibGVzV2l0aFNoYWRvd0RvbShjaGlsZCkpO1xuICAgIH0sIFtdKTtcbn07XG52YXIgZ2V0Rm9jdXNhYmxlc1dpdGhJRnJhbWUgPSBmdW5jdGlvbiAocGFyZW50LCB3aXRoR3VhcmRzKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIGNvbnRlbnREb2N1bWVudCBvZiBpZnJhbWUgd2lsbCBiZSBudWxsIGlmIGN1cnJlbnQgb3JpZ2luIGNhbm5vdCBhY2Nlc3MgaXRcbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgSFRNTElGcmFtZUVsZW1lbnQgJiYgKChfYSA9IHBhcmVudC5jb250ZW50RG9jdW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ib2R5KSkge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuZ2V0Rm9jdXNhYmxlcykoW3BhcmVudC5jb250ZW50RG9jdW1lbnQuYm9keV0sIHdpdGhHdWFyZHMpO1xuICAgIH1cbiAgICByZXR1cm4gW3BhcmVudF07XG59O1xudmFyIGdldEZvY3VzYWJsZXMgPSBmdW5jdGlvbiAocGFyZW50cywgd2l0aEd1YXJkcykge1xuICAgIHJldHVybiBwYXJlbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgZm9jdXNhYmxlV2l0aFNoYWRvd0RvbSA9IGdldEZvY3VzYWJsZXNXaXRoU2hhZG93RG9tKHBhcmVudCwgd2l0aEd1YXJkcyk7XG4gICAgICAgIHZhciBmb2N1c2FibGVXaXRoSWZyYW1lcyA9IChfYSA9IFtdKS5jb25jYXQuYXBwbHkoX2EsIGZvY3VzYWJsZVdpdGhTaGFkb3dEb20ubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBnZXRGb2N1c2FibGVzV2l0aElGcmFtZShub2RlLCB3aXRoR3VhcmRzKTsgfSkpO1xuICAgICAgICByZXR1cm4gYWNjLmNvbmNhdChcbiAgICAgICAgLy8gYWRkIGFsbCB0YWJiYWJsZXMgaW5zaWRlIGFuZCB3aXRoaW4gc2hhZG93IERPTXMgaW4gRE9NIG9yZGVyXG4gICAgICAgIGZvY3VzYWJsZVdpdGhJZnJhbWVzLCBcbiAgICAgICAgLy8gYWRkIGlmIG5vZGUgaXMgdGFiYmFibGUgaXRzZWxmXG4gICAgICAgIHBhcmVudC5wYXJlbnROb2RlXG4gICAgICAgICAgICA/ICgwLCBhcnJheV8xLnRvQXJyYXkpKHBhcmVudC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnlUYWJiYWJsZXMpKS5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUgPT09IHBhcmVudDsgfSlcbiAgICAgICAgICAgIDogW10pO1xuICAgIH0sIFtdKTtcbn07XG5leHBvcnRzLmdldEZvY3VzYWJsZXMgPSBnZXRGb2N1c2FibGVzO1xuLyoqXG4gKiByZXR1cm4gYSBsaXN0IG9mIGZvY3VzYWJsZSBub2RlcyB3aXRoaW4gYW4gYXJlYSBtYXJrZWQgYXMgXCJhdXRvLWZvY3VzYWJsZVwiXG4gKiBAcGFyYW0gcGFyZW50XG4gKi9cbnZhciBnZXRQYXJlbnRBdXRvZm9jdXNhYmxlcyA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICB2YXIgcGFyZW50Rm9jdXMgPSBwYXJlbnQucXVlcnlTZWxlY3RvckFsbChcIltcIi5jb25jYXQoY29uc3RhbnRzXzEuRk9DVVNfQVVUTywgXCJdXCIpKTtcbiAgICByZXR1cm4gKDAsIGFycmF5XzEudG9BcnJheSkocGFyZW50Rm9jdXMpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuICgwLCBleHBvcnRzLmdldEZvY3VzYWJsZXMpKFtub2RlXSk7IH0pXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgbm9kZXMpIHsgcmV0dXJuIGFjYy5jb25jYXQobm9kZXMpOyB9LCBbXSk7XG59O1xuZXhwb3J0cy5nZXRQYXJlbnRBdXRvZm9jdXNhYmxlcyA9IGdldFBhcmVudEF1dG9mb2N1c2FibGVzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRhYmJhYmxlcyA9IHZvaWQgMDtcbi8qKlxuICogbGlzdCBvZiB0aGUgb2JqZWN0IHRvIGJlIGNvbnNpZGVyZWQgYXMgZm9jdXNhYmxlXG4gKi9cbmV4cG9ydHMudGFiYmFibGVzID0gW1xuICAgICdidXR0b246ZW5hYmxlZCcsXG4gICAgJ3NlbGVjdDplbmFibGVkJyxcbiAgICAndGV4dGFyZWE6ZW5hYmxlZCcsXG4gICAgJ2lucHV0OmVuYWJsZWQnLFxuICAgIC8vIGVsZW1lbnRzIHdpdGggZXhwbGljaXQgcm9sZXMgd2lsbCBhbHNvIHVzZSBleHBsaWNpdCB0YWJpbmRleFxuICAgIC8vICdbcm9sZT1cImJ1dHRvblwiXScsXG4gICAgJ2FbaHJlZl0nLFxuICAgICdhcmVhW2hyZWZdJyxcbiAgICAnc3VtbWFyeScsXG4gICAgJ2lmcmFtZScsXG4gICAgJ29iamVjdCcsXG4gICAgJ2VtYmVkJyxcbiAgICAnYXVkaW9bY29udHJvbHNdJyxcbiAgICAndmlkZW9bY29udHJvbHNdJyxcbiAgICAnW3RhYmluZGV4XScsXG4gICAgJ1tjb250ZW50ZWRpdGFibGVdJyxcbiAgICAnW2F1dG9mb2N1c10nLFxuXTtcbiIsIlxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvckVhY2ggKG9iaiwgZm4sIGN0eCkge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKGZuKSAhPT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIGwgPSBvYmoubGVuZ3RoO1xuICAgIGlmIChsID09PSArbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrKSkge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpba10sIGssIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cblxudmFyIEVSUk9SX01FU1NBR0UgPSAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnO1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmdW5jVHlwZSA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZCh0aGF0KSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicgfHwgdG9TdHIuY2FsbCh0YXJnZXQpICE9PSBmdW5jVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUk9SX01FU1NBR0UgKyB0YXJnZXQpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBib3VuZDtcbiAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcbiAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xuICAgIH1cblxuICAgIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBpbXBsZW1lbnRhdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZ1bmN0aW9uc0hhdmVOYW1lcyA9IGZ1bmN0aW9uIGZ1bmN0aW9uc0hhdmVOYW1lcygpIHtcblx0cmV0dXJuIHR5cGVvZiBmdW5jdGlvbiBmKCkge30ubmFtZSA9PT0gJ3N0cmluZyc7XG59O1xuXG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5pZiAoZ09QRCkge1xuXHR0cnkge1xuXHRcdGdPUEQoW10sICdsZW5ndGgnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGdPUERcblx0XHRnT1BEID0gbnVsbDtcblx0fVxufVxuXG5mdW5jdGlvbnNIYXZlTmFtZXMuZnVuY3Rpb25zSGF2ZUNvbmZpZ3VyYWJsZU5hbWVzID0gZnVuY3Rpb24gZnVuY3Rpb25zSGF2ZUNvbmZpZ3VyYWJsZU5hbWVzKCkge1xuXHRpZiAoIWZ1bmN0aW9uc0hhdmVOYW1lcygpIHx8ICFnT1BEKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHZhciBkZXNjID0gZ09QRChmdW5jdGlvbiAoKSB7fSwgJ25hbWUnKTtcblx0cmV0dXJuICEhZGVzYyAmJiAhIWRlc2MuY29uZmlndXJhYmxlO1xufTtcblxudmFyICRiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQ7XG5cbmZ1bmN0aW9uc0hhdmVOYW1lcy5ib3VuZEZ1bmN0aW9uc0hhdmVOYW1lcyA9IGZ1bmN0aW9uIGJvdW5kRnVuY3Rpb25zSGF2ZU5hbWVzKCkge1xuXHRyZXR1cm4gZnVuY3Rpb25zSGF2ZU5hbWVzKCkgJiYgdHlwZW9mICRiaW5kID09PSAnZnVuY3Rpb24nICYmIGZ1bmN0aW9uIGYoKSB7fS5iaW5kKCkubmFtZSAhPT0gJyc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uc0hhdmVOYW1lcztcbiIsIi8qIVxuICogRnVzZS5qcyB2My42LjEgLSBMaWdodHdlaWdodCBmdXp6eS1zZWFyY2ggKGh0dHA6Ly9mdXNlanMuaW8pXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IEtpcm9sbG9zIFJpc2sgKGh0dHA6Ly9raXJvLm1lKVxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC4gQXBhY2hlIFNvZnR3YXJlIExpY2Vuc2UgMi4wXG4gKiBcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG4hZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShcIkZ1c2VcIixbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLkZ1c2U9dCgpOmUuRnVzZT10KCl9KHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9e307ZnVuY3Rpb24gcihuKXtpZih0W25dKXJldHVybiB0W25dLmV4cG9ydHM7dmFyIG89dFtuXT17aTpuLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbbl0uY2FsbChvLmV4cG9ydHMsbyxvLmV4cG9ydHMsciksby5sPSEwLG8uZXhwb3J0c31yZXR1cm4gci5tPWUsci5jPXQsci5kPWZ1bmN0aW9uKGUsdCxuKXtyLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6bn0pfSxyLnI9ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sci50PWZ1bmN0aW9uKGUsdCl7aWYoMSZ0JiYoZT1yKGUpKSw4JnQpcmV0dXJuIGU7aWYoNCZ0JiZcIm9iamVjdFwiPT10eXBlb2YgZSYmZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoci5yKG4pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KSwyJnQmJlwic3RyaW5nXCIhPXR5cGVvZiBlKWZvcih2YXIgbyBpbiBlKXIuZChuLG8sZnVuY3Rpb24odCl7cmV0dXJuIGVbdF19LmJpbmQobnVsbCxvKSk7cmV0dXJuIG59LHIubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gci5kKHQsXCJhXCIsdCksdH0sci5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxyLnA9XCJcIixyKHIucz0wKX0oW2Z1bmN0aW9uKGUsdCxyKXtmdW5jdGlvbiBuKGUpe3JldHVybihuPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX1mdW5jdGlvbiBvKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXRbcl07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4ua2V5LG4pfX12YXIgaT1yKDEpLGE9cig3KSxzPWEuZ2V0LGM9KGEuZGVlcFZhbHVlLGEuaXNBcnJheSksaD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxyKXt2YXIgbj1yLmxvY2F0aW9uLG89dm9pZCAwPT09bj8wOm4saT1yLmRpc3RhbmNlLGE9dm9pZCAwPT09aT8xMDA6aSxjPXIudGhyZXNob2xkLGg9dm9pZCAwPT09Yz8uNjpjLGw9ci5tYXhQYXR0ZXJuTGVuZ3RoLHU9dm9pZCAwPT09bD8zMjpsLGY9ci5jYXNlU2Vuc2l0aXZlLHY9dm9pZCAwIT09ZiYmZixwPXIudG9rZW5TZXBhcmF0b3IsZD12b2lkIDA9PT1wPy8gKy9nOnAsZz1yLmZpbmRBbGxNYXRjaGVzLHk9dm9pZCAwIT09ZyYmZyxtPXIubWluTWF0Y2hDaGFyTGVuZ3RoLGs9dm9pZCAwPT09bT8xOm0sYj1yLmlkLFM9dm9pZCAwPT09Yj9udWxsOmIseD1yLmtleXMsTT12b2lkIDA9PT14P1tdOngsXz1yLnNob3VsZFNvcnQsdz12b2lkIDA9PT1ffHxfLEw9ci5nZXRGbixBPXZvaWQgMD09PUw/czpMLE89ci5zb3J0Rm4sQz12b2lkIDA9PT1PP2Z1bmN0aW9uKGUsdCl7cmV0dXJuIGUuc2NvcmUtdC5zY29yZX06TyxqPXIudG9rZW5pemUsUD12b2lkIDAhPT1qJiZqLEk9ci5tYXRjaEFsbFRva2VucyxGPXZvaWQgMCE9PUkmJkksVD1yLmluY2x1ZGVNYXRjaGVzLE49dm9pZCAwIT09VCYmVCx6PXIuaW5jbHVkZVNjb3JlLEU9dm9pZCAwIT09eiYmeixXPXIudmVyYm9zZSxLPXZvaWQgMCE9PVcmJlc7IWZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxlKSx0aGlzLm9wdGlvbnM9e2xvY2F0aW9uOm8sZGlzdGFuY2U6YSx0aHJlc2hvbGQ6aCxtYXhQYXR0ZXJuTGVuZ3RoOnUsaXNDYXNlU2Vuc2l0aXZlOnYsdG9rZW5TZXBhcmF0b3I6ZCxmaW5kQWxsTWF0Y2hlczp5LG1pbk1hdGNoQ2hhckxlbmd0aDprLGlkOlMsa2V5czpNLGluY2x1ZGVNYXRjaGVzOk4saW5jbHVkZVNjb3JlOkUsc2hvdWxkU29ydDp3LGdldEZuOkEsc29ydEZuOkMsdmVyYm9zZTpLLHRva2VuaXplOlAsbWF0Y2hBbGxUb2tlbnM6Rn0sdGhpcy5zZXRDb2xsZWN0aW9uKHQpLHRoaXMuX3Byb2Nlc3NLZXlzKE0pfXZhciB0LHIsYTtyZXR1cm4gdD1lLChyPVt7a2V5Olwic2V0Q29sbGVjdGlvblwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmxpc3Q9ZSxlfX0se2tleTpcIl9wcm9jZXNzS2V5c1wiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKHRoaXMuX2tleVdlaWdodHM9e30sdGhpcy5fa2V5TmFtZXM9W10sZS5sZW5ndGgmJlwic3RyaW5nXCI9PXR5cGVvZiBlWzBdKWZvcih2YXIgdD0wLHI9ZS5sZW5ndGg7dDxyO3QrPTEpe3ZhciBuPWVbdF07dGhpcy5fa2V5V2VpZ2h0c1tuXT0xLHRoaXMuX2tleU5hbWVzLnB1c2gobil9ZWxzZXtmb3IodmFyIG89bnVsbCxpPW51bGwsYT0wLHM9MCxjPWUubGVuZ3RoO3M8YztzKz0xKXt2YXIgaD1lW3NdO2lmKCFoLmhhc093blByb3BlcnR5KFwibmFtZVwiKSl0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgXCJuYW1lXCIgcHJvcGVydHkgaW4ga2V5IG9iamVjdCcpO3ZhciBsPWgubmFtZTtpZih0aGlzLl9rZXlOYW1lcy5wdXNoKGwpLCFoLmhhc093blByb3BlcnR5KFwid2VpZ2h0XCIpKXRocm93IG5ldyBFcnJvcignTWlzc2luZyBcIndlaWdodFwiIHByb3BlcnR5IGluIGtleSBvYmplY3QnKTt2YXIgdT1oLndlaWdodDtpZih1PDB8fHU+MSl0aHJvdyBuZXcgRXJyb3IoJ1wid2VpZ2h0XCIgcHJvcGVydHkgaW4ga2V5IG11c3QgYmVpbiB0aGUgcmFuZ2Ugb2YgWzAsIDEpJyk7aT1udWxsPT1pP3U6TWF0aC5tYXgoaSx1KSxvPW51bGw9PW8/dTpNYXRoLm1pbihvLHUpLHRoaXMuX2tleVdlaWdodHNbbF09dSxhKz11fWlmKGE+MSl0aHJvdyBuZXcgRXJyb3IoXCJUb3RhbCBvZiB3ZWlnaHRzIGNhbm5vdCBleGNlZWQgMVwiKX19fSx7a2V5Olwic2VhcmNoXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOntsaW1pdDohMX07dGhpcy5fbG9nKCctLS0tLS0tLS1cXG5TZWFyY2ggcGF0dGVybjogXCInLmNvbmNhdChlLCdcIicpKTt2YXIgcj10aGlzLl9wcmVwYXJlU2VhcmNoZXJzKGUpLG49ci50b2tlblNlYXJjaGVycyxvPXIuZnVsbFNlYXJjaGVyLGk9dGhpcy5fc2VhcmNoKG4sbyk7cmV0dXJuIHRoaXMuX2NvbXB1dGVTY29yZShpKSx0aGlzLm9wdGlvbnMuc2hvdWxkU29ydCYmdGhpcy5fc29ydChpKSx0LmxpbWl0JiZcIm51bWJlclwiPT10eXBlb2YgdC5saW1pdCYmKGk9aS5zbGljZSgwLHQubGltaXQpKSx0aGlzLl9mb3JtYXQoaSl9fSx7a2V5OlwiX3ByZXBhcmVTZWFyY2hlcnNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpcIlwiLHQ9W107aWYodGhpcy5vcHRpb25zLnRva2VuaXplKWZvcih2YXIgcj1lLnNwbGl0KHRoaXMub3B0aW9ucy50b2tlblNlcGFyYXRvciksbj0wLG89ci5sZW5ndGg7bjxvO24rPTEpdC5wdXNoKG5ldyBpKHJbbl0sdGhpcy5vcHRpb25zKSk7cmV0dXJue3Rva2VuU2VhcmNoZXJzOnQsZnVsbFNlYXJjaGVyOm5ldyBpKGUsdGhpcy5vcHRpb25zKX19fSx7a2V5OlwiX3NlYXJjaFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOltdLHQ9YXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDAscj10aGlzLmxpc3Qsbj17fSxvPVtdO2lmKFwic3RyaW5nXCI9PXR5cGVvZiByWzBdKXtmb3IodmFyIGk9MCxhPXIubGVuZ3RoO2k8YTtpKz0xKXRoaXMuX2FuYWx5emUoe2tleTpcIlwiLHZhbHVlOnJbaV0scmVjb3JkOmksaW5kZXg6aX0se3Jlc3VsdE1hcDpuLHJlc3VsdHM6byx0b2tlblNlYXJjaGVyczplLGZ1bGxTZWFyY2hlcjp0fSk7cmV0dXJuIG99Zm9yKHZhciBzPTAsYz1yLmxlbmd0aDtzPGM7cys9MSlmb3IodmFyIGg9cltzXSxsPTAsdT10aGlzLl9rZXlOYW1lcy5sZW5ndGg7bDx1O2wrPTEpe3ZhciBmPXRoaXMuX2tleU5hbWVzW2xdO3RoaXMuX2FuYWx5emUoe2tleTpmLHZhbHVlOnRoaXMub3B0aW9ucy5nZXRGbihoLGYpLHJlY29yZDpoLGluZGV4OnN9LHtyZXN1bHRNYXA6bixyZXN1bHRzOm8sdG9rZW5TZWFyY2hlcnM6ZSxmdWxsU2VhcmNoZXI6dH0pfXJldHVybiBvfX0se2tleTpcIl9hbmFseXplXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLG49ZS5rZXksbz1lLmFycmF5SW5kZXgsaT12b2lkIDA9PT1vPy0xOm8sYT1lLnZhbHVlLHM9ZS5yZWNvcmQsaD1lLmluZGV4LGw9dC50b2tlblNlYXJjaGVycyx1PXZvaWQgMD09PWw/W106bCxmPXQuZnVsbFNlYXJjaGVyLHY9dC5yZXN1bHRNYXAscD12b2lkIDA9PT12P3t9OnYsZD10LnJlc3VsdHMsZz12b2lkIDA9PT1kP1tdOmQ7IWZ1bmN0aW9uIGUodCxvLGksYSl7aWYobnVsbCE9bylpZihcInN0cmluZ1wiPT10eXBlb2Ygbyl7dmFyIHM9ITEsaD0tMSxsPTA7ci5fbG9nKFwiXFxuS2V5OiBcIi5jb25jYXQoXCJcIj09PW4/XCItLVwiOm4pKTt2YXIgdj1mLnNlYXJjaChvKTtpZihyLl9sb2coJ0Z1bGwgdGV4dDogXCInLmNvbmNhdChvLCdcIiwgc2NvcmU6ICcpLmNvbmNhdCh2LnNjb3JlKSksci5vcHRpb25zLnRva2VuaXplKXtmb3IodmFyIGQ9by5zcGxpdChyLm9wdGlvbnMudG9rZW5TZXBhcmF0b3IpLHk9ZC5sZW5ndGgsbT1bXSxrPTAsYj11Lmxlbmd0aDtrPGI7ays9MSl7dmFyIFM9dVtrXTtyLl9sb2coJ1xcblBhdHRlcm46IFwiJy5jb25jYXQoUy5wYXR0ZXJuLCdcIicpKTtmb3IodmFyIHg9ITEsTT0wO008eTtNKz0xKXt2YXIgXz1kW01dLHc9Uy5zZWFyY2goXyksTD17fTt3LmlzTWF0Y2g/KExbX109dy5zY29yZSxzPSEwLHg9ITAsbS5wdXNoKHcuc2NvcmUpKTooTFtfXT0xLHIub3B0aW9ucy5tYXRjaEFsbFRva2Vuc3x8bS5wdXNoKDEpKSxyLl9sb2coJ1Rva2VuOiBcIicuY29uY2F0KF8sJ1wiLCBzY29yZTogJykuY29uY2F0KExbX10pKX14JiYobCs9MSl9aD1tWzBdO2Zvcih2YXIgQT1tLmxlbmd0aCxPPTE7TzxBO08rPTEpaCs9bVtPXTtoLz1BLHIuX2xvZyhcIlRva2VuIHNjb3JlIGF2ZXJhZ2U6XCIsaCl9dmFyIEM9di5zY29yZTtoPi0xJiYoQz0oQytoKS8yKSxyLl9sb2coXCJTY29yZSBhdmVyYWdlOlwiLEMpO3ZhciBqPSFyLm9wdGlvbnMudG9rZW5pemV8fCFyLm9wdGlvbnMubWF0Y2hBbGxUb2tlbnN8fGw+PXUubGVuZ3RoO2lmKHIuX2xvZyhcIlxcbkNoZWNrIE1hdGNoZXM6IFwiLmNvbmNhdChqKSksKHN8fHYuaXNNYXRjaCkmJmope3ZhciBQPXtrZXk6bixhcnJheUluZGV4OnQsdmFsdWU6byxzY29yZTpDfTtyLm9wdGlvbnMuaW5jbHVkZU1hdGNoZXMmJihQLm1hdGNoZWRJbmRpY2VzPXYubWF0Y2hlZEluZGljZXMpO3ZhciBJPXBbYV07ST9JLm91dHB1dC5wdXNoKFApOihwW2FdPXtpdGVtOmksb3V0cHV0OltQXX0sZy5wdXNoKHBbYV0pKX19ZWxzZSBpZihjKG8pKWZvcih2YXIgRj0wLFQ9by5sZW5ndGg7RjxUO0YrPTEpZShGLG9bRl0saSxhKX0oaSxhLHMsaCl9fSx7a2V5OlwiX2NvbXB1dGVTY29yZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuX2xvZyhcIlxcblxcbkNvbXB1dGluZyBzY29yZTpcXG5cIik7Zm9yKHZhciB0PXRoaXMuX2tleVdlaWdodHMscj0hIU9iamVjdC5rZXlzKHQpLmxlbmd0aCxuPTAsbz1lLmxlbmd0aDtuPG87bis9MSl7Zm9yKHZhciBpPWVbbl0sYT1pLm91dHB1dCxzPWEubGVuZ3RoLGM9MSxoPTA7aDxzO2grPTEpe3ZhciBsPWFbaF0sdT1sLmtleSxmPXI/dFt1XToxLHY9MD09PWwuc2NvcmUmJnQmJnRbdV0+MD9OdW1iZXIuRVBTSUxPTjpsLnNjb3JlO2MqPU1hdGgucG93KHYsZil9aS5zY29yZT1jLHRoaXMuX2xvZyhpKX19fSx7a2V5OlwiX3NvcnRcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLl9sb2coXCJcXG5cXG5Tb3J0aW5nLi4uLlwiKSxlLnNvcnQodGhpcy5vcHRpb25zLnNvcnRGbil9fSx7a2V5OlwiX2Zvcm1hdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PVtdO2lmKHRoaXMub3B0aW9ucy52ZXJib3NlKXt2YXIgcj1bXTt0aGlzLl9sb2coXCJcXG5cXG5PdXRwdXQ6XFxuXFxuXCIsSlNPTi5zdHJpbmdpZnkoZSxmdW5jdGlvbihlLHQpe2lmKFwib2JqZWN0XCI9PT1uKHQpJiZudWxsIT09dCl7aWYoLTEhPT1yLmluZGV4T2YodCkpcmV0dXJuO3IucHVzaCh0KX1yZXR1cm4gdH0sMikpLHI9bnVsbH12YXIgbz1bXTt0aGlzLm9wdGlvbnMuaW5jbHVkZU1hdGNoZXMmJm8ucHVzaChmdW5jdGlvbihlLHQpe3ZhciByPWUub3V0cHV0O3QubWF0Y2hlcz1bXTtmb3IodmFyIG49MCxvPXIubGVuZ3RoO248bztuKz0xKXt2YXIgaT1yW25dO2lmKDAhPT1pLm1hdGNoZWRJbmRpY2VzLmxlbmd0aCl7dmFyIGE9e2luZGljZXM6aS5tYXRjaGVkSW5kaWNlcyx2YWx1ZTppLnZhbHVlfTtpLmtleSYmKGEua2V5PWkua2V5KSxpLmhhc093blByb3BlcnR5KFwiYXJyYXlJbmRleFwiKSYmaS5hcnJheUluZGV4Pi0xJiYoYS5hcnJheUluZGV4PWkuYXJyYXlJbmRleCksdC5tYXRjaGVzLnB1c2goYSl9fX0pLHRoaXMub3B0aW9ucy5pbmNsdWRlU2NvcmUmJm8ucHVzaChmdW5jdGlvbihlLHQpe3Quc2NvcmU9ZS5zY29yZX0pO2Zvcih2YXIgaT0wLGE9ZS5sZW5ndGg7aTxhO2krPTEpe3ZhciBzPWVbaV07aWYodGhpcy5vcHRpb25zLmlkJiYocy5pdGVtPXRoaXMub3B0aW9ucy5nZXRGbihzLml0ZW0sdGhpcy5vcHRpb25zLmlkKVswXSksby5sZW5ndGgpe2Zvcih2YXIgYz17aXRlbTpzLml0ZW19LGg9MCxsPW8ubGVuZ3RoO2g8bDtoKz0xKW9baF0ocyxjKTt0LnB1c2goYyl9ZWxzZSB0LnB1c2gocy5pdGVtKX1yZXR1cm4gdH19LHtrZXk6XCJfbG9nXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZTt0aGlzLm9wdGlvbnMudmVyYm9zZSYmKGU9Y29uc29sZSkubG9nLmFwcGx5KGUsYXJndW1lbnRzKX19XSkmJm8odC5wcm90b3R5cGUsciksYSYmbyh0LGEpLGV9KCk7ZS5leHBvcnRzPWh9LGZ1bmN0aW9uKGUsdCxyKXtmdW5jdGlvbiBuKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXRbcl07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4ua2V5LG4pfX12YXIgbz1yKDIpLGk9cigzKSxhPXIoNikscz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxyKXt2YXIgbj1yLmxvY2F0aW9uLG89dm9pZCAwPT09bj8wOm4saT1yLmRpc3RhbmNlLHM9dm9pZCAwPT09aT8xMDA6aSxjPXIudGhyZXNob2xkLGg9dm9pZCAwPT09Yz8uNjpjLGw9ci5tYXhQYXR0ZXJuTGVuZ3RoLHU9dm9pZCAwPT09bD8zMjpsLGY9ci5pc0Nhc2VTZW5zaXRpdmUsdj12b2lkIDAhPT1mJiZmLHA9ci50b2tlblNlcGFyYXRvcixkPXZvaWQgMD09PXA/LyArL2c6cCxnPXIuZmluZEFsbE1hdGNoZXMseT12b2lkIDAhPT1nJiZnLG09ci5taW5NYXRjaENoYXJMZW5ndGgsaz12b2lkIDA9PT1tPzE6bSxiPXIuaW5jbHVkZU1hdGNoZXMsUz12b2lkIDAhPT1iJiZiOyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZSksdGhpcy5vcHRpb25zPXtsb2NhdGlvbjpvLGRpc3RhbmNlOnMsdGhyZXNob2xkOmgsbWF4UGF0dGVybkxlbmd0aDp1LGlzQ2FzZVNlbnNpdGl2ZTp2LHRva2VuU2VwYXJhdG9yOmQsZmluZEFsbE1hdGNoZXM6eSxpbmNsdWRlTWF0Y2hlczpTLG1pbk1hdGNoQ2hhckxlbmd0aDprfSx0aGlzLnBhdHRlcm49dj90OnQudG9Mb3dlckNhc2UoKSx0aGlzLnBhdHRlcm4ubGVuZ3RoPD11JiYodGhpcy5wYXR0ZXJuQWxwaGFiZXQ9YSh0aGlzLnBhdHRlcm4pKX12YXIgdCxyLHM7cmV0dXJuIHQ9ZSwocj1be2tleTpcInNlYXJjaFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMub3B0aW9ucyxyPXQuaXNDYXNlU2Vuc2l0aXZlLG49dC5pbmNsdWRlTWF0Y2hlcztpZihyfHwoZT1lLnRvTG93ZXJDYXNlKCkpLHRoaXMucGF0dGVybj09PWUpe3ZhciBhPXtpc01hdGNoOiEwLHNjb3JlOjB9O3JldHVybiBuJiYoYS5tYXRjaGVkSW5kaWNlcz1bWzAsZS5sZW5ndGgtMV1dKSxhfXZhciBzPXRoaXMub3B0aW9ucyxjPXMubWF4UGF0dGVybkxlbmd0aCxoPXMudG9rZW5TZXBhcmF0b3I7aWYodGhpcy5wYXR0ZXJuLmxlbmd0aD5jKXJldHVybiBvKGUsdGhpcy5wYXR0ZXJuLGgpO3ZhciBsPXRoaXMub3B0aW9ucyx1PWwubG9jYXRpb24sZj1sLmRpc3RhbmNlLHY9bC50aHJlc2hvbGQscD1sLmZpbmRBbGxNYXRjaGVzLGQ9bC5taW5NYXRjaENoYXJMZW5ndGg7cmV0dXJuIGkoZSx0aGlzLnBhdHRlcm4sdGhpcy5wYXR0ZXJuQWxwaGFiZXQse2xvY2F0aW9uOnUsZGlzdGFuY2U6Zix0aHJlc2hvbGQ6dixmaW5kQWxsTWF0Y2hlczpwLG1pbk1hdGNoQ2hhckxlbmd0aDpkLGluY2x1ZGVNYXRjaGVzOm59KX19XSkmJm4odC5wcm90b3R5cGUscikscyYmbih0LHMpLGV9KCk7ZS5leHBvcnRzPXN9LGZ1bmN0aW9uKGUsdCl7dmFyIHI9L1tcXC1cXFtcXF1cXC9cXHtcXH1cXChcXClcXCpcXCtcXD9cXC5cXFxcXFxeXFwkXFx8XS9nO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTovICsvZyxvPW5ldyBSZWdFeHAodC5yZXBsYWNlKHIsXCJcXFxcJCZcIikucmVwbGFjZShuLFwifFwiKSksaT1lLm1hdGNoKG8pLGE9ISFpLHM9W107aWYoYSlmb3IodmFyIGM9MCxoPWkubGVuZ3RoO2M8aDtjKz0xKXt2YXIgbD1pW2NdO3MucHVzaChbZS5pbmRleE9mKGwpLGwubGVuZ3RoLTFdKX1yZXR1cm57c2NvcmU6YT8uNToxLGlzTWF0Y2g6YSxtYXRjaGVkSW5kaWNlczpzfX19LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDQpLG89cig1KTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0LHIsaSl7Zm9yKHZhciBhPWkubG9jYXRpb24scz12b2lkIDA9PT1hPzA6YSxjPWkuZGlzdGFuY2UsaD12b2lkIDA9PT1jPzEwMDpjLGw9aS50aHJlc2hvbGQsdT12b2lkIDA9PT1sPy42OmwsZj1pLmZpbmRBbGxNYXRjaGVzLHY9dm9pZCAwIT09ZiYmZixwPWkubWluTWF0Y2hDaGFyTGVuZ3RoLGQ9dm9pZCAwPT09cD8xOnAsZz1pLmluY2x1ZGVNYXRjaGVzLHk9dm9pZCAwIT09ZyYmZyxtPXMsaz1lLmxlbmd0aCxiPXUsUz1lLmluZGV4T2YodCxtKSx4PXQubGVuZ3RoLE09W10sXz0wO188aztfKz0xKU1bX109MDtpZigtMSE9PVMpe3ZhciB3PW4odCx7ZXJyb3JzOjAsY3VycmVudExvY2F0aW9uOlMsZXhwZWN0ZWRMb2NhdGlvbjptLGRpc3RhbmNlOmh9KTtpZihiPU1hdGgubWluKHcsYiksLTEhPT0oUz1lLmxhc3RJbmRleE9mKHQsbSt4KSkpe3ZhciBMPW4odCx7ZXJyb3JzOjAsY3VycmVudExvY2F0aW9uOlMsZXhwZWN0ZWRMb2NhdGlvbjptLGRpc3RhbmNlOmh9KTtiPU1hdGgubWluKEwsYil9fVM9LTE7Zm9yKHZhciBBPVtdLE89MSxDPXgrayxqPTE8PCh4PD0zMT94LTE6MzApLFA9MDtQPHg7UCs9MSl7Zm9yKHZhciBJPTAsRj1DO0k8Rjspe24odCx7ZXJyb3JzOlAsY3VycmVudExvY2F0aW9uOm0rRixleHBlY3RlZExvY2F0aW9uOm0sZGlzdGFuY2U6aH0pPD1iP0k9RjpDPUYsRj1NYXRoLmZsb29yKChDLUkpLzIrSSl9Qz1GO3ZhciBUPU1hdGgubWF4KDEsbS1GKzEpLE49dj9rOk1hdGgubWluKG0rRixrKSt4LHo9QXJyYXkoTisyKTt6W04rMV09KDE8PFApLTE7Zm9yKHZhciBFPU47RT49VDtFLT0xKXt2YXIgVz1FLTEsSz1yW2UuY2hhckF0KFcpXTtpZihLJiYoTVtXXT0xKSx6W0VdPSh6W0UrMV08PDF8MSkmSywwIT09UCYmKHpbRV18PShBW0UrMV18QVtFXSk8PDF8MXxBW0UrMV0pLHpbRV0maiYmKE89bih0LHtlcnJvcnM6UCxjdXJyZW50TG9jYXRpb246VyxleHBlY3RlZExvY2F0aW9uOm0sZGlzdGFuY2U6aH0pKTw9Yil7aWYoYj1PLChTPVcpPD1tKWJyZWFrO1Q9TWF0aC5tYXgoMSwyKm0tUyl9fWlmKG4odCx7ZXJyb3JzOlArMSxjdXJyZW50TG9jYXRpb246bSxleHBlY3RlZExvY2F0aW9uOm0sZGlzdGFuY2U6aH0pPmIpYnJlYWs7QT16fXZhciAkPXtpc01hdGNoOlM+PTAsc2NvcmU6MD09PU8/LjAwMTpPfTtyZXR1cm4geSYmKCQubWF0Y2hlZEluZGljZXM9byhNLGQpKSwkfX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXt2YXIgcj10LmVycm9ycyxuPXZvaWQgMD09PXI/MDpyLG89dC5jdXJyZW50TG9jYXRpb24saT12b2lkIDA9PT1vPzA6byxhPXQuZXhwZWN0ZWRMb2NhdGlvbixzPXZvaWQgMD09PWE/MDphLGM9dC5kaXN0YW5jZSxoPXZvaWQgMD09PWM/MTAwOmMsbD1uL2UubGVuZ3RoLHU9TWF0aC5hYnMocy1pKTtyZXR1cm4gaD9sK3UvaDp1PzE6bH19LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpbXSx0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXToxLHI9W10sbj0tMSxvPS0xLGk9MCxhPWUubGVuZ3RoO2k8YTtpKz0xKXt2YXIgcz1lW2ldO3MmJi0xPT09bj9uPWk6c3x8LTE9PT1ufHwoKG89aS0xKS1uKzE+PXQmJnIucHVzaChbbixvXSksbj0tMSl9cmV0dXJuIGVbaS0xXSYmaS1uPj10JiZyLnB1c2goW24saS0xXSkscn19LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD17fSxyPWUubGVuZ3RoLG49MDtuPHI7bis9MSl0W2UuY2hhckF0KG4pXT0wO2Zvcih2YXIgbz0wO288cjtvKz0xKXRbZS5jaGFyQXQobyldfD0xPDxyLW8tMTtyZXR1cm4gdH19LGZ1bmN0aW9uKGUsdCl7dmFyIHI9ZnVuY3Rpb24oZSl7cmV0dXJuIEFycmF5LmlzQXJyYXk/QXJyYXkuaXNBcnJheShlKTpcIltvYmplY3QgQXJyYXldXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSl9LG49ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWU/XCJcIjpmdW5jdGlvbihlKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSlyZXR1cm4gZTt2YXIgdD1lK1wiXCI7cmV0dXJuXCIwXCI9PXQmJjEvZT09LTEvMD9cIi0wXCI6dH0oZSl9LG89ZnVuY3Rpb24oZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGV9LGk9ZnVuY3Rpb24oZSl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIGV9O2UuZXhwb3J0cz17Z2V0OmZ1bmN0aW9uKGUsdCl7dmFyIGE9W107cmV0dXJuIGZ1bmN0aW9uIGUodCxzKXtpZihzKXt2YXIgYz1zLmluZGV4T2YoXCIuXCIpLGg9cyxsPW51bGw7LTEhPT1jJiYoaD1zLnNsaWNlKDAsYyksbD1zLnNsaWNlKGMrMSkpO3ZhciB1PXRbaF07aWYobnVsbCE9dSlpZihsfHwhbyh1KSYmIWkodSkpaWYocih1KSlmb3IodmFyIGY9MCx2PXUubGVuZ3RoO2Y8djtmKz0xKWUodVtmXSxsKTtlbHNlIGwmJmUodSxsKTtlbHNlIGEucHVzaChuKHUpKX1lbHNlIGEucHVzaCh0KX0oZSx0KSxhfSxpc0FycmF5OnIsaXNTdHJpbmc6byxpc051bTppLHRvU3RyaW5nOm59fV0pfSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdW5kZWZpbmVkO1xuXG52YXIgJFN5bnRheEVycm9yID0gU3ludGF4RXJyb3I7XG52YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG52YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKGV4cHJlc3Npb25TeW50YXgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gJEZ1bmN0aW9uKCdcInVzZSBzdHJpY3RcIjsgcmV0dXJuICgnICsgZXhwcmVzc2lvblN5bnRheCArICcpLmNvbnN0cnVjdG9yOycpKCk7XG5cdH0gY2F0Y2ggKGUpIHt9XG59O1xuXG52YXIgJGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoe30sICcnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdCRnT1BEID0gbnVsbDsgLy8gdGhpcyBpcyBJRSA4LCB3aGljaCBoYXMgYSBicm9rZW4gZ09QRFxuXHR9XG59XG5cbnZhciB0aHJvd1R5cGVFcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoKTtcbn07XG52YXIgVGhyb3dUeXBlRXJyb3IgPSAkZ09QRFxuXHQ/IChmdW5jdGlvbiAoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnMsIG5vLWNhbGxlciwgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG5cdFx0XHRhcmd1bWVudHMuY2FsbGVlOyAvLyBJRSA4IGRvZXMgbm90IHRocm93IGhlcmVcblx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHR9IGNhdGNoIChjYWxsZWVUaHJvd3MpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIElFIDggdGhyb3dzIG9uIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXJndW1lbnRzLCAnJylcblx0XHRcdFx0cmV0dXJuICRnT1BEKGFyZ3VtZW50cywgJ2NhbGxlZScpLmdldDtcblx0XHRcdH0gY2F0Y2ggKGdPUER0aHJvd3MpIHtcblx0XHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fSgpKVxuXHQ6IHRocm93VHlwZUVycm9yO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcbnZhciBoYXNQcm90byA9IHJlcXVpcmUoJ2hhcy1wcm90bycpKCk7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCAoXG5cdGhhc1Byb3RvXG5cdFx0PyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5fX3Byb3RvX187IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXHRcdDogbnVsbFxuKTtcblxudmFyIG5lZWRzRXZhbCA9IHt9O1xuXG52YXIgVHlwZWRBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhVaW50OEFycmF5KTtcblxudmFyIElOVFJJTlNJQ1MgPSB7XG5cdCclQWdncmVnYXRlRXJyb3IlJzogdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFnZ3JlZ2F0ZUVycm9yLFxuXHQnJUFycmF5JSc6IEFycmF5LFxuXHQnJUFycmF5QnVmZmVyJSc6IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBcnJheUJ1ZmZlcixcblx0JyVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogbmVlZHNFdmFsLFxuXHQnJUF0b21pY3MlJzogdHlwZW9mIEF0b21pY3MgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXRvbWljcyxcblx0JyVCaWdJbnQlJzogdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQsXG5cdCclQmlnSW50NjRBcnJheSUnOiB0eXBlb2YgQmlnSW50NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQ2NEFycmF5LFxuXHQnJUJpZ1VpbnQ2NEFycmF5JSc6IHR5cGVvZiBCaWdVaW50NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdVaW50NjRBcnJheSxcblx0JyVCb29sZWFuJSc6IEJvb2xlYW4sXG5cdCclRGF0YVZpZXclJzogdHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IERhdGFWaWV3LFxuXHQnJURhdGUlJzogRGF0ZSxcblx0JyVkZWNvZGVVUkklJzogZGVjb2RlVVJJLFxuXHQnJWRlY29kZVVSSUNvbXBvbmVudCUnOiBkZWNvZGVVUklDb21wb25lbnQsXG5cdCclZW5jb2RlVVJJJSc6IGVuY29kZVVSSSxcblx0JyVlbmNvZGVVUklDb21wb25lbnQlJzogZW5jb2RlVVJJQ29tcG9uZW50LFxuXHQnJUVycm9yJSc6IEVycm9yLFxuXHQnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG5cdCclRXZhbEVycm9yJSc6IEV2YWxFcnJvcixcblx0JyVGbG9hdDMyQXJyYXklJzogdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDMyQXJyYXksXG5cdCclRmxvYXQ2NEFycmF5JSc6IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQ2NEFycmF5LFxuXHQnJUZpbmFsaXphdGlvblJlZ2lzdHJ5JSc6IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGaW5hbGl6YXRpb25SZWdpc3RyeSxcblx0JyVGdW5jdGlvbiUnOiAkRnVuY3Rpb24sXG5cdCclR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUludDhBcnJheSUnOiB0eXBlb2YgSW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDhBcnJheSxcblx0JyVJbnQxNkFycmF5JSc6IHR5cGVvZiBJbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDE2QXJyYXksXG5cdCclSW50MzJBcnJheSUnOiB0eXBlb2YgSW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQzMkFycmF5LFxuXHQnJWlzRmluaXRlJSc6IGlzRmluaXRlLFxuXHQnJWlzTmFOJSc6IGlzTmFOLFxuXHQnJUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90byhnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKSA6IHVuZGVmaW5lZCxcblx0JyVKU09OJSc6IHR5cGVvZiBKU09OID09PSAnb2JqZWN0JyA/IEpTT04gOiB1bmRlZmluZWQsXG5cdCclTWFwJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTWFwLFxuXHQnJU1hcEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBNYXAoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJU1hdGglJzogTWF0aCxcblx0JyVOdW1iZXIlJzogTnVtYmVyLFxuXHQnJU9iamVjdCUnOiBPYmplY3QsXG5cdCclcGFyc2VGbG9hdCUnOiBwYXJzZUZsb2F0LFxuXHQnJXBhcnNlSW50JSc6IHBhcnNlSW50LFxuXHQnJVByb21pc2UlJzogdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJvbWlzZSxcblx0JyVQcm94eSUnOiB0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJveHksXG5cdCclUmFuZ2VFcnJvciUnOiBSYW5nZUVycm9yLFxuXHQnJVJlZmVyZW5jZUVycm9yJSc6IFJlZmVyZW5jZUVycm9yLFxuXHQnJVJlZmxlY3QlJzogdHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUmVmbGVjdCxcblx0JyVSZWdFeHAlJzogUmVnRXhwLFxuXHQnJVNldCUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNldCxcblx0JyVTZXRJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgU2V0KClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlciUnOiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2hhcmVkQXJyYXlCdWZmZXIsXG5cdCclU3RyaW5nJSc6IFN0cmluZyxcblx0JyVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzICYmIGdldFByb3RvID8gZ2V0UHJvdG8oJydbU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVTeW1ib2wlJzogaGFzU3ltYm9scyA/IFN5bWJvbCA6IHVuZGVmaW5lZCxcblx0JyVTeW50YXhFcnJvciUnOiAkU3ludGF4RXJyb3IsXG5cdCclVGhyb3dUeXBlRXJyb3IlJzogVGhyb3dUeXBlRXJyb3IsXG5cdCclVHlwZWRBcnJheSUnOiBUeXBlZEFycmF5LFxuXHQnJVR5cGVFcnJvciUnOiAkVHlwZUVycm9yLFxuXHQnJVVpbnQ4QXJyYXklJzogdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhBcnJheSxcblx0JyVVaW50OENsYW1wZWRBcnJheSUnOiB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhDbGFtcGVkQXJyYXksXG5cdCclVWludDE2QXJyYXklJzogdHlwZW9mIFVpbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQxNkFycmF5LFxuXHQnJVVpbnQzMkFycmF5JSc6IHR5cGVvZiBVaW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MzJBcnJheSxcblx0JyVVUklFcnJvciUnOiBVUklFcnJvcixcblx0JyVXZWFrTWFwJSc6IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtNYXAsXG5cdCclV2Vha1JlZiUnOiB0eXBlb2YgV2Vha1JlZiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrUmVmLFxuXHQnJVdlYWtTZXQlJzogdHlwZW9mIFdlYWtTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1NldFxufTtcblxuaWYgKGdldFByb3RvKSB7XG5cdHRyeSB7XG5cdFx0bnVsbC5lcnJvcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXNoYWRvd3JlYWxtL3B1bGwvMzg0I2lzc3VlY29tbWVudC0xMzY0MjY0MjI5XG5cdFx0dmFyIGVycm9yUHJvdG8gPSBnZXRQcm90byhnZXRQcm90byhlKSk7XG5cdFx0SU5UUklOU0lDU1snJUVycm9yLnByb3RvdHlwZSUnXSA9IGVycm9yUHJvdG87XG5cdH1cbn1cblxudmFyIGRvRXZhbCA9IGZ1bmN0aW9uIGRvRXZhbChuYW1lKSB7XG5cdHZhciB2YWx1ZTtcblx0aWYgKG5hbWUgPT09ICclQXN5bmNGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2Z1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3IlJykge1xuXHRcdHZhciBmbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJyk7XG5cdFx0aWYgKGZuKSB7XG5cdFx0XHR2YWx1ZSA9IGZuLnByb3RvdHlwZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJScpIHtcblx0XHR2YXIgZ2VuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3IlJyk7XG5cdFx0aWYgKGdlbiAmJiBnZXRQcm90bykge1xuXHRcdFx0dmFsdWUgPSBnZXRQcm90byhnZW4ucHJvdG90eXBlKTtcblx0XHR9XG5cdH1cblxuXHRJTlRSSU5TSUNTW25hbWVdID0gdmFsdWU7XG5cblx0cmV0dXJuIHZhbHVlO1xufTtcblxudmFyIExFR0FDWV9BTElBU0VTID0ge1xuXHQnJUFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b3R5cGUlJzogWydBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvX2VudHJpZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZW50cmllcyddLFxuXHQnJUFycmF5UHJvdG9fZm9yRWFjaCUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdmb3JFYWNoJ10sXG5cdCclQXJyYXlQcm90b19rZXlzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2tleXMnXSxcblx0JyVBcnJheVByb3RvX3ZhbHVlcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICd2YWx1ZXMnXSxcblx0JyVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJSc6IFsnQXN5bmNGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVCb29sZWFuUHJvdG90eXBlJSc6IFsnQm9vbGVhbicsICdwcm90b3R5cGUnXSxcblx0JyVEYXRhVmlld1Byb3RvdHlwZSUnOiBbJ0RhdGFWaWV3JywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGVQcm90b3R5cGUlJzogWydEYXRlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUVycm9yUHJvdG90eXBlJSc6IFsnRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRXZhbEVycm9yUHJvdG90eXBlJSc6IFsnRXZhbEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0MzJBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDY0QXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDY0QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRnVuY3Rpb25Qcm90b3R5cGUlJzogWydGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3IlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3JQcm90b3R5cGUlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclSW50OEFycmF5UHJvdG90eXBlJSc6IFsnSW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDE2QXJyYXlQcm90b3R5cGUlJzogWydJbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDMyQXJyYXlQcm90b3R5cGUlJzogWydJbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUpTT05QYXJzZSUnOiBbJ0pTT04nLCAncGFyc2UnXSxcblx0JyVKU09OU3RyaW5naWZ5JSc6IFsnSlNPTicsICdzdHJpbmdpZnknXSxcblx0JyVNYXBQcm90b3R5cGUlJzogWydNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclTnVtYmVyUHJvdG90eXBlJSc6IFsnTnVtYmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJU9iamVjdFByb3RvdHlwZSUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnXSxcblx0JyVPYmpQcm90b190b1N0cmluZyUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndG9TdHJpbmcnXSxcblx0JyVPYmpQcm90b192YWx1ZU9mJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd2YWx1ZU9mJ10sXG5cdCclUHJvbWlzZVByb3RvdHlwZSUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJ10sXG5cdCclUHJvbWlzZVByb3RvX3RoZW4lJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZScsICd0aGVuJ10sXG5cdCclUHJvbWlzZV9hbGwlJzogWydQcm9taXNlJywgJ2FsbCddLFxuXHQnJVByb21pc2VfcmVqZWN0JSc6IFsnUHJvbWlzZScsICdyZWplY3QnXSxcblx0JyVQcm9taXNlX3Jlc29sdmUlJzogWydQcm9taXNlJywgJ3Jlc29sdmUnXSxcblx0JyVSYW5nZUVycm9yUHJvdG90eXBlJSc6IFsnUmFuZ2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSUnOiBbJ1JlZmVyZW5jZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZ0V4cFByb3RvdHlwZSUnOiBbJ1JlZ0V4cCcsICdwcm90b3R5cGUnXSxcblx0JyVTZXRQcm90b3R5cGUlJzogWydTZXQnLCAncHJvdG90eXBlJ10sXG5cdCclU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydTaGFyZWRBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVTdHJpbmdQcm90b3R5cGUlJzogWydTdHJpbmcnLCAncHJvdG90eXBlJ10sXG5cdCclU3ltYm9sUHJvdG90eXBlJSc6IFsnU3ltYm9sJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFsnU3ludGF4RXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZWRBcnJheVByb3RvdHlwZSUnOiBbJ1R5cGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZUVycm9yUHJvdG90eXBlJSc6IFsnVHlwZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4QXJyYXlQcm90b3R5cGUlJzogWydVaW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhDbGFtcGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDE2QXJyYXlQcm90b3R5cGUlJzogWydVaW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVSSUVycm9yUHJvdG90eXBlJSc6IFsnVVJJRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha01hcFByb3RvdHlwZSUnOiBbJ1dlYWtNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha1NldFByb3RvdHlwZSUnOiBbJ1dlYWtTZXQnLCAncHJvdG90eXBlJ11cbn07XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJ2hhcycpO1xudmFyICRjb25jYXQgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLmNvbmNhdCk7XG52YXIgJHNwbGljZUFwcGx5ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmFwcGx5LCBBcnJheS5wcm90b3R5cGUuc3BsaWNlKTtcbnZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyICRzdHJTbGljZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnNsaWNlKTtcbnZhciAkZXhlYyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBSZWdFeHAucHJvdG90eXBlLmV4ZWMpO1xuXG4vKiBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi80LjE3LjE1L2Rpc3QvbG9kYXNoLmpzI0w2NzM1LUw2NzQ0ICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nOyAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBmdW5jdGlvbiBzdHJpbmdUb1BhdGgoc3RyaW5nKSB7XG5cdHZhciBmaXJzdCA9ICRzdHJTbGljZShzdHJpbmcsIDAsIDEpO1xuXHR2YXIgbGFzdCA9ICRzdHJTbGljZShzdHJpbmcsIC0xKTtcblx0aWYgKGZpcnN0ID09PSAnJScgJiYgbGFzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYCcpO1xuXHR9IGVsc2UgaWYgKGxhc3QgPT09ICclJyAmJiBmaXJzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBvcGVuaW5nIGAlYCcpO1xuXHR9XG5cdHZhciByZXN1bHQgPSBbXTtcblx0JHJlcGxhY2Uoc3RyaW5nLCByZVByb3BOYW1lLCBmdW5jdGlvbiAobWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuXHRcdHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHF1b3RlID8gJHJlcGxhY2Uoc3ViU3RyaW5nLCByZUVzY2FwZUNoYXIsICckMScpIDogbnVtYmVyIHx8IG1hdGNoO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4vKiBlbmQgYWRhcHRhdGlvbiAqL1xuXG52YXIgZ2V0QmFzZUludHJpbnNpYyA9IGZ1bmN0aW9uIGdldEJhc2VJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWNOYW1lID0gbmFtZTtcblx0dmFyIGFsaWFzO1xuXHRpZiAoaGFzT3duKExFR0FDWV9BTElBU0VTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdGFsaWFzID0gTEVHQUNZX0FMSUFTRVNbaW50cmluc2ljTmFtZV07XG5cdFx0aW50cmluc2ljTmFtZSA9ICclJyArIGFsaWFzWzBdICsgJyUnO1xuXHR9XG5cblx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdHZhciB2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljTmFtZV07XG5cdFx0aWYgKHZhbHVlID09PSBuZWVkc0V2YWwpIHtcblx0XHRcdHZhbHVlID0gZG9FdmFsKGludHJpbnNpY05hbWUpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJiAhYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSEnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWxpYXM6IGFsaWFzLFxuXHRcdFx0bmFtZTogaW50cmluc2ljTmFtZSxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH07XG5cdH1cblxuXHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGRvZXMgbm90IGV4aXN0IScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBHZXRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGFsbG93TWlzc2luZyAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXG5cdGlmICgkZXhlYygvXiU/W14lXSolPyQvLCBuYW1lKSA9PT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2AlYCBtYXkgbm90IGJlIHByZXNlbnQgYW55d2hlcmUgYnV0IGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW50cmluc2ljIG5hbWUnKTtcblx0fVxuXHR2YXIgcGFydHMgPSBzdHJpbmdUb1BhdGgobmFtZSk7XG5cdHZhciBpbnRyaW5zaWNCYXNlTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6ICcnO1xuXG5cdHZhciBpbnRyaW5zaWMgPSBnZXRCYXNlSW50cmluc2ljKCclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnLCBhbGxvd01pc3NpbmcpO1xuXHR2YXIgaW50cmluc2ljUmVhbE5hbWUgPSBpbnRyaW5zaWMubmFtZTtcblx0dmFyIHZhbHVlID0gaW50cmluc2ljLnZhbHVlO1xuXHR2YXIgc2tpcEZ1cnRoZXJDYWNoaW5nID0gZmFsc2U7XG5cblx0dmFyIGFsaWFzID0gaW50cmluc2ljLmFsaWFzO1xuXHRpZiAoYWxpYXMpIHtcblx0XHRpbnRyaW5zaWNCYXNlTmFtZSA9IGFsaWFzWzBdO1xuXHRcdCRzcGxpY2VBcHBseShwYXJ0cywgJGNvbmNhdChbMCwgMV0sIGFsaWFzKSk7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMSwgaXNPd24gPSB0cnVlOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzW2ldO1xuXHRcdHZhciBmaXJzdCA9ICRzdHJTbGljZShwYXJ0LCAwLCAxKTtcblx0XHR2YXIgbGFzdCA9ICRzdHJTbGljZShwYXJ0LCAtMSk7XG5cdFx0aWYgKFxuXHRcdFx0KFxuXHRcdFx0XHQoZmlyc3QgPT09ICdcIicgfHwgZmlyc3QgPT09IFwiJ1wiIHx8IGZpcnN0ID09PSAnYCcpXG5cdFx0XHRcdHx8IChsYXN0ID09PSAnXCInIHx8IGxhc3QgPT09IFwiJ1wiIHx8IGxhc3QgPT09ICdgJylcblx0XHRcdClcblx0XHRcdCYmIGZpcnN0ICE9PSBsYXN0XG5cdFx0KSB7XG5cdFx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzJyk7XG5cdFx0fVxuXHRcdGlmIChwYXJ0ID09PSAnY29uc3RydWN0b3InIHx8ICFpc093bikge1xuXHRcdFx0c2tpcEZ1cnRoZXJDYWNoaW5nID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpbnRyaW5zaWNCYXNlTmFtZSArPSAnLicgKyBwYXJ0O1xuXHRcdGludHJpbnNpY1JlYWxOYW1lID0gJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJSc7XG5cblx0XHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY1JlYWxOYW1lKSkge1xuXHRcdFx0dmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdGlmICghKHBhcnQgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdGlmICghYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Jhc2UgaW50cmluc2ljIGZvciAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZvaWQgdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCRnT1BEICYmIChpICsgMSkgPj0gcGFydHMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBkZXNjID0gJGdPUEQodmFsdWUsIHBhcnQpO1xuXHRcdFx0XHRpc093biA9ICEhZGVzYztcblxuXHRcdFx0XHQvLyBCeSBjb252ZW50aW9uLCB3aGVuIGEgZGF0YSBwcm9wZXJ0eSBpcyBjb252ZXJ0ZWQgdG8gYW4gYWNjZXNzb3Jcblx0XHRcdFx0Ly8gcHJvcGVydHkgdG8gZW11bGF0ZSBhIGRhdGEgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBzdWZmZXIgZnJvbVxuXHRcdFx0XHQvLyB0aGUgb3ZlcnJpZGUgbWlzdGFrZSwgdGhhdCBhY2Nlc3NvcidzIGdldHRlciBpcyBtYXJrZWQgd2l0aFxuXHRcdFx0XHQvLyBhbiBgb3JpZ2luYWxWYWx1ZWAgcHJvcGVydHkuIEhlcmUsIHdoZW4gd2UgZGV0ZWN0IHRoaXMsIHdlXG5cdFx0XHRcdC8vIHVwaG9sZCB0aGUgaWxsdXNpb24gYnkgcHJldGVuZGluZyB0byBzZWUgdGhhdCBvcmlnaW5hbCBkYXRhXG5cdFx0XHRcdC8vIHByb3BlcnR5LCBpLmUuLCByZXR1cm5pbmcgdGhlIHZhbHVlIHJhdGhlciB0aGFuIHRoZSBnZXR0ZXJcblx0XHRcdFx0Ly8gaXRzZWxmLlxuXHRcdFx0XHRpZiAoaXNPd24gJiYgJ2dldCcgaW4gZGVzYyAmJiAhKCdvcmlnaW5hbFZhbHVlJyBpbiBkZXNjLmdldCkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRlc2MuZ2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlzT3duID0gaGFzT3duKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzT3duICYmICFza2lwRnVydGhlckNhY2hpbmcpIHtcblx0XHRcdFx0SU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufTtcbiIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cbnZhciBHZXRQYXJhbXMgPSBmdW5jdGlvbiAoZnVuYykge1xuXHQndXNlIHN0cmljdCc7XG5cblx0aWYgKHR5cGVvZiBmdW5jICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cblx0dmFyIHBhdHRlcm5Db21tZW50cyA9IC8oKFxcL1xcLy4qJCl8KFxcL1xcKltcXHNcXFNdKj9cXCpcXC8pKS9tZztcblx0dmFyIHBhdHRlcm5Bcmd1bWVudHMgPSAvKFteXFxzLF0rKS9nO1xuXG5cdHZhciBmdW5jU3RyaW5nID0gZnVuY1xuXHRcdC50b1N0cmluZygpXG5cdFx0LnJlcGxhY2UocGF0dGVybkNvbW1lbnRzLCAnJyk7XG5cblx0dmFyIHJlc3VsdCA9IGZ1bmNTdHJpbmdcblx0XHQuc2xpY2UoXG5cdFx0XHRmdW5jU3RyaW5nLmluZGV4T2YoJygnKSArIDEsXG5cdFx0XHRmdW5jU3RyaW5nLmluZGV4T2YoJyknKVxuXHRcdClcblx0XHQubWF0Y2gocGF0dGVybkFyZ3VtZW50cyk7XG5cblx0aWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuXHRtb2R1bGUuZXhwb3J0cyA9IEdldFBhcmFtcztcbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdHdpbmRvdy5HZXRQYXJhbXMgPSBHZXRQYXJhbXM7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuXG4vKipcbiAqIFNldCBhIG1hdDQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBpbnZlcnQ7XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gICAgaWYgKCFkZXQpIHsgXG4gICAgICAgIHJldHVybiBudWxsOyBcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzNdID0gKGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzZdID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzldID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTJdID0gKGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTVdID0gKGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgKiBkZXQ7XG5cbiAgICByZXR1cm4gb3V0O1xufTsiLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbG9va0F0O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGxvb2stYXQgbWF0cml4IHdpdGggdGhlIGdpdmVuIGV5ZSBwb3NpdGlvbiwgZm9jYWwgcG9pbnQsIGFuZCB1cCBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHt2ZWMzfSBleWUgUG9zaXRpb24gb2YgdGhlIHZpZXdlclxuICogQHBhcmFtIHt2ZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XG4gKiBAcGFyYW0ge3ZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gbG9va0F0KG91dCwgZXllLCBjZW50ZXIsIHVwKSB7XG4gICAgdmFyIHgwLCB4MSwgeDIsIHkwLCB5MSwgeTIsIHowLCB6MSwgejIsIGxlbixcbiAgICAgICAgZXlleCA9IGV5ZVswXSxcbiAgICAgICAgZXlleSA9IGV5ZVsxXSxcbiAgICAgICAgZXlleiA9IGV5ZVsyXSxcbiAgICAgICAgdXB4ID0gdXBbMF0sXG4gICAgICAgIHVweSA9IHVwWzFdLFxuICAgICAgICB1cHogPSB1cFsyXSxcbiAgICAgICAgY2VudGVyeCA9IGNlbnRlclswXSxcbiAgICAgICAgY2VudGVyeSA9IGNlbnRlclsxXSxcbiAgICAgICAgY2VudGVyeiA9IGNlbnRlclsyXTtcblxuICAgIGlmIChNYXRoLmFicyhleWV4IC0gY2VudGVyeCkgPCAwLjAwMDAwMSAmJlxuICAgICAgICBNYXRoLmFicyhleWV5IC0gY2VudGVyeSkgPCAwLjAwMDAwMSAmJlxuICAgICAgICBNYXRoLmFicyhleWV6IC0gY2VudGVyeikgPCAwLjAwMDAwMSkge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHkob3V0KTtcbiAgICB9XG5cbiAgICB6MCA9IGV5ZXggLSBjZW50ZXJ4O1xuICAgIHoxID0gZXlleSAtIGNlbnRlcnk7XG4gICAgejIgPSBleWV6IC0gY2VudGVyejtcblxuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQoejAgKiB6MCArIHoxICogejEgKyB6MiAqIHoyKTtcbiAgICB6MCAqPSBsZW47XG4gICAgejEgKj0gbGVuO1xuICAgIHoyICo9IGxlbjtcblxuICAgIHgwID0gdXB5ICogejIgLSB1cHogKiB6MTtcbiAgICB4MSA9IHVweiAqIHowIC0gdXB4ICogejI7XG4gICAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICAgIGxlbiA9IE1hdGguc3FydCh4MCAqIHgwICsgeDEgKiB4MSArIHgyICogeDIpO1xuICAgIGlmICghbGVuKSB7XG4gICAgICAgIHgwID0gMDtcbiAgICAgICAgeDEgPSAwO1xuICAgICAgICB4MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gMSAvIGxlbjtcbiAgICAgICAgeDAgKj0gbGVuO1xuICAgICAgICB4MSAqPSBsZW47XG4gICAgICAgIHgyICo9IGxlbjtcbiAgICB9XG5cbiAgICB5MCA9IHoxICogeDIgLSB6MiAqIHgxO1xuICAgIHkxID0gejIgKiB4MCAtIHowICogeDI7XG4gICAgeTIgPSB6MCAqIHgxIC0gejEgKiB4MDtcblxuICAgIGxlbiA9IE1hdGguc3FydCh5MCAqIHkwICsgeTEgKiB5MSArIHkyICogeTIpO1xuICAgIGlmICghbGVuKSB7XG4gICAgICAgIHkwID0gMDtcbiAgICAgICAgeTEgPSAwO1xuICAgICAgICB5MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gMSAvIGxlbjtcbiAgICAgICAgeTAgKj0gbGVuO1xuICAgICAgICB5MSAqPSBsZW47XG4gICAgICAgIHkyICo9IGxlbjtcbiAgICB9XG5cbiAgICBvdXRbMF0gPSB4MDtcbiAgICBvdXRbMV0gPSB5MDtcbiAgICBvdXRbMl0gPSB6MDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHgxO1xuICAgIG91dFs1XSA9IHkxO1xuICAgIG91dFs2XSA9IHoxO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0geDI7XG4gICAgb3V0WzldID0geTI7XG4gICAgb3V0WzEwXSA9IHoyO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAtKHgwICogZXlleCArIHgxICogZXlleSArIHgyICogZXlleik7XG4gICAgb3V0WzEzXSA9IC0oeTAgKiBleWV4ICsgeTEgKiBleWV5ICsgeTIgKiBleWV6KTtcbiAgICBvdXRbMTRdID0gLSh6MCAqIGV5ZXggKyB6MSAqIGV5ZXkgKyB6MiAqIGV5ZXopO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0J3NcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gICAgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG4gICAgdmFyIGIwICA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107ICBcbiAgICBvdXRbMF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzFdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsyXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbM10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbNF07IGIxID0gYls1XTsgYjIgPSBiWzZdOyBiMyA9IGJbN107XG4gICAgb3V0WzRdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFs1XSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbNl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzddID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzhdOyBiMSA9IGJbOV07IGIyID0gYlsxMF07IGIzID0gYlsxMV07XG4gICAgb3V0WzhdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFs5XSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMTBdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFsxMV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbMTJdOyBiMSA9IGJbMTNdOyBiMiA9IGJbMTRdOyBiMyA9IGJbMTVdO1xuICAgIG91dFsxMl0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzEzXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMTRdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFsxNV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBwZXJzcGVjdGl2ZTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhc3BlY3QgQXNwZWN0IHJhdGlvLiB0eXBpY2FsbHkgdmlld3BvcnQgd2lkdGgvaGVpZ2h0XG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBwZXJzcGVjdGl2ZShvdXQsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIGYgPSAxLjAgLyBNYXRoLnRhbihmb3Z5IC8gMiksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSBmIC8gYXNwZWN0O1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gZjtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTFdID0gLTE7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9ICgyICogZmFyICogbmVhcikgKiBuZjtcbiAgICBvdXRbMTVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0NCBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gICAgdmFyIHggPSBheGlzWzBdLCB5ID0gYXhpc1sxXSwgeiA9IGF4aXNbMl0sXG4gICAgICAgIGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopLFxuICAgICAgICBzLCBjLCB0LFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzLFxuICAgICAgICBiMDAsIGIwMSwgYjAyLFxuICAgICAgICBiMTAsIGIxMSwgYjEyLFxuICAgICAgICBiMjAsIGIyMSwgYjIyO1xuXG4gICAgaWYgKE1hdGguYWJzKGxlbikgPCAwLjAwMDAwMSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIFxuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeCAqPSBsZW47XG4gICAgeSAqPSBsZW47XG4gICAgeiAqPSBsZW47XG5cbiAgICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICB0ID0gMSAtIGM7XG5cbiAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gICAgLy8gQ29uc3RydWN0IHRoZSBlbGVtZW50cyBvZiB0aGUgcm90YXRpb24gbWF0cml4XG4gICAgYjAwID0geCAqIHggKiB0ICsgYzsgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7IGIwMiA9IHogKiB4ICogdCAtIHkgKiBzO1xuICAgIGIxMCA9IHggKiB5ICogdCAtIHogKiBzOyBiMTEgPSB5ICogeSAqIHQgKyBjOyBiMTIgPSB6ICogeSAqIHQgKyB4ICogcztcbiAgICBiMjAgPSB4ICogeiAqIHQgKyB5ICogczsgYjIxID0geSAqIHogKiB0IC0geCAqIHM7IGIyMiA9IHogKiB6ICogdCArIGM7XG5cbiAgICAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMjtcbiAgICBvdXRbMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDI7XG4gICAgb3V0WzJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyO1xuICAgIG91dFszXSA9IGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMjtcbiAgICBvdXRbNF0gPSBhMDAgKiBiMTAgKyBhMTAgKiBiMTEgKyBhMjAgKiBiMTI7XG4gICAgb3V0WzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xuICAgIG91dFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMjtcbiAgICBvdXRbN10gPSBhMDMgKiBiMTAgKyBhMTMgKiBiMTEgKyBhMjMgKiBiMTI7XG4gICAgb3V0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICAgIG91dFs5XSA9IGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMjtcbiAgICBvdXRbMTBdID0gYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyO1xuICAgIG91dFsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjI7XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1NYXQ0O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDQuXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgdyA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XVxuICAgIHcgPSB3IHx8IDEuMFxuICAgIG91dFswXSA9IChtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSkgLyB3XG4gICAgb3V0WzFdID0gKG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdKSAvIHdcbiAgICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAvIHdcbiAgICByZXR1cm4gb3V0XG59IiwiLy8gQGZsb3dcbid1c2Ugc3RyaWN0JztcblxudmFyIGtleSA9ICdfX2dsb2JhbF91bmlxdWVfaWRfXyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBnbG9iYWxba2V5XSA9IChnbG9iYWxba2V5XSB8fCAwKSArIDE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmRlZmluZVByb3BlcnR5JScsIHRydWUpO1xuXG52YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9ycyA9IGZ1bmN0aW9uIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMoKSB7XG5cdGlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0XHR0cnkge1xuXHRcdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5oYXNQcm9wZXJ0eURlc2NyaXB0b3JzLmhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnID0gZnVuY3Rpb24gaGFzQXJyYXlMZW5ndGhEZWZpbmVCdWcoKSB7XG5cdC8vIG5vZGUgdjAuNiBoYXMgYSBidWcgd2hlcmUgYXJyYXkgbGVuZ3RocyBjYW4gYmUgU2V0IGJ1dCBub3QgRGVmaW5lZFxuXHRpZiAoIWhhc1Byb3BlcnR5RGVzY3JpcHRvcnMoKSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHRyeSB7XG5cdFx0cmV0dXJuICRkZWZpbmVQcm9wZXJ0eShbXSwgJ2xlbmd0aCcsIHsgdmFsdWU6IDEgfSkubGVuZ3RoICE9PSAxO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSW4gRmlyZWZveCA0LTIyLCBkZWZpbmluZyBsZW5ndGggb24gYW4gYXJyYXkgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdGVzdCA9IHtcblx0Zm9vOiB7fVxufTtcblxudmFyICRPYmplY3QgPSBPYmplY3Q7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzUHJvdG8oKSB7XG5cdHJldHVybiB7IF9fcHJvdG9fXzogdGVzdCB9LmZvbyA9PT0gdGVzdC5mb28gJiYgISh7IF9fcHJvdG9fXzogbnVsbCB9IGluc3RhbmNlb2YgJE9iamVjdCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb3JpZ1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbDtcbnZhciBoYXNTeW1ib2xTaGFtID0gcmVxdWlyZSgnLi9zaGFtcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCgnZm9vJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCgnYmFyJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHJldHVybiBoYXNTeW1ib2xTaGFtKCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgY29tcGxleGl0eTogWzIsIDE4XSwgbWF4LXN0YXRlbWVudHM6IFsyLCAzM10gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdHZhciBvYmogPSB7fTtcblx0dmFyIHN5bSA9IFN5bWJvbCgndGVzdCcpO1xuXHR2YXIgc3ltT2JqID0gT2JqZWN0KHN5bSk7XG5cdGlmICh0eXBlb2Ygc3ltID09PSAnc3RyaW5nJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bU9iaikgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvb2JqZWN0LmFzc2lnbi9pc3N1ZXMvMTdcblx0Ly8gaWYgKHN5bSBpbnN0YW5jZW9mIFN5bWJvbCkgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzL2lzc3Vlcy80XG5cdC8vIGlmICghKHN5bU9iaiBpbnN0YW5jZW9mIFN5bWJvbCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gaWYgKHR5cGVvZiBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyBpZiAoU3RyaW5nKHN5bSkgIT09IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1WYWwgPSA0Mjtcblx0b2JqW3N5bV0gPSBzeW1WYWw7XG5cdGZvciAoc3ltIGluIG9iaikgeyByZXR1cm4gZmFsc2U7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tdW5yZWFjaGFibGUtbG9vcFxuXHRpZiAodHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaik7XG5cdGlmIChzeW1zLmxlbmd0aCAhPT0gMSB8fCBzeW1zWzBdICE9PSBzeW0pIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqLCBzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHN5bSk7XG5cdFx0aWYgKGRlc2NyaXB0b3IudmFsdWUgIT09IHN5bVZhbCB8fCBkZXNjcmlwdG9yLmVudW1lcmFibGUgIT09IHRydWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMvc2hhbXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNUb1N0cmluZ1RhZ1NoYW1zKCkge1xuXHRyZXR1cm4gaGFzU3ltYm9scygpICYmICEhU3ltYm9sLnRvU3RyaW5nVGFnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuIiwidmFyIG5vQ2FzZSA9IHJlcXVpcmUoJ25vLWNhc2UnKVxudmFyIHVwcGVyQ2FzZSA9IHJlcXVpcmUoJ3VwcGVyLWNhc2UnKVxuXG4vKipcbiAqIEhlYWRlciBjYXNlIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSAge3N0cmluZ30gW2xvY2FsZV1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIGxvY2FsZSkge1xuICByZXR1cm4gbm9DYXNlKHZhbHVlLCBsb2NhbGUsICctJykucmVwbGFjZSgvXi58LS4vZywgZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gdXBwZXJDYXNlKG0sIGxvY2FsZSlcbiAgfSlcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG52YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gIGNvbnRleHRUeXBlOiB0cnVlLFxuICBjb250ZXh0VHlwZXM6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIGdldERlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IHRydWUsXG4gIG1peGluczogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlLFxuICB0eXBlOiB0cnVlXG59O1xudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gIG5hbWU6IHRydWUsXG4gIGxlbmd0aDogdHJ1ZSxcbiAgcHJvdG90eXBlOiB0cnVlLFxuICBjYWxsZXI6IHRydWUsXG4gIGNhbGxlZTogdHJ1ZSxcbiAgYXJndW1lbnRzOiB0cnVlLFxuICBhcml0eTogdHJ1ZVxufTtcbnZhciBGT1JXQVJEX1JFRl9TVEFUSUNTID0ge1xuICAnJCR0eXBlb2YnOiB0cnVlLFxuICByZW5kZXI6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZVxufTtcbnZhciBNRU1PX1NUQVRJQ1MgPSB7XG4gICckJHR5cGVvZic6IHRydWUsXG4gIGNvbXBhcmU6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBUWVBFX1NUQVRJQ1MgPSB7fTtcblRZUEVfU1RBVElDU1tyZWFjdElzLkZvcndhcmRSZWZdID0gRk9SV0FSRF9SRUZfU1RBVElDUztcblRZUEVfU1RBVElDU1tyZWFjdElzLk1lbW9dID0gTUVNT19TVEFUSUNTO1xuXG5mdW5jdGlvbiBnZXRTdGF0aWNzKGNvbXBvbmVudCkge1xuICAvLyBSZWFjdCB2MTYuMTEgYW5kIGJlbG93XG4gIGlmIChyZWFjdElzLmlzTWVtbyhjb21wb25lbnQpKSB7XG4gICAgcmV0dXJuIE1FTU9fU1RBVElDUztcbiAgfSAvLyBSZWFjdCB2MTYuMTIgYW5kIGFib3ZlXG5cblxuICByZXR1cm4gVFlQRV9TVEFUSUNTW2NvbXBvbmVudFsnJCR0eXBlb2YnXV0gfHwgUkVBQ1RfU1RBVElDUztcbn1cblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgb2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbmZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50LCBibGFja2xpc3QpIHtcbiAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZG9uJ3QgaG9pc3Qgb3ZlciBzdHJpbmcgKGh0bWwpIGNvbXBvbmVudHNcbiAgICBpZiAob2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICB2YXIgaW5oZXJpdGVkQ29tcG9uZW50ID0gZ2V0UHJvdG90eXBlT2Yoc291cmNlQ29tcG9uZW50KTtcblxuICAgICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIGluaGVyaXRlZENvbXBvbmVudCwgYmxhY2tsaXN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcblxuICAgIGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlQ29tcG9uZW50KSk7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldFN0YXRpY3MgPSBnZXRTdGF0aWNzKHRhcmdldENvbXBvbmVudCk7XG4gICAgdmFyIHNvdXJjZVN0YXRpY3MgPSBnZXRTdGF0aWNzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoIUtOT1dOX1NUQVRJQ1Nba2V5XSAmJiAhKGJsYWNrbGlzdCAmJiBibGFja2xpc3Rba2V5XSkgJiYgIShzb3VyY2VTdGF0aWNzICYmIHNvdXJjZVN0YXRpY3Nba2V5XSkgJiYgISh0YXJnZXRTdGF0aWNzICYmIHRhcmdldFN0YXRpY3Nba2V5XSkpIHtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlQ29tcG9uZW50LCBrZXkpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gQXZvaWQgZmFpbHVyZXMgZnJvbSByZWFkLW9ubHkgcHJvcGVydGllc1xuICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldENvbXBvbmVudCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhvaXN0Tm9uUmVhY3RTdGF0aWNzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby12YXIsIHByZWZlci10ZW1wbGF0ZSAqL1xudmFyIHVwcGVyY2FzZVBhdHRlcm4gPSAvW0EtWl0vZztcbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG52YXIgY2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gdG9IeXBoZW5Mb3dlcihtYXRjaCkge1xuICByZXR1cm4gJy0nICsgbWF0Y2gudG9Mb3dlckNhc2UoKVxufVxuXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUobmFtZSkge1xuICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gY2FjaGVbbmFtZV1cbiAgfVxuXG4gIHZhciBoTmFtZSA9IG5hbWUucmVwbGFjZSh1cHBlcmNhc2VQYXR0ZXJuLCB0b0h5cGhlbkxvd2VyKTtcbiAgcmV0dXJuIChjYWNoZVtuYW1lXSA9IG1zUGF0dGVybi50ZXN0KGhOYW1lKSA/ICctJyArIGhOYW1lIDogaE5hbWUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlU3R5bGVOYW1lO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xuXG52YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gJHRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG52YXIgaXNMZWdhY3lBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaXNTdGFuZGFyZEFyZ3VtZW50cyh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiZcblx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZSkgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIGlzU3RhbmRhcmRBcmd1bWVudHMoYXJndW1lbnRzKTtcbn0oKSk7XG5cbmlzU3RhbmRhcmRBcmd1bWVudHMuaXNMZWdhY3lBcmd1bWVudHMgPSBpc0xlZ2FjeUFyZ3VtZW50czsgLy8gZm9yIHRlc3RzXG5cbm1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA/IGlzU3RhbmRhcmRBcmd1bWVudHMgOiBpc0xlZ2FjeUFyZ3VtZW50cztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdldERheSA9IERhdGUucHJvdG90eXBlLmdldERheTtcbnZhciB0cnlEYXRlT2JqZWN0ID0gZnVuY3Rpb24gdHJ5RGF0ZUdldERheUNhbGwodmFsdWUpIHtcblx0dHJ5IHtcblx0XHRnZXREYXkuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZGF0ZUNsYXNzID0gJ1tvYmplY3QgRGF0ZV0nO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0RhdGVPYmplY3QodmFsdWUpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuIGhhc1RvU3RyaW5nVGFnID8gdHJ5RGF0ZU9iamVjdCh2YWx1ZSkgOiB0b1N0ci5jYWxsKHZhbHVlKSA9PT0gZGF0ZUNsYXNzO1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJ2lzLW9iamVjdCcpXG52YXIgaXNXaW5kb3cgPSByZXF1aXJlKCdpcy13aW5kb3cnKVxuXG5mdW5jdGlvbiBpc05vZGUgKHZhbCkge1xuICBpZiAoIWlzT2JqZWN0KHZhbCkgfHwgIWlzV2luZG93KHdpbmRvdykgfHwgdHlwZW9mIHdpbmRvdy5Ob2RlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHlwZW9mIHZhbC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiZcbiAgICB0eXBlb2YgdmFsLm5vZGVOYW1lID09PSAnc3RyaW5nJ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTm9kZVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgaXNCcm93c2VyID0gZXhwb3J0cy5pc0Jyb3dzZXIgPSAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHdpbmRvdykpID09PSBcIm9iamVjdFwiICYmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihkb2N1bWVudCkpID09PSAnb2JqZWN0JyAmJiBkb2N1bWVudC5ub2RlVHlwZSA9PT0gOTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gaXNCcm93c2VyOyIsInZhciBsb3dlckNhc2UgPSByZXF1aXJlKCdsb3dlci1jYXNlJylcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBpcyBsb3dlciBjYXNlLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gIHN0cmluZ1xuICogQHBhcmFtICB7U3RyaW5nfSAgW2xvY2FsZV1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cmluZywgbG9jYWxlKSB7XG4gIHJldHVybiBsb3dlckNhc2Uoc3RyaW5nLCBsb2NhbGUpID09PSBzdHJpbmdcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcblx0cmV0dXJuIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmIHggIT09IG51bGw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcbnZhciBoYXM7XG52YXIgJGV4ZWM7XG52YXIgaXNSZWdleE1hcmtlcjtcbnZhciBiYWRTdHJpbmdpZmllcjtcblxuaWYgKGhhc1RvU3RyaW5nVGFnKSB7XG5cdGhhcyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eScpO1xuXHQkZXhlYyA9IGNhbGxCb3VuZCgnUmVnRXhwLnByb3RvdHlwZS5leGVjJyk7XG5cdGlzUmVnZXhNYXJrZXIgPSB7fTtcblxuXHR2YXIgdGhyb3dSZWdleE1hcmtlciA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aHJvdyBpc1JlZ2V4TWFya2VyO1xuXHR9O1xuXHRiYWRTdHJpbmdpZmllciA9IHtcblx0XHR0b1N0cmluZzogdGhyb3dSZWdleE1hcmtlcixcblx0XHR2YWx1ZU9mOiB0aHJvd1JlZ2V4TWFya2VyXG5cdH07XG5cblx0aWYgKHR5cGVvZiBTeW1ib2wudG9QcmltaXRpdmUgPT09ICdzeW1ib2wnKSB7XG5cdFx0YmFkU3RyaW5naWZpZXJbU3ltYm9sLnRvUHJpbWl0aXZlXSA9IHRocm93UmVnZXhNYXJrZXI7XG5cdH1cbn1cblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIHJlZ2V4Q2xhc3MgPSAnW29iamVjdCBSZWdFeHBdJztcblxubW9kdWxlLmV4cG9ydHMgPSBoYXNUb1N0cmluZ1RhZ1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblx0PyBmdW5jdGlvbiBpc1JlZ2V4KHZhbHVlKSB7XG5cdFx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHZhbHVlLCAnbGFzdEluZGV4Jyk7XG5cdFx0dmFyIGhhc0xhc3RJbmRleERhdGFQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgaGFzKGRlc2NyaXB0b3IsICd2YWx1ZScpO1xuXHRcdGlmICghaGFzTGFzdEluZGV4RGF0YVByb3BlcnR5KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdCRleGVjKHZhbHVlLCBiYWRTdHJpbmdpZmllcik7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIGUgPT09IGlzUmVnZXhNYXJrZXI7XG5cdFx0fVxuXHR9XG5cdDogZnVuY3Rpb24gaXNSZWdleCh2YWx1ZSkge1xuXHRcdC8vIEluIG9sZGVyIGJyb3dzZXJzLCB0eXBlb2YgcmVnZXggaW5jb3JyZWN0bHkgcmV0dXJucyAnZnVuY3Rpb24nXG5cdFx0aWYgKCF2YWx1ZSB8fCAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICR0b1N0cmluZyh2YWx1ZSkgPT09IHJlZ2V4Q2xhc3M7XG5cdH07XG4iLCJ2YXIgdXBwZXJDYXNlID0gcmVxdWlyZSgndXBwZXItY2FzZScpXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgaXMgdXBwZXIgY2FzZS5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICBzdHJpbmdcbiAqIEBwYXJhbSAge1N0cmluZ30gIFtsb2NhbGVdXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHJpbmcsIGxvY2FsZSkge1xuICByZXR1cm4gdXBwZXJDYXNlKHN0cmluZywgbG9jYWxlKSA9PT0gc3RyaW5nXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuXG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBvID0gT2JqZWN0KG9iaik7XG5cbiAgcmV0dXJuIG8gPT09IG8ud2luZG93O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWInKTtcbiIsInZhciBwYXRoR2V0dGVyID0gcmVxdWlyZSgnLi9wYXRoLWdldHRlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgV01hcCA9IHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJz9cbiAgV2Vha01hcDpcbiAgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfSxcbiAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChrZXlzW2ldID09PSBrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZG91Z2xhc2Nyb2NrZm9yZC9KU09OLWpzL2Jsb2IvbWFzdGVyL2N5Y2xlLmpzXG5cbmV4cG9ydHMuZGVjeWNsZSA9IGZ1bmN0aW9uIGRlY3ljbGUob2JqZWN0LCBvcHRpb25zLCByZXBsYWNlcikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIG1hcCA9IG5ldyBXTWFwKClcblxuICB2YXIgbm9DaXJjdWxhck9wdGlvbiA9ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ2NpcmN1bGFyJyk7XG4gIHZhciB3aXRoUmVmcyA9IG9wdGlvbnMucmVmcyAhPT0gZmFsc2U7XG5cbiAgcmV0dXJuIChmdW5jdGlvbiBkZXJleihfdmFsdWUsIHBhdGgsIGtleSkge1xuXG4gICAgLy8gVGhlIGRlcmV6IHJlY3Vyc2VzIHRocm91Z2ggdGhlIG9iamVjdCwgcHJvZHVjaW5nIHRoZSBkZWVwIGNvcHkuXG5cbiAgICB2YXIgaSwgICAgICAgIC8vIFRoZSBsb29wIGNvdW50ZXJcbiAgICAgIG5hbWUsICAgICAgIC8vIFByb3BlcnR5IG5hbWVcbiAgICAgIG51OyAgICAgICAgIC8vIFRoZSBuZXcgb2JqZWN0IG9yIGFycmF5XG5cbiAgICAvLyB0eXBlb2YgbnVsbCA9PT0gJ29iamVjdCcsIHNvIGdvIG9uIGlmIHRoaXMgdmFsdWUgaXMgcmVhbGx5IGFuIG9iamVjdCBidXQgbm90XG4gICAgLy8gb25lIG9mIHRoZSB3ZWlyZCBidWlsdGluIG9iamVjdHMuXG5cbiAgICB2YXIgdmFsdWUgPSB0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicgPyByZXBsYWNlcihrZXkgfHwgJycsIF92YWx1ZSkgOiBfdmFsdWU7XG5cbiAgICBpZiAob3B0aW9ucy5kYXRlICYmIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIHskanNhbjogJ2QnICsgdmFsdWUuZ2V0VGltZSgpfTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmVnZXggJiYgdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiB7JGpzYW46ICdyJyArIHV0aWxzLmdldFJlZ2V4RmxhZ3ModmFsdWUpICsgJywnICsgdmFsdWUuc291cmNlfTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnNbJ2Z1bmN0aW9uJ10gJiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4geyRqc2FuOiAnZicgKyB1dGlscy5zdHJpbmdpZnlGdW5jdGlvbih2YWx1ZSwgb3B0aW9uc1snZnVuY3Rpb24nXSl9XG4gICAgfVxuICAgIGlmIChvcHRpb25zWyduYW4nXSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHskanNhbjogJ24nfVxuICAgIH1cbiAgICBpZiAob3B0aW9uc1snaW5maW5pdHknXSkge1xuICAgICAgaWYgKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA9PT0gdmFsdWUpIHJldHVybiB7JGpzYW46ICdpJ31cbiAgICAgIGlmIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IHZhbHVlKSByZXR1cm4geyRqc2FuOiAneSd9XG4gICAgfVxuICAgIGlmIChvcHRpb25zWyd1bmRlZmluZWQnXSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4geyRqc2FuOiAndSd9XG4gICAgfVxuICAgIGlmIChvcHRpb25zWydlcnJvciddICYmIHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHJldHVybiB7JGpzYW46ICdlJyArIHZhbHVlLm1lc3NhZ2V9XG4gICAgfVxuICAgIGlmIChvcHRpb25zWydzeW1ib2wnXSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7XG4gICAgICB2YXIgc3ltYm9sS2V5ID0gU3ltYm9sLmtleUZvcih2YWx1ZSlcbiAgICAgIGlmIChzeW1ib2xLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4geyRqc2FuOiAnZycgKyBzeW1ib2xLZXl9XG4gICAgICB9XG5cbiAgICAgIC8vICdTeW1ib2woZm9vKScuc2xpY2UoNywgLTEpID09PSAnZm9vJ1xuICAgICAgcmV0dXJuIHskanNhbjogJ3MnICsgdmFsdWUudG9TdHJpbmcoKS5zbGljZSg3LCAtMSl9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnNbJ21hcCddICYmIHR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUgaW5zdGFuY2VvZiBNYXAgJiYgdHlwZW9mIEFycmF5LmZyb20gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB7JGpzYW46ICdtJyArIEpTT04uc3RyaW5naWZ5KGRlY3ljbGUoQXJyYXkuZnJvbSh2YWx1ZSksIG9wdGlvbnMsIHJlcGxhY2VyKSl9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnNbJ3NldCddICYmIHR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUgaW5zdGFuY2VvZiBTZXQgJiYgdHlwZW9mIEFycmF5LmZyb20gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB7JGpzYW46ICdsJyArIEpTT04uc3RyaW5naWZ5KGRlY3ljbGUoQXJyYXkuZnJvbSh2YWx1ZSksIG9wdGlvbnMsIHJlcGxhY2VyKSl9XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB2YXIga2V5U3RyaW5nID0gKGtleSB8fCAnJCcpO1xuICAgICAgICByZXR1cm4gXCJ0b0pTT04gZmFpbGVkIGZvciAnXCIgKyAobWFwLmdldCh2YWx1ZSkgfHwga2V5U3RyaW5nKSArIFwiJ1wiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmXG4gICAgICAhKHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbikgJiZcbiAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAgICAmJlxuICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgICYmXG4gICAgICAhKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSAgJiZcbiAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpICAmJlxuICAgICAgISh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSAgJiZcbiAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikpIHtcblxuICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IG9yIGFycmF5LCBsb29rIHRvIHNlZSBpZiB3ZSBoYXZlIGFscmVhZHlcbiAgICAgICAgLy8gZW5jb3VudGVyZWQgaXQuIElmIHNvLCByZXR1cm4gYSAkcmVmL3BhdGggb2JqZWN0LlxuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgZm91bmRQYXRoID0gbWFwLmdldCh2YWx1ZSk7XG4gICAgICAgIGlmIChmb3VuZFBhdGgpIHtcbiAgICAgICAgICBpZiAobm9DaXJjdWxhck9wdGlvbiAmJiB3aXRoUmVmcykge1xuICAgICAgICAgICAgcmV0dXJuIHskanNhbjogZm91bmRQYXRofTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhdGguaW5kZXhPZihmb3VuZFBhdGgpID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoIW5vQ2lyY3VsYXJPcHRpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvcHRpb25zLmNpcmN1bGFyID09PSAnZnVuY3Rpb24nP1xuICAgICAgICAgICAgICBvcHRpb25zLmNpcmN1bGFyKHZhbHVlLCBwYXRoLCBmb3VuZFBhdGgpOlxuICAgICAgICAgICAgICBvcHRpb25zLmNpcmN1bGFyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHskanNhbjogZm91bmRQYXRofTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHdpdGhSZWZzKSByZXR1cm4geyRqc2FuOiBmb3VuZFBhdGh9O1xuICAgICAgICB9XG4gICAgICAgIG1hcC5zZXQodmFsdWUsIHBhdGgpO1xuICAgICAgfVxuXG5cbiAgICAgIC8vIElmIGl0IGlzIGFuIGFycmF5LCByZXBsaWNhdGUgdGhlIGFycmF5LlxuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICBudSA9IFtdO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICBudVtpXSA9IGRlcmV6KHZhbHVlW2ldLCBwYXRoICsgJ1snICsgaSArICddJywgaSk7XG4gICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBJZiBpdCBpcyBhbiBvYmplY3QsIHJlcGxpY2F0ZSB0aGUgb2JqZWN0LlxuXG4gICAgICAgIG51ID0ge307XG4gICAgICAgIGZvciAobmFtZSBpbiB2YWx1ZSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIG5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFBhdGggPSAvXlxcdyskLy50ZXN0KG5hbWUpID9cbiAgICAgICAgICAgICAgJy4nICsgbmFtZSA6XG4gICAgICAgICAgICAgICdbJyArIEpTT04uc3RyaW5naWZ5KG5hbWUpICsgJ10nO1xuICAgICAgICAgICAgbnVbbmFtZV0gPSBuYW1lID09PSAnJGpzYW4nID8gW2RlcmV6KHZhbHVlW25hbWVdLCBwYXRoICsgbmV4dFBhdGgpXSA6IGRlcmV6KHZhbHVlW25hbWVdLCBwYXRoICsgbmV4dFBhdGgsIG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0ob2JqZWN0LCAnJCcpKTtcbn07XG5cblxuZXhwb3J0cy5yZXRyb2N5Y2xlID0gZnVuY3Rpb24gcmV0cm9jeWNsZSgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuXG4gIHJldHVybiAoZnVuY3Rpb24gcmV6KHZhbHVlKSB7XG5cbiAgICAvLyBUaGUgcmV6IGZ1bmN0aW9uIHdhbGtzIHJlY3Vyc2l2ZWx5IHRocm91Z2ggdGhlIG9iamVjdCBsb29raW5nIGZvciAkanNhblxuICAgIC8vIHByb3BlcnRpZXMuIFdoZW4gaXQgZmluZHMgb25lIHRoYXQgaGFzIGEgdmFsdWUgdGhhdCBpcyBhIHBhdGgsIHRoZW4gaXRcbiAgICAvLyByZXBsYWNlcyB0aGUgJGpzYW4gb2JqZWN0IHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIHZhbHVlIHRoYXQgaXMgZm91bmQgYnlcbiAgICAvLyB0aGUgcGF0aC5cblxuICAgIHZhciBpLCBpdGVtLCBuYW1lLCBwYXRoO1xuXG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpdGVtID0gdmFsdWVbaV07XG4gICAgICAgICAgaWYgKGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS4kanNhbikge1xuICAgICAgICAgICAgICB2YWx1ZVtpXSA9IHV0aWxzLnJlc3RvcmUoaXRlbS4kanNhbiwgJCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXooaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKG5hbWUgaW4gdmFsdWUpIHtcbiAgICAgICAgICAvLyBiYXNlIGNhc2UgcGFzc2VkIHJhdyBvYmplY3RcbiAgICAgICAgICBpZih0eXBlb2YgdmFsdWVbbmFtZV0gPT09ICdzdHJpbmcnICYmIG5hbWUgPT09ICckanNhbicpe1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLnJlc3RvcmUodmFsdWUuJGpzYW4sICQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICckanNhbicpIHtcbiAgICAgICAgICAgICAgdmFsdWVbbmFtZV0gPSB2YWx1ZVtuYW1lXVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVbbmFtZV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIGl0ZW0gPSB2YWx1ZVtuYW1lXTtcbiAgICAgICAgICAgICAgaWYgKGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uJGpzYW4pIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlW25hbWVdID0gdXRpbHMucmVzdG9yZShpdGVtLiRqc2FuLCAkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV6KGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0oJCkpO1xufTtcbiIsInZhciBjeWNsZSA9IHJlcXVpcmUoJy4vY3ljbGUnKTtcblxuZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSwgX29wdGlvbnMpIHtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDQpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeS5hcHBseShKU09OLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IF9vcHRpb25zIHx8IGZhbHNlO1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICAnZGF0ZSc6IG9wdGlvbnMsXG4gICAgICAnZnVuY3Rpb24nOiBvcHRpb25zLFxuICAgICAgJ3JlZ2V4Jzogb3B0aW9ucyxcbiAgICAgICd1bmRlZmluZWQnOiBvcHRpb25zLFxuICAgICAgJ2Vycm9yJzogb3B0aW9ucyxcbiAgICAgICdzeW1ib2wnOiBvcHRpb25zLFxuICAgICAgJ21hcCc6IG9wdGlvbnMsXG4gICAgICAnc2V0Jzogb3B0aW9ucyxcbiAgICAgICduYW4nOiBvcHRpb25zLFxuICAgICAgJ2luZmluaXR5Jzogb3B0aW9uc1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWN5Y2xlZCA9IGN5Y2xlLmRlY3ljbGUodmFsdWUsIG9wdGlvbnMsIHJlcGxhY2VyKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGVjeWNsZWQpO1xuICB9IGVsc2Uge1xuICAgIC8vIGRlY3ljbGUgYWxyZWFkeSBoYW5kbGVzIHdoZW4gcmVwbGFjZXIgaXMgYSBmdW5jdGlvbi5cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGVjeWNsZWQsIEFycmF5LmlzQXJyYXkocmVwbGFjZXIpID8gcmVwbGFjZXIgOiBudWxsLCBzcGFjZSk7XG4gIH1cbn1cblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRleHQsIHJldml2ZXIpIHtcbiAgdmFyIG5lZWRzUmV0cm9jeWNsZSA9IC9cIlxcJGpzYW5cIi8udGVzdCh0ZXh0KTtcbiAgdmFyIHBhcnNlZDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBwYXJzZWQgPSBKU09OLnBhcnNlKHRleHQpO1xuICB9IGVsc2Uge1xuICAgIHBhcnNlZCA9IEpTT04ucGFyc2UodGV4dCwgcmV2aXZlcik7XG4gIH1cbiAgaWYgKG5lZWRzUmV0cm9jeWNsZSkge1xuICAgIHBhcnNlZCA9IGN5Y2xlLnJldHJvY3ljbGUocGFyc2VkKTtcbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBwYXRoR2V0dGVyO1xuXG5mdW5jdGlvbiBwYXRoR2V0dGVyKG9iaiwgcGF0aCkge1xuICBpZiAocGF0aCAhPT0gJyQnKSB7XG4gICAgdmFyIHBhdGhzID0gZ2V0UGF0aHMocGF0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgcGF0aCA9IHBhdGhzW2ldLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxcXFwiL2csICdcIicpO1xuICAgICAgaWYgKHR5cGVvZiBvYmpbcGF0aF0gPT09ICd1bmRlZmluZWQnICYmIGkgIT09IHBhdGhzLmxlbmd0aCAtIDEpIGNvbnRpbnVlO1xuICAgICAgb2JqID0gb2JqW3BhdGhdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBnZXRQYXRocyhwYXRoU3RyaW5nKSB7XG4gIHZhciByZWdleCA9IC8oPzpcXC4oXFx3KykpfCg/OlxcWyhcXGQrKVxcXSl8KD86XFxbXCIoKD86W15cXFxcXCJdfFxcXFwuKSopXCJcXF0pL2c7XG4gIHZhciBtYXRjaGVzID0gW107XG4gIHZhciBtYXRjaDtcbiAgd2hpbGUgKG1hdGNoID0gcmVnZXguZXhlYyhwYXRoU3RyaW5nKSkge1xuICAgIG1hdGNoZXMucHVzaCggbWF0Y2hbMV0gfHwgbWF0Y2hbMl0gfHwgbWF0Y2hbM10gKTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcztcbn1cbiIsInZhciBwYXRoR2V0dGVyID0gcmVxdWlyZSgnLi9wYXRoLWdldHRlcicpO1xudmFyIGpzYW4gPSByZXF1aXJlKCcuLycpO1xuXG5leHBvcnRzLmdldFJlZ2V4RmxhZ3MgPSBmdW5jdGlvbiBnZXRSZWdleEZsYWdzKHJlZ2V4KSB7XG4gIHZhciBmbGFncyA9ICcnO1xuICBpZiAocmVnZXguaWdub3JlQ2FzZSkgZmxhZ3MgKz0gJ2knO1xuICBpZiAocmVnZXguZ2xvYmFsKSBmbGFncyArPSAnZyc7XG4gIGlmIChyZWdleC5tdWx0aWxpbmUpIGZsYWdzICs9ICdtJztcbiAgcmV0dXJuIGZsYWdzO1xufTtcblxuZXhwb3J0cy5zdHJpbmdpZnlGdW5jdGlvbiA9IGZ1bmN0aW9uIHN0cmluZ2lmeUZ1bmN0aW9uKGZuLCBjdXN0b21Ub1N0cmluZykge1xuICBpZiAodHlwZW9mIGN1c3RvbVRvU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGN1c3RvbVRvU3RyaW5nKGZuKTtcbiAgfVxuICB2YXIgc3RyID0gZm4udG9TdHJpbmcoKTtcbiAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKC9eW157XSp7fF5bXj1dKj0+Lyk7XG4gIHZhciBzdGFydCA9IG1hdGNoID8gbWF0Y2hbMF0gOiAnPGZ1bmN0aW9uPiAnO1xuICB2YXIgZW5kID0gc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJ30nID8gJ30nIDogJyc7XG4gIHJldHVybiBzdGFydC5yZXBsYWNlKC9cXHJcXG58XFxuL2csICcgJykucmVwbGFjZSgvXFxzKy9nLCAnICcpICsgJyAvKiAuLi4gKi8gJyArIGVuZDtcbn07XG5cbmV4cG9ydHMucmVzdG9yZSA9IGZ1bmN0aW9uIHJlc3RvcmUob2JqLCByb290KSB7XG4gIHZhciB0eXBlID0gb2JqWzBdO1xuICB2YXIgcmVzdCA9IG9iai5zbGljZSgxKTtcbiAgc3dpdGNoKHR5cGUpIHtcbiAgICBjYXNlICckJzpcbiAgICAgIHJldHVybiBwYXRoR2V0dGVyKHJvb3QsIG9iaik7XG4gICAgY2FzZSAncic6XG4gICAgICB2YXIgY29tbWEgPSByZXN0LmluZGV4T2YoJywnKTtcbiAgICAgIHZhciBmbGFncyA9IHJlc3Quc2xpY2UoMCwgY29tbWEpO1xuICAgICAgdmFyIHNvdXJjZSA9IHJlc3Quc2xpY2UoY29tbWEgKyAxKTtcbiAgICAgIHJldHVybiBSZWdFeHAoc291cmNlLCBmbGFncyk7XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbmV3IERhdGUoK3Jlc3QpO1xuICAgIGNhc2UgJ2YnOlxuICAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcihcImNhbid0IHJ1biBqc2FuIHBhcnNlZCBmdW5jdGlvblwiKSB9O1xuICAgICAgZm4udG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHJlc3Q7IH07XG4gICAgICByZXR1cm4gZm47XG4gICAgY2FzZSAndSc6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNhc2UgJ2UnOlxuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKHJlc3QpO1xuICAgICAgZXJyb3Iuc3RhY2sgPSAnU3RhY2sgaXMgdW5hdmFpbGFibGUgZm9yIGpzYW4gcGFyc2VkIGVycm9ycyc7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gU3ltYm9sKHJlc3QpO1xuICAgIGNhc2UgJ2cnOlxuICAgICAgcmV0dXJuIFN5bWJvbC5mb3IocmVzdCk7XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbmV3IE1hcChqc2FuLnBhcnNlKHJlc3QpKTtcbiAgICBjYXNlICdsJzpcbiAgICAgIHJldHVybiBuZXcgU2V0KGpzYW4ucGFyc2UocmVzdCkpO1xuICAgIGNhc2UgJ24nOlxuICAgICAgcmV0dXJuIE5hTjtcbiAgICBjYXNlICdpJzpcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiAtSW5maW5pdHk7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnNvbGUud2FybigndW5rbm93biB0eXBlJywgb2JqKTtcbiAgICAgIHJldHVybiBvYmo7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcblxuXG4vKipcbiAqIENvbnZlbmllbmNlIHdyYXBwZXIgYXJvdW5kIHRoZSBhcGkuXG4gKiBDYWxscyBgLmdldGAgd2hlbiBjYWxsZWQgd2l0aCBhbiBgb2JqZWN0YCBhbmQgYSBgcG9pbnRlcmAuXG4gKiBDYWxscyBgLnNldGAgd2hlbiBhbHNvIGNhbGxlZCB3aXRoIGB2YWx1ZWAuXG4gKiBJZiBvbmx5IHN1cHBsaWVkIGBvYmplY3RgLCByZXR1cm5zIGEgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24sIG1hcHBlZCB0byB0aGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBwb2ludGVyXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEByZXR1cm5zIHsqfVxuICovXG5cbmZ1bmN0aW9uIGFwaSAob2JqLCBwb2ludGVyLCB2YWx1ZSkge1xuICAgIC8vIC5zZXQoKVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHJldHVybiBhcGkuc2V0KG9iaiwgcG9pbnRlciwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyAuZ2V0KClcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICByZXR1cm4gYXBpLmdldChvYmosIHBvaW50ZXIpO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gYSBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbiBvbiBgb2JqYC5cbiAgICB2YXIgd3JhcHBlZCA9IGFwaS5iaW5kKGFwaSwgb2JqKTtcblxuICAgIC8vIFN1cHBvcnQgZm9yIG9vIHN0eWxlXG4gICAgZm9yICh2YXIgbmFtZSBpbiBhcGkpIHtcbiAgICAgICAgaWYgKGFwaS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgd3JhcHBlZFtuYW1lXSA9IGFwaVtuYW1lXS5iaW5kKHdyYXBwZWQsIG9iaik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cblxuLyoqXG4gKiBMb29rdXAgYSBqc29uIHBvaW50ZXIgaW4gYW4gb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBvaW50ZXJcbiAqIEByZXR1cm5zIHsqfVxuICovXG5hcGkuZ2V0ID0gZnVuY3Rpb24gZ2V0IChvYmosIHBvaW50ZXIpIHtcbiAgICB2YXIgcmVmVG9rZW5zID0gQXJyYXkuaXNBcnJheShwb2ludGVyKSA/IHBvaW50ZXIgOiBhcGkucGFyc2UocG9pbnRlcik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZlRva2Vucy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgdG9rID0gcmVmVG9rZW5zW2ldO1xuICAgICAgICBpZiAoISh0eXBlb2Ygb2JqID09ICdvYmplY3QnICYmIHRvayBpbiBvYmopKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVmZXJlbmNlIHRva2VuOiAnICsgdG9rKTtcbiAgICAgICAgfVxuICAgICAgICBvYmogPSBvYmpbdG9rXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbi8qKlxuICogU2V0cyBhIHZhbHVlIG9uIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBwb2ludGVyXG4gKiBAcGFyYW0gdmFsdWVcbiAqL1xuYXBpLnNldCA9IGZ1bmN0aW9uIHNldCAob2JqLCBwb2ludGVyLCB2YWx1ZSkge1xuICAgIHZhciByZWZUb2tlbnMgPSBBcnJheS5pc0FycmF5KHBvaW50ZXIpID8gcG9pbnRlciA6IGFwaS5wYXJzZShwb2ludGVyKSxcbiAgICAgIG5leHRUb2sgPSByZWZUb2tlbnNbMF07XG5cbiAgICBpZiAocmVmVG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0NhbiBub3Qgc2V0IHRoZSByb290IG9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVmVG9rZW5zLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICB2YXIgdG9rID0gcmVmVG9rZW5zW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHRvayAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHRvayAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0b2sgPSBTdHJpbmcodG9rKVxuICAgICAgICB9XG4gICAgICAgIGlmICh0b2sgPT09IFwiX19wcm90b19fXCIgfHwgdG9rID09PSBcImNvbnN0cnVjdG9yXCIgfHwgdG9rID09PSBcInByb3RvdHlwZVwiKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGlmICh0b2sgPT09ICctJyAmJiBBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICB0b2sgPSBvYmoubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIG5leHRUb2sgPSByZWZUb2tlbnNbaSArIDFdO1xuXG4gICAgICAgIGlmICghKHRvayBpbiBvYmopKSB7XG4gICAgICAgICAgICBpZiAobmV4dFRvay5tYXRjaCgvXihcXGQrfC0pJC8pKSB7XG4gICAgICAgICAgICAgICAgb2JqW3Rva10gPSBbXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqW3Rva10gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYmogPSBvYmpbdG9rXTtcbiAgICB9XG4gICAgaWYgKG5leHRUb2sgPT09ICctJyAmJiBBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIG5leHRUb2sgPSBvYmoubGVuZ3RoO1xuICAgIH1cbiAgICBvYmpbbmV4dFRva10gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gcG9pbnRlclxuICovXG5hcGkucmVtb3ZlID0gZnVuY3Rpb24gKG9iaiwgcG9pbnRlcikge1xuICAgIHZhciByZWZUb2tlbnMgPSBBcnJheS5pc0FycmF5KHBvaW50ZXIpID8gcG9pbnRlciA6IGFwaS5wYXJzZShwb2ludGVyKTtcbiAgICB2YXIgZmluYWxUb2tlbiA9IHJlZlRva2Vuc1tyZWZUb2tlbnMubGVuZ3RoIC0xXTtcbiAgICBpZiAoZmluYWxUb2tlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBKU09OIHBvaW50ZXIgZm9yIHJlbW92ZTogXCInICsgcG9pbnRlciArICdcIicpO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnQgPSBhcGkuZ2V0KG9iaiwgcmVmVG9rZW5zLnNsaWNlKDAsIC0xKSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgdmFyIGluZGV4ID0gK2ZpbmFsVG9rZW47XG4gICAgICBpZiAoZmluYWxUb2tlbiA9PT0gJycgJiYgaXNOYU4oaW5kZXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcnJheSBpbmRleDogXCInICsgZmluYWxUb2tlbiArICdcIicpO1xuICAgICAgfVxuXG4gICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwocGFyZW50LCBpbmRleCwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBwYXJlbnRbZmluYWxUb2tlbl07XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgKHBvaW50ZXIgLT4gdmFsdWUpIGRpY3Rpb25hcnkgZm9yIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSBvYmpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRlc2NlbmRcbiAqIEByZXR1cm5zIHt9XG4gKi9cbmFwaS5kaWN0ID0gZnVuY3Rpb24gZGljdCAob2JqLCBkZXNjZW5kKSB7XG4gICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICBhcGkud2FsayhvYmosIGZ1bmN0aW9uICh2YWx1ZSwgcG9pbnRlcikge1xuICAgICAgICByZXN1bHRzW3BvaW50ZXJdID0gdmFsdWU7XG4gICAgfSwgZGVzY2VuZCk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgYW4gb2JqZWN0XG4gKiBJdGVyYXRvcjogZnVuY3Rpb24gKHZhbHVlLCBwb2ludGVyKSB7fVxuICpcbiAqIEBwYXJhbSBvYmpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkZXNjZW5kXG4gKi9cbmFwaS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqLCBpdGVyYXRvciwgZGVzY2VuZCkge1xuICAgIHZhciByZWZUb2tlbnMgPSBbXTtcblxuICAgIGRlc2NlbmQgPSBkZXNjZW5kIHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0eXBlID09PSAnW29iamVjdCBPYmplY3RdJyB8fCB0eXBlID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH07XG5cbiAgICAoZnVuY3Rpb24gbmV4dCAoY3VyKSB7XG4gICAgICAgIGVhY2goY3VyLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgcmVmVG9rZW5zLnB1c2goU3RyaW5nKGtleSkpO1xuICAgICAgICAgICAgaWYgKGRlc2NlbmQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKHZhbHVlLCBhcGkuY29tcGlsZShyZWZUb2tlbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZlRva2Vucy5wb3AoKTtcbiAgICAgICAgfSk7XG4gICAgfShvYmopKTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgYW4gb2JqZWN0IGhhcyBhIHZhbHVlIGZvciBhIGpzb24gcG9pbnRlclxuICpcbiAqIEBwYXJhbSBvYmpcbiAqIEBwYXJhbSBwb2ludGVyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuYXBpLmhhcyA9IGZ1bmN0aW9uIGhhcyAob2JqLCBwb2ludGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXBpLmdldChvYmosIHBvaW50ZXIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogRXNjYXBlcyBhIHJlZmVyZW5jZSB0b2tlblxuICpcbiAqIEBwYXJhbSBzdHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmFwaS5lc2NhcGUgPSBmdW5jdGlvbiBlc2NhcGUgKHN0cikge1xuICAgIHJldHVybiBzdHIudG9TdHJpbmcoKS5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKTtcbn07XG5cbi8qKlxuICogVW5lc2NhcGVzIGEgcmVmZXJlbmNlIHRva2VuXG4gKlxuICogQHBhcmFtIHN0clxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuYXBpLnVuZXNjYXBlID0gZnVuY3Rpb24gdW5lc2NhcGUgKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvfjEvZywgJy8nKS5yZXBsYWNlKC9+MC9nLCAnficpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGpzb24gcG9pbnRlciBpbnRvIGEgYXJyYXkgb2YgcmVmZXJlbmNlIHRva2Vuc1xuICpcbiAqIEBwYXJhbSBwb2ludGVyXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmFwaS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlIChwb2ludGVyKSB7XG4gICAgaWYgKHBvaW50ZXIgPT09ICcnKSB7IHJldHVybiBbXTsgfVxuICAgIGlmIChwb2ludGVyLmNoYXJBdCgwKSAhPT0gJy8nKSB7IHRocm93IG5ldyBFcnJvcignSW52YWxpZCBKU09OIHBvaW50ZXI6ICcgKyBwb2ludGVyKTsgfVxuICAgIHJldHVybiBwb2ludGVyLnN1YnN0cmluZygxKS5zcGxpdCgvXFwvLykubWFwKGFwaS51bmVzY2FwZSk7XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIGpzb24gcG9pbnRlciBmcm9tIGEgYXJyYXkgb2YgcmVmZXJlbmNlIHRva2Vuc1xuICpcbiAqIEBwYXJhbSByZWZUb2tlbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmFwaS5jb21waWxlID0gZnVuY3Rpb24gY29tcGlsZSAocmVmVG9rZW5zKSB7XG4gICAgaWYgKHJlZlRva2Vucy5sZW5ndGggPT09IDApIHsgcmV0dXJuICcnOyB9XG4gICAgcmV0dXJuICcvJyArIHJlZlRva2Vucy5tYXAoYXBpLmVzY2FwZSkuam9pbignLycpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciBoeXBoZW5hdGUgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnaHlwaGVuYXRlLXN0eWxlLW5hbWUnKSk7XG5cbi8qKlxuICogQ29udmVydCBjYW1lbCBjYXNlZCBwcm9wZXJ0eSBuYW1lcyB0byBkYXNoIHNlcGFyYXRlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBjb252ZXJ0Q2FzZShzdHlsZSkge1xuICB2YXIgY29udmVydGVkID0ge307XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgIHZhciBrZXkgPSBwcm9wLmluZGV4T2YoJy0tJykgPT09IDAgPyBwcm9wIDogaHlwaGVuYXRlKHByb3ApO1xuICAgIGNvbnZlcnRlZFtrZXldID0gc3R5bGVbcHJvcF07XG4gIH1cblxuICBpZiAoc3R5bGUuZmFsbGJhY2tzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUuZmFsbGJhY2tzKSkgY29udmVydGVkLmZhbGxiYWNrcyA9IHN0eWxlLmZhbGxiYWNrcy5tYXAoY29udmVydENhc2UpO2Vsc2UgY29udmVydGVkLmZhbGxiYWNrcyA9IGNvbnZlcnRDYXNlKHN0eWxlLmZhbGxiYWNrcyk7XG4gIH1cblxuICByZXR1cm4gY29udmVydGVkO1xufVxuLyoqXG4gKiBBbGxvdyBjYW1lbCBjYXNlZCBwcm9wZXJ0eSBuYW1lcyBieSBjb252ZXJ0aW5nIHRoZW0gYmFjayB0byBkYXNoZXJpemVkLlxuICpcbiAqIEBwYXJhbSB7UnVsZX0gcnVsZVxuICovXG5cblxuZnVuY3Rpb24gY2FtZWxDYXNlKCkge1xuICBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlKSkge1xuICAgICAgLy8gSGFuZGxlIHJ1bGVzIGxpa2UgQGZvbnQtZmFjZSwgd2hpY2ggY2FuIGhhdmUgbXVsdGlwbGUgc3R5bGVzIGluIGFuIGFycmF5XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3R5bGUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHN0eWxlW2luZGV4XSA9IGNvbnZlcnRDYXNlKHN0eWxlW2luZGV4XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udmVydENhc2Uoc3R5bGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWx1ZSwgcHJvcCwgcnVsZSkge1xuICAgIGlmIChwcm9wLmluZGV4T2YoJy0tJykgPT09IDApIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgaHlwaGVuYXRlZFByb3AgPSBoeXBoZW5hdGUocHJvcCk7IC8vIFRoZXJlIHdhcyBubyBjYW1lbCBjYXNlIGluIHBsYWNlXG5cbiAgICBpZiAocHJvcCA9PT0gaHlwaGVuYXRlZFByb3ApIHJldHVybiB2YWx1ZTtcbiAgICBydWxlLnByb3AoaHlwaGVuYXRlZFByb3AsIHZhbHVlKTsgLy8gQ29yZSB3aWxsIGlnbm9yZSB0aGF0IHByb3BlcnR5IHZhbHVlIHdlIHNldCB0aGUgcHJvcGVyIG9uZSBhYm92ZS5cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGUsXG4gICAgb25DaGFuZ2VWYWx1ZTogb25DaGFuZ2VWYWx1ZVxuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBjYW1lbENhc2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBqc3MgPSByZXF1aXJlKCdqc3MnKTtcblxudmFyIHB4ID0ganNzLmhhc0NTU1RPTVN1cHBvcnQgJiYgQ1NTID8gQ1NTLnB4IDogJ3B4JztcbnZhciBtcyA9IGpzcy5oYXNDU1NUT01TdXBwb3J0ICYmIENTUyA/IENTUy5tcyA6ICdtcyc7XG52YXIgcGVyY2VudCA9IGpzcy5oYXNDU1NUT01TdXBwb3J0ICYmIENTUyA/IENTUy5wZXJjZW50IDogJyUnO1xuLyoqXG4gKiBHZW5lcmF0ZWQganNzLXBsdWdpbi1kZWZhdWx0LXVuaXQgQ1NTIHByb3BlcnR5IHVuaXRzXG4gKlxuICogQHR5cGUgb2JqZWN0XG4gKi9cblxudmFyIGRlZmF1bHRVbml0cyA9IHtcbiAgLy8gQW5pbWF0aW9uIHByb3BlcnRpZXNcbiAgJ2FuaW1hdGlvbi1kZWxheSc6IG1zLFxuICAnYW5pbWF0aW9uLWR1cmF0aW9uJzogbXMsXG4gIC8vIEJhY2tncm91bmQgcHJvcGVydGllc1xuICAnYmFja2dyb3VuZC1wb3NpdGlvbic6IHB4LFxuICAnYmFja2dyb3VuZC1wb3NpdGlvbi14JzogcHgsXG4gICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknOiBweCxcbiAgJ2JhY2tncm91bmQtc2l6ZSc6IHB4LFxuICAvLyBCb3JkZXIgUHJvcGVydGllc1xuICBib3JkZXI6IHB4LFxuICAnYm9yZGVyLWJvdHRvbSc6IHB4LFxuICAnYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyc6IHB4LFxuICAnYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXMnOiBweCxcbiAgJ2JvcmRlci1ib3R0b20td2lkdGgnOiBweCxcbiAgJ2JvcmRlci1sZWZ0JzogcHgsXG4gICdib3JkZXItbGVmdC13aWR0aCc6IHB4LFxuICAnYm9yZGVyLXJhZGl1cyc6IHB4LFxuICAnYm9yZGVyLXJpZ2h0JzogcHgsXG4gICdib3JkZXItcmlnaHQtd2lkdGgnOiBweCxcbiAgJ2JvcmRlci10b3AnOiBweCxcbiAgJ2JvcmRlci10b3AtbGVmdC1yYWRpdXMnOiBweCxcbiAgJ2JvcmRlci10b3AtcmlnaHQtcmFkaXVzJzogcHgsXG4gICdib3JkZXItdG9wLXdpZHRoJzogcHgsXG4gICdib3JkZXItd2lkdGgnOiBweCxcbiAgLy8gTWFyZ2luIHByb3BlcnRpZXNcbiAgbWFyZ2luOiBweCxcbiAgJ21hcmdpbi1ib3R0b20nOiBweCxcbiAgJ21hcmdpbi1sZWZ0JzogcHgsXG4gICdtYXJnaW4tcmlnaHQnOiBweCxcbiAgJ21hcmdpbi10b3AnOiBweCxcbiAgLy8gUGFkZGluZyBwcm9wZXJ0aWVzXG4gIHBhZGRpbmc6IHB4LFxuICAncGFkZGluZy1ib3R0b20nOiBweCxcbiAgJ3BhZGRpbmctbGVmdCc6IHB4LFxuICAncGFkZGluZy1yaWdodCc6IHB4LFxuICAncGFkZGluZy10b3AnOiBweCxcbiAgLy8gTWFzayBwcm9wZXJ0aWVzXG4gICdtYXNrLXBvc2l0aW9uLXgnOiBweCxcbiAgJ21hc2stcG9zaXRpb24teSc6IHB4LFxuICAnbWFzay1zaXplJzogcHgsXG4gIC8vIFdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllc1xuICBoZWlnaHQ6IHB4LFxuICB3aWR0aDogcHgsXG4gICdtaW4taGVpZ2h0JzogcHgsXG4gICdtYXgtaGVpZ2h0JzogcHgsXG4gICdtaW4td2lkdGgnOiBweCxcbiAgJ21heC13aWR0aCc6IHB4LFxuICAvLyBQb3NpdGlvbiBwcm9wZXJ0aWVzXG4gIGJvdHRvbTogcHgsXG4gIGxlZnQ6IHB4LFxuICB0b3A6IHB4LFxuICByaWdodDogcHgsXG4gIC8vIFNoYWRvdyBwcm9wZXJ0aWVzXG4gICdib3gtc2hhZG93JzogcHgsXG4gICd0ZXh0LXNoYWRvdyc6IHB4LFxuICAvLyBDb2x1bW4gcHJvcGVydGllc1xuICAnY29sdW1uLWdhcCc6IHB4LFxuICAnY29sdW1uLXJ1bGUnOiBweCxcbiAgJ2NvbHVtbi1ydWxlLXdpZHRoJzogcHgsXG4gICdjb2x1bW4td2lkdGgnOiBweCxcbiAgLy8gRm9udCBhbmQgdGV4dCBwcm9wZXJ0aWVzXG4gICdmb250LXNpemUnOiBweCxcbiAgJ2ZvbnQtc2l6ZS1kZWx0YSc6IHB4LFxuICAnbGV0dGVyLXNwYWNpbmcnOiBweCxcbiAgJ3RleHQtaW5kZW50JzogcHgsXG4gICd0ZXh0LXN0cm9rZSc6IHB4LFxuICAndGV4dC1zdHJva2Utd2lkdGgnOiBweCxcbiAgJ3dvcmQtc3BhY2luZyc6IHB4LFxuICAvLyBNb3Rpb24gcHJvcGVydGllc1xuICBtb3Rpb246IHB4LFxuICAnbW90aW9uLW9mZnNldCc6IHB4LFxuICAvLyBPdXRsaW5lIHByb3BlcnRpZXNcbiAgb3V0bGluZTogcHgsXG4gICdvdXRsaW5lLW9mZnNldCc6IHB4LFxuICAnb3V0bGluZS13aWR0aCc6IHB4LFxuICAvLyBQZXJzcGVjdGl2ZSBwcm9wZXJ0aWVzXG4gIHBlcnNwZWN0aXZlOiBweCxcbiAgJ3BlcnNwZWN0aXZlLW9yaWdpbi14JzogcGVyY2VudCxcbiAgJ3BlcnNwZWN0aXZlLW9yaWdpbi15JzogcGVyY2VudCxcbiAgLy8gVHJhbnNmb3JtIHByb3BlcnRpZXNcbiAgJ3RyYW5zZm9ybS1vcmlnaW4nOiBwZXJjZW50LFxuICAndHJhbnNmb3JtLW9yaWdpbi14JzogcGVyY2VudCxcbiAgJ3RyYW5zZm9ybS1vcmlnaW4teSc6IHBlcmNlbnQsXG4gICd0cmFuc2Zvcm0tb3JpZ2luLXonOiBwZXJjZW50LFxuICAvLyBUcmFuc2l0aW9uIHByb3BlcnRpZXNcbiAgJ3RyYW5zaXRpb24tZGVsYXknOiBtcyxcbiAgJ3RyYW5zaXRpb24tZHVyYXRpb24nOiBtcyxcbiAgLy8gQWxpZ25tZW50IHByb3BlcnRpZXNcbiAgJ3ZlcnRpY2FsLWFsaWduJzogcHgsXG4gICdmbGV4LWJhc2lzJzogcHgsXG4gIC8vIFNvbWUgcmFuZG9tIHByb3BlcnRpZXNcbiAgJ3NoYXBlLW1hcmdpbic6IHB4LFxuICBzaXplOiBweCxcbiAgLy8gR3JpZCBwcm9wZXJ0aWVzXG4gIGdyaWQ6IHB4LFxuICAnZ3JpZC1nYXAnOiBweCxcbiAgJ2dyaWQtcm93LWdhcCc6IHB4LFxuICAnZ3JpZC1jb2x1bW4tZ2FwJzogcHgsXG4gICdncmlkLXRlbXBsYXRlLXJvd3MnOiBweCxcbiAgJ2dyaWQtdGVtcGxhdGUtY29sdW1ucyc6IHB4LFxuICAnZ3JpZC1hdXRvLXJvd3MnOiBweCxcbiAgJ2dyaWQtYXV0by1jb2x1bW5zJzogcHgsXG4gIC8vIE5vdCBleGlzdGluZyBwcm9wZXJ0aWVzLlxuICAvLyBVc2VkIHRvIGF2b2lkIGlzc3VlcyB3aXRoIGpzcy1wbHVnaW4tZXhwYW5kIGludGVncmF0aW9uLlxuICAnYm94LXNoYWRvdy14JzogcHgsXG4gICdib3gtc2hhZG93LXknOiBweCxcbiAgJ2JveC1zaGFkb3ctYmx1cic6IHB4LFxuICAnYm94LXNoYWRvdy1zcHJlYWQnOiBweCxcbiAgJ2ZvbnQtbGluZS1oZWlnaHQnOiBweCxcbiAgJ3RleHQtc2hhZG93LXgnOiBweCxcbiAgJ3RleHQtc2hhZG93LXknOiBweCxcbiAgJ3RleHQtc2hhZG93LWJsdXInOiBweFxufTtcblxuLyoqXG4gKiBDbG9uZXMgdGhlIG9iamVjdCBhbmQgYWRkcyBhIGNhbWVsIGNhc2VkIHByb3BlcnR5IHZlcnNpb24uXG4gKi9cbmZ1bmN0aW9uIGFkZENhbWVsQ2FzZWRWZXJzaW9uKG9iaikge1xuICB2YXIgcmVnRXhwID0gLygtW2Etel0pL2c7XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHN0cikge1xuICAgIHJldHVybiBzdHJbMV0udG9VcHBlckNhc2UoKTtcbiAgfTtcblxuICB2YXIgbmV3T2JqID0ge307XG5cbiAgZm9yICh2YXIgX2tleSBpbiBvYmopIHtcbiAgICBuZXdPYmpbX2tleV0gPSBvYmpbX2tleV07XG4gICAgbmV3T2JqW19rZXkucmVwbGFjZShyZWdFeHAsIHJlcGxhY2UpXSA9IG9ialtfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBuZXdPYmo7XG59XG5cbnZhciB1bml0cyA9IGFkZENhbWVsQ2FzZWRWZXJzaW9uKGRlZmF1bHRVbml0cyk7XG4vKipcbiAqIFJlY3Vyc2l2ZSBkZWVwIHN0eWxlIHBhc3NpbmcgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBpdGVyYXRlKHByb3AsIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICghdmFsdWUpIHJldHVybiB2YWx1ZTtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZVtpXSA9IGl0ZXJhdGUocHJvcCwgdmFsdWVbaV0sIG9wdGlvbnMpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHByb3AgPT09ICdmYWxsYmFja3MnKSB7XG4gICAgICBmb3IgKHZhciBpbm5lclByb3AgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFsdWVbaW5uZXJQcm9wXSA9IGl0ZXJhdGUoaW5uZXJQcm9wLCB2YWx1ZVtpbm5lclByb3BdLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgX2lubmVyUHJvcCBpbiB2YWx1ZSkge1xuICAgICAgICB2YWx1ZVtfaW5uZXJQcm9wXSA9IGl0ZXJhdGUocHJvcCArIFwiLVwiICsgX2lubmVyUHJvcCwgdmFsdWVbX2lubmVyUHJvcF0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdmFyIHVuaXQgPSBvcHRpb25zW3Byb3BdIHx8IHVuaXRzW3Byb3BdO1xuXG4gICAgaWYgKHVuaXQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdW5pdCA9PT0gJ2Z1bmN0aW9uJyA/IHVuaXQodmFsdWUpLnRvU3RyaW5nKCkgOiBcIlwiICsgdmFsdWUgKyB1bml0O1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBBZGQgdW5pdCB0byBudW1lcmljIHZhbHVlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlZmF1bHRVbml0KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBjYW1lbENhc2VkT3B0aW9ucyA9IGFkZENhbWVsQ2FzZWRWZXJzaW9uKG9wdGlvbnMpO1xuXG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlKSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJykgcmV0dXJuIHN0eWxlO1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgc3R5bGVbcHJvcF0gPSBpdGVyYXRlKHByb3AsIHN0eWxlW3Byb3BdLCBjYW1lbENhc2VkT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWx1ZSwgcHJvcCkge1xuICAgIHJldHVybiBpdGVyYXRlKHByb3AsIHZhbHVlLCBjYW1lbENhc2VkT3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9uUHJvY2Vzc1N0eWxlOiBvblByb2Nlc3NTdHlsZSxcbiAgICBvbkNoYW5nZVZhbHVlOiBvbkNoYW5nZVZhbHVlXG4gIH07XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZmF1bHRVbml0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIF9leHRlbmRzID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcycpKTtcbnZhciBqc3MgPSByZXF1aXJlKCdqc3MnKTtcblxudmFyIGF0ID0gJ0BnbG9iYWwnO1xudmFyIGF0UHJlZml4ID0gJ0BnbG9iYWwgJztcblxudmFyIEdsb2JhbENvbnRhaW5lclJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHbG9iYWxDb250YWluZXJSdWxlKGtleSwgc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ2dsb2JhbCc7XG4gICAgdGhpcy5hdCA9IGF0O1xuICAgIHRoaXMucnVsZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucnVsZXMgPSBuZXcganNzLlJ1bGVMaXN0KF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBwYXJlbnQ6IHRoaXNcbiAgICB9KSk7XG5cbiAgICBmb3IgKHZhciBzZWxlY3RvciBpbiBzdHlsZXMpIHtcbiAgICAgIHRoaXMucnVsZXMuYWRkKHNlbGVjdG9yLCBzdHlsZXNbc2VsZWN0b3JdKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnByb2Nlc3MoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgcnVsZS5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gR2xvYmFsQ29udGFpbmVyUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFJ1bGUgPSBmdW5jdGlvbiBnZXRSdWxlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5nZXQobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgcmVnaXN0ZXIgcnVsZSwgcnVuIHBsdWdpbnMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFkZFJ1bGUgPSBmdW5jdGlvbiBhZGRSdWxlKG5hbWUsIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdmFyIHJ1bGUgPSB0aGlzLnJ1bGVzLmFkZChuYW1lLCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5pbmRleE9mKHJ1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgcmV0dXJuIEdsb2JhbENvbnRhaW5lclJ1bGU7XG59KCk7XG5cbnZhciBHbG9iYWxQcmVmaXhlZFJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHbG9iYWxQcmVmaXhlZFJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdnbG9iYWwnO1xuICAgIHRoaXMuYXQgPSBhdDtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5ydWxlID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHZhciBzZWxlY3RvciA9IGtleS5zdWJzdHIoYXRQcmVmaXgubGVuZ3RoKTtcbiAgICB0aGlzLnJ1bGUgPSBvcHRpb25zLmpzcy5jcmVhdGVSdWxlKHNlbGVjdG9yLCBzdHlsZSwgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHBhcmVudDogdGhpc1xuICAgIH0pKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gR2xvYmFsUHJlZml4ZWRSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8yLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnJ1bGUgPyB0aGlzLnJ1bGUudG9TdHJpbmcob3B0aW9ucykgOiAnJztcbiAgfTtcblxuICByZXR1cm4gR2xvYmFsUHJlZml4ZWRSdWxlO1xufSgpO1xuXG52YXIgc2VwYXJhdG9yUmVnRXhwID0gL1xccyosXFxzKi9nO1xuXG5mdW5jdGlvbiBhZGRTY29wZShzZWxlY3Rvciwgc2NvcGUpIHtcbiAgdmFyIHBhcnRzID0gc2VsZWN0b3Iuc3BsaXQoc2VwYXJhdG9yUmVnRXhwKTtcbiAgdmFyIHNjb3BlZCA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBzY29wZWQgKz0gc2NvcGUgKyBcIiBcIiArIHBhcnRzW2ldLnRyaW0oKTtcbiAgICBpZiAocGFydHNbaSArIDFdKSBzY29wZWQgKz0gJywgJztcbiAgfVxuXG4gIHJldHVybiBzY29wZWQ7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU5lc3RlZEdsb2JhbENvbnRhaW5lclJ1bGUocnVsZSkge1xuICB2YXIgb3B0aW9ucyA9IHJ1bGUub3B0aW9ucyxcbiAgICAgIHN0eWxlID0gcnVsZS5zdHlsZTtcbiAgdmFyIHJ1bGVzID0gc3R5bGUgPyBzdHlsZVthdF0gOiBudWxsO1xuICBpZiAoIXJ1bGVzKSByZXR1cm47XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBydWxlcykge1xuICAgIG9wdGlvbnMuc2hlZXQuYWRkUnVsZShuYW1lLCBydWxlc1tuYW1lXSwgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHNlbGVjdG9yOiBhZGRTY29wZShuYW1lLCBydWxlLnNlbGVjdG9yKVxuICAgIH0pKTtcbiAgfVxuXG4gIGRlbGV0ZSBzdHlsZVthdF07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVByZWZpeGVkR2xvYmFsUnVsZShydWxlKSB7XG4gIHZhciBvcHRpb25zID0gcnVsZS5vcHRpb25zLFxuICAgICAgc3R5bGUgPSBydWxlLnN0eWxlO1xuXG4gIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICBpZiAocHJvcFswXSAhPT0gJ0AnIHx8IHByb3Auc3Vic3RyKDAsIGF0Lmxlbmd0aCkgIT09IGF0KSBjb250aW51ZTtcbiAgICB2YXIgc2VsZWN0b3IgPSBhZGRTY29wZShwcm9wLnN1YnN0cihhdC5sZW5ndGgpLCBydWxlLnNlbGVjdG9yKTtcbiAgICBvcHRpb25zLnNoZWV0LmFkZFJ1bGUoc2VsZWN0b3IsIHN0eWxlW3Byb3BdLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yXG4gICAgfSkpO1xuICAgIGRlbGV0ZSBzdHlsZVtwcm9wXTtcbiAgfVxufVxuLyoqXG4gKiBDb252ZXJ0IG5lc3RlZCBydWxlcyB0byBzZXBhcmF0ZSwgcmVtb3ZlIHRoZW0gZnJvbSBvcmlnaW5hbCBzdHlsZXMuXG4gKlxuICogQHBhcmFtIHtSdWxlfSBydWxlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24ganNzR2xvYmFsKCkge1xuICBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUobmFtZSwgc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgaWYgKCFuYW1lKSByZXR1cm4gbnVsbDtcblxuICAgIGlmIChuYW1lID09PSBhdCkge1xuICAgICAgcmV0dXJuIG5ldyBHbG9iYWxDb250YWluZXJSdWxlKG5hbWUsIHN0eWxlcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWVbMF0gPT09ICdAJyAmJiBuYW1lLnN1YnN0cigwLCBhdFByZWZpeC5sZW5ndGgpID09PSBhdFByZWZpeCkge1xuICAgICAgcmV0dXJuIG5ldyBHbG9iYWxQcmVmaXhlZFJ1bGUobmFtZSwgc3R5bGVzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LnR5cGUgPT09ICdnbG9iYWwnIHx8IHBhcmVudC5vcHRpb25zLnBhcmVudCAmJiBwYXJlbnQub3B0aW9ucy5wYXJlbnQudHlwZSA9PT0gJ2dsb2JhbCcpIHtcbiAgICAgICAgb3B0aW9ucy5zY29wZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zY29wZWQgPT09IGZhbHNlKSB7XG4gICAgICBvcHRpb25zLnNlbGVjdG9yID0gbmFtZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1J1bGUocnVsZSkge1xuICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScpIHJldHVybjtcbiAgICBoYW5kbGVOZXN0ZWRHbG9iYWxDb250YWluZXJSdWxlKHJ1bGUpO1xuICAgIGhhbmRsZVByZWZpeGVkR2xvYmFsUnVsZShydWxlKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb25DcmVhdGVSdWxlOiBvbkNyZWF0ZVJ1bGUsXG4gICAgb25Qcm9jZXNzUnVsZTogb25Qcm9jZXNzUnVsZVxuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBqc3NHbG9iYWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgX2V4dGVuZHMgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzJykpO1xudmFyIHdhcm5pbmcgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgndGlueS13YXJuaW5nJykpO1xuXG52YXIgc2VwYXJhdG9yUmVnRXhwID0gL1xccyosXFxzKi9nO1xudmFyIHBhcmVudFJlZ0V4cCA9IC8mL2c7XG52YXIgcmVmUmVnRXhwID0gL1xcJChbXFx3LV0rKS9nO1xuLyoqXG4gKiBDb252ZXJ0IG5lc3RlZCBydWxlcyB0byBzZXBhcmF0ZSwgcmVtb3ZlIHRoZW0gZnJvbSBvcmlnaW5hbCBzdHlsZXMuXG4gKlxuICogQHBhcmFtIHtSdWxlfSBydWxlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGpzc05lc3RlZCgpIHtcbiAgLy8gR2V0IGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgJHJlZiByZXBsYWNlbWVudC5cbiAgZnVuY3Rpb24gZ2V0UmVwbGFjZVJlZihjb250YWluZXIsIHNoZWV0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtYXRjaCwga2V5KSB7XG4gICAgICB2YXIgcnVsZSA9IGNvbnRhaW5lci5nZXRSdWxlKGtleSkgfHwgc2hlZXQgJiYgc2hlZXQuZ2V0UnVsZShrZXkpO1xuXG4gICAgICBpZiAocnVsZSkge1xuICAgICAgICBydWxlID0gcnVsZTtcbiAgICAgICAgcmV0dXJuIHJ1bGUuc2VsZWN0b3I7XG4gICAgICB9XG5cbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIENvdWxkIG5vdCBmaW5kIHRoZSByZWZlcmVuY2VkIHJ1bGUgXFxcIlwiICsga2V5ICsgXCJcXFwiIGluIFxcXCJcIiArIChjb250YWluZXIub3B0aW9ucy5tZXRhIHx8IGNvbnRhaW5lci50b1N0cmluZygpKSArIFwiXFxcIi5cIikgOiB2b2lkIDA7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlUGFyZW50UmVmcyhuZXN0ZWRQcm9wLCBwYXJlbnRQcm9wKSB7XG4gICAgdmFyIHBhcmVudFNlbGVjdG9ycyA9IHBhcmVudFByb3Auc3BsaXQoc2VwYXJhdG9yUmVnRXhwKTtcbiAgICB2YXIgbmVzdGVkU2VsZWN0b3JzID0gbmVzdGVkUHJvcC5zcGxpdChzZXBhcmF0b3JSZWdFeHApO1xuICAgIHZhciByZXN1bHQgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50U2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGFyZW50ID0gcGFyZW50U2VsZWN0b3JzW2ldO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5lc3RlZFNlbGVjdG9ycy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbmVzdGVkID0gbmVzdGVkU2VsZWN0b3JzW2pdO1xuICAgICAgICBpZiAocmVzdWx0KSByZXN1bHQgKz0gJywgJzsgLy8gUmVwbGFjZSBhbGwgJiBieSB0aGUgcGFyZW50IG9yIHByZWZpeCAmIHdpdGggdGhlIHBhcmVudC5cblxuICAgICAgICByZXN1bHQgKz0gbmVzdGVkLmluZGV4T2YoJyYnKSAhPT0gLTEgPyBuZXN0ZWQucmVwbGFjZShwYXJlbnRSZWdFeHAsIHBhcmVudCkgOiBwYXJlbnQgKyBcIiBcIiArIG5lc3RlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0T3B0aW9ucyhydWxlLCBjb250YWluZXIsIHByZXZPcHRpb25zKSB7XG4gICAgLy8gT3B0aW9ucyBoYXMgYmVlbiBhbHJlYWR5IGNyZWF0ZWQsIG5vdyB3ZSBvbmx5IGluY3JlYXNlIGluZGV4LlxuICAgIGlmIChwcmV2T3B0aW9ucykgcmV0dXJuIF9leHRlbmRzKHt9LCBwcmV2T3B0aW9ucywge1xuICAgICAgaW5kZXg6IHByZXZPcHRpb25zLmluZGV4ICsgMVxuICAgIH0pO1xuICAgIHZhciBuZXN0aW5nTGV2ZWwgPSBydWxlLm9wdGlvbnMubmVzdGluZ0xldmVsO1xuICAgIG5lc3RpbmdMZXZlbCA9IG5lc3RpbmdMZXZlbCA9PT0gdW5kZWZpbmVkID8gMSA6IG5lc3RpbmdMZXZlbCArIDE7XG5cbiAgICB2YXIgb3B0aW9ucyA9IF9leHRlbmRzKHt9LCBydWxlLm9wdGlvbnMsIHtcbiAgICAgIG5lc3RpbmdMZXZlbDogbmVzdGluZ0xldmVsLFxuICAgICAgaW5kZXg6IGNvbnRhaW5lci5pbmRleE9mKHJ1bGUpICsgMSAvLyBXZSBkb24ndCBuZWVkIHRoZSBwYXJlbnQgbmFtZSB0byBiZSBzZXQgb3B0aW9ucyBmb3IgY2hsaWQuXG5cbiAgICB9KTtcblxuICAgIGRlbGV0ZSBvcHRpb25zLm5hbWU7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cblxuICBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSwgc2hlZXQpIHtcbiAgICBpZiAocnVsZS50eXBlICE9PSAnc3R5bGUnKSByZXR1cm4gc3R5bGU7XG4gICAgdmFyIHN0eWxlUnVsZSA9IHJ1bGU7XG4gICAgdmFyIGNvbnRhaW5lciA9IHN0eWxlUnVsZS5vcHRpb25zLnBhcmVudDtcbiAgICB2YXIgb3B0aW9ucztcbiAgICB2YXIgcmVwbGFjZVJlZjtcblxuICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHZhciBpc05lc3RlZCA9IHByb3AuaW5kZXhPZignJicpICE9PSAtMTtcbiAgICAgIHZhciBpc05lc3RlZENvbmRpdGlvbmFsID0gcHJvcFswXSA9PT0gJ0AnO1xuICAgICAgaWYgKCFpc05lc3RlZCAmJiAhaXNOZXN0ZWRDb25kaXRpb25hbCkgY29udGludWU7XG4gICAgICBvcHRpb25zID0gZ2V0T3B0aW9ucyhzdHlsZVJ1bGUsIGNvbnRhaW5lciwgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChpc05lc3RlZCkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSByZXBsYWNlUGFyZW50UmVmcyhwcm9wLCBzdHlsZVJ1bGUuc2VsZWN0b3IpOyAvLyBMYXppbHkgY3JlYXRlIHRoZSByZWYgcmVwbGFjZXIgZnVuY3Rpb24ganVzdCBvbmNlIGZvclxuICAgICAgICAvLyBhbGwgbmVzdGVkIHJ1bGVzIHdpdGhpbiB0aGUgc2hlZXQuXG5cbiAgICAgICAgaWYgKCFyZXBsYWNlUmVmKSByZXBsYWNlUmVmID0gZ2V0UmVwbGFjZVJlZihjb250YWluZXIsIHNoZWV0KTsgLy8gUmVwbGFjZSBhbGwgJHJlZnMuXG5cbiAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKHJlZlJlZ0V4cCwgcmVwbGFjZVJlZik7XG4gICAgICAgIGNvbnRhaW5lci5hZGRSdWxlKHNlbGVjdG9yLCBzdHlsZVtwcm9wXSwgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3JcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIGlmIChpc05lc3RlZENvbmRpdGlvbmFsKSB7XG4gICAgICAgIC8vIFBsYWNlIGNvbmRpdGlvbmFsIHJpZ2h0IGFmdGVyIHRoZSBwYXJlbnQgcnVsZSB0byBlbnN1cmUgcmlnaHQgb3JkZXJpbmcuXG4gICAgICAgIGNvbnRhaW5lci5hZGRSdWxlKHByb3AsIHt9LCBvcHRpb25zKSAvLyBGbG93IGV4cGVjdHMgbW9yZSBvcHRpb25zIGJ1dCB0aGV5IGFyZW4ndCByZXF1aXJlZFxuICAgICAgICAvLyBBbmQgZmxvdyBkb2Vzbid0IGtub3cgdGhpcyB3aWxsIGFsd2F5cyBiZSBhIFN0eWxlUnVsZSB3aGljaCBoYXMgdGhlIGFkZFJ1bGUgbWV0aG9kXG4gICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgLmFkZFJ1bGUoc3R5bGVSdWxlLmtleSwgc3R5bGVbcHJvcF0sIHtcbiAgICAgICAgICBzZWxlY3Rvcjogc3R5bGVSdWxlLnNlbGVjdG9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgc3R5bGVbcHJvcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGVcbiAgfTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0ganNzTmVzdGVkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vKipcbiAqIFNvcnQgcHJvcHMgYnkgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBqc3NQcm9wc1NvcnQoKSB7XG4gIHZhciBzb3J0ID0gZnVuY3Rpb24gc29ydChwcm9wMCwgcHJvcDEpIHtcbiAgICBpZiAocHJvcDAubGVuZ3RoID09PSBwcm9wMS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBwcm9wMCA+IHByb3AxID8gMSA6IC0xO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wMC5sZW5ndGggLSBwcm9wMS5sZW5ndGg7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBvblByb2Nlc3NTdHlsZTogZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUpIHtcbiAgICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScpIHJldHVybiBzdHlsZTtcbiAgICAgIHZhciBuZXdTdHlsZSA9IHt9O1xuICAgICAgdmFyIHByb3BzID0gT2JqZWN0LmtleXMoc3R5bGUpLnNvcnQoc29ydCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3U3R5bGVbcHJvcHNbaV1dID0gc3R5bGVbcHJvcHNbaV1dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3U3R5bGU7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBqc3NQcm9wc1NvcnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgd2FybmluZyA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCd0aW55LXdhcm5pbmcnKSk7XG52YXIganNzID0gcmVxdWlyZSgnanNzJyk7XG5cbnZhciBub3cgPSBEYXRlLm5vdygpO1xudmFyIGZuVmFsdWVzTnMgPSBcImZuVmFsdWVzXCIgKyBub3c7XG52YXIgZm5SdWxlTnMgPSBcImZuU3R5bGVcIiArICsrbm93O1xuZnVuY3Rpb24gZnVuY3Rpb25QbHVnaW4oKSB7XG4gIHJldHVybiB7XG4gICAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBkZWNsICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBydWxlID0ganNzLmNyZWF0ZVJ1bGUobmFtZSwge30sIG9wdGlvbnMpO1xuICAgICAgcnVsZVtmblJ1bGVOc10gPSBkZWNsO1xuICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgfSxcbiAgICBvblByb2Nlc3NTdHlsZTogZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gZXh0cmFjdCBmdW5jdGlvbiB2YWx1ZXMgZnJvbSB0aGUgZGVjbGFyYXRpb24sIHNvIHRoYXQgd2UgY2FuIGtlZXAgY29yZSB1bmF3YXJlIG9mIHRoZW0uXG4gICAgICAvLyBXZSBuZWVkIHRvIGRvIHRoYXQgb25seSBvbmNlLlxuICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBleHRyYWN0IGZ1bmN0aW9ucyBvbiBlYWNoIHN0eWxlIHVwZGF0ZSwgc2luY2UgdGhpcyBjYW4gaGFwcGVuIG9ubHkgb25jZS5cbiAgICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgZnVuY3Rpb24gdmFsdWVzIGluc2lkZSBvZiBmdW5jdGlvbiBydWxlcy5cbiAgICAgIGlmIChmblZhbHVlc05zIGluIHJ1bGUgfHwgZm5SdWxlTnMgaW4gcnVsZSkgcmV0dXJuIHN0eWxlO1xuICAgICAgdmFyIGZuVmFsdWVzID0ge307XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVbcHJvcF07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIGNvbnRpbnVlO1xuICAgICAgICBkZWxldGUgc3R5bGVbcHJvcF07XG4gICAgICAgIGZuVmFsdWVzW3Byb3BdID0gdmFsdWU7XG4gICAgICB9IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBydWxlW2ZuVmFsdWVzTnNdID0gZm5WYWx1ZXM7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSxcbiAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoZGF0YSwgcnVsZSwgc2hlZXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzdHlsZVJ1bGUgPSBydWxlO1xuICAgICAgdmFyIGZuUnVsZSA9IHN0eWxlUnVsZVtmblJ1bGVOc107IC8vIElmIHdlIGhhdmUgYSBzdHlsZSBmdW5jdGlvbiwgdGhlIGVudGlyZSBydWxlIGlzIGR5bmFtaWMgYW5kIHN0eWxlIG9iamVjdFxuICAgICAgLy8gd2lsbCBiZSByZXR1cm5lZCBmcm9tIHRoYXQgZnVuY3Rpb24uXG5cbiAgICAgIGlmIChmblJ1bGUpIHtcbiAgICAgICAgLy8gRW1wdHkgb2JqZWN0IHdpbGwgcmVtb3ZlIGFsbCBjdXJyZW50bHkgZGVmaW5lZCBwcm9wc1xuICAgICAgICAvLyBpbiBjYXNlIGZ1bmN0aW9uIHJ1bGUgcmV0dXJucyBhIGZhbHN5IHZhbHVlLlxuICAgICAgICBzdHlsZVJ1bGUuc3R5bGUgPSBmblJ1bGUoZGF0YSkgfHwge307XG5cbiAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGVSdWxlLnN0eWxlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlUnVsZS5zdHlsZVtwcm9wXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgJ1tKU1NdIEZ1bmN0aW9uIHZhbHVlcyBpbnNpZGUgZnVuY3Rpb24gcnVsZXMgYXJlIG5vdCBzdXBwb3J0ZWQuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZm5WYWx1ZXMgPSBzdHlsZVJ1bGVbZm5WYWx1ZXNOc107IC8vIElmIHdlIGhhdmUgYSBmbiB2YWx1ZXMgbWFwLCBpdCBpcyBhIHJ1bGUgd2l0aCBmdW5jdGlvbiB2YWx1ZXMuXG5cbiAgICAgIGlmIChmblZhbHVlcykge1xuICAgICAgICBmb3IgKHZhciBfcHJvcCBpbiBmblZhbHVlcykge1xuICAgICAgICAgIHN0eWxlUnVsZS5wcm9wKF9wcm9wLCBmblZhbHVlc1tfcHJvcF0oZGF0YSksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvblBsdWdpbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHZlbmRvciA9IHJlcXVpcmUoJ2Nzcy12ZW5kb3InKTtcbnZhciBqc3MgPSByZXF1aXJlKCdqc3MnKTtcblxuLyoqXG4gKiBBZGQgdmVuZG9yIHByZWZpeCB0byBhIHByb3BlcnR5IG5hbWUgd2hlbiBuZWVkZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBqc3NWZW5kb3JQcmVmaXhlcigpIHtcbiAgZnVuY3Rpb24gb25Qcm9jZXNzUnVsZShydWxlKSB7XG4gICAgaWYgKHJ1bGUudHlwZSA9PT0gJ2tleWZyYW1lcycpIHtcbiAgICAgIHZhciBhdFJ1bGUgPSBydWxlO1xuICAgICAgYXRSdWxlLmF0ID0gdmVuZG9yLnN1cHBvcnRlZEtleWZyYW1lcyhhdFJ1bGUuYXQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZWZpeFN0eWxlKHN0eWxlKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgdmFyIHZhbHVlID0gc3R5bGVbcHJvcF07XG5cbiAgICAgIGlmIChwcm9wID09PSAnZmFsbGJhY2tzJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBzdHlsZVtwcm9wXSA9IHZhbHVlLm1hcChwcmVmaXhTdHlsZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hhbmdlUHJvcCA9IGZhbHNlO1xuICAgICAgdmFyIHN1cHBvcnRlZFByb3AgPSB2ZW5kb3Iuc3VwcG9ydGVkUHJvcGVydHkocHJvcCk7XG4gICAgICBpZiAoc3VwcG9ydGVkUHJvcCAmJiBzdXBwb3J0ZWRQcm9wICE9PSBwcm9wKSBjaGFuZ2VQcm9wID0gdHJ1ZTtcbiAgICAgIHZhciBjaGFuZ2VWYWx1ZSA9IGZhbHNlO1xuICAgICAgdmFyIHN1cHBvcnRlZFZhbHVlID0gdmVuZG9yLnN1cHBvcnRlZFZhbHVlKHN1cHBvcnRlZFByb3AsIGpzcy50b0Nzc1ZhbHVlKHZhbHVlKSk7XG4gICAgICBpZiAoc3VwcG9ydGVkVmFsdWUgJiYgc3VwcG9ydGVkVmFsdWUgIT09IHZhbHVlKSBjaGFuZ2VWYWx1ZSA9IHRydWU7XG5cbiAgICAgIGlmIChjaGFuZ2VQcm9wIHx8IGNoYW5nZVZhbHVlKSB7XG4gICAgICAgIGlmIChjaGFuZ2VQcm9wKSBkZWxldGUgc3R5bGVbcHJvcF07XG4gICAgICAgIHN0eWxlW3N1cHBvcnRlZFByb3AgfHwgcHJvcF0gPSBzdXBwb3J0ZWRWYWx1ZSB8fCB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSkge1xuICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScpIHJldHVybiBzdHlsZTtcbiAgICByZXR1cm4gcHJlZml4U3R5bGUoc3R5bGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWx1ZSwgcHJvcCkge1xuICAgIHJldHVybiB2ZW5kb3Iuc3VwcG9ydGVkVmFsdWUocHJvcCwganNzLnRvQ3NzVmFsdWUodmFsdWUpKSB8fCB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb25Qcm9jZXNzUnVsZTogb25Qcm9jZXNzUnVsZSxcbiAgICBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGUsXG4gICAgb25DaGFuZ2VWYWx1ZTogb25DaGFuZ2VWYWx1ZVxuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBqc3NWZW5kb3JQcmVmaXhlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciBfZXh0ZW5kcyA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHMnKSk7XG52YXIgaXNJbkJyb3dzZXIgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnaXMtaW4tYnJvd3NlcicpKTtcbnZhciB3YXJuaW5nID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3Rpbnktd2FybmluZycpKTtcbnZhciBfY3JlYXRlQ2xhc3MgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpKTtcbnZhciBfaW5oZXJpdHNMb29zZSA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzTG9vc2UnKSk7XG52YXIgX2Fzc2VydFRoaXNJbml0aWFsaXplZCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZCcpKTtcbnZhciBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UnKSk7XG5cbnZhciBwbGFpbk9iamVjdENvbnN0cnVyY3RvciA9IHt9LmNvbnN0cnVjdG9yO1xuZnVuY3Rpb24gY2xvbmVTdHlsZShzdHlsZSkge1xuICBpZiAoc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2Ygc3R5bGUgIT09ICdvYmplY3QnKSByZXR1cm4gc3R5bGU7XG4gIGlmIChBcnJheS5pc0FycmF5KHN0eWxlKSkgcmV0dXJuIHN0eWxlLm1hcChjbG9uZVN0eWxlKTtcbiAgaWYgKHN0eWxlLmNvbnN0cnVjdG9yICE9PSBwbGFpbk9iamVjdENvbnN0cnVyY3RvcikgcmV0dXJuIHN0eWxlO1xuICB2YXIgbmV3U3R5bGUgPSB7fTtcblxuICBmb3IgKHZhciBuYW1lIGluIHN0eWxlKSB7XG4gICAgbmV3U3R5bGVbbmFtZV0gPSBjbG9uZVN0eWxlKHN0eWxlW25hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBuZXdTdHlsZTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBydWxlIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgbmFtZSA9ICd1bm5hbWVkJztcbiAgfVxuXG4gIHZhciBqc3MgPSBvcHRpb25zLmpzcztcbiAgdmFyIGRlY2xDb3B5ID0gY2xvbmVTdHlsZShkZWNsKTtcbiAgdmFyIHJ1bGUgPSBqc3MucGx1Z2lucy5vbkNyZWF0ZVJ1bGUobmFtZSwgZGVjbENvcHksIG9wdGlvbnMpO1xuICBpZiAocnVsZSkgcmV0dXJuIHJ1bGU7IC8vIEl0IGlzIGFuIGF0LXJ1bGUgYW5kIGl0IGhhcyBubyBpbnN0YW5jZS5cblxuICBpZiAobmFtZVswXSA9PT0gJ0AnKSB7XG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gVW5rbm93biBydWxlIFwiICsgbmFtZSkgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGpvaW4gPSBmdW5jdGlvbiBqb2luKHZhbHVlLCBieSkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIC8vIFJlbW92ZSAhaW1wb3J0YW50IGZyb20gdGhlIHZhbHVlLCBpdCB3aWxsIGJlIHJlYWRkZWQgbGF0ZXIuXG4gICAgaWYgKHZhbHVlW2ldID09PSAnIWltcG9ydGFudCcpIGJyZWFrO1xuICAgIGlmIChyZXN1bHQpIHJlc3VsdCArPSBieTtcbiAgICByZXN1bHQgKz0gdmFsdWVbaV07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQ29udmVydHMgYXJyYXkgdmFsdWVzIHRvIHN0cmluZy5cbiAqXG4gKiBgbWFyZ2luOiBbWyc1cHgnLCAnMTBweCddXWAgPiBgbWFyZ2luOiA1cHggMTBweDtgXG4gKiBgYm9yZGVyOiBbJzFweCcsICcycHgnXWAgPiBgYm9yZGVyOiAxcHgsIDJweDtgXG4gKiBgbWFyZ2luOiBbWyc1cHgnLCAnMTBweCddLCAnIWltcG9ydGFudCddYCA+IGBtYXJnaW46IDVweCAxMHB4ICFpbXBvcnRhbnQ7YFxuICogYGNvbG9yOiBbJ3JlZCcsICFpbXBvcnRhbnRdYCA+IGBjb2xvcjogcmVkICFpbXBvcnRhbnQ7YFxuICovXG5cblxuZnVuY3Rpb24gdG9Dc3NWYWx1ZSh2YWx1ZSwgaWdub3JlSW1wb3J0YW50KSB7XG4gIGlmIChpZ25vcmVJbXBvcnRhbnQgPT09IHZvaWQgMCkge1xuICAgIGlnbm9yZUltcG9ydGFudCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICB2YXIgY3NzVmFsdWUgPSAnJzsgLy8gU3VwcG9ydCBzcGFjZSBzZXBhcmF0ZWQgdmFsdWVzIHZpYSBgW1snNXB4JywgJzEwcHgnXV1gLlxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlWzBdKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZVtpXSA9PT0gJyFpbXBvcnRhbnQnKSBicmVhaztcbiAgICAgIGlmIChjc3NWYWx1ZSkgY3NzVmFsdWUgKz0gJywgJztcbiAgICAgIGNzc1ZhbHVlICs9IGpvaW4odmFsdWVbaV0sICcgJyk7XG4gICAgfVxuICB9IGVsc2UgY3NzVmFsdWUgPSBqb2luKHZhbHVlLCAnLCAnKTsgLy8gQWRkICFpbXBvcnRhbnQsIGJlY2F1c2UgaXQgd2FzIGlnbm9yZWQuXG5cblxuICBpZiAoIWlnbm9yZUltcG9ydGFudCAmJiB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJyFpbXBvcnRhbnQnKSB7XG4gICAgY3NzVmFsdWUgKz0gJyAhaW1wb3J0YW50JztcbiAgfVxuXG4gIHJldHVybiBjc3NWYWx1ZTtcbn1cblxuLyoqXG4gKiBJbmRlbnQgYSBzdHJpbmcuXG4gKiBodHRwOi8vanNwZXJmLmNvbS9hcnJheS1qb2luLXZzLWZvclxuICovXG5mdW5jdGlvbiBpbmRlbnRTdHIoc3RyLCBpbmRlbnQpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBpbmRlbnQ7IGluZGV4KyspIHtcbiAgICByZXN1bHQgKz0gJyAgJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQgKyBzdHI7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgUnVsZSB0byBDU1Mgc3RyaW5nLlxuICovXG5cblxuZnVuY3Rpb24gdG9Dc3Moc2VsZWN0b3IsIHN0eWxlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICghc3R5bGUpIHJldHVybiByZXN1bHQ7XG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRpbmRlbnQgPSBfb3B0aW9ucy5pbmRlbnQsXG4gICAgICBpbmRlbnQgPSBfb3B0aW9ucyRpbmRlbnQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRpbmRlbnQ7XG4gIHZhciBmYWxsYmFja3MgPSBzdHlsZS5mYWxsYmFja3M7XG4gIGlmIChzZWxlY3RvcikgaW5kZW50Kys7IC8vIEFwcGx5IGZhbGxiYWNrcyBmaXJzdC5cblxuICBpZiAoZmFsbGJhY2tzKSB7XG4gICAgLy8gQXJyYXkgc3ludGF4IHtmYWxsYmFja3M6IFt7cHJvcDogdmFsdWV9XX1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShmYWxsYmFja3MpKSB7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZmFsbGJhY2tzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgZmFsbGJhY2sgPSBmYWxsYmFja3NbaW5kZXhdO1xuXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gZmFsbGJhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBmYWxsYmFja1twcm9wXTtcblxuICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcIiArIGluZGVudFN0cihwcm9wICsgXCI6IFwiICsgdG9Dc3NWYWx1ZSh2YWx1ZSkgKyBcIjtcIiwgaW5kZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT2JqZWN0IHN5bnRheCB7ZmFsbGJhY2tzOiB7cHJvcDogdmFsdWV9fVxuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gZmFsbGJhY2tzKSB7XG4gICAgICAgIHZhciBfdmFsdWUgPSBmYWxsYmFja3NbX3Byb3BdO1xuXG4gICAgICAgIGlmIChfdmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZXN1bHQpIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICByZXN1bHQgKz0gXCJcIiArIGluZGVudFN0cihfcHJvcCArIFwiOiBcIiArIHRvQ3NzVmFsdWUoX3ZhbHVlKSArIFwiO1wiLCBpbmRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX3Byb3AyIGluIHN0eWxlKSB7XG4gICAgdmFyIF92YWx1ZTIgPSBzdHlsZVtfcHJvcDJdO1xuXG4gICAgaWYgKF92YWx1ZTIgIT0gbnVsbCAmJiBfcHJvcDIgIT09ICdmYWxsYmFja3MnKSB7XG4gICAgICBpZiAocmVzdWx0KSByZXN1bHQgKz0gJ1xcbic7XG4gICAgICByZXN1bHQgKz0gXCJcIiArIGluZGVudFN0cihfcHJvcDIgKyBcIjogXCIgKyB0b0Nzc1ZhbHVlKF92YWx1ZTIpICsgXCI7XCIsIGluZGVudCk7XG4gICAgfVxuICB9IC8vIEFsbG93IGVtcHR5IHN0eWxlIGluIHRoaXMgY2FzZSwgYmVjYXVzZSBwcm9wZXJ0aWVzIHdpbGwgYmUgYWRkZWQgZHluYW1pY2FsbHkuXG5cblxuICBpZiAoIXJlc3VsdCAmJiAhb3B0aW9ucy5hbGxvd0VtcHR5KSByZXR1cm4gcmVzdWx0OyAvLyBXaGVuIHJ1bGUgaXMgYmVpbmcgc3RyaW5naWZpZWQgYmVmb3JlIHNlbGVjdG9yIHdhcyBkZWZpbmVkLlxuXG4gIGlmICghc2VsZWN0b3IpIHJldHVybiByZXN1bHQ7XG4gIGluZGVudC0tO1xuICBpZiAocmVzdWx0KSByZXN1bHQgPSBcIlxcblwiICsgcmVzdWx0ICsgXCJcXG5cIjtcbiAgcmV0dXJuIGluZGVudFN0cihzZWxlY3RvciArIFwiIHtcIiArIHJlc3VsdCwgaW5kZW50KSArIGluZGVudFN0cignfScsIGluZGVudCk7XG59XG5cbnZhciBlc2NhcGVSZWdleCA9IC8oW1tcXF0uIyokPjwrfj18XjooKSxcIidgXFxzXSkvZztcbnZhciBuYXRpdmVFc2NhcGUgPSB0eXBlb2YgQ1NTICE9PSAndW5kZWZpbmVkJyAmJiBDU1MuZXNjYXBlO1xudmFyIGVzY2FwZSA9IChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBuYXRpdmVFc2NhcGUgPyBuYXRpdmVFc2NhcGUoc3RyKSA6IHN0ci5yZXBsYWNlKGVzY2FwZVJlZ2V4LCAnXFxcXCQxJyk7XG59KTtcblxudmFyIEJhc2VTdHlsZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXNlU3R5bGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAnc3R5bGUnO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0eWxlID0gdm9pZCAwO1xuICAgIHRoaXMucmVuZGVyZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5yZW5kZXJhYmxlID0gdm9pZCAwO1xuICAgIHRoaXMub3B0aW9ucyA9IHZvaWQgMDtcbiAgICB2YXIgc2hlZXQgPSBvcHRpb25zLnNoZWV0LFxuICAgICAgICBSZW5kZXJlciA9IG9wdGlvbnMuUmVuZGVyZXI7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgaWYgKHNoZWV0KSB0aGlzLnJlbmRlcmVyID0gc2hlZXQucmVuZGVyZXI7ZWxzZSBpZiAoUmVuZGVyZXIpIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IG9yIHNldCBhIHN0eWxlIHByb3BlcnR5LlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBCYXNlU3R5bGVSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucHJvcCA9IGZ1bmN0aW9uIHByb3AobmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAvLyBJdCdzIGEgZ2V0dGVyLlxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5zdHlsZVtuYW1lXTsgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhlIHZhbHVlIGhhcyBub3QgY2hhbmdlZC5cblxuICAgIHZhciBmb3JjZSA9IG9wdGlvbnMgPyBvcHRpb25zLmZvcmNlIDogZmFsc2U7XG4gICAgaWYgKCFmb3JjZSAmJiB0aGlzLnN0eWxlW25hbWVdID09PSB2YWx1ZSkgcmV0dXJuIHRoaXM7XG4gICAgdmFyIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5wcm9jZXNzICE9PSBmYWxzZSkge1xuICAgICAgbmV3VmFsdWUgPSB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnMub25DaGFuZ2VWYWx1ZSh2YWx1ZSwgbmFtZSwgdGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIGlzRW1wdHkgPSBuZXdWYWx1ZSA9PSBudWxsIHx8IG5ld1ZhbHVlID09PSBmYWxzZTtcbiAgICB2YXIgaXNEZWZpbmVkID0gbmFtZSBpbiB0aGlzLnN0eWxlOyAvLyBWYWx1ZSBpcyBlbXB0eSBhbmQgd2Fzbid0IGRlZmluZWQgYmVmb3JlLlxuXG4gICAgaWYgKGlzRW1wdHkgJiYgIWlzRGVmaW5lZCAmJiAhZm9yY2UpIHJldHVybiB0aGlzOyAvLyBXZSBhcmUgZ29pbmcgdG8gcmVtb3ZlIHRoaXMgdmFsdWUuXG5cbiAgICB2YXIgcmVtb3ZlID0gaXNFbXB0eSAmJiBpc0RlZmluZWQ7XG4gICAgaWYgKHJlbW92ZSkgZGVsZXRlIHRoaXMuc3R5bGVbbmFtZV07ZWxzZSB0aGlzLnN0eWxlW25hbWVdID0gbmV3VmFsdWU7IC8vIFJlbmRlcmFibGUgaXMgZGVmaW5lZCBpZiBTdHlsZVNoZWV0IG9wdGlvbiBgbGlua2AgaXMgdHJ1ZS5cblxuICAgIGlmICh0aGlzLnJlbmRlcmFibGUgJiYgdGhpcy5yZW5kZXJlcikge1xuICAgICAgaWYgKHJlbW92ZSkgdGhpcy5yZW5kZXJlci5yZW1vdmVQcm9wZXJ0eSh0aGlzLnJlbmRlcmFibGUsIG5hbWUpO2Vsc2UgdGhpcy5yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLnJlbmRlcmFibGUsIG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBzaGVldCA9IHRoaXMub3B0aW9ucy5zaGVldDtcblxuICAgIGlmIChzaGVldCAmJiBzaGVldC5hdHRhY2hlZCkge1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsICdbSlNTXSBSdWxlIGlzIG5vdCBsaW5rZWQuIE1pc3Npbmcgc2hlZXQgb3B0aW9uIFwibGluazogdHJ1ZVwiLicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBCYXNlU3R5bGVSdWxlO1xufSgpO1xudmFyIFN0eWxlUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhc2VTdHlsZVJ1bGUpIHtcbiAgX2luaGVyaXRzTG9vc2UoU3R5bGVSdWxlLCBfQmFzZVN0eWxlUnVsZSk7XG5cbiAgZnVuY3Rpb24gU3R5bGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9CYXNlU3R5bGVSdWxlLmNhbGwodGhpcywga2V5LCBzdHlsZSwgb3B0aW9ucykgfHwgdGhpcztcbiAgICBfdGhpcy5zZWxlY3RvclRleHQgPSB2b2lkIDA7XG4gICAgX3RoaXMuaWQgPSB2b2lkIDA7XG4gICAgX3RoaXMucmVuZGVyYWJsZSA9IHZvaWQgMDtcbiAgICB2YXIgc2VsZWN0b3IgPSBvcHRpb25zLnNlbGVjdG9yLFxuICAgICAgICBzY29wZWQgPSBvcHRpb25zLnNjb3BlZCxcbiAgICAgICAgc2hlZXQgPSBvcHRpb25zLnNoZWV0LFxuICAgICAgICBnZW5lcmF0ZUlkID0gb3B0aW9ucy5nZW5lcmF0ZUlkO1xuXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICBfdGhpcy5zZWxlY3RvclRleHQgPSBzZWxlY3RvcjtcbiAgICB9IGVsc2UgaWYgKHNjb3BlZCAhPT0gZmFsc2UpIHtcbiAgICAgIF90aGlzLmlkID0gZ2VuZXJhdGVJZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgc2hlZXQpO1xuICAgICAgX3RoaXMuc2VsZWN0b3JUZXh0ID0gXCIuXCIgKyBlc2NhcGUoX3RoaXMuaWQpO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0IHNlbGVjdG9yIHN0cmluZy5cbiAgICogQXR0ZW50aW9uOiB1c2UgdGhpcyB3aXRoIGNhdXRpb24uIE1vc3QgYnJvd3NlcnMgZGlkbid0IGltcGxlbWVudFxuICAgKiBzZWxlY3RvclRleHQgc2V0dGVyLCBzbyB0aGlzIG1heSByZXN1bHQgaW4gcmVyZW5kZXJpbmcgb2YgZW50aXJlIFN0eWxlIFNoZWV0LlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8yID0gU3R5bGVSdWxlLnByb3RvdHlwZTtcblxuICAvKipcbiAgICogQXBwbHkgcnVsZSB0byBhbiBlbGVtZW50IGlubGluZS5cbiAgICovXG4gIF9wcm90bzIuYXBwbHlUbyA9IGZ1bmN0aW9uIGFwcGx5VG8ocmVuZGVyYWJsZSkge1xuICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG5cbiAgICBpZiAocmVuZGVyZXIpIHtcbiAgICAgIHZhciBqc29uID0gdGhpcy50b0pTT04oKTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBqc29uKSB7XG4gICAgICAgIHJlbmRlcmVyLnNldFByb3BlcnR5KHJlbmRlcmFibGUsIHByb3AsIGpzb25bcHJvcF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHJ1bGUuXG4gICAqIEZhbGxiYWNrcyBhcmUgbm90IHN1cHBvcnRlZC5cbiAgICogVXNlZnVsIGZvciBpbmxpbmUgc3R5bGVzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzIudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHZhciBqc29uID0ge307XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc3R5bGVbcHJvcF07XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykganNvbltwcm9wXSA9IHZhbHVlO2Vsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSBqc29uW3Byb3BdID0gdG9Dc3NWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGpzb247XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvMi50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICB2YXIgc2hlZXQgPSB0aGlzLm9wdGlvbnMuc2hlZXQ7XG4gICAgdmFyIGxpbmsgPSBzaGVldCA/IHNoZWV0Lm9wdGlvbnMubGluayA6IGZhbHNlO1xuICAgIHZhciBvcHRzID0gbGluayA/IF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBhbGxvd0VtcHR5OiB0cnVlXG4gICAgfSkgOiBvcHRpb25zO1xuICAgIHJldHVybiB0b0Nzcyh0aGlzLnNlbGVjdG9yVGV4dCwgdGhpcy5zdHlsZSwgb3B0cyk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFN0eWxlUnVsZSwgW3tcbiAgICBrZXk6IFwic2VsZWN0b3JcIixcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChzZWxlY3Rvcikge1xuICAgICAgaWYgKHNlbGVjdG9yID09PSB0aGlzLnNlbGVjdG9yVGV4dCkgcmV0dXJuO1xuICAgICAgdGhpcy5zZWxlY3RvclRleHQgPSBzZWxlY3RvcjtcbiAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsXG4gICAgICAgICAgcmVuZGVyYWJsZSA9IHRoaXMucmVuZGVyYWJsZTtcbiAgICAgIGlmICghcmVuZGVyYWJsZSB8fCAhcmVuZGVyZXIpIHJldHVybjtcbiAgICAgIHZhciBoYXNDaGFuZ2VkID0gcmVuZGVyZXIuc2V0U2VsZWN0b3IocmVuZGVyYWJsZSwgc2VsZWN0b3IpOyAvLyBJZiBzZWxlY3RvciBzZXR0ZXIgaXMgbm90IGltcGxlbWVudGVkLCByZXJlbmRlciB0aGUgcnVsZS5cblxuICAgICAgaWYgKCFoYXNDaGFuZ2VkKSB7XG4gICAgICAgIHJlbmRlcmVyLnJlcGxhY2VSdWxlKHJlbmRlcmFibGUsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgc2VsZWN0b3Igc3RyaW5nLlxuICAgICAqL1xuICAgICxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdG9yVGV4dDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3R5bGVSdWxlO1xufShCYXNlU3R5bGVSdWxlKTtcbnZhciBwbHVnaW5TdHlsZVJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKG5hbWUsIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKG5hbWVbMF0gPT09ICdAJyB8fCBvcHRpb25zLnBhcmVudCAmJiBvcHRpb25zLnBhcmVudC50eXBlID09PSAna2V5ZnJhbWVzJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTdHlsZVJ1bGUobmFtZSwgc3R5bGUsIG9wdGlvbnMpO1xuICB9XG59O1xuXG52YXIgZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyA9IHtcbiAgaW5kZW50OiAxLFxuICBjaGlsZHJlbjogdHJ1ZVxufTtcbnZhciBhdFJlZ0V4cCA9IC9AKFtcXHctXSspLztcbi8qKlxuICogQ29uZGl0aW9uYWwgcnVsZSBmb3IgQG1lZGlhLCBAc3VwcG9ydHNcbiAqL1xuXG52YXIgQ29uZGl0aW9uYWxSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29uZGl0aW9uYWxSdWxlKGtleSwgc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ2NvbmRpdGlvbmFsJztcbiAgICB0aGlzLmF0ID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMucXVlcnkgPSB2b2lkIDA7XG4gICAgdGhpcy5ydWxlcyA9IHZvaWQgMDtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyYWJsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IGtleTsgLy8gS2V5IG1pZ2h0IGNvbnRhaW4gYSB1bmlxdWUgc3VmZml4IGluIGNhc2UgdGhlIGBuYW1lYCBwYXNzZWQgYnkgdXNlciB3YXMgZHVwbGljYXRlLlxuXG4gICAgdGhpcy5xdWVyeSA9IG9wdGlvbnMubmFtZTtcbiAgICB2YXIgYXRNYXRjaCA9IGtleS5tYXRjaChhdFJlZ0V4cCk7XG4gICAgdGhpcy5hdCA9IGF0TWF0Y2ggPyBhdE1hdGNoWzFdIDogJ3Vua25vd24nO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5ydWxlcyA9IG5ldyBSdWxlTGlzdChfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgcGFyZW50OiB0aGlzXG4gICAgfSkpO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIHRoaXMucnVsZXMuYWRkKG5hbWUsIHN0eWxlc1tuYW1lXSk7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcy5wcm9jZXNzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHJ1bGUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IENvbmRpdGlvbmFsUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFJ1bGUgPSBmdW5jdGlvbiBnZXRSdWxlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5nZXQobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5pbmRleE9mKHJ1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHJlZ2lzdGVyIHJ1bGUsIHJ1biBwbHVnaW5zLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5hZGRSdWxlID0gZnVuY3Rpb24gYWRkUnVsZShuYW1lLCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHZhciBydWxlID0gdGhpcy5ydWxlcy5hZGQobmFtZSwgc3R5bGUsIG9wdGlvbnMpO1xuICAgIGlmICghcnVsZSkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmluZGVudCA9PSBudWxsKSBvcHRpb25zLmluZGVudCA9IGRlZmF1bHRUb1N0cmluZ09wdGlvbnMuaW5kZW50O1xuICAgIGlmIChvcHRpb25zLmNoaWxkcmVuID09IG51bGwpIG9wdGlvbnMuY2hpbGRyZW4gPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zLmNoaWxkcmVuO1xuXG4gICAgaWYgKG9wdGlvbnMuY2hpbGRyZW4gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWVyeSArIFwiIHt9XCI7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5ydWxlcy50b1N0cmluZyhvcHRpb25zKTtcbiAgICByZXR1cm4gY2hpbGRyZW4gPyB0aGlzLnF1ZXJ5ICsgXCIge1xcblwiICsgY2hpbGRyZW4gKyBcIlxcbn1cIiA6ICcnO1xuICB9O1xuXG4gIHJldHVybiBDb25kaXRpb25hbFJ1bGU7XG59KCk7XG52YXIga2V5UmVnRXhwID0gL0BtZWRpYXxAc3VwcG9ydHNcXHMrLztcbnZhciBwbHVnaW5Db25kaXRpb25hbFJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGtleVJlZ0V4cC50ZXN0KGtleSkgPyBuZXcgQ29uZGl0aW9uYWxSdWxlKGtleSwgc3R5bGVzLCBvcHRpb25zKSA6IG51bGw7XG4gIH1cbn07XG5cbnZhciBkZWZhdWx0VG9TdHJpbmdPcHRpb25zJDEgPSB7XG4gIGluZGVudDogMSxcbiAgY2hpbGRyZW46IHRydWVcbn07XG52YXIgbmFtZVJlZ0V4cCA9IC9Aa2V5ZnJhbWVzXFxzKyhbXFx3LV0rKS87XG4vKipcbiAqIFJ1bGUgZm9yIEBrZXlmcmFtZXNcbiAqL1xuXG52YXIgS2V5ZnJhbWVzUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEtleWZyYW1lc1J1bGUoa2V5LCBmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAna2V5ZnJhbWVzJztcbiAgICB0aGlzLmF0ID0gJ0BrZXlmcmFtZXMnO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMubmFtZSA9IHZvaWQgMDtcbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMucnVsZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcmFibGUgPSB2b2lkIDA7XG4gICAgdmFyIG5hbWVNYXRjaCA9IGtleS5tYXRjaChuYW1lUmVnRXhwKTtcblxuICAgIGlmIChuYW1lTWF0Y2ggJiYgbmFtZU1hdGNoWzFdKSB7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lTWF0Y2hbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubmFtZSA9ICdub25hbWUnO1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gQmFkIGtleWZyYW1lcyBuYW1lIFwiICsga2V5KSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB0aGlzLmtleSA9IHRoaXMudHlwZSArIFwiLVwiICsgdGhpcy5uYW1lO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdmFyIHNjb3BlZCA9IG9wdGlvbnMuc2NvcGVkLFxuICAgICAgICBzaGVldCA9IG9wdGlvbnMuc2hlZXQsXG4gICAgICAgIGdlbmVyYXRlSWQgPSBvcHRpb25zLmdlbmVyYXRlSWQ7XG4gICAgdGhpcy5pZCA9IHNjb3BlZCA9PT0gZmFsc2UgPyB0aGlzLm5hbWUgOiBlc2NhcGUoZ2VuZXJhdGVJZCh0aGlzLCBzaGVldCkpO1xuICAgIHRoaXMucnVsZXMgPSBuZXcgUnVsZUxpc3QoX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHBhcmVudDogdGhpc1xuICAgIH0pKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gZnJhbWVzKSB7XG4gICAgICB0aGlzLnJ1bGVzLmFkZChuYW1lLCBmcmFtZXNbbmFtZV0sIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHBhcmVudDogdGhpc1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucHJvY2VzcygpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBLZXlmcmFtZXNSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRUb1N0cmluZ09wdGlvbnMkMTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbmRlbnQgPT0gbnVsbCkgb3B0aW9ucy5pbmRlbnQgPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zJDEuaW5kZW50O1xuICAgIGlmIChvcHRpb25zLmNoaWxkcmVuID09IG51bGwpIG9wdGlvbnMuY2hpbGRyZW4gPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zJDEuY2hpbGRyZW47XG5cbiAgICBpZiAob3B0aW9ucy5jaGlsZHJlbiA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0ICsgXCIgXCIgKyB0aGlzLmlkICsgXCIge31cIjtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnJ1bGVzLnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgIGlmIChjaGlsZHJlbikgY2hpbGRyZW4gPSBcIlxcblwiICsgY2hpbGRyZW4gKyBcIlxcblwiO1xuICAgIHJldHVybiB0aGlzLmF0ICsgXCIgXCIgKyB0aGlzLmlkICsgXCIge1wiICsgY2hpbGRyZW4gKyBcIn1cIjtcbiAgfTtcblxuICByZXR1cm4gS2V5ZnJhbWVzUnVsZTtcbn0oKTtcbnZhciBrZXlSZWdFeHAkMSA9IC9Aa2V5ZnJhbWVzXFxzKy87XG52YXIgcmVmUmVnRXhwID0gL1xcJChbXFx3LV0rKS9nO1xuXG52YXIgZmluZFJlZmVyZW5jZWRLZXlmcmFtZSA9IGZ1bmN0aW9uIGZpbmRSZWZlcmVuY2VkS2V5ZnJhbWUodmFsLCBrZXlmcmFtZXMpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbC5yZXBsYWNlKHJlZlJlZ0V4cCwgZnVuY3Rpb24gKG1hdGNoLCBuYW1lKSB7XG4gICAgICBpZiAobmFtZSBpbiBrZXlmcmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIGtleWZyYW1lc1tuYW1lXTtcbiAgICAgIH1cblxuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gUmVmZXJlbmNlZCBrZXlmcmFtZXMgcnVsZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkLlwiKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59O1xuLyoqXG4gKiBSZXBsYWNlIHRoZSByZWZlcmVuY2UgZm9yIGEgYW5pbWF0aW9uIG5hbWUuXG4gKi9cblxuXG52YXIgcmVwbGFjZVJlZiA9IGZ1bmN0aW9uIHJlcGxhY2VSZWYoc3R5bGUsIHByb3AsIGtleWZyYW1lcykge1xuICB2YXIgdmFsdWUgPSBzdHlsZVtwcm9wXTtcbiAgdmFyIHJlZktleWZyYW1lID0gZmluZFJlZmVyZW5jZWRLZXlmcmFtZSh2YWx1ZSwga2V5ZnJhbWVzKTtcblxuICBpZiAocmVmS2V5ZnJhbWUgIT09IHZhbHVlKSB7XG4gICAgc3R5bGVbcHJvcF0gPSByZWZLZXlmcmFtZTtcbiAgfVxufTtcblxudmFyIHBsdWdpbiA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5UmVnRXhwJDEudGVzdChrZXkpID8gbmV3IEtleWZyYW1lc1J1bGUoa2V5LCBmcmFtZXMsIG9wdGlvbnMpIDogbnVsbDtcbiAgfSxcbiAgLy8gQW5pbWF0aW9uIG5hbWUgcmVmIHJlcGxhY2VyLlxuICBvblByb2Nlc3NTdHlsZTogZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUsIHNoZWV0KSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJyB8fCAhc2hlZXQpIHJldHVybiBzdHlsZTtcbiAgICBpZiAoJ2FuaW1hdGlvbi1uYW1lJyBpbiBzdHlsZSkgcmVwbGFjZVJlZihzdHlsZSwgJ2FuaW1hdGlvbi1uYW1lJywgc2hlZXQua2V5ZnJhbWVzKTtcbiAgICBpZiAoJ2FuaW1hdGlvbicgaW4gc3R5bGUpIHJlcGxhY2VSZWYoc3R5bGUsICdhbmltYXRpb24nLCBzaGVldC5rZXlmcmFtZXMpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcbiAgb25DaGFuZ2VWYWx1ZTogZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWwsIHByb3AsIHJ1bGUpIHtcbiAgICB2YXIgc2hlZXQgPSBydWxlLm9wdGlvbnMuc2hlZXQ7XG5cbiAgICBpZiAoIXNoZWV0KSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgY2FzZSAnYW5pbWF0aW9uJzpcbiAgICAgICAgcmV0dXJuIGZpbmRSZWZlcmVuY2VkS2V5ZnJhbWUodmFsLCBzaGVldC5rZXlmcmFtZXMpO1xuXG4gICAgICBjYXNlICdhbmltYXRpb24tbmFtZSc6XG4gICAgICAgIHJldHVybiBmaW5kUmVmZXJlbmNlZEtleWZyYW1lKHZhbCwgc2hlZXQua2V5ZnJhbWVzKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBLZXlmcmFtZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlU3R5bGVSdWxlKSB7XG4gIF9pbmhlcml0c0xvb3NlKEtleWZyYW1lUnVsZSwgX0Jhc2VTdHlsZVJ1bGUpO1xuXG4gIGZ1bmN0aW9uIEtleWZyYW1lUnVsZSgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfQmFzZVN0eWxlUnVsZS5jYWxsLmFwcGx5KF9CYXNlU3R5bGVSdWxlLCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuICAgIF90aGlzLnJlbmRlcmFibGUgPSB2b2lkIDA7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEtleWZyYW1lUnVsZS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuICAgIHZhciBsaW5rID0gc2hlZXQgPyBzaGVldC5vcHRpb25zLmxpbmsgOiBmYWxzZTtcbiAgICB2YXIgb3B0cyA9IGxpbmsgPyBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgYWxsb3dFbXB0eTogdHJ1ZVxuICAgIH0pIDogb3B0aW9ucztcbiAgICByZXR1cm4gdG9Dc3ModGhpcy5rZXksIHRoaXMuc3R5bGUsIG9wdHMpO1xuICB9O1xuXG4gIHJldHVybiBLZXlmcmFtZVJ1bGU7XG59KEJhc2VTdHlsZVJ1bGUpO1xudmFyIHBsdWdpbktleWZyYW1lUnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnBhcmVudCAmJiBvcHRpb25zLnBhcmVudC50eXBlID09PSAna2V5ZnJhbWVzJykge1xuICAgICAgcmV0dXJuIG5ldyBLZXlmcmFtZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbnZhciBGb250RmFjZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGb250RmFjZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdmb250LWZhY2UnO1xuICAgIHRoaXMuYXQgPSAnQGZvbnQtZmFjZSc7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHlsZSA9IHZvaWQgMDtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyYWJsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gRm9udEZhY2VSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5zdHlsZSkpIHtcbiAgICAgIHZhciBzdHIgPSAnJztcblxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuc3R5bGUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHN0ciArPSB0b0Nzcyh0aGlzLmF0LCB0aGlzLnN0eWxlW2luZGV4XSk7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlW2luZGV4ICsgMV0pIHN0ciArPSAnXFxuJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9Dc3ModGhpcy5hdCwgdGhpcy5zdHlsZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIEZvbnRGYWNlUnVsZTtcbn0oKTtcbnZhciBrZXlSZWdFeHAkMiA9IC9AZm9udC1mYWNlLztcbnZhciBwbHVnaW5Gb250RmFjZVJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ga2V5UmVnRXhwJDIudGVzdChrZXkpID8gbmV3IEZvbnRGYWNlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSA6IG51bGw7XG4gIH1cbn07XG5cbnZhciBWaWV3cG9ydFJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWaWV3cG9ydFJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICd2aWV3cG9ydCc7XG4gICAgdGhpcy5hdCA9ICdAdmlld3BvcnQnO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcmFibGUgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFZpZXdwb3J0UnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHJldHVybiB0b0Nzcyh0aGlzLmtleSwgdGhpcy5zdHlsZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIFZpZXdwb3J0UnVsZTtcbn0oKTtcbnZhciBwbHVnaW5WaWV3cG9ydFJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ga2V5ID09PSAnQHZpZXdwb3J0JyB8fCBrZXkgPT09ICdALW1zLXZpZXdwb3J0JyA/IG5ldyBWaWV3cG9ydFJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykgOiBudWxsO1xuICB9XG59O1xuXG52YXIgU2ltcGxlUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNpbXBsZVJ1bGUoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdzaW1wbGUnO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcmFibGUgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxuXG4gIHZhciBfcHJvdG8gPSBTaW1wbGVSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy52YWx1ZSkpIHtcbiAgICAgIHZhciBzdHIgPSAnJztcblxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMudmFsdWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHN0ciArPSB0aGlzLmtleSArIFwiIFwiICsgdGhpcy52YWx1ZVtpbmRleF0gKyBcIjtcIjtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVbaW5kZXggKyAxXSkgc3RyICs9ICdcXG4nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmtleSArIFwiIFwiICsgdGhpcy52YWx1ZSArIFwiO1wiO1xuICB9O1xuXG4gIHJldHVybiBTaW1wbGVSdWxlO1xufSgpO1xudmFyIGtleXNNYXAgPSB7XG4gICdAY2hhcnNldCc6IHRydWUsXG4gICdAaW1wb3J0JzogdHJ1ZSxcbiAgJ0BuYW1lc3BhY2UnOiB0cnVlXG59O1xudmFyIHBsdWdpblNpbXBsZVJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ga2V5IGluIGtleXNNYXAgPyBuZXcgU2ltcGxlUnVsZShrZXksIHZhbHVlLCBvcHRpb25zKSA6IG51bGw7XG4gIH1cbn07XG5cbnZhciBwbHVnaW5zID0gW3BsdWdpblN0eWxlUnVsZSwgcGx1Z2luQ29uZGl0aW9uYWxSdWxlLCBwbHVnaW4sIHBsdWdpbktleWZyYW1lUnVsZSwgcGx1Z2luRm9udEZhY2VSdWxlLCBwbHVnaW5WaWV3cG9ydFJ1bGUsIHBsdWdpblNpbXBsZVJ1bGVdO1xuXG52YXIgZGVmYXVsdFVwZGF0ZU9wdGlvbnMgPSB7XG4gIHByb2Nlc3M6IHRydWVcbn07XG52YXIgZm9yY2VVcGRhdGVPcHRpb25zID0ge1xuICBmb3JjZTogdHJ1ZSxcbiAgcHJvY2VzczogdHJ1ZVxuICAvKipcbiAgICogQ29udGFpbnMgcnVsZXMgb2JqZWN0cyBhbmQgYWxsb3dzIGFkZGluZy9yZW1vdmluZyBldGMuXG4gICAqIElzIHVzZWQgZm9yIGUuZy4gYnkgYFN0eWxlU2hlZXRgIG9yIGBDb25kaXRpb25hbFJ1bGVgLlxuICAgKi9cblxufTtcblxudmFyIFJ1bGVMaXN0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLy8gUnVsZXMgcmVnaXN0cnkgZm9yIGFjY2VzcyBieSAuZ2V0KCkgbWV0aG9kLlxuICAvLyBJdCBjb250YWlucyB0aGUgc2FtZSBydWxlIHJlZ2lzdGVyZWQgYnkgbmFtZSBhbmQgYnkgc2VsZWN0b3IuXG4gIC8vIE9yaWdpbmFsIHN0eWxlcyBvYmplY3QuXG4gIC8vIFVzZWQgdG8gZW5zdXJlIGNvcnJlY3QgcnVsZXMgb3JkZXIuXG4gIGZ1bmN0aW9uIFJ1bGVMaXN0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuICAgIHRoaXMucmF3ID0ge307XG4gICAgdGhpcy5pbmRleCA9IFtdO1xuICAgIHRoaXMuY291bnRlciA9IDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuY2xhc3NlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleWZyYW1lcyA9IHZvaWQgMDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY2xhc3NlcyA9IG9wdGlvbnMuY2xhc3NlcztcbiAgICB0aGlzLmtleWZyYW1lcyA9IG9wdGlvbnMua2V5ZnJhbWVzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHJlZ2lzdGVyIHJ1bGUuXG4gICAqXG4gICAqIFdpbGwgbm90IHJlbmRlciBhZnRlciBTdHlsZSBTaGVldCB3YXMgcmVuZGVyZWQgdGhlIGZpcnN0IHRpbWUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFJ1bGVMaXN0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKG5hbWUsIGRlY2wsIHJ1bGVPcHRpb25zKSB7XG4gICAgdmFyIF90aGlzJG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHBhcmVudCA9IF90aGlzJG9wdGlvbnMucGFyZW50LFxuICAgICAgICBzaGVldCA9IF90aGlzJG9wdGlvbnMuc2hlZXQsXG4gICAgICAgIGpzcyA9IF90aGlzJG9wdGlvbnMuanNzLFxuICAgICAgICBSZW5kZXJlciA9IF90aGlzJG9wdGlvbnMuUmVuZGVyZXIsXG4gICAgICAgIGdlbmVyYXRlSWQgPSBfdGhpcyRvcHRpb25zLmdlbmVyYXRlSWQsXG4gICAgICAgIHNjb3BlZCA9IF90aGlzJG9wdGlvbnMuc2NvcGVkO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBfZXh0ZW5kcyh7XG4gICAgICBjbGFzc2VzOiB0aGlzLmNsYXNzZXMsXG4gICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgIHNoZWV0OiBzaGVldCxcbiAgICAgIGpzczoganNzLFxuICAgICAgUmVuZGVyZXI6IFJlbmRlcmVyLFxuICAgICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZCxcbiAgICAgIHNjb3BlZDogc2NvcGVkLFxuICAgICAgbmFtZTogbmFtZVxuICAgIH0sIHJ1bGVPcHRpb25zKTsgLy8gV2hlbiB1c2VyIHVzZXMgLmNyZWF0ZVN0eWxlU2hlZXQoKSwgZHVwbGljYXRlIG5hbWVzIGFyZSBub3QgcG9zc2libGUsIGJ1dFxuICAgIC8vIGBzaGVldC5hZGRSdWxlKClgIG9wZW5zIHRoZSBkb29yIGZvciBhbnkgZHVwbGljYXRlIHJ1bGUgbmFtZS4gV2hlbiB0aGlzIGhhcHBlbnNcbiAgICAvLyB3ZSBuZWVkIHRvIG1ha2UgdGhlIGtleSB1bmlxdWUgd2l0aGluIHRoaXMgUnVsZUxpc3QgaW5zdGFuY2Ugc2NvcGUuXG5cblxuICAgIHZhciBrZXkgPSBuYW1lO1xuXG4gICAgaWYgKG5hbWUgaW4gdGhpcy5yYXcpIHtcbiAgICAgIGtleSA9IG5hbWUgKyBcIi1kXCIgKyB0aGlzLmNvdW50ZXIrKztcbiAgICB9IC8vIFdlIG5lZWQgdG8gc2F2ZSB0aGUgb3JpZ2luYWwgZGVjbCBiZWZvcmUgY3JlYXRpbmcgdGhlIHJ1bGVcbiAgICAvLyBiZWNhdXNlIGNhY2hlIHBsdWdpbiBuZWVkcyB0byB1c2UgaXQgYXMgYSBrZXkgdG8gcmV0dXJuIGEgY2FjaGVkIHJ1bGUuXG5cblxuICAgIHRoaXMucmF3W2tleV0gPSBkZWNsO1xuXG4gICAgaWYgKGtleSBpbiB0aGlzLmNsYXNzZXMpIHtcbiAgICAgIC8vIEUuZy4gcnVsZXMgaW5zaWRlIG9mIEBtZWRpYSBjb250YWluZXJcbiAgICAgIG9wdGlvbnMuc2VsZWN0b3IgPSBcIi5cIiArIGVzY2FwZSh0aGlzLmNsYXNzZXNba2V5XSk7XG4gICAgfVxuXG4gICAgdmFyIHJ1bGUgPSBjcmVhdGVSdWxlKGtleSwgZGVjbCwgb3B0aW9ucyk7XG4gICAgaWYgKCFydWxlKSByZXR1cm4gbnVsbDtcbiAgICB0aGlzLnJlZ2lzdGVyKHJ1bGUpO1xuICAgIHZhciBpbmRleCA9IG9wdGlvbnMuaW5kZXggPT09IHVuZGVmaW5lZCA/IHRoaXMuaW5kZXgubGVuZ3RoIDogb3B0aW9ucy5pbmRleDtcbiAgICB0aGlzLmluZGV4LnNwbGljZShpbmRleCwgMCwgcnVsZSk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwW25hbWVdO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUocnVsZSkge1xuICAgIHRoaXMudW5yZWdpc3RlcihydWxlKTtcbiAgICBkZWxldGUgdGhpcy5yYXdbcnVsZS5rZXldO1xuICAgIHRoaXMuaW5kZXguc3BsaWNlKHRoaXMuaW5kZXguaW5kZXhPZihydWxlKSwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleC5pbmRleE9mKHJ1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBSdW4gYG9uUHJvY2Vzc1J1bGUoKWAgcGx1Z2lucyBvbiBldmVyeSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcygpIHtcbiAgICB2YXIgcGx1Z2lucyA9IHRoaXMub3B0aW9ucy5qc3MucGx1Z2luczsgLy8gV2UgbmVlZCB0byBjbG9uZSBhcnJheSBiZWNhdXNlIGlmIHdlIG1vZGlmeSB0aGUgaW5kZXggc29tZXdoZXJlIGVsc2UgZHVyaW5nIGEgbG9vcFxuICAgIC8vIHdlIGVuZCB1cCB3aXRoIHZlcnkgaGFyZC10by10cmFjay1kb3duIHNpZGUgZWZmZWN0cy5cblxuICAgIHRoaXMuaW5kZXguc2xpY2UoMCkuZm9yRWFjaChwbHVnaW5zLm9uUHJvY2Vzc1J1bGUsIHBsdWdpbnMpO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHJ1bGUgaW4gYC5tYXBgLCBgLmNsYXNzZXNgIGFuZCBgLmtleWZyYW1lc2AgbWFwcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlcihydWxlKSB7XG4gICAgdGhpcy5tYXBbcnVsZS5rZXldID0gcnVsZTtcblxuICAgIGlmIChydWxlIGluc3RhbmNlb2YgU3R5bGVSdWxlKSB7XG4gICAgICB0aGlzLm1hcFtydWxlLnNlbGVjdG9yXSA9IHJ1bGU7XG4gICAgICBpZiAocnVsZS5pZCkgdGhpcy5jbGFzc2VzW3J1bGUua2V5XSA9IHJ1bGUuaWQ7XG4gICAgfSBlbHNlIGlmIChydWxlIGluc3RhbmNlb2YgS2V5ZnJhbWVzUnVsZSAmJiB0aGlzLmtleWZyYW1lcykge1xuICAgICAgdGhpcy5rZXlmcmFtZXNbcnVsZS5uYW1lXSA9IHJ1bGUuaWQ7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udW5yZWdpc3RlciA9IGZ1bmN0aW9uIHVucmVnaXN0ZXIocnVsZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtydWxlLmtleV07XG5cbiAgICBpZiAocnVsZSBpbnN0YW5jZW9mIFN0eWxlUnVsZSkge1xuICAgICAgZGVsZXRlIHRoaXMubWFwW3J1bGUuc2VsZWN0b3JdO1xuICAgICAgZGVsZXRlIHRoaXMuY2xhc3Nlc1tydWxlLmtleV07XG4gICAgfSBlbHNlIGlmIChydWxlIGluc3RhbmNlb2YgS2V5ZnJhbWVzUnVsZSkge1xuICAgICAgZGVsZXRlIHRoaXMua2V5ZnJhbWVzW3J1bGUubmFtZV07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGZ1bmN0aW9uIHZhbHVlcyB3aXRoIGEgbmV3IGRhdGEuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgbmFtZTtcbiAgICB2YXIgZGF0YTtcbiAgICB2YXIgb3B0aW9ucztcblxuICAgIGlmICh0eXBlb2YgKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV07IC8vICRGbG93Rml4TWVcblxuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTsgLy8gJEZsb3dGaXhNZVxuXG4gICAgICBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdO1xuICAgICAgbmFtZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHRoaXMudXBkYXRlT25lKHRoaXMubWFwW25hbWVdLCBkYXRhLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuaW5kZXgubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHRoaXMudXBkYXRlT25lKHRoaXMuaW5kZXhbaW5kZXhdLCBkYXRhLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGUgcGx1Z2lucywgdXBkYXRlIHJ1bGUgcHJvcHMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVwZGF0ZU9uZSA9IGZ1bmN0aW9uIHVwZGF0ZU9uZShydWxlLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRVcGRhdGVPcHRpb25zO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyRvcHRpb25zMiA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgcGx1Z2lucyA9IF90aGlzJG9wdGlvbnMyLmpzcy5wbHVnaW5zLFxuICAgICAgICBzaGVldCA9IF90aGlzJG9wdGlvbnMyLnNoZWV0OyAvLyBJdCBpcyBhIHJ1bGVzIGNvbnRhaW5lciBsaWtlIGZvciBlLmcuIENvbmRpdGlvbmFsUnVsZS5cblxuICAgIGlmIChydWxlLnJ1bGVzIGluc3RhbmNlb2YgUnVsZUxpc3QpIHtcbiAgICAgIHJ1bGUucnVsZXMudXBkYXRlKGRhdGEsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdHlsZVJ1bGUgPSBydWxlO1xuICAgIHZhciBzdHlsZSA9IHN0eWxlUnVsZS5zdHlsZTtcbiAgICBwbHVnaW5zLm9uVXBkYXRlKGRhdGEsIHJ1bGUsIHNoZWV0LCBvcHRpb25zKTsgLy8gV2UgcmVseSBvbiBhIG5ldyBgc3R5bGVgIHJlZiBpbiBjYXNlIGl0IHdhcyBtdXRhdGVkIGR1cmluZyBvblVwZGF0ZSBob29rLlxuXG4gICAgaWYgKG9wdGlvbnMucHJvY2VzcyAmJiBzdHlsZSAmJiBzdHlsZSAhPT0gc3R5bGVSdWxlLnN0eWxlKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIHJ1biB0aGUgcGx1Z2lucyBpbiBjYXNlIG5ldyBgc3R5bGVgIHJlbGllcyBvbiBzeW50YXggcGx1Z2lucy5cbiAgICAgIHBsdWdpbnMub25Qcm9jZXNzU3R5bGUoc3R5bGVSdWxlLnN0eWxlLCBzdHlsZVJ1bGUsIHNoZWV0KTsgLy8gVXBkYXRlIGFuZCBhZGQgcHJvcHMuXG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGVSdWxlLnN0eWxlKSB7XG4gICAgICAgIHZhciBuZXh0VmFsdWUgPSBzdHlsZVJ1bGUuc3R5bGVbcHJvcF07XG4gICAgICAgIHZhciBwcmV2VmFsdWUgPSBzdHlsZVtwcm9wXTsgLy8gV2UgbmVlZCB0byB1c2UgYGZvcmNlOiB0cnVlYCBiZWNhdXNlIGBydWxlLnN0eWxlYCBoYXMgYmVlbiB1cGRhdGVkIGR1cmluZyBvblVwZGF0ZSBob29rLCBzbyBgcnVsZS5wcm9wKClgIHdpbGwgbm90IHVwZGF0ZSB0aGUgQ1NTT00gcnVsZS5cbiAgICAgICAgLy8gV2UgZG8gdGhpcyBjb21wYXJpc29uIHRvIGF2b2lkIHVubmVlZGVkIGBydWxlLnByb3AoKWAgY2FsbHMsIHNpbmNlIHdlIGhhdmUgdGhlIG9sZCBgc3R5bGVgIG9iamVjdCBoZXJlLlxuXG4gICAgICAgIGlmIChuZXh0VmFsdWUgIT09IHByZXZWYWx1ZSkge1xuICAgICAgICAgIHN0eWxlUnVsZS5wcm9wKHByb3AsIG5leHRWYWx1ZSwgZm9yY2VVcGRhdGVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZW1vdmUgcHJvcHMuXG5cblxuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gc3R5bGUpIHtcbiAgICAgICAgdmFyIF9uZXh0VmFsdWUgPSBzdHlsZVJ1bGUuc3R5bGVbX3Byb3BdO1xuICAgICAgICB2YXIgX3ByZXZWYWx1ZSA9IHN0eWxlW19wcm9wXTsgLy8gV2UgbmVlZCB0byB1c2UgYGZvcmNlOiB0cnVlYCBiZWNhdXNlIGBydWxlLnN0eWxlYCBoYXMgYmVlbiB1cGRhdGVkIGR1cmluZyBvblVwZGF0ZSBob29rLCBzbyBgcnVsZS5wcm9wKClgIHdpbGwgbm90IHVwZGF0ZSB0aGUgQ1NTT00gcnVsZS5cbiAgICAgICAgLy8gV2UgZG8gdGhpcyBjb21wYXJpc29uIHRvIGF2b2lkIHVubmVlZGVkIGBydWxlLnByb3AoKWAgY2FsbHMsIHNpbmNlIHdlIGhhdmUgdGhlIG9sZCBgc3R5bGVgIG9iamVjdCBoZXJlLlxuXG4gICAgICAgIGlmIChfbmV4dFZhbHVlID09IG51bGwgJiYgX25leHRWYWx1ZSAhPT0gX3ByZXZWYWx1ZSkge1xuICAgICAgICAgIHN0eWxlUnVsZS5wcm9wKF9wcm9wLCBudWxsLCBmb3JjZVVwZGF0ZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IHJ1bGVzIHRvIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIHZhciBzaGVldCA9IHRoaXMub3B0aW9ucy5zaGVldDtcbiAgICB2YXIgbGluayA9IHNoZWV0ID8gc2hlZXQub3B0aW9ucy5saW5rIDogZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5pbmRleC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBydWxlID0gdGhpcy5pbmRleFtpbmRleF07XG4gICAgICB2YXIgY3NzID0gcnVsZS50b1N0cmluZyhvcHRpb25zKTsgLy8gTm8gbmVlZCB0byByZW5kZXIgYW4gZW1wdHkgcnVsZS5cblxuICAgICAgaWYgKCFjc3MgJiYgIWxpbmspIGNvbnRpbnVlO1xuICAgICAgaWYgKHN0cikgc3RyICs9ICdcXG4nO1xuICAgICAgc3RyICs9IGNzcztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIHJldHVybiBSdWxlTGlzdDtcbn0oKTtcblxudmFyIFN0eWxlU2hlZXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHlsZVNoZWV0KHN0eWxlcywgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLmRlcGxveWVkID0gdm9pZCAwO1xuICAgIHRoaXMuYXR0YWNoZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5ydWxlcyA9IHZvaWQgMDtcbiAgICB0aGlzLnJlbmRlcmVyID0gdm9pZCAwO1xuICAgIHRoaXMuY2xhc3NlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleWZyYW1lcyA9IHZvaWQgMDtcbiAgICB0aGlzLnF1ZXVlID0gdm9pZCAwO1xuICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlcGxveWVkID0gZmFsc2U7XG4gICAgdGhpcy5jbGFzc2VzID0ge307XG4gICAgdGhpcy5rZXlmcmFtZXMgPSB7fTtcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgc2hlZXQ6IHRoaXMsXG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBjbGFzc2VzOiB0aGlzLmNsYXNzZXMsXG4gICAgICBrZXlmcmFtZXM6IHRoaXMua2V5ZnJhbWVzXG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5SZW5kZXJlcikge1xuICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBvcHRpb25zLlJlbmRlcmVyKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMgPSBuZXcgUnVsZUxpc3QodGhpcy5vcHRpb25zKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICB0aGlzLnJ1bGVzLmFkZChuYW1lLCBzdHlsZXNbbmFtZV0pO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucHJvY2VzcygpO1xuICB9XG4gIC8qKlxuICAgKiBBdHRhY2ggcmVuZGVyYWJsZSB0byB0aGUgcmVuZGVyIHRyZWUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFN0eWxlU2hlZXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5hdHRhY2ggPSBmdW5jdGlvbiBhdHRhY2goKSB7XG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHJldHVybiB0aGlzO1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB0aGlzLnJlbmRlcmVyLmF0dGFjaCgpO1xuICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlOyAvLyBPcmRlciBpcyBpbXBvcnRhbnQsIGJlY2F1c2Ugd2UgY2FuJ3QgdXNlIGluc2VydFJ1bGUgQVBJIGlmIHN0eWxlIGVsZW1lbnQgaXMgbm90IGF0dGFjaGVkLlxuXG4gICAgaWYgKCF0aGlzLmRlcGxveWVkKSB0aGlzLmRlcGxveSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgcmVuZGVyYWJsZSBmcm9tIHJlbmRlciB0cmVlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXRhY2ggPSBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgaWYgKCF0aGlzLmF0dGFjaGVkKSByZXR1cm4gdGhpcztcbiAgICBpZiAodGhpcy5yZW5kZXJlcikgdGhpcy5yZW5kZXJlci5kZXRhY2goKTtcbiAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIHJ1bGUgdG8gdGhlIGN1cnJlbnQgc3R5bGVzaGVldC5cbiAgICogV2lsbCBpbnNlcnQgYSBydWxlIGFsc28gYWZ0ZXIgdGhlIHN0eWxlc2hlZXQgaGFzIGJlZW4gcmVuZGVyZWQgZmlyc3QgdGltZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYWRkUnVsZSA9IGZ1bmN0aW9uIGFkZFJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWU7IC8vIFBsdWdpbnMgY2FuIGNyZWF0ZSBydWxlcy5cbiAgICAvLyBJbiBvcmRlciB0byBwcmVzZXJ2ZSB0aGUgcmlnaHQgb3JkZXIsIHdlIG5lZWQgdG8gcXVldWUgYWxsIGAuYWRkUnVsZWAgY2FsbHMsXG4gICAgLy8gd2hpY2ggaGFwcGVuIGFmdGVyIHRoZSBmaXJzdCBgcnVsZXMuYWRkKClgIGNhbGwuXG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiAhcXVldWUpIHRoaXMucXVldWUgPSBbXTtcbiAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXMuYWRkKG5hbWUsIGRlY2wsIG9wdGlvbnMpO1xuICAgIGlmICghcnVsZSkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgaWYgKCF0aGlzLmRlcGxveWVkKSByZXR1cm4gcnVsZTsgLy8gRG9uJ3QgaW5zZXJ0IHJ1bGUgZGlyZWN0bHkgaWYgdGhlcmUgaXMgbm8gc3RyaW5naWZpZWQgdmVyc2lvbiB5ZXQuXG4gICAgICAvLyBJdCB3aWxsIGJlIGluc2VydGVkIGFsbCB0b2dldGhlciB3aGVuIC5hdHRhY2ggaXMgY2FsbGVkLlxuXG4gICAgICBpZiAocXVldWUpIHF1ZXVlLnB1c2gocnVsZSk7ZWxzZSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcblxuICAgICAgICBpZiAodGhpcy5xdWV1ZSkge1xuICAgICAgICAgIHRoaXMucXVldWUuZm9yRWFjaCh0aGlzLmluc2VydFJ1bGUsIHRoaXMpO1xuICAgICAgICAgIHRoaXMucXVldWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBydWxlO1xuICAgIH0gLy8gV2UgY2FuJ3QgYWRkIHJ1bGVzIHRvIGEgZGV0YWNoZWQgc3R5bGUgbm9kZS5cbiAgICAvLyBXZSB3aWxsIHJlZGVwbG95IHRoZSBzaGVldCBvbmNlIHVzZXIgd2lsbCBhdHRhY2ggaXQuXG5cblxuICAgIHRoaXMuZGVwbG95ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IHJ1bGUgaW50byB0aGUgU3R5bGVTaGVldFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbnNlcnRSdWxlID0gZnVuY3Rpb24gaW5zZXJ0UnVsZShydWxlKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuaW5zZXJ0UnVsZShydWxlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgYWRkIHJ1bGVzLlxuICAgKiBXaWxsIHJlbmRlciBhbHNvIGFmdGVyIFN0eWxlIFNoZWV0IHdhcyByZW5kZXJlZCB0aGUgZmlyc3QgdGltZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYWRkUnVsZXMgPSBmdW5jdGlvbiBhZGRSdWxlcyhzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgYWRkZWQgPSBbXTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICB2YXIgcnVsZSA9IHRoaXMuYWRkUnVsZShuYW1lLCBzdHlsZXNbbmFtZV0sIG9wdGlvbnMpO1xuICAgICAgaWYgKHJ1bGUpIGFkZGVkLnB1c2gocnVsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZGVkO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBydWxlIGJ5IG5hbWUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldFJ1bGUgPSBmdW5jdGlvbiBnZXRSdWxlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5nZXQobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHJ1bGUgYnkgbmFtZS5cbiAgICogUmV0dXJucyBgdHJ1ZWA6IGlmIHJ1bGUgaGFzIGJlZW4gZGVsZXRlZCBmcm9tIHRoZSBET00uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlbGV0ZVJ1bGUgPSBmdW5jdGlvbiBkZWxldGVSdWxlKG5hbWUpIHtcbiAgICB2YXIgcnVsZSA9IHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JyA/IG5hbWUgOiB0aGlzLnJ1bGVzLmdldChuYW1lKTtcbiAgICBpZiAoIXJ1bGUpIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLnJ1bGVzLnJlbW92ZShydWxlKTtcblxuICAgIGlmICh0aGlzLmF0dGFjaGVkICYmIHJ1bGUucmVuZGVyYWJsZSAmJiB0aGlzLnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5kZWxldGVSdWxlKHJ1bGUucmVuZGVyYWJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5pbmRleE9mKHJ1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBEZXBsb3kgcHVyZSBDU1Mgc3RyaW5nIHRvIGEgcmVuZGVyYWJsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVwbG95ID0gZnVuY3Rpb24gZGVwbG95KCkge1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB0aGlzLnJlbmRlcmVyLmRlcGxveSgpO1xuICAgIHRoaXMuZGVwbG95ZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGZ1bmN0aW9uIHZhbHVlcyB3aXRoIGEgbmV3IGRhdGEuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgX3RoaXMkcnVsZXM7XG5cbiAgICAoX3RoaXMkcnVsZXMgPSB0aGlzLnJ1bGVzKS51cGRhdGUuYXBwbHkoX3RoaXMkcnVsZXMsIGFyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBhIHNpbmdsZSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51cGRhdGVPbmUgPSBmdW5jdGlvbiB1cGRhdGVPbmUocnVsZSwgZGF0YSwgb3B0aW9ucykge1xuICAgIHRoaXMucnVsZXMudXBkYXRlT25lKHJ1bGUsIGRhdGEsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IHJ1bGVzIHRvIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMudG9TdHJpbmcob3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIFN0eWxlU2hlZXQ7XG59KCk7XG5cbnZhciBQbHVnaW5zUmVnaXN0cnkgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQbHVnaW5zUmVnaXN0cnkoKSB7XG4gICAgdGhpcy5wbHVnaW5zID0ge1xuICAgICAgaW50ZXJuYWw6IFtdLFxuICAgICAgZXh0ZXJuYWw6IFtdXG4gICAgfTtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0gdm9pZCAwO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBsdWdpbnNSZWdpc3RyeS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIENhbGwgYG9uQ3JlYXRlUnVsZWAgaG9va3MgYW5kIHJldHVybiBhbiBvYmplY3QgaWYgcmV0dXJuZWQgYnkgYSBob29rLlxuICAgKi9cbiAgX3Byb3RvLm9uQ3JlYXRlUnVsZSA9IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShuYW1lLCBkZWNsLCBvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lm9uQ3JlYXRlUnVsZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJ1bGUgPSB0aGlzLnJlZ2lzdHJ5Lm9uQ3JlYXRlUnVsZVtpXShuYW1lLCBkZWNsLCBvcHRpb25zKTtcbiAgICAgIGlmIChydWxlKSByZXR1cm4gcnVsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ2FsbCBgb25Qcm9jZXNzUnVsZWAgaG9va3MuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9uUHJvY2Vzc1J1bGUgPSBmdW5jdGlvbiBvblByb2Nlc3NSdWxlKHJ1bGUpIHtcbiAgICBpZiAocnVsZS5pc1Byb2Nlc3NlZCkgcmV0dXJuO1xuICAgIHZhciBzaGVldCA9IHJ1bGUub3B0aW9ucy5zaGVldDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NSdWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1J1bGVbaV0ocnVsZSwgc2hlZXQpO1xuICAgIH1cblxuICAgIGlmIChydWxlLnN0eWxlKSB0aGlzLm9uUHJvY2Vzc1N0eWxlKHJ1bGUuc3R5bGUsIHJ1bGUsIHNoZWV0KTtcbiAgICBydWxlLmlzUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCBgb25Qcm9jZXNzU3R5bGVgIGhvb2tzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vblByb2Nlc3NTdHlsZSA9IGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlLCBzaGVldCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NTdHlsZS5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgcnVsZS5zdHlsZSA9IHRoaXMucmVnaXN0cnkub25Qcm9jZXNzU3R5bGVbaV0ocnVsZS5zdHlsZSwgcnVsZSwgc2hlZXQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FsbCBgb25Qcm9jZXNzU2hlZXRgIGhvb2tzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vblByb2Nlc3NTaGVldCA9IGZ1bmN0aW9uIG9uUHJvY2Vzc1NoZWV0KHNoZWV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1NoZWV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1NoZWV0W2ldKHNoZWV0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYG9uVXBkYXRlYCBob29rcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ub25VcGRhdGUgPSBmdW5jdGlvbiBvblVwZGF0ZShkYXRhLCBydWxlLCBzaGVldCwgb3B0aW9ucykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vblVwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5yZWdpc3RyeS5vblVwZGF0ZVtpXShkYXRhLCBydWxlLCBzaGVldCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxsIGBvbkNoYW5nZVZhbHVlYCBob29rcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ub25DaGFuZ2VWYWx1ZSA9IGZ1bmN0aW9uIG9uQ2hhbmdlVmFsdWUodmFsdWUsIHByb3AsIHJ1bGUpIHtcbiAgICB2YXIgcHJvY2Vzc2VkVmFsdWUgPSB2YWx1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vbkNoYW5nZVZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm9jZXNzZWRWYWx1ZSA9IHRoaXMucmVnaXN0cnkub25DaGFuZ2VWYWx1ZVtpXShwcm9jZXNzZWRWYWx1ZSwgcHJvcCwgcnVsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2Nlc3NlZFZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHBsdWdpbi5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXNlID0gZnVuY3Rpb24gdXNlKG5ld1BsdWdpbiwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHF1ZXVlOiAnZXh0ZXJuYWwnXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBwbHVnaW5zID0gdGhpcy5wbHVnaW5zW29wdGlvbnMucXVldWVdOyAvLyBBdm9pZHMgYXBwbHlpbmcgc2FtZSBwbHVnaW4gdHdpY2UsIGF0IGxlYXN0IGJhc2VkIG9uIHJlZi5cblxuICAgIGlmIChwbHVnaW5zLmluZGV4T2YobmV3UGx1Z2luKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwbHVnaW5zLnB1c2gobmV3UGx1Z2luKTtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0gW10uY29uY2F0KHRoaXMucGx1Z2lucy5leHRlcm5hbCwgdGhpcy5wbHVnaW5zLmludGVybmFsKS5yZWR1Y2UoZnVuY3Rpb24gKHJlZ2lzdHJ5LCBwbHVnaW4pIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcGx1Z2luKSB7XG4gICAgICAgIGlmIChuYW1lIGluIHJlZ2lzdHJ5KSB7XG4gICAgICAgICAgcmVnaXN0cnlbbmFtZV0ucHVzaChwbHVnaW5bbmFtZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIFVua25vd24gaG9vayBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLlwiKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVnaXN0cnk7XG4gICAgfSwge1xuICAgICAgb25DcmVhdGVSdWxlOiBbXSxcbiAgICAgIG9uUHJvY2Vzc1J1bGU6IFtdLFxuICAgICAgb25Qcm9jZXNzU3R5bGU6IFtdLFxuICAgICAgb25Qcm9jZXNzU2hlZXQ6IFtdLFxuICAgICAgb25DaGFuZ2VWYWx1ZTogW10sXG4gICAgICBvblVwZGF0ZTogW11cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gUGx1Z2luc1JlZ2lzdHJ5O1xufSgpO1xuXG4vKipcbiAqIFNoZWV0cyByZWdpc3RyeSB0byBhY2Nlc3MgdGhlbSBhbGwgYXQgb25lIHBsYWNlLlxuICovXG52YXIgU2hlZXRzUmVnaXN0cnkgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaGVldHNSZWdpc3RyeSgpIHtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0gW107XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2hlZXRzUmVnaXN0cnkucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIFN0eWxlIFNoZWV0LlxuICAgKi9cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChzaGVldCkge1xuICAgIHZhciByZWdpc3RyeSA9IHRoaXMucmVnaXN0cnk7XG4gICAgdmFyIGluZGV4ID0gc2hlZXQub3B0aW9ucy5pbmRleDtcbiAgICBpZiAocmVnaXN0cnkuaW5kZXhPZihzaGVldCkgIT09IC0xKSByZXR1cm47XG5cbiAgICBpZiAocmVnaXN0cnkubGVuZ3RoID09PSAwIHx8IGluZGV4ID49IHRoaXMuaW5kZXgpIHtcbiAgICAgIHJlZ2lzdHJ5LnB1c2goc2hlZXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRmluZCBhIHBvc2l0aW9uLlxuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVnaXN0cnlbaV0ub3B0aW9ucy5pbmRleCA+IGluZGV4KSB7XG4gICAgICAgIHJlZ2lzdHJ5LnNwbGljZShpLCAwLCBzaGVldCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSByZWdpc3RyeS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0gW107XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhIFN0eWxlIFNoZWV0LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoc2hlZXQpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnJlZ2lzdHJ5LmluZGV4T2Yoc2hlZXQpO1xuICAgIHRoaXMucmVnaXN0cnkuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCBhbGwgYXR0YWNoZWQgc2hlZXRzIHRvIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhfdGVtcCkge1xuICAgIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICAgIGF0dGFjaGVkID0gX3JlZi5hdHRhY2hlZCxcbiAgICAgICAgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIFtcImF0dGFjaGVkXCJdKTtcblxuICAgIHZhciBjc3MgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNoZWV0ID0gdGhpcy5yZWdpc3RyeVtpXTtcblxuICAgICAgaWYgKGF0dGFjaGVkICE9IG51bGwgJiYgc2hlZXQuYXR0YWNoZWQgIT09IGF0dGFjaGVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3NzKSBjc3MgKz0gJ1xcbic7XG4gICAgICBjc3MgKz0gc2hlZXQudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNzcztcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoU2hlZXRzUmVnaXN0cnksIFt7XG4gICAga2V5OiBcImluZGV4XCIsXG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGhpZ2hlc3QgaW5kZXggbnVtYmVyLlxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnkubGVuZ3RoID09PSAwID8gMCA6IHRoaXMucmVnaXN0cnlbdGhpcy5yZWdpc3RyeS5sZW5ndGggLSAxXS5vcHRpb25zLmluZGV4O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTaGVldHNSZWdpc3RyeTtcbn0oKTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgZ2xvYmFsIHNoZWV0cyByZWdpc3RyeS4gT25seSBEb21SZW5kZXJlciB3aWxsIGFkZCBzaGVldHMgdG8gaXQuXG4gKiBPbiB0aGUgc2VydmVyIG9uZSBzaG91bGQgdXNlIGFuIG93biBTaGVldHNSZWdpc3RyeSBpbnN0YW5jZSBhbmQgYWRkIHRoZVxuICogc2hlZXRzIHRvIGl0LCBiZWNhdXNlIHlvdSBuZWVkIHRvIG1ha2Ugc3VyZSB0byBjcmVhdGUgYSBuZXcgcmVnaXN0cnkgZm9yXG4gKiBlYWNoIHJlcXVlc3QgaW4gb3JkZXIgdG8gbm90IGxlYWsgc2hlZXRzIGFjcm9zcyByZXF1ZXN0cy5cbiAqL1xuXG52YXIgc2hlZXRzID0gbmV3IFNoZWV0c1JlZ2lzdHJ5KCk7XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbFRoaXMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGggPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG52YXIgbnMgPSAnMmYxYWNjNmMzYTYwNmIwODJlNWVlZjVlNTQ0MTRmZmInO1xuaWYgKGdsb2JhbFRoaXNbbnNdID09IG51bGwpIGdsb2JhbFRoaXNbbnNdID0gMDsgLy8gQnVuZGxlIG1heSBjb250YWluIG11bHRpcGxlIEpTUyB2ZXJzaW9ucyBhdCB0aGUgc2FtZSB0aW1lLiBJbiBvcmRlciB0byBpZGVudGlmeVxuLy8gdGhlIGN1cnJlbnQgdmVyc2lvbiB3aXRoIGp1c3Qgb25lIHNob3J0IG51bWJlciBhbmQgdXNlIGl0IGZvciBjbGFzc2VzIGdlbmVyYXRpb25cbi8vIHdlIHVzZSBhIGNvdW50ZXIuIEFsc28gaXQgaXMgbW9yZSBhY2N1cmF0ZSwgYmVjYXVzZSB1c2VyIGNhbiBtYW51YWxseSByZWV2YWx1YXRlXG4vLyB0aGUgbW9kdWxlLlxuXG52YXIgbW9kdWxlSWQgPSBnbG9iYWxUaGlzW25zXSsrO1xuXG52YXIgbWF4UnVsZXMgPSAxZTEwO1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBnZW5lcmF0ZXMgdW5pcXVlIGNsYXNzIG5hbWVzIGJhc2VkIG9uIGNvdW50ZXJzLlxuICogV2hlbiBuZXcgZ2VuZXJhdG9yIGZ1bmN0aW9uIGlzIGNyZWF0ZWQsIHJ1bGUgY291bnRlciBpcyByZXNldGVkLlxuICogV2UgbmVlZCB0byByZXNldCB0aGUgcnVsZSBjb3VudGVyIGZvciBTU1IgZm9yIGVhY2ggcmVxdWVzdC5cbiAqL1xudmFyIGNyZWF0ZUdlbmVyYXRlSWQgPSBmdW5jdGlvbiBjcmVhdGVHZW5lcmF0ZUlkKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBydWxlQ291bnRlciA9IDA7XG4gIHJldHVybiBmdW5jdGlvbiAocnVsZSwgc2hlZXQpIHtcbiAgICBydWxlQ291bnRlciArPSAxO1xuXG4gICAgaWYgKHJ1bGVDb3VudGVyID4gbWF4UnVsZXMpIHtcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIFlvdSBtaWdodCBoYXZlIGEgbWVtb3J5IGxlYWsuIFJ1bGUgY291bnRlciBpcyBhdCBcIiArIHJ1bGVDb3VudGVyICsgXCIuXCIpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciBqc3NJZCA9ICcnO1xuICAgIHZhciBwcmVmaXggPSAnJztcblxuICAgIGlmIChzaGVldCkge1xuICAgICAgaWYgKHNoZWV0Lm9wdGlvbnMuY2xhc3NOYW1lUHJlZml4KSB7XG4gICAgICAgIHByZWZpeCA9IHNoZWV0Lm9wdGlvbnMuY2xhc3NOYW1lUHJlZml4O1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hlZXQub3B0aW9ucy5qc3MuaWQgIT0gbnVsbCkge1xuICAgICAgICBqc3NJZCA9IFN0cmluZyhzaGVldC5vcHRpb25zLmpzcy5pZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubWluaWZ5KSB7XG4gICAgICAvLyBVc2luZyBcImNcIiBiZWNhdXNlIGEgbnVtYmVyIGNhbid0IGJlIHRoZSBmaXJzdCBjaGFyIGluIGEgY2xhc3MgbmFtZS5cbiAgICAgIHJldHVybiBcIlwiICsgKHByZWZpeCB8fCAnYycpICsgbW9kdWxlSWQgKyBqc3NJZCArIHJ1bGVDb3VudGVyO1xuICAgIH1cblxuICAgIHJldHVybiBwcmVmaXggKyBydWxlLmtleSArIFwiLVwiICsgbW9kdWxlSWQgKyAoanNzSWQgPyBcIi1cIiArIGpzc0lkIDogJycpICsgXCItXCIgKyBydWxlQ291bnRlcjtcbiAgfTtcbn07XG5cbi8qKlxuICogQ2FjaGUgdGhlIHZhbHVlIGZyb20gdGhlIGZpcnN0IHRpbWUgYSBmdW5jdGlvbiBpcyBjYWxsZWQuXG4gKi9cbnZhciBtZW1vaXplID0gZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICB2YXIgdmFsdWU7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF2YWx1ZSkgdmFsdWUgPSBmbigpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn07XG4vKipcbiAqIEdldCBhIHN0eWxlIHByb3BlcnR5IHZhbHVlLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0UHJvcGVydHlWYWx1ZShjc3NSdWxlLCBwcm9wKSB7XG4gIHRyeSB7XG4gICAgLy8gU3VwcG9ydCBDU1NUT00uXG4gICAgaWYgKGNzc1J1bGUuYXR0cmlidXRlU3R5bGVNYXApIHtcbiAgICAgIHJldHVybiBjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwLmdldChwcm9wKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3NzUnVsZS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBJRSBtYXkgdGhyb3cgaWYgcHJvcGVydHkgaXMgdW5rbm93bi5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxuICogU2V0IGEgc3R5bGUgcHJvcGVydHkuXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRQcm9wZXJ0eShjc3NSdWxlLCBwcm9wLCB2YWx1ZSkge1xuICB0cnkge1xuICAgIHZhciBjc3NWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBjc3NWYWx1ZSA9IHRvQ3NzVmFsdWUodmFsdWUsIHRydWUpO1xuXG4gICAgICBpZiAodmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gPT09ICchaW1wb3J0YW50Jykge1xuICAgICAgICBjc3NSdWxlLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIGNzc1ZhbHVlLCAnaW1wb3J0YW50Jyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gLy8gU3VwcG9ydCBDU1NUT00uXG5cblxuICAgIGlmIChjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwKSB7XG4gICAgICBjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwLnNldChwcm9wLCBjc3NWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNzc1J1bGUuc3R5bGUuc2V0UHJvcGVydHkocHJvcCwgY3NzVmFsdWUpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gSUUgbWF5IHRocm93IGlmIHByb3BlcnR5IGlzIHVua25vd24uXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFJlbW92ZSBhIHN0eWxlIHByb3BlcnR5LlxuICovXG5cblxuZnVuY3Rpb24gcmVtb3ZlUHJvcGVydHkoY3NzUnVsZSwgcHJvcCkge1xuICB0cnkge1xuICAgIC8vIFN1cHBvcnQgQ1NTVE9NLlxuICAgIGlmIChjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwKSB7XG4gICAgICBjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwLmRlbGV0ZShwcm9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3NzUnVsZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIERPTUV4Y2VwdGlvbiBcXFwiXCIgKyBlcnIubWVzc2FnZSArIFwiXFxcIiB3YXMgdGhyb3duLiBUcmllZCB0byByZW1vdmUgcHJvcGVydHkgXFxcIlwiICsgcHJvcCArIFwiXFxcIi5cIikgOiB2b2lkIDA7XG4gIH1cbn1cbi8qKlxuICogU2V0IHRoZSBzZWxlY3Rvci5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFNlbGVjdG9yKGNzc1J1bGUsIHNlbGVjdG9yVGV4dCkge1xuICBjc3NSdWxlLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yVGV4dDsgLy8gUmV0dXJuIGZhbHNlIGlmIHNldHRlciB3YXMgbm90IHN1Y2Nlc3NmdWwuXG4gIC8vIEN1cnJlbnRseSB3b3JrcyBpbiBjaHJvbWUgb25seS5cblxuICByZXR1cm4gY3NzUnVsZS5zZWxlY3RvclRleHQgPT09IHNlbGVjdG9yVGV4dDtcbn1cbi8qKlxuICogR2V0cyB0aGUgYGhlYWRgIGVsZW1lbnQgdXBvbiB0aGUgZmlyc3QgY2FsbCBhbmQgY2FjaGVzIGl0LlxuICogV2UgYXNzdW1lIGl0IGNhbid0IGJlIG51bGwuXG4gKi9cblxuXG52YXIgZ2V0SGVhZCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCcpO1xufSk7XG4vKipcbiAqIEZpbmQgYXR0YWNoZWQgc2hlZXQgd2l0aCBhbiBpbmRleCBoaWdoZXIgdGhhbiB0aGUgcGFzc2VkIG9uZS5cbiAqL1xuXG5mdW5jdGlvbiBmaW5kSGlnaGVyU2hlZXQocmVnaXN0cnksIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyeS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzaGVldCA9IHJlZ2lzdHJ5W2ldO1xuXG4gICAgaWYgKHNoZWV0LmF0dGFjaGVkICYmIHNoZWV0Lm9wdGlvbnMuaW5kZXggPiBvcHRpb25zLmluZGV4ICYmIHNoZWV0Lm9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgPT09IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQpIHtcbiAgICAgIHJldHVybiBzaGVldDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogRmluZCBhdHRhY2hlZCBzaGVldCB3aXRoIHRoZSBoaWdoZXN0IGluZGV4LlxuICovXG5cblxuZnVuY3Rpb24gZmluZEhpZ2hlc3RTaGVldChyZWdpc3RyeSwgb3B0aW9ucykge1xuICBmb3IgKHZhciBpID0gcmVnaXN0cnkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgc2hlZXQgPSByZWdpc3RyeVtpXTtcblxuICAgIGlmIChzaGVldC5hdHRhY2hlZCAmJiBzaGVldC5vcHRpb25zLmluc2VydGlvblBvaW50ID09PSBvcHRpb25zLmluc2VydGlvblBvaW50KSB7XG4gICAgICByZXR1cm4gc2hlZXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEZpbmQgYSBjb21tZW50IHdpdGggXCJqc3NcIiBpbnNpZGUuXG4gKi9cblxuXG5mdW5jdGlvbiBmaW5kQ29tbWVudE5vZGUodGV4dCkge1xuICB2YXIgaGVhZCA9IGdldEhlYWQoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gaGVhZC5jaGlsZE5vZGVzW2ldO1xuXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggJiYgbm9kZS5ub2RlVmFsdWUudHJpbSgpID09PSB0ZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBGaW5kIGEgbm9kZSBiZWZvcmUgd2hpY2ggd2UgY2FuIGluc2VydCB0aGUgc2hlZXQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRQcmV2Tm9kZShvcHRpb25zKSB7XG4gIHZhciByZWdpc3RyeSA9IHNoZWV0cy5yZWdpc3RyeTtcblxuICBpZiAocmVnaXN0cnkubGVuZ3RoID4gMCkge1xuICAgIC8vIFRyeSB0byBpbnNlcnQgYmVmb3JlIHRoZSBuZXh0IGhpZ2hlciBzaGVldC5cbiAgICB2YXIgc2hlZXQgPSBmaW5kSGlnaGVyU2hlZXQocmVnaXN0cnksIG9wdGlvbnMpO1xuXG4gICAgaWYgKHNoZWV0ICYmIHNoZWV0LnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJlbnQ6IHNoZWV0LnJlbmRlcmVyLmVsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgICAgbm9kZTogc2hlZXQucmVuZGVyZXIuZWxlbWVudFxuICAgICAgfTtcbiAgICB9IC8vIE90aGVyd2lzZSBpbnNlcnQgYWZ0ZXIgdGhlIGxhc3QgYXR0YWNoZWQuXG5cblxuICAgIHNoZWV0ID0gZmluZEhpZ2hlc3RTaGVldChyZWdpc3RyeSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoc2hlZXQgJiYgc2hlZXQucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcmVudDogc2hlZXQucmVuZGVyZXIuZWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgICBub2RlOiBzaGVldC5yZW5kZXJlci5lbGVtZW50Lm5leHRTaWJsaW5nXG4gICAgICB9O1xuICAgIH1cbiAgfSAvLyBUcnkgdG8gZmluZCBhIGNvbW1lbnQgcGxhY2Vob2xkZXIgaWYgcmVnaXN0cnkgaXMgZW1wdHkuXG5cblxuICB2YXIgaW5zZXJ0aW9uUG9pbnQgPSBvcHRpb25zLmluc2VydGlvblBvaW50O1xuXG4gIGlmIChpbnNlcnRpb25Qb2ludCAmJiB0eXBlb2YgaW5zZXJ0aW9uUG9pbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGNvbW1lbnQgPSBmaW5kQ29tbWVudE5vZGUoaW5zZXJ0aW9uUG9pbnQpO1xuXG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcmVudDogY29tbWVudC5wYXJlbnROb2RlLFxuICAgICAgICBub2RlOiBjb21tZW50Lm5leHRTaWJsaW5nXG4gICAgICB9O1xuICAgIH0gLy8gSWYgdXNlciBzcGVjaWZpZXMgYW4gaW5zZXJ0aW9uIHBvaW50IGFuZCBpdCBjYW4ndCBiZSBmb3VuZCBpbiB0aGUgZG9jdW1lbnQgLVxuICAgIC8vIGJhZCBzcGVjaWZpY2l0eSBpc3N1ZXMgbWF5IGFwcGVhci5cblxuXG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gSW5zZXJ0aW9uIHBvaW50IFxcXCJcIiArIGluc2VydGlvblBvaW50ICsgXCJcXFwiIG5vdCBmb3VuZC5cIikgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEluc2VydCBzdHlsZSBlbGVtZW50IGludG8gdGhlIERPTS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlKHN0eWxlLCBvcHRpb25zKSB7XG4gIHZhciBpbnNlcnRpb25Qb2ludCA9IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQ7XG4gIHZhciBuZXh0Tm9kZSA9IGZpbmRQcmV2Tm9kZShvcHRpb25zKTtcblxuICBpZiAobmV4dE5vZGUgIT09IGZhbHNlICYmIG5leHROb2RlLnBhcmVudCkge1xuICAgIG5leHROb2RlLnBhcmVudC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHROb2RlLm5vZGUpO1xuICAgIHJldHVybjtcbiAgfSAvLyBXb3JrcyB3aXRoIGlmcmFtZXMgYW5kIGFueSBub2RlIHR5cGVzLlxuXG5cbiAgaWYgKGluc2VydGlvblBvaW50ICYmIHR5cGVvZiBpbnNlcnRpb25Qb2ludC5ub2RlVHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80MTMyODcyOC9mb3JjZS1jYXN0aW5nLWluLWZsb3dcbiAgICB2YXIgaW5zZXJ0aW9uUG9pbnRFbGVtZW50ID0gaW5zZXJ0aW9uUG9pbnQ7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBpbnNlcnRpb25Qb2ludEVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50Tm9kZSkgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3R5bGUsIGluc2VydGlvblBvaW50RWxlbWVudC5uZXh0U2libGluZyk7ZWxzZSBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgJ1tKU1NdIEluc2VydGlvbiBwb2ludCBpcyBub3QgaW4gdGhlIERPTS4nKSA6IHZvaWQgMDtcbiAgICByZXR1cm47XG4gIH1cblxuICBnZXRIZWFkKCkuYXBwZW5kQ2hpbGQoc3R5bGUpO1xufVxuLyoqXG4gKiBSZWFkIGpzcyBub25jZSBzZXR0aW5nIGZyb20gdGhlIHBhZ2UgaWYgdGhlIHVzZXIgaGFzIHNldCBpdC5cbiAqL1xuXG5cbnZhciBnZXROb25jZSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbcHJvcGVydHk9XCJjc3Atbm9uY2VcIl0nKTtcbiAgcmV0dXJuIG5vZGUgPyBub2RlLmdldEF0dHJpYnV0ZSgnY29udGVudCcpIDogbnVsbDtcbn0pO1xuXG52YXIgX2luc2VydFJ1bGUgPSBmdW5jdGlvbiBpbnNlcnRSdWxlKGNvbnRhaW5lciwgcnVsZSwgaW5kZXgpIHtcbiAgdmFyIG1heEluZGV4ID0gY29udGFpbmVyLmNzc1J1bGVzLmxlbmd0aDsgLy8gSW4gY2FzZSBwcmV2aW91cyBpbnNlcnRpb24gZmFpbHMsIHBhc3NlZCBpbmRleCBtaWdodCBiZSB3cm9uZ1xuXG4gIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkIHx8IGluZGV4ID4gbWF4SW5kZXgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBpbmRleCA9IG1heEluZGV4O1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAoJ2luc2VydFJ1bGUnIGluIGNvbnRhaW5lcikge1xuICAgICAgdmFyIGMgPSBjb250YWluZXI7XG4gICAgICBjLmluc2VydFJ1bGUocnVsZSwgaW5kZXgpO1xuICAgIH0gLy8gS2V5ZnJhbWVzIHJ1bGUuXG4gICAgZWxzZSBpZiAoJ2FwcGVuZFJ1bGUnIGluIGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgX2MgPSBjb250YWluZXI7XG5cbiAgICAgICAgX2MuYXBwZW5kUnVsZShydWxlKTtcbiAgICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gXCIgKyBlcnIubWVzc2FnZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRhaW5lci5jc3NSdWxlc1tpbmRleF07XG59O1xuXG52YXIgY3JlYXRlU3R5bGUgPSBmdW5jdGlvbiBjcmVhdGVTdHlsZSgpIHtcbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTsgLy8gV2l0aG91dCBpdCwgSUUgd2lsbCBoYXZlIGEgYnJva2VuIHNvdXJjZSBvcmRlciBzcGVjaWZpY2l0eSBpZiB3ZVxuICAvLyBpbnNlcnQgcnVsZXMgYWZ0ZXIgd2UgaW5zZXJ0IHRoZSBzdHlsZSB0YWcuXG4gIC8vIEl0IHNlZW1zIHRvIGtpY2stb2ZmIHRoZSBzb3VyY2Ugb3JkZXIgc3BlY2lmaWNpdHkgYWxnb3JpdGhtLlxuXG4gIGVsLnRleHRDb250ZW50ID0gJ1xcbic7XG4gIHJldHVybiBlbDtcbn07XG5cbnZhciBEb21SZW5kZXJlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8vIEhUTUxTdHlsZUVsZW1lbnQgbmVlZHMgZml4aW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yNjk2XG4gIGZ1bmN0aW9uIERvbVJlbmRlcmVyKHNoZWV0KSB7XG4gICAgdGhpcy5nZXRQcm9wZXJ0eVZhbHVlID0gZ2V0UHJvcGVydHlWYWx1ZTtcbiAgICB0aGlzLnNldFByb3BlcnR5ID0gc2V0UHJvcGVydHk7XG4gICAgdGhpcy5yZW1vdmVQcm9wZXJ0eSA9IHJlbW92ZVByb3BlcnR5O1xuICAgIHRoaXMuc2V0U2VsZWN0b3IgPSBzZXRTZWxlY3RvcjtcbiAgICB0aGlzLmVsZW1lbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5zaGVldCA9IHZvaWQgMDtcbiAgICB0aGlzLmhhc0luc2VydGVkUnVsZXMgPSBmYWxzZTtcbiAgICAvLyBUaGVyZSBpcyBubyBzaGVldCB3aGVuIHRoZSByZW5kZXJlciBpcyB1c2VkIGZyb20gYSBzdGFuZGFsb25lIFN0eWxlUnVsZS5cbiAgICBpZiAoc2hlZXQpIHNoZWV0cy5hZGQoc2hlZXQpO1xuICAgIHRoaXMuc2hlZXQgPSBzaGVldDtcblxuICAgIHZhciBfcmVmID0gdGhpcy5zaGVldCA/IHRoaXMuc2hlZXQub3B0aW9ucyA6IHt9LFxuICAgICAgICBtZWRpYSA9IF9yZWYubWVkaWEsXG4gICAgICAgIG1ldGEgPSBfcmVmLm1ldGEsXG4gICAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQ7XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50IHx8IGNyZWF0ZVN0eWxlKCk7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1qc3MnLCAnJyk7XG4gICAgaWYgKG1lZGlhKSB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgICBpZiAobWV0YSkgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1tZXRhJywgbWV0YSk7XG4gICAgdmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcbiAgICBpZiAobm9uY2UpIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgbm9uY2UpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgc3R5bGUgZWxlbWVudCBpbnRvIHJlbmRlciB0cmVlLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBEb21SZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmF0dGFjaCA9IGZ1bmN0aW9uIGF0dGFjaCgpIHtcbiAgICAvLyBJbiB0aGUgY2FzZSB0aGUgZWxlbWVudCBub2RlIGlzIGV4dGVybmFsIGFuZCBpdCBpcyBhbHJlYWR5IGluIHRoZSBET00uXG4gICAgaWYgKHRoaXMuZWxlbWVudC5wYXJlbnROb2RlIHx8ICF0aGlzLnNoZWV0KSByZXR1cm47XG4gICAgaW5zZXJ0U3R5bGUodGhpcy5lbGVtZW50LCB0aGlzLnNoZWV0Lm9wdGlvbnMpOyAvLyBXaGVuIHJ1bGVzIGFyZSBpbnNlcnRlZCB1c2luZyBgaW5zZXJ0UnVsZWAgQVBJLCBhZnRlciBgc2hlZXQuZGV0YWNoKCkuYXR0YWNoKClgXG4gICAgLy8gbW9zdCBicm93c2VycyBjcmVhdGUgYSBuZXcgQ1NTU3R5bGVTaGVldCwgZXhjZXB0IG9mIGFsbCBJRXMuXG5cbiAgICB2YXIgZGVwbG95ZWQgPSBCb29sZWFuKHRoaXMuc2hlZXQgJiYgdGhpcy5zaGVldC5kZXBsb3llZCk7XG5cbiAgICBpZiAodGhpcy5oYXNJbnNlcnRlZFJ1bGVzICYmIGRlcGxveWVkKSB7XG4gICAgICB0aGlzLmhhc0luc2VydGVkUnVsZXMgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVwbG95KCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgc3R5bGUgZWxlbWVudCBmcm9tIHJlbmRlciB0cmVlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXRhY2ggPSBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgdmFyIHBhcmVudE5vZGUgPSB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50Tm9kZSkgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICB9XG4gIC8qKlxuICAgKiBJbmplY3QgQ1NTIHN0cmluZyBpbnRvIGVsZW1lbnQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlcGxveSA9IGZ1bmN0aW9uIGRlcGxveSgpIHtcbiAgICB2YXIgc2hlZXQgPSB0aGlzLnNoZWV0O1xuICAgIGlmICghc2hlZXQpIHJldHVybjtcblxuICAgIGlmIChzaGVldC5vcHRpb25zLmxpbmspIHtcbiAgICAgIHRoaXMuaW5zZXJ0UnVsZXMoc2hlZXQucnVsZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC50ZXh0Q29udGVudCA9IFwiXFxuXCIgKyBzaGVldC50b1N0cmluZygpICsgXCJcXG5cIjtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IFJ1bGVMaXN0IGludG8gYW4gZWxlbWVudC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5zZXJ0UnVsZXMgPSBmdW5jdGlvbiBpbnNlcnRSdWxlcyhydWxlcywgbmF0aXZlUGFyZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5pbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5pbnNlcnRSdWxlKHJ1bGVzLmluZGV4W2ldLCBpLCBuYXRpdmVQYXJlbnQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IGEgcnVsZSBpbnRvIGVsZW1lbnQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluc2VydFJ1bGUgPSBmdW5jdGlvbiBpbnNlcnRSdWxlKHJ1bGUsIGluZGV4LCBuYXRpdmVQYXJlbnQpIHtcbiAgICBpZiAobmF0aXZlUGFyZW50ID09PSB2b2lkIDApIHtcbiAgICAgIG5hdGl2ZVBhcmVudCA9IHRoaXMuZWxlbWVudC5zaGVldDtcbiAgICB9XG5cbiAgICBpZiAocnVsZS5ydWxlcykge1xuICAgICAgdmFyIHBhcmVudCA9IHJ1bGU7XG4gICAgICB2YXIgbGF0ZXN0TmF0aXZlUGFyZW50ID0gbmF0aXZlUGFyZW50O1xuXG4gICAgICBpZiAocnVsZS50eXBlID09PSAnY29uZGl0aW9uYWwnIHx8IHJ1bGUudHlwZSA9PT0gJ2tleWZyYW1lcycpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byByZW5kZXIgdGhlIGNvbnRhaW5lciB3aXRob3V0IGNoaWxkcmVuIGZpcnN0LlxuICAgICAgICBsYXRlc3ROYXRpdmVQYXJlbnQgPSBfaW5zZXJ0UnVsZShuYXRpdmVQYXJlbnQsIHBhcmVudC50b1N0cmluZyh7XG4gICAgICAgICAgY2hpbGRyZW46IGZhbHNlXG4gICAgICAgIH0pLCBpbmRleCk7XG5cbiAgICAgICAgaWYgKGxhdGVzdE5hdGl2ZVBhcmVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5pbnNlcnRSdWxlcyhwYXJlbnQucnVsZXMsIGxhdGVzdE5hdGl2ZVBhcmVudCk7XG4gICAgICByZXR1cm4gbGF0ZXN0TmF0aXZlUGFyZW50O1xuICAgIH0gLy8gSUUga2VlcHMgdGhlIENTU1N0eWxlU2hlZXQgYWZ0ZXIgc3R5bGUgbm9kZSBoYXMgYmVlbiByZWF0dGFjaGVkLFxuICAgIC8vIHNvIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIGByZW5kZXJhYmxlYCByZWZlcmVuY2UgdGhlIHJpZ2h0IHN0eWxlIHNoZWV0IGFuZCBub3RcbiAgICAvLyByZXJlbmRlciB0aG9zZSBydWxlcy5cblxuXG4gICAgaWYgKHJ1bGUucmVuZGVyYWJsZSAmJiBydWxlLnJlbmRlcmFibGUucGFyZW50U3R5bGVTaGVldCA9PT0gdGhpcy5lbGVtZW50LnNoZWV0KSB7XG4gICAgICByZXR1cm4gcnVsZS5yZW5kZXJhYmxlO1xuICAgIH1cblxuICAgIHZhciBydWxlU3RyID0gcnVsZS50b1N0cmluZygpO1xuICAgIGlmICghcnVsZVN0cikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIG5hdGl2ZVJ1bGUgPSBfaW5zZXJ0UnVsZShuYXRpdmVQYXJlbnQsIHJ1bGVTdHIsIGluZGV4KTtcblxuICAgIGlmIChuYXRpdmVSdWxlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuaGFzSW5zZXJ0ZWRSdWxlcyA9IHRydWU7XG4gICAgcnVsZS5yZW5kZXJhYmxlID0gbmF0aXZlUnVsZTtcbiAgICByZXR1cm4gbmF0aXZlUnVsZTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVsZXRlUnVsZSA9IGZ1bmN0aW9uIGRlbGV0ZVJ1bGUoY3NzUnVsZSkge1xuICAgIHZhciBzaGVldCA9IHRoaXMuZWxlbWVudC5zaGVldDtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YoY3NzUnVsZSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgIHNoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5kZXggb2YgYSBDU1MgUnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YoY3NzUnVsZSkge1xuICAgIHZhciBjc3NSdWxlcyA9IHRoaXMuZWxlbWVudC5zaGVldC5jc3NSdWxlcztcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBjc3NSdWxlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGlmIChjc3NSdWxlID09PSBjc3NSdWxlc1tpbmRleF0pIHJldHVybiBpbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgbmV3IENTUyBydWxlIGFuZCByZXBsYWNlIHRoZSBleGlzdGluZyBvbmUuXG4gICAqXG4gICAqIE9ubHkgdXNlZCBmb3Igc29tZSBvbGQgYnJvd3NlcnMgYmVjYXVzZSB0aGV5IGNhbid0IHNldCBhIHNlbGVjdG9yLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXBsYWNlUnVsZSA9IGZ1bmN0aW9uIHJlcGxhY2VSdWxlKGNzc1J1bGUsIHJ1bGUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YoY3NzUnVsZSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuZWxlbWVudC5zaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFsbCBydWxlcyBlbGVtZW50cy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0UnVsZXMgPSBmdW5jdGlvbiBnZXRSdWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LnNoZWV0LmNzc1J1bGVzO1xuICB9O1xuXG4gIHJldHVybiBEb21SZW5kZXJlcjtcbn0oKTtcblxudmFyIGluc3RhbmNlQ291bnRlciA9IDA7XG5cbnZhciBKc3MgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBKc3Mob3B0aW9ucykge1xuICAgIHRoaXMuaWQgPSBpbnN0YW5jZUNvdW50ZXIrKztcbiAgICB0aGlzLnZlcnNpb24gPSBcIjEwLjMuMFwiO1xuICAgIHRoaXMucGx1Z2lucyA9IG5ldyBQbHVnaW5zUmVnaXN0cnkoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBpZDoge1xuICAgICAgICBtaW5pZnk6IGZhbHNlXG4gICAgICB9LFxuICAgICAgY3JlYXRlR2VuZXJhdGVJZDogY3JlYXRlR2VuZXJhdGVJZCxcbiAgICAgIFJlbmRlcmVyOiBpc0luQnJvd3NlciA/IERvbVJlbmRlcmVyIDogbnVsbCxcbiAgICAgIHBsdWdpbnM6IFtdXG4gICAgfTtcbiAgICB0aGlzLmdlbmVyYXRlSWQgPSBjcmVhdGVHZW5lcmF0ZUlkKHtcbiAgICAgIG1pbmlmeTogZmFsc2VcbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5wbHVnaW5zLnVzZShwbHVnaW5zW2ldLCB7XG4gICAgICAgIHF1ZXVlOiAnaW50ZXJuYWwnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnNldHVwKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBQcmVwYXJlcyB2YXJpb3VzIG9wdGlvbnMsIGFwcGxpZXMgcGx1Z2lucy5cbiAgICogU2hvdWxkIG5vdCBiZSB1c2VkIHR3aWNlIG9uIHRoZSBzYW1lIGluc3RhbmNlLCBiZWNhdXNlIHRoZXJlIGlzIG5vIHBsdWdpbnNcbiAgICogZGVkdXBsaWNhdGlvbiBsb2dpYy5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gSnNzLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0dXAgPSBmdW5jdGlvbiBzZXR1cChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNyZWF0ZUdlbmVyYXRlSWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkID0gb3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmlkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuaWQgPSBfZXh0ZW5kcyh7fSwgdGhpcy5vcHRpb25zLmlkLCBvcHRpb25zLmlkKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkIHx8IG9wdGlvbnMuaWQpIHtcbiAgICAgIHRoaXMuZ2VuZXJhdGVJZCA9IHRoaXMub3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkKHRoaXMub3B0aW9ucy5pZCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgIT0gbnVsbCkgdGhpcy5vcHRpb25zLmluc2VydGlvblBvaW50ID0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludDtcblxuICAgIGlmICgnUmVuZGVyZXInIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5SZW5kZXJlciA9IG9wdGlvbnMuUmVuZGVyZXI7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxuXG5cbiAgICBpZiAob3B0aW9ucy5wbHVnaW5zKSB0aGlzLnVzZS5hcHBseSh0aGlzLCBvcHRpb25zLnBsdWdpbnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBTdHlsZSBTaGVldC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uY3JlYXRlU3R5bGVTaGVldCA9IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlU2hlZXQoc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICAgIGluZGV4ID0gX29wdGlvbnMuaW5kZXg7XG5cbiAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgaW5kZXggPSBzaGVldHMuaW5kZXggPT09IDAgPyAwIDogc2hlZXRzLmluZGV4ICsgMTtcbiAgICB9XG5cbiAgICB2YXIgc2hlZXQgPSBuZXcgU3R5bGVTaGVldChzdHlsZXMsIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBqc3M6IHRoaXMsXG4gICAgICBnZW5lcmF0ZUlkOiBvcHRpb25zLmdlbmVyYXRlSWQgfHwgdGhpcy5nZW5lcmF0ZUlkLFxuICAgICAgaW5zZXJ0aW9uUG9pbnQ6IHRoaXMub3B0aW9ucy5pbnNlcnRpb25Qb2ludCxcbiAgICAgIFJlbmRlcmVyOiB0aGlzLm9wdGlvbnMuUmVuZGVyZXIsXG4gICAgICBpbmRleDogaW5kZXhcbiAgICB9KSk7XG4gICAgdGhpcy5wbHVnaW5zLm9uUHJvY2Vzc1NoZWV0KHNoZWV0KTtcbiAgICByZXR1cm4gc2hlZXQ7XG4gIH1cbiAgLyoqXG4gICAqIERldGFjaCB0aGUgU3R5bGUgU2hlZXQgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSByZWdpc3RyeS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVtb3ZlU3R5bGVTaGVldCA9IGZ1bmN0aW9uIHJlbW92ZVN0eWxlU2hlZXQoc2hlZXQpIHtcbiAgICBzaGVldC5kZXRhY2goKTtcbiAgICBzaGVldHMucmVtb3ZlKHNoZWV0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgcnVsZSB3aXRob3V0IGEgU3R5bGUgU2hlZXQuXG4gICAqIFtEZXByZWNhdGVkXSB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uY3JlYXRlUnVsZSA9IGZ1bmN0aW9uIGNyZWF0ZVJ1bGUkMShuYW1lLCBzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmIChzdHlsZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzdHlsZSA9IHt9O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBFbmFibGUgcnVsZSB3aXRob3V0IG5hbWUgZm9yIGlubGluZSBzdHlsZXMuXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUnVsZSh1bmRlZmluZWQsIG5hbWUsIHN0eWxlKTtcbiAgICB9XG5cbiAgICB2YXIgcnVsZU9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGpzczogdGhpcyxcbiAgICAgIFJlbmRlcmVyOiB0aGlzLm9wdGlvbnMuUmVuZGVyZXJcbiAgICB9KTtcblxuICAgIGlmICghcnVsZU9wdGlvbnMuZ2VuZXJhdGVJZCkgcnVsZU9wdGlvbnMuZ2VuZXJhdGVJZCA9IHRoaXMuZ2VuZXJhdGVJZDtcbiAgICBpZiAoIXJ1bGVPcHRpb25zLmNsYXNzZXMpIHJ1bGVPcHRpb25zLmNsYXNzZXMgPSB7fTtcbiAgICBpZiAoIXJ1bGVPcHRpb25zLmtleWZyYW1lcykgcnVsZU9wdGlvbnMua2V5ZnJhbWVzID0ge307XG5cbiAgICB2YXIgcnVsZSA9IGNyZWF0ZVJ1bGUobmFtZSwgc3R5bGUsIHJ1bGVPcHRpb25zKTtcblxuICAgIGlmIChydWxlKSB0aGlzLnBsdWdpbnMub25Qcm9jZXNzUnVsZShydWxlKTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgcGx1Z2luLiBQYXNzZWQgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIHdpdGggYSBydWxlIGluc3RhbmNlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51c2UgPSBmdW5jdGlvbiB1c2UoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgcGx1Z2luc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgX3RoaXMucGx1Z2lucy51c2UocGx1Z2luKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gSnNzO1xufSgpO1xuXG4vKipcbiAqIEV4dHJhY3RzIGEgc3R5bGVzIG9iamVjdCB3aXRoIG9ubHkgcHJvcHMgdGhhdCBjb250YWluIGZ1bmN0aW9uIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0RHluYW1pY1N0eWxlcyhzdHlsZXMpIHtcbiAgdmFyIHRvID0gbnVsbDtcblxuICBmb3IgKHZhciBrZXkgaW4gc3R5bGVzKSB7XG4gICAgdmFyIHZhbHVlID0gc3R5bGVzW2tleV07XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKCF0bykgdG8gPSB7fTtcbiAgICAgIHRvW2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFyIGV4dHJhY3RlZCA9IGdldER5bmFtaWNTdHlsZXModmFsdWUpO1xuXG4gICAgICBpZiAoZXh0cmFjdGVkKSB7XG4gICAgICAgIGlmICghdG8pIHRvID0ge307XG4gICAgICAgIHRvW2tleV0gPSBleHRyYWN0ZWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRvO1xufVxuXG4vKipcbiAqIFNoZWV0c01hbmFnZXIgaXMgbGlrZSBhIFdlYWtNYXAgd2hpY2ggaXMgZGVzaWduZWQgdG8gY291bnQgU3R5bGVTaGVldFxuICogaW5zdGFuY2VzIGFuZCBhdHRhY2gvZGV0YWNoIGF1dG9tYXRpY2FsbHkuXG4gKi9cbnZhciBTaGVldHNNYW5hZ2VyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2hlZXRzTWFuYWdlcigpIHtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5zaGVldHMgPSBuZXcgV2Vha01hcCgpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNoZWV0c01hbmFnZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5zaGVldHMuZ2V0KGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnNoZWV0O1xuICB9O1xuXG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQoa2V5LCBzaGVldCkge1xuICAgIGlmICh0aGlzLnNoZWV0cy5oYXMoa2V5KSkgcmV0dXJuO1xuICAgIHRoaXMubGVuZ3RoKys7XG4gICAgdGhpcy5zaGVldHMuc2V0KGtleSwge1xuICAgICAgc2hlZXQ6IHNoZWV0LFxuICAgICAgcmVmczogMFxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5tYW5hZ2UgPSBmdW5jdGlvbiBtYW5hZ2Uoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5zaGVldHMuZ2V0KGtleSk7XG5cbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGlmIChlbnRyeS5yZWZzID09PSAwKSB7XG4gICAgICAgIGVudHJ5LnNoZWV0LmF0dGFjaCgpO1xuICAgICAgfVxuXG4gICAgICBlbnRyeS5yZWZzKys7XG4gICAgICByZXR1cm4gZW50cnkuc2hlZXQ7XG4gICAgfVxuXG4gICAgd2FybmluZyhmYWxzZSwgXCJbSlNTXSBTaGVldHNNYW5hZ2VyOiBjYW4ndCBmaW5kIHNoZWV0IHRvIG1hbmFnZVwiKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIF9wcm90by51bm1hbmFnZSA9IGZ1bmN0aW9uIHVubWFuYWdlKGtleSkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuc2hlZXRzLmdldChrZXkpO1xuXG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBpZiAoZW50cnkucmVmcyA+IDApIHtcbiAgICAgICAgZW50cnkucmVmcy0tO1xuICAgICAgICBpZiAoZW50cnkucmVmcyA9PT0gMCkgZW50cnkuc2hlZXQuZGV0YWNoKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsIFwiU2hlZXRzTWFuYWdlcjogY2FuJ3QgZmluZCBzaGVldCB0byB1bm1hbmFnZVwiKTtcbiAgICB9XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFNoZWV0c01hbmFnZXIsIFt7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2hlZXRzTWFuYWdlcjtcbn0oKTtcblxuLyoqXG4gKiBBIGJldHRlciBhYnN0cmFjdGlvbiBvdmVyIENTUy5cbiAqXG4gKiBAY29weXJpZ2h0IE9sZWcgSXNvbmVuIChTbG9ib2Rza29pKSAvIElzb25lbiAyMDE0LXByZXNlbnRcbiAqIEB3ZWJzaXRlIGh0dHBzOi8vZ2l0aHViLmNvbS9jc3NpbmpzL2pzc1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuLyoqXG4gKiBFeHBvcnQgYSBjb25zdGFudCBpbmRpY2F0aW5nIGlmIHRoaXMgYnJvd3NlciBoYXMgQ1NTVE9NIHN1cHBvcnQuXG4gKiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDE4LzAzL2Nzc29tXG4gKi9cbnZhciBoYXNDU1NUT01TdXBwb3J0ID0gdHlwZW9mIENTUyAhPT0gJ3VuZGVmaW5lZCcgJiYgQ1NTICYmICdudW1iZXInIGluIENTUztcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBKc3MuXG4gKi9cblxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgSnNzKG9wdGlvbnMpO1xufTtcbi8qKlxuICogQSBnbG9iYWwgSnNzIGluc3RhbmNlLlxuICovXG5cbnZhciBpbmRleCA9IGNyZWF0ZSgpO1xuXG5leHBvcnRzLlJ1bGVMaXN0ID0gUnVsZUxpc3Q7XG5leHBvcnRzLlNoZWV0c01hbmFnZXIgPSBTaGVldHNNYW5hZ2VyO1xuZXhwb3J0cy5TaGVldHNSZWdpc3RyeSA9IFNoZWV0c1JlZ2lzdHJ5O1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmNyZWF0ZUdlbmVyYXRlSWQgPSBjcmVhdGVHZW5lcmF0ZUlkO1xuZXhwb3J0cy5jcmVhdGVSdWxlID0gY3JlYXRlUnVsZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGluZGV4O1xuZXhwb3J0cy5nZXREeW5hbWljU3R5bGVzID0gZ2V0RHluYW1pY1N0eWxlcztcbmV4cG9ydHMuaGFzQ1NTVE9NU3VwcG9ydCA9IGhhc0NTU1RPTVN1cHBvcnQ7XG5leHBvcnRzLnNoZWV0cyA9IHNoZWV0cztcbmV4cG9ydHMudG9Dc3NWYWx1ZSA9IHRvQ3NzVmFsdWU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29uc3RhbnRzLlxuICovXG5cbnZhciBlcnJvck1lc3NhZ2U7XG5cbmVycm9yTWVzc2FnZSA9ICdBbiBhcmd1bWVudCB3aXRob3V0IGFwcGVuZCwgcHJlcGVuZCwgJyArXG4gICAgJ29yIGRldGFjaCBtZXRob2RzIHdhcyBnaXZlbiB0byBgTGlzdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBMaXN0OiBBIGxpbmtlZCBsaXN0IGlzIGEgYml0IGxpa2UgYW4gQXJyYXksIGJ1dFxuICoga25vd3Mgbm90aGluZyBhYm91dCBob3cgbWFueSBpdGVtcyBhcmUgaW4gaXQsIGFuZCBrbm93cyBvbmx5IGFib3V0IGl0c1xuICogZmlyc3QgKGBoZWFkYCkgYW5kIGxhc3QgKGB0YWlsYCkgaXRlbXMuIEVhY2ggaXRlbSAoZS5nLiBgaGVhZGAsIGB0YWlsYCxcbiAqICZjLikga25vd3Mgd2hpY2ggaXRlbSBjb21lcyBiZWZvcmUgb3IgYWZ0ZXIgaXQgKGl0cyBtb3JlIGxpa2UgdGhlXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgRE9NIGluIEphdmFTY3JpcHQpLlxuICogQGdsb2JhbFxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGNsYXNzIFJlcHJlc2VudHMgYW4gaW5zdGFuY2Ugb2YgTGlzdC5cbiAqL1xuXG5mdW5jdGlvbiBMaXN0KC8qaXRlbXMuLi4qLykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBMaXN0LmZyb20oYXJndW1lbnRzKTtcbiAgICB9XG59XG5cbnZhciBMaXN0UHJvdG90eXBlO1xuXG5MaXN0UHJvdG90eXBlID0gTGlzdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBsaXN0IGZyb20gdGhlIGFyZ3VtZW50cyAoZWFjaCBhIGxpc3QgaXRlbSkgcGFzc2VkIGluLlxuICogQG5hbWUgTGlzdC5vZlxuICogQHBhcmFtIHsuLi5MaXN0SXRlbX0gW2l0ZW1zXSAtIFplcm8gb3IgbW9yZSBpdGVtcyB0byBhdHRhY2guXG4gKiBAcmV0dXJucyB7bGlzdH0gLSBBIG5ldyBpbnN0YW5jZSBvZiBMaXN0LlxuICovXG5cbkxpc3Qub2YgPSBmdW5jdGlvbiAoLyppdGVtcy4uLiovKSB7XG4gICAgcmV0dXJuIExpc3QuZnJvbS5jYWxsKHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbGlzdCBmcm9tIHRoZSBnaXZlbiBhcnJheS1saWtlIG9iamVjdCAoZWFjaCBhIGxpc3QgaXRlbSlcbiAqIHBhc3NlZCBpbi5cbiAqIEBuYW1lIExpc3QuZnJvbVxuICogQHBhcmFtIHtMaXN0SXRlbVtdfSBbaXRlbXNdIC0gVGhlIGl0ZW1zIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtsaXN0fSAtIEEgbmV3IGluc3RhbmNlIG9mIExpc3QuXG4gKi9cbkxpc3QuZnJvbSA9IGZ1bmN0aW9uIChpdGVtcykge1xuICAgIHZhciBsaXN0ID0gbmV3IHRoaXMoKSwgbGVuZ3RoLCBpdGVyYXRvciwgaXRlbTtcblxuICAgIGlmIChpdGVtcyAmJiAobGVuZ3RoID0gaXRlbXMubGVuZ3RoKSkge1xuICAgICAgICBpdGVyYXRvciA9IC0xO1xuXG4gICAgICAgIHdoaWxlICgrK2l0ZXJhdG9yIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVtID0gaXRlbXNbaXRlcmF0b3JdO1xuXG4gICAgICAgICAgICBpZiAoaXRlbSAhPT0gbnVsbCAmJiBpdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsaXN0LmFwcGVuZChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xufTtcblxuLyoqXG4gKiBMaXN0I2hlYWRcbiAqIERlZmF1bHQgdG8gYG51bGxgLlxuICovXG5MaXN0UHJvdG90eXBlLmhlYWQgPSBudWxsO1xuXG4vKipcbiAqIExpc3QjdGFpbFxuICogRGVmYXVsdCB0byBgbnVsbGAuXG4gKi9cbkxpc3RQcm90b3R5cGUudGFpbCA9IG51bGw7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGlzdCdzIGl0ZW1zIGFzIGFuIGFycmF5LiBUaGlzIGRvZXMgKm5vdCogZGV0YWNoIHRoZSBpdGVtcy5cbiAqIEBuYW1lIExpc3QjdG9BcnJheVxuICogQHJldHVybnMge0xpc3RJdGVtW119IC0gQW4gYXJyYXkgb2YgKHN0aWxsIGF0dGFjaGVkKSBMaXN0SXRlbXMuXG4gKi9cbkxpc3RQcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaXRlbSA9IHRoaXMuaGVhZCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoaXRlbSkge1xuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgaXRlbSA9IGl0ZW0ubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBQcmVwZW5kcyB0aGUgZ2l2ZW4gaXRlbSB0byB0aGUgbGlzdDogSXRlbSB3aWxsIGJlIHRoZSBuZXcgZmlyc3QgaXRlbVxuICogKGBoZWFkYCkuXG4gKiBAbmFtZSBMaXN0I3ByZXBlbmRcbiAqIEBwYXJhbSB7TGlzdEl0ZW19IGl0ZW0gLSBUaGUgaXRlbSB0byBwcmVwZW5kLlxuICogQHJldHVybnMge0xpc3RJdGVtfSAtIEFuIGluc3RhbmNlIG9mIExpc3RJdGVtICh0aGUgZ2l2ZW4gaXRlbSkuXG4gKi9cbkxpc3RQcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWl0ZW0uYXBwZW5kIHx8ICFpdGVtLnByZXBlbmQgfHwgIWl0ZW0uZGV0YWNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UgKyAnI3ByZXBlbmRgLicpO1xuICAgIH1cblxuICAgIHZhciBzZWxmLCBoZWFkO1xuXG4gICAgLy8gQ2FjaGUgc2VsZi5cbiAgICBzZWxmID0gdGhpcztcblxuICAgIC8vIElmIHNlbGYgaGFzIGEgZmlyc3QgaXRlbSwgZGVmZXIgcHJlcGVuZCB0byB0aGUgZmlyc3QgaXRlbXMgcHJlcGVuZFxuICAgIC8vIG1ldGhvZCwgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICAgIGhlYWQgPSBzZWxmLmhlYWQ7XG5cbiAgICBpZiAoaGVhZCkge1xuICAgICAgICByZXR1cm4gaGVhZC5wcmVwZW5kKGl0ZW0pO1xuICAgIH1cblxuICAgIC8vIC4uLm90aGVyd2lzZSwgdGhlcmUgaXMgbm8gYGhlYWRgIChvciBgdGFpbGApIGl0ZW0geWV0LlxuXG4gICAgLy8gRGV0YWNoIHRoZSBwcmVwZW5kZWUuXG4gICAgaXRlbS5kZXRhY2goKTtcblxuICAgIC8vIFNldCB0aGUgcHJlcGVuZGVlcyBwYXJlbnQgbGlzdCB0byByZWZlcmVuY2Ugc2VsZi5cbiAgICBpdGVtLmxpc3QgPSBzZWxmO1xuXG4gICAgLy8gU2V0IHNlbGYncyBmaXJzdCBpdGVtIHRvIHRoZSBwcmVwZW5kZWUsIGFuZCByZXR1cm4gdGhlIGl0ZW0uXG4gICAgc2VsZi5oZWFkID0gaXRlbTtcblxuICAgIHJldHVybiBpdGVtO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBnaXZlbiBpdGVtIHRvIHRoZSBsaXN0OiBJdGVtIHdpbGwgYmUgdGhlIG5ldyBsYXN0IGl0ZW0gKGB0YWlsYClcbiAqIGlmIHRoZSBsaXN0IGhhZCBhIGZpcnN0IGl0ZW0sIGFuZCBpdHMgZmlyc3QgaXRlbSAoYGhlYWRgKSBvdGhlcndpc2UuXG4gKiBAbmFtZSBMaXN0I2FwcGVuZFxuICogQHBhcmFtIHtMaXN0SXRlbX0gaXRlbSAtIFRoZSBpdGVtIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtMaXN0SXRlbX0gLSBBbiBpbnN0YW5jZSBvZiBMaXN0SXRlbSAodGhlIGdpdmVuIGl0ZW0pLlxuICovXG5cbkxpc3RQcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghaXRlbS5hcHBlbmQgfHwgIWl0ZW0ucHJlcGVuZCB8fCAhaXRlbS5kZXRhY2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSArICcjYXBwZW5kYC4nKTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiwgaGVhZCwgdGFpbDtcblxuICAgIC8vIENhY2hlIHNlbGYuXG4gICAgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBJZiBzZWxmIGhhcyBhIGxhc3QgaXRlbSwgZGVmZXIgYXBwZW5kaW5nIHRvIHRoZSBsYXN0IGl0ZW1zIGFwcGVuZFxuICAgIC8vIG1ldGhvZCwgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICAgIHRhaWwgPSBzZWxmLnRhaWw7XG5cbiAgICBpZiAodGFpbCkge1xuICAgICAgICByZXR1cm4gdGFpbC5hcHBlbmQoaXRlbSk7XG4gICAgfVxuXG4gICAgLy8gSWYgc2VsZiBoYXMgYSBmaXJzdCBpdGVtLCBkZWZlciBhcHBlbmRpbmcgdG8gdGhlIGZpcnN0IGl0ZW1zIGFwcGVuZFxuICAgIC8vIG1ldGhvZCwgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICAgIGhlYWQgPSBzZWxmLmhlYWQ7XG5cbiAgICBpZiAoaGVhZCkge1xuICAgICAgICByZXR1cm4gaGVhZC5hcHBlbmQoaXRlbSk7XG4gICAgfVxuXG4gICAgLy8gLi4ub3RoZXJ3aXNlLCB0aGVyZSBpcyBubyBgdGFpbGAgb3IgYGhlYWRgIGl0ZW0geWV0LlxuXG4gICAgLy8gRGV0YWNoIHRoZSBhcHBlbmRlZS5cbiAgICBpdGVtLmRldGFjaCgpO1xuXG4gICAgLy8gU2V0IHRoZSBhcHBlbmRlZXMgcGFyZW50IGxpc3QgdG8gcmVmZXJlbmNlIHNlbGYuXG4gICAgaXRlbS5saXN0ID0gc2VsZjtcblxuICAgIC8vIFNldCBzZWxmJ3MgZmlyc3QgaXRlbSB0byB0aGUgYXBwZW5kZWUsIGFuZCByZXR1cm4gdGhlIGl0ZW0uXG4gICAgc2VsZi5oZWFkID0gaXRlbTtcblxuICAgIHJldHVybiBpdGVtO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IExpc3RJdGVtOiBBIGxpbmtlZCBsaXN0IGl0ZW0gaXMgYSBiaXQgbGlrZSBET00gbm9kZTpcbiAqIEl0IGtub3dzIG9ubHkgYWJvdXQgaXRzIFwicGFyZW50XCIgKGBsaXN0YCksIHRoZSBpdGVtIGJlZm9yZSBpdCAoYHByZXZgKSxcbiAqIGFuZCB0aGUgaXRlbSBhZnRlciBpdCAoYG5leHRgKS5cbiAqIEBnbG9iYWxcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBjbGFzcyBSZXByZXNlbnRzIGFuIGluc3RhbmNlIG9mIExpc3RJdGVtLlxuICovXG5cbmZ1bmN0aW9uIExpc3RJdGVtKCkge31cblxuTGlzdC5JdGVtID0gTGlzdEl0ZW07XG5cbnZhciBMaXN0SXRlbVByb3RvdHlwZSA9IExpc3RJdGVtLnByb3RvdHlwZTtcblxuTGlzdEl0ZW1Qcm90b3R5cGUubmV4dCA9IG51bGw7XG5cbkxpc3RJdGVtUHJvdG90eXBlLnByZXYgPSBudWxsO1xuXG5MaXN0SXRlbVByb3RvdHlwZS5saXN0ID0gbnVsbDtcblxuLyoqXG4gKiBEZXRhY2hlcyB0aGUgaXRlbSBvcGVyYXRlZCBvbiBmcm9tIGl0cyBwYXJlbnQgbGlzdC5cbiAqIEBuYW1lIExpc3RJdGVtI2RldGFjaFxuICogQHJldHVybnMge0xpc3RJdGVtfSAtIFRoZSBpdGVtIG9wZXJhdGVkIG9uLlxuICovXG5MaXN0SXRlbVByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQ2FjaGUgc2VsZiwgdGhlIHBhcmVudCBsaXN0LCBhbmQgdGhlIHByZXZpb3VzIGFuZCBuZXh0IGl0ZW1zLlxuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgbGlzdCA9IHNlbGYubGlzdCxcbiAgICAgICAgcHJldiA9IHNlbGYucHJldixcbiAgICAgICAgbmV4dCA9IHNlbGYubmV4dDtcblxuICAgIC8vIElmIHRoZSBpdGVtIGlzIGFscmVhZHkgZGV0YWNoZWQsIHJldHVybiBzZWxmLlxuICAgIGlmICghbGlzdCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBJZiBzZWxmIGlzIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIHBhcmVudCBsaXN0LCBsaW5rIHRoZSBsaXN0cyBsYXN0IGl0ZW1cbiAgICAvLyB0byB0aGUgcHJldmlvdXMgaXRlbS5cbiAgICBpZiAobGlzdC50YWlsID09PSBzZWxmKSB7XG4gICAgICAgIGxpc3QudGFpbCA9IHByZXY7XG4gICAgfVxuXG4gICAgLy8gSWYgc2VsZiBpcyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgcGFyZW50IGxpc3QsIGxpbmsgdGhlIGxpc3RzIGZpcnN0IGl0ZW1cbiAgICAvLyB0byB0aGUgbmV4dCBpdGVtLlxuICAgIGlmIChsaXN0LmhlYWQgPT09IHNlbGYpIHtcbiAgICAgICAgbGlzdC5oZWFkID0gbmV4dDtcbiAgICB9XG5cbiAgICAvLyBJZiBib3RoIHRoZSBsYXN0IGFuZCBmaXJzdCBpdGVtcyBpbiB0aGUgcGFyZW50IGxpc3QgYXJlIHRoZSBzYW1lLFxuICAgIC8vIHJlbW92ZSB0aGUgbGluayB0byB0aGUgbGFzdCBpdGVtLlxuICAgIGlmIChsaXN0LnRhaWwgPT09IGxpc3QuaGVhZCkge1xuICAgICAgICBsaXN0LnRhaWwgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIElmIGEgcHJldmlvdXMgaXRlbSBleGlzdHMsIGxpbmsgaXRzIG5leHQgaXRlbSB0byBzZWxmcyBuZXh0IGl0ZW0uXG4gICAgaWYgKHByZXYpIHtcbiAgICAgICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgICB9XG5cbiAgICAvLyBJZiBhIG5leHQgaXRlbSBleGlzdHMsIGxpbmsgaXRzIHByZXZpb3VzIGl0ZW0gdG8gc2VsZnMgcHJldmlvdXMgaXRlbS5cbiAgICBpZiAobmV4dCkge1xuICAgICAgICBuZXh0LnByZXYgPSBwcmV2O1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBsaW5rcyBmcm9tIHNlbGYgdG8gYm90aCB0aGUgbmV4dCBhbmQgcHJldmlvdXMgaXRlbXMsIGFuZCB0byB0aGVcbiAgICAvLyBwYXJlbnQgbGlzdC5cbiAgICBzZWxmLnByZXYgPSBzZWxmLm5leHQgPSBzZWxmLmxpc3QgPSBudWxsO1xuXG4gICAgLy8gUmV0dXJuIHNlbGYuXG4gICAgcmV0dXJuIHNlbGY7XG59O1xuXG4vKipcbiAqIFByZXBlbmRzIHRoZSBnaXZlbiBpdGVtICpiZWZvcmUqIHRoZSBpdGVtIG9wZXJhdGVkIG9uLlxuICogQG5hbWUgTGlzdEl0ZW0jcHJlcGVuZFxuICogQHBhcmFtIHtMaXN0SXRlbX0gaXRlbSAtIFRoZSBpdGVtIHRvIHByZXBlbmQuXG4gKiBAcmV0dXJucyB7TGlzdEl0ZW19IC0gVGhlIGl0ZW0gb3BlcmF0ZWQgb24sIG9yIGZhbHNlIHdoZW4gdGhhdCBpdGVtIGlzIG5vdFxuICogYXR0YWNoZWQuXG4gKi9cbkxpc3RJdGVtUHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmICghaXRlbSB8fCAhaXRlbS5hcHBlbmQgfHwgIWl0ZW0ucHJlcGVuZCB8fCAhaXRlbS5kZXRhY2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSArICdJdGVtI3ByZXBlbmRgLicpO1xuICAgIH1cblxuICAgIC8vIENhY2hlIHNlbGYsIHRoZSBwYXJlbnQgbGlzdCwgYW5kIHRoZSBwcmV2aW91cyBpdGVtLlxuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgbGlzdCA9IHNlbGYubGlzdCxcbiAgICAgICAgcHJldiA9IHNlbGYucHJldjtcblxuICAgIC8vIElmIHNlbGYgaXMgZGV0YWNoZWQsIHJldHVybiBmYWxzZS5cbiAgICBpZiAoIWxpc3QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIERldGFjaCB0aGUgcHJlcGVuZGVlLlxuICAgIGl0ZW0uZGV0YWNoKCk7XG5cbiAgICAvLyBJZiBzZWxmIGhhcyBhIHByZXZpb3VzIGl0ZW0uLi5cbiAgICBpZiAocHJldikge1xuICAgICAgICAvLyAuLi5saW5rIHRoZSBwcmVwZW5kZWVzIHByZXZpb3VzIGl0ZW0sIHRvIHNlbGZzIHByZXZpb3VzIGl0ZW0uXG4gICAgICAgIGl0ZW0ucHJldiA9IHByZXY7XG5cbiAgICAgICAgLy8gLi4ubGluayB0aGUgcHJldmlvdXMgaXRlbXMgbmV4dCBpdGVtLCB0byBzZWxmLlxuICAgICAgICBwcmV2Lm5leHQgPSBpdGVtO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgcHJlcGVuZGVlcyBuZXh0IGl0ZW0gdG8gc2VsZi5cbiAgICBpdGVtLm5leHQgPSBzZWxmO1xuXG4gICAgLy8gU2V0IHRoZSBwcmVwZW5kZWVzIHBhcmVudCBsaXN0IHRvIHNlbGZzIHBhcmVudCBsaXN0LlxuICAgIGl0ZW0ubGlzdCA9IGxpc3Q7XG5cbiAgICAvLyBTZXQgdGhlIHByZXZpb3VzIGl0ZW0gb2Ygc2VsZiB0byB0aGUgcHJlcGVuZGVlLlxuICAgIHNlbGYucHJldiA9IGl0ZW07XG5cbiAgICAvLyBJZiBzZWxmIGlzIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBwYXJlbnQgbGlzdCwgbGluayB0aGUgbGlzdHMgZmlyc3QgaXRlbVxuICAgIC8vIHRvIHRoZSBwcmVwZW5kZWUuXG4gICAgaWYgKHNlbGYgPT09IGxpc3QuaGVhZCkge1xuICAgICAgICBsaXN0LmhlYWQgPSBpdGVtO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSB0aGUgcGFyZW50IGxpc3QgaGFzIG5vIGxhc3QgaXRlbSwgbGluayB0aGUgbGlzdHMgbGFzdCBpdGVtIHRvXG4gICAgLy8gc2VsZi5cbiAgICBpZiAoIWxpc3QudGFpbCkge1xuICAgICAgICBsaXN0LnRhaWwgPSBzZWxmO1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGUgcHJlcGVuZGVlLlxuICAgIHJldHVybiBpdGVtO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBnaXZlbiBpdGVtICphZnRlciogdGhlIGl0ZW0gb3BlcmF0ZWQgb24uXG4gKiBAbmFtZSBMaXN0SXRlbSNhcHBlbmRcbiAqIEBwYXJhbSB7TGlzdEl0ZW19IGl0ZW0gLSBUaGUgaXRlbSB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7TGlzdEl0ZW19IC0gVGhlIGl0ZW0gb3BlcmF0ZWQgb24sIG9yIGZhbHNlIHdoZW4gdGhhdCBpdGVtIGlzIG5vdFxuICogYXR0YWNoZWQuXG4gKi9cbkxpc3RJdGVtUHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgLy8gSWYgaXRlbSBpcyBmYWxzZXksIHJldHVybiBmYWxzZS5cbiAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0uYXBwZW5kIHx8ICFpdGVtLnByZXBlbmQgfHwgIWl0ZW0uZGV0YWNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UgKyAnSXRlbSNhcHBlbmRgLicpO1xuICAgIH1cblxuICAgIC8vIENhY2hlIHNlbGYsIHRoZSBwYXJlbnQgbGlzdCwgYW5kIHRoZSBuZXh0IGl0ZW0uXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBsaXN0ID0gc2VsZi5saXN0LFxuICAgICAgICBuZXh0ID0gc2VsZi5uZXh0O1xuXG4gICAgLy8gSWYgc2VsZiBpcyBkZXRhY2hlZCwgcmV0dXJuIGZhbHNlLlxuICAgIGlmICghbGlzdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRGV0YWNoIHRoZSBhcHBlbmRlZS5cbiAgICBpdGVtLmRldGFjaCgpO1xuXG4gICAgLy8gSWYgc2VsZiBoYXMgYSBuZXh0IGl0ZW0uLi5cbiAgICBpZiAobmV4dCkge1xuICAgICAgICAvLyAuLi5saW5rIHRoZSBhcHBlbmRlZXMgbmV4dCBpdGVtLCB0byBzZWxmcyBuZXh0IGl0ZW0uXG4gICAgICAgIGl0ZW0ubmV4dCA9IG5leHQ7XG5cbiAgICAgICAgLy8gLi4ubGluayB0aGUgbmV4dCBpdGVtcyBwcmV2aW91cyBpdGVtLCB0byB0aGUgYXBwZW5kZWUuXG4gICAgICAgIG5leHQucHJldiA9IGl0ZW07XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBhcHBlbmRlZXMgcHJldmlvdXMgaXRlbSB0byBzZWxmLlxuICAgIGl0ZW0ucHJldiA9IHNlbGY7XG5cbiAgICAvLyBTZXQgdGhlIGFwcGVuZGVlcyBwYXJlbnQgbGlzdCB0byBzZWxmcyBwYXJlbnQgbGlzdC5cbiAgICBpdGVtLmxpc3QgPSBsaXN0O1xuXG4gICAgLy8gU2V0IHRoZSBuZXh0IGl0ZW0gb2Ygc2VsZiB0byB0aGUgYXBwZW5kZWUuXG4gICAgc2VsZi5uZXh0ID0gaXRlbTtcblxuICAgIC8vIElmIHRoZSB0aGUgcGFyZW50IGxpc3QgaGFzIG5vIGxhc3QgaXRlbSBvciBpZiBzZWxmIGlzIHRoZSBwYXJlbnQgbGlzdHNcbiAgICAvLyBsYXN0IGl0ZW0sIGxpbmsgdGhlIGxpc3RzIGxhc3QgaXRlbSB0byB0aGUgYXBwZW5kZWUuXG4gICAgaWYgKHNlbGYgPT09IGxpc3QudGFpbCB8fCAhbGlzdC50YWlsKSB7XG4gICAgICAgIGxpc3QudGFpbCA9IGl0ZW07XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRoZSBhcHBlbmRlZS5cbiAgICByZXR1cm4gaXRlbTtcbn07XG5cbi8qKlxuICogRXhwb3NlIGBMaXN0YC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fc291cmNlL2xpbmtlZC1saXN0LmpzJyk7XG4iLCJ2YXIgbWFwID0gcmVxdWlyZShcIi4vbWFwXCIpO1xuXG52YXIgZ2V0Q291bnRyeUNvZGUgPSBmdW5jdGlvbihsb2NhbGVTdHJpbmcpIHtcbiAgICB2YXIgY29tcG9uZW50cyA9IGxvY2FsZVN0cmluZy5zcGxpdChcIl9cIik7XG4gICAgaWYgKGNvbXBvbmVudHMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHMucG9wKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudHMgPSBsb2NhbGVTdHJpbmcuc3BsaXQoXCItXCIpO1xuICAgIGlmIChjb21wb25lbnRzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlU3RyaW5nO1xufVxuXG5leHBvcnRzLmdldEN1cnJlbmN5ID0gZnVuY3Rpb24obG9jYWxlKSB7XG4gICAgdmFyIGNvdW50cnlDb2RlID0gZ2V0Q291bnRyeUNvZGUobG9jYWxlKS50b1VwcGVyQ2FzZSgpO1xuICAgIGlmIChjb3VudHJ5Q29kZSBpbiBtYXApIHtcbiAgICAgICAgcmV0dXJuIG1hcFtjb3VudHJ5Q29kZV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5leHBvcnRzLmdldExvY2FsZXMgPSBmdW5jdGlvbihjdXJyZW5jeUNvZGUpIHtcbiAgICBjdXJyZW5jeUNvZGUgPSBjdXJyZW5jeUNvZGUudG9VcHBlckNhc2UoKTtcbiAgICB2YXIgbG9jYWxlcyA9IFtdO1xuICAgIGZvciAoY291bnRyeUNvZGUgaW4gbWFwKSB7XG4gICAgICAgIGlmIChtYXBbY291bnRyeUNvZGVdID09PSBjdXJyZW5jeUNvZGUpIHtcbiAgICAgICAgICAgIGxvY2FsZXMucHVzaChjb3VudHJ5Q29kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZXM7XG59IiwiLy8gR2VuZXJhdGVkIHVzaW5nIFNob3dDdXJyZW5jaWVzLmphdmFcbnZhciBtYXAgPSB7XG5BRDogJ0VVUicsXG5BRTogJ0FFRCcsXG5BRjogJ0FGTicsXG5BRzogJ1hDRCcsXG5BSTogJ1hDRCcsXG5BTDogJ0FMTCcsXG5BTTogJ0FNRCcsXG5BTjogJ0FORycsXG5BTzogJ0FPQScsXG5BUjogJ0FSUycsXG5BUzogJ1VTRCcsXG5BVDogJ0VVUicsXG5BVTogJ0FVRCcsXG5BVzogJ0FXRycsXG5BWDogJ0VVUicsXG5BWjogJ0FaTicsXG5CQTogJ0JBTScsXG5CQjogJ0JCRCcsXG5CRDogJ0JEVCcsXG5CRTogJ0VVUicsXG5CRjogJ1hPRicsXG5CRzogJ0JHTicsXG5CSDogJ0JIRCcsXG5CSTogJ0JJRicsXG5CSjogJ1hPRicsXG5CTDogJ0VVUicsXG5CTTogJ0JNRCcsXG5CTjogJ0JORCcsXG5CTzogJ0JPQicsXG5CUTogJ1VTRCcsXG5CUjogJ0JSTCcsXG5CUzogJ0JTRCcsXG5CVDogJ0JUTicsXG5CVjogJ05PSycsXG5CVzogJ0JXUCcsXG5CWTogJ0JZUicsXG5CWjogJ0JaRCcsXG5DQTogJ0NBRCcsXG5DQzogJ0FVRCcsXG5DRDogJ0NERicsXG5DRjogJ1hBRicsXG5DRzogJ1hBRicsXG5DSDogJ0NIRicsXG5DSTogJ1hPRicsXG5DSzogJ05aRCcsXG5DTDogJ0NMUCcsXG5DTTogJ1hBRicsXG5DTjogJ0NOWScsXG5DTzogJ0NPUCcsXG5DUjogJ0NSQycsXG5DVTogJ0NVUCcsXG5DVjogJ0NWRScsXG5DVzogJ0FORycsXG5DWDogJ0FVRCcsXG5DWTogJ0VVUicsXG5DWjogJ0NaSycsXG5ERTogJ0VVUicsXG5ESjogJ0RKRicsXG5ESzogJ0RLSycsXG5ETTogJ1hDRCcsXG5ETzogJ0RPUCcsXG5EWjogJ0RaRCcsXG5FQzogJ1VTRCcsXG5FRTogJ0VVUicsXG5FRzogJ0VHUCcsXG5FSDogJ01BRCcsXG5FUjogJ0VSTicsXG5FUzogJ0VVUicsXG5FVDogJ0VUQicsXG5GSTogJ0VVUicsXG5GSjogJ0ZKRCcsXG5GSzogJ0ZLUCcsXG5GTTogJ1VTRCcsXG5GTzogJ0RLSycsXG5GUjogJ0VVUicsXG5HQTogJ1hBRicsXG5HQjogJ0dCUCcsXG5HRDogJ1hDRCcsXG5HRTogJ0dFTCcsXG5HRjogJ0VVUicsXG5HRzogJ0dCUCcsXG5HSDogJ0dIUycsXG5HSTogJ0dJUCcsXG5HTDogJ0RLSycsXG5HTTogJ0dNRCcsXG5HTjogJ0dORicsXG5HUDogJ0VVUicsXG5HUTogJ1hBRicsXG5HUjogJ0VVUicsXG5HUzogJ0dCUCcsXG5HVDogJ0dUUScsXG5HVTogJ1VTRCcsXG5HVzogJ1hPRicsXG5HWTogJ0dZRCcsXG5ISzogJ0hLRCcsXG5ITTogJ0FVRCcsXG5ITjogJ0hOTCcsXG5IUjogJ0hSSycsXG5IVDogJ0hURycsXG5IVTogJ0hVRicsXG5JRDogJ0lEUicsXG5JRTogJ0VVUicsXG5JTDogJ0lMUycsXG5JTTogJ0dCUCcsXG5JTjogJ0lOUicsXG5JTzogJ1VTRCcsXG5JUTogJ0lRRCcsXG5JUjogJ0lSUicsXG5JUzogJ0lTSycsXG5JVDogJ0VVUicsXG5KRTogJ0dCUCcsXG5KTTogJ0pNRCcsXG5KTzogJ0pPRCcsXG5KUDogJ0pQWScsXG5LRTogJ0tFUycsXG5LRzogJ0tHUycsXG5LSDogJ0tIUicsXG5LSTogJ0FVRCcsXG5LTTogJ0tNRicsXG5LTjogJ1hDRCcsXG5LUDogJ0tQVycsXG5LUjogJ0tSVycsXG5LVzogJ0tXRCcsXG5LWTogJ0tZRCcsXG5LWjogJ0taVCcsXG5MQTogJ0xBSycsXG5MQjogJ0xCUCcsXG5MQzogJ1hDRCcsXG5MSTogJ0NIRicsXG5MSzogJ0xLUicsXG5MUjogJ0xSRCcsXG5MUzogJ0xTTCcsXG5MVDogJ0xUTCcsXG5MVTogJ0VVUicsXG5MVjogJ0xWTCcsXG5MWTogJ0xZRCcsXG5NQTogJ01BRCcsXG5NQzogJ0VVUicsXG5NRDogJ01ETCcsXG5NRTogJ0VVUicsXG5NRjogJ0VVUicsXG5NRzogJ01HQScsXG5NSDogJ1VTRCcsXG5NSzogJ01LRCcsXG5NTDogJ1hPRicsXG5NTTogJ01NSycsXG5NTjogJ01OVCcsXG5NTzogJ01PUCcsXG5NUDogJ1VTRCcsXG5NUTogJ0VVUicsXG5NUjogJ01STycsXG5NUzogJ1hDRCcsXG5NVDogJ0VVUicsXG5NVTogJ01VUicsXG5NVjogJ01WUicsXG5NVzogJ01XSycsXG5NWDogJ01YTicsXG5NWTogJ01ZUicsXG5NWjogJ01aTicsXG5OQTogJ05BRCcsXG5OQzogJ1hQRicsXG5ORTogJ1hPRicsXG5ORjogJ0FVRCcsXG5ORzogJ05HTicsXG5OSTogJ05JTycsXG5OTDogJ0VVUicsXG5OTzogJ05PSycsXG5OUDogJ05QUicsXG5OUjogJ0FVRCcsXG5OVTogJ05aRCcsXG5OWjogJ05aRCcsXG5PTTogJ09NUicsXG5QQTogJ1BBQicsXG5QRTogJ1BFTicsXG5QRjogJ1hQRicsXG5QRzogJ1BHSycsXG5QSDogJ1BIUCcsXG5QSzogJ1BLUicsXG5QTDogJ1BMTicsXG5QTTogJ0VVUicsXG5QTjogJ05aRCcsXG5QUjogJ1VTRCcsXG5QUzogJ0lMUycsXG5QVDogJ0VVUicsXG5QVzogJ1VTRCcsXG5QWTogJ1BZRycsXG5RQTogJ1FBUicsXG5SRTogJ0VVUicsXG5STzogJ1JPTicsXG5SUzogJ1JTRCcsXG5SVTogJ1JVQicsXG5SVzogJ1JXRicsXG5TQTogJ1NBUicsXG5TQjogJ1NCRCcsXG5TQzogJ1NDUicsXG5TRDogJ1NERycsXG5TRTogJ1NFSycsXG5TRzogJ1NHRCcsXG5TSDogJ1NIUCcsXG5TSTogJ0VVUicsXG5TSjogJ05PSycsXG5TSzogJ0VVUicsXG5TTDogJ1NMTCcsXG5TTTogJ0VVUicsXG5TTjogJ1hPRicsXG5TTzogJ1NPUycsXG5TUjogJ1NSRCcsXG5TVDogJ1NURCcsXG5TVjogJ1NWQycsXG5TWDogJ0FORycsXG5TWTogJ1NZUCcsXG5TWjogJ1NaTCcsXG5UQzogJ1VTRCcsXG5URDogJ1hBRicsXG5URjogJ0VVUicsXG5URzogJ1hPRicsXG5USDogJ1RIQicsXG5USjogJ1RKUycsXG5USzogJ05aRCcsXG5UTDogJ1VTRCcsXG5UTTogJ1RNVCcsXG5UTjogJ1RORCcsXG5UTzogJ1RPUCcsXG5UUjogJ1RSWScsXG5UVDogJ1RURCcsXG5UVjogJ0FVRCcsXG5UVzogJ1RXRCcsXG5UWjogJ1RaUycsXG5VQTogJ1VBSCcsXG5VRzogJ1VHWCcsXG5VTTogJ1VTRCcsXG5VUzogJ1VTRCcsXG5VWTogJ1VZVScsXG5VWjogJ1VaUycsXG5WQTogJ0VVUicsXG5WQzogJ1hDRCcsXG5WRTogJ1ZFRicsXG5WRzogJ1VTRCcsXG5WSTogJ1VTRCcsXG5WTjogJ1ZORCcsXG5WVTogJ1ZVVicsXG5XRjogJ1hQRicsXG5XUzogJ1dTVCcsXG5ZRTogJ1lFUicsXG5ZVDogJ0VVUicsXG5aQTogJ1pBUicsXG5aTTogJ1pNSycsXG5aVzogJ1pXTCdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwOyIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQWdncmVnYXRvcmAgZm9yIGFycmF5cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlBZ2dyZWdhdG9yKGFycmF5LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgYXJyYXkpO1xuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUFnZ3JlZ2F0b3I7XG4iLCJ2YXIgYmFzZUluZGV4T2YgPSByZXF1aXJlKCcuL19iYXNlSW5kZXhPZicpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmNsdWRlc2AgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBzcGVjaWZ5aW5nIGFuIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCAwKSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5SW5jbHVkZXM7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuIiwidmFyIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9fYmFzZUVhY2gnKTtcblxuLyoqXG4gKiBBZ2dyZWdhdGVzIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBvbiBgYWNjdW11bGF0b3JgIHdpdGgga2V5cyB0cmFuc2Zvcm1lZFxuICogYnkgYGl0ZXJhdGVlYCBhbmQgdmFsdWVzIHNldCBieSBgc2V0dGVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFnZ3JlZ2F0b3IoY29sbGVjdGlvbiwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFnZ3JlZ2F0b3I7XG4iLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzJyksXG4gICAgYXJyYXlJbmNsdWRlc1dpdGggPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzV2l0aCcpLFxuICAgIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRpZmZlcmVuY2VgIHdpdGhvdXQgc3VwcG9ydFxuICogZm9yIGV4Y2x1ZGluZyBtdWx0aXBsZSBhcnJheXMgb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgdmFsdWVzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgdmFsdWVzID0gYXJyYXlNYXAodmFsdWVzLCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgfVxuICBpZiAoY29tcGFyYXRvcikge1xuICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgfVxuICBlbHNlIGlmICh2YWx1ZXMubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgdmFsdWVzID0gbmV3IFNldENhY2hlKHZhbHVlcyk7XG4gIH1cbiAgb3V0ZXI6XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID09IG51bGwgPyB2YWx1ZSA6IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgIHZhciB2YWx1ZXNJbmRleCA9IHZhbHVlc0xlbmd0aDtcbiAgICAgIHdoaWxlICh2YWx1ZXNJbmRleC0tKSB7XG4gICAgICAgIGlmICh2YWx1ZXNbdmFsdWVzSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpbmNsdWRlcyh2YWx1ZXMsIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VEaWZmZXJlbmNlO1xuIiwidmFyIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgY3JlYXRlQmFzZUVhY2ggPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRWFjaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRWFjaDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGaW5kSW5kZXg7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNGbGF0dGVuYWJsZSA9IHJlcXVpcmUoJy4vX2lzRmxhdHRlbmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZsYXR0ZW47XG4iLCJ2YXIgYmFzZUZpbmRJbmRleCA9IHJlcXVpcmUoJy4vX2Jhc2VGaW5kSW5kZXgnKSxcbiAgICBiYXNlSXNOYU4gPSByZXF1aXJlKCcuL19iYXNlSXNOYU4nKSxcbiAgICBzdHJpY3RJbmRleE9mID0gcmVxdWlyZSgnLi9fc3RyaWN0SW5kZXhPZicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJbmRleE9mO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYU47XG4iLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJlc3Q7XG4iLCJ2YXIgY29uc3RhbnQgPSByZXF1aXJlKCcuL2NvbnN0YW50JyksXG4gICAgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAnd3JpdGFibGUnOiB0cnVlXG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0VG9TdHJpbmc7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnN1bWAgYW5kIGBfLnN1bUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAqL1xuZnVuY3Rpb24gYmFzZVN1bShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIHJlc3VsdCxcbiAgICAgIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgY3VycmVudCA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSk7XG4gICAgaWYgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBjdXJyZW50IDogKHJlc3VsdCArIGN1cnJlbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTdW07XG4iLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzJyksXG4gICAgYXJyYXlJbmNsdWRlc1dpdGggPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzV2l0aCcpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKSxcbiAgICBjcmVhdGVTZXQgPSByZXF1aXJlKCcuL19jcmVhdGVTZXQnKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICByZXN1bHQgPSBbXSxcbiAgICAgIHNlZW4gPSByZXN1bHQ7XG5cbiAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gIH1cbiAgZWxzZSBpZiAobGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICB2YXIgc2V0ID0gaXRlcmF0ZWUgPyBudWxsIDogY3JlYXRlU2V0KGFycmF5KTtcbiAgICBpZiAoc2V0KSB7XG4gICAgICByZXR1cm4gc2V0VG9BcnJheShzZXQpO1xuICAgIH1cbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgc2VlbiA9IG5ldyBTZXRDYWNoZTtcbiAgfVxuICBlbHNlIHtcbiAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgfVxuICBvdXRlcjpcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcbiAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWluY2x1ZGVzKHNlZW4sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgaWYgKHNlZW4gIT09IHJlc3VsdCkge1xuICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmlxO1xuIiwidmFyIGFycmF5QWdncmVnYXRvciA9IHJlcXVpcmUoJy4vX2FycmF5QWdncmVnYXRvcicpLFxuICAgIGJhc2VBZ2dyZWdhdG9yID0gcmVxdWlyZSgnLi9fYmFzZUFnZ3JlZ2F0b3InKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uZ3JvdXBCeWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbml0aWFsaXplcl0gVGhlIGFjY3VtdWxhdG9yIG9iamVjdCBpbml0aWFsaXplci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFnZ3JlZ2F0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyLCBpbml0aWFsaXplcikge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUFnZ3JlZ2F0b3IgOiBiYXNlQWdncmVnYXRvcixcbiAgICAgICAgYWNjdW11bGF0b3IgPSBpbml0aWFsaXplciA/IGluaXRpYWxpemVyKCkgOiB7fTtcblxuICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIHNldHRlciwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYWNjdW11bGF0b3IpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFnZ3JlZ2F0b3I7XG4iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUVhY2g7XG4iLCJ2YXIgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgbm9vcCA9IHJlcXVpcmUoJy4vbm9vcCcpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNldCBvYmplY3Qgb2YgYHZhbHVlc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFkZCB0byB0aGUgc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHNldC5cbiAqL1xudmFyIGNyZWF0ZVNldCA9ICEoU2V0ICYmICgxIC8gc2V0VG9BcnJheShuZXcgU2V0KFssLTBdKSlbMV0pID09IElORklOSVRZKSA/IG5vb3AgOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBTZXQodmFsdWVzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU2V0O1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbGF0dGVuYWJsZTtcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlclJlc3Q7XG4iLCJ2YXIgYmFzZVNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVNldFRvU3RyaW5nJyksXG4gICAgc2hvcnRPdXQgPSByZXF1aXJlKCcuL19zaG9ydE91dCcpO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvU3RyaW5nO1xuIiwiLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3J0T3V0O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmljdEluZGV4T2Y7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zdGFudDtcbiIsInZhciBiYXNlRGlmZmVyZW5jZSA9IHJlcXVpcmUoJy4vX2Jhc2VEaWZmZXJlbmNlJyksXG4gICAgYmFzZUZsYXR0ZW4gPSByZXF1aXJlKCcuL19iYXNlRmxhdHRlbicpLFxuICAgIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGBhcnJheWAgdmFsdWVzIG5vdCBpbmNsdWRlZCBpbiB0aGUgb3RoZXIgZ2l2ZW4gYXJyYXlzXG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICpcbiAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAqIEBzZWUgXy53aXRob3V0LCBfLnhvclxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRpZmZlcmVuY2UoWzIsIDFdLCBbMiwgM10pO1xuICogLy8gPT4gWzFdXG4gKi9cbnZhciBkaWZmZXJlbmNlID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpXG4gICAgOiBbXTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRpZmZlcmVuY2U7XG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csXG4gICAgcmVIYXNSZWdFeHBDaGFyID0gUmVnRXhwKHJlUmVnRXhwQ2hhci5zb3VyY2UpO1xuXG4vKipcbiAqIEVzY2FwZXMgdGhlIGBSZWdFeHBgIHNwZWNpYWwgY2hhcmFjdGVycyBcIl5cIiwgXCIkXCIsIFwiXFxcIiwgXCIuXCIsIFwiKlwiLCBcIitcIixcbiAqIFwiP1wiLCBcIihcIiwgXCIpXCIsIFwiW1wiLCBcIl1cIiwgXCJ7XCIsIFwifVwiLCBhbmQgXCJ8XCIgaW4gYHN0cmluZ2AuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZXNjYXBlUmVnRXhwKCdbbG9kYXNoXShodHRwczovL2xvZGFzaC5jb20vKScpO1xuICogLy8gPT4gJ1xcW2xvZGFzaFxcXVxcKGh0dHBzOi8vbG9kYXNoXFwuY29tL1xcKSdcbiAqL1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1JlZ0V4cENoYXIudGVzdChzdHJpbmcpKVxuICAgID8gc3RyaW5nLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICA6IHN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVSZWdFeHA7XG4iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJvb2xlYW4sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Jvb2xlYW4oZmFsc2UpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCb29sZWFuKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBib29sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Jvb2xlYW47XG4iLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAqIGVxdWl2YWxlbnQuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxuICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcbiAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICogbm9kZXMgYXJlIGNvbXBhcmVkIGJ5IHN0cmljdCBlcXVhbGl0eSwgaS5lLiBgPT09YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIG9iamVjdCA9PT0gb3RoZXI7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0VxdWFsO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTnVtYmVyYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqICoqTm90ZToqKiBUbyBleGNsdWRlIGBJbmZpbml0eWAsIGAtSW5maW5pdHlgLCBhbmQgYE5hTmAsIHdoaWNoIGFyZVxuICogY2xhc3NpZmllZCBhcyBudW1iZXJzLCB1c2UgdGhlIGBfLmlzRmluaXRlYCBtZXRob2QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc051bWJlcigzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBudW1iZXJUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTnVtYmVyO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTdHJpbmcoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpbmc7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLm5vb3ApO1xuICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICovXG5mdW5jdGlvbiBub29wKCkge1xuICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vb3A7XG4iLCJ2YXIgY3JlYXRlQWdncmVnYXRvciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUFnZ3JlZ2F0b3InKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gdHdvIGdyb3VwcywgdGhlIGZpcnN0IG9mIHdoaWNoXG4gKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IsIHRoZSBzZWNvbmQgb2Ygd2hpY2hcbiAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5IGZvci4gVGhlIHByZWRpY2F0ZSBpc1xuICogaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogZmFsc2UgfVxuICogXTtcbiAqXG4gKiBfLnBhcnRpdGlvbih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hY3RpdmU7IH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8ucGFydGl0aW9uKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbWydwZWJibGVzJ10sIFsnYmFybmV5JywgJ2ZyZWQnXV1cbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLnBhcnRpdGlvbih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgJ3BlYmJsZXMnXSwgWydmcmVkJ11dXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLnBhcnRpdGlvbih1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG4gKi9cbnZhciBwYXJ0aXRpb24gPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICByZXN1bHRba2V5ID8gMCA6IDFdLnB1c2godmFsdWUpO1xufSwgZnVuY3Rpb24oKSB7IHJldHVybiBbW10sIFtdXTsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFydGl0aW9uO1xuIiwidmFyIGJhc2VTdW0gPSByZXF1aXJlKCcuL19iYXNlU3VtJyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHN1bSBvZiB0aGUgdmFsdWVzIGluIGBhcnJheWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjQuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc3VtKFs0LCAyLCA4LCA2XSk7XG4gKiAvLyA9PiAyMFxuICovXG5mdW5jdGlvbiBzdW0oYXJyYXkpIHtcbiAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgPyBiYXNlU3VtKGFycmF5LCBpZGVudGl0eSlcbiAgICA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3VtO1xuIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKSxcbiAgICBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgYmFzZVVuaXEgPSByZXF1aXJlKCcuL19iYXNlVW5pcScpLFxuICAgIGlzQXJyYXlMaWtlT2JqZWN0ID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZU9iamVjdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIGZyb20gYWxsIGdpdmVuIGFycmF5cyB1c2luZ1xuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmlvbihbMl0sIFsxLCAyXSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqL1xudmFyIHVuaW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bmlvbjtcbiIsInZhciBsb3dlckNhc2UgPSByZXF1aXJlKCdsb3dlci1jYXNlJylcblxuLyoqXG4gKiBMb3dlciBjYXNlIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBsb2NhbGUpIHtcbiAgaWYgKHN0ciA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBzdHIgPSBTdHJpbmcoc3RyKVxuXG4gIHJldHVybiBsb3dlckNhc2Uoc3RyLmNoYXJBdCgwKSwgbG9jYWxlKSArIHN0ci5zdWJzdHIoMSlcbn1cbiIsIi8qKlxuICogU3BlY2lhbCBsYW5ndWFnZS1zcGVjaWZpYyBvdmVycmlkZXMuXG4gKlxuICogU291cmNlOiBmdHA6Ly9mdHAudW5pY29kZS5vcmcvUHVibGljL1VDRC9sYXRlc3QvdWNkL1NwZWNpYWxDYXNpbmcudHh0XG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIExBTkdVQUdFUyA9IHtcbiAgdHI6IHtcbiAgICByZWdleHA6IC9cXHUwMTMwfFxcdTAwNDl8XFx1MDA0OVxcdTAzMDcvZyxcbiAgICBtYXA6IHtcbiAgICAgICdcXHUwMTMwJzogJ1xcdTAwNjknLFxuICAgICAgJ1xcdTAwNDknOiAnXFx1MDEzMScsXG4gICAgICAnXFx1MDA0OVxcdTAzMDcnOiAnXFx1MDA2OSdcbiAgICB9XG4gIH0sXG4gIGF6OiB7XG4gICAgcmVnZXhwOiAvW1xcdTAxMzBdL2csXG4gICAgbWFwOiB7XG4gICAgICAnXFx1MDEzMCc6ICdcXHUwMDY5JyxcbiAgICAgICdcXHUwMDQ5JzogJ1xcdTAxMzEnLFxuICAgICAgJ1xcdTAwNDlcXHUwMzA3JzogJ1xcdTAwNjknXG4gICAgfVxuICB9LFxuICBsdDoge1xuICAgIHJlZ2V4cDogL1tcXHUwMDQ5XFx1MDA0QVxcdTAxMkVcXHUwMENDXFx1MDBDRFxcdTAxMjhdL2csXG4gICAgbWFwOiB7XG4gICAgICAnXFx1MDA0OSc6ICdcXHUwMDY5XFx1MDMwNycsXG4gICAgICAnXFx1MDA0QSc6ICdcXHUwMDZBXFx1MDMwNycsXG4gICAgICAnXFx1MDEyRSc6ICdcXHUwMTJGXFx1MDMwNycsXG4gICAgICAnXFx1MDBDQyc6ICdcXHUwMDY5XFx1MDMwN1xcdTAzMDAnLFxuICAgICAgJ1xcdTAwQ0QnOiAnXFx1MDA2OVxcdTAzMDdcXHUwMzAxJyxcbiAgICAgICdcXHUwMTI4JzogJ1xcdTAwNjlcXHUwMzA3XFx1MDMwMydcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBMb3dlcmNhc2UgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBsb2NhbGUpIHtcbiAgdmFyIGxhbmcgPSBMQU5HVUFHRVNbbG9jYWxlXVxuXG4gIHN0ciA9IHN0ciA9PSBudWxsID8gJycgOiBTdHJpbmcoc3RyKVxuXG4gIGlmIChsYW5nKSB7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UobGFuZy5yZWdleHAsIGZ1bmN0aW9uIChtKSB7IHJldHVybiBsYW5nLm1hcFttXSB9KVxuICB9XG5cbiAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpXG59XG4iLCIvKlxuICBodHRwczovL2dpdGh1Yi5jb20vYmFua3NlYW4gd3JhcHBlZCBNYWtvdG8gTWF0c3Vtb3RvIGFuZCBUYWt1amkgTmlzaGltdXJhJ3MgY29kZSBpbiBhIG5hbWVzcGFjZVxuICBzbyBpdCdzIGJldHRlciBlbmNhcHN1bGF0ZWQuIE5vdyB5b3UgY2FuIGhhdmUgbXVsdGlwbGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3JzXG4gIGFuZCB0aGV5IHdvbid0IHN0b21wIGFsbCBvdmVyIGVhY2hvdGhlcidzIHN0YXRlLlxuXG4gIElmIHlvdSB3YW50IHRvIHVzZSB0aGlzIGFzIGEgc3Vic3RpdHV0ZSBmb3IgTWF0aC5yYW5kb20oKSwgdXNlIHRoZSByYW5kb20oKVxuICBtZXRob2QgbGlrZSBzbzpcblxuICB2YXIgbSA9IG5ldyBNZXJzZW5uZVR3aXN0ZXIoKTtcbiAgdmFyIHJhbmRvbU51bWJlciA9IG0ucmFuZG9tKCk7XG5cbiAgWW91IGNhbiBhbHNvIGNhbGwgdGhlIG90aGVyIGdlbnJhbmRfe2Zvb30oKSBtZXRob2RzIG9uIHRoZSBpbnN0YW5jZS5cblxuICBJZiB5b3Ugd2FudCB0byB1c2UgYSBzcGVjaWZpYyBzZWVkIGluIG9yZGVyIHRvIGdldCBhIHJlcGVhdGFibGUgcmFuZG9tXG4gIHNlcXVlbmNlLCBwYXNzIGFuIGludGVnZXIgaW50byB0aGUgY29uc3RydWN0b3I6XG5cbiAgdmFyIG0gPSBuZXcgTWVyc2VubmVUd2lzdGVyKDEyMyk7XG5cbiAgYW5kIHRoYXQgd2lsbCBhbHdheXMgcHJvZHVjZSB0aGUgc2FtZSByYW5kb20gc2VxdWVuY2UuXG5cbiAgU2VhbiBNY0N1bGxvdWdoIChiYW5rc2VhbkBnbWFpbC5jb20pXG4qL1xuXG4vKlxuICAgQSBDLXByb2dyYW0gZm9yIE1UMTk5MzcsIHdpdGggaW5pdGlhbGl6YXRpb24gaW1wcm92ZWQgMjAwMi8xLzI2LlxuICAgQ29kZWQgYnkgVGFrdWppIE5pc2hpbXVyYSBhbmQgTWFrb3RvIE1hdHN1bW90by5cblxuICAgQmVmb3JlIHVzaW5nLCBpbml0aWFsaXplIHRoZSBzdGF0ZSBieSB1c2luZyBpbml0X3NlZWQoc2VlZClcbiAgIG9yIGluaXRfYnlfYXJyYXkoaW5pdF9rZXksIGtleV9sZW5ndGgpLlxuXG4gICBDb3B5cmlnaHQgKEMpIDE5OTcgLSAyMDAyLCBNYWtvdG8gTWF0c3Vtb3RvIGFuZCBUYWt1amkgTmlzaGltdXJhLFxuICAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgIGFyZSBtZXQ6XG5cbiAgICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgICAzLiBUaGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlXG4gICAgICAgIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlblxuICAgICAgICBwZXJtaXNzaW9uLlxuXG4gICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gICBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gICBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAgIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxuICAgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXG4gICBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAgIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gICBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAgIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuXG5cbiAgIEFueSBmZWVkYmFjayBpcyB2ZXJ5IHdlbGNvbWUuXG4gICBodHRwOi8vd3d3Lm1hdGguc2NpLmhpcm9zaGltYS11LmFjLmpwL35tLW1hdC9NVC9lbXQuaHRtbFxuICAgZW1haWw6IG0tbWF0IEAgbWF0aC5zY2kuaGlyb3NoaW1hLXUuYWMuanAgKHJlbW92ZSBzcGFjZSlcbiovXG5cbnZhciBNZXJzZW5uZVR3aXN0ZXIgPSBmdW5jdGlvbihzZWVkKSB7XG5cdGlmIChzZWVkID09IHVuZGVmaW5lZCkge1xuXHRcdHNlZWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0fVxuXG5cdC8qIFBlcmlvZCBwYXJhbWV0ZXJzICovXG5cdHRoaXMuTiA9IDYyNDtcblx0dGhpcy5NID0gMzk3O1xuXHR0aGlzLk1BVFJJWF9BID0gMHg5OTA4YjBkZjsgICAvKiBjb25zdGFudCB2ZWN0b3IgYSAqL1xuXHR0aGlzLlVQUEVSX01BU0sgPSAweDgwMDAwMDAwOyAvKiBtb3N0IHNpZ25pZmljYW50IHctciBiaXRzICovXG5cdHRoaXMuTE9XRVJfTUFTSyA9IDB4N2ZmZmZmZmY7IC8qIGxlYXN0IHNpZ25pZmljYW50IHIgYml0cyAqL1xuXG5cdHRoaXMubXQgPSBuZXcgQXJyYXkodGhpcy5OKTsgLyogdGhlIGFycmF5IGZvciB0aGUgc3RhdGUgdmVjdG9yICovXG5cdHRoaXMubXRpPXRoaXMuTisxOyAvKiBtdGk9PU4rMSBtZWFucyBtdFtOXSBpcyBub3QgaW5pdGlhbGl6ZWQgKi9cblxuXHRpZiAoc2VlZC5jb25zdHJ1Y3RvciA9PSBBcnJheSkge1xuXHRcdHRoaXMuaW5pdF9ieV9hcnJheShzZWVkLCBzZWVkLmxlbmd0aCk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0dGhpcy5pbml0X3NlZWQoc2VlZCk7XG5cdH1cbn1cblxuLyogaW5pdGlhbGl6ZXMgbXRbTl0gd2l0aCBhIHNlZWQgKi9cbi8qIG9yaWdpbiBuYW1lIGluaXRfZ2VucmFuZCAqL1xuTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5pbml0X3NlZWQgPSBmdW5jdGlvbihzKSB7XG5cdHRoaXMubXRbMF0gPSBzID4+PiAwO1xuXHRmb3IgKHRoaXMubXRpPTE7IHRoaXMubXRpPHRoaXMuTjsgdGhpcy5tdGkrKykge1xuXHRcdHZhciBzID0gdGhpcy5tdFt0aGlzLm10aS0xXSBeICh0aGlzLm10W3RoaXMubXRpLTFdID4+PiAzMCk7XG5cdFx0dGhpcy5tdFt0aGlzLm10aV0gPSAoKCgoKHMgJiAweGZmZmYwMDAwKSA+Pj4gMTYpICogMTgxMjQzMzI1MykgPDwgMTYpICsgKHMgJiAweDAwMDBmZmZmKSAqIDE4MTI0MzMyNTMpXG5cdFx0KyB0aGlzLm10aTtcblx0XHQvKiBTZWUgS251dGggVEFPQ1AgVm9sMi4gM3JkIEVkLiBQLjEwNiBmb3IgbXVsdGlwbGllci4gKi9cblx0XHQvKiBJbiB0aGUgcHJldmlvdXMgdmVyc2lvbnMsIE1TQnMgb2YgdGhlIHNlZWQgYWZmZWN0ICAgKi9cblx0XHQvKiBvbmx5IE1TQnMgb2YgdGhlIGFycmF5IG10W10uICAgICAgICAgICAgICAgICAgICAgICAgKi9cblx0XHQvKiAyMDAyLzAxLzA5IG1vZGlmaWVkIGJ5IE1ha290byBNYXRzdW1vdG8gICAgICAgICAgICAgKi9cblx0XHR0aGlzLm10W3RoaXMubXRpXSA+Pj49IDA7XG5cdFx0LyogZm9yID4zMiBiaXQgbWFjaGluZXMgKi9cblx0fVxufVxuXG4vKiBpbml0aWFsaXplIGJ5IGFuIGFycmF5IHdpdGggYXJyYXktbGVuZ3RoICovXG4vKiBpbml0X2tleSBpcyB0aGUgYXJyYXkgZm9yIGluaXRpYWxpemluZyBrZXlzICovXG4vKiBrZXlfbGVuZ3RoIGlzIGl0cyBsZW5ndGggKi9cbi8qIHNsaWdodCBjaGFuZ2UgZm9yIEMrKywgMjAwNC8yLzI2ICovXG5NZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmluaXRfYnlfYXJyYXkgPSBmdW5jdGlvbihpbml0X2tleSwga2V5X2xlbmd0aCkge1xuXHR2YXIgaSwgaiwgaztcblx0dGhpcy5pbml0X3NlZWQoMTk2NTAyMTgpO1xuXHRpPTE7IGo9MDtcblx0ayA9ICh0aGlzLk4+a2V5X2xlbmd0aCA/IHRoaXMuTiA6IGtleV9sZW5ndGgpO1xuXHRmb3IgKDsgazsgay0tKSB7XG5cdFx0dmFyIHMgPSB0aGlzLm10W2ktMV0gXiAodGhpcy5tdFtpLTFdID4+PiAzMClcblx0XHR0aGlzLm10W2ldID0gKHRoaXMubXRbaV0gXiAoKCgoKHMgJiAweGZmZmYwMDAwKSA+Pj4gMTYpICogMTY2NDUyNSkgPDwgMTYpICsgKChzICYgMHgwMDAwZmZmZikgKiAxNjY0NTI1KSkpXG5cdFx0KyBpbml0X2tleVtqXSArIGo7IC8qIG5vbiBsaW5lYXIgKi9cblx0XHR0aGlzLm10W2ldID4+Pj0gMDsgLyogZm9yIFdPUkRTSVpFID4gMzIgbWFjaGluZXMgKi9cblx0XHRpKys7IGorKztcblx0XHRpZiAoaT49dGhpcy5OKSB7IHRoaXMubXRbMF0gPSB0aGlzLm10W3RoaXMuTi0xXTsgaT0xOyB9XG5cdFx0aWYgKGo+PWtleV9sZW5ndGgpIGo9MDtcblx0fVxuXHRmb3IgKGs9dGhpcy5OLTE7IGs7IGstLSkge1xuXHRcdHZhciBzID0gdGhpcy5tdFtpLTFdIF4gKHRoaXMubXRbaS0xXSA+Pj4gMzApO1xuXHRcdHRoaXMubXRbaV0gPSAodGhpcy5tdFtpXSBeICgoKCgocyAmIDB4ZmZmZjAwMDApID4+PiAxNikgKiAxNTY2MDgzOTQxKSA8PCAxNikgKyAocyAmIDB4MDAwMGZmZmYpICogMTU2NjA4Mzk0MSkpXG5cdFx0LSBpOyAvKiBub24gbGluZWFyICovXG5cdFx0dGhpcy5tdFtpXSA+Pj49IDA7IC8qIGZvciBXT1JEU0laRSA+IDMyIG1hY2hpbmVzICovXG5cdFx0aSsrO1xuXHRcdGlmIChpPj10aGlzLk4pIHsgdGhpcy5tdFswXSA9IHRoaXMubXRbdGhpcy5OLTFdOyBpPTE7IH1cblx0fVxuXG5cdHRoaXMubXRbMF0gPSAweDgwMDAwMDAwOyAvKiBNU0IgaXMgMTsgYXNzdXJpbmcgbm9uLXplcm8gaW5pdGlhbCBhcnJheSAqL1xufVxuXG4vKiBnZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIG9uIFswLDB4ZmZmZmZmZmZdLWludGVydmFsICovXG4vKiBvcmlnaW4gbmFtZSBnZW5yYW5kX2ludDMyICovXG5NZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLnJhbmRvbV9pbnQgPSBmdW5jdGlvbigpIHtcblx0dmFyIHk7XG5cdHZhciBtYWcwMSA9IG5ldyBBcnJheSgweDAsIHRoaXMuTUFUUklYX0EpO1xuXHQvKiBtYWcwMVt4XSA9IHggKiBNQVRSSVhfQSAgZm9yIHg9MCwxICovXG5cblx0aWYgKHRoaXMubXRpID49IHRoaXMuTikgeyAvKiBnZW5lcmF0ZSBOIHdvcmRzIGF0IG9uZSB0aW1lICovXG5cdFx0dmFyIGtrO1xuXG5cdFx0aWYgKHRoaXMubXRpID09IHRoaXMuTisxKSAgLyogaWYgaW5pdF9zZWVkKCkgaGFzIG5vdCBiZWVuIGNhbGxlZCwgKi9cblx0XHRcdHRoaXMuaW5pdF9zZWVkKDU0ODkpOyAgLyogYSBkZWZhdWx0IGluaXRpYWwgc2VlZCBpcyB1c2VkICovXG5cblx0XHRmb3IgKGtrPTA7a2s8dGhpcy5OLXRoaXMuTTtraysrKSB7XG5cdFx0XHR5ID0gKHRoaXMubXRba2tdJnRoaXMuVVBQRVJfTUFTSyl8KHRoaXMubXRba2srMV0mdGhpcy5MT1dFUl9NQVNLKTtcblx0XHRcdHRoaXMubXRba2tdID0gdGhpcy5tdFtrayt0aGlzLk1dIF4gKHkgPj4+IDEpIF4gbWFnMDFbeSAmIDB4MV07XG5cdFx0fVxuXHRcdGZvciAoO2trPHRoaXMuTi0xO2trKyspIHtcblx0XHRcdHkgPSAodGhpcy5tdFtra10mdGhpcy5VUFBFUl9NQVNLKXwodGhpcy5tdFtraysxXSZ0aGlzLkxPV0VSX01BU0spO1xuXHRcdFx0dGhpcy5tdFtra10gPSB0aGlzLm10W2trKyh0aGlzLk0tdGhpcy5OKV0gXiAoeSA+Pj4gMSkgXiBtYWcwMVt5ICYgMHgxXTtcblx0XHR9XG5cdFx0eSA9ICh0aGlzLm10W3RoaXMuTi0xXSZ0aGlzLlVQUEVSX01BU0spfCh0aGlzLm10WzBdJnRoaXMuTE9XRVJfTUFTSyk7XG5cdFx0dGhpcy5tdFt0aGlzLk4tMV0gPSB0aGlzLm10W3RoaXMuTS0xXSBeICh5ID4+PiAxKSBeIG1hZzAxW3kgJiAweDFdO1xuXG5cdFx0dGhpcy5tdGkgPSAwO1xuXHR9XG5cblx0eSA9IHRoaXMubXRbdGhpcy5tdGkrK107XG5cblx0LyogVGVtcGVyaW5nICovXG5cdHkgXj0gKHkgPj4+IDExKTtcblx0eSBePSAoeSA8PCA3KSAmIDB4OWQyYzU2ODA7XG5cdHkgXj0gKHkgPDwgMTUpICYgMHhlZmM2MDAwMDtcblx0eSBePSAoeSA+Pj4gMTgpO1xuXG5cdHJldHVybiB5ID4+PiAwO1xufVxuXG4vKiBnZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIG9uIFswLDB4N2ZmZmZmZmZdLWludGVydmFsICovXG4vKiBvcmlnaW4gbmFtZSBnZW5yYW5kX2ludDMxICovXG5NZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLnJhbmRvbV9pbnQzMSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gKHRoaXMucmFuZG9tX2ludCgpPj4+MSk7XG59XG5cbi8qIGdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgb24gWzAsMV0tcmVhbC1pbnRlcnZhbCAqL1xuLyogb3JpZ2luIG5hbWUgZ2VucmFuZF9yZWFsMSAqL1xuTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5yYW5kb21faW5jbCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5yYW5kb21faW50KCkqKDEuMC80Mjk0OTY3Mjk1LjApO1xuXHQvKiBkaXZpZGVkIGJ5IDJeMzItMSAqL1xufVxuXG4vKiBnZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIG9uIFswLDEpLXJlYWwtaW50ZXJ2YWwgKi9cbk1lcnNlbm5lVHdpc3Rlci5wcm90b3R5cGUucmFuZG9tID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnJhbmRvbV9pbnQoKSooMS4wLzQyOTQ5NjcyOTYuMCk7XG5cdC8qIGRpdmlkZWQgYnkgMl4zMiAqL1xufVxuXG4vKiBnZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIG9uICgwLDEpLXJlYWwtaW50ZXJ2YWwgKi9cbi8qIG9yaWdpbiBuYW1lIGdlbnJhbmRfcmVhbDMgKi9cbk1lcnNlbm5lVHdpc3Rlci5wcm90b3R5cGUucmFuZG9tX2V4Y2wgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuICh0aGlzLnJhbmRvbV9pbnQoKSArIDAuNSkqKDEuMC80Mjk0OTY3Mjk2LjApO1xuXHQvKiBkaXZpZGVkIGJ5IDJeMzIgKi9cbn1cblxuLyogZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBvbiBbMCwxKSB3aXRoIDUzLWJpdCByZXNvbHV0aW9uKi9cbi8qIG9yaWdpbiBuYW1lIGdlbnJhbmRfcmVzNTMgKi9cbk1lcnNlbm5lVHdpc3Rlci5wcm90b3R5cGUucmFuZG9tX2xvbmcgPSBmdW5jdGlvbigpIHtcblx0dmFyIGE9dGhpcy5yYW5kb21faW50KCk+Pj41LCBiPXRoaXMucmFuZG9tX2ludCgpPj4+Njtcblx0cmV0dXJuKGEqNjcxMDg4NjQuMCtiKSooMS4wLzkwMDcxOTkyNTQ3NDA5OTIuMCk7XG59XG5cbi8qIFRoZXNlIHJlYWwgdmVyc2lvbnMgYXJlIGR1ZSB0byBJc2FrdSBXYWRhLCAyMDAyLzAxLzA5IGFkZGVkICovXG5cbm1vZHVsZS5leHBvcnRzID0gTWVyc2VubmVUd2lzdGVyO1xuIiwiJ3VzZSBzdHJpY3QnO2Z1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdChlKXtyZXR1cm4oZSYmKHR5cGVvZiBlPT09J29iamVjdCcpJiYnZGVmYXVsdCdpbiBlKT9lWydkZWZhdWx0J106ZX12YXIgUmVhY3Q9cmVxdWlyZSgncmVhY3QnKSxSZWFjdF9fZGVmYXVsdD1faW50ZXJvcERlZmF1bHQoUmVhY3QpLF9pbmhlcml0c0xvb3NlPV9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzTG9vc2UnKSksUHJvcFR5cGVzPV9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdwcm9wLXR5cGVzJykpLGd1ZD1faW50ZXJvcERlZmF1bHQocmVxdWlyZSgnZ3VkJykpLHdhcm5pbmc9X2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3Rpbnktd2FybmluZycpKTt2YXIgTUFYX1NJR05FRF8zMV9CSVRfSU5UID0gMTA3Mzc0MTgyMztcblxuZnVuY3Rpb24gb2JqZWN0SXMoeCwgeSkge1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50RW1pdHRlcih2YWx1ZSkge1xuICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBvbjogZnVuY3Rpb24gb24oaGFuZGxlcikge1xuICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICB9LFxuICAgIG9mZjogZnVuY3Rpb24gb2ZmKGhhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXJzID0gaGFuZGxlcnMuZmlsdGVyKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHJldHVybiBoICE9PSBoYW5kbGVyO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ZhbHVlLCBjaGFuZ2VkQml0cykge1xuICAgICAgdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIodmFsdWUsIGNoYW5nZWRCaXRzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuWzBdIDogY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0Q29udGV4dChkZWZhdWx0VmFsdWUsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSB7XG4gIHZhciBfUHJvdmlkZXIkY2hpbGRDb250ZXgsIF9Db25zdW1lciRjb250ZXh0VHlwZTtcblxuICB2YXIgY29udGV4dFByb3AgPSAnX19jcmVhdGUtcmVhY3QtY29udGV4dC0nICsgZ3VkKCkgKyAnX18nO1xuXG4gIHZhciBQcm92aWRlciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHNMb29zZShQcm92aWRlciwgX0NvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBQcm92aWRlcigpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX3RoaXMgPSBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgIF90aGlzLmVtaXR0ZXIgPSBjcmVhdGVFdmVudEVtaXR0ZXIoX3RoaXMucHJvcHMudmFsdWUpO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBQcm92aWRlci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgdmFyIF9yZWY7XG5cbiAgICAgIHJldHVybiBfcmVmID0ge30sIF9yZWZbY29udGV4dFByb3BdID0gdGhpcy5lbWl0dGVyLCBfcmVmO1xuICAgIH07XG5cbiAgICBfcHJvdG8uY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy52YWx1ZSAhPT0gbmV4dFByb3BzLnZhbHVlKSB7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMucHJvcHMudmFsdWU7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IG5leHRQcm9wcy52YWx1ZTtcbiAgICAgICAgdmFyIGNoYW5nZWRCaXRzO1xuXG4gICAgICAgIGlmIChvYmplY3RJcyhvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgICAgICAgY2hhbmdlZEJpdHMgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoYW5nZWRCaXRzID0gdHlwZW9mIGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSAnZnVuY3Rpb24nID8gY2FsY3VsYXRlQ2hhbmdlZEJpdHMob2xkVmFsdWUsIG5ld1ZhbHVlKSA6IE1BWF9TSUdORURfMzFfQklUX0lOVDtcblxuICAgICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgd2FybmluZygoY2hhbmdlZEJpdHMgJiBNQVhfU0lHTkVEXzMxX0JJVF9JTlQpID09PSBjaGFuZ2VkQml0cywgJ2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBFeHBlY3RlZCB0aGUgcmV0dXJuIHZhbHVlIHRvIGJlIGEgJyArICczMS1iaXQgaW50ZWdlci4gSW5zdGVhZCByZWNlaXZlZDogJyArIGNoYW5nZWRCaXRzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGFuZ2VkQml0cyB8PSAwO1xuXG4gICAgICAgICAgaWYgKGNoYW5nZWRCaXRzICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuc2V0KG5leHRQcm9wcy52YWx1ZSwgY2hhbmdlZEJpdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfTtcblxuICAgIHJldHVybiBQcm92aWRlcjtcbiAgfShSZWFjdC5Db21wb25lbnQpO1xuXG4gIFByb3ZpZGVyLmNoaWxkQ29udGV4dFR5cGVzID0gKF9Qcm92aWRlciRjaGlsZENvbnRleCA9IHt9LCBfUHJvdmlkZXIkY2hpbGRDb250ZXhbY29udGV4dFByb3BdID0gUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLCBfUHJvdmlkZXIkY2hpbGRDb250ZXgpO1xuXG4gIHZhciBDb25zdW1lciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9Db21wb25lbnQyKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoQ29uc3VtZXIsIF9Db21wb25lbnQyKTtcblxuICAgIGZ1bmN0aW9uIENvbnN1bWVyKCkge1xuICAgICAgdmFyIF90aGlzMjtcblxuICAgICAgX3RoaXMyID0gX0NvbXBvbmVudDIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgX3RoaXMyLnN0YXRlID0ge1xuICAgICAgICB2YWx1ZTogX3RoaXMyLmdldFZhbHVlKClcbiAgICAgIH07XG5cbiAgICAgIF90aGlzMi5vblVwZGF0ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgY2hhbmdlZEJpdHMpIHtcbiAgICAgICAgdmFyIG9ic2VydmVkQml0cyA9IF90aGlzMi5vYnNlcnZlZEJpdHMgfCAwO1xuXG4gICAgICAgIGlmICgob2JzZXJ2ZWRCaXRzICYgY2hhbmdlZEJpdHMpICE9PSAwKSB7XG4gICAgICAgICAgX3RoaXMyLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHZhbHVlOiBfdGhpczIuZ2V0VmFsdWUoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gX3RoaXMyO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8yID0gQ29uc3VtZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvMi5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgIHZhciBvYnNlcnZlZEJpdHMgPSBuZXh0UHJvcHMub2JzZXJ2ZWRCaXRzO1xuICAgICAgdGhpcy5vYnNlcnZlZEJpdHMgPSBvYnNlcnZlZEJpdHMgPT09IHVuZGVmaW5lZCB8fCBvYnNlcnZlZEJpdHMgPT09IG51bGwgPyBNQVhfU0lHTkVEXzMxX0JJVF9JTlQgOiBvYnNlcnZlZEJpdHM7XG4gICAgfTtcblxuICAgIF9wcm90bzIuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRbY29udGV4dFByb3BdKSB7XG4gICAgICAgIHRoaXMuY29udGV4dFtjb250ZXh0UHJvcF0ub24odGhpcy5vblVwZGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvYnNlcnZlZEJpdHMgPSB0aGlzLnByb3BzLm9ic2VydmVkQml0cztcbiAgICAgIHRoaXMub2JzZXJ2ZWRCaXRzID0gb2JzZXJ2ZWRCaXRzID09PSB1bmRlZmluZWQgfHwgb2JzZXJ2ZWRCaXRzID09PSBudWxsID8gTUFYX1NJR05FRF8zMV9CSVRfSU5UIDogb2JzZXJ2ZWRCaXRzO1xuICAgIH07XG5cbiAgICBfcHJvdG8yLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICBpZiAodGhpcy5jb250ZXh0W2NvbnRleHRQcm9wXSkge1xuICAgICAgICB0aGlzLmNvbnRleHRbY29udGV4dFByb3BdLm9mZih0aGlzLm9uVXBkYXRlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvMi5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgaWYgKHRoaXMuY29udGV4dFtjb250ZXh0UHJvcF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dFtjb250ZXh0UHJvcF0uZ2V0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8yLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiBvbmx5Q2hpbGQodGhpcy5wcm9wcy5jaGlsZHJlbikodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBDb25zdW1lcjtcbiAgfShSZWFjdC5Db21wb25lbnQpO1xuXG4gIENvbnN1bWVyLmNvbnRleHRUeXBlcyA9IChfQ29uc3VtZXIkY29udGV4dFR5cGUgPSB7fSwgX0NvbnN1bWVyJGNvbnRleHRUeXBlW2NvbnRleHRQcm9wXSA9IFByb3BUeXBlcy5vYmplY3QsIF9Db25zdW1lciRjb250ZXh0VHlwZSk7XG4gIHJldHVybiB7XG4gICAgUHJvdmlkZXI6IFByb3ZpZGVyLFxuICAgIENvbnN1bWVyOiBDb25zdW1lclxuICB9O1xufXZhciBpbmRleCA9IFJlYWN0X19kZWZhdWx0LmNyZWF0ZUNvbnRleHQgfHwgY3JlYXRlUmVhY3RDb250ZXh0O21vZHVsZS5leHBvcnRzPWluZGV4OyIsIid1c2Ugc3RyaWN0J1xuXG5jbGFzcyBCYXNlIHtcbiAgY29uc3RydWN0b3IgKG5hbWUsIGNvZGUsIGltcGxlbWVudGF0aW9uLCBhbHBoYWJldCkge1xuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLmNvZGUgPSBjb2RlXG4gICAgdGhpcy5hbHBoYWJldCA9IGFscGhhYmV0XG4gICAgaWYgKGltcGxlbWVudGF0aW9uICYmIGFscGhhYmV0KSB7XG4gICAgICB0aGlzLmVuZ2luZSA9IGltcGxlbWVudGF0aW9uKGFscGhhYmV0KVxuICAgIH1cbiAgfVxuXG4gIGVuY29kZSAoc3RyaW5nT3JCdWZmZXIpIHtcbiAgICByZXR1cm4gdGhpcy5lbmdpbmUuZW5jb2RlKHN0cmluZ09yQnVmZmVyKVxuICB9XG5cbiAgZGVjb2RlIChzdHJpbmdPckJ1ZmZlcikge1xuICAgIHJldHVybiB0aGlzLmVuZ2luZS5kZWNvZGUoc3RyaW5nT3JCdWZmZXIpXG4gIH1cblxuICBpc0ltcGxlbWVudGVkICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmdpbmVcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VcbiIsIid1c2Ugc3RyaWN0J1xuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmFzZTE2IChhbHBoYWJldCkge1xuICByZXR1cm4ge1xuICAgIGVuY29kZSAoaW5wdXQpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShpbnB1dCkudG9TdHJpbmcoJ2hleCcpXG4gICAgICB9XG4gICAgICByZXR1cm4gaW5wdXQudG9TdHJpbmcoJ2hleCcpXG4gICAgfSxcbiAgICBkZWNvZGUgKGlucHV0KSB7XG4gICAgICBmb3IgKGNvbnN0IGNoYXIgb2YgaW5wdXQpIHtcbiAgICAgICAgaWYgKGFscGhhYmV0LmluZGV4T2YoY2hhcikgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJhc2UxNiBjaGFyYWN0ZXInKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oaW5wdXQsICdoZXgnKVxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmZ1bmN0aW9uIGRlY29kZSAoaW5wdXQsIGFscGhhYmV0KSB7XG4gIGlucHV0ID0gaW5wdXQucmVwbGFjZShuZXcgUmVnRXhwKCc9JywgJ2cnKSwgJycpXG4gIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aFxuXG4gIGxldCBiaXRzID0gMFxuICBsZXQgdmFsdWUgPSAwXG5cbiAgbGV0IGluZGV4ID0gMFxuICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDhBcnJheSgobGVuZ3RoICogNSAvIDgpIHwgMClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFsdWUgPSAodmFsdWUgPDwgNSkgfCBhbHBoYWJldC5pbmRleE9mKGlucHV0W2ldKVxuICAgIGJpdHMgKz0gNVxuXG4gICAgaWYgKGJpdHMgPj0gOCkge1xuICAgICAgb3V0cHV0W2luZGV4KytdID0gKHZhbHVlID4+PiAoYml0cyAtIDgpKSAmIDI1NVxuICAgICAgYml0cyAtPSA4XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dC5idWZmZXJcbn1cblxuZnVuY3Rpb24gZW5jb2RlIChidWZmZXIsIGFscGhhYmV0KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGJ1ZmZlci5ieXRlTGVuZ3RoXG4gIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpXG4gIGNvbnN0IHBhZGRpbmcgPSBhbHBoYWJldC5pbmRleE9mKCc9JykgPT09IGFscGhhYmV0Lmxlbmd0aCAtIDFcblxuICBpZiAocGFkZGluZykge1xuICAgIGFscGhhYmV0ID0gYWxwaGFiZXQuc3Vic3RyaW5nKDAsIGFscGhhYmV0Lmxlbmd0aCAtIDEpXG4gIH1cblxuICBsZXQgYml0cyA9IDBcbiAgbGV0IHZhbHVlID0gMFxuICBsZXQgb3V0cHV0ID0gJydcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFsdWUgPSAodmFsdWUgPDwgOCkgfCB2aWV3W2ldXG4gICAgYml0cyArPSA4XG5cbiAgICB3aGlsZSAoYml0cyA+PSA1KSB7XG4gICAgICBvdXRwdXQgKz0gYWxwaGFiZXRbKHZhbHVlID4+PiAoYml0cyAtIDUpKSAmIDMxXVxuICAgICAgYml0cyAtPSA1XG4gICAgfVxuICB9XG5cbiAgaWYgKGJpdHMgPiAwKSB7XG4gICAgb3V0cHV0ICs9IGFscGhhYmV0Wyh2YWx1ZSA8PCAoNSAtIGJpdHMpKSAmIDMxXVxuICB9XG5cbiAgaWYgKHBhZGRpbmcpIHtcbiAgICB3aGlsZSAoKG91dHB1dC5sZW5ndGggJSA4KSAhPT0gMCkge1xuICAgICAgb3V0cHV0ICs9ICc9J1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiYXNlMzIgKGFscGhhYmV0KSB7XG4gIHJldHVybiB7XG4gICAgZW5jb2RlIChpbnB1dCkge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZShVaW50OEFycmF5LmZyb20oaW5wdXQpLCBhbHBoYWJldClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVuY29kZShpbnB1dCwgYWxwaGFiZXQpXG4gICAgfSxcbiAgICBkZWNvZGUgKGlucHV0KSB7XG4gICAgICBmb3IgKGNvbnN0IGNoYXIgb2YgaW5wdXQpIHtcbiAgICAgICAgaWYgKGFscGhhYmV0LmluZGV4T2YoY2hhcikgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJhc2UzMiBjaGFyYWN0ZXInKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWNvZGUoaW5wdXQsIGFscGhhYmV0KVxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiYXNlNjQgKGFscGhhYmV0KSB7XG4gIC8vIFRoZSBhbHBoYWJldCBpcyBvbmx5IHVzZWQgdG8ga25vdzpcbiAgLy8gICAxLiBJZiBwYWRkaW5nIGlzIGVuYWJsZWQgKG11c3QgY29udGFpbiAnPScpXG4gIC8vICAgMi4gSWYgdGhlIG91dHB1dCBtdXN0IGJlIHVybC1zYWZlIChtdXN0IGNvbnRhaW4gJy0nIGFuZCAnXycpXG4gIC8vICAgMy4gSWYgdGhlIGlucHV0IG9mIHRoZSBvdXRwdXQgZnVuY3Rpb24gaXMgdmFsaWRcbiAgLy8gVGhlIGFscGhhYmV0cyBmcm9tIFJGQyA0NjQ4IGFyZSBhbHdheXMgdXNlZC5cbiAgY29uc3QgcGFkZGluZyA9IGFscGhhYmV0LmluZGV4T2YoJz0nKSA+IC0xXG4gIGNvbnN0IHVybCA9IGFscGhhYmV0LmluZGV4T2YoJy0nKSA+IC0xICYmIGFscGhhYmV0LmluZGV4T2YoJ18nKSA+IC0xXG5cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGUgKGlucHV0KSB7XG4gICAgICBsZXQgb3V0cHV0ID0gJydcblxuICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb3V0cHV0ID0gQnVmZmVyLmZyb20oaW5wdXQpLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0gaW5wdXQudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgICB9XG5cbiAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhZCA9IG91dHB1dC5pbmRleE9mKCc9JylcbiAgICAgIGlmIChwYWQgPiAwICYmICFwYWRkaW5nKSB7XG4gICAgICAgIG91dHB1dCA9IG91dHB1dC5zdWJzdHJpbmcoMCwgcGFkKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0XG4gICAgfSxcbiAgICBkZWNvZGUgKGlucHV0KSB7XG4gICAgICBmb3IgKGNvbnN0IGNoYXIgb2YgaW5wdXQpIHtcbiAgICAgICAgaWYgKGFscGhhYmV0LmluZGV4T2YoY2hhcikgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJhc2U2NCBjaGFyYWN0ZXInKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShpbnB1dCwgJ2Jhc2U2NCcpXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZS5qcycpXG5jb25zdCBiYXNlWCA9IHJlcXVpcmUoJ2Jhc2UteCcpXG5jb25zdCBiYXNlMTYgPSByZXF1aXJlKCcuL2Jhc2UxNicpXG5jb25zdCBiYXNlMzIgPSByZXF1aXJlKCcuL2Jhc2UzMicpXG5jb25zdCBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpXG5cbi8vIG5hbWUsIGNvZGUsIGltcGxlbWVudGF0aW9uLCBhbHBoYWJldFxuY29uc3QgY29uc3RhbnRzID0gW1xuICBbJ2Jhc2UxJywgJzEnLCAnJywgJzEnXSxcbiAgWydiYXNlMicsICcwJywgYmFzZVgsICcwMSddLFxuICBbJ2Jhc2U4JywgJzcnLCBiYXNlWCwgJzAxMjM0NTY3J10sXG4gIFsnYmFzZTEwJywgJzknLCBiYXNlWCwgJzAxMjM0NTY3ODknXSxcbiAgWydiYXNlMTYnLCAnZicsIGJhc2UxNiwgJzAxMjM0NTY3ODlhYmNkZWYnXSxcbiAgWydiYXNlMzInLCAnYicsIGJhc2UzMiwgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3J10sXG4gIFsnYmFzZTMycGFkJywgJ2MnLCBiYXNlMzIsICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2Nz0nXSxcbiAgWydiYXNlMzJoZXgnLCAndicsIGJhc2UzMiwgJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2J10sXG4gIFsnYmFzZTMyaGV4cGFkJywgJ3QnLCBiYXNlMzIsICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dj0nXSxcbiAgWydiYXNlMzJ6JywgJ2gnLCBiYXNlMzIsICd5Ym5kcmZnOGVqa21jcHF4b3QxdXdpc3phMzQ1aDc2OSddLFxuICBbJ2Jhc2U1OGZsaWNrcicsICdaJywgYmFzZVgsICcxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaJ10sXG4gIFsnYmFzZTU4YnRjJywgJ3onLCBiYXNlWCwgJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXSxcbiAgWydiYXNlNjQnLCAnbScsIGJhc2U2NCwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXSxcbiAgWydiYXNlNjRwYWQnLCAnTScsIGJhc2U2NCwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89J10sXG4gIFsnYmFzZTY0dXJsJywgJ3UnLCBiYXNlNjQsICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJ10sXG4gIFsnYmFzZTY0dXJscGFkJywgJ1UnLCBiYXNlNjQsICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fPSddXG5dXG5cbmNvbnN0IG5hbWVzID0gY29uc3RhbnRzLnJlZHVjZSgocHJldiwgdHVwcGxlKSA9PiB7XG4gIHByZXZbdHVwcGxlWzBdXSA9IG5ldyBCYXNlKHR1cHBsZVswXSwgdHVwcGxlWzFdLCB0dXBwbGVbMl0sIHR1cHBsZVszXSlcbiAgcmV0dXJuIHByZXZcbn0sIHt9KVxuXG5jb25zdCBjb2RlcyA9IGNvbnN0YW50cy5yZWR1Y2UoKHByZXYsIHR1cHBsZSkgPT4ge1xuICBwcmV2W3R1cHBsZVsxXV0gPSBuYW1lc1t0dXBwbGVbMF1dXG4gIHJldHVybiBwcmV2XG59LCB7fSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWVzOiBuYW1lcyxcbiAgY29kZXM6IGNvZGVzXG59XG4iLCIvKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBbbXVsdGliYXNlXShodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL211bHRpYmFzZSkgc3BlY2lmaWNhdGlvbi5cbiAqIEBtb2R1bGUgTXVsdGliYXNlXG4gKi9cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gbXVsdGliYXNlXG5leHBvcnRzLmVuY29kZSA9IGVuY29kZVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGVcbmV4cG9ydHMuaXNFbmNvZGVkID0gaXNFbmNvZGVkXG5leHBvcnRzLm5hbWVzID0gT2JqZWN0LmZyZWV6ZShPYmplY3Qua2V5cyhjb25zdGFudHMubmFtZXMpKVxuZXhwb3J0cy5jb2RlcyA9IE9iamVjdC5mcmVlemUoT2JqZWN0LmtleXMoY29uc3RhbnRzLmNvZGVzKSlcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYnVmZmVyIHdpdGggdGhlIG11bHRpYmFzZSB2YXJpbnQrY29kZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG5hbWVPckNvZGUgLSBUaGUgbXVsdGliYXNlIG5hbWUgb3IgY29kZSBudW1iZXIuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIC0gVGhlIGRhdGEgdG8gYmUgcHJlZml4ZWQgd2l0aCBtdWx0aWJhc2UuXG4gKiBAbWVtYmVyb2YgTXVsdGliYXNlXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBtdWx0aWJhc2UgKG5hbWVPckNvZGUsIGJ1Zikge1xuICBpZiAoIWJ1Zikge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZXMgYW4gZW5jb2RlZCBidWZmZXInKVxuICB9XG4gIGNvbnN0IGJhc2UgPSBnZXRCYXNlKG5hbWVPckNvZGUpXG4gIGNvbnN0IGNvZGVCdWYgPSBCdWZmZXIuZnJvbShiYXNlLmNvZGUpXG5cbiAgY29uc3QgbmFtZSA9IGJhc2UubmFtZVxuICB2YWxpZEVuY29kZShuYW1lLCBidWYpXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtjb2RlQnVmLCBidWZdKVxufVxuXG4vKipcbiAqIEVuY29kZSBkYXRhIHdpdGggdGhlIHNwZWNpZmllZCBiYXNlIGFuZCBhZGQgdGhlIG11bHRpYmFzZSBwcmVmaXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBuYW1lT3JDb2RlIC0gVGhlIG11bHRpYmFzZSBuYW1lIG9yIGNvZGUgbnVtYmVyLlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiAtIFRoZSBkYXRhIHRvIGJlIGVuY29kZWQuXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICogQG1lbWJlcm9mIE11bHRpYmFzZVxuICovXG5mdW5jdGlvbiBlbmNvZGUgKG5hbWVPckNvZGUsIGJ1Zikge1xuICBjb25zdCBiYXNlID0gZ2V0QmFzZShuYW1lT3JDb2RlKVxuICBjb25zdCBuYW1lID0gYmFzZS5uYW1lXG5cbiAgcmV0dXJuIG11bHRpYmFzZShuYW1lLCBCdWZmZXIuZnJvbShiYXNlLmVuY29kZShidWYpKSlcbn1cblxuLyoqXG4gKiBUYWtlcyBhIGJ1ZmZlciBvciBzdHJpbmcgZW5jb2RlZCB3aXRoIG11bHRpYmFzZSBoZWFkZXIsIGRlY29kZXMgaXQgYW5kXG4gKiByZXR1cm5zIHRoZSBkZWNvZGVkIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfHN0cmluZ30gYnVmT3JTdHJpbmdcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKiBAbWVtYmVyb2YgTXVsdGliYXNlXG4gKlxuICovXG5mdW5jdGlvbiBkZWNvZGUgKGJ1Zk9yU3RyaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmT3JTdHJpbmcpKSB7XG4gICAgYnVmT3JTdHJpbmcgPSBidWZPclN0cmluZy50b1N0cmluZygpXG4gIH1cblxuICBjb25zdCBjb2RlID0gYnVmT3JTdHJpbmcuc3Vic3RyaW5nKDAsIDEpXG4gIGJ1Zk9yU3RyaW5nID0gYnVmT3JTdHJpbmcuc3Vic3RyaW5nKDEsIGJ1Zk9yU3RyaW5nLmxlbmd0aClcblxuICBpZiAodHlwZW9mIGJ1Zk9yU3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgIGJ1Zk9yU3RyaW5nID0gQnVmZmVyLmZyb20oYnVmT3JTdHJpbmcpXG4gIH1cblxuICBjb25zdCBiYXNlID0gZ2V0QmFzZShjb2RlKVxuICByZXR1cm4gQnVmZmVyLmZyb20oYmFzZS5kZWNvZGUoYnVmT3JTdHJpbmcudG9TdHJpbmcoKSkpXG59XG5cbi8qKlxuICogSXMgdGhlIGdpdmVuIGRhdGEgbXVsdGliYXNlIGVuY29kZWQ/XG4gKlxuICogQHBhcmFtIHtCdWZmZXJ8c3RyaW5nfSBidWZPclN0cmluZ1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAbWVtYmVyb2YgTXVsdGliYXNlXG4gKi9cbmZ1bmN0aW9uIGlzRW5jb2RlZCAoYnVmT3JTdHJpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihidWZPclN0cmluZykpIHtcbiAgICBidWZPclN0cmluZyA9IGJ1Zk9yU3RyaW5nLnRvU3RyaW5nKClcbiAgfVxuXG4gIC8vIEVuc3VyZSBidWZPclN0cmluZyBpcyBhIHN0cmluZ1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJ1Zk9yU3RyaW5nKSAhPT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IGNvZGUgPSBidWZPclN0cmluZy5zdWJzdHJpbmcoMCwgMSlcbiAgdHJ5IHtcbiAgICBjb25zdCBiYXNlID0gZ2V0QmFzZShjb2RlKVxuICAgIHJldHVybiBiYXNlLm5hbWVcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICogQHByaXZhdGVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHZhbGlkRW5jb2RlIChuYW1lLCBidWYpIHtcbiAgY29uc3QgYmFzZSA9IGdldEJhc2UobmFtZSlcbiAgYmFzZS5kZWNvZGUoYnVmLnRvU3RyaW5nKCkpXG59XG5cbmZ1bmN0aW9uIGdldEJhc2UgKG5hbWVPckNvZGUpIHtcbiAgbGV0IGJhc2VcblxuICBpZiAoY29uc3RhbnRzLm5hbWVzW25hbWVPckNvZGVdKSB7XG4gICAgYmFzZSA9IGNvbnN0YW50cy5uYW1lc1tuYW1lT3JDb2RlXVxuICB9IGVsc2UgaWYgKGNvbnN0YW50cy5jb2Rlc1tuYW1lT3JDb2RlXSkge1xuICAgIGJhc2UgPSBjb25zdGFudHMuY29kZXNbbmFtZU9yQ29kZV1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGVuY29kaW5nJylcbiAgfVxuXG4gIGlmICghYmFzZS5pc0ltcGxlbWVudGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jhc2UgJyArIG5hbWVPckNvZGUgKyAnIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKVxuICB9XG5cbiAgcmV0dXJuIGJhc2Vcbn1cbiIsIi8qIGVzbGludCBxdW90ZS1wcm9wczogb2ZmICovXG4vKiBlc2xpbnQga2V5LXNwYWNpbmc6IG9mZiAqL1xuJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMubmFtZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgJ2lkZW50aXR5JzogICAweDAsXG4gICdzaGExJzogICAgICAgMHgxMSxcbiAgJ3NoYTItMjU2JzogICAweDEyLFxuICAnc2hhMi01MTInOiAgIDB4MTMsXG4gICdkYmwtc2hhMi0yNTYnOiAweDU2LFxuICAnc2hhMy0yMjQnOiAgIDB4MTcsXG4gICdzaGEzLTI1Nic6ICAgMHgxNixcbiAgJ3NoYTMtMzg0JzogICAweDE1LFxuICAnc2hhMy01MTInOiAgIDB4MTQsXG4gICdzaGFrZS0xMjgnOiAgMHgxOCxcbiAgJ3NoYWtlLTI1Nic6ICAweDE5LFxuICAna2VjY2FrLTIyNCc6IDB4MUEsXG4gICdrZWNjYWstMjU2JzogMHgxQixcbiAgJ2tlY2Nhay0zODQnOiAweDFDLFxuICAna2VjY2FrLTUxMic6IDB4MUQsXG4gICdtdXJtdXIzLTEyOCc6IDB4MjIsXG4gICdtdXJtdXIzLTMyJzogIDB4MjMsXG4gICdtZDQnOiAgICAgICAgIDB4ZDQsXG4gICdtZDUnOiAgICAgICAgIDB4ZDUsXG4gICdibGFrZTJiLTgnOiAgIDB4YjIwMSxcbiAgJ2JsYWtlMmItMTYnOiAgMHhiMjAyLFxuICAnYmxha2UyYi0yNCc6ICAweGIyMDMsXG4gICdibGFrZTJiLTMyJzogIDB4YjIwNCxcbiAgJ2JsYWtlMmItNDAnOiAgMHhiMjA1LFxuICAnYmxha2UyYi00OCc6ICAweGIyMDYsXG4gICdibGFrZTJiLTU2JzogIDB4YjIwNyxcbiAgJ2JsYWtlMmItNjQnOiAgMHhiMjA4LFxuICAnYmxha2UyYi03Mic6ICAweGIyMDksXG4gICdibGFrZTJiLTgwJzogIDB4YjIwYSxcbiAgJ2JsYWtlMmItODgnOiAgMHhiMjBiLFxuICAnYmxha2UyYi05Nic6ICAweGIyMGMsXG4gICdibGFrZTJiLTEwNCc6IDB4YjIwZCxcbiAgJ2JsYWtlMmItMTEyJzogMHhiMjBlLFxuICAnYmxha2UyYi0xMjAnOiAweGIyMGYsXG4gICdibGFrZTJiLTEyOCc6IDB4YjIxMCxcbiAgJ2JsYWtlMmItMTM2JzogMHhiMjExLFxuICAnYmxha2UyYi0xNDQnOiAweGIyMTIsXG4gICdibGFrZTJiLTE1Mic6IDB4YjIxMyxcbiAgJ2JsYWtlMmItMTYwJzogMHhiMjE0LFxuICAnYmxha2UyYi0xNjgnOiAweGIyMTUsXG4gICdibGFrZTJiLTE3Nic6IDB4YjIxNixcbiAgJ2JsYWtlMmItMTg0JzogMHhiMjE3LFxuICAnYmxha2UyYi0xOTInOiAweGIyMTgsXG4gICdibGFrZTJiLTIwMCc6IDB4YjIxOSxcbiAgJ2JsYWtlMmItMjA4JzogMHhiMjFhLFxuICAnYmxha2UyYi0yMTYnOiAweGIyMWIsXG4gICdibGFrZTJiLTIyNCc6IDB4YjIxYyxcbiAgJ2JsYWtlMmItMjMyJzogMHhiMjFkLFxuICAnYmxha2UyYi0yNDAnOiAweGIyMWUsXG4gICdibGFrZTJiLTI0OCc6IDB4YjIxZixcbiAgJ2JsYWtlMmItMjU2JzogMHhiMjIwLFxuICAnYmxha2UyYi0yNjQnOiAweGIyMjEsXG4gICdibGFrZTJiLTI3Mic6IDB4YjIyMixcbiAgJ2JsYWtlMmItMjgwJzogMHhiMjIzLFxuICAnYmxha2UyYi0yODgnOiAweGIyMjQsXG4gICdibGFrZTJiLTI5Nic6IDB4YjIyNSxcbiAgJ2JsYWtlMmItMzA0JzogMHhiMjI2LFxuICAnYmxha2UyYi0zMTInOiAweGIyMjcsXG4gICdibGFrZTJiLTMyMCc6IDB4YjIyOCxcbiAgJ2JsYWtlMmItMzI4JzogMHhiMjI5LFxuICAnYmxha2UyYi0zMzYnOiAweGIyMmEsXG4gICdibGFrZTJiLTM0NCc6IDB4YjIyYixcbiAgJ2JsYWtlMmItMzUyJzogMHhiMjJjLFxuICAnYmxha2UyYi0zNjAnOiAweGIyMmQsXG4gICdibGFrZTJiLTM2OCc6IDB4YjIyZSxcbiAgJ2JsYWtlMmItMzc2JzogMHhiMjJmLFxuICAnYmxha2UyYi0zODQnOiAweGIyMzAsXG4gICdibGFrZTJiLTM5Mic6IDB4YjIzMSxcbiAgJ2JsYWtlMmItNDAwJzogMHhiMjMyLFxuICAnYmxha2UyYi00MDgnOiAweGIyMzMsXG4gICdibGFrZTJiLTQxNic6IDB4YjIzNCxcbiAgJ2JsYWtlMmItNDI0JzogMHhiMjM1LFxuICAnYmxha2UyYi00MzInOiAweGIyMzYsXG4gICdibGFrZTJiLTQ0MCc6IDB4YjIzNyxcbiAgJ2JsYWtlMmItNDQ4JzogMHhiMjM4LFxuICAnYmxha2UyYi00NTYnOiAweGIyMzksXG4gICdibGFrZTJiLTQ2NCc6IDB4YjIzYSxcbiAgJ2JsYWtlMmItNDcyJzogMHhiMjNiLFxuICAnYmxha2UyYi00ODAnOiAweGIyM2MsXG4gICdibGFrZTJiLTQ4OCc6IDB4YjIzZCxcbiAgJ2JsYWtlMmItNDk2JzogMHhiMjNlLFxuICAnYmxha2UyYi01MDQnOiAweGIyM2YsXG4gICdibGFrZTJiLTUxMic6IDB4YjI0MCxcbiAgJ2JsYWtlMnMtOCc6ICAgMHhiMjQxLFxuICAnYmxha2Uycy0xNic6ICAweGIyNDIsXG4gICdibGFrZTJzLTI0JzogIDB4YjI0MyxcbiAgJ2JsYWtlMnMtMzInOiAgMHhiMjQ0LFxuICAnYmxha2Uycy00MCc6ICAweGIyNDUsXG4gICdibGFrZTJzLTQ4JzogIDB4YjI0NixcbiAgJ2JsYWtlMnMtNTYnOiAgMHhiMjQ3LFxuICAnYmxha2Uycy02NCc6ICAweGIyNDgsXG4gICdibGFrZTJzLTcyJzogIDB4YjI0OSxcbiAgJ2JsYWtlMnMtODAnOiAgMHhiMjRhLFxuICAnYmxha2Uycy04OCc6ICAweGIyNGIsXG4gICdibGFrZTJzLTk2JzogIDB4YjI0YyxcbiAgJ2JsYWtlMnMtMTA0JzogMHhiMjRkLFxuICAnYmxha2Uycy0xMTInOiAweGIyNGUsXG4gICdibGFrZTJzLTEyMCc6IDB4YjI0ZixcbiAgJ2JsYWtlMnMtMTI4JzogMHhiMjUwLFxuICAnYmxha2Uycy0xMzYnOiAweGIyNTEsXG4gICdibGFrZTJzLTE0NCc6IDB4YjI1MixcbiAgJ2JsYWtlMnMtMTUyJzogMHhiMjUzLFxuICAnYmxha2Uycy0xNjAnOiAweGIyNTQsXG4gICdibGFrZTJzLTE2OCc6IDB4YjI1NSxcbiAgJ2JsYWtlMnMtMTc2JzogMHhiMjU2LFxuICAnYmxha2Uycy0xODQnOiAweGIyNTcsXG4gICdibGFrZTJzLTE5Mic6IDB4YjI1OCxcbiAgJ2JsYWtlMnMtMjAwJzogMHhiMjU5LFxuICAnYmxha2Uycy0yMDgnOiAweGIyNWEsXG4gICdibGFrZTJzLTIxNic6IDB4YjI1YixcbiAgJ2JsYWtlMnMtMjI0JzogMHhiMjVjLFxuICAnYmxha2Uycy0yMzInOiAweGIyNWQsXG4gICdibGFrZTJzLTI0MCc6IDB4YjI1ZSxcbiAgJ2JsYWtlMnMtMjQ4JzogMHhiMjVmLFxuICAnYmxha2Uycy0yNTYnOiAweGIyNjAsXG4gICdTa2VpbjI1Ni04JzogMHhiMzAxLFxuICAnU2tlaW4yNTYtMTYnOiAweGIzMDIsXG4gICdTa2VpbjI1Ni0yNCc6IDB4YjMwMyxcbiAgJ1NrZWluMjU2LTMyJzogMHhiMzA0LFxuICAnU2tlaW4yNTYtNDAnOiAweGIzMDUsXG4gICdTa2VpbjI1Ni00OCc6IDB4YjMwNixcbiAgJ1NrZWluMjU2LTU2JzogMHhiMzA3LFxuICAnU2tlaW4yNTYtNjQnOiAweGIzMDgsXG4gICdTa2VpbjI1Ni03Mic6IDB4YjMwOSxcbiAgJ1NrZWluMjU2LTgwJzogMHhiMzBhLFxuICAnU2tlaW4yNTYtODgnOiAweGIzMGIsXG4gICdTa2VpbjI1Ni05Nic6IDB4YjMwYyxcbiAgJ1NrZWluMjU2LTEwNCc6IDB4YjMwZCxcbiAgJ1NrZWluMjU2LTExMic6IDB4YjMwZSxcbiAgJ1NrZWluMjU2LTEyMCc6IDB4YjMwZixcbiAgJ1NrZWluMjU2LTEyOCc6IDB4YjMxMCxcbiAgJ1NrZWluMjU2LTEzNic6IDB4YjMxMSxcbiAgJ1NrZWluMjU2LTE0NCc6IDB4YjMxMixcbiAgJ1NrZWluMjU2LTE1Mic6IDB4YjMxMyxcbiAgJ1NrZWluMjU2LTE2MCc6IDB4YjMxNCxcbiAgJ1NrZWluMjU2LTE2OCc6IDB4YjMxNSxcbiAgJ1NrZWluMjU2LTE3Nic6IDB4YjMxNixcbiAgJ1NrZWluMjU2LTE4NCc6IDB4YjMxNyxcbiAgJ1NrZWluMjU2LTE5Mic6IDB4YjMxOCxcbiAgJ1NrZWluMjU2LTIwMCc6IDB4YjMxOSxcbiAgJ1NrZWluMjU2LTIwOCc6IDB4YjMxYSxcbiAgJ1NrZWluMjU2LTIxNic6IDB4YjMxYixcbiAgJ1NrZWluMjU2LTIyNCc6IDB4YjMxYyxcbiAgJ1NrZWluMjU2LTIzMic6IDB4YjMxZCxcbiAgJ1NrZWluMjU2LTI0MCc6IDB4YjMxZSxcbiAgJ1NrZWluMjU2LTI0OCc6IDB4YjMxZixcbiAgJ1NrZWluMjU2LTI1Nic6IDB4YjMyMCxcbiAgJ1NrZWluNTEyLTgnOiAweGIzMjEsXG4gICdTa2VpbjUxMi0xNic6IDB4YjMyMixcbiAgJ1NrZWluNTEyLTI0JzogMHhiMzIzLFxuICAnU2tlaW41MTItMzInOiAweGIzMjQsXG4gICdTa2VpbjUxMi00MCc6IDB4YjMyNSxcbiAgJ1NrZWluNTEyLTQ4JzogMHhiMzI2LFxuICAnU2tlaW41MTItNTYnOiAweGIzMjcsXG4gICdTa2VpbjUxMi02NCc6IDB4YjMyOCxcbiAgJ1NrZWluNTEyLTcyJzogMHhiMzI5LFxuICAnU2tlaW41MTItODAnOiAweGIzMmEsXG4gICdTa2VpbjUxMi04OCc6IDB4YjMyYixcbiAgJ1NrZWluNTEyLTk2JzogMHhiMzJjLFxuICAnU2tlaW41MTItMTA0JzogMHhiMzJkLFxuICAnU2tlaW41MTItMTEyJzogMHhiMzJlLFxuICAnU2tlaW41MTItMTIwJzogMHhiMzJmLFxuICAnU2tlaW41MTItMTI4JzogMHhiMzMwLFxuICAnU2tlaW41MTItMTM2JzogMHhiMzMxLFxuICAnU2tlaW41MTItMTQ0JzogMHhiMzMyLFxuICAnU2tlaW41MTItMTUyJzogMHhiMzMzLFxuICAnU2tlaW41MTItMTYwJzogMHhiMzM0LFxuICAnU2tlaW41MTItMTY4JzogMHhiMzM1LFxuICAnU2tlaW41MTItMTc2JzogMHhiMzM2LFxuICAnU2tlaW41MTItMTg0JzogMHhiMzM3LFxuICAnU2tlaW41MTItMTkyJzogMHhiMzM4LFxuICAnU2tlaW41MTItMjAwJzogMHhiMzM5LFxuICAnU2tlaW41MTItMjA4JzogMHhiMzNhLFxuICAnU2tlaW41MTItMjE2JzogMHhiMzNiLFxuICAnU2tlaW41MTItMjI0JzogMHhiMzNjLFxuICAnU2tlaW41MTItMjMyJzogMHhiMzNkLFxuICAnU2tlaW41MTItMjQwJzogMHhiMzNlLFxuICAnU2tlaW41MTItMjQ4JzogMHhiMzNmLFxuICAnU2tlaW41MTItMjU2JzogMHhiMzQwLFxuICAnU2tlaW41MTItMjY0JzogMHhiMzQxLFxuICAnU2tlaW41MTItMjcyJzogMHhiMzQyLFxuICAnU2tlaW41MTItMjgwJzogMHhiMzQzLFxuICAnU2tlaW41MTItMjg4JzogMHhiMzQ0LFxuICAnU2tlaW41MTItMjk2JzogMHhiMzQ1LFxuICAnU2tlaW41MTItMzA0JzogMHhiMzQ2LFxuICAnU2tlaW41MTItMzEyJzogMHhiMzQ3LFxuICAnU2tlaW41MTItMzIwJzogMHhiMzQ4LFxuICAnU2tlaW41MTItMzI4JzogMHhiMzQ5LFxuICAnU2tlaW41MTItMzM2JzogMHhiMzRhLFxuICAnU2tlaW41MTItMzQ0JzogMHhiMzRiLFxuICAnU2tlaW41MTItMzUyJzogMHhiMzRjLFxuICAnU2tlaW41MTItMzYwJzogMHhiMzRkLFxuICAnU2tlaW41MTItMzY4JzogMHhiMzRlLFxuICAnU2tlaW41MTItMzc2JzogMHhiMzRmLFxuICAnU2tlaW41MTItMzg0JzogMHhiMzUwLFxuICAnU2tlaW41MTItMzkyJzogMHhiMzUxLFxuICAnU2tlaW41MTItNDAwJzogMHhiMzUyLFxuICAnU2tlaW41MTItNDA4JzogMHhiMzUzLFxuICAnU2tlaW41MTItNDE2JzogMHhiMzU0LFxuICAnU2tlaW41MTItNDI0JzogMHhiMzU1LFxuICAnU2tlaW41MTItNDMyJzogMHhiMzU2LFxuICAnU2tlaW41MTItNDQwJzogMHhiMzU3LFxuICAnU2tlaW41MTItNDQ4JzogMHhiMzU4LFxuICAnU2tlaW41MTItNDU2JzogMHhiMzU5LFxuICAnU2tlaW41MTItNDY0JzogMHhiMzVhLFxuICAnU2tlaW41MTItNDcyJzogMHhiMzViLFxuICAnU2tlaW41MTItNDgwJzogMHhiMzVjLFxuICAnU2tlaW41MTItNDg4JzogMHhiMzVkLFxuICAnU2tlaW41MTItNDk2JzogMHhiMzVlLFxuICAnU2tlaW41MTItNTA0JzogMHhiMzVmLFxuICAnU2tlaW41MTItNTEyJzogMHhiMzYwLFxuICAnU2tlaW4xMDI0LTgnOiAweGIzNjEsXG4gICdTa2VpbjEwMjQtMTYnOiAweGIzNjIsXG4gICdTa2VpbjEwMjQtMjQnOiAweGIzNjMsXG4gICdTa2VpbjEwMjQtMzInOiAweGIzNjQsXG4gICdTa2VpbjEwMjQtNDAnOiAweGIzNjUsXG4gICdTa2VpbjEwMjQtNDgnOiAweGIzNjYsXG4gICdTa2VpbjEwMjQtNTYnOiAweGIzNjcsXG4gICdTa2VpbjEwMjQtNjQnOiAweGIzNjgsXG4gICdTa2VpbjEwMjQtNzInOiAweGIzNjksXG4gICdTa2VpbjEwMjQtODAnOiAweGIzNmEsXG4gICdTa2VpbjEwMjQtODgnOiAweGIzNmIsXG4gICdTa2VpbjEwMjQtOTYnOiAweGIzNmMsXG4gICdTa2VpbjEwMjQtMTA0JzogMHhiMzZkLFxuICAnU2tlaW4xMDI0LTExMic6IDB4YjM2ZSxcbiAgJ1NrZWluMTAyNC0xMjAnOiAweGIzNmYsXG4gICdTa2VpbjEwMjQtMTI4JzogMHhiMzcwLFxuICAnU2tlaW4xMDI0LTEzNic6IDB4YjM3MSxcbiAgJ1NrZWluMTAyNC0xNDQnOiAweGIzNzIsXG4gICdTa2VpbjEwMjQtMTUyJzogMHhiMzczLFxuICAnU2tlaW4xMDI0LTE2MCc6IDB4YjM3NCxcbiAgJ1NrZWluMTAyNC0xNjgnOiAweGIzNzUsXG4gICdTa2VpbjEwMjQtMTc2JzogMHhiMzc2LFxuICAnU2tlaW4xMDI0LTE4NCc6IDB4YjM3NyxcbiAgJ1NrZWluMTAyNC0xOTInOiAweGIzNzgsXG4gICdTa2VpbjEwMjQtMjAwJzogMHhiMzc5LFxuICAnU2tlaW4xMDI0LTIwOCc6IDB4YjM3YSxcbiAgJ1NrZWluMTAyNC0yMTYnOiAweGIzN2IsXG4gICdTa2VpbjEwMjQtMjI0JzogMHhiMzdjLFxuICAnU2tlaW4xMDI0LTIzMic6IDB4YjM3ZCxcbiAgJ1NrZWluMTAyNC0yNDAnOiAweGIzN2UsXG4gICdTa2VpbjEwMjQtMjQ4JzogMHhiMzdmLFxuICAnU2tlaW4xMDI0LTI1Nic6IDB4YjM4MCxcbiAgJ1NrZWluMTAyNC0yNjQnOiAweGIzODEsXG4gICdTa2VpbjEwMjQtMjcyJzogMHhiMzgyLFxuICAnU2tlaW4xMDI0LTI4MCc6IDB4YjM4MyxcbiAgJ1NrZWluMTAyNC0yODgnOiAweGIzODQsXG4gICdTa2VpbjEwMjQtMjk2JzogMHhiMzg1LFxuICAnU2tlaW4xMDI0LTMwNCc6IDB4YjM4NixcbiAgJ1NrZWluMTAyNC0zMTInOiAweGIzODcsXG4gICdTa2VpbjEwMjQtMzIwJzogMHhiMzg4LFxuICAnU2tlaW4xMDI0LTMyOCc6IDB4YjM4OSxcbiAgJ1NrZWluMTAyNC0zMzYnOiAweGIzOGEsXG4gICdTa2VpbjEwMjQtMzQ0JzogMHhiMzhiLFxuICAnU2tlaW4xMDI0LTM1Mic6IDB4YjM4YyxcbiAgJ1NrZWluMTAyNC0zNjAnOiAweGIzOGQsXG4gICdTa2VpbjEwMjQtMzY4JzogMHhiMzhlLFxuICAnU2tlaW4xMDI0LTM3Nic6IDB4YjM4ZixcbiAgJ1NrZWluMTAyNC0zODQnOiAweGIzOTAsXG4gICdTa2VpbjEwMjQtMzkyJzogMHhiMzkxLFxuICAnU2tlaW4xMDI0LTQwMCc6IDB4YjM5MixcbiAgJ1NrZWluMTAyNC00MDgnOiAweGIzOTMsXG4gICdTa2VpbjEwMjQtNDE2JzogMHhiMzk0LFxuICAnU2tlaW4xMDI0LTQyNCc6IDB4YjM5NSxcbiAgJ1NrZWluMTAyNC00MzInOiAweGIzOTYsXG4gICdTa2VpbjEwMjQtNDQwJzogMHhiMzk3LFxuICAnU2tlaW4xMDI0LTQ0OCc6IDB4YjM5OCxcbiAgJ1NrZWluMTAyNC00NTYnOiAweGIzOTksXG4gICdTa2VpbjEwMjQtNDY0JzogMHhiMzlhLFxuICAnU2tlaW4xMDI0LTQ3Mic6IDB4YjM5YixcbiAgJ1NrZWluMTAyNC00ODAnOiAweGIzOWMsXG4gICdTa2VpbjEwMjQtNDg4JzogMHhiMzlkLFxuICAnU2tlaW4xMDI0LTQ5Nic6IDB4YjM5ZSxcbiAgJ1NrZWluMTAyNC01MDQnOiAweGIzOWYsXG4gICdTa2VpbjEwMjQtNTEyJzogMHhiM2EwLFxuICAnU2tlaW4xMDI0LTUyMCc6IDB4YjNhMSxcbiAgJ1NrZWluMTAyNC01MjgnOiAweGIzYTIsXG4gICdTa2VpbjEwMjQtNTM2JzogMHhiM2EzLFxuICAnU2tlaW4xMDI0LTU0NCc6IDB4YjNhNCxcbiAgJ1NrZWluMTAyNC01NTInOiAweGIzYTUsXG4gICdTa2VpbjEwMjQtNTYwJzogMHhiM2E2LFxuICAnU2tlaW4xMDI0LTU2OCc6IDB4YjNhNyxcbiAgJ1NrZWluMTAyNC01NzYnOiAweGIzYTgsXG4gICdTa2VpbjEwMjQtNTg0JzogMHhiM2E5LFxuICAnU2tlaW4xMDI0LTU5Mic6IDB4YjNhYSxcbiAgJ1NrZWluMTAyNC02MDAnOiAweGIzYWIsXG4gICdTa2VpbjEwMjQtNjA4JzogMHhiM2FjLFxuICAnU2tlaW4xMDI0LTYxNic6IDB4YjNhZCxcbiAgJ1NrZWluMTAyNC02MjQnOiAweGIzYWUsXG4gICdTa2VpbjEwMjQtNjMyJzogMHhiM2FmLFxuICAnU2tlaW4xMDI0LTY0MCc6IDB4YjNiMCxcbiAgJ1NrZWluMTAyNC02NDgnOiAweGIzYjEsXG4gICdTa2VpbjEwMjQtNjU2JzogMHhiM2IyLFxuICAnU2tlaW4xMDI0LTY2NCc6IDB4YjNiMyxcbiAgJ1NrZWluMTAyNC02NzInOiAweGIzYjQsXG4gICdTa2VpbjEwMjQtNjgwJzogMHhiM2I1LFxuICAnU2tlaW4xMDI0LTY4OCc6IDB4YjNiNixcbiAgJ1NrZWluMTAyNC02OTYnOiAweGIzYjcsXG4gICdTa2VpbjEwMjQtNzA0JzogMHhiM2I4LFxuICAnU2tlaW4xMDI0LTcxMic6IDB4YjNiOSxcbiAgJ1NrZWluMTAyNC03MjAnOiAweGIzYmEsXG4gICdTa2VpbjEwMjQtNzI4JzogMHhiM2JiLFxuICAnU2tlaW4xMDI0LTczNic6IDB4YjNiYyxcbiAgJ1NrZWluMTAyNC03NDQnOiAweGIzYmQsXG4gICdTa2VpbjEwMjQtNzUyJzogMHhiM2JlLFxuICAnU2tlaW4xMDI0LTc2MCc6IDB4YjNiZixcbiAgJ1NrZWluMTAyNC03NjgnOiAweGIzYzAsXG4gICdTa2VpbjEwMjQtNzc2JzogMHhiM2MxLFxuICAnU2tlaW4xMDI0LTc4NCc6IDB4YjNjMixcbiAgJ1NrZWluMTAyNC03OTInOiAweGIzYzMsXG4gICdTa2VpbjEwMjQtODAwJzogMHhiM2M0LFxuICAnU2tlaW4xMDI0LTgwOCc6IDB4YjNjNSxcbiAgJ1NrZWluMTAyNC04MTYnOiAweGIzYzYsXG4gICdTa2VpbjEwMjQtODI0JzogMHhiM2M3LFxuICAnU2tlaW4xMDI0LTgzMic6IDB4YjNjOCxcbiAgJ1NrZWluMTAyNC04NDAnOiAweGIzYzksXG4gICdTa2VpbjEwMjQtODQ4JzogMHhiM2NhLFxuICAnU2tlaW4xMDI0LTg1Nic6IDB4YjNjYixcbiAgJ1NrZWluMTAyNC04NjQnOiAweGIzY2MsXG4gICdTa2VpbjEwMjQtODcyJzogMHhiM2NkLFxuICAnU2tlaW4xMDI0LTg4MCc6IDB4YjNjZSxcbiAgJ1NrZWluMTAyNC04ODgnOiAweGIzY2YsXG4gICdTa2VpbjEwMjQtODk2JzogMHhiM2QwLFxuICAnU2tlaW4xMDI0LTkwNCc6IDB4YjNkMSxcbiAgJ1NrZWluMTAyNC05MTInOiAweGIzZDIsXG4gICdTa2VpbjEwMjQtOTIwJzogMHhiM2QzLFxuICAnU2tlaW4xMDI0LTkyOCc6IDB4YjNkNCxcbiAgJ1NrZWluMTAyNC05MzYnOiAweGIzZDUsXG4gICdTa2VpbjEwMjQtOTQ0JzogMHhiM2Q2LFxuICAnU2tlaW4xMDI0LTk1Mic6IDB4YjNkNyxcbiAgJ1NrZWluMTAyNC05NjAnOiAweGIzZDgsXG4gICdTa2VpbjEwMjQtOTY4JzogMHhiM2Q5LFxuICAnU2tlaW4xMDI0LTk3Nic6IDB4YjNkYSxcbiAgJ1NrZWluMTAyNC05ODQnOiAweGIzZGIsXG4gICdTa2VpbjEwMjQtOTkyJzogMHhiM2RjLFxuICAnU2tlaW4xMDI0LTEwMDAnOiAweGIzZGQsXG4gICdTa2VpbjEwMjQtMTAwOCc6IDB4YjNkZSxcbiAgJ1NrZWluMTAyNC0xMDE2JzogMHhiM2RmLFxuICAnU2tlaW4xMDI0LTEwMjQnOiAweGIzZTBcbn0pXG5cbmV4cG9ydHMuY29kZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgMHgwOiAnaWRlbnRpdHknLFxuXG4gIC8vIHNoYSBmYW1pbHlcbiAgMHgxMTogJ3NoYTEnLFxuICAweDEyOiAnc2hhMi0yNTYnLFxuICAweDEzOiAnc2hhMi01MTInLFxuICAweDU2OiAnZGJsLXNoYTItMjU2JyxcbiAgMHgxNzogJ3NoYTMtMjI0JyxcbiAgMHgxNjogJ3NoYTMtMjU2JyxcbiAgMHgxNTogJ3NoYTMtMzg0JyxcbiAgMHgxNDogJ3NoYTMtNTEyJyxcbiAgMHgxODogJ3NoYWtlLTEyOCcsXG4gIDB4MTk6ICdzaGFrZS0yNTYnLFxuICAweDFBOiAna2VjY2FrLTIyNCcsXG4gIDB4MUI6ICdrZWNjYWstMjU2JyxcbiAgMHgxQzogJ2tlY2Nhay0zODQnLFxuICAweDFEOiAna2VjY2FrLTUxMicsXG5cbiAgMHgyMjogJ211cm11cjMtMTI4JyxcbiAgMHgyMzogJ211cm11cjMtMzInLFxuXG4gIDB4ZDQ6ICdtZDQnLFxuICAweGQ1OiAnbWQ1JyxcblxuICAvLyBibGFrZTJcbiAgMHhiMjAxOiAnYmxha2UyYi04JyxcbiAgMHhiMjAyOiAnYmxha2UyYi0xNicsXG4gIDB4YjIwMzogJ2JsYWtlMmItMjQnLFxuICAweGIyMDQ6ICdibGFrZTJiLTMyJyxcbiAgMHhiMjA1OiAnYmxha2UyYi00MCcsXG4gIDB4YjIwNjogJ2JsYWtlMmItNDgnLFxuICAweGIyMDc6ICdibGFrZTJiLTU2JyxcbiAgMHhiMjA4OiAnYmxha2UyYi02NCcsXG4gIDB4YjIwOTogJ2JsYWtlMmItNzInLFxuICAweGIyMGE6ICdibGFrZTJiLTgwJyxcbiAgMHhiMjBiOiAnYmxha2UyYi04OCcsXG4gIDB4YjIwYzogJ2JsYWtlMmItOTYnLFxuICAweGIyMGQ6ICdibGFrZTJiLTEwNCcsXG4gIDB4YjIwZTogJ2JsYWtlMmItMTEyJyxcbiAgMHhiMjBmOiAnYmxha2UyYi0xMjAnLFxuICAweGIyMTA6ICdibGFrZTJiLTEyOCcsXG4gIDB4YjIxMTogJ2JsYWtlMmItMTM2JyxcbiAgMHhiMjEyOiAnYmxha2UyYi0xNDQnLFxuICAweGIyMTM6ICdibGFrZTJiLTE1MicsXG4gIDB4YjIxNDogJ2JsYWtlMmItMTYwJyxcbiAgMHhiMjE1OiAnYmxha2UyYi0xNjgnLFxuICAweGIyMTY6ICdibGFrZTJiLTE3NicsXG4gIDB4YjIxNzogJ2JsYWtlMmItMTg0JyxcbiAgMHhiMjE4OiAnYmxha2UyYi0xOTInLFxuICAweGIyMTk6ICdibGFrZTJiLTIwMCcsXG4gIDB4YjIxYTogJ2JsYWtlMmItMjA4JyxcbiAgMHhiMjFiOiAnYmxha2UyYi0yMTYnLFxuICAweGIyMWM6ICdibGFrZTJiLTIyNCcsXG4gIDB4YjIxZDogJ2JsYWtlMmItMjMyJyxcbiAgMHhiMjFlOiAnYmxha2UyYi0yNDAnLFxuICAweGIyMWY6ICdibGFrZTJiLTI0OCcsXG4gIDB4YjIyMDogJ2JsYWtlMmItMjU2JyxcbiAgMHhiMjIxOiAnYmxha2UyYi0yNjQnLFxuICAweGIyMjI6ICdibGFrZTJiLTI3MicsXG4gIDB4YjIyMzogJ2JsYWtlMmItMjgwJyxcbiAgMHhiMjI0OiAnYmxha2UyYi0yODgnLFxuICAweGIyMjU6ICdibGFrZTJiLTI5NicsXG4gIDB4YjIyNjogJ2JsYWtlMmItMzA0JyxcbiAgMHhiMjI3OiAnYmxha2UyYi0zMTInLFxuICAweGIyMjg6ICdibGFrZTJiLTMyMCcsXG4gIDB4YjIyOTogJ2JsYWtlMmItMzI4JyxcbiAgMHhiMjJhOiAnYmxha2UyYi0zMzYnLFxuICAweGIyMmI6ICdibGFrZTJiLTM0NCcsXG4gIDB4YjIyYzogJ2JsYWtlMmItMzUyJyxcbiAgMHhiMjJkOiAnYmxha2UyYi0zNjAnLFxuICAweGIyMmU6ICdibGFrZTJiLTM2OCcsXG4gIDB4YjIyZjogJ2JsYWtlMmItMzc2JyxcbiAgMHhiMjMwOiAnYmxha2UyYi0zODQnLFxuICAweGIyMzE6ICdibGFrZTJiLTM5MicsXG4gIDB4YjIzMjogJ2JsYWtlMmItNDAwJyxcbiAgMHhiMjMzOiAnYmxha2UyYi00MDgnLFxuICAweGIyMzQ6ICdibGFrZTJiLTQxNicsXG4gIDB4YjIzNTogJ2JsYWtlMmItNDI0JyxcbiAgMHhiMjM2OiAnYmxha2UyYi00MzInLFxuICAweGIyMzc6ICdibGFrZTJiLTQ0MCcsXG4gIDB4YjIzODogJ2JsYWtlMmItNDQ4JyxcbiAgMHhiMjM5OiAnYmxha2UyYi00NTYnLFxuICAweGIyM2E6ICdibGFrZTJiLTQ2NCcsXG4gIDB4YjIzYjogJ2JsYWtlMmItNDcyJyxcbiAgMHhiMjNjOiAnYmxha2UyYi00ODAnLFxuICAweGIyM2Q6ICdibGFrZTJiLTQ4OCcsXG4gIDB4YjIzZTogJ2JsYWtlMmItNDk2JyxcbiAgMHhiMjNmOiAnYmxha2UyYi01MDQnLFxuICAweGIyNDA6ICdibGFrZTJiLTUxMicsXG4gIDB4YjI0MTogJ2JsYWtlMnMtOCcsXG4gIDB4YjI0MjogJ2JsYWtlMnMtMTYnLFxuICAweGIyNDM6ICdibGFrZTJzLTI0JyxcbiAgMHhiMjQ0OiAnYmxha2Uycy0zMicsXG4gIDB4YjI0NTogJ2JsYWtlMnMtNDAnLFxuICAweGIyNDY6ICdibGFrZTJzLTQ4JyxcbiAgMHhiMjQ3OiAnYmxha2Uycy01NicsXG4gIDB4YjI0ODogJ2JsYWtlMnMtNjQnLFxuICAweGIyNDk6ICdibGFrZTJzLTcyJyxcbiAgMHhiMjRhOiAnYmxha2Uycy04MCcsXG4gIDB4YjI0YjogJ2JsYWtlMnMtODgnLFxuICAweGIyNGM6ICdibGFrZTJzLTk2JyxcbiAgMHhiMjRkOiAnYmxha2Uycy0xMDQnLFxuICAweGIyNGU6ICdibGFrZTJzLTExMicsXG4gIDB4YjI0ZjogJ2JsYWtlMnMtMTIwJyxcbiAgMHhiMjUwOiAnYmxha2Uycy0xMjgnLFxuICAweGIyNTE6ICdibGFrZTJzLTEzNicsXG4gIDB4YjI1MjogJ2JsYWtlMnMtMTQ0JyxcbiAgMHhiMjUzOiAnYmxha2Uycy0xNTInLFxuICAweGIyNTQ6ICdibGFrZTJzLTE2MCcsXG4gIDB4YjI1NTogJ2JsYWtlMnMtMTY4JyxcbiAgMHhiMjU2OiAnYmxha2Uycy0xNzYnLFxuICAweGIyNTc6ICdibGFrZTJzLTE4NCcsXG4gIDB4YjI1ODogJ2JsYWtlMnMtMTkyJyxcbiAgMHhiMjU5OiAnYmxha2Uycy0yMDAnLFxuICAweGIyNWE6ICdibGFrZTJzLTIwOCcsXG4gIDB4YjI1YjogJ2JsYWtlMnMtMjE2JyxcbiAgMHhiMjVjOiAnYmxha2Uycy0yMjQnLFxuICAweGIyNWQ6ICdibGFrZTJzLTIzMicsXG4gIDB4YjI1ZTogJ2JsYWtlMnMtMjQwJyxcbiAgMHhiMjVmOiAnYmxha2Uycy0yNDgnLFxuICAweGIyNjA6ICdibGFrZTJzLTI1NicsXG5cbiAgLy8gc2tlaW5cbiAgMHhiMzAxOiAnU2tlaW4yNTYtOCcsXG4gIDB4YjMwMjogJ1NrZWluMjU2LTE2JyxcbiAgMHhiMzAzOiAnU2tlaW4yNTYtMjQnLFxuICAweGIzMDQ6ICdTa2VpbjI1Ni0zMicsXG4gIDB4YjMwNTogJ1NrZWluMjU2LTQwJyxcbiAgMHhiMzA2OiAnU2tlaW4yNTYtNDgnLFxuICAweGIzMDc6ICdTa2VpbjI1Ni01NicsXG4gIDB4YjMwODogJ1NrZWluMjU2LTY0JyxcbiAgMHhiMzA5OiAnU2tlaW4yNTYtNzInLFxuICAweGIzMGE6ICdTa2VpbjI1Ni04MCcsXG4gIDB4YjMwYjogJ1NrZWluMjU2LTg4JyxcbiAgMHhiMzBjOiAnU2tlaW4yNTYtOTYnLFxuICAweGIzMGQ6ICdTa2VpbjI1Ni0xMDQnLFxuICAweGIzMGU6ICdTa2VpbjI1Ni0xMTInLFxuICAweGIzMGY6ICdTa2VpbjI1Ni0xMjAnLFxuICAweGIzMTA6ICdTa2VpbjI1Ni0xMjgnLFxuICAweGIzMTE6ICdTa2VpbjI1Ni0xMzYnLFxuICAweGIzMTI6ICdTa2VpbjI1Ni0xNDQnLFxuICAweGIzMTM6ICdTa2VpbjI1Ni0xNTInLFxuICAweGIzMTQ6ICdTa2VpbjI1Ni0xNjAnLFxuICAweGIzMTU6ICdTa2VpbjI1Ni0xNjgnLFxuICAweGIzMTY6ICdTa2VpbjI1Ni0xNzYnLFxuICAweGIzMTc6ICdTa2VpbjI1Ni0xODQnLFxuICAweGIzMTg6ICdTa2VpbjI1Ni0xOTInLFxuICAweGIzMTk6ICdTa2VpbjI1Ni0yMDAnLFxuICAweGIzMWE6ICdTa2VpbjI1Ni0yMDgnLFxuICAweGIzMWI6ICdTa2VpbjI1Ni0yMTYnLFxuICAweGIzMWM6ICdTa2VpbjI1Ni0yMjQnLFxuICAweGIzMWQ6ICdTa2VpbjI1Ni0yMzInLFxuICAweGIzMWU6ICdTa2VpbjI1Ni0yNDAnLFxuICAweGIzMWY6ICdTa2VpbjI1Ni0yNDgnLFxuICAweGIzMjA6ICdTa2VpbjI1Ni0yNTYnLFxuICAweGIzMjE6ICdTa2VpbjUxMi04JyxcbiAgMHhiMzIyOiAnU2tlaW41MTItMTYnLFxuICAweGIzMjM6ICdTa2VpbjUxMi0yNCcsXG4gIDB4YjMyNDogJ1NrZWluNTEyLTMyJyxcbiAgMHhiMzI1OiAnU2tlaW41MTItNDAnLFxuICAweGIzMjY6ICdTa2VpbjUxMi00OCcsXG4gIDB4YjMyNzogJ1NrZWluNTEyLTU2JyxcbiAgMHhiMzI4OiAnU2tlaW41MTItNjQnLFxuICAweGIzMjk6ICdTa2VpbjUxMi03MicsXG4gIDB4YjMyYTogJ1NrZWluNTEyLTgwJyxcbiAgMHhiMzJiOiAnU2tlaW41MTItODgnLFxuICAweGIzMmM6ICdTa2VpbjUxMi05NicsXG4gIDB4YjMyZDogJ1NrZWluNTEyLTEwNCcsXG4gIDB4YjMyZTogJ1NrZWluNTEyLTExMicsXG4gIDB4YjMyZjogJ1NrZWluNTEyLTEyMCcsXG4gIDB4YjMzMDogJ1NrZWluNTEyLTEyOCcsXG4gIDB4YjMzMTogJ1NrZWluNTEyLTEzNicsXG4gIDB4YjMzMjogJ1NrZWluNTEyLTE0NCcsXG4gIDB4YjMzMzogJ1NrZWluNTEyLTE1MicsXG4gIDB4YjMzNDogJ1NrZWluNTEyLTE2MCcsXG4gIDB4YjMzNTogJ1NrZWluNTEyLTE2OCcsXG4gIDB4YjMzNjogJ1NrZWluNTEyLTE3NicsXG4gIDB4YjMzNzogJ1NrZWluNTEyLTE4NCcsXG4gIDB4YjMzODogJ1NrZWluNTEyLTE5MicsXG4gIDB4YjMzOTogJ1NrZWluNTEyLTIwMCcsXG4gIDB4YjMzYTogJ1NrZWluNTEyLTIwOCcsXG4gIDB4YjMzYjogJ1NrZWluNTEyLTIxNicsXG4gIDB4YjMzYzogJ1NrZWluNTEyLTIyNCcsXG4gIDB4YjMzZDogJ1NrZWluNTEyLTIzMicsXG4gIDB4YjMzZTogJ1NrZWluNTEyLTI0MCcsXG4gIDB4YjMzZjogJ1NrZWluNTEyLTI0OCcsXG4gIDB4YjM0MDogJ1NrZWluNTEyLTI1NicsXG4gIDB4YjM0MTogJ1NrZWluNTEyLTI2NCcsXG4gIDB4YjM0MjogJ1NrZWluNTEyLTI3MicsXG4gIDB4YjM0MzogJ1NrZWluNTEyLTI4MCcsXG4gIDB4YjM0NDogJ1NrZWluNTEyLTI4OCcsXG4gIDB4YjM0NTogJ1NrZWluNTEyLTI5NicsXG4gIDB4YjM0NjogJ1NrZWluNTEyLTMwNCcsXG4gIDB4YjM0NzogJ1NrZWluNTEyLTMxMicsXG4gIDB4YjM0ODogJ1NrZWluNTEyLTMyMCcsXG4gIDB4YjM0OTogJ1NrZWluNTEyLTMyOCcsXG4gIDB4YjM0YTogJ1NrZWluNTEyLTMzNicsXG4gIDB4YjM0YjogJ1NrZWluNTEyLTM0NCcsXG4gIDB4YjM0YzogJ1NrZWluNTEyLTM1MicsXG4gIDB4YjM0ZDogJ1NrZWluNTEyLTM2MCcsXG4gIDB4YjM0ZTogJ1NrZWluNTEyLTM2OCcsXG4gIDB4YjM0ZjogJ1NrZWluNTEyLTM3NicsXG4gIDB4YjM1MDogJ1NrZWluNTEyLTM4NCcsXG4gIDB4YjM1MTogJ1NrZWluNTEyLTM5MicsXG4gIDB4YjM1MjogJ1NrZWluNTEyLTQwMCcsXG4gIDB4YjM1MzogJ1NrZWluNTEyLTQwOCcsXG4gIDB4YjM1NDogJ1NrZWluNTEyLTQxNicsXG4gIDB4YjM1NTogJ1NrZWluNTEyLTQyNCcsXG4gIDB4YjM1NjogJ1NrZWluNTEyLTQzMicsXG4gIDB4YjM1NzogJ1NrZWluNTEyLTQ0MCcsXG4gIDB4YjM1ODogJ1NrZWluNTEyLTQ0OCcsXG4gIDB4YjM1OTogJ1NrZWluNTEyLTQ1NicsXG4gIDB4YjM1YTogJ1NrZWluNTEyLTQ2NCcsXG4gIDB4YjM1YjogJ1NrZWluNTEyLTQ3MicsXG4gIDB4YjM1YzogJ1NrZWluNTEyLTQ4MCcsXG4gIDB4YjM1ZDogJ1NrZWluNTEyLTQ4OCcsXG4gIDB4YjM1ZTogJ1NrZWluNTEyLTQ5NicsXG4gIDB4YjM1ZjogJ1NrZWluNTEyLTUwNCcsXG4gIDB4YjM2MDogJ1NrZWluNTEyLTUxMicsXG4gIDB4YjM2MTogJ1NrZWluMTAyNC04JyxcbiAgMHhiMzYyOiAnU2tlaW4xMDI0LTE2JyxcbiAgMHhiMzYzOiAnU2tlaW4xMDI0LTI0JyxcbiAgMHhiMzY0OiAnU2tlaW4xMDI0LTMyJyxcbiAgMHhiMzY1OiAnU2tlaW4xMDI0LTQwJyxcbiAgMHhiMzY2OiAnU2tlaW4xMDI0LTQ4JyxcbiAgMHhiMzY3OiAnU2tlaW4xMDI0LTU2JyxcbiAgMHhiMzY4OiAnU2tlaW4xMDI0LTY0JyxcbiAgMHhiMzY5OiAnU2tlaW4xMDI0LTcyJyxcbiAgMHhiMzZhOiAnU2tlaW4xMDI0LTgwJyxcbiAgMHhiMzZiOiAnU2tlaW4xMDI0LTg4JyxcbiAgMHhiMzZjOiAnU2tlaW4xMDI0LTk2JyxcbiAgMHhiMzZkOiAnU2tlaW4xMDI0LTEwNCcsXG4gIDB4YjM2ZTogJ1NrZWluMTAyNC0xMTInLFxuICAweGIzNmY6ICdTa2VpbjEwMjQtMTIwJyxcbiAgMHhiMzcwOiAnU2tlaW4xMDI0LTEyOCcsXG4gIDB4YjM3MTogJ1NrZWluMTAyNC0xMzYnLFxuICAweGIzNzI6ICdTa2VpbjEwMjQtMTQ0JyxcbiAgMHhiMzczOiAnU2tlaW4xMDI0LTE1MicsXG4gIDB4YjM3NDogJ1NrZWluMTAyNC0xNjAnLFxuICAweGIzNzU6ICdTa2VpbjEwMjQtMTY4JyxcbiAgMHhiMzc2OiAnU2tlaW4xMDI0LTE3NicsXG4gIDB4YjM3NzogJ1NrZWluMTAyNC0xODQnLFxuICAweGIzNzg6ICdTa2VpbjEwMjQtMTkyJyxcbiAgMHhiMzc5OiAnU2tlaW4xMDI0LTIwMCcsXG4gIDB4YjM3YTogJ1NrZWluMTAyNC0yMDgnLFxuICAweGIzN2I6ICdTa2VpbjEwMjQtMjE2JyxcbiAgMHhiMzdjOiAnU2tlaW4xMDI0LTIyNCcsXG4gIDB4YjM3ZDogJ1NrZWluMTAyNC0yMzInLFxuICAweGIzN2U6ICdTa2VpbjEwMjQtMjQwJyxcbiAgMHhiMzdmOiAnU2tlaW4xMDI0LTI0OCcsXG4gIDB4YjM4MDogJ1NrZWluMTAyNC0yNTYnLFxuICAweGIzODE6ICdTa2VpbjEwMjQtMjY0JyxcbiAgMHhiMzgyOiAnU2tlaW4xMDI0LTI3MicsXG4gIDB4YjM4MzogJ1NrZWluMTAyNC0yODAnLFxuICAweGIzODQ6ICdTa2VpbjEwMjQtMjg4JyxcbiAgMHhiMzg1OiAnU2tlaW4xMDI0LTI5NicsXG4gIDB4YjM4NjogJ1NrZWluMTAyNC0zMDQnLFxuICAweGIzODc6ICdTa2VpbjEwMjQtMzEyJyxcbiAgMHhiMzg4OiAnU2tlaW4xMDI0LTMyMCcsXG4gIDB4YjM4OTogJ1NrZWluMTAyNC0zMjgnLFxuICAweGIzOGE6ICdTa2VpbjEwMjQtMzM2JyxcbiAgMHhiMzhiOiAnU2tlaW4xMDI0LTM0NCcsXG4gIDB4YjM4YzogJ1NrZWluMTAyNC0zNTInLFxuICAweGIzOGQ6ICdTa2VpbjEwMjQtMzYwJyxcbiAgMHhiMzhlOiAnU2tlaW4xMDI0LTM2OCcsXG4gIDB4YjM4ZjogJ1NrZWluMTAyNC0zNzYnLFxuICAweGIzOTA6ICdTa2VpbjEwMjQtMzg0JyxcbiAgMHhiMzkxOiAnU2tlaW4xMDI0LTM5MicsXG4gIDB4YjM5MjogJ1NrZWluMTAyNC00MDAnLFxuICAweGIzOTM6ICdTa2VpbjEwMjQtNDA4JyxcbiAgMHhiMzk0OiAnU2tlaW4xMDI0LTQxNicsXG4gIDB4YjM5NTogJ1NrZWluMTAyNC00MjQnLFxuICAweGIzOTY6ICdTa2VpbjEwMjQtNDMyJyxcbiAgMHhiMzk3OiAnU2tlaW4xMDI0LTQ0MCcsXG4gIDB4YjM5ODogJ1NrZWluMTAyNC00NDgnLFxuICAweGIzOTk6ICdTa2VpbjEwMjQtNDU2JyxcbiAgMHhiMzlhOiAnU2tlaW4xMDI0LTQ2NCcsXG4gIDB4YjM5YjogJ1NrZWluMTAyNC00NzInLFxuICAweGIzOWM6ICdTa2VpbjEwMjQtNDgwJyxcbiAgMHhiMzlkOiAnU2tlaW4xMDI0LTQ4OCcsXG4gIDB4YjM5ZTogJ1NrZWluMTAyNC00OTYnLFxuICAweGIzOWY6ICdTa2VpbjEwMjQtNTA0JyxcbiAgMHhiM2EwOiAnU2tlaW4xMDI0LTUxMicsXG4gIDB4YjNhMTogJ1NrZWluMTAyNC01MjAnLFxuICAweGIzYTI6ICdTa2VpbjEwMjQtNTI4JyxcbiAgMHhiM2EzOiAnU2tlaW4xMDI0LTUzNicsXG4gIDB4YjNhNDogJ1NrZWluMTAyNC01NDQnLFxuICAweGIzYTU6ICdTa2VpbjEwMjQtNTUyJyxcbiAgMHhiM2E2OiAnU2tlaW4xMDI0LTU2MCcsXG4gIDB4YjNhNzogJ1NrZWluMTAyNC01NjgnLFxuICAweGIzYTg6ICdTa2VpbjEwMjQtNTc2JyxcbiAgMHhiM2E5OiAnU2tlaW4xMDI0LTU4NCcsXG4gIDB4YjNhYTogJ1NrZWluMTAyNC01OTInLFxuICAweGIzYWI6ICdTa2VpbjEwMjQtNjAwJyxcbiAgMHhiM2FjOiAnU2tlaW4xMDI0LTYwOCcsXG4gIDB4YjNhZDogJ1NrZWluMTAyNC02MTYnLFxuICAweGIzYWU6ICdTa2VpbjEwMjQtNjI0JyxcbiAgMHhiM2FmOiAnU2tlaW4xMDI0LTYzMicsXG4gIDB4YjNiMDogJ1NrZWluMTAyNC02NDAnLFxuICAweGIzYjE6ICdTa2VpbjEwMjQtNjQ4JyxcbiAgMHhiM2IyOiAnU2tlaW4xMDI0LTY1NicsXG4gIDB4YjNiMzogJ1NrZWluMTAyNC02NjQnLFxuICAweGIzYjQ6ICdTa2VpbjEwMjQtNjcyJyxcbiAgMHhiM2I1OiAnU2tlaW4xMDI0LTY4MCcsXG4gIDB4YjNiNjogJ1NrZWluMTAyNC02ODgnLFxuICAweGIzYjc6ICdTa2VpbjEwMjQtNjk2JyxcbiAgMHhiM2I4OiAnU2tlaW4xMDI0LTcwNCcsXG4gIDB4YjNiOTogJ1NrZWluMTAyNC03MTInLFxuICAweGIzYmE6ICdTa2VpbjEwMjQtNzIwJyxcbiAgMHhiM2JiOiAnU2tlaW4xMDI0LTcyOCcsXG4gIDB4YjNiYzogJ1NrZWluMTAyNC03MzYnLFxuICAweGIzYmQ6ICdTa2VpbjEwMjQtNzQ0JyxcbiAgMHhiM2JlOiAnU2tlaW4xMDI0LTc1MicsXG4gIDB4YjNiZjogJ1NrZWluMTAyNC03NjAnLFxuICAweGIzYzA6ICdTa2VpbjEwMjQtNzY4JyxcbiAgMHhiM2MxOiAnU2tlaW4xMDI0LTc3NicsXG4gIDB4YjNjMjogJ1NrZWluMTAyNC03ODQnLFxuICAweGIzYzM6ICdTa2VpbjEwMjQtNzkyJyxcbiAgMHhiM2M0OiAnU2tlaW4xMDI0LTgwMCcsXG4gIDB4YjNjNTogJ1NrZWluMTAyNC04MDgnLFxuICAweGIzYzY6ICdTa2VpbjEwMjQtODE2JyxcbiAgMHhiM2M3OiAnU2tlaW4xMDI0LTgyNCcsXG4gIDB4YjNjODogJ1NrZWluMTAyNC04MzInLFxuICAweGIzYzk6ICdTa2VpbjEwMjQtODQwJyxcbiAgMHhiM2NhOiAnU2tlaW4xMDI0LTg0OCcsXG4gIDB4YjNjYjogJ1NrZWluMTAyNC04NTYnLFxuICAweGIzY2M6ICdTa2VpbjEwMjQtODY0JyxcbiAgMHhiM2NkOiAnU2tlaW4xMDI0LTg3MicsXG4gIDB4YjNjZTogJ1NrZWluMTAyNC04ODAnLFxuICAweGIzY2Y6ICdTa2VpbjEwMjQtODg4JyxcbiAgMHhiM2QwOiAnU2tlaW4xMDI0LTg5NicsXG4gIDB4YjNkMTogJ1NrZWluMTAyNC05MDQnLFxuICAweGIzZDI6ICdTa2VpbjEwMjQtOTEyJyxcbiAgMHhiM2QzOiAnU2tlaW4xMDI0LTkyMCcsXG4gIDB4YjNkNDogJ1NrZWluMTAyNC05MjgnLFxuICAweGIzZDU6ICdTa2VpbjEwMjQtOTM2JyxcbiAgMHhiM2Q2OiAnU2tlaW4xMDI0LTk0NCcsXG4gIDB4YjNkNzogJ1NrZWluMTAyNC05NTInLFxuICAweGIzZDg6ICdTa2VpbjEwMjQtOTYwJyxcbiAgMHhiM2Q5OiAnU2tlaW4xMDI0LTk2OCcsXG4gIDB4YjNkYTogJ1NrZWluMTAyNC05NzYnLFxuICAweGIzZGI6ICdTa2VpbjEwMjQtOTg0JyxcbiAgMHhiM2RjOiAnU2tlaW4xMDI0LTk5MicsXG4gIDB4YjNkZDogJ1NrZWluMTAyNC0xMDAwJyxcbiAgMHhiM2RlOiAnU2tlaW4xMDI0LTEwMDgnLFxuICAweGIzZGY6ICdTa2VpbjEwMjQtMTAxNicsXG4gIDB4YjNlMDogJ1NrZWluMTAyNC0xMDI0J1xufSlcblxuZXhwb3J0cy5kZWZhdWx0TGVuZ3RocyA9IE9iamVjdC5mcmVlemUoe1xuICAweDExOiAyMCxcbiAgMHgxMjogMzIsXG4gIDB4MTM6IDY0LFxuICAweDU2OiAzMixcbiAgMHgxNzogMjgsXG4gIDB4MTY6IDMyLFxuICAweDE1OiA0OCxcbiAgMHgxNDogNjQsXG4gIDB4MTg6IDMyLFxuICAweDE5OiA2NCxcbiAgMHgxQTogMjgsXG4gIDB4MUI6IDMyLFxuICAweDFDOiA0OCxcbiAgMHgxRDogNjQsXG4gIDB4MjI6IDMyLFxuXG4gIDB4YjIwMTogMHgwMSxcbiAgMHhiMjAyOiAweDAyLFxuICAweGIyMDM6IDB4MDMsXG4gIDB4YjIwNDogMHgwNCxcbiAgMHhiMjA1OiAweDA1LFxuICAweGIyMDY6IDB4MDYsXG4gIDB4YjIwNzogMHgwNyxcbiAgMHhiMjA4OiAweDA4LFxuICAweGIyMDk6IDB4MDksXG4gIDB4YjIwYTogMHgwYSxcbiAgMHhiMjBiOiAweDBiLFxuICAweGIyMGM6IDB4MGMsXG4gIDB4YjIwZDogMHgwZCxcbiAgMHhiMjBlOiAweDBlLFxuICAweGIyMGY6IDB4MGYsXG4gIDB4YjIxMDogMHgxMCxcbiAgMHhiMjExOiAweDExLFxuICAweGIyMTI6IDB4MTIsXG4gIDB4YjIxMzogMHgxMyxcbiAgMHhiMjE0OiAweDE0LFxuICAweGIyMTU6IDB4MTUsXG4gIDB4YjIxNjogMHgxNixcbiAgMHhiMjE3OiAweDE3LFxuICAweGIyMTg6IDB4MTgsXG4gIDB4YjIxOTogMHgxOSxcbiAgMHhiMjFhOiAweDFhLFxuICAweGIyMWI6IDB4MWIsXG4gIDB4YjIxYzogMHgxYyxcbiAgMHhiMjFkOiAweDFkLFxuICAweGIyMWU6IDB4MWUsXG4gIDB4YjIxZjogMHgxZixcbiAgMHhiMjIwOiAweDIwLFxuICAweGIyMjE6IDB4MjEsXG4gIDB4YjIyMjogMHgyMixcbiAgMHhiMjIzOiAweDIzLFxuICAweGIyMjQ6IDB4MjQsXG4gIDB4YjIyNTogMHgyNSxcbiAgMHhiMjI2OiAweDI2LFxuICAweGIyMjc6IDB4MjcsXG4gIDB4YjIyODogMHgyOCxcbiAgMHhiMjI5OiAweDI5LFxuICAweGIyMmE6IDB4MmEsXG4gIDB4YjIyYjogMHgyYixcbiAgMHhiMjJjOiAweDJjLFxuICAweGIyMmQ6IDB4MmQsXG4gIDB4YjIyZTogMHgyZSxcbiAgMHhiMjJmOiAweDJmLFxuICAweGIyMzA6IDB4MzAsXG4gIDB4YjIzMTogMHgzMSxcbiAgMHhiMjMyOiAweDMyLFxuICAweGIyMzM6IDB4MzMsXG4gIDB4YjIzNDogMHgzNCxcbiAgMHhiMjM1OiAweDM1LFxuICAweGIyMzY6IDB4MzYsXG4gIDB4YjIzNzogMHgzNyxcbiAgMHhiMjM4OiAweDM4LFxuICAweGIyMzk6IDB4MzksXG4gIDB4YjIzYTogMHgzYSxcbiAgMHhiMjNiOiAweDNiLFxuICAweGIyM2M6IDB4M2MsXG4gIDB4YjIzZDogMHgzZCxcbiAgMHhiMjNlOiAweDNlLFxuICAweGIyM2Y6IDB4M2YsXG4gIDB4YjI0MDogMHg0MCxcbiAgMHhiMjQxOiAweDAxLFxuICAweGIyNDI6IDB4MDIsXG4gIDB4YjI0MzogMHgwMyxcbiAgMHhiMjQ0OiAweDA0LFxuICAweGIyNDU6IDB4MDUsXG4gIDB4YjI0NjogMHgwNixcbiAgMHhiMjQ3OiAweDA3LFxuICAweGIyNDg6IDB4MDgsXG4gIDB4YjI0OTogMHgwOSxcbiAgMHhiMjRhOiAweDBhLFxuICAweGIyNGI6IDB4MGIsXG4gIDB4YjI0YzogMHgwYyxcbiAgMHhiMjRkOiAweDBkLFxuICAweGIyNGU6IDB4MGUsXG4gIDB4YjI0ZjogMHgwZixcbiAgMHhiMjUwOiAweDEwLFxuICAweGIyNTE6IDB4MTEsXG4gIDB4YjI1MjogMHgxMixcbiAgMHhiMjUzOiAweDEzLFxuICAweGIyNTQ6IDB4MTQsXG4gIDB4YjI1NTogMHgxNSxcbiAgMHhiMjU2OiAweDE2LFxuICAweGIyNTc6IDB4MTcsXG4gIDB4YjI1ODogMHgxOCxcbiAgMHhiMjU5OiAweDE5LFxuICAweGIyNWE6IDB4MWEsXG4gIDB4YjI1YjogMHgxYixcbiAgMHhiMjVjOiAweDFjLFxuICAweGIyNWQ6IDB4MWQsXG4gIDB4YjI1ZTogMHgxZSxcbiAgMHhiMjVmOiAweDFmLFxuICAweGIyNjA6IDB4MjAsXG4gIDB4YjMwMTogMHgwMSxcbiAgMHhiMzAyOiAweDAyLFxuICAweGIzMDM6IDB4MDMsXG4gIDB4YjMwNDogMHgwNCxcbiAgMHhiMzA1OiAweDA1LFxuICAweGIzMDY6IDB4MDYsXG4gIDB4YjMwNzogMHgwNyxcbiAgMHhiMzA4OiAweDA4LFxuICAweGIzMDk6IDB4MDksXG4gIDB4YjMwYTogMHgwYSxcbiAgMHhiMzBiOiAweDBiLFxuICAweGIzMGM6IDB4MGMsXG4gIDB4YjMwZDogMHgwZCxcbiAgMHhiMzBlOiAweDBlLFxuICAweGIzMGY6IDB4MGYsXG4gIDB4YjMxMDogMHgxMCxcbiAgMHhiMzExOiAweDExLFxuICAweGIzMTI6IDB4MTIsXG4gIDB4YjMxMzogMHgxMyxcbiAgMHhiMzE0OiAweDE0LFxuICAweGIzMTU6IDB4MTUsXG4gIDB4YjMxNjogMHgxNixcbiAgMHhiMzE3OiAweDE3LFxuICAweGIzMTg6IDB4MTgsXG4gIDB4YjMxOTogMHgxOSxcbiAgMHhiMzFhOiAweDFhLFxuICAweGIzMWI6IDB4MWIsXG4gIDB4YjMxYzogMHgxYyxcbiAgMHhiMzFkOiAweDFkLFxuICAweGIzMWU6IDB4MWUsXG4gIDB4YjMxZjogMHgxZixcbiAgMHhiMzIwOiAweDIwLFxuICAweGIzMjE6IDB4MDEsXG4gIDB4YjMyMjogMHgwMixcbiAgMHhiMzIzOiAweDAzLFxuICAweGIzMjQ6IDB4MDQsXG4gIDB4YjMyNTogMHgwNSxcbiAgMHhiMzI2OiAweDA2LFxuICAweGIzMjc6IDB4MDcsXG4gIDB4YjMyODogMHgwOCxcbiAgMHhiMzI5OiAweDA5LFxuICAweGIzMmE6IDB4MGEsXG4gIDB4YjMyYjogMHgwYixcbiAgMHhiMzJjOiAweDBjLFxuICAweGIzMmQ6IDB4MGQsXG4gIDB4YjMyZTogMHgwZSxcbiAgMHhiMzJmOiAweDBmLFxuICAweGIzMzA6IDB4MTAsXG4gIDB4YjMzMTogMHgxMSxcbiAgMHhiMzMyOiAweDEyLFxuICAweGIzMzM6IDB4MTMsXG4gIDB4YjMzNDogMHgxNCxcbiAgMHhiMzM1OiAweDE1LFxuICAweGIzMzY6IDB4MTYsXG4gIDB4YjMzNzogMHgxNyxcbiAgMHhiMzM4OiAweDE4LFxuICAweGIzMzk6IDB4MTksXG4gIDB4YjMzYTogMHgxYSxcbiAgMHhiMzNiOiAweDFiLFxuICAweGIzM2M6IDB4MWMsXG4gIDB4YjMzZDogMHgxZCxcbiAgMHhiMzNlOiAweDFlLFxuICAweGIzM2Y6IDB4MWYsXG4gIDB4YjM0MDogMHgyMCxcbiAgMHhiMzQxOiAweDIxLFxuICAweGIzNDI6IDB4MjIsXG4gIDB4YjM0MzogMHgyMyxcbiAgMHhiMzQ0OiAweDI0LFxuICAweGIzNDU6IDB4MjUsXG4gIDB4YjM0NjogMHgyNixcbiAgMHhiMzQ3OiAweDI3LFxuICAweGIzNDg6IDB4MjgsXG4gIDB4YjM0OTogMHgyOSxcbiAgMHhiMzRhOiAweDJhLFxuICAweGIzNGI6IDB4MmIsXG4gIDB4YjM0YzogMHgyYyxcbiAgMHhiMzRkOiAweDJkLFxuICAweGIzNGU6IDB4MmUsXG4gIDB4YjM0ZjogMHgyZixcbiAgMHhiMzUwOiAweDMwLFxuICAweGIzNTE6IDB4MzEsXG4gIDB4YjM1MjogMHgzMixcbiAgMHhiMzUzOiAweDMzLFxuICAweGIzNTQ6IDB4MzQsXG4gIDB4YjM1NTogMHgzNSxcbiAgMHhiMzU2OiAweDM2LFxuICAweGIzNTc6IDB4MzcsXG4gIDB4YjM1ODogMHgzOCxcbiAgMHhiMzU5OiAweDM5LFxuICAweGIzNWE6IDB4M2EsXG4gIDB4YjM1YjogMHgzYixcbiAgMHhiMzVjOiAweDNjLFxuICAweGIzNWQ6IDB4M2QsXG4gIDB4YjM1ZTogMHgzZSxcbiAgMHhiMzVmOiAweDNmLFxuICAweGIzNjA6IDB4NDAsXG4gIDB4YjM2MTogMHgwMSxcbiAgMHhiMzYyOiAweDAyLFxuICAweGIzNjM6IDB4MDMsXG4gIDB4YjM2NDogMHgwNCxcbiAgMHhiMzY1OiAweDA1LFxuICAweGIzNjY6IDB4MDYsXG4gIDB4YjM2NzogMHgwNyxcbiAgMHhiMzY4OiAweDA4LFxuICAweGIzNjk6IDB4MDksXG4gIDB4YjM2YTogMHgwYSxcbiAgMHhiMzZiOiAweDBiLFxuICAweGIzNmM6IDB4MGMsXG4gIDB4YjM2ZDogMHgwZCxcbiAgMHhiMzZlOiAweDBlLFxuICAweGIzNmY6IDB4MGYsXG4gIDB4YjM3MDogMHgxMCxcbiAgMHhiMzcxOiAweDExLFxuICAweGIzNzI6IDB4MTIsXG4gIDB4YjM3MzogMHgxMyxcbiAgMHhiMzc0OiAweDE0LFxuICAweGIzNzU6IDB4MTUsXG4gIDB4YjM3NjogMHgxNixcbiAgMHhiMzc3OiAweDE3LFxuICAweGIzNzg6IDB4MTgsXG4gIDB4YjM3OTogMHgxOSxcbiAgMHhiMzdhOiAweDFhLFxuICAweGIzN2I6IDB4MWIsXG4gIDB4YjM3YzogMHgxYyxcbiAgMHhiMzdkOiAweDFkLFxuICAweGIzN2U6IDB4MWUsXG4gIDB4YjM3ZjogMHgxZixcbiAgMHhiMzgwOiAweDIwLFxuICAweGIzODE6IDB4MjEsXG4gIDB4YjM4MjogMHgyMixcbiAgMHhiMzgzOiAweDIzLFxuICAweGIzODQ6IDB4MjQsXG4gIDB4YjM4NTogMHgyNSxcbiAgMHhiMzg2OiAweDI2LFxuICAweGIzODc6IDB4MjcsXG4gIDB4YjM4ODogMHgyOCxcbiAgMHhiMzg5OiAweDI5LFxuICAweGIzOGE6IDB4MmEsXG4gIDB4YjM4YjogMHgyYixcbiAgMHhiMzhjOiAweDJjLFxuICAweGIzOGQ6IDB4MmQsXG4gIDB4YjM4ZTogMHgyZSxcbiAgMHhiMzhmOiAweDJmLFxuICAweGIzOTA6IDB4MzAsXG4gIDB4YjM5MTogMHgzMSxcbiAgMHhiMzkyOiAweDMyLFxuICAweGIzOTM6IDB4MzMsXG4gIDB4YjM5NDogMHgzNCxcbiAgMHhiMzk1OiAweDM1LFxuICAweGIzOTY6IDB4MzYsXG4gIDB4YjM5NzogMHgzNyxcbiAgMHhiMzk4OiAweDM4LFxuICAweGIzOTk6IDB4MzksXG4gIDB4YjM5YTogMHgzYSxcbiAgMHhiMzliOiAweDNiLFxuICAweGIzOWM6IDB4M2MsXG4gIDB4YjM5ZDogMHgzZCxcbiAgMHhiMzllOiAweDNlLFxuICAweGIzOWY6IDB4M2YsXG4gIDB4YjNhMDogMHg0MCxcbiAgMHhiM2ExOiAweDQxLFxuICAweGIzYTI6IDB4NDIsXG4gIDB4YjNhMzogMHg0MyxcbiAgMHhiM2E0OiAweDQ0LFxuICAweGIzYTU6IDB4NDUsXG4gIDB4YjNhNjogMHg0NixcbiAgMHhiM2E3OiAweDQ3LFxuICAweGIzYTg6IDB4NDgsXG4gIDB4YjNhOTogMHg0OSxcbiAgMHhiM2FhOiAweDRhLFxuICAweGIzYWI6IDB4NGIsXG4gIDB4YjNhYzogMHg0YyxcbiAgMHhiM2FkOiAweDRkLFxuICAweGIzYWU6IDB4NGUsXG4gIDB4YjNhZjogMHg0ZixcbiAgMHhiM2IwOiAweDUwLFxuICAweGIzYjE6IDB4NTEsXG4gIDB4YjNiMjogMHg1MixcbiAgMHhiM2IzOiAweDUzLFxuICAweGIzYjQ6IDB4NTQsXG4gIDB4YjNiNTogMHg1NSxcbiAgMHhiM2I2OiAweDU2LFxuICAweGIzYjc6IDB4NTcsXG4gIDB4YjNiODogMHg1OCxcbiAgMHhiM2I5OiAweDU5LFxuICAweGIzYmE6IDB4NWEsXG4gIDB4YjNiYjogMHg1YixcbiAgMHhiM2JjOiAweDVjLFxuICAweGIzYmQ6IDB4NWQsXG4gIDB4YjNiZTogMHg1ZSxcbiAgMHhiM2JmOiAweDVmLFxuICAweGIzYzA6IDB4NjAsXG4gIDB4YjNjMTogMHg2MSxcbiAgMHhiM2MyOiAweDYyLFxuICAweGIzYzM6IDB4NjMsXG4gIDB4YjNjNDogMHg2NCxcbiAgMHhiM2M1OiAweDY1LFxuICAweGIzYzY6IDB4NjYsXG4gIDB4YjNjNzogMHg2NyxcbiAgMHhiM2M4OiAweDY4LFxuICAweGIzYzk6IDB4NjksXG4gIDB4YjNjYTogMHg2YSxcbiAgMHhiM2NiOiAweDZiLFxuICAweGIzY2M6IDB4NmMsXG4gIDB4YjNjZDogMHg2ZCxcbiAgMHhiM2NlOiAweDZlLFxuICAweGIzY2Y6IDB4NmYsXG4gIDB4YjNkMDogMHg3MCxcbiAgMHhiM2QxOiAweDcxLFxuICAweGIzZDI6IDB4NzIsXG4gIDB4YjNkMzogMHg3MyxcbiAgMHhiM2Q0OiAweDc0LFxuICAweGIzZDU6IDB4NzUsXG4gIDB4YjNkNjogMHg3NixcbiAgMHhiM2Q3OiAweDc3LFxuICAweGIzZDg6IDB4NzgsXG4gIDB4YjNkOTogMHg3OSxcbiAgMHhiM2RhOiAweDdhLFxuICAweGIzZGI6IDB4N2IsXG4gIDB4YjNkYzogMHg3YyxcbiAgMHhiM2RkOiAweDdkLFxuICAweGIzZGU6IDB4N2UsXG4gIDB4YjNkZjogMHg3ZixcbiAgMHhiM2UwOiAweDgwXG59KVxuIiwiLyoqXG4gKiBNdWx0aWhhc2ggaW1wbGVtZW50YXRpb24gaW4gSmF2YVNjcmlwdC5cbiAqXG4gKiBAbW9kdWxlIG11bHRpaGFzaFxuICovXG4ndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCBtdWx0aWJhc2UgPSByZXF1aXJlKCdtdWx0aWJhc2UnKVxuY29uc3QgdmFyaW50ID0gcmVxdWlyZSgndmFyaW50JylcbmNvbnN0IGNzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuXG5leHBvcnRzLm5hbWVzID0gY3MubmFtZXNcbmV4cG9ydHMuY29kZXMgPSBjcy5jb2Rlc1xuZXhwb3J0cy5kZWZhdWx0TGVuZ3RocyA9IGNzLmRlZmF1bHRMZW5ndGhzXG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gbXVsdGloYXNoIHRvIGEgaGV4IGVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBoYXNoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnRzLnRvSGV4U3RyaW5nID0gZnVuY3Rpb24gdG9IZXhTdHJpbmcgKGhhc2gpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoaGFzaCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgYmUgcGFzc2VkIGEgYnVmZmVyJylcbiAgfVxuXG4gIHJldHVybiBoYXNoLnRvU3RyaW5nKCdoZXgnKVxufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGhleCBlbmNvZGVkIHN0cmluZyB0byBhIG11bHRpaGFzaC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaFxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5mcm9tSGV4U3RyaW5nID0gZnVuY3Rpb24gZnJvbUhleFN0cmluZyAoaGFzaCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oaGFzaCwgJ2hleCcpXG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gbXVsdGloYXNoIHRvIGEgYmFzZTU4IGVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBoYXNoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnRzLnRvQjU4U3RyaW5nID0gZnVuY3Rpb24gdG9CNThTdHJpbmcgKGhhc2gpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoaGFzaCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgYmUgcGFzc2VkIGEgYnVmZmVyJylcbiAgfVxuXG4gIHJldHVybiBtdWx0aWJhc2UuZW5jb2RlKCdiYXNlNThidGMnLCBoYXNoKS50b1N0cmluZygpLnNsaWNlKDEpXG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gYmFzZTU4IGVuY29kZWQgc3RyaW5nIHRvIGEgbXVsdGloYXNoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gaGFzaFxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5mcm9tQjU4U3RyaW5nID0gZnVuY3Rpb24gZnJvbUI1OFN0cmluZyAoaGFzaCkge1xuICBsZXQgZW5jb2RlZCA9IGhhc2hcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihoYXNoKSkge1xuICAgIGVuY29kZWQgPSBoYXNoLnRvU3RyaW5nKClcbiAgfVxuXG4gIHJldHVybiBtdWx0aWJhc2UuZGVjb2RlKCd6JyArIGVuY29kZWQpXG59XG5cbi8qKlxuICogRGVjb2RlIGEgaGFzaCBmcm9tIHRoZSBnaXZlbiBtdWx0aWhhc2guXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICogQHJldHVybnMge3tjb2RlOiBudW1iZXIsIG5hbWU6IHN0cmluZywgbGVuZ3RoOiBudW1iZXIsIGRpZ2VzdDogQnVmZmVyfX0gcmVzdWx0XG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlIChidWYpIHtcbiAgaWYgKCEoQnVmZmVyLmlzQnVmZmVyKGJ1ZikpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWhhc2ggbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoYnVmLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpaGFzaCB0b28gc2hvcnQuIG11c3QgYmUgPiAyIGJ5dGVzLicpXG4gIH1cblxuICBjb25zdCBjb2RlID0gdmFyaW50LmRlY29kZShidWYpXG4gIGlmICghZXhwb3J0cy5pc1ZhbGlkQ29kZShjb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgbXVsdGloYXNoIHVua25vd24gZnVuY3Rpb24gY29kZTogMHgke2NvZGUudG9TdHJpbmcoMTYpfWApXG4gIH1cbiAgYnVmID0gYnVmLnNsaWNlKHZhcmludC5kZWNvZGUuYnl0ZXMpXG5cbiAgY29uc3QgbGVuID0gdmFyaW50LmRlY29kZShidWYpXG4gIGlmIChsZW4gPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBtdWx0aWhhc2ggaW52YWxpZCBsZW5ndGg6ICR7bGVufWApXG4gIH1cbiAgYnVmID0gYnVmLnNsaWNlKHZhcmludC5kZWNvZGUuYnl0ZXMpXG5cbiAgaWYgKGJ1Zi5sZW5ndGggIT09IGxlbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgbXVsdGloYXNoIGxlbmd0aCBpbmNvbnNpc3RlbnQ6IDB4JHtidWYudG9TdHJpbmcoJ2hleCcpfWApXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvZGU6IGNvZGUsXG4gICAgbmFtZTogY3MuY29kZXNbY29kZV0sXG4gICAgbGVuZ3RoOiBsZW4sXG4gICAgZGlnZXN0OiBidWZcbiAgfVxufVxuXG4vKipcbiAqICBFbmNvZGUgYSBoYXNoIGRpZ2VzdCBhbG9uZyB3aXRoIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gY29kZS5cbiAqXG4gKiA+ICoqTm90ZToqKiB0aGUgbGVuZ3RoIGlzIGRlcml2ZWQgZnJvbSB0aGUgbGVuZ3RoIG9mIHRoZSBkaWdlc3QgaXRzZWxmLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBkaWdlc3RcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gY29kZVxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZSAoZGlnZXN0LCBjb2RlLCBsZW5ndGgpIHtcbiAgaWYgKCFkaWdlc3QgfHwgY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWhhc2ggZW5jb2RlIHJlcXVpcmVzIGF0IGxlYXN0IHR3byBhcmdzOiBkaWdlc3QsIGNvZGUnKVxuICB9XG5cbiAgLy8gZW5zdXJlIGl0J3MgYSBoYXNoZnVuY3Rpb24gY29kZS5cbiAgY29uc3QgaGFzaGZuID0gZXhwb3J0cy5jb2VyY2VDb2RlKGNvZGUpXG5cbiAgaWYgKCEoQnVmZmVyLmlzQnVmZmVyKGRpZ2VzdCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3Qgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgIGxlbmd0aCA9IGRpZ2VzdC5sZW5ndGhcbiAgfVxuXG4gIGlmIChsZW5ndGggJiYgZGlnZXN0Lmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QgbGVuZ3RoIHNob3VsZCBiZSBlcXVhbCB0byBzcGVjaWZpZWQgbGVuZ3RoLicpXG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbXG4gICAgQnVmZmVyLmZyb20odmFyaW50LmVuY29kZShoYXNoZm4pKSxcbiAgICBCdWZmZXIuZnJvbSh2YXJpbnQuZW5jb2RlKGxlbmd0aCkpLFxuICAgIGRpZ2VzdFxuICBdKVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgaGFzaCBmdW5jdGlvbiBuYW1lIGludG8gdGhlIG1hdGNoaW5nIGNvZGUuXG4gKiBJZiBwYXNzZWQgYSBudW1iZXIgaXQgd2lsbCByZXR1cm4gdGhlIG51bWJlciBpZiBpdCdzIGEgdmFsaWQgY29kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbmFtZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0cy5jb2VyY2VDb2RlID0gZnVuY3Rpb24gY29lcmNlQ29kZSAobmFtZSkge1xuICBsZXQgY29kZSA9IG5hbWVcblxuICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGNzLm5hbWVzW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGhhc2ggZnVuY3Rpb24gbmFtZWQ6ICR7bmFtZX1gKVxuICAgIH1cbiAgICBjb2RlID0gY3MubmFtZXNbbmFtZV1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY29kZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEhhc2ggZnVuY3Rpb24gY29kZSBzaG91bGQgYmUgYSBudW1iZXIuIEdvdDogJHtjb2RlfWApXG4gIH1cblxuICBpZiAoY3MuY29kZXNbY29kZV0gPT09IHVuZGVmaW5lZCAmJiAhZXhwb3J0cy5pc0FwcENvZGUoY29kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBmdW5jdGlvbiBjb2RlOiAke2NvZGV9YClcbiAgfVxuXG4gIHJldHVybiBjb2RlXG59XG5cbi8qKlxuICogQ2hlY2tzIHdldGhlciBhIGNvZGUgaXMgcGFydCBvZiB0aGUgYXBwIHJhbmdlXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzQXBwQ29kZSA9IGZ1bmN0aW9uIGFwcENvZGUgKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPiAwICYmIGNvZGUgPCAweDEwXG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBtdWx0aWhhc2ggY29kZSBpcyB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZENvZGUgPSBmdW5jdGlvbiB2YWxpZENvZGUgKGNvZGUpIHtcbiAgaWYgKGV4cG9ydHMuaXNBcHBDb2RlKGNvZGUpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChjcy5jb2Rlc1tjb2RlXSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gYnVmZmVyIGlzIGEgdmFsaWQgbXVsdGloYXNoLiBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgaXMgbm90IHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBtdWx0aWhhc2hcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGUgKG11bHRpaGFzaCkge1xuICBleHBvcnRzLmRlY29kZShtdWx0aWhhc2gpIC8vIHRocm93cyBpZiBiYWQuXG59XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGVcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJlZml4IGZyb20gYSB2YWxpZCBtdWx0aWhhc2guIFRocm93cyBhbiBlcnJvciBpZiBpdCBpcyBub3QgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IG11bHRpaGFzaFxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEB0aHJvd3Mge0Vycm9yfVxuICovXG5leHBvcnRzLnByZWZpeCA9IGZ1bmN0aW9uIHByZWZpeCAobXVsdGloYXNoKSB7XG4gIHZhbGlkYXRlKG11bHRpaGFzaClcblxuICByZXR1cm4gbXVsdGloYXNoLnNsaWNlKDAsIDIpXG59XG4iLCIvLyBUaGlzIGFscGhhYmV0IHVzZXMgYS16IEEtWiAwLTkgXy0gc3ltYm9scy5cbi8vIFN5bWJvbHMgYXJlIGdlbmVyYXRlZCBmb3Igc21hbGxlciBzaXplLlxuLy8gLV96eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYTk4NzY1NDMyMTBaWVhXVlVUU1JRUE9OTUxLSklIR0ZFRENCQVxudmFyIHVybCA9ICctXydcbi8vIExvb3AgZnJvbSAzNiB0byAwIChmcm9tIHogdG8gYSBhbmQgOSB0byAwIGluIEJhc2UzNikuXG52YXIgaSA9IDM2XG53aGlsZSAoaS0tKSB7XG4gIC8vIDM2IGlzIHJhZGl4LiBOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nKDM2KSByZXR1cm5zIG51bWJlclxuICAvLyBpbiBCYXNlMzYgcmVwcmVzZW50YXRpb24uIEJhc2UzNiBpcyBsaWtlIGhleCwgYnV0IGl0IHVzZXMgMOKAkzkgYW5kIGEtei5cbiAgdXJsICs9IGkudG9TdHJpbmcoMzYpXG59XG4vLyBMb29wIGZyb20gMzYgdG8gMTAgKGZyb20gWiB0byBBIGluIEJhc2UzNikuXG5pID0gMzZcbndoaWxlIChpLS0gLSAxMCkge1xuICB1cmwgKz0gaS50b1N0cmluZygzNikudG9VcHBlckNhc2UoKVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIFVSTC1mcmllbmRseSB1bmlxdWUgSUQuIFRoaXMgbWV0aG9kIHVzZSBub24tc2VjdXJlIHByZWRpY3RhYmxlXG4gKiByYW5kb20gZ2VuZXJhdG9yIHdpdGggYmlnZ2VyIGNvbGxpc2lvbiBwcm9iYWJpbGl0eS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemU9MjFdIFRoZSBudW1iZXIgb2Ygc3ltYm9scyBpbiBJRC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJhbmRvbSBzdHJpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG5hbm9pZCA9IHJlcXVpcmUoJ25hbm9pZC9ub24tc2VjdXJlJylcbiAqIG1vZGVsLmlkID0gbmFub2lkKCkgLy89PiBcIlVha2diX0o1bTlnLTBKRE1iY0pxTFwiXG4gKlxuICogQG5hbWUgbm9uU2VjdXJlXG4gKiBAZnVuY3Rpb25cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICB2YXIgaWQgPSAnJ1xuICBpID0gc2l6ZSB8fCAyMVxuICAvLyBDb21wYWN0IGFsdGVybmF0aXZlIGZvciBgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspYFxuICB3aGlsZSAoaS0tKSB7XG4gICAgLy8gYHwgMGAgaXMgY29tcGFjdCBhbmQgZmFzdGVyIGFsdGVybmF0aXZlIGZvciBgTWF0aC5mbG9vcigpYFxuICAgIGlkICs9IHVybFtNYXRoLnJhbmRvbSgpICogNjQgfCAwXVxuICB9XG4gIHJldHVybiBpZFxufVxuIiwidmFyIGxvd2VyQ2FzZSA9IHJlcXVpcmUoJ2xvd2VyLWNhc2UnKVxuXG52YXIgTk9OX1dPUkRfUkVHRVhQID0gcmVxdWlyZSgnLi92ZW5kb3Ivbm9uLXdvcmQtcmVnZXhwJylcbnZhciBDQU1FTF9DQVNFX1JFR0VYUCA9IHJlcXVpcmUoJy4vdmVuZG9yL2NhbWVsLWNhc2UtcmVnZXhwJylcbnZhciBDQU1FTF9DQVNFX1VQUEVSX1JFR0VYUCA9IHJlcXVpcmUoJy4vdmVuZG9yL2NhbWVsLWNhc2UtdXBwZXItcmVnZXhwJylcblxuLyoqXG4gKiBTZW50ZW5jZSBjYXNlIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGxvY2FsZVxuICogQHBhcmFtICB7c3RyaW5nfSByZXBsYWNlbWVudFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIsIGxvY2FsZSwgcmVwbGFjZW1lbnQpIHtcbiAgaWYgKHN0ciA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICByZXBsYWNlbWVudCA9IHR5cGVvZiByZXBsYWNlbWVudCAhPT0gJ3N0cmluZycgPyAnICcgOiByZXBsYWNlbWVudFxuXG4gIGZ1bmN0aW9uIHJlcGxhY2UgKG1hdGNoLCBpbmRleCwgdmFsdWUpIHtcbiAgICBpZiAoaW5kZXggPT09IDAgfHwgaW5kZXggPT09ICh2YWx1ZS5sZW5ndGggLSBtYXRjaC5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG5cbiAgICByZXR1cm4gcmVwbGFjZW1lbnRcbiAgfVxuXG4gIHN0ciA9IFN0cmluZyhzdHIpXG4gICAgLy8gU3VwcG9ydCBjYW1lbCBjYXNlIChcImNhbWVsQ2FzZVwiIC0+IFwiY2FtZWwgQ2FzZVwiKS5cbiAgICAucmVwbGFjZShDQU1FTF9DQVNFX1JFR0VYUCwgJyQxICQyJylcbiAgICAvLyBTdXBwb3J0IG9kZCBjYW1lbCBjYXNlIChcIkNBTUVMQ2FzZVwiIC0+IFwiQ0FNRUwgQ2FzZVwiKS5cbiAgICAucmVwbGFjZShDQU1FTF9DQVNFX1VQUEVSX1JFR0VYUCwgJyQxICQyJylcbiAgICAvLyBSZW1vdmUgYWxsIG5vbi13b3JkIGNoYXJhY3RlcnMgYW5kIHJlcGxhY2Ugd2l0aCBhIHNpbmdsZSBzcGFjZS5cbiAgICAucmVwbGFjZShOT05fV09SRF9SRUdFWFAsIHJlcGxhY2UpXG5cbiAgLy8gTG93ZXIgY2FzZSB0aGUgZW50aXJlIHN0cmluZy5cbiAgcmV0dXJuIGxvd2VyQ2FzZShzdHIsIGxvY2FsZSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gLyhbYS16XFx4QjVcXHhERi1cXHhGNlxceEY4LVxceEZGXFx1MDEwMVxcdTAxMDNcXHUwMTA1XFx1MDEwN1xcdTAxMDlcXHUwMTBCXFx1MDEwRFxcdTAxMEZcXHUwMTExXFx1MDExM1xcdTAxMTVcXHUwMTE3XFx1MDExOVxcdTAxMUJcXHUwMTFEXFx1MDExRlxcdTAxMjFcXHUwMTIzXFx1MDEyNVxcdTAxMjdcXHUwMTI5XFx1MDEyQlxcdTAxMkRcXHUwMTJGXFx1MDEzMVxcdTAxMzNcXHUwMTM1XFx1MDEzN1xcdTAxMzhcXHUwMTNBXFx1MDEzQ1xcdTAxM0VcXHUwMTQwXFx1MDE0MlxcdTAxNDRcXHUwMTQ2XFx1MDE0OFxcdTAxNDlcXHUwMTRCXFx1MDE0RFxcdTAxNEZcXHUwMTUxXFx1MDE1M1xcdTAxNTVcXHUwMTU3XFx1MDE1OVxcdTAxNUJcXHUwMTVEXFx1MDE1RlxcdTAxNjFcXHUwMTYzXFx1MDE2NVxcdTAxNjdcXHUwMTY5XFx1MDE2QlxcdTAxNkRcXHUwMTZGXFx1MDE3MVxcdTAxNzNcXHUwMTc1XFx1MDE3N1xcdTAxN0FcXHUwMTdDXFx1MDE3RS1cXHUwMTgwXFx1MDE4M1xcdTAxODVcXHUwMTg4XFx1MDE4Q1xcdTAxOERcXHUwMTkyXFx1MDE5NVxcdTAxOTktXFx1MDE5QlxcdTAxOUVcXHUwMUExXFx1MDFBM1xcdTAxQTVcXHUwMUE4XFx1MDFBQVxcdTAxQUJcXHUwMUFEXFx1MDFCMFxcdTAxQjRcXHUwMUI2XFx1MDFCOVxcdTAxQkFcXHUwMUJELVxcdTAxQkZcXHUwMUM2XFx1MDFDOVxcdTAxQ0NcXHUwMUNFXFx1MDFEMFxcdTAxRDJcXHUwMUQ0XFx1MDFENlxcdTAxRDhcXHUwMURBXFx1MDFEQ1xcdTAxRERcXHUwMURGXFx1MDFFMVxcdTAxRTNcXHUwMUU1XFx1MDFFN1xcdTAxRTlcXHUwMUVCXFx1MDFFRFxcdTAxRUZcXHUwMUYwXFx1MDFGM1xcdTAxRjVcXHUwMUY5XFx1MDFGQlxcdTAxRkRcXHUwMUZGXFx1MDIwMVxcdTAyMDNcXHUwMjA1XFx1MDIwN1xcdTAyMDlcXHUwMjBCXFx1MDIwRFxcdTAyMEZcXHUwMjExXFx1MDIxM1xcdTAyMTVcXHUwMjE3XFx1MDIxOVxcdTAyMUJcXHUwMjFEXFx1MDIxRlxcdTAyMjFcXHUwMjIzXFx1MDIyNVxcdTAyMjdcXHUwMjI5XFx1MDIyQlxcdTAyMkRcXHUwMjJGXFx1MDIzMVxcdTAyMzMtXFx1MDIzOVxcdTAyM0NcXHUwMjNGXFx1MDI0MFxcdTAyNDJcXHUwMjQ3XFx1MDI0OVxcdTAyNEJcXHUwMjREXFx1MDI0Ri1cXHUwMjkzXFx1MDI5NS1cXHUwMkFGXFx1MDM3MVxcdTAzNzNcXHUwMzc3XFx1MDM3Qi1cXHUwMzdEXFx1MDM5MFxcdTAzQUMtXFx1MDNDRVxcdTAzRDBcXHUwM0QxXFx1MDNENS1cXHUwM0Q3XFx1MDNEOVxcdTAzREJcXHUwM0REXFx1MDNERlxcdTAzRTFcXHUwM0UzXFx1MDNFNVxcdTAzRTdcXHUwM0U5XFx1MDNFQlxcdTAzRURcXHUwM0VGLVxcdTAzRjNcXHUwM0Y1XFx1MDNGOFxcdTAzRkJcXHUwM0ZDXFx1MDQzMC1cXHUwNDVGXFx1MDQ2MVxcdTA0NjNcXHUwNDY1XFx1MDQ2N1xcdTA0NjlcXHUwNDZCXFx1MDQ2RFxcdTA0NkZcXHUwNDcxXFx1MDQ3M1xcdTA0NzVcXHUwNDc3XFx1MDQ3OVxcdTA0N0JcXHUwNDdEXFx1MDQ3RlxcdTA0ODFcXHUwNDhCXFx1MDQ4RFxcdTA0OEZcXHUwNDkxXFx1MDQ5M1xcdTA0OTVcXHUwNDk3XFx1MDQ5OVxcdTA0OUJcXHUwNDlEXFx1MDQ5RlxcdTA0QTFcXHUwNEEzXFx1MDRBNVxcdTA0QTdcXHUwNEE5XFx1MDRBQlxcdTA0QURcXHUwNEFGXFx1MDRCMVxcdTA0QjNcXHUwNEI1XFx1MDRCN1xcdTA0QjlcXHUwNEJCXFx1MDRCRFxcdTA0QkZcXHUwNEMyXFx1MDRDNFxcdTA0QzZcXHUwNEM4XFx1MDRDQVxcdTA0Q0NcXHUwNENFXFx1MDRDRlxcdTA0RDFcXHUwNEQzXFx1MDRENVxcdTA0RDdcXHUwNEQ5XFx1MDREQlxcdTA0RERcXHUwNERGXFx1MDRFMVxcdTA0RTNcXHUwNEU1XFx1MDRFN1xcdTA0RTlcXHUwNEVCXFx1MDRFRFxcdTA0RUZcXHUwNEYxXFx1MDRGM1xcdTA0RjVcXHUwNEY3XFx1MDRGOVxcdTA0RkJcXHUwNEZEXFx1MDRGRlxcdTA1MDFcXHUwNTAzXFx1MDUwNVxcdTA1MDdcXHUwNTA5XFx1MDUwQlxcdTA1MERcXHUwNTBGXFx1MDUxMVxcdTA1MTNcXHUwNTE1XFx1MDUxN1xcdTA1MTlcXHUwNTFCXFx1MDUxRFxcdTA1MUZcXHUwNTIxXFx1MDUyM1xcdTA1MjVcXHUwNTI3XFx1MDUyOVxcdTA1MkJcXHUwNTJEXFx1MDUyRlxcdTA1NjEtXFx1MDU4N1xcdTEzRjgtXFx1MTNGRFxcdTFEMDAtXFx1MUQyQlxcdTFENkItXFx1MUQ3N1xcdTFENzktXFx1MUQ5QVxcdTFFMDFcXHUxRTAzXFx1MUUwNVxcdTFFMDdcXHUxRTA5XFx1MUUwQlxcdTFFMERcXHUxRTBGXFx1MUUxMVxcdTFFMTNcXHUxRTE1XFx1MUUxN1xcdTFFMTlcXHUxRTFCXFx1MUUxRFxcdTFFMUZcXHUxRTIxXFx1MUUyM1xcdTFFMjVcXHUxRTI3XFx1MUUyOVxcdTFFMkJcXHUxRTJEXFx1MUUyRlxcdTFFMzFcXHUxRTMzXFx1MUUzNVxcdTFFMzdcXHUxRTM5XFx1MUUzQlxcdTFFM0RcXHUxRTNGXFx1MUU0MVxcdTFFNDNcXHUxRTQ1XFx1MUU0N1xcdTFFNDlcXHUxRTRCXFx1MUU0RFxcdTFFNEZcXHUxRTUxXFx1MUU1M1xcdTFFNTVcXHUxRTU3XFx1MUU1OVxcdTFFNUJcXHUxRTVEXFx1MUU1RlxcdTFFNjFcXHUxRTYzXFx1MUU2NVxcdTFFNjdcXHUxRTY5XFx1MUU2QlxcdTFFNkRcXHUxRTZGXFx1MUU3MVxcdTFFNzNcXHUxRTc1XFx1MUU3N1xcdTFFNzlcXHUxRTdCXFx1MUU3RFxcdTFFN0ZcXHUxRTgxXFx1MUU4M1xcdTFFODVcXHUxRTg3XFx1MUU4OVxcdTFFOEJcXHUxRThEXFx1MUU4RlxcdTFFOTFcXHUxRTkzXFx1MUU5NS1cXHUxRTlEXFx1MUU5RlxcdTFFQTFcXHUxRUEzXFx1MUVBNVxcdTFFQTdcXHUxRUE5XFx1MUVBQlxcdTFFQURcXHUxRUFGXFx1MUVCMVxcdTFFQjNcXHUxRUI1XFx1MUVCN1xcdTFFQjlcXHUxRUJCXFx1MUVCRFxcdTFFQkZcXHUxRUMxXFx1MUVDM1xcdTFFQzVcXHUxRUM3XFx1MUVDOVxcdTFFQ0JcXHUxRUNEXFx1MUVDRlxcdTFFRDFcXHUxRUQzXFx1MUVENVxcdTFFRDdcXHUxRUQ5XFx1MUVEQlxcdTFFRERcXHUxRURGXFx1MUVFMVxcdTFFRTNcXHUxRUU1XFx1MUVFN1xcdTFFRTlcXHUxRUVCXFx1MUVFRFxcdTFFRUZcXHUxRUYxXFx1MUVGM1xcdTFFRjVcXHUxRUY3XFx1MUVGOVxcdTFFRkJcXHUxRUZEXFx1MUVGRi1cXHUxRjA3XFx1MUYxMC1cXHUxRjE1XFx1MUYyMC1cXHUxRjI3XFx1MUYzMC1cXHUxRjM3XFx1MUY0MC1cXHUxRjQ1XFx1MUY1MC1cXHUxRjU3XFx1MUY2MC1cXHUxRjY3XFx1MUY3MC1cXHUxRjdEXFx1MUY4MC1cXHUxRjg3XFx1MUY5MC1cXHUxRjk3XFx1MUZBMC1cXHUxRkE3XFx1MUZCMC1cXHUxRkI0XFx1MUZCNlxcdTFGQjdcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNlxcdTFGQzdcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2XFx1MUZEN1xcdTFGRTAtXFx1MUZFN1xcdTFGRjItXFx1MUZGNFxcdTFGRjZcXHUxRkY3XFx1MjEwQVxcdTIxMEVcXHUyMTBGXFx1MjExM1xcdTIxMkZcXHUyMTM0XFx1MjEzOVxcdTIxM0NcXHUyMTNEXFx1MjE0Ni1cXHUyMTQ5XFx1MjE0RVxcdTIxODRcXHUyQzMwLVxcdTJDNUVcXHUyQzYxXFx1MkM2NVxcdTJDNjZcXHUyQzY4XFx1MkM2QVxcdTJDNkNcXHUyQzcxXFx1MkM3M1xcdTJDNzRcXHUyQzc2LVxcdTJDN0JcXHUyQzgxXFx1MkM4M1xcdTJDODVcXHUyQzg3XFx1MkM4OVxcdTJDOEJcXHUyQzhEXFx1MkM4RlxcdTJDOTFcXHUyQzkzXFx1MkM5NVxcdTJDOTdcXHUyQzk5XFx1MkM5QlxcdTJDOURcXHUyQzlGXFx1MkNBMVxcdTJDQTNcXHUyQ0E1XFx1MkNBN1xcdTJDQTlcXHUyQ0FCXFx1MkNBRFxcdTJDQUZcXHUyQ0IxXFx1MkNCM1xcdTJDQjVcXHUyQ0I3XFx1MkNCOVxcdTJDQkJcXHUyQ0JEXFx1MkNCRlxcdTJDQzFcXHUyQ0MzXFx1MkNDNVxcdTJDQzdcXHUyQ0M5XFx1MkNDQlxcdTJDQ0RcXHUyQ0NGXFx1MkNEMVxcdTJDRDNcXHUyQ0Q1XFx1MkNEN1xcdTJDRDlcXHUyQ0RCXFx1MkNERFxcdTJDREZcXHUyQ0UxXFx1MkNFM1xcdTJDRTRcXHUyQ0VDXFx1MkNFRVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdUE2NDFcXHVBNjQzXFx1QTY0NVxcdUE2NDdcXHVBNjQ5XFx1QTY0QlxcdUE2NERcXHVBNjRGXFx1QTY1MVxcdUE2NTNcXHVBNjU1XFx1QTY1N1xcdUE2NTlcXHVBNjVCXFx1QTY1RFxcdUE2NUZcXHVBNjYxXFx1QTY2M1xcdUE2NjVcXHVBNjY3XFx1QTY2OVxcdUE2NkJcXHVBNjZEXFx1QTY4MVxcdUE2ODNcXHVBNjg1XFx1QTY4N1xcdUE2ODlcXHVBNjhCXFx1QTY4RFxcdUE2OEZcXHVBNjkxXFx1QTY5M1xcdUE2OTVcXHVBNjk3XFx1QTY5OVxcdUE2OUJcXHVBNzIzXFx1QTcyNVxcdUE3MjdcXHVBNzI5XFx1QTcyQlxcdUE3MkRcXHVBNzJGLVxcdUE3MzFcXHVBNzMzXFx1QTczNVxcdUE3MzdcXHVBNzM5XFx1QTczQlxcdUE3M0RcXHVBNzNGXFx1QTc0MVxcdUE3NDNcXHVBNzQ1XFx1QTc0N1xcdUE3NDlcXHVBNzRCXFx1QTc0RFxcdUE3NEZcXHVBNzUxXFx1QTc1M1xcdUE3NTVcXHVBNzU3XFx1QTc1OVxcdUE3NUJcXHVBNzVEXFx1QTc1RlxcdUE3NjFcXHVBNzYzXFx1QTc2NVxcdUE3NjdcXHVBNzY5XFx1QTc2QlxcdUE3NkRcXHVBNzZGXFx1QTc3MS1cXHVBNzc4XFx1QTc3QVxcdUE3N0NcXHVBNzdGXFx1QTc4MVxcdUE3ODNcXHVBNzg1XFx1QTc4N1xcdUE3OENcXHVBNzhFXFx1QTc5MVxcdUE3OTMtXFx1QTc5NVxcdUE3OTdcXHVBNzk5XFx1QTc5QlxcdUE3OURcXHVBNzlGXFx1QTdBMVxcdUE3QTNcXHVBN0E1XFx1QTdBN1xcdUE3QTlcXHVBN0I1XFx1QTdCN1xcdUE3RkFcXHVBQjMwLVxcdUFCNUFcXHVBQjYwLVxcdUFCNjVcXHVBQjcwLVxcdUFCQkZcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGRjQxLVxcdUZGNUEwLTlcXHhCMlxceEIzXFx4QjlcXHhCQy1cXHhCRVxcdTA2NjAtXFx1MDY2OVxcdTA2RjAtXFx1MDZGOVxcdTA3QzAtXFx1MDdDOVxcdTA5NjYtXFx1MDk2RlxcdTA5RTYtXFx1MDlFRlxcdTA5RjQtXFx1MDlGOVxcdTBBNjYtXFx1MEE2RlxcdTBBRTYtXFx1MEFFRlxcdTBCNjYtXFx1MEI2RlxcdTBCNzItXFx1MEI3N1xcdTBCRTYtXFx1MEJGMlxcdTBDNjYtXFx1MEM2RlxcdTBDNzgtXFx1MEM3RVxcdTBDRTYtXFx1MENFRlxcdTBENjYtXFx1MEQ3NVxcdTBERTYtXFx1MERFRlxcdTBFNTAtXFx1MEU1OVxcdTBFRDAtXFx1MEVEOVxcdTBGMjAtXFx1MEYzM1xcdTEwNDAtXFx1MTA0OVxcdTEwOTAtXFx1MTA5OVxcdTEzNjktXFx1MTM3Q1xcdTE2RUUtXFx1MTZGMFxcdTE3RTAtXFx1MTdFOVxcdTE3RjAtXFx1MTdGOVxcdTE4MTAtXFx1MTgxOVxcdTE5NDYtXFx1MTk0RlxcdTE5RDAtXFx1MTlEQVxcdTFBODAtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFCNTAtXFx1MUI1OVxcdTFCQjAtXFx1MUJCOVxcdTFDNDAtXFx1MUM0OVxcdTFDNTAtXFx1MUM1OVxcdTIwNzBcXHUyMDc0LVxcdTIwNzlcXHUyMDgwLVxcdTIwODlcXHUyMTUwLVxcdTIxODJcXHUyMTg1LVxcdTIxODlcXHUyNDYwLVxcdTI0OUJcXHUyNEVBLVxcdTI0RkZcXHUyNzc2LVxcdTI3OTNcXHUyQ0ZEXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzgtXFx1MzAzQVxcdTMxOTItXFx1MzE5NVxcdTMyMjAtXFx1MzIyOVxcdTMyNDgtXFx1MzI0RlxcdTMyNTEtXFx1MzI1RlxcdTMyODAtXFx1MzI4OVxcdTMyQjEtXFx1MzJCRlxcdUE2MjAtXFx1QTYyOVxcdUE2RTYtXFx1QTZFRlxcdUE4MzAtXFx1QTgzNVxcdUE4RDAtXFx1QThEOVxcdUE5MDAtXFx1QTkwOVxcdUE5RDAtXFx1QTlEOVxcdUE5RjAtXFx1QTlGOVxcdUFBNTAtXFx1QUE1OVxcdUFCRjAtXFx1QUJGOVxcdUZGMTAtXFx1RkYxOV0pKFtBLVpcXHhDMC1cXHhENlxceEQ4LVxceERFXFx1MDEwMFxcdTAxMDJcXHUwMTA0XFx1MDEwNlxcdTAxMDhcXHUwMTBBXFx1MDEwQ1xcdTAxMEVcXHUwMTEwXFx1MDExMlxcdTAxMTRcXHUwMTE2XFx1MDExOFxcdTAxMUFcXHUwMTFDXFx1MDExRVxcdTAxMjBcXHUwMTIyXFx1MDEyNFxcdTAxMjZcXHUwMTI4XFx1MDEyQVxcdTAxMkNcXHUwMTJFXFx1MDEzMFxcdTAxMzJcXHUwMTM0XFx1MDEzNlxcdTAxMzlcXHUwMTNCXFx1MDEzRFxcdTAxM0ZcXHUwMTQxXFx1MDE0M1xcdTAxNDVcXHUwMTQ3XFx1MDE0QVxcdTAxNENcXHUwMTRFXFx1MDE1MFxcdTAxNTJcXHUwMTU0XFx1MDE1NlxcdTAxNThcXHUwMTVBXFx1MDE1Q1xcdTAxNUVcXHUwMTYwXFx1MDE2MlxcdTAxNjRcXHUwMTY2XFx1MDE2OFxcdTAxNkFcXHUwMTZDXFx1MDE2RVxcdTAxNzBcXHUwMTcyXFx1MDE3NFxcdTAxNzZcXHUwMTc4XFx1MDE3OVxcdTAxN0JcXHUwMTdEXFx1MDE4MVxcdTAxODJcXHUwMTg0XFx1MDE4NlxcdTAxODdcXHUwMTg5LVxcdTAxOEJcXHUwMThFLVxcdTAxOTFcXHUwMTkzXFx1MDE5NFxcdTAxOTYtXFx1MDE5OFxcdTAxOUNcXHUwMTlEXFx1MDE5RlxcdTAxQTBcXHUwMUEyXFx1MDFBNFxcdTAxQTZcXHUwMUE3XFx1MDFBOVxcdTAxQUNcXHUwMUFFXFx1MDFBRlxcdTAxQjEtXFx1MDFCM1xcdTAxQjVcXHUwMUI3XFx1MDFCOFxcdTAxQkNcXHUwMUM0XFx1MDFDN1xcdTAxQ0FcXHUwMUNEXFx1MDFDRlxcdTAxRDFcXHUwMUQzXFx1MDFENVxcdTAxRDdcXHUwMUQ5XFx1MDFEQlxcdTAxREVcXHUwMUUwXFx1MDFFMlxcdTAxRTRcXHUwMUU2XFx1MDFFOFxcdTAxRUFcXHUwMUVDXFx1MDFFRVxcdTAxRjFcXHUwMUY0XFx1MDFGNi1cXHUwMUY4XFx1MDFGQVxcdTAxRkNcXHUwMUZFXFx1MDIwMFxcdTAyMDJcXHUwMjA0XFx1MDIwNlxcdTAyMDhcXHUwMjBBXFx1MDIwQ1xcdTAyMEVcXHUwMjEwXFx1MDIxMlxcdTAyMTRcXHUwMjE2XFx1MDIxOFxcdTAyMUFcXHUwMjFDXFx1MDIxRVxcdTAyMjBcXHUwMjIyXFx1MDIyNFxcdTAyMjZcXHUwMjI4XFx1MDIyQVxcdTAyMkNcXHUwMjJFXFx1MDIzMFxcdTAyMzJcXHUwMjNBXFx1MDIzQlxcdTAyM0RcXHUwMjNFXFx1MDI0MVxcdTAyNDMtXFx1MDI0NlxcdTAyNDhcXHUwMjRBXFx1MDI0Q1xcdTAyNEVcXHUwMzcwXFx1MDM3MlxcdTAzNzZcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFXFx1MDM4RlxcdTAzOTEtXFx1MDNBMVxcdTAzQTMtXFx1MDNBQlxcdTAzQ0ZcXHUwM0QyLVxcdTAzRDRcXHUwM0Q4XFx1MDNEQVxcdTAzRENcXHUwM0RFXFx1MDNFMFxcdTAzRTJcXHUwM0U0XFx1MDNFNlxcdTAzRThcXHUwM0VBXFx1MDNFQ1xcdTAzRUVcXHUwM0Y0XFx1MDNGN1xcdTAzRjlcXHUwM0ZBXFx1MDNGRC1cXHUwNDJGXFx1MDQ2MFxcdTA0NjJcXHUwNDY0XFx1MDQ2NlxcdTA0NjhcXHUwNDZBXFx1MDQ2Q1xcdTA0NkVcXHUwNDcwXFx1MDQ3MlxcdTA0NzRcXHUwNDc2XFx1MDQ3OFxcdTA0N0FcXHUwNDdDXFx1MDQ3RVxcdTA0ODBcXHUwNDhBXFx1MDQ4Q1xcdTA0OEVcXHUwNDkwXFx1MDQ5MlxcdTA0OTRcXHUwNDk2XFx1MDQ5OFxcdTA0OUFcXHUwNDlDXFx1MDQ5RVxcdTA0QTBcXHUwNEEyXFx1MDRBNFxcdTA0QTZcXHUwNEE4XFx1MDRBQVxcdTA0QUNcXHUwNEFFXFx1MDRCMFxcdTA0QjJcXHUwNEI0XFx1MDRCNlxcdTA0QjhcXHUwNEJBXFx1MDRCQ1xcdTA0QkVcXHUwNEMwXFx1MDRDMVxcdTA0QzNcXHUwNEM1XFx1MDRDN1xcdTA0QzlcXHUwNENCXFx1MDRDRFxcdTA0RDBcXHUwNEQyXFx1MDRENFxcdTA0RDZcXHUwNEQ4XFx1MDREQVxcdTA0RENcXHUwNERFXFx1MDRFMFxcdTA0RTJcXHUwNEU0XFx1MDRFNlxcdTA0RThcXHUwNEVBXFx1MDRFQ1xcdTA0RUVcXHUwNEYwXFx1MDRGMlxcdTA0RjRcXHUwNEY2XFx1MDRGOFxcdTA0RkFcXHUwNEZDXFx1MDRGRVxcdTA1MDBcXHUwNTAyXFx1MDUwNFxcdTA1MDZcXHUwNTA4XFx1MDUwQVxcdTA1MENcXHUwNTBFXFx1MDUxMFxcdTA1MTJcXHUwNTE0XFx1MDUxNlxcdTA1MThcXHUwNTFBXFx1MDUxQ1xcdTA1MUVcXHUwNTIwXFx1MDUyMlxcdTA1MjRcXHUwNTI2XFx1MDUyOFxcdTA1MkFcXHUwNTJDXFx1MDUyRVxcdTA1MzEtXFx1MDU1NlxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTNBMC1cXHUxM0Y1XFx1MUUwMFxcdTFFMDJcXHUxRTA0XFx1MUUwNlxcdTFFMDhcXHUxRTBBXFx1MUUwQ1xcdTFFMEVcXHUxRTEwXFx1MUUxMlxcdTFFMTRcXHUxRTE2XFx1MUUxOFxcdTFFMUFcXHUxRTFDXFx1MUUxRVxcdTFFMjBcXHUxRTIyXFx1MUUyNFxcdTFFMjZcXHUxRTI4XFx1MUUyQVxcdTFFMkNcXHUxRTJFXFx1MUUzMFxcdTFFMzJcXHUxRTM0XFx1MUUzNlxcdTFFMzhcXHUxRTNBXFx1MUUzQ1xcdTFFM0VcXHUxRTQwXFx1MUU0MlxcdTFFNDRcXHUxRTQ2XFx1MUU0OFxcdTFFNEFcXHUxRTRDXFx1MUU0RVxcdTFFNTBcXHUxRTUyXFx1MUU1NFxcdTFFNTZcXHUxRTU4XFx1MUU1QVxcdTFFNUNcXHUxRTVFXFx1MUU2MFxcdTFFNjJcXHUxRTY0XFx1MUU2NlxcdTFFNjhcXHUxRTZBXFx1MUU2Q1xcdTFFNkVcXHUxRTcwXFx1MUU3MlxcdTFFNzRcXHUxRTc2XFx1MUU3OFxcdTFFN0FcXHUxRTdDXFx1MUU3RVxcdTFFODBcXHUxRTgyXFx1MUU4NFxcdTFFODZcXHUxRTg4XFx1MUU4QVxcdTFFOENcXHUxRThFXFx1MUU5MFxcdTFFOTJcXHUxRTk0XFx1MUU5RVxcdTFFQTBcXHUxRUEyXFx1MUVBNFxcdTFFQTZcXHUxRUE4XFx1MUVBQVxcdTFFQUNcXHUxRUFFXFx1MUVCMFxcdTFFQjJcXHUxRUI0XFx1MUVCNlxcdTFFQjhcXHUxRUJBXFx1MUVCQ1xcdTFFQkVcXHUxRUMwXFx1MUVDMlxcdTFFQzRcXHUxRUM2XFx1MUVDOFxcdTFFQ0FcXHUxRUNDXFx1MUVDRVxcdTFFRDBcXHUxRUQyXFx1MUVENFxcdTFFRDZcXHUxRUQ4XFx1MUVEQVxcdTFFRENcXHUxRURFXFx1MUVFMFxcdTFFRTJcXHUxRUU0XFx1MUVFNlxcdTFFRThcXHUxRUVBXFx1MUVFQ1xcdTFFRUVcXHUxRUYwXFx1MUVGMlxcdTFFRjRcXHUxRUY2XFx1MUVGOFxcdTFFRkFcXHUxRUZDXFx1MUVGRVxcdTFGMDgtXFx1MUYwRlxcdTFGMTgtXFx1MUYxRFxcdTFGMjgtXFx1MUYyRlxcdTFGMzgtXFx1MUYzRlxcdTFGNDgtXFx1MUY0RFxcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUZcXHUxRjY4LVxcdTFGNkZcXHUxRkI4LVxcdTFGQkJcXHUxRkM4LVxcdTFGQ0JcXHUxRkQ4LVxcdTFGREJcXHUxRkU4LVxcdTFGRUNcXHUxRkY4LVxcdTFGRkJcXHUyMTAyXFx1MjEwN1xcdTIxMEItXFx1MjEwRFxcdTIxMTAtXFx1MjExMlxcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTMwLVxcdTIxMzNcXHUyMTNFXFx1MjEzRlxcdTIxNDVcXHUyMTgzXFx1MkMwMC1cXHUyQzJFXFx1MkM2MFxcdTJDNjItXFx1MkM2NFxcdTJDNjdcXHUyQzY5XFx1MkM2QlxcdTJDNkQtXFx1MkM3MFxcdTJDNzJcXHUyQzc1XFx1MkM3RS1cXHUyQzgwXFx1MkM4MlxcdTJDODRcXHUyQzg2XFx1MkM4OFxcdTJDOEFcXHUyQzhDXFx1MkM4RVxcdTJDOTBcXHUyQzkyXFx1MkM5NFxcdTJDOTZcXHUyQzk4XFx1MkM5QVxcdTJDOUNcXHUyQzlFXFx1MkNBMFxcdTJDQTJcXHUyQ0E0XFx1MkNBNlxcdTJDQThcXHUyQ0FBXFx1MkNBQ1xcdTJDQUVcXHUyQ0IwXFx1MkNCMlxcdTJDQjRcXHUyQ0I2XFx1MkNCOFxcdTJDQkFcXHUyQ0JDXFx1MkNCRVxcdTJDQzBcXHUyQ0MyXFx1MkNDNFxcdTJDQzZcXHUyQ0M4XFx1MkNDQVxcdTJDQ0NcXHUyQ0NFXFx1MkNEMFxcdTJDRDJcXHUyQ0Q0XFx1MkNENlxcdTJDRDhcXHUyQ0RBXFx1MkNEQ1xcdTJDREVcXHUyQ0UwXFx1MkNFMlxcdTJDRUJcXHUyQ0VEXFx1MkNGMlxcdUE2NDBcXHVBNjQyXFx1QTY0NFxcdUE2NDZcXHVBNjQ4XFx1QTY0QVxcdUE2NENcXHVBNjRFXFx1QTY1MFxcdUE2NTJcXHVBNjU0XFx1QTY1NlxcdUE2NThcXHVBNjVBXFx1QTY1Q1xcdUE2NUVcXHVBNjYwXFx1QTY2MlxcdUE2NjRcXHVBNjY2XFx1QTY2OFxcdUE2NkFcXHVBNjZDXFx1QTY4MFxcdUE2ODJcXHVBNjg0XFx1QTY4NlxcdUE2ODhcXHVBNjhBXFx1QTY4Q1xcdUE2OEVcXHVBNjkwXFx1QTY5MlxcdUE2OTRcXHVBNjk2XFx1QTY5OFxcdUE2OUFcXHVBNzIyXFx1QTcyNFxcdUE3MjZcXHVBNzI4XFx1QTcyQVxcdUE3MkNcXHVBNzJFXFx1QTczMlxcdUE3MzRcXHVBNzM2XFx1QTczOFxcdUE3M0FcXHVBNzNDXFx1QTczRVxcdUE3NDBcXHVBNzQyXFx1QTc0NFxcdUE3NDZcXHVBNzQ4XFx1QTc0QVxcdUE3NENcXHVBNzRFXFx1QTc1MFxcdUE3NTJcXHVBNzU0XFx1QTc1NlxcdUE3NThcXHVBNzVBXFx1QTc1Q1xcdUE3NUVcXHVBNzYwXFx1QTc2MlxcdUE3NjRcXHVBNzY2XFx1QTc2OFxcdUE3NkFcXHVBNzZDXFx1QTc2RVxcdUE3NzlcXHVBNzdCXFx1QTc3RFxcdUE3N0VcXHVBNzgwXFx1QTc4MlxcdUE3ODRcXHVBNzg2XFx1QTc4QlxcdUE3OERcXHVBNzkwXFx1QTc5MlxcdUE3OTZcXHVBNzk4XFx1QTc5QVxcdUE3OUNcXHVBNzlFXFx1QTdBMFxcdUE3QTJcXHVBN0E0XFx1QTdBNlxcdUE3QThcXHVBN0FBLVxcdUE3QURcXHVBN0IwLVxcdUE3QjRcXHVBN0I2XFx1RkYyMS1cXHVGRjNBXSkvZ1xuIiwibW9kdWxlLmV4cG9ydHMgPSAvKFtBLVpcXHhDMC1cXHhENlxceEQ4LVxceERFXFx1MDEwMFxcdTAxMDJcXHUwMTA0XFx1MDEwNlxcdTAxMDhcXHUwMTBBXFx1MDEwQ1xcdTAxMEVcXHUwMTEwXFx1MDExMlxcdTAxMTRcXHUwMTE2XFx1MDExOFxcdTAxMUFcXHUwMTFDXFx1MDExRVxcdTAxMjBcXHUwMTIyXFx1MDEyNFxcdTAxMjZcXHUwMTI4XFx1MDEyQVxcdTAxMkNcXHUwMTJFXFx1MDEzMFxcdTAxMzJcXHUwMTM0XFx1MDEzNlxcdTAxMzlcXHUwMTNCXFx1MDEzRFxcdTAxM0ZcXHUwMTQxXFx1MDE0M1xcdTAxNDVcXHUwMTQ3XFx1MDE0QVxcdTAxNENcXHUwMTRFXFx1MDE1MFxcdTAxNTJcXHUwMTU0XFx1MDE1NlxcdTAxNThcXHUwMTVBXFx1MDE1Q1xcdTAxNUVcXHUwMTYwXFx1MDE2MlxcdTAxNjRcXHUwMTY2XFx1MDE2OFxcdTAxNkFcXHUwMTZDXFx1MDE2RVxcdTAxNzBcXHUwMTcyXFx1MDE3NFxcdTAxNzZcXHUwMTc4XFx1MDE3OVxcdTAxN0JcXHUwMTdEXFx1MDE4MVxcdTAxODJcXHUwMTg0XFx1MDE4NlxcdTAxODdcXHUwMTg5LVxcdTAxOEJcXHUwMThFLVxcdTAxOTFcXHUwMTkzXFx1MDE5NFxcdTAxOTYtXFx1MDE5OFxcdTAxOUNcXHUwMTlEXFx1MDE5RlxcdTAxQTBcXHUwMUEyXFx1MDFBNFxcdTAxQTZcXHUwMUE3XFx1MDFBOVxcdTAxQUNcXHUwMUFFXFx1MDFBRlxcdTAxQjEtXFx1MDFCM1xcdTAxQjVcXHUwMUI3XFx1MDFCOFxcdTAxQkNcXHUwMUM0XFx1MDFDN1xcdTAxQ0FcXHUwMUNEXFx1MDFDRlxcdTAxRDFcXHUwMUQzXFx1MDFENVxcdTAxRDdcXHUwMUQ5XFx1MDFEQlxcdTAxREVcXHUwMUUwXFx1MDFFMlxcdTAxRTRcXHUwMUU2XFx1MDFFOFxcdTAxRUFcXHUwMUVDXFx1MDFFRVxcdTAxRjFcXHUwMUY0XFx1MDFGNi1cXHUwMUY4XFx1MDFGQVxcdTAxRkNcXHUwMUZFXFx1MDIwMFxcdTAyMDJcXHUwMjA0XFx1MDIwNlxcdTAyMDhcXHUwMjBBXFx1MDIwQ1xcdTAyMEVcXHUwMjEwXFx1MDIxMlxcdTAyMTRcXHUwMjE2XFx1MDIxOFxcdTAyMUFcXHUwMjFDXFx1MDIxRVxcdTAyMjBcXHUwMjIyXFx1MDIyNFxcdTAyMjZcXHUwMjI4XFx1MDIyQVxcdTAyMkNcXHUwMjJFXFx1MDIzMFxcdTAyMzJcXHUwMjNBXFx1MDIzQlxcdTAyM0RcXHUwMjNFXFx1MDI0MVxcdTAyNDMtXFx1MDI0NlxcdTAyNDhcXHUwMjRBXFx1MDI0Q1xcdTAyNEVcXHUwMzcwXFx1MDM3MlxcdTAzNzZcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFXFx1MDM4RlxcdTAzOTEtXFx1MDNBMVxcdTAzQTMtXFx1MDNBQlxcdTAzQ0ZcXHUwM0QyLVxcdTAzRDRcXHUwM0Q4XFx1MDNEQVxcdTAzRENcXHUwM0RFXFx1MDNFMFxcdTAzRTJcXHUwM0U0XFx1MDNFNlxcdTAzRThcXHUwM0VBXFx1MDNFQ1xcdTAzRUVcXHUwM0Y0XFx1MDNGN1xcdTAzRjlcXHUwM0ZBXFx1MDNGRC1cXHUwNDJGXFx1MDQ2MFxcdTA0NjJcXHUwNDY0XFx1MDQ2NlxcdTA0NjhcXHUwNDZBXFx1MDQ2Q1xcdTA0NkVcXHUwNDcwXFx1MDQ3MlxcdTA0NzRcXHUwNDc2XFx1MDQ3OFxcdTA0N0FcXHUwNDdDXFx1MDQ3RVxcdTA0ODBcXHUwNDhBXFx1MDQ4Q1xcdTA0OEVcXHUwNDkwXFx1MDQ5MlxcdTA0OTRcXHUwNDk2XFx1MDQ5OFxcdTA0OUFcXHUwNDlDXFx1MDQ5RVxcdTA0QTBcXHUwNEEyXFx1MDRBNFxcdTA0QTZcXHUwNEE4XFx1MDRBQVxcdTA0QUNcXHUwNEFFXFx1MDRCMFxcdTA0QjJcXHUwNEI0XFx1MDRCNlxcdTA0QjhcXHUwNEJBXFx1MDRCQ1xcdTA0QkVcXHUwNEMwXFx1MDRDMVxcdTA0QzNcXHUwNEM1XFx1MDRDN1xcdTA0QzlcXHUwNENCXFx1MDRDRFxcdTA0RDBcXHUwNEQyXFx1MDRENFxcdTA0RDZcXHUwNEQ4XFx1MDREQVxcdTA0RENcXHUwNERFXFx1MDRFMFxcdTA0RTJcXHUwNEU0XFx1MDRFNlxcdTA0RThcXHUwNEVBXFx1MDRFQ1xcdTA0RUVcXHUwNEYwXFx1MDRGMlxcdTA0RjRcXHUwNEY2XFx1MDRGOFxcdTA0RkFcXHUwNEZDXFx1MDRGRVxcdTA1MDBcXHUwNTAyXFx1MDUwNFxcdTA1MDZcXHUwNTA4XFx1MDUwQVxcdTA1MENcXHUwNTBFXFx1MDUxMFxcdTA1MTJcXHUwNTE0XFx1MDUxNlxcdTA1MThcXHUwNTFBXFx1MDUxQ1xcdTA1MUVcXHUwNTIwXFx1MDUyMlxcdTA1MjRcXHUwNTI2XFx1MDUyOFxcdTA1MkFcXHUwNTJDXFx1MDUyRVxcdTA1MzEtXFx1MDU1NlxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTNBMC1cXHUxM0Y1XFx1MUUwMFxcdTFFMDJcXHUxRTA0XFx1MUUwNlxcdTFFMDhcXHUxRTBBXFx1MUUwQ1xcdTFFMEVcXHUxRTEwXFx1MUUxMlxcdTFFMTRcXHUxRTE2XFx1MUUxOFxcdTFFMUFcXHUxRTFDXFx1MUUxRVxcdTFFMjBcXHUxRTIyXFx1MUUyNFxcdTFFMjZcXHUxRTI4XFx1MUUyQVxcdTFFMkNcXHUxRTJFXFx1MUUzMFxcdTFFMzJcXHUxRTM0XFx1MUUzNlxcdTFFMzhcXHUxRTNBXFx1MUUzQ1xcdTFFM0VcXHUxRTQwXFx1MUU0MlxcdTFFNDRcXHUxRTQ2XFx1MUU0OFxcdTFFNEFcXHUxRTRDXFx1MUU0RVxcdTFFNTBcXHUxRTUyXFx1MUU1NFxcdTFFNTZcXHUxRTU4XFx1MUU1QVxcdTFFNUNcXHUxRTVFXFx1MUU2MFxcdTFFNjJcXHUxRTY0XFx1MUU2NlxcdTFFNjhcXHUxRTZBXFx1MUU2Q1xcdTFFNkVcXHUxRTcwXFx1MUU3MlxcdTFFNzRcXHUxRTc2XFx1MUU3OFxcdTFFN0FcXHUxRTdDXFx1MUU3RVxcdTFFODBcXHUxRTgyXFx1MUU4NFxcdTFFODZcXHUxRTg4XFx1MUU4QVxcdTFFOENcXHUxRThFXFx1MUU5MFxcdTFFOTJcXHUxRTk0XFx1MUU5RVxcdTFFQTBcXHUxRUEyXFx1MUVBNFxcdTFFQTZcXHUxRUE4XFx1MUVBQVxcdTFFQUNcXHUxRUFFXFx1MUVCMFxcdTFFQjJcXHUxRUI0XFx1MUVCNlxcdTFFQjhcXHUxRUJBXFx1MUVCQ1xcdTFFQkVcXHUxRUMwXFx1MUVDMlxcdTFFQzRcXHUxRUM2XFx1MUVDOFxcdTFFQ0FcXHUxRUNDXFx1MUVDRVxcdTFFRDBcXHUxRUQyXFx1MUVENFxcdTFFRDZcXHUxRUQ4XFx1MUVEQVxcdTFFRENcXHUxRURFXFx1MUVFMFxcdTFFRTJcXHUxRUU0XFx1MUVFNlxcdTFFRThcXHUxRUVBXFx1MUVFQ1xcdTFFRUVcXHUxRUYwXFx1MUVGMlxcdTFFRjRcXHUxRUY2XFx1MUVGOFxcdTFFRkFcXHUxRUZDXFx1MUVGRVxcdTFGMDgtXFx1MUYwRlxcdTFGMTgtXFx1MUYxRFxcdTFGMjgtXFx1MUYyRlxcdTFGMzgtXFx1MUYzRlxcdTFGNDgtXFx1MUY0RFxcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUZcXHUxRjY4LVxcdTFGNkZcXHUxRkI4LVxcdTFGQkJcXHUxRkM4LVxcdTFGQ0JcXHUxRkQ4LVxcdTFGREJcXHUxRkU4LVxcdTFGRUNcXHUxRkY4LVxcdTFGRkJcXHUyMTAyXFx1MjEwN1xcdTIxMEItXFx1MjEwRFxcdTIxMTAtXFx1MjExMlxcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTMwLVxcdTIxMzNcXHUyMTNFXFx1MjEzRlxcdTIxNDVcXHUyMTgzXFx1MkMwMC1cXHUyQzJFXFx1MkM2MFxcdTJDNjItXFx1MkM2NFxcdTJDNjdcXHUyQzY5XFx1MkM2QlxcdTJDNkQtXFx1MkM3MFxcdTJDNzJcXHUyQzc1XFx1MkM3RS1cXHUyQzgwXFx1MkM4MlxcdTJDODRcXHUyQzg2XFx1MkM4OFxcdTJDOEFcXHUyQzhDXFx1MkM4RVxcdTJDOTBcXHUyQzkyXFx1MkM5NFxcdTJDOTZcXHUyQzk4XFx1MkM5QVxcdTJDOUNcXHUyQzlFXFx1MkNBMFxcdTJDQTJcXHUyQ0E0XFx1MkNBNlxcdTJDQThcXHUyQ0FBXFx1MkNBQ1xcdTJDQUVcXHUyQ0IwXFx1MkNCMlxcdTJDQjRcXHUyQ0I2XFx1MkNCOFxcdTJDQkFcXHUyQ0JDXFx1MkNCRVxcdTJDQzBcXHUyQ0MyXFx1MkNDNFxcdTJDQzZcXHUyQ0M4XFx1MkNDQVxcdTJDQ0NcXHUyQ0NFXFx1MkNEMFxcdTJDRDJcXHUyQ0Q0XFx1MkNENlxcdTJDRDhcXHUyQ0RBXFx1MkNEQ1xcdTJDREVcXHUyQ0UwXFx1MkNFMlxcdTJDRUJcXHUyQ0VEXFx1MkNGMlxcdUE2NDBcXHVBNjQyXFx1QTY0NFxcdUE2NDZcXHVBNjQ4XFx1QTY0QVxcdUE2NENcXHVBNjRFXFx1QTY1MFxcdUE2NTJcXHVBNjU0XFx1QTY1NlxcdUE2NThcXHVBNjVBXFx1QTY1Q1xcdUE2NUVcXHVBNjYwXFx1QTY2MlxcdUE2NjRcXHVBNjY2XFx1QTY2OFxcdUE2NkFcXHVBNjZDXFx1QTY4MFxcdUE2ODJcXHVBNjg0XFx1QTY4NlxcdUE2ODhcXHVBNjhBXFx1QTY4Q1xcdUE2OEVcXHVBNjkwXFx1QTY5MlxcdUE2OTRcXHVBNjk2XFx1QTY5OFxcdUE2OUFcXHVBNzIyXFx1QTcyNFxcdUE3MjZcXHVBNzI4XFx1QTcyQVxcdUE3MkNcXHVBNzJFXFx1QTczMlxcdUE3MzRcXHVBNzM2XFx1QTczOFxcdUE3M0FcXHVBNzNDXFx1QTczRVxcdUE3NDBcXHVBNzQyXFx1QTc0NFxcdUE3NDZcXHVBNzQ4XFx1QTc0QVxcdUE3NENcXHVBNzRFXFx1QTc1MFxcdUE3NTJcXHVBNzU0XFx1QTc1NlxcdUE3NThcXHVBNzVBXFx1QTc1Q1xcdUE3NUVcXHVBNzYwXFx1QTc2MlxcdUE3NjRcXHVBNzY2XFx1QTc2OFxcdUE3NkFcXHVBNzZDXFx1QTc2RVxcdUE3NzlcXHVBNzdCXFx1QTc3RFxcdUE3N0VcXHVBNzgwXFx1QTc4MlxcdUE3ODRcXHVBNzg2XFx1QTc4QlxcdUE3OERcXHVBNzkwXFx1QTc5MlxcdUE3OTZcXHVBNzk4XFx1QTc5QVxcdUE3OUNcXHVBNzlFXFx1QTdBMFxcdUE3QTJcXHVBN0E0XFx1QTdBNlxcdUE3QThcXHVBN0FBLVxcdUE3QURcXHVBN0IwLVxcdUE3QjRcXHVBN0I2XFx1RkYyMS1cXHVGRjNBXSkoW0EtWlxceEMwLVxceEQ2XFx4RDgtXFx4REVcXHUwMTAwXFx1MDEwMlxcdTAxMDRcXHUwMTA2XFx1MDEwOFxcdTAxMEFcXHUwMTBDXFx1MDEwRVxcdTAxMTBcXHUwMTEyXFx1MDExNFxcdTAxMTZcXHUwMTE4XFx1MDExQVxcdTAxMUNcXHUwMTFFXFx1MDEyMFxcdTAxMjJcXHUwMTI0XFx1MDEyNlxcdTAxMjhcXHUwMTJBXFx1MDEyQ1xcdTAxMkVcXHUwMTMwXFx1MDEzMlxcdTAxMzRcXHUwMTM2XFx1MDEzOVxcdTAxM0JcXHUwMTNEXFx1MDEzRlxcdTAxNDFcXHUwMTQzXFx1MDE0NVxcdTAxNDdcXHUwMTRBXFx1MDE0Q1xcdTAxNEVcXHUwMTUwXFx1MDE1MlxcdTAxNTRcXHUwMTU2XFx1MDE1OFxcdTAxNUFcXHUwMTVDXFx1MDE1RVxcdTAxNjBcXHUwMTYyXFx1MDE2NFxcdTAxNjZcXHUwMTY4XFx1MDE2QVxcdTAxNkNcXHUwMTZFXFx1MDE3MFxcdTAxNzJcXHUwMTc0XFx1MDE3NlxcdTAxNzhcXHUwMTc5XFx1MDE3QlxcdTAxN0RcXHUwMTgxXFx1MDE4MlxcdTAxODRcXHUwMTg2XFx1MDE4N1xcdTAxODktXFx1MDE4QlxcdTAxOEUtXFx1MDE5MVxcdTAxOTNcXHUwMTk0XFx1MDE5Ni1cXHUwMTk4XFx1MDE5Q1xcdTAxOURcXHUwMTlGXFx1MDFBMFxcdTAxQTJcXHUwMUE0XFx1MDFBNlxcdTAxQTdcXHUwMUE5XFx1MDFBQ1xcdTAxQUVcXHUwMUFGXFx1MDFCMS1cXHUwMUIzXFx1MDFCNVxcdTAxQjdcXHUwMUI4XFx1MDFCQ1xcdTAxQzRcXHUwMUM3XFx1MDFDQVxcdTAxQ0RcXHUwMUNGXFx1MDFEMVxcdTAxRDNcXHUwMUQ1XFx1MDFEN1xcdTAxRDlcXHUwMURCXFx1MDFERVxcdTAxRTBcXHUwMUUyXFx1MDFFNFxcdTAxRTZcXHUwMUU4XFx1MDFFQVxcdTAxRUNcXHUwMUVFXFx1MDFGMVxcdTAxRjRcXHUwMUY2LVxcdTAxRjhcXHUwMUZBXFx1MDFGQ1xcdTAxRkVcXHUwMjAwXFx1MDIwMlxcdTAyMDRcXHUwMjA2XFx1MDIwOFxcdTAyMEFcXHUwMjBDXFx1MDIwRVxcdTAyMTBcXHUwMjEyXFx1MDIxNFxcdTAyMTZcXHUwMjE4XFx1MDIxQVxcdTAyMUNcXHUwMjFFXFx1MDIyMFxcdTAyMjJcXHUwMjI0XFx1MDIyNlxcdTAyMjhcXHUwMjJBXFx1MDIyQ1xcdTAyMkVcXHUwMjMwXFx1MDIzMlxcdTAyM0FcXHUwMjNCXFx1MDIzRFxcdTAyM0VcXHUwMjQxXFx1MDI0My1cXHUwMjQ2XFx1MDI0OFxcdTAyNEFcXHUwMjRDXFx1MDI0RVxcdTAzNzBcXHUwMzcyXFx1MDM3NlxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEVcXHUwMzhGXFx1MDM5MS1cXHUwM0ExXFx1MDNBMy1cXHUwM0FCXFx1MDNDRlxcdTAzRDItXFx1MDNENFxcdTAzRDhcXHUwM0RBXFx1MDNEQ1xcdTAzREVcXHUwM0UwXFx1MDNFMlxcdTAzRTRcXHUwM0U2XFx1MDNFOFxcdTAzRUFcXHUwM0VDXFx1MDNFRVxcdTAzRjRcXHUwM0Y3XFx1MDNGOVxcdTAzRkFcXHUwM0ZELVxcdTA0MkZcXHUwNDYwXFx1MDQ2MlxcdTA0NjRcXHUwNDY2XFx1MDQ2OFxcdTA0NkFcXHUwNDZDXFx1MDQ2RVxcdTA0NzBcXHUwNDcyXFx1MDQ3NFxcdTA0NzZcXHUwNDc4XFx1MDQ3QVxcdTA0N0NcXHUwNDdFXFx1MDQ4MFxcdTA0OEFcXHUwNDhDXFx1MDQ4RVxcdTA0OTBcXHUwNDkyXFx1MDQ5NFxcdTA0OTZcXHUwNDk4XFx1MDQ5QVxcdTA0OUNcXHUwNDlFXFx1MDRBMFxcdTA0QTJcXHUwNEE0XFx1MDRBNlxcdTA0QThcXHUwNEFBXFx1MDRBQ1xcdTA0QUVcXHUwNEIwXFx1MDRCMlxcdTA0QjRcXHUwNEI2XFx1MDRCOFxcdTA0QkFcXHUwNEJDXFx1MDRCRVxcdTA0QzBcXHUwNEMxXFx1MDRDM1xcdTA0QzVcXHUwNEM3XFx1MDRDOVxcdTA0Q0JcXHUwNENEXFx1MDREMFxcdTA0RDJcXHUwNEQ0XFx1MDRENlxcdTA0RDhcXHUwNERBXFx1MDREQ1xcdTA0REVcXHUwNEUwXFx1MDRFMlxcdTA0RTRcXHUwNEU2XFx1MDRFOFxcdTA0RUFcXHUwNEVDXFx1MDRFRVxcdTA0RjBcXHUwNEYyXFx1MDRGNFxcdTA0RjZcXHUwNEY4XFx1MDRGQVxcdTA0RkNcXHUwNEZFXFx1MDUwMFxcdTA1MDJcXHUwNTA0XFx1MDUwNlxcdTA1MDhcXHUwNTBBXFx1MDUwQ1xcdTA1MEVcXHUwNTEwXFx1MDUxMlxcdTA1MTRcXHUwNTE2XFx1MDUxOFxcdTA1MUFcXHUwNTFDXFx1MDUxRVxcdTA1MjBcXHUwNTIyXFx1MDUyNFxcdTA1MjZcXHUwNTI4XFx1MDUyQVxcdTA1MkNcXHUwNTJFXFx1MDUzMS1cXHUwNTU2XFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxM0EwLVxcdTEzRjVcXHUxRTAwXFx1MUUwMlxcdTFFMDRcXHUxRTA2XFx1MUUwOFxcdTFFMEFcXHUxRTBDXFx1MUUwRVxcdTFFMTBcXHUxRTEyXFx1MUUxNFxcdTFFMTZcXHUxRTE4XFx1MUUxQVxcdTFFMUNcXHUxRTFFXFx1MUUyMFxcdTFFMjJcXHUxRTI0XFx1MUUyNlxcdTFFMjhcXHUxRTJBXFx1MUUyQ1xcdTFFMkVcXHUxRTMwXFx1MUUzMlxcdTFFMzRcXHUxRTM2XFx1MUUzOFxcdTFFM0FcXHUxRTNDXFx1MUUzRVxcdTFFNDBcXHUxRTQyXFx1MUU0NFxcdTFFNDZcXHUxRTQ4XFx1MUU0QVxcdTFFNENcXHUxRTRFXFx1MUU1MFxcdTFFNTJcXHUxRTU0XFx1MUU1NlxcdTFFNThcXHUxRTVBXFx1MUU1Q1xcdTFFNUVcXHUxRTYwXFx1MUU2MlxcdTFFNjRcXHUxRTY2XFx1MUU2OFxcdTFFNkFcXHUxRTZDXFx1MUU2RVxcdTFFNzBcXHUxRTcyXFx1MUU3NFxcdTFFNzZcXHUxRTc4XFx1MUU3QVxcdTFFN0NcXHUxRTdFXFx1MUU4MFxcdTFFODJcXHUxRTg0XFx1MUU4NlxcdTFFODhcXHUxRThBXFx1MUU4Q1xcdTFFOEVcXHUxRTkwXFx1MUU5MlxcdTFFOTRcXHUxRTlFXFx1MUVBMFxcdTFFQTJcXHUxRUE0XFx1MUVBNlxcdTFFQThcXHUxRUFBXFx1MUVBQ1xcdTFFQUVcXHUxRUIwXFx1MUVCMlxcdTFFQjRcXHUxRUI2XFx1MUVCOFxcdTFFQkFcXHUxRUJDXFx1MUVCRVxcdTFFQzBcXHUxRUMyXFx1MUVDNFxcdTFFQzZcXHUxRUM4XFx1MUVDQVxcdTFFQ0NcXHUxRUNFXFx1MUVEMFxcdTFFRDJcXHUxRUQ0XFx1MUVENlxcdTFFRDhcXHUxRURBXFx1MUVEQ1xcdTFFREVcXHUxRUUwXFx1MUVFMlxcdTFFRTRcXHUxRUU2XFx1MUVFOFxcdTFFRUFcXHUxRUVDXFx1MUVFRVxcdTFFRjBcXHUxRUYyXFx1MUVGNFxcdTFFRjZcXHUxRUY4XFx1MUVGQVxcdTFFRkNcXHUxRUZFXFx1MUYwOC1cXHUxRjBGXFx1MUYxOC1cXHUxRjFEXFx1MUYyOC1cXHUxRjJGXFx1MUYzOC1cXHUxRjNGXFx1MUY0OC1cXHUxRjREXFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1RlxcdTFGNjgtXFx1MUY2RlxcdTFGQjgtXFx1MUZCQlxcdTFGQzgtXFx1MUZDQlxcdTFGRDgtXFx1MUZEQlxcdTFGRTgtXFx1MUZFQ1xcdTFGRjgtXFx1MUZGQlxcdTIxMDJcXHUyMTA3XFx1MjEwQi1cXHUyMTBEXFx1MjExMC1cXHUyMTEyXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMzAtXFx1MjEzM1xcdTIxM0VcXHUyMTNGXFx1MjE0NVxcdTIxODNcXHUyQzAwLVxcdTJDMkVcXHUyQzYwXFx1MkM2Mi1cXHUyQzY0XFx1MkM2N1xcdTJDNjlcXHUyQzZCXFx1MkM2RC1cXHUyQzcwXFx1MkM3MlxcdTJDNzVcXHUyQzdFLVxcdTJDODBcXHUyQzgyXFx1MkM4NFxcdTJDODZcXHUyQzg4XFx1MkM4QVxcdTJDOENcXHUyQzhFXFx1MkM5MFxcdTJDOTJcXHUyQzk0XFx1MkM5NlxcdTJDOThcXHUyQzlBXFx1MkM5Q1xcdTJDOUVcXHUyQ0EwXFx1MkNBMlxcdTJDQTRcXHUyQ0E2XFx1MkNBOFxcdTJDQUFcXHUyQ0FDXFx1MkNBRVxcdTJDQjBcXHUyQ0IyXFx1MkNCNFxcdTJDQjZcXHUyQ0I4XFx1MkNCQVxcdTJDQkNcXHUyQ0JFXFx1MkNDMFxcdTJDQzJcXHUyQ0M0XFx1MkNDNlxcdTJDQzhcXHUyQ0NBXFx1MkNDQ1xcdTJDQ0VcXHUyQ0QwXFx1MkNEMlxcdTJDRDRcXHUyQ0Q2XFx1MkNEOFxcdTJDREFcXHUyQ0RDXFx1MkNERVxcdTJDRTBcXHUyQ0UyXFx1MkNFQlxcdTJDRURcXHUyQ0YyXFx1QTY0MFxcdUE2NDJcXHVBNjQ0XFx1QTY0NlxcdUE2NDhcXHVBNjRBXFx1QTY0Q1xcdUE2NEVcXHVBNjUwXFx1QTY1MlxcdUE2NTRcXHVBNjU2XFx1QTY1OFxcdUE2NUFcXHVBNjVDXFx1QTY1RVxcdUE2NjBcXHVBNjYyXFx1QTY2NFxcdUE2NjZcXHVBNjY4XFx1QTY2QVxcdUE2NkNcXHVBNjgwXFx1QTY4MlxcdUE2ODRcXHVBNjg2XFx1QTY4OFxcdUE2OEFcXHVBNjhDXFx1QTY4RVxcdUE2OTBcXHVBNjkyXFx1QTY5NFxcdUE2OTZcXHVBNjk4XFx1QTY5QVxcdUE3MjJcXHVBNzI0XFx1QTcyNlxcdUE3MjhcXHVBNzJBXFx1QTcyQ1xcdUE3MkVcXHVBNzMyXFx1QTczNFxcdUE3MzZcXHVBNzM4XFx1QTczQVxcdUE3M0NcXHVBNzNFXFx1QTc0MFxcdUE3NDJcXHVBNzQ0XFx1QTc0NlxcdUE3NDhcXHVBNzRBXFx1QTc0Q1xcdUE3NEVcXHVBNzUwXFx1QTc1MlxcdUE3NTRcXHVBNzU2XFx1QTc1OFxcdUE3NUFcXHVBNzVDXFx1QTc1RVxcdUE3NjBcXHVBNzYyXFx1QTc2NFxcdUE3NjZcXHVBNzY4XFx1QTc2QVxcdUE3NkNcXHVBNzZFXFx1QTc3OVxcdUE3N0JcXHVBNzdEXFx1QTc3RVxcdUE3ODBcXHVBNzgyXFx1QTc4NFxcdUE3ODZcXHVBNzhCXFx1QTc4RFxcdUE3OTBcXHVBNzkyXFx1QTc5NlxcdUE3OThcXHVBNzlBXFx1QTc5Q1xcdUE3OUVcXHVBN0EwXFx1QTdBMlxcdUE3QTRcXHVBN0E2XFx1QTdBOFxcdUE3QUEtXFx1QTdBRFxcdUE3QjAtXFx1QTdCNFxcdUE3QjZcXHVGRjIxLVxcdUZGM0FdW2EtelxceEI1XFx4REYtXFx4RjZcXHhGOC1cXHhGRlxcdTAxMDFcXHUwMTAzXFx1MDEwNVxcdTAxMDdcXHUwMTA5XFx1MDEwQlxcdTAxMERcXHUwMTBGXFx1MDExMVxcdTAxMTNcXHUwMTE1XFx1MDExN1xcdTAxMTlcXHUwMTFCXFx1MDExRFxcdTAxMUZcXHUwMTIxXFx1MDEyM1xcdTAxMjVcXHUwMTI3XFx1MDEyOVxcdTAxMkJcXHUwMTJEXFx1MDEyRlxcdTAxMzFcXHUwMTMzXFx1MDEzNVxcdTAxMzdcXHUwMTM4XFx1MDEzQVxcdTAxM0NcXHUwMTNFXFx1MDE0MFxcdTAxNDJcXHUwMTQ0XFx1MDE0NlxcdTAxNDhcXHUwMTQ5XFx1MDE0QlxcdTAxNERcXHUwMTRGXFx1MDE1MVxcdTAxNTNcXHUwMTU1XFx1MDE1N1xcdTAxNTlcXHUwMTVCXFx1MDE1RFxcdTAxNUZcXHUwMTYxXFx1MDE2M1xcdTAxNjVcXHUwMTY3XFx1MDE2OVxcdTAxNkJcXHUwMTZEXFx1MDE2RlxcdTAxNzFcXHUwMTczXFx1MDE3NVxcdTAxNzdcXHUwMTdBXFx1MDE3Q1xcdTAxN0UtXFx1MDE4MFxcdTAxODNcXHUwMTg1XFx1MDE4OFxcdTAxOENcXHUwMThEXFx1MDE5MlxcdTAxOTVcXHUwMTk5LVxcdTAxOUJcXHUwMTlFXFx1MDFBMVxcdTAxQTNcXHUwMUE1XFx1MDFBOFxcdTAxQUFcXHUwMUFCXFx1MDFBRFxcdTAxQjBcXHUwMUI0XFx1MDFCNlxcdTAxQjlcXHUwMUJBXFx1MDFCRC1cXHUwMUJGXFx1MDFDNlxcdTAxQzlcXHUwMUNDXFx1MDFDRVxcdTAxRDBcXHUwMUQyXFx1MDFENFxcdTAxRDZcXHUwMUQ4XFx1MDFEQVxcdTAxRENcXHUwMUREXFx1MDFERlxcdTAxRTFcXHUwMUUzXFx1MDFFNVxcdTAxRTdcXHUwMUU5XFx1MDFFQlxcdTAxRURcXHUwMUVGXFx1MDFGMFxcdTAxRjNcXHUwMUY1XFx1MDFGOVxcdTAxRkJcXHUwMUZEXFx1MDFGRlxcdTAyMDFcXHUwMjAzXFx1MDIwNVxcdTAyMDdcXHUwMjA5XFx1MDIwQlxcdTAyMERcXHUwMjBGXFx1MDIxMVxcdTAyMTNcXHUwMjE1XFx1MDIxN1xcdTAyMTlcXHUwMjFCXFx1MDIxRFxcdTAyMUZcXHUwMjIxXFx1MDIyM1xcdTAyMjVcXHUwMjI3XFx1MDIyOVxcdTAyMkJcXHUwMjJEXFx1MDIyRlxcdTAyMzFcXHUwMjMzLVxcdTAyMzlcXHUwMjNDXFx1MDIzRlxcdTAyNDBcXHUwMjQyXFx1MDI0N1xcdTAyNDlcXHUwMjRCXFx1MDI0RFxcdTAyNEYtXFx1MDI5M1xcdTAyOTUtXFx1MDJBRlxcdTAzNzFcXHUwMzczXFx1MDM3N1xcdTAzN0ItXFx1MDM3RFxcdTAzOTBcXHUwM0FDLVxcdTAzQ0VcXHUwM0QwXFx1MDNEMVxcdTAzRDUtXFx1MDNEN1xcdTAzRDlcXHUwM0RCXFx1MDNERFxcdTAzREZcXHUwM0UxXFx1MDNFM1xcdTAzRTVcXHUwM0U3XFx1MDNFOVxcdTAzRUJcXHUwM0VEXFx1MDNFRi1cXHUwM0YzXFx1MDNGNVxcdTAzRjhcXHUwM0ZCXFx1MDNGQ1xcdTA0MzAtXFx1MDQ1RlxcdTA0NjFcXHUwNDYzXFx1MDQ2NVxcdTA0NjdcXHUwNDY5XFx1MDQ2QlxcdTA0NkRcXHUwNDZGXFx1MDQ3MVxcdTA0NzNcXHUwNDc1XFx1MDQ3N1xcdTA0NzlcXHUwNDdCXFx1MDQ3RFxcdTA0N0ZcXHUwNDgxXFx1MDQ4QlxcdTA0OERcXHUwNDhGXFx1MDQ5MVxcdTA0OTNcXHUwNDk1XFx1MDQ5N1xcdTA0OTlcXHUwNDlCXFx1MDQ5RFxcdTA0OUZcXHUwNEExXFx1MDRBM1xcdTA0QTVcXHUwNEE3XFx1MDRBOVxcdTA0QUJcXHUwNEFEXFx1MDRBRlxcdTA0QjFcXHUwNEIzXFx1MDRCNVxcdTA0QjdcXHUwNEI5XFx1MDRCQlxcdTA0QkRcXHUwNEJGXFx1MDRDMlxcdTA0QzRcXHUwNEM2XFx1MDRDOFxcdTA0Q0FcXHUwNENDXFx1MDRDRVxcdTA0Q0ZcXHUwNEQxXFx1MDREM1xcdTA0RDVcXHUwNEQ3XFx1MDREOVxcdTA0REJcXHUwNEREXFx1MDRERlxcdTA0RTFcXHUwNEUzXFx1MDRFNVxcdTA0RTdcXHUwNEU5XFx1MDRFQlxcdTA0RURcXHUwNEVGXFx1MDRGMVxcdTA0RjNcXHUwNEY1XFx1MDRGN1xcdTA0RjlcXHUwNEZCXFx1MDRGRFxcdTA0RkZcXHUwNTAxXFx1MDUwM1xcdTA1MDVcXHUwNTA3XFx1MDUwOVxcdTA1MEJcXHUwNTBEXFx1MDUwRlxcdTA1MTFcXHUwNTEzXFx1MDUxNVxcdTA1MTdcXHUwNTE5XFx1MDUxQlxcdTA1MURcXHUwNTFGXFx1MDUyMVxcdTA1MjNcXHUwNTI1XFx1MDUyN1xcdTA1MjlcXHUwNTJCXFx1MDUyRFxcdTA1MkZcXHUwNTYxLVxcdTA1ODdcXHUxM0Y4LVxcdTEzRkRcXHUxRDAwLVxcdTFEMkJcXHUxRDZCLVxcdTFENzdcXHUxRDc5LVxcdTFEOUFcXHUxRTAxXFx1MUUwM1xcdTFFMDVcXHUxRTA3XFx1MUUwOVxcdTFFMEJcXHUxRTBEXFx1MUUwRlxcdTFFMTFcXHUxRTEzXFx1MUUxNVxcdTFFMTdcXHUxRTE5XFx1MUUxQlxcdTFFMURcXHUxRTFGXFx1MUUyMVxcdTFFMjNcXHUxRTI1XFx1MUUyN1xcdTFFMjlcXHUxRTJCXFx1MUUyRFxcdTFFMkZcXHUxRTMxXFx1MUUzM1xcdTFFMzVcXHUxRTM3XFx1MUUzOVxcdTFFM0JcXHUxRTNEXFx1MUUzRlxcdTFFNDFcXHUxRTQzXFx1MUU0NVxcdTFFNDdcXHUxRTQ5XFx1MUU0QlxcdTFFNERcXHUxRTRGXFx1MUU1MVxcdTFFNTNcXHUxRTU1XFx1MUU1N1xcdTFFNTlcXHUxRTVCXFx1MUU1RFxcdTFFNUZcXHUxRTYxXFx1MUU2M1xcdTFFNjVcXHUxRTY3XFx1MUU2OVxcdTFFNkJcXHUxRTZEXFx1MUU2RlxcdTFFNzFcXHUxRTczXFx1MUU3NVxcdTFFNzdcXHUxRTc5XFx1MUU3QlxcdTFFN0RcXHUxRTdGXFx1MUU4MVxcdTFFODNcXHUxRTg1XFx1MUU4N1xcdTFFODlcXHUxRThCXFx1MUU4RFxcdTFFOEZcXHUxRTkxXFx1MUU5M1xcdTFFOTUtXFx1MUU5RFxcdTFFOUZcXHUxRUExXFx1MUVBM1xcdTFFQTVcXHUxRUE3XFx1MUVBOVxcdTFFQUJcXHUxRUFEXFx1MUVBRlxcdTFFQjFcXHUxRUIzXFx1MUVCNVxcdTFFQjdcXHUxRUI5XFx1MUVCQlxcdTFFQkRcXHUxRUJGXFx1MUVDMVxcdTFFQzNcXHUxRUM1XFx1MUVDN1xcdTFFQzlcXHUxRUNCXFx1MUVDRFxcdTFFQ0ZcXHUxRUQxXFx1MUVEM1xcdTFFRDVcXHUxRUQ3XFx1MUVEOVxcdTFFREJcXHUxRUREXFx1MUVERlxcdTFFRTFcXHUxRUUzXFx1MUVFNVxcdTFFRTdcXHUxRUU5XFx1MUVFQlxcdTFFRURcXHUxRUVGXFx1MUVGMVxcdTFFRjNcXHUxRUY1XFx1MUVGN1xcdTFFRjlcXHUxRUZCXFx1MUVGRFxcdTFFRkYtXFx1MUYwN1xcdTFGMTAtXFx1MUYxNVxcdTFGMjAtXFx1MUYyN1xcdTFGMzAtXFx1MUYzN1xcdTFGNDAtXFx1MUY0NVxcdTFGNTAtXFx1MUY1N1xcdTFGNjAtXFx1MUY2N1xcdTFGNzAtXFx1MUY3RFxcdTFGODAtXFx1MUY4N1xcdTFGOTAtXFx1MUY5N1xcdTFGQTAtXFx1MUZBN1xcdTFGQjAtXFx1MUZCNFxcdTFGQjZcXHUxRkI3XFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzZcXHUxRkM3XFx1MUZEMC1cXHUxRkQzXFx1MUZENlxcdTFGRDdcXHUxRkUwLVxcdTFGRTdcXHUxRkYyLVxcdTFGRjRcXHUxRkY2XFx1MUZGN1xcdTIxMEFcXHUyMTBFXFx1MjEwRlxcdTIxMTNcXHUyMTJGXFx1MjEzNFxcdTIxMzlcXHUyMTNDXFx1MjEzRFxcdTIxNDYtXFx1MjE0OVxcdTIxNEVcXHUyMTg0XFx1MkMzMC1cXHUyQzVFXFx1MkM2MVxcdTJDNjVcXHUyQzY2XFx1MkM2OFxcdTJDNkFcXHUyQzZDXFx1MkM3MVxcdTJDNzNcXHUyQzc0XFx1MkM3Ni1cXHUyQzdCXFx1MkM4MVxcdTJDODNcXHUyQzg1XFx1MkM4N1xcdTJDODlcXHUyQzhCXFx1MkM4RFxcdTJDOEZcXHUyQzkxXFx1MkM5M1xcdTJDOTVcXHUyQzk3XFx1MkM5OVxcdTJDOUJcXHUyQzlEXFx1MkM5RlxcdTJDQTFcXHUyQ0EzXFx1MkNBNVxcdTJDQTdcXHUyQ0E5XFx1MkNBQlxcdTJDQURcXHUyQ0FGXFx1MkNCMVxcdTJDQjNcXHUyQ0I1XFx1MkNCN1xcdTJDQjlcXHUyQ0JCXFx1MkNCRFxcdTJDQkZcXHUyQ0MxXFx1MkNDM1xcdTJDQzVcXHUyQ0M3XFx1MkNDOVxcdTJDQ0JcXHUyQ0NEXFx1MkNDRlxcdTJDRDFcXHUyQ0QzXFx1MkNENVxcdTJDRDdcXHUyQ0Q5XFx1MkNEQlxcdTJDRERcXHUyQ0RGXFx1MkNFMVxcdTJDRTNcXHUyQ0U0XFx1MkNFQ1xcdTJDRUVcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHVBNjQxXFx1QTY0M1xcdUE2NDVcXHVBNjQ3XFx1QTY0OVxcdUE2NEJcXHVBNjREXFx1QTY0RlxcdUE2NTFcXHVBNjUzXFx1QTY1NVxcdUE2NTdcXHVBNjU5XFx1QTY1QlxcdUE2NURcXHVBNjVGXFx1QTY2MVxcdUE2NjNcXHVBNjY1XFx1QTY2N1xcdUE2NjlcXHVBNjZCXFx1QTY2RFxcdUE2ODFcXHVBNjgzXFx1QTY4NVxcdUE2ODdcXHVBNjg5XFx1QTY4QlxcdUE2OERcXHVBNjhGXFx1QTY5MVxcdUE2OTNcXHVBNjk1XFx1QTY5N1xcdUE2OTlcXHVBNjlCXFx1QTcyM1xcdUE3MjVcXHVBNzI3XFx1QTcyOVxcdUE3MkJcXHVBNzJEXFx1QTcyRi1cXHVBNzMxXFx1QTczM1xcdUE3MzVcXHVBNzM3XFx1QTczOVxcdUE3M0JcXHVBNzNEXFx1QTczRlxcdUE3NDFcXHVBNzQzXFx1QTc0NVxcdUE3NDdcXHVBNzQ5XFx1QTc0QlxcdUE3NERcXHVBNzRGXFx1QTc1MVxcdUE3NTNcXHVBNzU1XFx1QTc1N1xcdUE3NTlcXHVBNzVCXFx1QTc1RFxcdUE3NUZcXHVBNzYxXFx1QTc2M1xcdUE3NjVcXHVBNzY3XFx1QTc2OVxcdUE3NkJcXHVBNzZEXFx1QTc2RlxcdUE3NzEtXFx1QTc3OFxcdUE3N0FcXHVBNzdDXFx1QTc3RlxcdUE3ODFcXHVBNzgzXFx1QTc4NVxcdUE3ODdcXHVBNzhDXFx1QTc4RVxcdUE3OTFcXHVBNzkzLVxcdUE3OTVcXHVBNzk3XFx1QTc5OVxcdUE3OUJcXHVBNzlEXFx1QTc5RlxcdUE3QTFcXHVBN0EzXFx1QTdBNVxcdUE3QTdcXHVBN0E5XFx1QTdCNVxcdUE3QjdcXHVBN0ZBXFx1QUIzMC1cXHVBQjVBXFx1QUI2MC1cXHVBQjY1XFx1QUI3MC1cXHVBQkJGXFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkY0MS1cXHVGRjVBXSkvZ1xuIiwibW9kdWxlLmV4cG9ydHMgPSAvW15BLVphLXpcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCNFxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNjBcXHUwQzYxXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDVGLVxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZGMS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE4M1xcdTIxODRcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJFMkZcXHUzMDA1XFx1MzAwNlxcdTMwMzEtXFx1MzAzNVxcdTMwM0JcXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RTVcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QURcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGREMwLTlcXHhCMlxceEIzXFx4QjlcXHhCQy1cXHhCRVxcdTA2NjAtXFx1MDY2OVxcdTA2RjAtXFx1MDZGOVxcdTA3QzAtXFx1MDdDOVxcdTA5NjYtXFx1MDk2RlxcdTA5RTYtXFx1MDlFRlxcdTA5RjQtXFx1MDlGOVxcdTBBNjYtXFx1MEE2RlxcdTBBRTYtXFx1MEFFRlxcdTBCNjYtXFx1MEI2RlxcdTBCNzItXFx1MEI3N1xcdTBCRTYtXFx1MEJGMlxcdTBDNjYtXFx1MEM2RlxcdTBDNzgtXFx1MEM3RVxcdTBDRTYtXFx1MENFRlxcdTBENjYtXFx1MEQ3NVxcdTBERTYtXFx1MERFRlxcdTBFNTAtXFx1MEU1OVxcdTBFRDAtXFx1MEVEOVxcdTBGMjAtXFx1MEYzM1xcdTEwNDAtXFx1MTA0OVxcdTEwOTAtXFx1MTA5OVxcdTEzNjktXFx1MTM3Q1xcdTE2RUUtXFx1MTZGMFxcdTE3RTAtXFx1MTdFOVxcdTE3RjAtXFx1MTdGOVxcdTE4MTAtXFx1MTgxOVxcdTE5NDYtXFx1MTk0RlxcdTE5RDAtXFx1MTlEQVxcdTFBODAtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFCNTAtXFx1MUI1OVxcdTFCQjAtXFx1MUJCOVxcdTFDNDAtXFx1MUM0OVxcdTFDNTAtXFx1MUM1OVxcdTIwNzBcXHUyMDc0LVxcdTIwNzlcXHUyMDgwLVxcdTIwODlcXHUyMTUwLVxcdTIxODJcXHUyMTg1LVxcdTIxODlcXHUyNDYwLVxcdTI0OUJcXHUyNEVBLVxcdTI0RkZcXHUyNzc2LVxcdTI3OTNcXHUyQ0ZEXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzgtXFx1MzAzQVxcdTMxOTItXFx1MzE5NVxcdTMyMjAtXFx1MzIyOVxcdTMyNDgtXFx1MzI0RlxcdTMyNTEtXFx1MzI1RlxcdTMyODAtXFx1MzI4OVxcdTMyQjEtXFx1MzJCRlxcdUE2MjAtXFx1QTYyOVxcdUE2RTYtXFx1QTZFRlxcdUE4MzAtXFx1QTgzNVxcdUE4RDAtXFx1QThEOVxcdUE5MDAtXFx1QTkwOVxcdUE5RDAtXFx1QTlEOVxcdUE5RjAtXFx1QTlGOVxcdUFBNTAtXFx1QUE1OVxcdUFCRjAtXFx1QUJGOVxcdUZGMTAtXFx1RkYxOV0rL2dcbiIsIlwidXNlIHN0cmljdFwiO1xyXG4vLyBBbiBhdWdtZW50ZWQgQVZMIFRyZWUgd2hlcmUgZWFjaCBub2RlIG1haW50YWlucyBhIGxpc3Qgb2YgcmVjb3JkcyBhbmQgdGhlaXIgc2VhcmNoIGludGVydmFscy5cclxuLy8gUmVjb3JkIGlzIGNvbXBvc2VkIG9mIGFuIGludGVydmFsIGFuZCBpdHMgdW5kZXJseWluZyBkYXRhLCBzZW50IGJ5IGEgY2xpZW50LiBUaGlzIGFsbG93cyB0aGVcclxuLy8gaW50ZXJ2YWwgdHJlZSB0byBoYXZlIHRoZSBzYW1lIGludGVydmFsIGluc2VydGVkIG11bHRpcGxlIHRpbWVzLCBhcyBsb25nIGl0cyBkYXRhIGlzIGRpZmZlcmVudC5cclxuLy8gQm90aCBpbnNlcnRpb24gYW5kIGRlbGV0aW9uIHJlcXVpcmUgTyhsb2cgbikgdGltZS4gU2VhcmNoaW5nIHJlcXVpcmVzIE8oaypsb2duKSB0aW1lLCB3aGVyZSBga2BcclxuLy8gaXMgdGhlIG51bWJlciBvZiBpbnRlcnZhbHMgaW4gdGhlIG91dHB1dCBsaXN0LlxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBpc1NhbWUgPSByZXF1aXJlKFwic2hhbGxvd2VxdWFsXCIpO1xyXG5mdW5jdGlvbiBoZWlnaHQobm9kZSkge1xyXG4gICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBub2RlLmhlaWdodDtcclxuICAgIH1cclxufVxyXG52YXIgTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5vZGUoaW50ZXJ2YWxUcmVlLCByZWNvcmQpIHtcclxuICAgICAgICB0aGlzLmludGVydmFsVHJlZSA9IGludGVydmFsVHJlZTtcclxuICAgICAgICB0aGlzLnJlY29yZHMgPSBbXTtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgdGhpcy5rZXkgPSByZWNvcmQubG93O1xyXG4gICAgICAgIHRoaXMubWF4ID0gcmVjb3JkLmhpZ2g7XHJcbiAgICAgICAgLy8gU2F2ZSB0aGUgYXJyYXkgb2YgYWxsIHJlY29yZHMgd2l0aCB0aGUgc2FtZSBrZXkgZm9yIHRoaXMgbm9kZVxyXG4gICAgICAgIHRoaXMucmVjb3Jkcy5wdXNoKHJlY29yZCk7XHJcbiAgICB9XHJcbiAgICAvLyBHZXRzIHRoZSBoaWdoZXN0IHJlY29yZC5oaWdoIHZhbHVlIGZvciB0aGlzIG5vZGVcclxuICAgIE5vZGUucHJvdG90eXBlLmdldE5vZGVIaWdoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBoaWdoID0gdGhpcy5yZWNvcmRzWzBdLmhpZ2g7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLnJlY29yZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVjb3Jkc1tpXS5oaWdoID4gaGlnaCkge1xyXG4gICAgICAgICAgICAgICAgaGlnaCA9IHRoaXMucmVjb3Jkc1tpXS5oaWdoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoaWdoO1xyXG4gICAgfTtcclxuICAgIC8vIFVwZGF0ZXMgaGVpZ2h0IHZhbHVlIG9mIHRoZSBub2RlLiBDYWxsZWQgZHVyaW5nIGluc2VydGlvbiwgcmViYWxhbmNlLCByZW1vdmFsXHJcbiAgICBOb2RlLnByb3RvdHlwZS51cGRhdGVIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1heChoZWlnaHQodGhpcy5sZWZ0KSwgaGVpZ2h0KHRoaXMucmlnaHQpKSArIDE7XHJcbiAgICB9O1xyXG4gICAgLy8gVXBkYXRlcyB0aGUgbWF4IHZhbHVlIG9mIGFsbCB0aGUgcGFyZW50cyBhZnRlciBpbnNlcnRpbmcgaW50byBhbHJlYWR5IGV4aXN0aW5nIG5vZGUsIGFzIHdlbGwgYXNcclxuICAgIC8vIHJlbW92aW5nIHRoZSBub2RlIGNvbXBsZXRlbHkgb3IgcmVtb3ZpbmcgdGhlIHJlY29yZCBvZiBhbiBhbHJlYWR5IGV4aXN0aW5nIG5vZGUuIFN0YXJ0cyB3aXRoXHJcbiAgICAvLyB0aGUgcGFyZW50IG9mIGFuIGFmZmVjdGVkIG5vZGUgYW5kIGJ1YmJsZXMgdXAgdG8gcm9vdFxyXG4gICAgTm9kZS5wcm90b3R5cGUudXBkYXRlTWF4T2ZQYXJlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGhpc0hpZ2ggPSB0aGlzLmdldE5vZGVIaWdoKCk7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KE1hdGgubWF4KHRoaXMubGVmdC5tYXgsIHRoaXMucmlnaHQubWF4KSwgdGhpc0hpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLmxlZnQubWF4LCB0aGlzSGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXMucmlnaHQubWF4LCB0aGlzSGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IHRoaXNIaWdoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQudXBkYXRlTWF4T2ZQYXJlbnRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBMZWZ0LUxlZnQgY2FzZTpcclxuICBcclxuICAgICAgICAgICB6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5XHJcbiAgICAgICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvICAgXFxcclxuICAgICAgICAgeSAgIFQ0ICAgICAgUmlnaHQgUm90YXRlICh6KSAgICAgICAgICB4ICAgICB6XHJcbiAgICAgICAgLyBcXCAgICAgICAgICAtIC0gLSAtIC0gLSAtIC0gLT4gICAgICAgLyBcXCAgIC8gXFxcclxuICAgICAgIHggICBUMyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVDEgVDIgVDMgVDRcclxuICAgICAgLyBcXFxyXG4gICAgVDEgICBUMlxyXG4gIFxyXG4gICAgTGVmdC1SaWdodCBjYXNlOlxyXG4gIFxyXG4gICAgICAgICB6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHogICAgICAgICAgICAgICAgICAgICAgICAgICB4XHJcbiAgICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgIC8gICBcXFxyXG4gICAgICAgeSAgIFQ0ICBMZWZ0IFJvdGF0ZSAoeSkgICAgICAgICB4ICBUNCAgUmlnaHQgUm90YXRlKHopICAgICB5ICAgICB6XHJcbiAgICAgIC8gXFwgICAgICAtIC0gLSAtIC0gLSAtIC0gLT4gICAgIC8gXFwgICAgICAtIC0gLSAtIC0gLSAtIC0+ICAvIFxcICAgLyBcXFxyXG4gICAgVDEgICB4ICAgICAgICAgICAgICAgICAgICAgICAgICAgeSAgVDMgICAgICAgICAgICAgICAgICAgICAgVDEgVDIgVDMgVDRcclxuICAgICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgIC8gXFxcclxuICAgICAgVDIgICBUMyAgICAgICAgICAgICAgICAgICAgICBUMSBUMlxyXG4gICAgKi9cclxuICAgIC8vIEhhbmRsZXMgTGVmdC1MZWZ0IGNhc2UgYW5kIExlZnQtUmlnaHQgY2FzZSBhZnRlciByZWJhbGFuY2luZyBBVkwgdHJlZVxyXG4gICAgTm9kZS5wcm90b3R5cGUuX3VwZGF0ZU1heEFmdGVyUmlnaHRSb3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIHZhciBsZWZ0ID0gcGFyZW50LmxlZnQ7XHJcbiAgICAgICAgLy8gVXBkYXRlIG1heCBvZiBsZWZ0IHNpYmxpbmcgKHggaW4gZmlyc3QgY2FzZSwgeSBpbiBzZWNvbmQpXHJcbiAgICAgICAgdmFyIHRoaXNQYXJlbnRMZWZ0SGlnaCA9IGxlZnQuZ2V0Tm9kZUhpZ2goKTtcclxuICAgICAgICBpZiAobGVmdC5sZWZ0ID09PSB1bmRlZmluZWQgJiYgbGVmdC5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxlZnQubWF4ID0gTWF0aC5tYXgodGhpc1BhcmVudExlZnRIaWdoLCBsZWZ0LnJpZ2h0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxlZnQubGVmdCAhPT0gdW5kZWZpbmVkICYmIGxlZnQucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZWZ0Lm1heCA9IE1hdGgubWF4KHRoaXNQYXJlbnRMZWZ0SGlnaCwgbGVmdC5sZWZ0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxlZnQubGVmdCA9PT0gdW5kZWZpbmVkICYmIGxlZnQucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZWZ0Lm1heCA9IHRoaXNQYXJlbnRMZWZ0SGlnaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxlZnQubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgobGVmdC5sZWZ0Lm1heCwgbGVmdC5yaWdodC5tYXgpLCB0aGlzUGFyZW50TGVmdEhpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIGl0c2VsZiAoeilcclxuICAgICAgICB2YXIgdGhpc0hpZ2ggPSB0aGlzLmdldE5vZGVIaWdoKCk7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXNIaWdoLCB0aGlzLnJpZ2h0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXNIaWdoLCB0aGlzLmxlZnQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gdGhpc0hpZ2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KE1hdGgubWF4KHRoaXMubGVmdC5tYXgsIHRoaXMucmlnaHQubWF4KSwgdGhpc0hpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIHBhcmVudCAoeSBpbiBmaXJzdCBjYXNlLCB4IGluIHNlY29uZClcclxuICAgICAgICBwYXJlbnQubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgocGFyZW50LmxlZnQubWF4LCBwYXJlbnQucmlnaHQubWF4KSwgcGFyZW50LmdldE5vZGVIaWdoKCkpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBSaWdodC1SaWdodCBjYXNlOlxyXG4gIFxyXG4gICAgICB6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlcclxuICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICBcXFxyXG4gICAgVDEgIHkgICAgIExlZnQgUm90YXRlKHopICAgICAgIHogICAgIHhcclxuICAgICAgIC8gXFwgICAtIC0gLSAtIC0gLSAtIC0+ICAgICAvIFxcICAgLyBcXFxyXG4gICAgICBUMiAgeCAgICAgICAgICAgICAgICAgICAgICBUMSBUMiBUMyBUNFxyXG4gICAgICAgICAvIFxcXHJcbiAgICAgICAgVDMgVDRcclxuICBcclxuICAgIFJpZ2h0LUxlZnQgY2FzZTpcclxuICBcclxuICAgICAgIHogICAgICAgICAgICAgICAgICAgICAgICAgICAgeiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4XHJcbiAgICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAgLyAgIFxcXHJcbiAgICAgVDEgIHkgICBSaWdodCBSb3RhdGUgKHkpICAgICBUMSAgeCAgICAgIExlZnQgUm90YXRlKHopICAgeiAgICAgeVxyXG4gICAgICAgIC8gXFwgIC0gLSAtIC0gLSAtIC0gLSAtPiAgICAgIC8gXFwgICAtIC0gLSAtIC0gLSAtIC0+ICAvIFxcICAgLyBcXFxyXG4gICAgICAgeCAgVDQgICAgICAgICAgICAgICAgICAgICAgICBUMiAgeSAgICAgICAgICAgICAgICAgICBUMSBUMiBUMyBUNFxyXG4gICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyBcXFxyXG4gICAgVDIgICBUMyAgICAgICAgICAgICAgICAgICAgICAgICAgIFQzIFQ0XHJcbiAgICAqL1xyXG4gICAgLy8gSGFuZGxlcyBSaWdodC1SaWdodCBjYXNlIGFuZCBSaWdodC1MZWZ0IGNhc2UgaW4gcmViYWxhbmNpbmcgQVZMIHRyZWVcclxuICAgIE5vZGUucHJvdG90eXBlLl91cGRhdGVNYXhBZnRlckxlZnRSb3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIHZhciByaWdodCA9IHBhcmVudC5yaWdodDtcclxuICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIHJpZ2h0IHNpYmxpbmcgKHggaW4gZmlyc3QgY2FzZSwgeSBpbiBzZWNvbmQpXHJcbiAgICAgICAgdmFyIHRoaXNQYXJlbnRSaWdodEhpZ2ggPSByaWdodC5nZXROb2RlSGlnaCgpO1xyXG4gICAgICAgIGlmIChyaWdodC5sZWZ0ID09PSB1bmRlZmluZWQgJiYgcmlnaHQucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByaWdodC5tYXggPSBNYXRoLm1heCh0aGlzUGFyZW50UmlnaHRIaWdoLCByaWdodC5yaWdodC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyaWdodC5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgcmlnaHQucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByaWdodC5tYXggPSBNYXRoLm1heCh0aGlzUGFyZW50UmlnaHRIaWdoLCByaWdodC5sZWZ0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJpZ2h0LmxlZnQgPT09IHVuZGVmaW5lZCAmJiByaWdodC5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJpZ2h0Lm1heCA9IHRoaXNQYXJlbnRSaWdodEhpZ2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByaWdodC5tYXggPSBNYXRoLm1heChNYXRoLm1heChyaWdodC5sZWZ0Lm1heCwgcmlnaHQucmlnaHQubWF4KSwgdGhpc1BhcmVudFJpZ2h0SGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgaXRzZWxmICh6KVxyXG4gICAgICAgIHZhciB0aGlzSGlnaCA9IHRoaXMuZ2V0Tm9kZUhpZ2goKTtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpc0hpZ2gsIHRoaXMucmlnaHQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpc0hpZ2gsIHRoaXMubGVmdC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxlZnQgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSB0aGlzSGlnaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgodGhpcy5sZWZ0Lm1heCwgdGhpcy5yaWdodC5tYXgpLCB0aGlzSGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgcGFyZW50ICh5IGluIGZpcnN0IGNhc2UsIHggaW4gc2Vjb25kKVxyXG4gICAgICAgIHBhcmVudC5tYXggPSBNYXRoLm1heChNYXRoLm1heChwYXJlbnQubGVmdC5tYXgsIHJpZ2h0Lm1heCksIHBhcmVudC5nZXROb2RlSGlnaCgpKTtcclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5fbGVmdFJvdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmlnaHRDaGlsZCA9IHRoaXMucmlnaHQ7XHJcbiAgICAgICAgcmlnaHRDaGlsZC5wYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICBpZiAocmlnaHRDaGlsZC5wYXJlbnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmludGVydmFsVHJlZS5yb290ID0gcmlnaHRDaGlsZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChyaWdodENoaWxkLnBhcmVudC5sZWZ0ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICByaWdodENoaWxkLnBhcmVudC5sZWZ0ID0gcmlnaHRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChyaWdodENoaWxkLnBhcmVudC5yaWdodCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgcmlnaHRDaGlsZC5wYXJlbnQucmlnaHQgPSByaWdodENoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodENoaWxkLmxlZnQ7XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0LnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJpZ2h0Q2hpbGQubGVmdCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSByaWdodENoaWxkO1xyXG4gICAgICAgIHRoaXMudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICAgICAgcmlnaHRDaGlsZC51cGRhdGVIZWlnaHQoKTtcclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5fcmlnaHRSb3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxlZnRDaGlsZCA9IHRoaXMubGVmdDtcclxuICAgICAgICBsZWZ0Q2hpbGQucGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKGxlZnRDaGlsZC5wYXJlbnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmludGVydmFsVHJlZS5yb290ID0gbGVmdENoaWxkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGxlZnRDaGlsZC5wYXJlbnQubGVmdCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgbGVmdENoaWxkLnBhcmVudC5sZWZ0ID0gbGVmdENoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxlZnRDaGlsZC5wYXJlbnQucmlnaHQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIGxlZnRDaGlsZC5wYXJlbnQucmlnaHQgPSBsZWZ0Q2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdENoaWxkLnJpZ2h0O1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmxlZnQucGFyZW50ID0gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgbGVmdENoaWxkLnJpZ2h0ID0gdGhpcztcclxuICAgICAgICB0aGlzLnBhcmVudCA9IGxlZnRDaGlsZDtcclxuICAgICAgICB0aGlzLnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgICAgIGxlZnRDaGlsZC51cGRhdGVIZWlnaHQoKTtcclxuICAgIH07XHJcbiAgICAvLyBSZWJhbGFuY2VzIHRoZSB0cmVlIGlmIHRoZSBoZWlnaHQgdmFsdWUgYmV0d2VlbiB0d28gbm9kZXMgb2YgdGhlIHNhbWUgcGFyZW50IGlzIGdyZWF0ZXIgdGhhblxyXG4gICAgLy8gdHdvLiBUaGVyZSBhcmUgNCBjYXNlcyB0aGF0IGNhbiBoYXBwZW4gd2hpY2ggYXJlIG91dGxpbmVkIGluIHRoZSBncmFwaGljcyBhYm92ZVxyXG4gICAgTm9kZS5wcm90b3R5cGUuX3JlYmFsYW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoaGVpZ2h0KHRoaXMubGVmdCkgPj0gMiArIGhlaWdodCh0aGlzLnJpZ2h0KSkge1xyXG4gICAgICAgICAgICB2YXIgbGVmdCA9IHRoaXMubGVmdDtcclxuICAgICAgICAgICAgaWYgKGhlaWdodChsZWZ0LmxlZnQpID49IGhlaWdodChsZWZ0LnJpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTGVmdC1MZWZ0IGNhc2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JpZ2h0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVNYXhBZnRlclJpZ2h0Um90YXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBMZWZ0LVJpZ2h0IGNhc2VcclxuICAgICAgICAgICAgICAgIGxlZnQuX2xlZnRSb3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JpZ2h0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVNYXhBZnRlclJpZ2h0Um90YXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGVpZ2h0KHRoaXMucmlnaHQpID49IDIgKyBoZWlnaHQodGhpcy5sZWZ0KSkge1xyXG4gICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnJpZ2h0O1xyXG4gICAgICAgICAgICBpZiAoaGVpZ2h0KHJpZ2h0LnJpZ2h0KSA+PSBoZWlnaHQocmlnaHQubGVmdCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJpZ2h0LVJpZ2h0IGNhc2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlZnRSb3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZU1heEFmdGVyTGVmdFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gUmlnaHQtTGVmdCBjYXNlXHJcbiAgICAgICAgICAgICAgICByaWdodC5fcmlnaHRSb3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlZnRSb3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZU1heEFmdGVyTGVmdFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE5vZGUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICBpZiAocmVjb3JkLmxvdyA8IHRoaXMua2V5KSB7XHJcbiAgICAgICAgICAgIC8vIEluc2VydCBpbnRvIGxlZnQgc3VidHJlZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVmdCA9IG5ldyBOb2RlKHRoaXMuaW50ZXJ2YWxUcmVlLCByZWNvcmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0LnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQuaW5zZXJ0KHJlY29yZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEluc2VydCBpbnRvIHJpZ2h0IHN1YnRyZWVcclxuICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodCA9IG5ldyBOb2RlKHRoaXMuaW50ZXJ2YWxUcmVlLCByZWNvcmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5pbnNlcnQocmVjb3JkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgdGhlIG1heCB2YWx1ZSBvZiB0aGlzIGFuY2VzdG9yIGlmIG5lZWRlZFxyXG4gICAgICAgIGlmICh0aGlzLm1heCA8IHJlY29yZC5oaWdoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gcmVjb3JkLmhpZ2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBoZWlnaHQgb2YgZWFjaCBub2RlXHJcbiAgICAgICAgdGhpcy51cGRhdGVIZWlnaHQoKTtcclxuICAgICAgICAvLyBSZWJhbGFuY2UgdGhlIHRyZWUgdG8gZW5zdXJlIGFsbCBvcGVyYXRpb25zIGFyZSBleGVjdXRlZCBpbiBPKGxvZ24pIHRpbWUuIFRoaXMgaXMgZXNwZWNpYWxseVxyXG4gICAgICAgIC8vIGltcG9ydGFudCBpbiBzZWFyY2hpbmcsIGFzIHRoZSB0cmVlIGhhcyBhIGhpZ2ggY2hhbmNlIG9mIGRlZ2VuZXJhdGluZyB3aXRob3V0IHRoZSByZWJhbGFuY2luZ1xyXG4gICAgICAgIHRoaXMuX3JlYmFsYW5jZSgpO1xyXG4gICAgfTtcclxuICAgIE5vZGUucHJvdG90eXBlLl9nZXRPdmVybGFwcGluZ1JlY29yZHMgPSBmdW5jdGlvbiAoY3VycmVudE5vZGUsIGxvdywgaGlnaCkge1xyXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZS5rZXkgPD0gaGlnaCAmJiBsb3cgPD0gY3VycmVudE5vZGUuZ2V0Tm9kZUhpZ2goKSkge1xyXG4gICAgICAgICAgICAvLyBOb2RlcyBhcmUgb3ZlcmxhcHBpbmcsIGNoZWNrIGlmIGluZGl2aWR1YWwgcmVjb3JkcyBpbiB0aGUgbm9kZSBhcmUgb3ZlcmxhcHBpbmdcclxuICAgICAgICAgICAgdmFyIHRlbXBSZXN1bHRzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VycmVudE5vZGUucmVjb3Jkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLnJlY29yZHNbaV0uaGlnaCA+PSBsb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wUmVzdWx0cy5wdXNoKGN1cnJlbnROb2RlLnJlY29yZHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0ZW1wUmVzdWx0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuICAgIE5vZGUucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChsb3csIGhpZ2gpIHtcclxuICAgICAgICAvLyBEb24ndCBzZWFyY2ggbm9kZXMgdGhhdCBkb24ndCBleGlzdFxyXG4gICAgICAgIGlmICh0aGlzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGVmdFNlYXJjaCA9IFtdO1xyXG4gICAgICAgIHZhciBvd25TZWFyY2ggPSBbXTtcclxuICAgICAgICB2YXIgcmlnaHRTZWFyY2ggPSBbXTtcclxuICAgICAgICAvLyBJZiBpbnRlcnZhbCBpcyB0byB0aGUgcmlnaHQgb2YgdGhlIHJpZ2h0bW9zdCBwb2ludCBvZiBhbnkgaW50ZXJ2YWwgaW4gdGhpcyBub2RlIGFuZCBhbGwgaXRzXHJcbiAgICAgICAgLy8gY2hpbGRyZW4sIHRoZXJlIHdvbid0IGJlIGFueSBtYXRjaGVzXHJcbiAgICAgICAgaWYgKGxvdyA+IHRoaXMubWF4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2VhcmNoIGxlZnQgY2hpbGRyZW5cclxuICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5sZWZ0Lm1heCA+PSBsb3cpIHtcclxuICAgICAgICAgICAgbGVmdFNlYXJjaCA9IHRoaXMubGVmdC5zZWFyY2gobG93LCBoaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgdGhpcyBub2RlXHJcbiAgICAgICAgb3duU2VhcmNoID0gdGhpcy5fZ2V0T3ZlcmxhcHBpbmdSZWNvcmRzKHRoaXMsIGxvdywgaGlnaCk7XHJcbiAgICAgICAgLy8gSWYgaW50ZXJ2YWwgaXMgdG8gdGhlIGxlZnQgb2YgdGhlIHN0YXJ0IG9mIHRoaXMgaW50ZXJ2YWwsIHRoZW4gaXQgY2FuJ3QgYmUgaW4gYW55IGNoaWxkIHRvXHJcbiAgICAgICAgLy8gdGhlIHJpZ2h0XHJcbiAgICAgICAgaWYgKGhpZ2ggPCB0aGlzLmtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbGVmdFNlYXJjaC5jb25jYXQob3duU2VhcmNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzZWFyY2ggcmlnaHQgY2hpbGRyZW5cclxuICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJpZ2h0U2VhcmNoID0gdGhpcy5yaWdodC5zZWFyY2gobG93LCBoaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmV0dXJuIGFjY3VtdWxhdGVkIHJlc3VsdHMsIGlmIGFueVxyXG4gICAgICAgIHJldHVybiBsZWZ0U2VhcmNoLmNvbmNhdChvd25TZWFyY2gsIHJpZ2h0U2VhcmNoKTtcclxuICAgIH07XHJcbiAgICAvLyBTZWFyY2hlcyBmb3IgYSBub2RlIGJ5IGEgYGtleWAgdmFsdWVcclxuICAgIE5vZGUucHJvdG90eXBlLnNlYXJjaEV4aXN0aW5nID0gZnVuY3Rpb24gKGxvdykge1xyXG4gICAgICAgIGlmICh0aGlzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMua2V5ID09PSBsb3cpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxvdyA8IHRoaXMua2V5KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5zZWFyY2hFeGlzdGluZyhsb3cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5zZWFyY2hFeGlzdGluZyhsb3cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyB0aGUgc21hbGxlc3Qgbm9kZSBvZiB0aGUgc3VidHJlZVxyXG4gICAgTm9kZS5wcm90b3R5cGUuX21pblZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuX21pblZhbHVlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE5vZGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIGlmIChub2RlLmtleSA8IHRoaXMua2V5KSB7XHJcbiAgICAgICAgICAgIC8vIE5vZGUgdG8gYmUgcmVtb3ZlZCBpcyBvbiB0aGUgbGVmdCBzaWRlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5vZGUua2V5ID4gdGhpcy5rZXkpIHtcclxuICAgICAgICAgICAgLy8gTm9kZSB0byBiZSByZW1vdmVkIGlzIG9uIHRoZSByaWdodCBzaWRlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0LnJlbW92ZShub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vZGUgaGFzIHR3byBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgdmFyIG1pblZhbHVlID0gdGhpcy5yaWdodC5fbWluVmFsdWUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMua2V5ID0gbWluVmFsdWUua2V5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvcmRzID0gbWluVmFsdWUucmVjb3JkcztcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0LnJlbW92ZSh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXJlbnQubGVmdCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgLy8gT25lIGNoaWxkIG9yIG5vIGNoaWxkIGNhc2Ugb24gbGVmdCBzaWRlXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSB0aGlzLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmlnaHQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSB0aGlzLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdC5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFyZW50LnVwZGF0ZU1heE9mUGFyZW50cygpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Ll9yZWJhbGFuY2UoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudC5yaWdodCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgLy8gT25lIGNoaWxkIG9yIG5vIGNoaWxkIGNhc2Ugb24gcmlnaHQgc2lkZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5yaWdodCA9IHRoaXMucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodC5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSB0aGlzLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdC5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFyZW50LnVwZGF0ZU1heE9mUGFyZW50cygpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Ll9yZWJhbGFuY2UoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBOb2RlO1xyXG59KCkpO1xyXG5leHBvcnRzLk5vZGUgPSBOb2RlO1xyXG52YXIgSW50ZXJ2YWxUcmVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSW50ZXJ2YWxUcmVlKCkge1xyXG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xyXG4gICAgfVxyXG4gICAgSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAocmVjb3JkKSB7XHJcbiAgICAgICAgaWYgKHJlY29yZC5sb3cgPiByZWNvcmQuaGlnaCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bsb3dgIHZhbHVlIG11c3QgYmUgbG93ZXIgb3IgZXF1YWwgdG8gYGhpZ2hgIHZhbHVlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnJvb3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBCYXNlIGNhc2U6IFRyZWUgaXMgZW1wdHksIG5ldyBub2RlIGJlY29tZXMgcm9vdFxyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBuZXcgTm9kZSh0aGlzLCByZWNvcmQpO1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50Kys7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjaGVjayBpZiBub2RlIGFscmVhZHkgZXhpc3RzIHdpdGggdGhlIHNhbWUga2V5XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5yb290LnNlYXJjaEV4aXN0aW5nKHJlY29yZC5sb3cpO1xyXG4gICAgICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgcmVjb3JkcyBpbiB0aGlzIG5vZGUgaWYgdGhlcmUgYWxyZWFkeSBpcyB0aGUgb25lIHdpdGggc2FtZSBsb3csIGhpZ2gsIGRhdGFcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5yZWNvcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2FtZShub2RlLnJlY29yZHNbaV0sIHJlY29yZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyByZWNvcmQgaXMgc2FtZSBhcyB0aGUgb25lIHdlJ3JlIHRyeWluZyB0byBpbnNlcnQ7IHJldHVybiBmYWxzZSB0byBpbmRpY2F0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RoaW5nIGhhcyBiZWVuIGluc2VydGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHJlY29yZCB0byB0aGUgbm9kZVxyXG4gICAgICAgICAgICAgICAgbm9kZS5yZWNvcmRzLnB1c2gocmVjb3JkKTtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgdGhlIG5vZGUgYW5kIGl0cyBwYXJlbnRzIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC5oaWdoID4gbm9kZS5tYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLm1heCA9IHJlY29yZC5oaWdoO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudC51cGRhdGVNYXhPZlBhcmVudHMoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vZGUgd2l0aCB0aGlzIGtleSBkb2Vzbid0IGFscmVhZHkgZXhpc3QuIENhbGwgaW5zZXJ0IGZ1bmN0aW9uIG9uIHJvb3QncyBub2RlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QuaW5zZXJ0KHJlY29yZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbnRlcnZhbFRyZWUucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChsb3csIGhpZ2gpIHtcclxuICAgICAgICBpZiAodGhpcy5yb290ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gVHJlZSBpcyBlbXB0eTsgcmV0dXJuIGVtcHR5IGFycmF5XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3Quc2VhcmNoKGxvdywgaGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEludGVydmFsVHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJvb3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBUcmVlIGlzIGVtcHR5OyBub3RoaW5nIHRvIHJlbW92ZVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMucm9vdC5zZWFyY2hFeGlzdGluZyhyZWNvcmQubG93KTtcclxuICAgICAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUucmVjb3Jkcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZFJlY29yZCA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIC8vIE5vZGUgd2l0aCB0aGlzIGtleSBoYXMgMiBvciBtb3JlIHJlY29yZHMuIEZpbmQgdGhlIG9uZSB3ZSBuZWVkIGFuZCByZW1vdmUgaXRcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5yZWNvcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2FtZShub2RlLnJlY29yZHNbaV0sIHJlY29yZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFJlY29yZCA9IG5vZGUucmVjb3Jkc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZWNvcmRzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWRSZWNvcmQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkUmVjb3JkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgdGhhdCBub2RlIGFuZCBpdHMgcGFyZW50cyBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmhpZ2ggPT09IG5vZGUubWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlSGlnaCA9IG5vZGUuZ2V0Tm9kZUhpZ2goKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVmdCAhPT0gdW5kZWZpbmVkICYmIG5vZGUucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXggPSBNYXRoLm1heChNYXRoLm1heChub2RlLmxlZnQubWF4LCBub2RlLnJpZ2h0Lm1heCksIG5vZGVIaWdoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLmxlZnQgIT09IHVuZGVmaW5lZCAmJiBub2RlLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubWF4ID0gTWF0aC5tYXgobm9kZS5sZWZ0Lm1heCwgbm9kZUhpZ2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubGVmdCA9PT0gdW5kZWZpbmVkICYmIG5vZGUucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXggPSBNYXRoLm1heChub2RlLnJpZ2h0Lm1heCwgbm9kZUhpZ2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXggPSBub2RlSGlnaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LnVwZGF0ZU1heE9mUGFyZW50cygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnQtLTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLnJlY29yZHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb2RlIHdpdGggdGhpcyBrZXkgaGFzIG9ubHkgMSByZWNvcmQuIENoZWNrIGlmIHRoZSByZW1haW5pbmcgcmVjb3JkIGluIHRoaXMgbm9kZSBpc1xyXG4gICAgICAgICAgICAgICAgLy8gYWN0dWFsbHkgdGhlIG9uZSB3ZSB3YW50IHRvIHJlbW92ZVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzU2FtZShub2RlLnJlY29yZHNbMF0sIHJlY29yZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIHJlY29yZCBpcyB0aGUgb25lIHdlIHdhbnQgdG8gcmVtb3ZlLiBSZW1vdmUgdGhlIHdob2xlIG5vZGUgZnJvbSB0aGUgdHJlZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJvb3Qua2V5ID09PSBub2RlLmtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSdyZSByZW1vdmluZyB0aGUgcm9vdCBlbGVtZW50LiBDcmVhdGUgYSBkdW1teSBub2RlIHRoYXQgd2lsbCB0ZW1wb3JhcmlseSB0YWtlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJvb3QncyBwYXJlbnQgcm9sZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdFBhcmVudCA9IG5ldyBOb2RlKHRoaXMsIHsgbG93OiByZWNvcmQubG93LCBoaWdoOiByZWNvcmQubG93IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb290UGFyZW50LmxlZnQgPSB0aGlzLnJvb3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdC5wYXJlbnQgPSByb290UGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZE5vZGUgPSB0aGlzLnJvb3QucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSByb290UGFyZW50LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJvb3QgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290LnBhcmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWROb2RlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVkTm9kZSA9IHRoaXMucm9vdC5yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZE5vZGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50LS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgcmVjb3JkIGlzIG5vdCB0aGUgb25lIHdlIHdhbnQgdG8gcmVtb3ZlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm8gcmVjb3JkcyBhdCBhbGwgaW4gdGhpcyBub2RlPyEgU2hvdWxkbid0IGhhcHBlblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEludGVydmFsVHJlZS5wcm90b3R5cGUuaW5PcmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEluT3JkZXIodGhpcy5yb290KTtcclxuICAgIH07XHJcbiAgICBJbnRlcnZhbFRyZWUucHJvdG90eXBlLnByZU9yZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlT3JkZXIodGhpcy5yb290KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSW50ZXJ2YWxUcmVlO1xyXG59KCkpO1xyXG5leHBvcnRzLkludGVydmFsVHJlZSA9IEludGVydmFsVHJlZTtcclxudmFyIERhdGFJbnRlcnZhbFRyZWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEYXRhSW50ZXJ2YWxUcmVlKCkge1xyXG4gICAgICAgIHRoaXMudHJlZSA9IG5ldyBJbnRlcnZhbFRyZWUoKTtcclxuICAgIH1cclxuICAgIERhdGFJbnRlcnZhbFRyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChsb3csIGhpZ2gsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLmluc2VydCh7IGxvdzogbG93LCBoaWdoOiBoaWdoLCBkYXRhOiBkYXRhIH0pO1xyXG4gICAgfTtcclxuICAgIERhdGFJbnRlcnZhbFRyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChsb3csIGhpZ2gsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLnJlbW92ZSh7IGxvdzogbG93LCBoaWdoOiBoaWdoLCBkYXRhOiBkYXRhIH0pO1xyXG4gICAgfTtcclxuICAgIERhdGFJbnRlcnZhbFRyZWUucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChsb3csIGhpZ2gpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLnNlYXJjaChsb3csIGhpZ2gpLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdi5kYXRhOyB9KTtcclxuICAgIH07XHJcbiAgICBEYXRhSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5pbk9yZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyZWUuaW5PcmRlcigpO1xyXG4gICAgfTtcclxuICAgIERhdGFJbnRlcnZhbFRyZWUucHJvdG90eXBlLnByZU9yZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyZWUucHJlT3JkZXIoKTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YUludGVydmFsVHJlZS5wcm90b3R5cGUsIFwiY291bnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlLmNvdW50O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIERhdGFJbnRlcnZhbFRyZWU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERhdGFJbnRlcnZhbFRyZWU7XHJcbnZhciBJbk9yZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSW5PcmRlcihzdGFydE5vZGUpIHtcclxuICAgICAgICB0aGlzLnN0YWNrID0gW107XHJcbiAgICAgICAgaWYgKHN0YXJ0Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaChzdGFydE5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEluT3JkZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gV2lsbCBvbmx5IGhhcHBlbiBpZiBzdGFjayBpcyBlbXB0eSBhbmQgcG9wIGlzIGNhbGxlZFxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnROb2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRvbmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQcm9jZXNzIHRoaXMgbm9kZVxyXG4gICAgICAgIGlmICh0aGlzLmkgPCB0aGlzLmN1cnJlbnROb2RlLnJlY29yZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmN1cnJlbnROb2RlLnJlY29yZHNbdGhpcy5pKytdLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZS5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLmN1cnJlbnROb2RlLnJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE1pZ2h0IHBvcCB0aGUgbGFzdCBhbmQgc2V0IHRoaXMuY3VycmVudE5vZGUgPSB1bmRlZmluZWRcclxuICAgICAgICAgICAgdGhpcy5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCgpO1xyXG4gICAgfTtcclxuICAgIEluT3JkZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBub2RlO1xyXG4gICAgICAgIHRoaXMuaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuY3VycmVudE5vZGUubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmN1cnJlbnROb2RlKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IHRoaXMuY3VycmVudE5vZGUubGVmdDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW5PcmRlci5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSB0aGlzLnN0YWNrLnBvcCgpO1xyXG4gICAgICAgIHRoaXMuaSA9IDA7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEluT3JkZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuSW5PcmRlciA9IEluT3JkZXI7XHJcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBJbk9yZGVyLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcclxufVxyXG52YXIgUHJlT3JkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQcmVPcmRlcihzdGFydE5vZGUpIHtcclxuICAgICAgICB0aGlzLnN0YWNrID0gW107XHJcbiAgICAgICAgdGhpcy5pID0gMDtcclxuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gc3RhcnROb2RlO1xyXG4gICAgfVxyXG4gICAgUHJlT3JkZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gV2lsbCBvbmx5IGhhcHBlbiBpZiBzdGFjayBpcyBlbXB0eSBhbmQgcG9wIGlzIGNhbGxlZCxcclxuICAgICAgICAvLyB3aGljaCBvbmx5IGhhcHBlbnMgaWYgdGhlcmUgaXMgbm8gcmlnaHQgbm9kZSAoaS5lIHdlIGFyZSBkb25lKVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnROb2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRvbmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQcm9jZXNzIHRoaXMgbm9kZVxyXG4gICAgICAgIGlmICh0aGlzLmkgPCB0aGlzLmN1cnJlbnROb2RlLnJlY29yZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmN1cnJlbnROb2RlLnJlY29yZHNbdGhpcy5pKytdLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZS5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLmN1cnJlbnROb2RlLnJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLmN1cnJlbnROb2RlLmxlZnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBvcCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5leHQoKTtcclxuICAgIH07XHJcbiAgICBQcmVPcmRlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKG5vZGUpO1xyXG4gICAgfTtcclxuICAgIFByZU9yZGVyLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IHRoaXMuc3RhY2sucG9wKCk7XHJcbiAgICAgICAgdGhpcy5pID0gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUHJlT3JkZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuUHJlT3JkZXIgPSBQcmVPcmRlcjtcclxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIFByZU9yZGVyLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCdcblxuY29uc3Qgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJylcblxuLyoqXG4gKiBOb0ZpbHRlciBzdHJlYW0uICBDYW4gYmUgdXNlZCB0byBzaW5rIG9yIHNvdXJjZSBkYXRhIHRvIGFuZCBmcm9tXG4gKiBvdGhlciBub2RlIHN0cmVhbXMuICBJbXBsZW1lbnRlZCBhcyB0aGUgXCJpZGVudGl0eVwiIFRyYW5zZm9ybSBzdHJlYW1cbiAqIChoZW5jZSB0aGUgbmFtZSksIGJ1dCBhbGxvd3MgZm9yIGluc3BlY3RpbmcgZGF0YSB0aGF0IGlzIGluLWZsaWdodC5cbiAqXG4gKiBBbGxvd3MgcGFzc2luZyBpbiBzb3VyY2UgZGF0YSAoaW5wdXQsIGlucHV0RW5jb2RpbmcpIGF0IGNyZWF0aW9uXG4gKiB0aW1lLiAgU291cmNlIGRhdGEgY2FuIGFsc28gYmUgcGFzc2VkIGluIHRoZSBvcHRpb25zIG9iamVjdC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5zb3VyY2U8L2NhcHRpb24+XG4gKiBjb25zdCBuID0gbmV3IE5vRmlsdGVyKCdabTl2JywgJ2Jhc2U2NCcpO1xuICogbi5waXBlKHByb2Nlc3Muc3Rkb3V0KTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5zaW5rPC9jYXB0aW9uPlxuICogY29uc3QgbiA9IG5ldyBOb2ZpbHRlcigpO1xuICogLy8gTk9URTogJ2ZpbmlzaCcgZmlyZXMgd2hlbiB0aGUgaW5wdXQgaXMgZG9uZSB3cml0aW5nXG4gKiBuLm9uKCdmaW5pc2gnLCBmdW5jdGlvbigpIHsgY29uc29sZS5sb2cobi50b1N0cmluZygnYmFzZTY0JykpOyB9KTtcbiAqIHByb2Nlc3Muc3RkaW4ucGlwZShuKTtcbiAqL1xuY2xhc3MgTm9GaWx0ZXIgZXh0ZW5kcyBzdHJlYW0uVHJhbnNmb3JtIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBOb0ZpbHRlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBbaW5wdXRdIC0gU291cmNlIGRhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtpbnB1dEVuY29kaW5nPW51bGxdIC0gRW5jb2RpbmcgbmFtZSBmb3IgaW5wdXQsXG4gICAqICAgaWdub3JlZCBpZiBpbnB1dCBpcyBub3QgYSBTdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIE90aGVyIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBbb3B0aW9ucy5pbnB1dD1udWxsXSAtIElucHV0IHNvdXJjZSBkYXRhXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pbnB1dEVuY29kaW5nPW51bGxdIC0gRW5jb2RpbmcgbmFtZSBmb3IgaW5wdXQsXG4gICAqICAgaWdub3JlZCBpZiBpbnB1dCBpcyBub3QgYSBTdHJpbmdcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhpZ2hXYXRlck1hcms9MTYzODRdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGJ5dGVzXG4gICAqICAgdG8gc3RvcmUgaW4gdGhlIGludGVybmFsIGJ1ZmZlciBiZWZvcmUgY2Vhc2luZyB0byByZWFkIGZyb20gdGhlXG4gICAqICAgdW5kZXJseWluZyByZXNvdXJjZS4gRGVmYXVsdD0xNmtiLCBvciAxNiBmb3Igb2JqZWN0TW9kZSBzdHJlYW1zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz1udWxsXSAtIElmIHNwZWNpZmllZCwgdGhlbiBidWZmZXJzIHdpbGxcbiAgICogICBiZSBkZWNvZGVkIHRvIHN0cmluZ3MgdXNpbmcgdGhlIHNwZWNpZmllZCBlbmNvZGluZ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm9iamVjdE1vZGU9ZmFsc2VdIC0gV2hldGhlciB0aGlzIHN0cmVhbSBzaG91bGRcbiAgICogICBiZWhhdmUgYXMgYSBzdHJlYW0gb2Ygb2JqZWN0cy4gTWVhbmluZyB0aGF0IHN0cmVhbS5yZWFkKG4pIHJldHVybnMgYVxuICAgKiAgIHNpbmdsZSB2YWx1ZSBpbnN0ZWFkIG9mIGEgQnVmZmVyIG9mIHNpemUgblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlY29kZVN0cmluZ3M9dHJ1ZV0gLSBXaGV0aGVyIG9yIG5vdCB0byBkZWNvZGVcbiAgICogICBzdHJpbmdzIGludG8gQnVmZmVycyBiZWZvcmUgcGFzc2luZyB0aGVtIHRvIF93cml0ZSgpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMud2F0Y2hQaXBlPXRydWVdIC0gV2hldGhlciB0byB3YXRjaCBmb3IgJ3BpcGUnXG4gICAqICAgZXZlbnRzLCBzZXR0aW5nIHRoaXMgc3RyZWFtJ3Mgb2JqZWN0TW9kZSBiYXNlZCBvbiB0aGUgb2JqZWN0TW9kZSBvZiB0aGVcbiAgICogICBpbnB1dCBzdHJlYW1cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZWFkRXJyb3I9ZmFsc2VdIC0gSWYgdHJ1ZSwgd2hlbiBhIHJlYWQoKVxuICAgKiAgIHVuZGVyZmxvd3MsIHRocm93IGFuIGVycm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3IoaW5wdXQsIGlucHV0RW5jb2RpbmcsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG4gICAgbGV0IGlucFxuICAgIGxldCBpbnBFXG4gICAgc3dpdGNoICh0eXBlb2YoaW5wdXQpKSB7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGlucHV0KSkge1xuICAgICAgICAgIGlucCA9IGlucHV0XG4gICAgICAgICAgaWYgKChpbnB1dEVuY29kaW5nICE9IG51bGwpICYmICh0eXBlb2YoaW5wdXRFbmNvZGluZykgPT09ICdvYmplY3QnKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGlucHV0RW5jb2RpbmdcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGlucHV0XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGlucCA9IGlucHV0XG4gICAgICAgIGlmICgoaW5wdXRFbmNvZGluZyAhPSBudWxsKSAmJiAodHlwZW9mKGlucHV0RW5jb2RpbmcpID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICBvcHRpb25zID0gaW5wdXRFbmNvZGluZ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlucEUgPSBpbnB1dEVuY29kaW5nXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBpZiAoKG9wdGlvbnMgPT0gbnVsbCkpIHtcbiAgICAgIG9wdGlvbnMgPSB7fVxuICAgIH1cbiAgICBpZiAoaW5wID09IG51bGwpIHtcbiAgICAgIGlucCA9IG9wdGlvbnMuaW5wdXRcbiAgICB9XG4gICAgaWYgKGlucEUgPT0gbnVsbCkge1xuICAgICAgaW5wRSA9IG9wdGlvbnMuaW5wdXRFbmNvZGluZ1xuICAgIH1cbiAgICBkZWxldGUgb3B0aW9ucy5pbnB1dFxuICAgIGRlbGV0ZSBvcHRpb25zLmlucHV0RW5jb2RpbmdcbiAgICBjb25zdCB3YXRjaFBpcGUgPSBvcHRpb25zLndhdGNoUGlwZSAhPSBudWxsID8gb3B0aW9ucy53YXRjaFBpcGUgOiB0cnVlXG4gICAgZGVsZXRlIG9wdGlvbnMud2F0Y2hQaXBlXG4gICAgY29uc3QgcmVhZEVycm9yID0gISEgb3B0aW9ucy5yZWFkRXJyb3JcbiAgICBkZWxldGUgb3B0aW9ucy5yZWFkRXJyb3JcbiAgICBzdXBlcihvcHRpb25zKVxuXG4gICAgdGhpcy5yZWFkRXJyb3IgPSByZWFkRXJyb3JcblxuICAgIGlmICh3YXRjaFBpcGUpIHtcbiAgICAgIHRoaXMub24oJ3BpcGUnLCByZWFkYWJsZSA9PiB7XG4gICAgICAgIGNvbnN0IG9tID0gcmVhZGFibGUuX3JlYWRhYmxlU3RhdGUub2JqZWN0TW9kZVxuICAgICAgICBpZiAoKHRoaXMubGVuZ3RoID4gMCkgJiYgKG9tICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLm9iamVjdE1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0RvIG5vdCBzd2l0Y2ggb2JqZWN0TW9kZSBpbiB0aGUgbWlkZGxlIG9mIHRoZSBzdHJlYW0nKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlID0gb21cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUub2JqZWN0TW9kZSA9IG9tXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChpbnAgIT0gbnVsbCkge1xuICAgICAgdGhpcy5lbmQoaW5wLCBpbnBFKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJcyB0aGUgZ2l2ZW4gb2JqZWN0IGEge05vRmlsdGVyfT9cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIG9iaiBpcyBhIE5vRmlsdGVyXG4gICAqL1xuICBzdGF0aWMgaXNOb0ZpbHRlcihvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzYW1lIGFzIG5mMS5jb21wYXJlKG5mMikuIFVzZWZ1bCBmb3Igc29ydGluZyBhbiBBcnJheSBvZiBOb0ZpbHRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9GaWx0ZXJ9IG5mMSAtIFRoZSBmaXJzdCBvYmplY3QgdG8gY29tcGFyZVxuICAgKiBAcGFyYW0ge05vRmlsdGVyfSBuZjIgLSBUaGUgc2Vjb25kIG9iamVjdCB0byBjb21wYXJlXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IC0xLCAwLCAxIGZvciBsZXNzLCBlcXVhbCwgZ3JlYXRlclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBhcnIgPSBbbmV3IE5vRmlsdGVyKCcxMjM0JyksIG5ldyBOb0ZpbHRlcignMDEyMycpXTtcbiAgICogYXJyLnNvcnQoTm9GaWx0ZXIuY29tcGFyZSk7XG4gICAqL1xuICBzdGF0aWMgY29tcGFyZShuZjEsIG5mMikge1xuICAgIGlmICghKG5mMSBpbnN0YW5jZW9mIHRoaXMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBOb0ZpbHRlcnMnKVxuICAgIH1cbiAgICBpZiAobmYxID09PSBuZjIpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZjEuY29tcGFyZShuZjIpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBidWZmZXIgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBjb25jYXRlbmF0aW5nIGFsbCB0aGVcbiAgICogTm9GaWx0ZXJzIGluIHRoZSBsaXN0IHRvZ2V0aGVyLiBJZiB0aGUgbGlzdCBoYXMgbm8gaXRlbXMsIG9yIGlmXG4gICAqIHRoZSB0b3RhbExlbmd0aCBpcyAwLCB0aGVuIGl0IHJldHVybnMgYSB6ZXJvLWxlbmd0aCBidWZmZXIuXG4gICAqXG4gICAqIElmIGxlbmd0aCBpcyBub3QgcHJvdmlkZWQsIGl0IGlzIHJlYWQgZnJvbSB0aGUgYnVmZmVycyBpbiB0aGVcbiAgICogbGlzdC4gSG93ZXZlciwgdGhpcyBhZGRzIGFuIGFkZGl0aW9uYWwgbG9vcCB0byB0aGUgZnVuY3Rpb24sIHNvXG4gICAqIGl0IGlzIGZhc3RlciB0byBwcm92aWRlIHRoZSBsZW5ndGggZXhwbGljaXRseSBpZiB5b3UgYWxyZWFkeSBrbm93IGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PE5vRmlsdGVyPn0gbGlzdCBJbnB1dHMuICBNdXN0IG5vdCBiZSBhbGwgZWl0aGVyIGluIG9iamVjdFxuICAgKiAgIG1vZGUsIG9yIGFsbCBub3QgaW4gb2JqZWN0IG1vZGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPW51bGxdIE51bWJlciBvZiBieXRlcyBvciBvYmplY3RzIHRvIHJlYWRcbiAgICogQHJldHVybnMge0J1ZmZlcnxBcnJheX0gVGhlIGNvbmNhdGVuYXRlZCB2YWx1ZXMgYXMgYW4gYXJyYXkgaWYgaW4gb2JqZWN0XG4gICAqICAgbW9kZSwgb3RoZXJ3aXNlIGEgQnVmZmVyXG4gICAqL1xuICBzdGF0aWMgY29uY2F0KGxpc3QsIGxlbmd0aCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGlzdCBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIE5vRmlsdGVycycpXG4gICAgfVxuICAgIGlmICgobGlzdC5sZW5ndGggPT09IDApIHx8IChsZW5ndGggPT09IDApKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gICAgfVxuICAgIGlmICgobGVuZ3RoID09IG51bGwpKSB7XG4gICAgICBsZW5ndGggPSBsaXN0LnJlZHVjZSgodG90LCBuZikgPT4ge1xuICAgICAgICBpZiAoIShuZiBpbnN0YW5jZW9mIE5vRmlsdGVyKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBOb0ZpbHRlcnMnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3QgKyBuZi5sZW5ndGhcbiAgICAgIH0sIDApXG4gICAgfVxuICAgIGxldCBhbGxCdWZzID0gdHJ1ZVxuICAgIGxldCBhbGxPYmpzID0gdHJ1ZVxuICAgIGNvbnN0IGJ1ZnMgPSBsaXN0Lm1hcChuZiA9PiB7XG4gICAgICBpZiAoIShuZiBpbnN0YW5jZW9mIE5vRmlsdGVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0IGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgTm9GaWx0ZXJzJylcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJ1ZiA9IG5mLnNsaWNlKClcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgICBhbGxPYmpzID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbEJ1ZnMgPSBmYWxzZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH0pXG4gICAgaWYgKGFsbEJ1ZnMpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KGJ1ZnMsIGxlbmd0aClcbiAgICB9XG4gICAgaWYgKGFsbE9ianMpIHtcbiAgICAgIHJldHVybiBbXS5jb25jYXQoLi4uYnVmcykuc2xpY2UoMCwgbGVuZ3RoKVxuICAgIH1cbiAgICAvLyBUT0RPOiBtYXliZSBjb2FsZXNjZSBidWZmZXJzLCBjb3VudGluZyBieXRlcywgYW5kIGZsYXR0ZW4gaW4gYXJyYXlzXG4gICAgLy8gY291bnRpbmcgb2JqZWN0cz8gIEkgY2FuJ3QgaW1hZ2luZSB3aHkgdGhhdCB3b3VsZCBiZSB1c2VmdWwuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb25jYXRlbmF0aW5nIG1peGVkIG9iamVjdCBhbmQgYnl0ZSBzdHJlYW1zIG5vdCBzdXBwb3J0ZWQnKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUub2JqZWN0TW9kZSAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpXG4gICAgfVxuICAgIHRoaXMucHVzaChjaHVuaylcbiAgICBjYWxsYmFjaygpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9idWZBcnJheSgpIHtcbiAgICBsZXQgYnVmcyA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyXG4gICAgLy8gSEFDSzogcmVwbGFjZSB3aXRoIHNvbWV0aGluZyBlbHNlIG9uZSBkYXkuICBUaGlzIGlzIHdoYXQgSSBnZXQgZm9yXG4gICAgLy8gcmVseWluZyBvbiBpbnRlcm5hbHMuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGJ1ZnMpKSB7XG4gICAgICBsZXQgYiA9IGJ1ZnMuaGVhZFxuICAgICAgYnVmcyA9IFtdXG4gICAgICB3aGlsZSAoYiAhPSBudWxsKSB7XG4gICAgICAgIGJ1ZnMucHVzaChiLmRhdGEpXG4gICAgICAgIGIgPSBiLm5leHRcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ1ZnNcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWxscyBzb21lIGRhdGEgb3V0IG9mIHRoZSBpbnRlcm5hbCBidWZmZXIgYW5kIHJldHVybnMgaXQuXG4gICAqIElmIHRoZXJlIGlzIG5vIGRhdGEgYXZhaWxhYmxlLCB0aGVuIGl0IHdpbGwgcmV0dXJuIG51bGwuXG4gICAqXG4gICAqIElmIHlvdSBwYXNzIGluIGEgc2l6ZSBhcmd1bWVudCwgdGhlbiBpdCB3aWxsIHJldHVybiB0aGF0IG1hbnkgYnl0ZXMuIElmXG4gICAqIHNpemUgYnl0ZXMgYXJlIG5vdCBhdmFpbGFibGUsIHRoZW4gaXQgd2lsbCByZXR1cm4gbnVsbCwgdW5sZXNzIHdlJ3ZlXG4gICAqIGVuZGVkLCBpbiB3aGljaCBjYXNlIGl0IHdpbGwgcmV0dXJuIHRoZSBkYXRhIHJlbWFpbmluZyBpbiB0aGUgYnVmZmVyLlxuICAgKlxuICAgKiBJZiB5b3UgZG8gbm90IHNwZWNpZnkgYSBzaXplIGFyZ3VtZW50LCB0aGVuIGl0IHdpbGwgcmV0dXJuIGFsbCB0aGUgZGF0YSBpblxuICAgKiB0aGUgaW50ZXJuYWwgYnVmZmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemU9bnVsbF0gLSBOdW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICogQHJldHVybnMge3N0cmluZ3xCdWZmZXJ8bnVsbH0gSWYgbm8gZGF0YSBvciBub3QgZW5vdWdoIGRhdGEsIG51bGwuICBJZlxuICAgKiAgIGRlY29kaW5nIG91dHB1dCBhIHN0cmluZywgb3RoZXJ3aXNlIGEgQnVmZmVyXG4gICAqIEB0aHJvd3MgRXJyb3IgLSBpZiByZWFkRXJyb3IgaXMgdHJ1ZSBhbmQgdGhlcmUgd2FzIHVuZGVyZmxvd1xuICAgKiBAZmlyZXMgTm9GaWx0ZXIjcmVhZFxuICAgKi9cbiAgcmVhZChzaXplKSB7XG4gICAgY29uc3QgYnVmID0gc3VwZXIucmVhZChzaXplKVxuICAgIGlmIChidWYgIT0gbnVsbCkge1xuICAgICAgLypcbiAgICAgICAqIFJlYWQgZXZlbnQuIEZpcmVkIHdoZW5ldmVyIGFueXRoaW5nIGlzIHJlYWQgZnJvbSB0aGUgc3RyZWFtLlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBOb0ZpbHRlciNyZWFkXG4gICAgICAgKiBAdHlwZSB7QnVmZmVyfHN0cmluZ3xPYmplY3R9XG4gICAgICAgKlxuICAgICAgICovXG4gICAgICB0aGlzLmVtaXQoJ3JlYWQnLCBidWYpXG4gICAgICBpZiAodGhpcy5yZWFkRXJyb3IgJiYgKGJ1Zi5sZW5ndGggPCBzaXplKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlYWQgJHtidWYubGVuZ3RofSwgd2FudGVkICR7c2l6ZX1gKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5yZWFkRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZGF0YSBhdmFpbGFibGUsIHdhbnRlZCAke3NpemV9YClcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHByb21pc2UgZnVsZmlsbGVkIHdpdGggdGhlIGZ1bGwgY29udGVudHMsIGFmdGVyIHRoZSAnZmluaXNoJ1xuICAgKiBldmVudCBmaXJlcy4gIEVycm9ycyBvbiB0aGUgc3RyZWFtIGNhdXNlIHRoZSBwcm9taXNlIHRvIGJlIHJlamVjdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2I9bnVsbF0gLSBmaW5pc2hlZC9lcnJvciBjYWxsYmFjayB1c2VkIGluICphZGRpdGlvbipcbiAgICogICB0byB0aGUgcHJvbWlzZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWZmZXJ8U3RyaW5nPn0gZnVsZmlsbGVkIHdoZW4gY29tcGxldGVcbiAgICovXG4gIHByb21pc2UoY2IpIHtcbiAgICBsZXQgZG9uZSA9IGZhbHNlXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMub24oJ2ZpbmlzaCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMucmVhZCgpXG4gICAgICAgIGlmICgoY2IgIT0gbnVsbCkgJiYgIWRvbmUpIHtcbiAgICAgICAgICBkb25lID0gdHJ1ZVxuICAgICAgICAgIGNiKG51bGwsIGRhdGEpXG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShkYXRhKVxuICAgICAgfSlcbiAgICAgIHRoaXMub24oJ2Vycm9yJywgKGVyKSA9PiB7XG4gICAgICAgIGlmICgoY2IgIT0gbnVsbCkgJiYgIWRvbmUpIHtcbiAgICAgICAgICBkb25lID0gdHJ1ZVxuICAgICAgICAgIGNiKGVyKVxuICAgICAgICB9XG4gICAgICAgIHJlamVjdChlcilcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbnVtYmVyIGluZGljYXRpbmcgd2hldGhlciB0aGlzIGNvbWVzIGJlZm9yZSBvciBhZnRlciBvciBpcyB0aGVcbiAgICogc2FtZSBhcyB0aGUgb3RoZXIgTm9GaWx0ZXIgaW4gc29ydCBvcmRlci5cbiAgICpcbiAgICogQHBhcmFtIHtOb0ZpbHRlcn0gb3RoZXIgLSBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmVcbiAgICogQHJldHVybnMge051bWJlcn0gLTEsIDAsIDEgZm9yIGxlc3MsIGVxdWFsLCBncmVhdGVyXG4gICAqL1xuICBjb21wYXJlKG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBOb0ZpbHRlcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIE5vRmlsdGVycycpXG4gICAgfVxuICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgcmV0dXJuIDBcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYnVmMSA9IHRoaXMuc2xpY2UoKVxuICAgICAgY29uc3QgYnVmMiA9IG90aGVyLnNsaWNlKClcbiAgICAgIC8vIHRoZXNlIHdpbGwgYm90aCBiZSBidWZmZXJzIGJlY2F1c2Ugb2YgdGhlIGNoZWNrIGFib3ZlLlxuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihidWYxKSAmJiBCdWZmZXIuaXNCdWZmZXIoYnVmMikpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZjEuY29tcGFyZShidWYyKVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcGFyZSBzdHJlYW1zIGluIG9iamVjdCBtb2RlJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRG8gdGhlc2UgTm9GaWx0ZXIncyBjb250YWluIHRoZSBzYW1lIGJ5dGVzPyAgRG9lc24ndCB3b3JrIGlmIGVpdGhlciBpc1xuICAgKiBpbiBvYmplY3QgbW9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtOb0ZpbHRlcn0gb3RoZXJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IEVxdWFsP1xuICAgKi9cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZShvdGhlcikgPT09IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGJ5dGVzIG9yIG9iamVjdHMgd2l0aG91dCBjb25zdW1pbmcgdGhlbS4gIFVzZWZ1bCBmb3IgZGlhZ25vc3RpY3MuXG4gICAqIE5vdGU6IGFzIGEgc2lkZS1lZmZlY3QsIGNvbmNhdGVuYXRlcyBtdWx0aXBsZSB3cml0ZXMgdG9nZXRoZXIgaW50byB3aGF0XG4gICAqIGxvb2tzIGxpa2UgYSBzaW5nbGUgd3JpdGUsIHNvIHRoYXQgdGhpcyBjb25jYXQgZG9lc24ndCBoYXZlIHRvIGhhcHBlblxuICAgKiBtdWx0aXBsZSB0aW1lcyB3aGVuIHlvdSdyZSBmdXR6aW5nIHdpdGggdGhlIHNhbWUgTm9GaWx0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnQ9MF0gLSBiZWdpbm5pbmcgb2Zmc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kPWxlbmd0aF0gLSBlbmRpbmcgb2Zmc2V0XG4gICAqIEByZXR1cm5zIHtCdWZmZXJ8QXJyYXl9IGlmIGluIG9iamVjdCBtb2RlLCBhbiBhcnJheSBvZiBvYmplY3RzLiAgT3RoZXJ3aXNlLFxuICAgKiAgIGNvbmNhdGVuYXRlZCBhcnJheSBvZiBjb250ZW50cy5cbiAgICovXG4gIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYnVmQXJyYXkoKS5zbGljZShzdGFydCwgZW5kKVxuICAgIH1cbiAgICBjb25zdCBidWZzID0gdGhpcy5fYnVmQXJyYXkoKVxuICAgIHN3aXRjaCAoYnVmcy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICAgICAgY2FzZSAxOiByZXR1cm4gYnVmc1swXS5zbGljZShzdGFydCwgZW5kKVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc3QgYiA9IEJ1ZmZlci5jb25jYXQoYnVmcylcbiAgICAgICAgLy8gVE9ETzogc3RvcmUgdGhlIGNvbmNhdGVudGVkIGJ1ZnMgYmFja1xuICAgICAgICAvLyBAX3JlYWRhYmxlU3RhdGUuYnVmZmVyID0gW2JdXG4gICAgICAgIHJldHVybiBiLnNsaWNlKHN0YXJ0LCBlbmQpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAgKiBHZXQgYSBieXRlIGJ5IG9mZnNldC4gIEkgZGlkbid0IHdhbnQgdG8gZ2V0IGludG8gbWV0YXByb2dyYW1taW5nXG4gICAgKiB0byBnaXZlIHlvdSB0aGUgYE5vRmlsdGVyWzBdYCBzeW50YXguXG4gICAgKlxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIGJ5dGUgdG8gcmV0cmlldmVcbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IDAtMjU1XG4gICAgKi9cbiAgZ2V0KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuc2xpY2UoKVtpbmRleF1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gb2JqZWN0IGNvbXBhdGlibGUgd2l0aCBCdWZmZXIncyB0b0pTT04gaW1wbGVtZW50YXRpb24sIHNvXG4gICAqIHRoYXQgcm91bmQtdHJpcHBpbmcgd2lsbCBwcm9kdWNlIGEgQnVmZmVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKlxuICAgKiBAZXhhbXBsZSBvdXRwdXQgZm9yICdmb28nXG4gICAqICAgeyB0eXBlOiAnQnVmZmVyJywgZGF0YTogWyAxMDIsIDExMSwgMTExIF0gfVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IGIgPSB0aGlzLnNsaWNlKClcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gYi50b0pTT04oKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYlxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGVzIGFuZCByZXR1cm5zIGEgc3RyaW5nIGZyb20gYnVmZmVyIGRhdGEgZW5jb2RlZCB1c2luZyB0aGUgc3BlY2lmaWVkXG4gICAqIGNoYXJhY3RlciBzZXQgZW5jb2RpbmcuIElmIGVuY29kaW5nIGlzIHVuZGVmaW5lZCBvciBudWxsLCB0aGVuIGVuY29kaW5nXG4gICAqIGRlZmF1bHRzIHRvICd1dGY4Jy4gVGhlIHN0YXJ0IGFuZCBlbmQgcGFyYW1ldGVycyBkZWZhdWx0IHRvIDAgYW5kXG4gICAqIE5vRmlsdGVyLmxlbmd0aCB3aGVuIHVuZGVmaW5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtlbmNvZGluZz0ndXRmOCddIC0gV2hpY2ggdG8gdXNlIGZvciBkZWNvZGluZz9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydD0wXSAtIFN0YXJ0IG9mZnNldFxuICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZD1sZW5ndGhdIC0gRW5kIG9mZnNldFxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBidWYgPSB0aGlzLnNsaWNlKHN0YXJ0LCBlbmQpXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGJ1ZilcbiAgICB9XG4gICAgaWYgKCghZW5jb2RpbmcgfHwgKGVuY29kaW5nID09PSAndXRmOCcpKSAmJiB1dGlsLlRleHREZWNvZGVyKSB7XG4gICAgICBjb25zdCB0ZCA9IG5ldyB1dGlsLlRleHREZWNvZGVyKCd1dGY4Jywge1xuICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgaWdub3JlQk9NOiB0cnVlXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHRkLmRlY29kZShidWYpXG4gICAgfVxuICAgIHJldHVybiBidWYudG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGluc3BlY3QoZGVwdGgsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpc1t1dGlsLmluc3BlY3QuY3VzdG9tXShkZXB0aCwgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgW3V0aWwuaW5zcGVjdC5jdXN0b21dKGRlcHRoLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYnVmcyA9IHRoaXMuX2J1ZkFycmF5KClcbiAgICBjb25zdCBoZXggPSBidWZzLm1hcCgoYikgPT4ge1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgICAgICBpZiAoKG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMuc3R5bGl6ZSA6IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5zdHlsaXplKGIudG9TdHJpbmcoJ2hleCcpLCAnc3RyaW5nJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYi50b1N0cmluZygnaGV4JylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuaW5zcGVjdChiLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH0pLmpvaW4oJywgJylcbiAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBbJHtoZXh9XWBcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXJyZW50IHJlYWRhYmxlIGxlbmd0aCwgaW4gYnl0ZXMuXG4gICAqXG4gICAqIEBtZW1iZXIge251bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGEgSmF2YVNjcmlwdCBCaWdJbnQgdG8gdGhlIHN0cmVhbS4gIE5lZ2F0aXZlIG51bWJlcnMgd2lsbCBiZVxuICAgKiB3cml0dGVuIGFzIHRoZWlyIDIncyBjb21wbGVtZW50IHZlcnNpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7YmlnaW50fSB2YWwgLSBUaGUgdmFsdWUgdG8gd3JpdGVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb24gc3VjY2Vzc1xuICAgKi9cbiAgd3JpdGVCaWdJbnQodmFsKSB7XG4gICAgbGV0IHN0ciA9IHZhbC50b1N0cmluZygxNilcbiAgICBpZiAodmFsIDwgMCkge1xuICAgICAgLy8gdHdvJ3MgY29tcGxlbWVudFxuICAgICAgLy8gTm90ZTogc3RyIGFsd2F5cyBzdGFydHMgd2l0aCAnLScgaGVyZS5cbiAgICAgIGNvbnN0IHN6ID0gQmlnSW50KE1hdGguZmxvb3Ioc3RyLmxlbmd0aCAvIDIpKVxuICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgxKSA8PCAoc3ogKiBCaWdJbnQoOCkpXG4gICAgICB2YWwgPSBtYXNrICsgdmFsXG4gICAgICBzdHIgPSB2YWwudG9TdHJpbmcoMTYpXG4gICAgfVxuICAgIGlmIChzdHIubGVuZ3RoICUgMikge1xuICAgICAgc3RyID0gJzAnICsgc3RyXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnB1c2goQnVmZmVyLmZyb20oc3RyLCAnaGV4JykpXG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIHZhcmlhYmxlLXNpemVkIEphdmFTY3JpcHQgdW5zaWduZWQgQmlnSW50IGZyb20gdGhlIHN0cmVhbS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9ICBbbGVuPW51bGxdIC0gbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQgb3IgYWxsIHJlbWFpbmluZ1xuICAgKiAgIGlmIG51bGxcbiAgICogQHJldHVybnMge2JpZ2ludH1cbiAgICovXG4gIHJlYWRVQmlnSW50KGxlbikge1xuICAgIGNvbnN0IGIgPSB0aGlzLnJlYWQobGVuKVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICByZXR1cm4gQmlnSW50KCcweCcgKyBiLnRvU3RyaW5nKCdoZXgnKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGEgdmFyaWFibGUtc2l6ZWQgSmF2YVNjcmlwdCBzaWduZWQgQmlnSW50IGZyb20gdGhlIHN0cmVhbSBpbiAyJ3NcbiAgICogY29tcGxlbWVudCBmb3JtYXQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuPW51bGxdIC0gbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQgb3IgYWxsIHJlbWFpbmluZ1xuICAgKiAgIGlmIG51bGxcbiAgICogQHJldHVybnMge2JpZ2ludH1cbiAgICovXG4gIHJlYWRCaWdJbnQobGVuKSB7XG4gICAgY29uc3QgYiA9IHRoaXMucmVhZChsZW4pXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIGxldCByZXQgPSBCaWdJbnQoJzB4JyArIGIudG9TdHJpbmcoJ2hleCcpKVxuICAgIC8vIG5lZ2F0aXZlP1xuICAgIGlmIChiWzBdICYgMHg4MCkge1xuICAgICAgLy8gdHdvJ3MgY29tcGxlbWVudFxuICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgxKSA8PCAoQmlnSW50KGIubGVuZ3RoKSAqIEJpZ0ludCg4KSlcbiAgICAgIHJldCA9IHJldCAtIG1hc2tcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGggLSBtZXRob2QgdG8gY2FsbFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiAtIG51bWJlciBvZiBieXRlcyB0byB3cml0ZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3JlYWRfZ2VuKG1ldGgsIGxlbikge1xuICByZXR1cm4gZnVuY3Rpb24odmFsKSB7XG4gICAgY29uc3QgYiA9IHRoaXMucmVhZChsZW4pXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHJldHVybiBiW21ldGhdLmNhbGwoYiwgMCwgdHJ1ZSlcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRoIC0gbWV0aG9kIHRvIGNhbGxcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gLSBudW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF93cml0ZV9nZW4obWV0aCwgbGVuKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWwpIHtcbiAgICBjb25zdCBiID0gQnVmZmVyLmFsbG9jKGxlbilcbiAgICBiW21ldGhdLmNhbGwoYiwgdmFsLCAwLCB0cnVlKVxuICAgIHJldHVybiB0aGlzLnB1c2goYilcbiAgfVxufVxuXG5PYmplY3QuYXNzaWduKE5vRmlsdGVyLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogV3JpdGUgYW4gOC1iaXQgdW5zaWduZWQgaW50ZWdlciB0byB0aGUgc3RyZWFtLiAgQWRkcyAxIGJ5dGUuXG4gICAqXG4gICAqIEBmdW5jdGlvbiB3cml0ZVVJbnQ4XG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gMC0yNTVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb24gc3VjY2Vzc1xuICAgKi9cbiAgd3JpdGVVSW50ODogX3dyaXRlX2dlbignd3JpdGVVSW50OCcsIDEpLFxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIGxpdHRsZS1lbmRpYW4gMTYtYml0IHVuc2lnbmVkIGludGVnZXIgdG8gdGhlIHN0cmVhbS4gIEFkZHNcbiAgICogMiBieXRlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHdyaXRlVUludDE2TEVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb24gc3VjY2Vzc1xuICAgKi9cbiAgd3JpdGVVSW50MTZMRTogX3dyaXRlX2dlbignd3JpdGVVSW50MTZMRScsIDIpLFxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIGJpZy1lbmRpYW4gMTYtYml0IHVuc2lnbmVkIGludGVnZXIgdG8gdGhlIHN0cmVhbS4gIEFkZHNcbiAgICogMiBieXRlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHdyaXRlVUludDE2QkVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb24gc3VjY2Vzc1xuICAgKi9cbiAgd3JpdGVVSW50MTZCRTogX3dyaXRlX2dlbignd3JpdGVVSW50MTZCRScsIDIpLFxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIGxpdHRsZS1lbmRpYW4gMzItYml0IHVuc2lnbmVkIGludGVnZXIgdG8gdGhlIHN0cmVhbS4gIEFkZHNcbiAgICogNCBieXRlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHdyaXRlVUludDMyTEVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb24gc3VjY2Vzc1xuICAgKi9cbiAgd3JpdGVVSW50MzJMRTogX3dyaXRlX2dlbignd3JpdGVVSW50MzJMRScsIDQpLFxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIGJpZy1lbmRpYW4gMzItYml0IHVuc2lnbmVkIGludGVnZXIgdG8gdGhlIHN0cmVhbS4gIEFkZHNcbiAgICogNCBieXRlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHdyaXRlVUludDMyQkVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb24gc3VjY2Vzc1xuICAgKi9cbiAgd3JpdGVVSW50MzJCRTogX3dyaXRlX2dlbignd3JpdGVVSW50MzJCRScsIDQpLFxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIHNpZ25lZCA4LWJpdCBpbnRlZ2VyIHRvIHRoZSBzdHJlYW0uICBBZGRzIDEgYnl0ZS5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHdyaXRlSW50OFxuICAgKiBAbWVtYmVyT2YgTm9GaWx0ZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBvbiBzdWNjZXNzXG4gICAqL1xuICB3cml0ZUludDg6IF93cml0ZV9nZW4oJ3dyaXRlSW50OCcsIDEpLFxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIHNpZ25lZCBsaXR0bGUtZW5kaWFuIDE2LWJpdCBpbnRlZ2VyIHRvIHRoZSBzdHJlYW0uICBBZGRzIDIgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiB3cml0ZUludDE2TEVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb24gc3VjY2Vzc1xuICAgKi9cbiAgd3JpdGVJbnQxNkxFOiBfd3JpdGVfZ2VuKCd3cml0ZUludDE2TEUnLCAyKSxcblxuICAvKipcbiAgICogV3JpdGUgYSBzaWduZWQgYmlnLWVuZGlhbiAxNi1iaXQgaW50ZWdlciB0byB0aGUgc3RyZWFtLiAgQWRkcyAyIGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gd3JpdGVJbnQxNkJFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiAgICovXG4gIHdyaXRlSW50MTZCRTogX3dyaXRlX2dlbignd3JpdGVJbnQxNkJFJywgMiksXG5cbiAgLyoqXG4gICAqIFdyaXRlIGEgc2lnbmVkIGxpdHRsZS1lbmRpYW4gMzItYml0IGludGVnZXIgdG8gdGhlIHN0cmVhbS4gIEFkZHMgNCBieXRlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHdyaXRlSW50MzJMRVxuICAgKiBAbWVtYmVyT2YgTm9GaWx0ZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBvbiBzdWNjZXNzXG4gICAqL1xuICB3cml0ZUludDMyTEU6IF93cml0ZV9nZW4oJ3dyaXRlSW50MzJMRScsIDQpLFxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIHNpZ25lZCBiaWctZW5kaWFuIDMyLWJpdCBpbnRlZ2VyIHRvIHRoZSBzdHJlYW0uICBBZGRzIDQgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiB3cml0ZUludDMyQkVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb24gc3VjY2Vzc1xuICAgKi9cbiAgd3JpdGVJbnQzMkJFOiBfd3JpdGVfZ2VuKCd3cml0ZUludDMyQkUnLCA0KSxcblxuICAvKipcbiAgICogV3JpdGUgYSBsaXR0bGUtZW5kaWFuIDMyLWJpdCBmbG9hdCB0byB0aGUgc3RyZWFtLiAgQWRkcyA0IGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gd3JpdGVGbG9hdExFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiAgICovXG4gIHdyaXRlRmxvYXRMRTogX3dyaXRlX2dlbignd3JpdGVGbG9hdExFJywgNCksXG5cbiAgLyoqXG4gICAqIFdyaXRlIGEgYmlnLWVuZGlhbiAzMi1iaXQgZmxvYXQgdG8gdGhlIHN0cmVhbS4gIEFkZHMgNCBieXRlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHdyaXRlRmxvYXRCRVxuICAgKiBAbWVtYmVyT2YgTm9GaWx0ZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBvbiBzdWNjZXNzXG4gICAqL1xuICB3cml0ZUZsb2F0QkU6IF93cml0ZV9nZW4oJ3dyaXRlRmxvYXRCRScsIDQpLFxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIGxpdHRsZS1lbmRpYW4gNjQtYml0IGZsb2F0IHRvIHRoZSBzdHJlYW0uICBBZGRzIDggYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiB3cml0ZURvdWJsZUxFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiAgICovXG4gIHdyaXRlRG91YmxlTEU6IF93cml0ZV9nZW4oJ3dyaXRlRG91YmxlTEUnLCA4KSxcblxuICAvKipcbiAgICogV3JpdGUgYSBiaWctZW5kaWFuIDY0LWJpdCBmbG9hdCB0byB0aGUgc3RyZWFtLiAgQWRkcyA4IGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gd3JpdGVEb3VibGVCRVxuICAgKiBAbWVtYmVyT2YgTm9GaWx0ZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBvbiBzdWNjZXNzXG4gICAqL1xuICB3cml0ZURvdWJsZUJFOiBfd3JpdGVfZ2VuKCd3cml0ZURvdWJsZUJFJywgOCksXG5cbiAgLyoqXG4gICAqIFJlYWQgYW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlciBmcm9tIHRoZSBzdHJlYW0uICBDb25zdW1lcyAxIGJ5dGUuXG4gICAqXG4gICAqIEBmdW5jdGlvbiByZWFkVUludDhcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgcmVhZFVJbnQ4OiBfcmVhZF9nZW4oJ3JlYWRVSW50OCcsIDEpLFxuXG4gIC8qKlxuICAgKiBSZWFkIGEgbGl0dGxlLWVuZGlhbiB1bnNpZ25lZCAxNi1iaXQgaW50ZWdlciBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIENvbnN1bWVzIDIgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiByZWFkVUludDE2TEVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgcmVhZFVJbnQxNkxFOiBfcmVhZF9nZW4oJ3JlYWRVSW50MTZMRScsIDIpLFxuXG4gIC8qKlxuICAgKiBSZWFkIGEgYmlnLWVuZGlhbiB1bnNpZ25lZCAxNi1iaXQgaW50ZWdlciBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIENvbnN1bWVzIDIgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiByZWFkVUludDE2QkVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgcmVhZFVJbnQxNkJFOiBfcmVhZF9nZW4oJ3JlYWRVSW50MTZCRScsIDIpLFxuXG4gIC8qKlxuICAgKiBSZWFkIGEgbGl0dGxlLWVuZGlhbiB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlciBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIENvbnN1bWVzIDQgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiByZWFkVUludDMyTEVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgcmVhZFVJbnQzMkxFOiBfcmVhZF9nZW4oJ3JlYWRVSW50MzJMRScsIDQpLFxuXG4gIC8qKlxuICAgKiBSZWFkIGEgYmlnLWVuZGlhbiB1bnNpZ25lZCAxNi1iaXQgaW50ZWdlciBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIENvbnN1bWVzIDQgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiByZWFkVUludDMyQkVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgcmVhZFVJbnQzMkJFOiBfcmVhZF9nZW4oJ3JlYWRVSW50MzJCRScsIDQpLFxuXG4gIC8qKlxuICAgKiBSZWFkIGEgc2lnbmVkIDgtYml0IGludGVnZXIgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBDb25zdW1lcyAxIGJ5dGUuXG4gICAqXG4gICAqIEBmdW5jdGlvbiByZWFkSW50OFxuICAgKiBAbWVtYmVyT2YgTm9GaWx0ZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHZhbHVlXG4gICAqL1xuICByZWFkSW50ODogX3JlYWRfZ2VuKCdyZWFkSW50OCcsIDEpLFxuXG4gIC8qKlxuICAgKiBSZWFkIGEgc2lnbmVkIDE2LWJpdCBsaXR0bGUtZW5kaWFuIGludGVnZXIgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBDb25zdW1lcyAyIGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gcmVhZEludDE2TEVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgcmVhZEludDE2TEU6IF9yZWFkX2dlbigncmVhZEludDE2TEUnLCAyKSxcblxuICAvKipcbiAgICogUmVhZCBhIHNpZ25lZCAxNi1iaXQgYmlnLWVuZGlhbiBpbnRlZ2VyIGZyb20gdGhlIHN0cmVhbS5cbiAgICogQ29uc3VtZXMgMiBieXRlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHJlYWRJbnQxNkJFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJldHVybnMge051bWJlcn0gdmFsdWVcbiAgICovXG4gIHJlYWRJbnQxNkJFOiBfcmVhZF9nZW4oJ3JlYWRJbnQxNkJFJywgMiksXG5cbiAgLyoqXG4gICAqIFJlYWQgYSBzaWduZWQgMzItYml0IGxpdHRsZS1lbmRpYW4gaW50ZWdlciBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIENvbnN1bWVzIDQgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiByZWFkSW50MzJMRVxuICAgKiBAbWVtYmVyT2YgTm9GaWx0ZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHZhbHVlXG4gICAqL1xuICByZWFkSW50MzJMRTogX3JlYWRfZ2VuKCdyZWFkSW50MzJMRScsIDQpLFxuXG4gIC8qKlxuICAgKiBSZWFkIGEgc2lnbmVkIDMyLWJpdCBiaWctZW5kaWFuIGludGVnZXIgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBDb25zdW1lcyA0IGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gcmVhZEludDMyQkVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgcmVhZEludDMyQkU6IF9yZWFkX2dlbigncmVhZEludDMyQkUnLCA0KSxcblxuICAvKipcbiAgICogUmVhZCBhIDMyLWJpdCBsaXR0bGUtZW5kaWFuIGZsb2F0IGZyb20gdGhlIHN0cmVhbS5cbiAgICogQ29uc3VtZXMgNCBieXRlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHJlYWRGbG9hdExFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJldHVybnMge051bWJlcn0gdmFsdWVcbiAgICovXG4gIHJlYWRGbG9hdExFOiBfcmVhZF9nZW4oJ3JlYWRGbG9hdExFJywgNCksXG5cbiAgLyoqXG4gICAqIFJlYWQgYSAzMi1iaXQgYmlnLWVuZGlhbiBmbG9hdCBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIENvbnN1bWVzIDQgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiByZWFkRmxvYXRCRVxuICAgKiBAbWVtYmVyT2YgTm9GaWx0ZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHZhbHVlXG4gICAqL1xuICByZWFkRmxvYXRCRTogX3JlYWRfZ2VuKCdyZWFkRmxvYXRCRScsIDQpLFxuXG4gIC8qKlxuICAgKiBSZWFkIGEgNjQtYml0IGxpdHRsZS1lbmRpYW4gZmxvYXQgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBDb25zdW1lcyA4IGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gcmVhZERvdWJsZUxFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJldHVybnMge051bWJlcn0gdmFsdWVcbiAgICovXG4gIHJlYWREb3VibGVMRTogX3JlYWRfZ2VuKCdyZWFkRG91YmxlTEUnLCA4KSxcblxuICAvKipcbiAgICogUmVhZCBhIDY0LWJpdCBiaWctZW5kaWFuIGZsb2F0IGZyb20gdGhlIHN0cmVhbS5cbiAgICogQ29uc3VtZXMgOCBieXRlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHJlYWREb3VibGVCRVxuICAgKiBAbWVtYmVyT2YgTm9GaWx0ZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHZhbHVlXG4gICAqL1xuICByZWFkRG91YmxlQkU6IF9yZWFkX2dlbigncmVhZERvdWJsZUJFJywgOClcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gTm9GaWx0ZXJcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG51bWJlcklzTmFOID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzKGEsIGIpIHtcblx0aWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuXHRcdHJldHVybiAxIC8gYSA9PT0gMSAvIGI7XG5cdH1cblx0aWYgKGEgPT09IGIpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRpZiAobnVtYmVySXNOYU4oYSkgJiYgbnVtYmVySXNOYU4oYikpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kJyk7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBzaGltID0gcmVxdWlyZSgnLi9zaGltJyk7XG5cbnZhciBwb2x5ZmlsbCA9IGNhbGxCaW5kKGdldFBvbHlmaWxsKCksIE9iamVjdCk7XG5cbmRlZmluZShwb2x5ZmlsbCwge1xuXHRnZXRQb2x5ZmlsbDogZ2V0UG9seWZpbGwsXG5cdGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvbixcblx0c2hpbTogc2hpbVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9seWZpbGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0cmV0dXJuIHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1PYmplY3RJcygpIHtcblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0ZGVmaW5lKE9iamVjdCwgeyBpczogcG9seWZpbGwgfSwge1xuXHRcdGlzOiBmdW5jdGlvbiB0ZXN0T2JqZWN0SXMoKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmlzICE9PSBwb2x5ZmlsbDtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcG9seWZpbGw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5c1NoaW07XG5pZiAoIU9iamVjdC5rZXlzKSB7XG5cdC8vIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG5cdHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHR2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHR2YXIgaXNBcmdzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGdsb2JhbC1yZXF1aXJlXG5cdHZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXHR2YXIgaGFzRG9udEVudW1CdWcgPSAhaXNFbnVtZXJhYmxlLmNhbGwoeyB0b1N0cmluZzogbnVsbCB9LCAndG9TdHJpbmcnKTtcblx0dmFyIGhhc1Byb3RvRW51bUJ1ZyA9IGlzRW51bWVyYWJsZS5jYWxsKGZ1bmN0aW9uICgpIHt9LCAncHJvdG90eXBlJyk7XG5cdHZhciBkb250RW51bXMgPSBbXG5cdFx0J3RvU3RyaW5nJyxcblx0XHQndG9Mb2NhbGVTdHJpbmcnLFxuXHRcdCd2YWx1ZU9mJyxcblx0XHQnaGFzT3duUHJvcGVydHknLFxuXHRcdCdpc1Byb3RvdHlwZU9mJyxcblx0XHQncHJvcGVydHlJc0VudW1lcmFibGUnLFxuXHRcdCdjb25zdHJ1Y3Rvcidcblx0XTtcblx0dmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlID0gZnVuY3Rpb24gKG8pIHtcblx0XHR2YXIgY3RvciA9IG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIGN0b3IgJiYgY3Rvci5wcm90b3R5cGUgPT09IG87XG5cdH07XG5cdHZhciBleGNsdWRlZEtleXMgPSB7XG5cdFx0JGFwcGxpY2F0aW9uQ2FjaGU6IHRydWUsXG5cdFx0JGNvbnNvbGU6IHRydWUsXG5cdFx0JGV4dGVybmFsOiB0cnVlLFxuXHRcdCRmcmFtZTogdHJ1ZSxcblx0XHQkZnJhbWVFbGVtZW50OiB0cnVlLFxuXHRcdCRmcmFtZXM6IHRydWUsXG5cdFx0JGlubmVySGVpZ2h0OiB0cnVlLFxuXHRcdCRpbm5lcldpZHRoOiB0cnVlLFxuXHRcdCRvbm1vemZ1bGxzY3JlZW5jaGFuZ2U6IHRydWUsXG5cdFx0JG9ubW96ZnVsbHNjcmVlbmVycm9yOiB0cnVlLFxuXHRcdCRvdXRlckhlaWdodDogdHJ1ZSxcblx0XHQkb3V0ZXJXaWR0aDogdHJ1ZSxcblx0XHQkcGFnZVhPZmZzZXQ6IHRydWUsXG5cdFx0JHBhZ2VZT2Zmc2V0OiB0cnVlLFxuXHRcdCRwYXJlbnQ6IHRydWUsXG5cdFx0JHNjcm9sbExlZnQ6IHRydWUsXG5cdFx0JHNjcm9sbFRvcDogdHJ1ZSxcblx0XHQkc2Nyb2xsWDogdHJ1ZSxcblx0XHQkc2Nyb2xsWTogdHJ1ZSxcblx0XHQkc2VsZjogdHJ1ZSxcblx0XHQkd2Via2l0SW5kZXhlZERCOiB0cnVlLFxuXHRcdCR3ZWJraXRTdG9yYWdlSW5mbzogdHJ1ZSxcblx0XHQkd2luZG93OiB0cnVlXG5cdH07XG5cdHZhciBoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcgPSAoZnVuY3Rpb24gKCkge1xuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm9yICh2YXIgayBpbiB3aW5kb3cpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghZXhjbHVkZWRLZXlzWyckJyArIGtdICYmIGhhcy5jYWxsKHdpbmRvdywgaykgJiYgd2luZG93W2tdICE9PSBudWxsICYmIHR5cGVvZiB3aW5kb3dba10gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKHdpbmRvd1trXSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0oKSk7XG5cdHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kgPSBmdW5jdGlvbiAobykge1xuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1Zykge1xuXHRcdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0a2V5c1NoaW0gPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuXHRcdHZhciBpc09iamVjdCA9IG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jztcblx0XHR2YXIgaXNGdW5jdGlvbiA9IHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0XHR2YXIgaXNBcmd1bWVudHMgPSBpc0FyZ3Mob2JqZWN0KTtcblx0XHR2YXIgaXNTdHJpbmcgPSBpc09iamVjdCAmJiB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuXHRcdHZhciB0aGVLZXlzID0gW107XG5cblx0XHRpZiAoIWlzT2JqZWN0ICYmICFpc0Z1bmN0aW9uICYmICFpc0FyZ3VtZW50cykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdCcpO1xuXHRcdH1cblxuXHRcdHZhciBza2lwUHJvdG8gPSBoYXNQcm90b0VudW1CdWcgJiYgaXNGdW5jdGlvbjtcblx0XHRpZiAoaXNTdHJpbmcgJiYgb2JqZWN0Lmxlbmd0aCA+IDAgJiYgIWhhcy5jYWxsKG9iamVjdCwgMCkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc0FyZ3VtZW50cyAmJiBvYmplY3QubGVuZ3RoID4gMCkge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBvYmplY3QubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhqKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdGlmICghKHNraXBQcm90byAmJiBuYW1lID09PSAncHJvdG90eXBlJykgJiYgaGFzLmNhbGwob2JqZWN0LCBuYW1lKSkge1xuXHRcdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcobmFtZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGhhc0RvbnRFbnVtQnVnKSB7XG5cdFx0XHR2YXIgc2tpcENvbnN0cnVjdG9yID0gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5KG9iamVjdCk7XG5cblx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgZG9udEVudW1zLmxlbmd0aDsgKytrKSB7XG5cdFx0XHRcdGlmICghKHNraXBDb25zdHJ1Y3RvciAmJiBkb250RW51bXNba10gPT09ICdjb25zdHJ1Y3RvcicpICYmIGhhcy5jYWxsKG9iamVjdCwgZG9udEVudW1zW2tdKSkge1xuXHRcdFx0XHRcdHRoZUtleXMucHVzaChkb250RW51bXNba10pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGVLZXlzO1xuXHR9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGlzQXJncyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKTtcblxudmFyIG9yaWdLZXlzID0gT2JqZWN0LmtleXM7XG52YXIga2V5c1NoaW0gPSBvcmlnS2V5cyA/IGZ1bmN0aW9uIGtleXMobykgeyByZXR1cm4gb3JpZ0tleXMobyk7IH0gOiByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbnZhciBvcmlnaW5hbEtleXMgPSBPYmplY3Qua2V5cztcblxua2V5c1NoaW0uc2hpbSA9IGZ1bmN0aW9uIHNoaW1PYmplY3RLZXlzKCkge1xuXHRpZiAoT2JqZWN0LmtleXMpIHtcblx0XHR2YXIga2V5c1dvcmtzV2l0aEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBTYWZhcmkgNS4wIGJ1Z1xuXHRcdFx0dmFyIGFyZ3MgPSBPYmplY3Qua2V5cyhhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIGFyZ3MgJiYgYXJncy5sZW5ndGggPT09IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0fSgxLCAyKSk7XG5cdFx0aWYgKCFrZXlzV29ya3NXaXRoQXJndW1lbnRzKSB7XG5cdFx0XHRPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG5cdFx0XHRcdGlmIChpc0FyZ3Mob2JqZWN0KSkge1xuXHRcdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMoc2xpY2UuY2FsbChvYmplY3QpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKG9iamVjdCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRPYmplY3Qua2V5cyA9IGtleXNTaGltO1xuXHR9XG5cdHJldHVybiBPYmplY3Qua2V5cyB8fCBrZXlzU2hpbTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0dmFyIHN0ciA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHR2YXIgaXNBcmdzID0gc3RyID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcblx0aWYgKCFpc0FyZ3MpIHtcblx0XHRpc0FyZ3MgPSBzdHIgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHRcdHZhbHVlICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHRcdHRvU3RyLmNhbGwodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0fVxuXHRyZXR1cm4gaXNBcmdzO1xufTtcbiIsImV4cG9ydHMuZW5kaWFubmVzcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdMRScgfTtcblxuZXhwb3J0cy5ob3N0bmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbG9jYXRpb24uaG9zdG5hbWVcbiAgICB9XG4gICAgZWxzZSByZXR1cm4gJyc7XG59O1xuXG5leHBvcnRzLmxvYWRhdmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXSB9O1xuXG5leHBvcnRzLnVwdGltZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcblxuZXhwb3J0cy5mcmVlbWVtID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xufTtcblxuZXhwb3J0cy50b3RhbG1lbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbmV4cG9ydHMuY3B1cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdIH07XG5cbmV4cG9ydHMudHlwZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdCcm93c2VyJyB9O1xuXG5leHBvcnRzLnJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IuYXBwVmVyc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufTtcblxuZXhwb3J0cy5uZXR3b3JrSW50ZXJmYWNlc1xuPSBleHBvcnRzLmdldE5ldHdvcmtJbnRlcmZhY2VzXG49IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHt9IH07XG5cbmV4cG9ydHMuYXJjaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdqYXZhc2NyaXB0JyB9O1xuXG5leHBvcnRzLnBsYXRmb3JtID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ2Jyb3dzZXInIH07XG5cbmV4cG9ydHMudG1wZGlyID0gZXhwb3J0cy50bXBEaXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcvdG1wJztcbn07XG5cbmV4cG9ydHMuRU9MID0gJ1xcbic7XG5cbmV4cG9ydHMuaG9tZWRpciA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuICcvJ1xufTtcbiIsInZhciBub0Nhc2UgPSByZXF1aXJlKCduby1jYXNlJylcblxuLyoqXG4gKiBQYXJhbSBjYXNlIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSAge3N0cmluZ30gW2xvY2FsZV1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIGxvY2FsZSkge1xuICByZXR1cm4gbm9DYXNlKHZhbHVlLCBsb2NhbGUsICctJylcbn1cbiIsInZhciBjYW1lbENhc2UgPSByZXF1aXJlKCdjYW1lbC1jYXNlJylcbnZhciB1cHBlckNhc2VGaXJzdCA9IHJlcXVpcmUoJ3VwcGVyLWNhc2UtZmlyc3QnKVxuXG4vKipcbiAqIFBhc2NhbCBjYXNlIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHZhbHVlXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBbbG9jYWxlXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gW21lcmdlTnVtYmVyc11cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIGxvY2FsZSwgbWVyZ2VOdW1iZXJzKSB7XG4gIHJldHVybiB1cHBlckNhc2VGaXJzdChjYW1lbENhc2UodmFsdWUsIGxvY2FsZSwgbWVyZ2VOdW1iZXJzKSwgbG9jYWxlKVxufVxuIiwidmFyIG5vQ2FzZSA9IHJlcXVpcmUoJ25vLWNhc2UnKVxuXG4vKipcbiAqIFBhdGggY2FzZSBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IFtsb2NhbGVdXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBsb2NhbGUpIHtcbiAgcmV0dXJuIG5vQ2FzZSh2YWx1ZSwgbG9jYWxlLCAnLycpXG59XG4iLCJ2YXIgaXNhcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG4vKipcbiAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBwYXRoVG9SZWdleHBcbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2Vcbm1vZHVsZS5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlXG5tb2R1bGUuZXhwb3J0cy50b2tlbnNUb0Z1bmN0aW9uID0gdG9rZW5zVG9GdW5jdGlvblxubW9kdWxlLmV4cG9ydHMudG9rZW5zVG9SZWdFeHAgPSB0b2tlbnNUb1JlZ0V4cFxuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b24ndCB0cmFuc2Zvcm0uXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCIsIHVuZGVmaW5lZF1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiICA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAvLyBcIi8qXCIgICAgICAgICAgICA9PiBbXCIvXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCIqXCJdXG4gICcoW1xcXFwvLl0pPyg/Oig/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSkoWysqP10pP3woXFxcXCopKSdcbl0uam9pbignfCcpLCAnZycpXG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybiB7IUFycmF5fVxuICovXG5mdW5jdGlvbiBwYXJzZSAoc3RyLCBvcHRpb25zKSB7XG4gIHZhciB0b2tlbnMgPSBbXVxuICB2YXIga2V5ID0gMFxuICB2YXIgaW5kZXggPSAwXG4gIHZhciBwYXRoID0gJydcbiAgdmFyIGRlZmF1bHREZWxpbWl0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJ1xuICB2YXIgcmVzXG5cbiAgd2hpbGUgKChyZXMgPSBQQVRIX1JFR0VYUC5leGVjKHN0cikpICE9IG51bGwpIHtcbiAgICB2YXIgbSA9IHJlc1swXVxuICAgIHZhciBlc2NhcGVkID0gcmVzWzFdXG4gICAgdmFyIG9mZnNldCA9IHJlcy5pbmRleFxuICAgIHBhdGggKz0gc3RyLnNsaWNlKGluZGV4LCBvZmZzZXQpXG4gICAgaW5kZXggPSBvZmZzZXQgKyBtLmxlbmd0aFxuXG4gICAgLy8gSWdub3JlIGFscmVhZHkgZXNjYXBlZCBzZXF1ZW5jZXMuXG4gICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgIHBhdGggKz0gZXNjYXBlZFsxXVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IHN0cltpbmRleF1cbiAgICB2YXIgcHJlZml4ID0gcmVzWzJdXG4gICAgdmFyIG5hbWUgPSByZXNbM11cbiAgICB2YXIgY2FwdHVyZSA9IHJlc1s0XVxuICAgIHZhciBncm91cCA9IHJlc1s1XVxuICAgIHZhciBtb2RpZmllciA9IHJlc1s2XVxuICAgIHZhciBhc3RlcmlzayA9IHJlc1s3XVxuXG4gICAgLy8gUHVzaCB0aGUgY3VycmVudCBwYXRoIG9udG8gdGhlIHRva2Vucy5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdG9rZW5zLnB1c2gocGF0aClcbiAgICAgIHBhdGggPSAnJ1xuICAgIH1cblxuICAgIHZhciBwYXJ0aWFsID0gcHJlZml4ICE9IG51bGwgJiYgbmV4dCAhPSBudWxsICYmIG5leHQgIT09IHByZWZpeFxuICAgIHZhciByZXBlYXQgPSBtb2RpZmllciA9PT0gJysnIHx8IG1vZGlmaWVyID09PSAnKidcbiAgICB2YXIgb3B0aW9uYWwgPSBtb2RpZmllciA9PT0gJz8nIHx8IG1vZGlmaWVyID09PSAnKidcbiAgICB2YXIgZGVsaW1pdGVyID0gcmVzWzJdIHx8IGRlZmF1bHREZWxpbWl0ZXJcbiAgICB2YXIgcGF0dGVybiA9IGNhcHR1cmUgfHwgZ3JvdXBcblxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICBwcmVmaXg6IHByZWZpeCB8fCAnJyxcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxuICAgICAgYXN0ZXJpc2s6ICEhYXN0ZXJpc2ssXG4gICAgICBwYXR0ZXJuOiBwYXR0ZXJuID8gZXNjYXBlR3JvdXAocGF0dGVybikgOiAoYXN0ZXJpc2sgPyAnLionIDogJ1teJyArIGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIpICsgJ10rPycpXG4gICAgfSlcbiAgfVxuXG4gIC8vIE1hdGNoIGFueSBjaGFyYWN0ZXJzIHN0aWxsIHJlbWFpbmluZy5cbiAgaWYgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIHBhdGggKz0gc3RyLnN1YnN0cihpbmRleClcbiAgfVxuXG4gIC8vIElmIHRoZSBwYXRoIGV4aXN0cywgcHVzaCBpdCBvbnRvIHRoZSBlbmQuXG4gIGlmIChwYXRoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0aClcbiAgfVxuXG4gIHJldHVybiB0b2tlbnNcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFmdW5jdGlvbihPYmplY3Q9LCBPYmplY3Q9KX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZSAoc3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucykpXG59XG5cbi8qKlxuICogUHJldHRpZXIgZW5jb2Rpbmcgb2YgVVJJIHBhdGggc2VnbWVudHMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvW1xcLz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbmNvZGUgdGhlIGFzdGVyaXNrIHBhcmFtZXRlci4gU2ltaWxhciB0byBgcHJldHR5YCwgYnV0IGFsbG93cyBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQXN0ZXJpc2sgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbiAodG9rZW5zKSB7XG4gIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheSh0b2tlbnMubGVuZ3RoKVxuXG4gIC8vIENvbXBpbGUgYWxsIHRoZSBwYXR0ZXJucyBiZWZvcmUgY29tcGlsYXRpb24uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiB0b2tlbnNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBtYXRjaGVzW2ldID0gbmV3IFJlZ0V4cCgnXig/OicgKyB0b2tlbnNbaV0ucGF0dGVybiArICcpJCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgICB2YXIgcGF0aCA9ICcnXG4gICAgdmFyIGRhdGEgPSBvYmogfHwge31cbiAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge31cbiAgICB2YXIgZW5jb2RlID0gb3B0aW9ucy5wcmV0dHkgPyBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgOiBlbmNvZGVVUklDb21wb25lbnRcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGF0aCArPSB0b2tlblxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IGRhdGFbdG9rZW4ubmFtZV1cbiAgICAgIHZhciBzZWdtZW50XG5cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgIC8vIFByZXBlbmQgcGFydGlhbCBzZWdtZW50IHByZWZpeGVzLlxuICAgICAgICAgIGlmICh0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBiZSBkZWZpbmVkJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNhcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCByZXBlYXQsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdgJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IGJlIGVtcHR5JylcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSlcblxuICAgICAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhbGwgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeShzZWdtZW50KSArICdgJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoICs9IChqID09PSAwID8gdG9rZW4ucHJlZml4IDogdG9rZW4uZGVsaW1pdGVyKSArIHNlZ21lbnRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnQgPSB0b2tlbi5hc3RlcmlzayA/IGVuY29kZUFzdGVyaXNrKHZhbHVlKSA6IGVuY29kZSh2YWx1ZSlcblxuICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgXCInICsgc2VnbWVudCArICdcIicpXG4gICAgICB9XG5cbiAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudFxuICAgIH1cblxuICAgIHJldHVybiBwYXRoXG4gIH1cbn1cblxuLyoqXG4gKiBFc2NhcGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXxcXC9cXFxcXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogRXNjYXBlIHRoZSBjYXB0dXJpbmcgZ3JvdXAgYnkgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gZ3JvdXBcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5yZXBsYWNlKC8oWz0hOiRcXC8oKV0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEF0dGFjaCB0aGUga2V5cyBhcyBhIHByb3BlcnR5IG9mIHRoZSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcmVcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEtleXMgKHJlLCBrZXlzKSB7XG4gIHJlLmtleXMgPSBrZXlzXG4gIHJldHVybiByZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZmxhZ3MgZm9yIGEgcmVnZXhwIGZyb20gdGhlIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZsYWdzIChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knXG59XG5cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XG4gIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKVxuXG4gIGlmIChncm91cHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgbmFtZTogaSxcbiAgICAgICAgcHJlZml4OiBudWxsLFxuICAgICAgICBkZWxpbWl0ZXI6IG51bGwsXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgcmVwZWF0OiBmYWxzZSxcbiAgICAgICAgcGFydGlhbDogZmFsc2UsXG4gICAgICAgIGFzdGVyaXNrOiBmYWxzZSxcbiAgICAgICAgcGF0dGVybjogbnVsbFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKHBhdGhUb1JlZ2V4cChwYXRoW2ldLCBrZXlzLCBvcHRpb25zKS5zb3VyY2UpXG4gIH1cblxuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJywgZmxhZ3Mob3B0aW9ucykpXG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocmVnZXhwLCBrZXlzKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb1JlZ0V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gICAgICAgICAgdG9rZW5zXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19IGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9SZWdFeHAgKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKVxuICAgIGtleXMgPSBbXVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3RcbiAgdmFyIGVuZCA9IG9wdGlvbnMuZW5kICE9PSBmYWxzZVxuICB2YXIgcm91dGUgPSAnJ1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgcm91dGUgKz0gZXNjYXBlU3RyaW5nKHRva2VuKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKHRva2VuLnByZWZpeClcbiAgICAgIHZhciBjYXB0dXJlID0gJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJyknXG5cbiAgICAgIGtleXMucHVzaCh0b2tlbilcblxuICAgICAgaWYgKHRva2VuLnJlcGVhdCkge1xuICAgICAgICBjYXB0dXJlICs9ICcoPzonICsgcHJlZml4ICsgY2FwdHVyZSArICcpKidcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgIGlmICghdG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgIGNhcHR1cmUgPSAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyk/J1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpJ1xuICAgICAgfVxuXG4gICAgICByb3V0ZSArPSBjYXB0dXJlXG4gICAgfVxuICB9XG5cbiAgdmFyIGRlbGltaXRlciA9IGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCAnLycpXG4gIHZhciBlbmRzV2l0aERlbGltaXRlciA9IHJvdXRlLnNsaWNlKC1kZWxpbWl0ZXIubGVuZ3RoKSA9PT0gZGVsaW1pdGVyXG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cbiAgLy8gbWF0Y2ggYWxyZWFkeSBlbmRzIHdpdGggYSBzbGFzaCwgd2UgcmVtb3ZlIGl0IGZvciBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoXG4gIC8vIGlzIHZhbGlkIGF0IHRoZSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3QgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHJvdXRlID0gKGVuZHNXaXRoRGVsaW1pdGVyID8gcm91dGUuc2xpY2UoMCwgLWRlbGltaXRlci5sZW5ndGgpIDogcm91dGUpICsgJyg/OicgKyBkZWxpbWl0ZXIgKyAnKD89JCkpPydcbiAgfVxuXG4gIGlmIChlbmQpIHtcbiAgICByb3V0ZSArPSAnJCdcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBub24tZW5kaW5nIG1vZGUsIHdlIG5lZWQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaCBhc1xuICAgIC8vIHBvc3NpYmxlIGJ5IHVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkIHRvIHRoZSBlbmQgb3IgbmV4dCBwYXRoIHNlZ21lbnQuXG4gICAgcm91dGUgKz0gc3RyaWN0ICYmIGVuZHNXaXRoRGVsaW1pdGVyID8gJycgOiAnKD89JyArIGRlbGltaXRlciArICd8JCknXG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSksIGtleXMpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqXG4gKiBAcGFyYW0gIHsoc3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0gICAgICAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucylcbiAgICBrZXlzID0gW11cbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSlcbiAgfVxuXG4gIGlmIChpc2FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAoLyoqIEB0eXBlIHshQXJyYXl9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdUb1JlZ2V4cCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLyoqIVxuICogQGZpbGVPdmVydmlldyBLaWNrYXNzIGxpYnJhcnkgdG8gY3JlYXRlIGFuZCBwbGFjZSBwb3BwZXJzIG5lYXIgdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnRzLlxuICogQHZlcnNpb24gMS4xNS4wXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2IEZlZGVyaWNvIFppdm9sbyBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLlBvcHBlciA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbnZhciBsb25nZXJUaW1lb3V0QnJvd3NlcnMgPSBbJ0VkZ2UnLCAnVHJpZGVudCcsICdGaXJlZm94J107XG52YXIgdGltZW91dER1cmF0aW9uID0gMDtcbmZvciAodmFyIGkgPSAwOyBpIDwgbG9uZ2VyVGltZW91dEJyb3dzZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gIGlmIChpc0Jyb3dzZXIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKGxvbmdlclRpbWVvdXRCcm93c2Vyc1tpXSkgPj0gMCkge1xuICAgIHRpbWVvdXREdXJhdGlvbiA9IDE7XG4gICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWljcm90YXNrRGVib3VuY2UoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB3aW5kb3cuUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsZWQgPSBmYWxzZTtcbiAgICAgIGZuKCk7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRhc2tEZWJvdW5jZShmbikge1xuICB2YXIgc2NoZWR1bGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIGZuKCk7XG4gICAgICB9LCB0aW1lb3V0RHVyYXRpb24pO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHN1cHBvcnRzTWljcm9UYXNrcyA9IGlzQnJvd3NlciAmJiB3aW5kb3cuUHJvbWlzZTtcblxuLyoqXG4qIENyZWF0ZSBhIGRlYm91bmNlZCB2ZXJzaW9uIG9mIGEgbWV0aG9kLCB0aGF0J3MgYXN5bmNocm9ub3VzbHkgZGVmZXJyZWRcbiogYnV0IGNhbGxlZCBpbiB0aGUgbWluaW11bSB0aW1lIHBvc3NpYmxlLlxuKlxuKiBAbWV0aG9kXG4qIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiogQGFyZ3VtZW50IHtGdW5jdGlvbn0gZm5cbiogQHJldHVybnMge0Z1bmN0aW9ufVxuKi9cbnZhciBkZWJvdW5jZSA9IHN1cHBvcnRzTWljcm9UYXNrcyA/IG1pY3JvdGFza0RlYm91bmNlIDogdGFza0RlYm91bmNlO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FueX0gZnVuY3Rpb25Ub0NoZWNrIC0gdmFyaWFibGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSBhbnN3ZXIgdG86IGlzIGEgZnVuY3Rpb24/XG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuY3Rpb25Ub0NoZWNrKSB7XG4gIHZhciBnZXRUeXBlID0ge307XG4gIHJldHVybiBmdW5jdGlvblRvQ2hlY2sgJiYgZ2V0VHlwZS50b1N0cmluZy5jYWxsKGZ1bmN0aW9uVG9DaGVjaykgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogR2V0IENTUyBjb21wdXRlZCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwcm9wZXJ0eVxuICovXG5mdW5jdGlvbiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgdmFyIHdpbmRvdyA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgdmFyIGNzcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICByZXR1cm4gcHJvcGVydHkgPyBjc3NbcHJvcGVydHldIDogY3NzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhcmVudE5vZGUgb3IgdGhlIGhvc3Qgb2YgdGhlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHJldHVybiBlbGVtZW50LnBhcmVudE5vZGUgfHwgZWxlbWVudC5ob3N0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNjcm9sbGluZyBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IHNjcm9sbCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gUmV0dXJuIGJvZHksIGBnZXRTY3JvbGxgIHdpbGwgdGFrZSBjYXJlIHRvIGdldCB0aGUgY29ycmVjdCBgc2Nyb2xsVG9wYCBmcm9tIGl0XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgc3dpdGNoIChlbGVtZW50Lm5vZGVOYW1lKSB7XG4gICAgY2FzZSAnSFRNTCc6XG4gICAgY2FzZSAnQk9EWSc6XG4gICAgICByZXR1cm4gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgIHJldHVybiBlbGVtZW50LmJvZHk7XG4gIH1cblxuICAvLyBGaXJlZm94IHdhbnQgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcblxuICB2YXIgX2dldFN0eWxlQ29tcHV0ZWRQcm9wID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3csXG4gICAgICBvdmVyZmxvd1ggPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WTtcblxuICBpZiAoLyhhdXRvfHNjcm9sbHxvdmVybGF5KS8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG59XG5cbnZhciBpc0lFMTEgPSBpc0Jyb3dzZXIgJiYgISEod2luZG93Lk1TSW5wdXRNZXRob2RDb250ZXh0ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSk7XG52YXIgaXNJRTEwID0gaXNCcm93c2VyICYmIC9NU0lFIDEwLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGJyb3dzZXIgaXMgSW50ZXJuZXQgRXhwbG9yZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7TnVtYmVyfSB2ZXJzaW9uIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXNJRVxuICovXG5mdW5jdGlvbiBpc0lFKHZlcnNpb24pIHtcbiAgaWYgKHZlcnNpb24gPT09IDExKSB7XG4gICAgcmV0dXJuIGlzSUUxMTtcbiAgfVxuICBpZiAodmVyc2lvbiA9PT0gMTApIHtcbiAgICByZXR1cm4gaXNJRTEwO1xuICB9XG4gIHJldHVybiBpc0lFMTEgfHwgaXNJRTEwO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG9mZnNldCBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IG9mZnNldCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIHZhciBub09mZnNldFBhcmVudCA9IGlzSUUoMTApID8gZG9jdW1lbnQuYm9keSA6IG51bGw7XG5cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgdmFyIG9mZnNldFBhcmVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50IHx8IG51bGw7XG4gIC8vIFNraXAgaGlkZGVuIGVsZW1lbnRzIHdoaWNoIGRvbid0IGhhdmUgYW4gb2Zmc2V0UGFyZW50XG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgPT09IG5vT2Zmc2V0UGFyZW50ICYmIGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gKGVsZW1lbnQgPSBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZykub2Zmc2V0UGFyZW50O1xuICB9XG5cbiAgdmFyIG5vZGVOYW1lID0gb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudC5ub2RlTmFtZTtcblxuICBpZiAoIW5vZGVOYW1lIHx8IG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBlbGVtZW50ID8gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIC5vZmZzZXRQYXJlbnQgd2lsbCByZXR1cm4gdGhlIGNsb3Nlc3QgVEgsIFREIG9yIFRBQkxFIGluIGNhc2VcbiAgLy8gbm8gb2Zmc2V0UGFyZW50IGlzIHByZXNlbnQsIEkgaGF0ZSB0aGlzIGpvYi4uLlxuICBpZiAoWydUSCcsICdURCcsICdUQUJMRSddLmluZGV4T2Yob2Zmc2V0UGFyZW50Lm5vZGVOYW1lKSAhPT0gLTEgJiYgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KG9mZnNldFBhcmVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudDtcbn1cblxuZnVuY3Rpb24gaXNPZmZzZXRDb250YWluZXIoZWxlbWVudCkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ0hUTUwnIHx8IGdldE9mZnNldFBhcmVudChlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSA9PT0gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgcm9vdCBub2RlIChkb2N1bWVudCwgc2hhZG93RE9NIHJvb3QpIG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm5zIHtFbGVtZW50fSByb290IG5vZGVcbiAqL1xuZnVuY3Rpb24gZ2V0Um9vdChub2RlKSB7XG4gIGlmIChub2RlLnBhcmVudE5vZGUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZ2V0Um9vdChub2RlLnBhcmVudE5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIG9mZnNldCBwYXJlbnQgY29tbW9uIHRvIHRoZSB0d28gcHJvdmlkZWQgbm9kZXNcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudDFcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudDJcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBjb21tb24gb2Zmc2V0IHBhcmVudFxuICovXG5mdW5jdGlvbiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxLCBlbGVtZW50Mikge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgaWYgKCFlbGVtZW50MSB8fCAhZWxlbWVudDEubm9kZVR5cGUgfHwgIWVsZW1lbnQyIHx8ICFlbGVtZW50Mi5ub2RlVHlwZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyBIZXJlIHdlIG1ha2Ugc3VyZSB0byBnaXZlIGFzIFwic3RhcnRcIiB0aGUgZWxlbWVudCB0aGF0IGNvbWVzIGZpcnN0IGluIHRoZSBET01cbiAgdmFyIG9yZGVyID0gZWxlbWVudDEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZWxlbWVudDIpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc7XG4gIHZhciBzdGFydCA9IG9yZGVyID8gZWxlbWVudDEgOiBlbGVtZW50MjtcbiAgdmFyIGVuZCA9IG9yZGVyID8gZWxlbWVudDIgOiBlbGVtZW50MTtcblxuICAvLyBHZXQgY29tbW9uIGFuY2VzdG9yIGNvbnRhaW5lclxuICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICByYW5nZS5zZXRTdGFydChzdGFydCwgMCk7XG4gIHJhbmdlLnNldEVuZChlbmQsIDApO1xuICB2YXIgY29tbW9uQW5jZXN0b3JDb250YWluZXIgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcblxuICAvLyBCb3RoIG5vZGVzIGFyZSBpbnNpZGUgI2RvY3VtZW50XG5cbiAgaWYgKGVsZW1lbnQxICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lciAmJiBlbGVtZW50MiAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgfHwgc3RhcnQuY29udGFpbnMoZW5kKSkge1xuICAgIGlmIChpc09mZnNldENvbnRhaW5lcihjb21tb25BbmNlc3RvckNvbnRhaW5lcikpIHtcbiAgICAgIHJldHVybiBjb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKTtcbiAgfVxuXG4gIC8vIG9uZSBvZiB0aGUgbm9kZXMgaXMgaW5zaWRlIHNoYWRvd0RPTSwgZmluZCB3aGljaCBvbmVcbiAgdmFyIGVsZW1lbnQxcm9vdCA9IGdldFJvb3QoZWxlbWVudDEpO1xuICBpZiAoZWxlbWVudDFyb290Lmhvc3QpIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MXJvb3QuaG9zdCwgZWxlbWVudDIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxLCBnZXRSb290KGVsZW1lbnQyKS5ob3N0KTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIHNjcm9sbCB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBpbiB0aGUgZ2l2ZW4gc2lkZSAodG9wIGFuZCBsZWZ0KVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge1N0cmluZ30gc2lkZSBgdG9wYCBvciBgbGVmdGBcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGFtb3VudCBvZiBzY3JvbGxlZCBwaXhlbHNcbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsKGVsZW1lbnQpIHtcbiAgdmFyIHNpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICd0b3AnO1xuXG4gIHZhciB1cHBlclNpZGUgPSBzaWRlID09PSAndG9wJyA/ICdzY3JvbGxUb3AnIDogJ3Njcm9sbExlZnQnO1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICB2YXIgaHRtbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgdmFyIHNjcm9sbGluZ0VsZW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBodG1sO1xuICAgIHJldHVybiBzY3JvbGxpbmdFbGVtZW50W3VwcGVyU2lkZV07XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFt1cHBlclNpZGVdO1xufVxuXG4vKlxuICogU3VtIG9yIHN1YnRyYWN0IHRoZSBlbGVtZW50IHNjcm9sbCB2YWx1ZXMgKGxlZnQgYW5kIHRvcCkgZnJvbSBhIGdpdmVuIHJlY3Qgb2JqZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjdCAtIFJlY3Qgb2JqZWN0IHlvdSB3YW50IHRvIGNoYW5nZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IGZyb20gdGhlIGZ1bmN0aW9uIHJlYWRzIHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHN1YnRyYWN0IC0gc2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gc3VidHJhY3QgdGhlIHNjcm9sbCB2YWx1ZXNcbiAqIEByZXR1cm4ge09iamVjdH0gcmVjdCAtIFRoZSBtb2RpZmllciByZWN0IG9iamVjdFxuICovXG5mdW5jdGlvbiBpbmNsdWRlU2Nyb2xsKHJlY3QsIGVsZW1lbnQpIHtcbiAgdmFyIHN1YnRyYWN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICB2YXIgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICd0b3AnKTtcbiAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgdmFyIG1vZGlmaWVyID0gc3VidHJhY3QgPyAtMSA6IDE7XG4gIHJlY3QudG9wICs9IHNjcm9sbFRvcCAqIG1vZGlmaWVyO1xuICByZWN0LmJvdHRvbSArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5sZWZ0ICs9IHNjcm9sbExlZnQgKiBtb2RpZmllcjtcbiAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJldHVybiByZWN0O1xufVxuXG4vKlxuICogSGVscGVyIHRvIGRldGVjdCBib3JkZXJzIG9mIGEgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcbiAqIFJlc3VsdCBvZiBgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5YCBvbiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IGF4aXMgLSBgeGAgb3IgYHlgXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGJvcmRlcnMgLSBUaGUgYm9yZGVycyBzaXplIG9mIHRoZSBnaXZlbiBheGlzXG4gKi9cblxuZnVuY3Rpb24gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCBheGlzKSB7XG4gIHZhciBzaWRlQSA9IGF4aXMgPT09ICd4JyA/ICdMZWZ0JyA6ICdUb3AnO1xuICB2YXIgc2lkZUIgPSBzaWRlQSA9PT0gJ0xlZnQnID8gJ1JpZ2h0JyA6ICdCb3R0b20nO1xuXG4gIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlc1snYm9yZGVyJyArIHNpZGVBICsgJ1dpZHRoJ10sIDEwKSArIHBhcnNlRmxvYXQoc3R5bGVzWydib3JkZXInICsgc2lkZUIgKyAnV2lkdGgnXSwgMTApO1xufVxuXG5mdW5jdGlvbiBnZXRTaXplKGF4aXMsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KGJvZHlbJ29mZnNldCcgKyBheGlzXSwgYm9keVsnc2Nyb2xsJyArIGF4aXNdLCBodG1sWydjbGllbnQnICsgYXhpc10sIGh0bWxbJ29mZnNldCcgKyBheGlzXSwgaHRtbFsnc2Nyb2xsJyArIGF4aXNdLCBpc0lFKDEwKSA/IHBhcnNlSW50KGh0bWxbJ29mZnNldCcgKyBheGlzXSkgKyBwYXJzZUludChjb21wdXRlZFN0eWxlWydtYXJnaW4nICsgKGF4aXMgPT09ICdIZWlnaHQnID8gJ1RvcCcgOiAnTGVmdCcpXSkgKyBwYXJzZUludChjb21wdXRlZFN0eWxlWydtYXJnaW4nICsgKGF4aXMgPT09ICdIZWlnaHQnID8gJ0JvdHRvbScgOiAnUmlnaHQnKV0pIDogMCk7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1NpemVzKGRvY3VtZW50KSB7XG4gIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgdmFyIGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBjb21wdXRlZFN0eWxlID0gaXNJRSgxMCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShodG1sKTtcblxuICByZXR1cm4ge1xuICAgIGhlaWdodDogZ2V0U2l6ZSgnSGVpZ2h0JywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSksXG4gICAgd2lkdGg6IGdldFNpemUoJ1dpZHRoJywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSlcbiAgfTtcbn1cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbnZhciBjcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG5cblxuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEdpdmVuIGVsZW1lbnQgb2Zmc2V0cywgZ2VuZXJhdGUgYW4gb3V0cHV0IHNpbWlsYXIgdG8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gb2Zmc2V0c1xuICogQHJldHVybnMge09iamVjdH0gQ2xpZW50UmVjdCBsaWtlIG91dHB1dFxuICovXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0KG9mZnNldHMpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBvZmZzZXRzLCB7XG4gICAgcmlnaHQ6IG9mZnNldHMubGVmdCArIG9mZnNldHMud2lkdGgsXG4gICAgYm90dG9tOiBvZmZzZXRzLnRvcCArIG9mZnNldHMuaGVpZ2h0XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCBib3VuZGluZyBjbGllbnQgcmVjdCBvZiBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtPYmplY3R9IGNsaWVudCByZWN0XG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0ge307XG5cbiAgLy8gSUUxMCAxMCBGSVg6IFBsZWFzZSwgZG9uJ3QgYXNrLCB0aGUgZWxlbWVudCBpc24ndFxuICAvLyBjb25zaWRlcmVkIGluIERPTSBpbiBzb21lIGNpcmN1bXN0YW5jZXMuLi5cbiAgLy8gVGhpcyBpc24ndCByZXByb2R1Y2libGUgaW4gSUUxMCBjb21wYXRpYmlsaXR5IG1vZGUgb2YgSUUxMVxuICB0cnkge1xuICAgIGlmIChpc0lFKDEwKSkge1xuICAgICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICd0b3AnKTtcbiAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gICAgICByZWN0LnRvcCArPSBzY3JvbGxUb3A7XG4gICAgICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdDtcbiAgICAgIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSB7XG4gICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgIHRvcDogcmVjdC50b3AsXG4gICAgd2lkdGg6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gIH07XG5cbiAgLy8gc3VidHJhY3Qgc2Nyb2xsYmFyIHNpemUgZnJvbSBzaXplc1xuICB2YXIgc2l6ZXMgPSBlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcgPyBnZXRXaW5kb3dTaXplcyhlbGVtZW50Lm93bmVyRG9jdW1lbnQpIDoge307XG4gIHZhciB3aWR0aCA9IHNpemVzLndpZHRoIHx8IGVsZW1lbnQuY2xpZW50V2lkdGggfHwgcmVzdWx0LnJpZ2h0IC0gcmVzdWx0LmxlZnQ7XG4gIHZhciBoZWlnaHQgPSBzaXplcy5oZWlnaHQgfHwgZWxlbWVudC5jbGllbnRIZWlnaHQgfHwgcmVzdWx0LmJvdHRvbSAtIHJlc3VsdC50b3A7XG5cbiAgdmFyIGhvcml6U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRXaWR0aCAtIHdpZHRoO1xuICB2YXIgdmVydFNjcm9sbGJhciA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IC0gaGVpZ2h0O1xuXG4gIC8vIGlmIGFuIGh5cG90aGV0aWNhbCBzY3JvbGxiYXIgaXMgZGV0ZWN0ZWQsIHdlIG11c3QgYmUgc3VyZSBpdCdzIG5vdCBhIGBib3JkZXJgXG4gIC8vIHdlIG1ha2UgdGhpcyBjaGVjayBjb25kaXRpb25hbCBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICBpZiAoaG9yaXpTY3JvbGxiYXIgfHwgdmVydFNjcm9sbGJhcikge1xuICAgIHZhciBzdHlsZXMgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCk7XG4gICAgaG9yaXpTY3JvbGxiYXIgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAneCcpO1xuICAgIHZlcnRTY3JvbGxiYXIgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAneScpO1xuXG4gICAgcmVzdWx0LndpZHRoIC09IGhvcml6U2Nyb2xsYmFyO1xuICAgIHJlc3VsdC5oZWlnaHQgLT0gdmVydFNjcm9sbGJhcjtcbiAgfVxuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShjaGlsZHJlbiwgcGFyZW50KSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICB2YXIgaXNJRTEwID0gaXNJRSgxMCk7XG4gIHZhciBpc0hUTUwgPSBwYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJztcbiAgdmFyIGNoaWxkcmVuUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChjaGlsZHJlbik7XG4gIHZhciBwYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHBhcmVudCk7XG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoY2hpbGRyZW4pO1xuXG4gIHZhciBzdHlsZXMgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkocGFyZW50KTtcbiAgdmFyIGJvcmRlclRvcFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyVG9wV2lkdGgsIDEwKTtcbiAgdmFyIGJvcmRlckxlZnRXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlckxlZnRXaWR0aCwgMTApO1xuXG4gIC8vIEluIGNhc2VzIHdoZXJlIHRoZSBwYXJlbnQgaXMgZml4ZWQsIHdlIG11c3QgaWdub3JlIG5lZ2F0aXZlIHNjcm9sbCBpbiBvZmZzZXQgY2FsY1xuICBpZiAoZml4ZWRQb3NpdGlvbiAmJiBpc0hUTUwpIHtcbiAgICBwYXJlbnRSZWN0LnRvcCA9IE1hdGgubWF4KHBhcmVudFJlY3QudG9wLCAwKTtcbiAgICBwYXJlbnRSZWN0LmxlZnQgPSBNYXRoLm1heChwYXJlbnRSZWN0LmxlZnQsIDApO1xuICB9XG4gIHZhciBvZmZzZXRzID0gZ2V0Q2xpZW50UmVjdCh7XG4gICAgdG9wOiBjaGlsZHJlblJlY3QudG9wIC0gcGFyZW50UmVjdC50b3AgLSBib3JkZXJUb3BXaWR0aCxcbiAgICBsZWZ0OiBjaGlsZHJlblJlY3QubGVmdCAtIHBhcmVudFJlY3QubGVmdCAtIGJvcmRlckxlZnRXaWR0aCxcbiAgICB3aWR0aDogY2hpbGRyZW5SZWN0LndpZHRoLFxuICAgIGhlaWdodDogY2hpbGRyZW5SZWN0LmhlaWdodFxuICB9KTtcbiAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSAwO1xuICBvZmZzZXRzLm1hcmdpbkxlZnQgPSAwO1xuXG4gIC8vIFN1YnRyYWN0IG1hcmdpbnMgb2YgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgaXQncyBiZWluZyB1c2VkIGFzIHBhcmVudFxuICAvLyB3ZSBkbyB0aGlzIG9ubHkgb24gSFRNTCBiZWNhdXNlIGl0J3MgdGhlIG9ubHkgZWxlbWVudCB0aGF0IGJlaGF2ZXNcbiAgLy8gZGlmZmVyZW50bHkgd2hlbiBtYXJnaW5zIGFyZSBhcHBsaWVkIHRvIGl0LiBUaGUgbWFyZ2lucyBhcmUgaW5jbHVkZWQgaW5cbiAgLy8gdGhlIGJveCBvZiB0aGUgZG9jdW1lbnRFbGVtZW50LCBpbiB0aGUgb3RoZXIgY2FzZXMgbm90LlxuICBpZiAoIWlzSUUxMCAmJiBpc0hUTUwpIHtcbiAgICB2YXIgbWFyZ2luVG9wID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wLCAxMCk7XG4gICAgdmFyIG1hcmdpbkxlZnQgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5MZWZ0LCAxMCk7XG5cbiAgICBvZmZzZXRzLnRvcCAtPSBib3JkZXJUb3BXaWR0aCAtIG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLmJvdHRvbSAtPSBib3JkZXJUb3BXaWR0aCAtIG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLmxlZnQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcbiAgICBvZmZzZXRzLnJpZ2h0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG5cbiAgICAvLyBBdHRhY2ggbWFyZ2luVG9wIGFuZCBtYXJnaW5MZWZ0IGJlY2F1c2UgaW4gc29tZSBjaXJjdW1zdGFuY2VzIHdlIG1heSBuZWVkIHRoZW1cbiAgICBvZmZzZXRzLm1hcmdpblRvcCA9IG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLm1hcmdpbkxlZnQgPSBtYXJnaW5MZWZ0O1xuICB9XG5cbiAgaWYgKGlzSUUxMCAmJiAhZml4ZWRQb3NpdGlvbiA/IHBhcmVudC5jb250YWlucyhzY3JvbGxQYXJlbnQpIDogcGFyZW50ID09PSBzY3JvbGxQYXJlbnQgJiYgc2Nyb2xsUGFyZW50Lm5vZGVOYW1lICE9PSAnQk9EWScpIHtcbiAgICBvZmZzZXRzID0gaW5jbHVkZVNjcm9sbChvZmZzZXRzLCBwYXJlbnQpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShlbGVtZW50KSB7XG4gIHZhciBleGNsdWRlU2Nyb2xsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaHRtbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciByZWxhdGl2ZU9mZnNldCA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShlbGVtZW50LCBodG1sKTtcbiAgdmFyIHdpZHRoID0gTWF0aC5tYXgoaHRtbC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCk7XG4gIHZhciBoZWlnaHQgPSBNYXRoLm1heChodG1sLmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuXG4gIHZhciBzY3JvbGxUb3AgPSAhZXhjbHVkZVNjcm9sbCA/IGdldFNjcm9sbChodG1sKSA6IDA7XG4gIHZhciBzY3JvbGxMZWZ0ID0gIWV4Y2x1ZGVTY3JvbGwgPyBnZXRTY3JvbGwoaHRtbCwgJ2xlZnQnKSA6IDA7XG5cbiAgdmFyIG9mZnNldCA9IHtcbiAgICB0b3A6IHNjcm9sbFRvcCAtIHJlbGF0aXZlT2Zmc2V0LnRvcCArIHJlbGF0aXZlT2Zmc2V0Lm1hcmdpblRvcCxcbiAgICBsZWZ0OiBzY3JvbGxMZWZ0IC0gcmVsYXRpdmVPZmZzZXQubGVmdCArIHJlbGF0aXZlT2Zmc2V0Lm1hcmdpbkxlZnQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3Qob2Zmc2V0KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBmaXhlZCBvciBpcyBpbnNpZGUgYSBmaXhlZCBwYXJlbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBjdXN0b21Db250YWluZXJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBhbnN3ZXIgdG8gXCJpc0ZpeGVkP1wiXG4gKi9cbmZ1bmN0aW9uIGlzRml4ZWQoZWxlbWVudCkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCwgJ3Bvc2l0aW9uJykgPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIGlmICghcGFyZW50Tm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNGaXhlZChwYXJlbnROb2RlKTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgZmlyc3QgcGFyZW50IG9mIGFuIGVsZW1lbnQgdGhhdCBoYXMgYSB0cmFuc2Zvcm1lZCBwcm9wZXJ0eSBkZWZpbmVkXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBmaXJzdCB0cmFuc2Zvcm1lZCBwYXJlbnQgb3IgZG9jdW1lbnRFbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQucGFyZW50RWxlbWVudCB8fCBpc0lFKCkpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG4gIHZhciBlbCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgd2hpbGUgKGVsICYmIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbCwgJ3RyYW5zZm9ybScpID09PSAnbm9uZScpIHtcbiAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGVsIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbn1cblxuLyoqXG4gKiBDb21wdXRlZCB0aGUgYm91bmRhcmllcyBsaW1pdHMgYW5kIHJldHVybiB0aGVtXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmdcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50IC0gRWxlbWVudCB1c2VkIHRvIGRlZmluZSB0aGUgYm91bmRhcmllc1xuICogQHBhcmFtIHtCb29sZWFufSBmaXhlZFBvc2l0aW9uIC0gSXMgaW4gZml4ZWQgcG9zaXRpb24gbW9kZVxuICogQHJldHVybnMge09iamVjdH0gQ29vcmRpbmF0ZXMgb2YgdGhlIGJvdW5kYXJpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRhcmllcyhwb3BwZXIsIHJlZmVyZW5jZSwgcGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuXG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG5cbiAgdmFyIGJvdW5kYXJpZXMgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuICB2YXIgb2Zmc2V0UGFyZW50ID0gZml4ZWRQb3NpdGlvbiA/IGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQocG9wcGVyKSA6IGZpbmRDb21tb25PZmZzZXRQYXJlbnQocG9wcGVyLCByZWZlcmVuY2UpO1xuXG4gIC8vIEhhbmRsZSB2aWV3cG9ydCBjYXNlXG4gIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgIGJvdW5kYXJpZXMgPSBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUob2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBIYW5kbGUgb3RoZXIgY2FzZXMgYmFzZWQgb24gRE9NIGVsZW1lbnQgdXNlZCBhcyBib3VuZGFyaWVzXG4gICAgdmFyIGJvdW5kYXJpZXNOb2RlID0gdm9pZCAwO1xuICAgIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3Njcm9sbFBhcmVudCcpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUocmVmZXJlbmNlKSk7XG4gICAgICBpZiAoYm91bmRhcmllc05vZGUubm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgICAgICBib3VuZGFyaWVzTm9kZSA9IHBvcHBlci5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAnd2luZG93Jykge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gYm91bmRhcmllc0VsZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIG9mZnNldHMgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoYm91bmRhcmllc05vZGUsIG9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG5cbiAgICAvLyBJbiBjYXNlIG9mIEhUTUwsIHdlIG5lZWQgYSBkaWZmZXJlbnQgY29tcHV0YXRpb25cbiAgICBpZiAoYm91bmRhcmllc05vZGUubm9kZU5hbWUgPT09ICdIVE1MJyAmJiAhaXNGaXhlZChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICB2YXIgX2dldFdpbmRvd1NpemVzID0gZ2V0V2luZG93U2l6ZXMocG9wcGVyLm93bmVyRG9jdW1lbnQpLFxuICAgICAgICAgIGhlaWdodCA9IF9nZXRXaW5kb3dTaXplcy5oZWlnaHQsXG4gICAgICAgICAgd2lkdGggPSBfZ2V0V2luZG93U2l6ZXMud2lkdGg7XG5cbiAgICAgIGJvdW5kYXJpZXMudG9wICs9IG9mZnNldHMudG9wIC0gb2Zmc2V0cy5tYXJnaW5Ub3A7XG4gICAgICBib3VuZGFyaWVzLmJvdHRvbSA9IGhlaWdodCArIG9mZnNldHMudG9wO1xuICAgICAgYm91bmRhcmllcy5sZWZ0ICs9IG9mZnNldHMubGVmdCAtIG9mZnNldHMubWFyZ2luTGVmdDtcbiAgICAgIGJvdW5kYXJpZXMucmlnaHQgPSB3aWR0aCArIG9mZnNldHMubGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yIGFsbCB0aGUgb3RoZXIgRE9NIGVsZW1lbnRzLCB0aGlzIG9uZSBpcyBnb29kXG4gICAgICBib3VuZGFyaWVzID0gb2Zmc2V0cztcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgcGFkZGluZ3NcbiAgcGFkZGluZyA9IHBhZGRpbmcgfHwgMDtcbiAgdmFyIGlzUGFkZGluZ051bWJlciA9IHR5cGVvZiBwYWRkaW5nID09PSAnbnVtYmVyJztcbiAgYm91bmRhcmllcy5sZWZ0ICs9IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLmxlZnQgfHwgMDtcbiAgYm91bmRhcmllcy50b3AgKz0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcudG9wIHx8IDA7XG4gIGJvdW5kYXJpZXMucmlnaHQgLT0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcucmlnaHQgfHwgMDtcbiAgYm91bmRhcmllcy5ib3R0b20gLT0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcuYm90dG9tIHx8IDA7XG5cbiAgcmV0dXJuIGJvdW5kYXJpZXM7XG59XG5cbmZ1bmN0aW9uIGdldEFyZWEoX3JlZikge1xuICB2YXIgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQ7XG5cbiAgcmV0dXJuIHdpZHRoICogaGVpZ2h0O1xufVxuXG4vKipcbiAqIFV0aWxpdHkgdXNlZCB0byB0cmFuc2Zvcm0gdGhlIGBhdXRvYCBwbGFjZW1lbnQgdG8gdGhlIHBsYWNlbWVudCB3aXRoIG1vcmVcbiAqIGF2YWlsYWJsZSBzcGFjZS5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHBsYWNlbWVudCwgcmVmUmVjdCwgcG9wcGVyLCByZWZlcmVuY2UsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIHZhciBwYWRkaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiAwO1xuXG4gIGlmIChwbGFjZW1lbnQuaW5kZXhPZignYXV0bycpID09PSAtMSkge1xuICAgIHJldHVybiBwbGFjZW1lbnQ7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KTtcblxuICB2YXIgcmVjdHMgPSB7XG4gICAgdG9wOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogcmVmUmVjdC50b3AgLSBib3VuZGFyaWVzLnRvcFxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLnJpZ2h0IC0gcmVmUmVjdC5yaWdodCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5oZWlnaHRcbiAgICB9LFxuICAgIGJvdHRvbToge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuYm90dG9tIC0gcmVmUmVjdC5ib3R0b21cbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgIHdpZHRoOiByZWZSZWN0LmxlZnQgLSBib3VuZGFyaWVzLmxlZnQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfVxuICB9O1xuXG4gIHZhciBzb3J0ZWRBcmVhcyA9IE9iamVjdC5rZXlzKHJlY3RzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICBrZXk6IGtleVxuICAgIH0sIHJlY3RzW2tleV0sIHtcbiAgICAgIGFyZWE6IGdldEFyZWEocmVjdHNba2V5XSlcbiAgICB9KTtcbiAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLmFyZWEgLSBhLmFyZWE7XG4gIH0pO1xuXG4gIHZhciBmaWx0ZXJlZEFyZWFzID0gc29ydGVkQXJlYXMuZmlsdGVyKGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciB3aWR0aCA9IF9yZWYyLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfcmVmMi5oZWlnaHQ7XG4gICAgcmV0dXJuIHdpZHRoID49IHBvcHBlci5jbGllbnRXaWR0aCAmJiBoZWlnaHQgPj0gcG9wcGVyLmNsaWVudEhlaWdodDtcbiAgfSk7XG5cbiAgdmFyIGNvbXB1dGVkUGxhY2VtZW50ID0gZmlsdGVyZWRBcmVhcy5sZW5ndGggPiAwID8gZmlsdGVyZWRBcmVhc1swXS5rZXkgOiBzb3J0ZWRBcmVhc1swXS5rZXk7XG5cbiAgdmFyIHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIHJldHVybiBjb21wdXRlZFBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG59XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IHJlZmVyZW5jZSAtIHRoZSByZWZlcmVuY2UgZWxlbWVudCAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGZpeGVkUG9zaXRpb24gLSBpcyBpbiBmaXhlZCBwb3NpdGlvbiBtb2RlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb2Zmc2V0cyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlclxuICovXG5mdW5jdGlvbiBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICB2YXIgY29tbW9uT2Zmc2V0UGFyZW50ID0gZml4ZWRQb3NpdGlvbiA/IGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQocG9wcGVyKSA6IGZpbmRDb21tb25PZmZzZXRQYXJlbnQocG9wcGVyLCByZWZlcmVuY2UpO1xuICByZXR1cm4gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKHJlZmVyZW5jZSwgY29tbW9uT2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG91dGVyIHNpemVzIG9mIHRoZSBnaXZlbiBlbGVtZW50IChvZmZzZXQgc2l6ZSArIG1hcmdpbnMpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCBjb250YWluaW5nIHdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBnZXRPdXRlclNpemVzKGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICB2YXIgeCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCB8fCAwKSArIHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkJvdHRvbSB8fCAwKTtcbiAgdmFyIHkgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5MZWZ0IHx8IDApICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luUmlnaHQgfHwgMCk7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgd2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGggKyB5LFxuICAgIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHQgKyB4XG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgb2YgdGhlIGdpdmVuIG9uZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudFxuICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHZhciBoYXNoID0geyBsZWZ0OiAncmlnaHQnLCByaWdodDogJ2xlZnQnLCBib3R0b206ICd0b3AnLCB0b3A6ICdib3R0b20nIH07XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiAtIENTUyBwb3NpdGlvbiB0aGUgUG9wcGVyIHdpbGwgZ2V0IGFwcGxpZWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHMgLSB0aGUgcmVmZXJlbmNlIG9mZnNldHMgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHBhcmFtIHtTdHJpbmd9IHBsYWNlbWVudCAtIG9uZSBvZiB0aGUgdmFsaWQgcGxhY2VtZW50IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IHBvcHBlck9mZnNldHMgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb2Zmc2V0cyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlclxuICovXG5mdW5jdGlvbiBnZXRQb3BwZXJPZmZzZXRzKHBvcHBlciwgcmVmZXJlbmNlT2Zmc2V0cywgcGxhY2VtZW50KSB7XG4gIHBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIC8vIEdldCBwb3BwZXIgbm9kZSBzaXplc1xuICB2YXIgcG9wcGVyUmVjdCA9IGdldE91dGVyU2l6ZXMocG9wcGVyKTtcblxuICAvLyBBZGQgcG9zaXRpb24sIHdpZHRoIGFuZCBoZWlnaHQgdG8gb3VyIG9mZnNldHMgb2JqZWN0XG4gIHZhciBwb3BwZXJPZmZzZXRzID0ge1xuICAgIHdpZHRoOiBwb3BwZXJSZWN0LndpZHRoLFxuICAgIGhlaWdodDogcG9wcGVyUmVjdC5oZWlnaHRcbiAgfTtcblxuICAvLyBkZXBlbmRpbmcgYnkgdGhlIHBvcHBlciBwbGFjZW1lbnQgd2UgaGF2ZSB0byBjb21wdXRlIGl0cyBvZmZzZXRzIHNsaWdodGx5IGRpZmZlcmVudGx5XG4gIHZhciBpc0hvcml6ID0gWydyaWdodCcsICdsZWZ0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIG1haW5TaWRlID0gaXNIb3JpeiA/ICd0b3AnIDogJ2xlZnQnO1xuICB2YXIgc2Vjb25kYXJ5U2lkZSA9IGlzSG9yaXogPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG1lYXN1cmVtZW50ID0gaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgdmFyIHNlY29uZGFyeU1lYXN1cmVtZW50ID0gIWlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgcG9wcGVyT2Zmc2V0c1ttYWluU2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW21haW5TaWRlXSArIHJlZmVyZW5jZU9mZnNldHNbbWVhc3VyZW1lbnRdIC8gMiAtIHBvcHBlclJlY3RbbWVhc3VyZW1lbnRdIC8gMjtcbiAgaWYgKHBsYWNlbWVudCA9PT0gc2Vjb25kYXJ5U2lkZSkge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW3NlY29uZGFyeVNpZGVdIC0gcG9wcGVyUmVjdFtzZWNvbmRhcnlNZWFzdXJlbWVudF07XG4gIH0gZWxzZSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQoc2Vjb25kYXJ5U2lkZSldO1xuICB9XG5cbiAgcmV0dXJuIHBvcHBlck9mZnNldHM7XG59XG5cbi8qKlxuICogTWltaWNzIHRoZSBgZmluZGAgbWV0aG9kIG9mIEFycmF5XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FycmF5fSBhcnJcbiAqIEBhcmd1bWVudCBwcm9wXG4gKiBAYXJndW1lbnQgdmFsdWVcbiAqIEByZXR1cm5zIGluZGV4IG9yIC0xXG4gKi9cbmZ1bmN0aW9uIGZpbmQoYXJyLCBjaGVjaykge1xuICAvLyB1c2UgbmF0aXZlIGZpbmQgaWYgc3VwcG9ydGVkXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmluZCkge1xuICAgIHJldHVybiBhcnIuZmluZChjaGVjayk7XG4gIH1cblxuICAvLyB1c2UgYGZpbHRlcmAgdG8gb2J0YWluIHRoZSBzYW1lIGJlaGF2aW9yIG9mIGBmaW5kYFxuICByZXR1cm4gYXJyLmZpbHRlcihjaGVjaylbMF07XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hpbmcgb2JqZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FycmF5fSBhcnJcbiAqIEBhcmd1bWVudCBwcm9wXG4gKiBAYXJndW1lbnQgdmFsdWVcbiAqIEByZXR1cm5zIGluZGV4IG9yIC0xXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnIsIHByb3AsIHZhbHVlKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZEluZGV4IGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCkge1xuICAgIHJldHVybiBhcnIuZmluZEluZGV4KGZ1bmN0aW9uIChjdXIpIHtcbiAgICAgIHJldHVybiBjdXJbcHJvcF0gPT09IHZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gdXNlIGBmaW5kYCArIGBpbmRleE9mYCBpZiBgZmluZEluZGV4YCBpc24ndCBzdXBwb3J0ZWRcbiAgdmFyIG1hdGNoID0gZmluZChhcnIsIGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqW3Byb3BdID09PSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBhcnIuaW5kZXhPZihtYXRjaCk7XG59XG5cbi8qKlxuICogTG9vcCB0cm91Z2ggdGhlIGxpc3Qgb2YgbW9kaWZpZXJzIGFuZCBydW4gdGhlbSBpbiBvcmRlcixcbiAqIGVhY2ggb2YgdGhlbSB3aWxsIHRoZW4gZWRpdCB0aGUgZGF0YSBvYmplY3QuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVyc1xuICogQHBhcmFtIHtTdHJpbmd9IGVuZHMgLSBPcHRpb25hbCBtb2RpZmllciBuYW1lIHVzZWQgYXMgc3RvcHBlclxuICogQHJldHVybnMge2RhdGFPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHJ1bk1vZGlmaWVycyhtb2RpZmllcnMsIGRhdGEsIGVuZHMpIHtcbiAgdmFyIG1vZGlmaWVyc1RvUnVuID0gZW5kcyA9PT0gdW5kZWZpbmVkID8gbW9kaWZpZXJzIDogbW9kaWZpZXJzLnNsaWNlKDAsIGZpbmRJbmRleChtb2RpZmllcnMsICduYW1lJywgZW5kcykpO1xuXG4gIG1vZGlmaWVyc1RvUnVuLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKG1vZGlmaWVyWydmdW5jdGlvbiddKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgICAgY29uc29sZS53YXJuKCdgbW9kaWZpZXIuZnVuY3Rpb25gIGlzIGRlcHJlY2F0ZWQsIHVzZSBgbW9kaWZpZXIuZm5gIScpO1xuICAgIH1cbiAgICB2YXIgZm4gPSBtb2RpZmllclsnZnVuY3Rpb24nXSB8fCBtb2RpZmllci5mbjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICBpZiAobW9kaWZpZXIuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgLy8gQWRkIHByb3BlcnRpZXMgdG8gb2Zmc2V0cyB0byBtYWtlIHRoZW0gYSBjb21wbGV0ZSBjbGllbnRSZWN0IG9iamVjdFxuICAgICAgLy8gd2UgZG8gdGhpcyBiZWZvcmUgZWFjaCBtb2RpZmllciB0byBtYWtlIHN1cmUgdGhlIHByZXZpb3VzIG9uZSBkb2Vzbid0XG4gICAgICAvLyBtZXNzIHdpdGggdGhlc2UgdmFsdWVzXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcbiAgICAgIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UpO1xuXG4gICAgICBkYXRhID0gZm4oZGF0YSwgbW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHBvcHBlciwgY29tcHV0aW5nIHRoZSBuZXcgb2Zmc2V0cyBhbmQgYXBwbHlpbmdcbiAqIHRoZSBuZXcgc3R5bGUuPGJyIC8+XG4gKiBQcmVmZXIgYHNjaGVkdWxlVXBkYXRlYCBvdmVyIGB1cGRhdGVgIGJlY2F1c2Ugb2YgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gdXBkYXRlKCkge1xuICAvLyBpZiBwb3BwZXIgaXMgZGVzdHJveWVkLCBkb24ndCBwZXJmb3JtIGFueSBmdXJ0aGVyIHVwZGF0ZVxuICBpZiAodGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkYXRhID0ge1xuICAgIGluc3RhbmNlOiB0aGlzLFxuICAgIHN0eWxlczoge30sXG4gICAgYXJyb3dTdHlsZXM6IHt9LFxuICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgIGZsaXBwZWQ6IGZhbHNlLFxuICAgIG9mZnNldHM6IHt9XG4gIH07XG5cbiAgLy8gY29tcHV0ZSByZWZlcmVuY2UgZWxlbWVudCBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHRoaXMuc3RhdGUsIHRoaXMucG9wcGVyLCB0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIGNvbXB1dGUgYXV0byBwbGFjZW1lbnQsIHN0b3JlIHBsYWNlbWVudCBpbnNpZGUgdGhlIGRhdGEgb2JqZWN0LFxuICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gIC8vIGFuZCByZWZlciB0byBvcmlnaW5hbFBsYWNlbWVudCB0byBrbm93IHRoZSBvcmlnaW5hbCB2YWx1ZVxuICBkYXRhLnBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KHRoaXMub3B0aW9ucy5wbGFjZW1lbnQsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIHRoaXMucG9wcGVyLCB0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LCB0aGlzLm9wdGlvbnMubW9kaWZpZXJzLmZsaXAucGFkZGluZyk7XG5cbiAgLy8gc3RvcmUgdGhlIGNvbXB1dGVkIHBsYWNlbWVudCBpbnNpZGUgYG9yaWdpbmFsUGxhY2VtZW50YFxuICBkYXRhLm9yaWdpbmFsUGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG5cbiAgZGF0YS5wb3NpdGlvbkZpeGVkID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQ7XG5cbiAgLy8gY29tcHV0ZSB0aGUgcG9wcGVyIG9mZnNldHNcbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldFBvcHBlck9mZnNldHModGhpcy5wb3BwZXIsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KTtcblxuICBkYXRhLm9mZnNldHMucG9wcGVyLnBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJztcblxuICAvLyBydW4gdGhlIG1vZGlmaWVyc1xuICBkYXRhID0gcnVuTW9kaWZpZXJzKHRoaXMubW9kaWZpZXJzLCBkYXRhKTtcblxuICAvLyB0aGUgZmlyc3QgYHVwZGF0ZWAgd2lsbCBjYWxsIGBvbkNyZWF0ZWAgY2FsbGJhY2tcbiAgLy8gdGhlIG90aGVyIG9uZXMgd2lsbCBjYWxsIGBvblVwZGF0ZWAgY2FsbGJhY2tcbiAgaWYgKCF0aGlzLnN0YXRlLmlzQ3JlYXRlZCkge1xuICAgIHRoaXMuc3RhdGUuaXNDcmVhdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMub25DcmVhdGUoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHRpb25zLm9uVXBkYXRlKGRhdGEpO1xuICB9XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgaXMgZW5hYmxlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc01vZGlmaWVyRW5hYmxlZChtb2RpZmllcnMsIG1vZGlmaWVyTmFtZSkge1xuICByZXR1cm4gbW9kaWZpZXJzLnNvbWUoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgZW5hYmxlZCA9IF9yZWYuZW5hYmxlZDtcbiAgICByZXR1cm4gZW5hYmxlZCAmJiBuYW1lID09PSBtb2RpZmllck5hbWU7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJlZml4ZWQgc3VwcG9ydGVkIHByb3BlcnR5IG5hbWVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwcm9wZXJ0eSAoY2FtZWxDYXNlKVxuICogQHJldHVybnMge1N0cmluZ30gcHJlZml4ZWQgcHJvcGVydHkgKGNhbWVsQ2FzZSBvciBQYXNjYWxDYXNlLCBkZXBlbmRpbmcgb24gdGhlIHZlbmRvciBwcmVmaXgpXG4gKi9cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZShwcm9wZXJ0eSkge1xuICB2YXIgcHJlZml4ZXMgPSBbZmFsc2UsICdtcycsICdXZWJraXQnLCAnTW96JywgJ08nXTtcbiAgdmFyIHVwcGVyUHJvcCA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcmVmaXggPSBwcmVmaXhlc1tpXTtcbiAgICB2YXIgdG9DaGVjayA9IHByZWZpeCA/ICcnICsgcHJlZml4ICsgdXBwZXJQcm9wIDogcHJvcGVydHk7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudC5ib2R5LnN0eWxlW3RvQ2hlY2tdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRvQ2hlY2s7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIERlc3Ryb3lzIHRoZSBwb3BwZXIuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gIHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQgPSB0cnVlO1xuXG4gIC8vIHRvdWNoIERPTSBvbmx5IGlmIGBhcHBseVN0eWxlYCBtb2RpZmllciBpcyBlbmFibGVkXG4gIGlmIChpc01vZGlmaWVyRW5hYmxlZCh0aGlzLm1vZGlmaWVycywgJ2FwcGx5U3R5bGUnKSkge1xuICAgIHRoaXMucG9wcGVyLnJlbW92ZUF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnKTtcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5wb3NpdGlvbiA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnRvcCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLmxlZnQgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5yaWdodCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLmJvdHRvbSA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLndpbGxDaGFuZ2UgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZVtnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpXSA9ICcnO1xuICB9XG5cbiAgdGhpcy5kaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAvLyByZW1vdmUgdGhlIHBvcHBlciBpZiB1c2VyIGV4cGxpY2l0eSBhc2tlZCBmb3IgdGhlIGRlbGV0aW9uIG9uIGRlc3Ryb3lcbiAgLy8gZG8gbm90IHVzZSBgcmVtb3ZlYCBiZWNhdXNlIElFMTEgZG9lc24ndCBzdXBwb3J0IGl0XG4gIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlT25EZXN0cm95KSB7XG4gICAgdGhpcy5wb3BwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHBlcik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogR2V0IHRoZSB3aW5kb3cgYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50XG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtXaW5kb3d9XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyhlbGVtZW50KSB7XG4gIHZhciBvd25lckRvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICByZXR1cm4gb3duZXJEb2N1bWVudCA/IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiB3aW5kb3c7XG59XG5cbmZ1bmN0aW9uIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxQYXJlbnQsIGV2ZW50LCBjYWxsYmFjaywgc2Nyb2xsUGFyZW50cykge1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50Lm5vZGVOYW1lID09PSAnQk9EWSc7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBzY3JvbGxQYXJlbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHNjcm9sbFBhcmVudDtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgaWYgKCFpc0JvZHkpIHtcbiAgICBhdHRhY2hUb1Njcm9sbFBhcmVudHMoZ2V0U2Nyb2xsUGFyZW50KHRhcmdldC5wYXJlbnROb2RlKSwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKTtcbiAgfVxuICBzY3JvbGxQYXJlbnRzLnB1c2godGFyZ2V0KTtcbn1cblxuLyoqXG4gKiBTZXR1cCBuZWVkZWQgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldHVwRXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBvcHRpb25zLCBzdGF0ZSwgdXBkYXRlQm91bmQpIHtcbiAgLy8gUmVzaXplIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvd1xuICBzdGF0ZS51cGRhdGVCb3VuZCA9IHVwZGF0ZUJvdW5kO1xuICBnZXRXaW5kb3cocmVmZXJlbmNlKS5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gIC8vIFNjcm9sbCBldmVudCBsaXN0ZW5lciBvbiBzY3JvbGwgcGFyZW50c1xuICB2YXIgc2Nyb2xsRWxlbWVudCA9IGdldFNjcm9sbFBhcmVudChyZWZlcmVuY2UpO1xuICBhdHRhY2hUb1Njcm9sbFBhcmVudHMoc2Nyb2xsRWxlbWVudCwgJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kLCBzdGF0ZS5zY3JvbGxQYXJlbnRzKTtcbiAgc3RhdGUuc2Nyb2xsRWxlbWVudCA9IHNjcm9sbEVsZW1lbnQ7XG4gIHN0YXRlLmV2ZW50c0VuYWJsZWQgPSB0cnVlO1xuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIGFkZCByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgc3RhcnQgcmVjYWxjdWxhdGluZ1xuICogcG9zaXRpb24gb2YgdGhlIHBvcHBlciBlbGVtZW50IHdoZW4gdGhleSBhcmUgdHJpZ2dlcmVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKCF0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICB0aGlzLnN0YXRlID0gc2V0dXBFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLCB0aGlzLnN0YXRlLCB0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBzdGF0ZSkge1xuICAvLyBSZW1vdmUgcmVzaXplIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvd1xuICBnZXRXaW5kb3cocmVmZXJlbmNlKS5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG5cbiAgLy8gUmVtb3ZlIHNjcm9sbCBldmVudCBsaXN0ZW5lciBvbiBzY3JvbGwgcGFyZW50c1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG4gIH0pO1xuXG4gIC8vIFJlc2V0IHN0YXRlXG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gbnVsbDtcbiAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IFtdO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGZhbHNlO1xuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogSXQgd2lsbCByZW1vdmUgcmVzaXplL3Njcm9sbCBldmVudHMgYW5kIHdvbid0IHJlY2FsY3VsYXRlIHBvcHBlciBwb3NpdGlvblxuICogd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuIEl0IGFsc28gd29uJ3QgdHJpZ2dlciBgb25VcGRhdGVgIGNhbGxiYWNrIGFueW1vcmUsXG4gKiB1bmxlc3MgeW91IGNhbGwgYHVwZGF0ZWAgbWV0aG9kIG1hbnVhbGx5LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICh0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgICB0aGlzLnN0YXRlID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMuc3RhdGUpO1xuICB9XG59XG5cbi8qKlxuICogVGVsbHMgaWYgYSBnaXZlbiBpbnB1dCBpcyBhIG51bWJlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHsqfSBpbnB1dCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcbiAgcmV0dXJuIG4gIT09ICcnICYmICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHN0eWxlIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIHN0eWxlIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRTdHlsZXMoZWxlbWVudCwgc3R5bGVzKSB7XG4gIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB1bml0ID0gJyc7XG4gICAgLy8gYWRkIHVuaXQgaWYgdGhlIHZhbHVlIGlzIG51bWVyaWMgYW5kIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nXG4gICAgaWYgKFsnd2lkdGgnLCAnaGVpZ2h0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLmluZGV4T2YocHJvcCkgIT09IC0xICYmIGlzTnVtZXJpYyhzdHlsZXNbcHJvcF0pKSB7XG4gICAgICB1bml0ID0gJ3B4JztcbiAgICB9XG4gICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHN0eWxlc1twcm9wXSArIHVuaXQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgYXR0cmlidXRlcyB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBhdHRyaWJ1dGVzIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUocHJvcCwgYXR0cmlidXRlc1twcm9wXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5zdHlsZXMgLSBMaXN0IG9mIHN0eWxlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLmF0dHJpYnV0ZXMgLSBMaXN0IG9mIGF0dHJpYnV0ZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgc2FtZSBkYXRhIG9iamVjdFxuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlKGRhdGEpIHtcbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuc3R5bGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gaW4gdGhpcyB3YXkgd2UgY2FuIG1ha2UgdGhlIDNyZCBwYXJ0eSBtb2RpZmllcnMgYWRkIGN1c3RvbSBzdHlsZXMgdG8gaXRcbiAgLy8gQmUgYXdhcmUsIG1vZGlmaWVycyBjb3VsZCBvdmVycmlkZSB0aGUgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoZSBwcmV2aW91c1xuICAvLyBsaW5lcyBvZiB0aGlzIG1vZGlmaWVyIVxuICBzZXRTdHlsZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuc3R5bGVzKTtcblxuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5hdHRyaWJ1dGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gdGhleSB3aWxsIGJlIHNldCBhcyBIVE1MIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnRcbiAgc2V0QXR0cmlidXRlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5hdHRyaWJ1dGVzKTtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgZGVmaW5lZCBhbmQgYXJyb3dTdHlsZXMgaGFzIHNvbWUgcHJvcGVydGllc1xuICBpZiAoZGF0YS5hcnJvd0VsZW1lbnQgJiYgT2JqZWN0LmtleXMoZGF0YS5hcnJvd1N0eWxlcykubGVuZ3RoKSB7XG4gICAgc2V0U3R5bGVzKGRhdGEuYXJyb3dFbGVtZW50LCBkYXRhLmFycm93U3R5bGVzKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFNldCB0aGUgeC1wbGFjZW1lbnQgYXR0cmlidXRlIGJlZm9yZSBldmVyeXRoaW5nIGVsc2UgYmVjYXVzZSBpdCBjb3VsZCBiZSB1c2VkXG4gKiB0byBhZGQgbWFyZ2lucyB0byB0aGUgcG9wcGVyIG1hcmdpbnMgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZCB0byBnZXQgdGhlXG4gKiBjb3JyZWN0IHBvcHBlciBvZmZzZXRzLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5tb2RpZmllcnNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUG9wcGVyLmpzIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZU9uTG9hZChyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBzdGF0ZSkge1xuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgdmFyIHJlZmVyZW5jZU9mZnNldHMgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgdmFyIHBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KG9wdGlvbnMucGxhY2VtZW50LCByZWZlcmVuY2VPZmZzZXRzLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICBwb3BwZXIuc2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcsIHBsYWNlbWVudCk7XG5cbiAgLy8gQXBwbHkgYHBvc2l0aW9uYCB0byBwb3BwZXIgYmVmb3JlIGFueXRoaW5nIGVsc2UgYmVjYXVzZVxuICAvLyB3aXRob3V0IHRoZSBwb3NpdGlvbiBhcHBsaWVkIHdlIGNhbid0IGd1YXJhbnRlZSBjb3JyZWN0IGNvbXB1dGF0aW9uc1xuICBzZXRTdHlsZXMocG9wcGVyLCB7IHBvc2l0aW9uOiBvcHRpb25zLnBvc2l0aW9uRml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJyB9KTtcblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7Qm9vbGVhbn0gc2hvdWxkUm91bmQgLSBJZiB0aGUgb2Zmc2V0cyBzaG91bGQgYmUgcm91bmRlZCBhdCBhbGxcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwb3BwZXIncyBwb3NpdGlvbiBvZmZzZXRzIHJvdW5kZWRcbiAqXG4gKiBUaGUgdGFsZSBvZiBwaXhlbC1wZXJmZWN0IHBvc2l0aW9uaW5nLiBJdCdzIHN0aWxsIG5vdCAxMDAlIHBlcmZlY3QsIGJ1dCBhc1xuICogZ29vZCBhcyBpdCBjYW4gYmUgd2l0aGluIHJlYXNvbi5cbiAqIERpc2N1c3Npb24gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvcHVsbC83MTVcbiAqXG4gKiBMb3cgRFBJIHNjcmVlbnMgY2F1c2UgYSBwb3BwZXIgdG8gYmUgYmx1cnJ5IGlmIG5vdCB1c2luZyBmdWxsIHBpeGVscyAoU2FmYXJpXG4gKiBhcyB3ZWxsIG9uIEhpZ2ggRFBJIHNjcmVlbnMpLlxuICpcbiAqIEZpcmVmb3ggcHJlZmVycyBubyByb3VuZGluZyBmb3IgcG9zaXRpb25pbmcgYW5kIGRvZXMgbm90IGhhdmUgYmx1cnJpbmVzcyBvblxuICogaGlnaCBEUEkgc2NyZWVucy5cbiAqXG4gKiBPbmx5IGhvcml6b250YWwgcGxhY2VtZW50IGFuZCBsZWZ0L3JpZ2h0IHZhbHVlcyBuZWVkIHRvIGJlIGNvbnNpZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIGdldFJvdW5kZWRPZmZzZXRzKGRhdGEsIHNob3VsZFJvdW5kKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZCxcbiAgICAgIGZsb29yID0gTWF0aC5mbG9vcjtcblxuICB2YXIgbm9Sb3VuZCA9IGZ1bmN0aW9uIG5vUm91bmQodikge1xuICAgIHJldHVybiB2O1xuICB9O1xuXG4gIHZhciByZWZlcmVuY2VXaWR0aCA9IHJvdW5kKHJlZmVyZW5jZS53aWR0aCk7XG4gIHZhciBwb3BwZXJXaWR0aCA9IHJvdW5kKHBvcHBlci53aWR0aCk7XG5cbiAgdmFyIGlzVmVydGljYWwgPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGRhdGEucGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBpc1ZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LmluZGV4T2YoJy0nKSAhPT0gLTE7XG4gIHZhciBzYW1lV2lkdGhQYXJpdHkgPSByZWZlcmVuY2VXaWR0aCAlIDIgPT09IHBvcHBlcldpZHRoICUgMjtcbiAgdmFyIGJvdGhPZGRXaWR0aCA9IHJlZmVyZW5jZVdpZHRoICUgMiA9PT0gMSAmJiBwb3BwZXJXaWR0aCAlIDIgPT09IDE7XG5cbiAgdmFyIGhvcml6b250YWxUb0ludGVnZXIgPSAhc2hvdWxkUm91bmQgPyBub1JvdW5kIDogaXNWZXJ0aWNhbCB8fCBpc1ZhcmlhdGlvbiB8fCBzYW1lV2lkdGhQYXJpdHkgPyByb3VuZCA6IGZsb29yO1xuICB2YXIgdmVydGljYWxUb0ludGVnZXIgPSAhc2hvdWxkUm91bmQgPyBub1JvdW5kIDogcm91bmQ7XG5cbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBob3Jpem9udGFsVG9JbnRlZ2VyKGJvdGhPZGRXaWR0aCAmJiAhaXNWYXJpYXRpb24gJiYgc2hvdWxkUm91bmQgPyBwb3BwZXIubGVmdCAtIDEgOiBwb3BwZXIubGVmdCksXG4gICAgdG9wOiB2ZXJ0aWNhbFRvSW50ZWdlcihwb3BwZXIudG9wKSxcbiAgICBib3R0b206IHZlcnRpY2FsVG9JbnRlZ2VyKHBvcHBlci5ib3R0b20pLFxuICAgIHJpZ2h0OiBob3Jpem9udGFsVG9JbnRlZ2VyKHBvcHBlci5yaWdodClcbiAgfTtcbn1cblxudmFyIGlzRmlyZWZveCA9IGlzQnJvd3NlciAmJiAvRmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZShkYXRhLCBvcHRpb25zKSB7XG4gIHZhciB4ID0gb3B0aW9ucy54LFxuICAgICAgeSA9IG9wdGlvbnMueTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgLy8gUmVtb3ZlIHRoaXMgbGVnYWN5IHN1cHBvcnQgaW4gUG9wcGVyLmpzIHYyXG5cbiAgdmFyIGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA9IGZpbmQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSAnYXBwbHlTdHlsZSc7XG4gIH0pLmdwdUFjY2VsZXJhdGlvbjtcbiAgaWYgKGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgZ3B1QWNjZWxlcmF0aW9uYCBvcHRpb24gbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXIgYW5kIHdpbGwgbm90IGJlIHN1cHBvcnRlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgUG9wcGVyLmpzIScpO1xuICB9XG4gIHZhciBncHVBY2NlbGVyYXRpb24gPSBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gIT09IHVuZGVmaW5lZCA/IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA6IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uO1xuXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgb2Zmc2V0UGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuXG4gIC8vIFN0eWxlc1xuICB2YXIgc3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiBwb3BwZXIucG9zaXRpb25cbiAgfTtcblxuICB2YXIgb2Zmc2V0cyA9IGdldFJvdW5kZWRPZmZzZXRzKGRhdGEsIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDwgMiB8fCAhaXNGaXJlZm94KTtcblxuICB2YXIgc2lkZUEgPSB4ID09PSAnYm90dG9tJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gIHZhciBzaWRlQiA9IHkgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuXG4gIC8vIGlmIGdwdUFjY2VsZXJhdGlvbiBpcyBzZXQgdG8gYHRydWVgIGFuZCB0cmFuc2Zvcm0gaXMgc3VwcG9ydGVkLFxuICAvLyAgd2UgdXNlIGB0cmFuc2xhdGUzZGAgdG8gYXBwbHkgdGhlIHBvc2l0aW9uIHRvIHRoZSBwb3BwZXIgd2VcbiAgLy8gYXV0b21hdGljYWxseSB1c2UgdGhlIHN1cHBvcnRlZCBwcmVmaXhlZCB2ZXJzaW9uIGlmIG5lZWRlZFxuICB2YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyk7XG5cbiAgLy8gbm93LCBsZXQncyBtYWtlIGEgc3RlcCBiYWNrIGFuZCBsb29rIGF0IHRoaXMgY29kZSBjbG9zZWx5ICh3dGY/KVxuICAvLyBJZiB0aGUgY29udGVudCBvZiB0aGUgcG9wcGVyIGdyb3dzIG9uY2UgaXQncyBiZWVuIHBvc2l0aW9uZWQsIGl0XG4gIC8vIG1heSBoYXBwZW4gdGhhdCB0aGUgcG9wcGVyIGdldHMgbWlzcGxhY2VkIGJlY2F1c2Ugb2YgdGhlIG5ldyBjb250ZW50XG4gIC8vIG92ZXJmbG93aW5nIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUbyBhdm9pZCB0aGlzIHByb2JsZW0sIHdlIHByb3ZpZGUgdHdvIG9wdGlvbnMgKHggYW5kIHkpLCB3aGljaCBhbGxvd1xuICAvLyB0aGUgY29uc3VtZXIgdG8gZGVmaW5lIHRoZSBvZmZzZXQgb3JpZ2luLlxuICAvLyBJZiB3ZSBwb3NpdGlvbiBhIHBvcHBlciBvbiB0b3Agb2YgYSByZWZlcmVuY2UgZWxlbWVudCwgd2UgY2FuIHNldFxuICAvLyBgeGAgdG8gYHRvcGAgdG8gbWFrZSB0aGUgcG9wcGVyIGdyb3cgdG93YXJkcyBpdHMgdG9wIGluc3RlYWQgb2ZcbiAgLy8gaXRzIGJvdHRvbS5cbiAgdmFyIGxlZnQgPSB2b2lkIDAsXG4gICAgICB0b3AgPSB2b2lkIDA7XG4gIGlmIChzaWRlQSA9PT0gJ2JvdHRvbScpIHtcbiAgICAvLyB3aGVuIG9mZnNldFBhcmVudCBpcyA8aHRtbD4gdGhlIHBvc2l0aW9uaW5nIGlzIHJlbGF0aXZlIHRvIHRoZSBib3R0b20gb2YgdGhlIHNjcmVlbiAoZXhjbHVkaW5nIHRoZSBzY3JvbGxiYXIpXG4gICAgLy8gYW5kIG5vdCB0aGUgYm90dG9tIG9mIHRoZSBodG1sIGVsZW1lbnRcbiAgICBpZiAob2Zmc2V0UGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgIHRvcCA9IC1vZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcCA9IC1vZmZzZXRQYXJlbnRSZWN0LmhlaWdodCArIG9mZnNldHMuYm90dG9tO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0b3AgPSBvZmZzZXRzLnRvcDtcbiAgfVxuICBpZiAoc2lkZUIgPT09ICdyaWdodCcpIHtcbiAgICBpZiAob2Zmc2V0UGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgIGxlZnQgPSAtb2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IC1vZmZzZXRQYXJlbnRSZWN0LndpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGVmdCA9IG9mZnNldHMubGVmdDtcbiAgfVxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uICYmIHByZWZpeGVkUHJvcGVydHkpIHtcbiAgICBzdHlsZXNbcHJlZml4ZWRQcm9wZXJ0eV0gPSAndHJhbnNsYXRlM2QoJyArIGxlZnQgKyAncHgsICcgKyB0b3AgKyAncHgsIDApJztcbiAgICBzdHlsZXNbc2lkZUFdID0gMDtcbiAgICBzdHlsZXNbc2lkZUJdID0gMDtcbiAgICBzdHlsZXMud2lsbENoYW5nZSA9ICd0cmFuc2Zvcm0nO1xuICB9IGVsc2Uge1xuICAgIC8vIG90aHdlcmlzZSwgd2UgdXNlIHRoZSBzdGFuZGFyZCBgdG9wYCwgYGxlZnRgLCBgYm90dG9tYCBhbmQgYHJpZ2h0YCBwcm9wZXJ0aWVzXG4gICAgdmFyIGludmVydFRvcCA9IHNpZGVBID09PSAnYm90dG9tJyA/IC0xIDogMTtcbiAgICB2YXIgaW52ZXJ0TGVmdCA9IHNpZGVCID09PSAncmlnaHQnID8gLTEgOiAxO1xuICAgIHN0eWxlc1tzaWRlQV0gPSB0b3AgKiBpbnZlcnRUb3A7XG4gICAgc3R5bGVzW3NpZGVCXSA9IGxlZnQgKiBpbnZlcnRMZWZ0O1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gc2lkZUEgKyAnLCAnICsgc2lkZUI7XG4gIH1cblxuICAvLyBBdHRyaWJ1dGVzXG4gIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICd4LXBsYWNlbWVudCc6IGRhdGEucGxhY2VtZW50XG4gIH07XG5cbiAgLy8gVXBkYXRlIGBkYXRhYCBhdHRyaWJ1dGVzLCBzdHlsZXMgYW5kIGFycm93U3R5bGVzXG4gIGRhdGEuYXR0cmlidXRlcyA9IF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCBkYXRhLmF0dHJpYnV0ZXMpO1xuICBkYXRhLnN0eWxlcyA9IF9leHRlbmRzKHt9LCBzdHlsZXMsIGRhdGEuc3R5bGVzKTtcbiAgZGF0YS5hcnJvd1N0eWxlcyA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMuYXJyb3csIGRhdGEuYXJyb3dTdHlsZXMpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGRlcGVuZHMgZnJvbSBhbm90aGVyIG9uZS48YnIgLz5cbiAqIEl0IGNoZWNrcyBpZiB0aGUgbmVlZGVkIG1vZGlmaWVyIGlzIGxpc3RlZCBhbmQgZW5hYmxlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVycyAtIGxpc3Qgb2YgbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGluZ05hbWUgLSBuYW1lIG9mIHJlcXVlc3RpbmcgbW9kaWZpZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0ZWROYW1lIC0gbmFtZSBvZiByZXF1ZXN0ZWQgbW9kaWZpZXJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc01vZGlmaWVyUmVxdWlyZWQobW9kaWZpZXJzLCByZXF1ZXN0aW5nTmFtZSwgcmVxdWVzdGVkTmFtZSkge1xuICB2YXIgcmVxdWVzdGluZyA9IGZpbmQobW9kaWZpZXJzLCBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgIHJldHVybiBuYW1lID09PSByZXF1ZXN0aW5nTmFtZTtcbiAgfSk7XG5cbiAgdmFyIGlzUmVxdWlyZWQgPSAhIXJlcXVlc3RpbmcgJiYgbW9kaWZpZXJzLnNvbWUoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09IHJlcXVlc3RlZE5hbWUgJiYgbW9kaWZpZXIuZW5hYmxlZCAmJiBtb2RpZmllci5vcmRlciA8IHJlcXVlc3Rpbmcub3JkZXI7XG4gIH0pO1xuXG4gIGlmICghaXNSZXF1aXJlZCkge1xuICAgIHZhciBfcmVxdWVzdGluZyA9ICdgJyArIHJlcXVlc3RpbmdOYW1lICsgJ2AnO1xuICAgIHZhciByZXF1ZXN0ZWQgPSAnYCcgKyByZXF1ZXN0ZWROYW1lICsgJ2AnO1xuICAgIGNvbnNvbGUud2FybihyZXF1ZXN0ZWQgKyAnIG1vZGlmaWVyIGlzIHJlcXVpcmVkIGJ5ICcgKyBfcmVxdWVzdGluZyArICcgbW9kaWZpZXIgaW4gb3JkZXIgdG8gd29yaywgYmUgc3VyZSB0byBpbmNsdWRlIGl0IGJlZm9yZSAnICsgX3JlcXVlc3RpbmcgKyAnIScpO1xuICB9XG4gIHJldHVybiBpc1JlcXVpcmVkO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gYXJyb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyRhcnJvdztcblxuICAvLyBhcnJvdyBkZXBlbmRzIG9uIGtlZXBUb2dldGhlciBpbiBvcmRlciB0byB3b3JrXG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnYXJyb3cnLCAna2VlcFRvZ2V0aGVyJykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBhcnJvd0VsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG5cbiAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIGEgc3RyaW5nLCBzdXBwb3NlIGl0J3MgYSBDU1Mgc2VsZWN0b3JcbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIG5vdCBmb3VuZCwgZG9uJ3QgcnVuIHRoZSBtb2RpZmllclxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgdGhlIGFycm93RWxlbWVudCBpc24ndCBhIHF1ZXJ5IHNlbGVjdG9yIHdlIG11c3QgY2hlY2sgdGhhdCB0aGVcbiAgICAvLyBwcm92aWRlZCBET00gbm9kZSBpcyBjaGlsZCBvZiBpdHMgcG9wcGVyIG5vZGVcbiAgICBpZiAoIWRhdGEuaW5zdGFuY2UucG9wcGVyLmNvbnRhaW5zKGFycm93RWxlbWVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogYGFycm93LmVsZW1lbnRgIG11c3QgYmUgY2hpbGQgb2YgaXRzIHBvcHBlciBlbGVtZW50IScpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgaXNWZXJ0aWNhbCA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzaWRlQ2FwaXRhbGl6ZWQgPSBpc1ZlcnRpY2FsID8gJ1RvcCcgOiAnTGVmdCc7XG4gIHZhciBzaWRlID0gc2lkZUNhcGl0YWxpemVkLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBhbHRTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgdmFyIGFycm93RWxlbWVudFNpemUgPSBnZXRPdXRlclNpemVzKGFycm93RWxlbWVudClbbGVuXTtcblxuICAvL1xuICAvLyBleHRlbmRzIGtlZXBUb2dldGhlciBiZWhhdmlvciBtYWtpbmcgc3VyZSB0aGUgcG9wcGVyIGFuZCBpdHNcbiAgLy8gcmVmZXJlbmNlIGhhdmUgZW5vdWdoIHBpeGVscyBpbiBjb25qdW5jdGlvblxuICAvL1xuXG4gIC8vIHRvcC9sZWZ0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSA8IHBvcHBlcltzaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLT0gcG9wcGVyW3NpZGVdIC0gKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSk7XG4gIH1cbiAgLy8gYm90dG9tL3JpZ2h0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgPiBwb3BwZXJbb3BTaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gKz0gcmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSAtIHBvcHBlcltvcFNpZGVdO1xuICB9XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuXG4gIC8vIGNvbXB1dGUgY2VudGVyIG9mIHRoZSBwb3BwZXJcbiAgdmFyIGNlbnRlciA9IHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVtsZW5dIC8gMiAtIGFycm93RWxlbWVudFNpemUgLyAyO1xuXG4gIC8vIENvbXB1dGUgdGhlIHNpZGVWYWx1ZSB1c2luZyB0aGUgdXBkYXRlZCBwb3BwZXIgb2Zmc2V0c1xuICAvLyB0YWtlIHBvcHBlciBtYXJnaW4gaW4gYWNjb3VudCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgdGhpcyBpbmZvIGF2YWlsYWJsZVxuICB2YXIgY3NzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgdmFyIHBvcHBlck1hcmdpblNpZGUgPSBwYXJzZUZsb2F0KGNzc1snbWFyZ2luJyArIHNpZGVDYXBpdGFsaXplZF0sIDEwKTtcbiAgdmFyIHBvcHBlckJvcmRlclNpZGUgPSBwYXJzZUZsb2F0KGNzc1snYm9yZGVyJyArIHNpZGVDYXBpdGFsaXplZCArICdXaWR0aCddLCAxMCk7XG4gIHZhciBzaWRlVmFsdWUgPSBjZW50ZXIgLSBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC0gcG9wcGVyTWFyZ2luU2lkZSAtIHBvcHBlckJvcmRlclNpZGU7XG5cbiAgLy8gcHJldmVudCBhcnJvd0VsZW1lbnQgZnJvbSBiZWluZyBwbGFjZWQgbm90IGNvbnRpZ3VvdXNseSB0byBpdHMgcG9wcGVyXG4gIHNpZGVWYWx1ZSA9IE1hdGgubWF4KE1hdGgubWluKHBvcHBlcltsZW5dIC0gYXJyb3dFbGVtZW50U2l6ZSwgc2lkZVZhbHVlKSwgMCk7XG5cbiAgZGF0YS5hcnJvd0VsZW1lbnQgPSBhcnJvd0VsZW1lbnQ7XG4gIGRhdGEub2Zmc2V0cy5hcnJvdyA9IChfZGF0YSRvZmZzZXRzJGFycm93ID0ge30sIGRlZmluZVByb3BlcnR5KF9kYXRhJG9mZnNldHMkYXJyb3csIHNpZGUsIE1hdGgucm91bmQoc2lkZVZhbHVlKSksIGRlZmluZVByb3BlcnR5KF9kYXRhJG9mZnNldHMkYXJyb3csIGFsdFNpZGUsICcnKSwgX2RhdGEkb2Zmc2V0cyRhcnJvdyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgdmFyaWF0aW9uIG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudCB2YXJpYXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKSB7XG4gIGlmICh2YXJpYXRpb24gPT09ICdlbmQnKSB7XG4gICAgcmV0dXJuICdzdGFydCc7XG4gIH0gZWxzZSBpZiAodmFyaWF0aW9uID09PSAnc3RhcnQnKSB7XG4gICAgcmV0dXJuICdlbmQnO1xuICB9XG4gIHJldHVybiB2YXJpYXRpb247XG59XG5cbi8qKlxuICogTGlzdCBvZiBhY2NlcHRlZCBwbGFjZW1lbnRzIHRvIHVzZSBhcyB2YWx1ZXMgb2YgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbi48YnIgLz5cbiAqIFZhbGlkIHBsYWNlbWVudHMgYXJlOlxuICogLSBgYXV0b2BcbiAqIC0gYHRvcGBcbiAqIC0gYHJpZ2h0YFxuICogLSBgYm90dG9tYFxuICogLSBgbGVmdGBcbiAqXG4gKiBFYWNoIHBsYWNlbWVudCBjYW4gaGF2ZSBhIHZhcmlhdGlvbiBmcm9tIHRoaXMgbGlzdDpcbiAqIC0gYC1zdGFydGBcbiAqIC0gYC1lbmRgXG4gKlxuICogVmFyaWF0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgZWFzaWx5IGlmIHlvdSB0aGluayBvZiB0aGVtIGFzIHRoZSBsZWZ0IHRvIHJpZ2h0XG4gKiB3cml0dGVuIGxhbmd1YWdlcy4gSG9yaXpvbnRhbGx5IChgdG9wYCBhbmQgYGJvdHRvbWApLCBgc3RhcnRgIGlzIGxlZnQgYW5kIGBlbmRgXG4gKiBpcyByaWdodC48YnIgLz5cbiAqIFZlcnRpY2FsbHkgKGBsZWZ0YCBhbmQgYHJpZ2h0YCksIGBzdGFydGAgaXMgdG9wIGFuZCBgZW5kYCBpcyBib3R0b20uXG4gKlxuICogU29tZSB2YWxpZCBleGFtcGxlcyBhcmU6XG4gKiAtIGB0b3AtZW5kYCAob24gdG9wIG9mIHJlZmVyZW5jZSwgcmlnaHQgYWxpZ25lZClcbiAqIC0gYHJpZ2h0LXN0YXJ0YCAob24gcmlnaHQgb2YgcmVmZXJlbmNlLCB0b3AgYWxpZ25lZClcbiAqIC0gYGJvdHRvbWAgKG9uIGJvdHRvbSwgY2VudGVyZWQpXG4gKiAtIGBhdXRvLWVuZGAgKG9uIHRoZSBzaWRlIHdpdGggbW9yZSBzcGFjZSBhdmFpbGFibGUsIGFsaWdubWVudCBkZXBlbmRzIGJ5IHBsYWNlbWVudClcbiAqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAZW51bSB7U3RyaW5nfVxuICogQHJlYWRvbmx5XG4gKiBAbWV0aG9kIHBsYWNlbWVudHNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIHBsYWNlbWVudHMgPSBbJ2F1dG8tc3RhcnQnLCAnYXV0bycsICdhdXRvLWVuZCcsICd0b3Atc3RhcnQnLCAndG9wJywgJ3RvcC1lbmQnLCAncmlnaHQtc3RhcnQnLCAncmlnaHQnLCAncmlnaHQtZW5kJywgJ2JvdHRvbS1lbmQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdsZWZ0LWVuZCcsICdsZWZ0JywgJ2xlZnQtc3RhcnQnXTtcblxuLy8gR2V0IHJpZCBvZiBgYXV0b2AgYGF1dG8tc3RhcnRgIGFuZCBgYXV0by1lbmRgXG52YXIgdmFsaWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5zbGljZSgzKTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbml0aWFsIHBsYWNlbWVudCwgcmV0dXJucyBhbGwgdGhlIHN1YnNlcXVlbnQgcGxhY2VtZW50c1xuICogY2xvY2t3aXNlIChvciBjb3VudGVyLWNsb2Nrd2lzZSkuXG4gKlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCAtIEEgdmFsaWQgcGxhY2VtZW50IChpdCBhY2NlcHRzIHZhcmlhdGlvbnMpXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IGNvdW50ZXIgLSBTZXQgdG8gdHJ1ZSB0byB3YWxrIHRoZSBwbGFjZW1lbnRzIGNvdW50ZXJjbG9ja3dpc2VcbiAqIEByZXR1cm5zIHtBcnJheX0gcGxhY2VtZW50cyBpbmNsdWRpbmcgdGhlaXIgdmFyaWF0aW9uc1xuICovXG5mdW5jdGlvbiBjbG9ja3dpc2UocGxhY2VtZW50KSB7XG4gIHZhciBjb3VudGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaW5kZXggPSB2YWxpZFBsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpO1xuICB2YXIgYXJyID0gdmFsaWRQbGFjZW1lbnRzLnNsaWNlKGluZGV4ICsgMSkuY29uY2F0KHZhbGlkUGxhY2VtZW50cy5zbGljZSgwLCBpbmRleCkpO1xuICByZXR1cm4gY291bnRlciA/IGFyci5yZXZlcnNlKCkgOiBhcnI7XG59XG5cbnZhciBCRUhBVklPUlMgPSB7XG4gIEZMSVA6ICdmbGlwJyxcbiAgQ0xPQ0tXSVNFOiAnY2xvY2t3aXNlJyxcbiAgQ09VTlRFUkNMT0NLV0lTRTogJ2NvdW50ZXJjbG9ja3dpc2UnXG59O1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gZmxpcChkYXRhLCBvcHRpb25zKSB7XG4gIC8vIGlmIGBpbm5lcmAgbW9kaWZpZXIgaXMgZW5hYmxlZCwgd2UgY2FuJ3QgdXNlIHRoZSBgZmxpcGAgbW9kaWZpZXJcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaW5uZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgaWYgKGRhdGEuZmxpcHBlZCAmJiBkYXRhLnBsYWNlbWVudCA9PT0gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCkge1xuICAgIC8vIHNlZW1zIGxpa2UgZmxpcCBpcyB0cnlpbmcgdG8gbG9vcCwgcHJvYmFibHkgdGhlcmUncyBub3QgZW5vdWdoIHNwYWNlIG9uIGFueSBvZiB0aGUgZmxpcHBhYmxlIHNpZGVzXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQsIGRhdGEucG9zaXRpb25GaXhlZCk7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzFdIHx8ICcnO1xuXG4gIHZhciBmbGlwT3JkZXIgPSBbXTtcblxuICBzd2l0Y2ggKG9wdGlvbnMuYmVoYXZpb3IpIHtcbiAgICBjYXNlIEJFSEFWSU9SUy5GTElQOlxuICAgICAgZmxpcE9yZGVyID0gW3BsYWNlbWVudCwgcGxhY2VtZW50T3Bwb3NpdGVdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DT1VOVEVSQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCwgdHJ1ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZmxpcE9yZGVyID0gb3B0aW9ucy5iZWhhdmlvcjtcbiAgfVxuXG4gIGZsaXBPcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChzdGVwLCBpbmRleCkge1xuICAgIGlmIChwbGFjZW1lbnQgIT09IHN0ZXAgfHwgZmxpcE9yZGVyLmxlbmd0aCA9PT0gaW5kZXggKyAxKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBwb3BwZXJPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcbiAgICB2YXIgcmVmT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgICAvLyB1c2luZyBmbG9vciBiZWNhdXNlIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyBtYXkgY29udGFpbiBkZWNpbWFscyB3ZSBhcmUgbm90IGdvaW5nIHRvIGNvbnNpZGVyIGhlcmVcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBvdmVybGFwc1JlZiA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IocmVmT2Zmc2V0cy5sZWZ0KSB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKHJlZk9mZnNldHMucmlnaHQpIHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IocmVmT2Zmc2V0cy50b3ApIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IocmVmT2Zmc2V0cy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0xlZnQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IoYm91bmRhcmllcy5sZWZ0KTtcbiAgICB2YXIgb3ZlcmZsb3dzUmlnaHQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKGJvdW5kYXJpZXMucmlnaHQpO1xuICAgIHZhciBvdmVyZmxvd3NUb3AgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihib3VuZGFyaWVzLnRvcCk7XG4gICAgdmFyIG92ZXJmbG93c0JvdHRvbSA9IGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKGJvdW5kYXJpZXMuYm90dG9tKTtcblxuICAgIHZhciBvdmVyZmxvd3NCb3VuZGFyaWVzID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBvdmVyZmxvd3NUb3AgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBvdmVyZmxvd3NCb3R0b207XG5cbiAgICAvLyBmbGlwIHRoZSB2YXJpYXRpb24gaWYgcmVxdWlyZWRcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgICAvLyBmbGlwcyB2YXJpYXRpb24gaWYgcmVmZXJlbmNlIGVsZW1lbnQgb3ZlcmZsb3dzIGJvdW5kYXJpZXNcbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbkJ5UmVmID0gISFvcHRpb25zLmZsaXBWYXJpYXRpb25zICYmIChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NMZWZ0IHx8IGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NSaWdodCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzVG9wIHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzQm90dG9tKTtcblxuICAgIC8vIGZsaXBzIHZhcmlhdGlvbiBpZiBwb3BwZXIgY29udGVudCBvdmVyZmxvd3MgYm91bmRhcmllc1xuICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uQnlDb250ZW50ID0gISFvcHRpb25zLmZsaXBWYXJpYXRpb25zQnlDb250ZW50ICYmIChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NSaWdodCB8fCBpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzQm90dG9tIHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzVG9wKTtcblxuICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uID0gZmxpcHBlZFZhcmlhdGlvbkJ5UmVmIHx8IGZsaXBwZWRWYXJpYXRpb25CeUNvbnRlbnQ7XG5cbiAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcyB8fCBmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAvLyB0aGlzIGJvb2xlYW4gdG8gZGV0ZWN0IGFueSBmbGlwIGxvb3BcbiAgICAgIGRhdGEuZmxpcHBlZCA9IHRydWU7XG5cbiAgICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzKSB7XG4gICAgICAgIHBsYWNlbWVudCA9IGZsaXBPcmRlcltpbmRleCArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgICB2YXJpYXRpb24gPSBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnBsYWNlbWVudCA9IHBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG5cbiAgICAgIC8vIHRoaXMgb2JqZWN0IGNvbnRhaW5zIGBwb3NpdGlvbmAsIHdlIHdhbnQgdG8gcHJlc2VydmUgaXQgYWxvbmcgd2l0aFxuICAgICAgLy8gYW55IGFkZGl0aW9uYWwgcHJvcGVydHkgd2UgbWF5IGFkZCBpbiB0aGUgZnV0dXJlXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5wb3BwZXIsIGdldFBvcHBlck9mZnNldHMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KSk7XG5cbiAgICAgIGRhdGEgPSBydW5Nb2RpZmllcnMoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGRhdGEsICdmbGlwJyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBrZWVwVG9nZXRoZXIoZGF0YSkge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ3JpZ2h0JyA6ICdib3R0b20nO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gIGlmIChwb3BwZXJbc2lkZV0gPCBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkgLSBwb3BwZXJbbWVhc3VyZW1lbnRdO1xuICB9XG4gIGlmIChwb3BwZXJbb3BTaWRlXSA+IGZsb29yKHJlZmVyZW5jZVtzaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgY29udGFpbmluZyB2YWx1ZSArIHVuaXQgaW50byBhIHB4IHZhbHVlIG51bWJlclxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHN0ciAtIFZhbHVlICsgdW5pdCBzdHJpbmdcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBtZWFzdXJlbWVudCAtIGBoZWlnaHRgIG9yIGB3aWR0aGBcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gKiBAYXJndW1lbnQge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0c1xuICogQHJldHVybnMge051bWJlcnxTdHJpbmd9XG4gKiBWYWx1ZSBpbiBwaXhlbHMsIG9yIG9yaWdpbmFsIHN0cmluZyBpZiBubyB2YWx1ZXMgd2VyZSBleHRyYWN0ZWRcbiAqL1xuZnVuY3Rpb24gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKSB7XG4gIC8vIHNlcGFyYXRlIHZhbHVlIGZyb20gdW5pdFxuICB2YXIgc3BsaXQgPSBzdHIubWF0Y2goLygoPzpcXC18XFwrKT9cXGQqXFwuP1xcZCopKC4qKS8pO1xuICB2YXIgdmFsdWUgPSArc3BsaXRbMV07XG4gIHZhciB1bml0ID0gc3BsaXRbMl07XG5cbiAgLy8gSWYgaXQncyBub3QgYSBudW1iZXIgaXQncyBhbiBvcGVyYXRvciwgSSBndWVzc1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGlmICh1bml0LmluZGV4T2YoJyUnKSA9PT0gMCkge1xuICAgIHZhciBlbGVtZW50ID0gdm9pZCAwO1xuICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgY2FzZSAnJXAnOlxuICAgICAgICBlbGVtZW50ID0gcG9wcGVyT2Zmc2V0cztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICclJzpcbiAgICAgIGNhc2UgJyVyJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGVsZW1lbnQgPSByZWZlcmVuY2VPZmZzZXRzO1xuICAgIH1cblxuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdChlbGVtZW50KTtcbiAgICByZXR1cm4gcmVjdFttZWFzdXJlbWVudF0gLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIGlmICh1bml0ID09PSAndmgnIHx8IHVuaXQgPT09ICd2dycpIHtcbiAgICAvLyBpZiBpcyBhIHZoIG9yIHZ3LCB3ZSBjYWxjdWxhdGUgdGhlIHNpemUgYmFzZWQgb24gdGhlIHZpZXdwb3J0XG4gICAgdmFyIHNpemUgPSB2b2lkIDA7XG4gICAgaWYgKHVuaXQgPT09ICd2aCcpIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZSAvIDEwMCAqIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIC8vIGlmIGlzIGFuIGV4cGxpY2l0IHBpeGVsIHVuaXQsIHdlIGdldCByaWQgb2YgdGhlIHVuaXQgYW5kIGtlZXAgdGhlIHZhbHVlXG4gICAgLy8gaWYgaXMgYW4gaW1wbGljaXQgdW5pdCwgaXQncyBweCwgYW5kIHdlIHJldHVybiBqdXN0IHRoZSB2YWx1ZVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGFuIGBvZmZzZXRgIHN0cmluZyB0byBleHRyYXBvbGF0ZSBgeGAgYW5kIGB5YCBudW1lcmljIG9mZnNldHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAqIEBwcml2YXRlXG4gKiBAYXJndW1lbnQge1N0cmluZ30gb2Zmc2V0XG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBiYXNlUGxhY2VtZW50XG4gKiBAcmV0dXJucyB7QXJyYXl9IGEgdHdvIGNlbGxzIGFycmF5IHdpdGggeCBhbmQgeSBvZmZzZXRzIGluIG51bWJlcnNcbiAqL1xuZnVuY3Rpb24gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzLCBiYXNlUGxhY2VtZW50KSB7XG4gIHZhciBvZmZzZXRzID0gWzAsIDBdO1xuXG4gIC8vIFVzZSBoZWlnaHQgaWYgcGxhY2VtZW50IGlzIGxlZnQgb3IgcmlnaHQgYW5kIGluZGV4IGlzIDAgb3RoZXJ3aXNlIHVzZSB3aWR0aFxuICAvLyBpbiB0aGlzIHdheSB0aGUgZmlyc3Qgb2Zmc2V0IHdpbGwgdXNlIGFuIGF4aXMgYW5kIHRoZSBzZWNvbmQgb25lXG4gIC8vIHdpbGwgdXNlIHRoZSBvdGhlciBvbmVcbiAgdmFyIHVzZUhlaWdodCA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gIC8vIFNwbGl0IHRoZSBvZmZzZXQgc3RyaW5nIHRvIG9idGFpbiBhIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kc1xuICAvLyBUaGUgcmVnZXggYWRkcmVzc2VzIHZhbHVlcyB3aXRoIHRoZSBwbHVzIG9yIG1pbnVzIHNpZ24gaW4gZnJvbnQgKCsxMCwgLTIwLCBldGMpXG4gIHZhciBmcmFnbWVudHMgPSBvZmZzZXQuc3BsaXQoLyhcXCt8XFwtKS8pLm1hcChmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnRyaW0oKTtcbiAgfSk7XG5cbiAgLy8gRGV0ZWN0IGlmIHRoZSBvZmZzZXQgc3RyaW5nIGNvbnRhaW5zIGEgcGFpciBvZiB2YWx1ZXMgb3IgYSBzaW5nbGUgb25lXG4gIC8vIHRoZXkgY291bGQgYmUgc2VwYXJhdGVkIGJ5IGNvbW1hIG9yIHNwYWNlXG4gIHZhciBkaXZpZGVyID0gZnJhZ21lbnRzLmluZGV4T2YoZmluZChmcmFnbWVudHMsIGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgcmV0dXJuIGZyYWcuc2VhcmNoKC8sfFxccy8pICE9PSAtMTtcbiAgfSkpO1xuXG4gIGlmIChmcmFnbWVudHNbZGl2aWRlcl0gJiYgZnJhZ21lbnRzW2RpdmlkZXJdLmluZGV4T2YoJywnKSA9PT0gLTEpIHtcbiAgICBjb25zb2xlLndhcm4oJ09mZnNldHMgc2VwYXJhdGVkIGJ5IHdoaXRlIHNwYWNlKHMpIGFyZSBkZXByZWNhdGVkLCB1c2UgYSBjb21tYSAoLCkgaW5zdGVhZC4nKTtcbiAgfVxuXG4gIC8vIElmIGRpdmlkZXIgaXMgZm91bmQsIHdlIGRpdmlkZSB0aGUgbGlzdCBvZiB2YWx1ZXMgYW5kIG9wZXJhbmRzIHRvIGRpdmlkZVxuICAvLyB0aGVtIGJ5IG9mc2V0IFggYW5kIFkuXG4gIHZhciBzcGxpdFJlZ2V4ID0gL1xccyosXFxzKnxcXHMrLztcbiAgdmFyIG9wcyA9IGRpdmlkZXIgIT09IC0xID8gW2ZyYWdtZW50cy5zbGljZSgwLCBkaXZpZGVyKS5jb25jYXQoW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVswXV0pLCBbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzFdXS5jb25jYXQoZnJhZ21lbnRzLnNsaWNlKGRpdmlkZXIgKyAxKSldIDogW2ZyYWdtZW50c107XG5cbiAgLy8gQ29udmVydCB0aGUgdmFsdWVzIHdpdGggdW5pdHMgdG8gYWJzb2x1dGUgcGl4ZWxzIHRvIGFsbG93IG91ciBjb21wdXRhdGlvbnNcbiAgb3BzID0gb3BzLm1hcChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgLy8gTW9zdCBvZiB0aGUgdW5pdHMgcmVseSBvbiB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHBvcHBlclxuICAgIHZhciBtZWFzdXJlbWVudCA9IChpbmRleCA9PT0gMSA/ICF1c2VIZWlnaHQgOiB1c2VIZWlnaHQpID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgIHJldHVybiBvcFxuICAgIC8vIFRoaXMgYWdncmVnYXRlcyBhbnkgYCtgIG9yIGAtYCBzaWduIHRoYXQgYXJlbid0IGNvbnNpZGVyZWQgb3BlcmF0b3JzXG4gICAgLy8gZS5nLjogMTAgKyArNSA9PiBbMTAsICssICs1XVxuICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGlmIChhW2EubGVuZ3RoIC0gMV0gPT09ICcnICYmIFsnKycsICctJ10uaW5kZXhPZihiKSAhPT0gLTEpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdID0gYjtcbiAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSBpZiAobWVyZ2VXaXRoUHJldmlvdXMpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdICs9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgfVxuICAgIH0sIFtdKVxuICAgIC8vIEhlcmUgd2UgY29udmVydCB0aGUgc3RyaW5nIHZhbHVlcyBpbnRvIG51bWJlciB2YWx1ZXMgKGluIHB4KVxuICAgIC5tYXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIExvb3AgdHJvdWdoIHRoZSBvZmZzZXRzIGFycmF5cyBhbmQgZXhlY3V0ZSB0aGUgb3BlcmF0aW9uc1xuICBvcHMuZm9yRWFjaChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgb3AuZm9yRWFjaChmdW5jdGlvbiAoZnJhZywgaW5kZXgyKSB7XG4gICAgICBpZiAoaXNOdW1lcmljKGZyYWcpKSB7XG4gICAgICAgIG9mZnNldHNbaW5kZXhdICs9IGZyYWcgKiAob3BbaW5kZXgyIC0gMV0gPT09ICctJyA/IC0xIDogMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAYXJndW1lbnQge051bWJlcnxTdHJpbmd9IG9wdGlvbnMub2Zmc2V0PTBcbiAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBvZmZzZXQoZGF0YSwgX3JlZikge1xuICB2YXIgb2Zmc2V0ID0gX3JlZi5vZmZzZXQ7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudCxcbiAgICAgIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgdmFyIG9mZnNldHMgPSB2b2lkIDA7XG4gIGlmIChpc051bWVyaWMoK29mZnNldCkpIHtcbiAgICBvZmZzZXRzID0gWytvZmZzZXQsIDBdO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldHMgPSBwYXJzZU9mZnNldChvZmZzZXQsIHBvcHBlciwgcmVmZXJlbmNlLCBiYXNlUGxhY2VtZW50KTtcbiAgfVxuXG4gIGlmIChiYXNlUGxhY2VtZW50ID09PSAnbGVmdCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAncmlnaHQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAnYm90dG9tJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzFdO1xuICB9XG5cbiAgZGF0YS5wb3BwZXIgPSBwb3BwZXI7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgYm91bmRhcmllc0VsZW1lbnQgPSBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50IHx8IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG5cbiAgLy8gSWYgb2Zmc2V0UGFyZW50IGlzIHRoZSByZWZlcmVuY2UgZWxlbWVudCwgd2UgcmVhbGx5IHdhbnQgdG9cbiAgLy8gZ28gb25lIHN0ZXAgdXAgYW5kIHVzZSB0aGUgbmV4dCBvZmZzZXRQYXJlbnQgYXMgcmVmZXJlbmNlIHRvXG4gIC8vIGF2b2lkIHRvIG1ha2UgdGhpcyBtb2RpZmllciBjb21wbGV0ZWx5IHVzZWxlc3MgYW5kIGxvb2sgbGlrZSBicm9rZW5cbiAgaWYgKGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlID09PSBib3VuZGFyaWVzRWxlbWVudCkge1xuICAgIGJvdW5kYXJpZXNFbGVtZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGJvdW5kYXJpZXNFbGVtZW50KTtcbiAgfVxuXG4gIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAvLyByZXNldHMgdGhlIHBvcHBlcidzIHBvc2l0aW9uIHNvIHRoYXQgdGhlIGRvY3VtZW50IHNpemUgY2FuIGJlIGNhbGN1bGF0ZWQgZXhjbHVkaW5nXG4gIC8vIHRoZSBzaXplIG9mIHRoZSBwb3BwZXIgZWxlbWVudCBpdHNlbGZcbiAgdmFyIHRyYW5zZm9ybVByb3AgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuICB2YXIgcG9wcGVyU3R5bGVzID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIuc3R5bGU7IC8vIGFzc2lnbm1lbnQgdG8gaGVscCBtaW5pZmljYXRpb25cbiAgdmFyIHRvcCA9IHBvcHBlclN0eWxlcy50b3AsXG4gICAgICBsZWZ0ID0gcG9wcGVyU3R5bGVzLmxlZnQsXG4gICAgICB0cmFuc2Zvcm0gPSBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF07XG5cbiAgcG9wcGVyU3R5bGVzLnRvcCA9ICcnO1xuICBwb3BwZXJTdHlsZXMubGVmdCA9ICcnO1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSAnJztcblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50LCBkYXRhLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAvLyByZXN0b3JlcyB0aGUgb3JpZ2luYWwgc3R5bGUgcHJvcGVydGllcyBhZnRlciB0aGUgb2Zmc2V0cyBoYXZlIGJlZW4gY29tcHV0ZWRcbiAgcG9wcGVyU3R5bGVzLnRvcCA9IHRvcDtcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSBsZWZ0O1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm07XG5cbiAgb3B0aW9ucy5ib3VuZGFyaWVzID0gYm91bmRhcmllcztcblxuICB2YXIgb3JkZXIgPSBvcHRpb25zLnByaW9yaXR5O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICB2YXIgY2hlY2sgPSB7XG4gICAgcHJpbWFyeTogZnVuY3Rpb24gcHJpbWFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlcltwbGFjZW1lbnRdO1xuICAgICAgaWYgKHBvcHBlcltwbGFjZW1lbnRdIDwgYm91bmRhcmllc1twbGFjZW1lbnRdICYmICFvcHRpb25zLmVzY2FwZVdpdGhSZWZlcmVuY2UpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLm1heChwb3BwZXJbcGxhY2VtZW50XSwgYm91bmRhcmllc1twbGFjZW1lbnRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgcGxhY2VtZW50LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZWNvbmRhcnk6IGZ1bmN0aW9uIHNlY29uZGFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciBtYWluU2lkZSA9IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgICAgdmFyIHZhbHVlID0gcG9wcGVyW21haW5TaWRlXTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA+IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5taW4ocG9wcGVyW21haW5TaWRlXSwgYm91bmRhcmllc1twbGFjZW1lbnRdIC0gKHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/IHBvcHBlci53aWR0aCA6IHBvcHBlci5oZWlnaHQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgbWFpblNpZGUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgb3JkZXIuZm9yRWFjaChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgdmFyIHNpZGUgPSBbJ2xlZnQnLCAndG9wJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMSA/ICdwcmltYXJ5JyA6ICdzZWNvbmRhcnknO1xuICAgIHBvcHBlciA9IF9leHRlbmRzKHt9LCBwb3BwZXIsIGNoZWNrW3NpZGVdKHBsYWNlbWVudCkpO1xuICB9KTtcblxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gcG9wcGVyO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBzaGlmdChkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHNoaWZ0dmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgLy8gaWYgc2hpZnQgc2hpZnR2YXJpYXRpb24gaXMgc3BlY2lmaWVkLCBydW4gdGhlIG1vZGlmaWVyXG4gIGlmIChzaGlmdHZhcmlhdGlvbikge1xuICAgIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXI7XG5cbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsnYm90dG9tJywgJ3RvcCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuICAgIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgIHZhciBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgICB2YXIgc2hpZnRPZmZzZXRzID0ge1xuICAgICAgc3RhcnQ6IGRlZmluZVByb3BlcnR5KHt9LCBzaWRlLCByZWZlcmVuY2Vbc2lkZV0pLFxuICAgICAgZW5kOiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW21lYXN1cmVtZW50XSAtIHBvcHBlclttZWFzdXJlbWVudF0pXG4gICAgfTtcblxuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBzaGlmdE9mZnNldHNbc2hpZnR2YXJpYXRpb25dKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gaGlkZShkYXRhKSB7XG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaGlkZScsICdwcmV2ZW50T3ZlcmZsb3cnKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIHJlZlJlY3QgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuICB2YXIgYm91bmQgPSBmaW5kKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gJ3ByZXZlbnRPdmVyZmxvdyc7XG4gIH0pLmJvdW5kYXJpZXM7XG5cbiAgaWYgKHJlZlJlY3QuYm90dG9tIDwgYm91bmQudG9wIHx8IHJlZlJlY3QubGVmdCA+IGJvdW5kLnJpZ2h0IHx8IHJlZlJlY3QudG9wID4gYm91bmQuYm90dG9tIHx8IHJlZlJlY3QucmlnaHQgPCBib3VuZC5sZWZ0KSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gdHJ1ZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSBmYWxzZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGlubmVyKGRhdGEpIHtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGlzSG9yaXogPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgc3VidHJhY3RMZW5ndGggPSBbJ3RvcCcsICdsZWZ0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA9PT0gLTE7XG5cbiAgcG9wcGVyW2lzSG9yaXogPyAnbGVmdCcgOiAndG9wJ10gPSByZWZlcmVuY2VbYmFzZVBsYWNlbWVudF0gLSAoc3VidHJhY3RMZW5ndGggPyBwb3BwZXJbaXNIb3JpeiA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gOiAwKTtcblxuICBkYXRhLnBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KHBvcHBlcik7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogTW9kaWZpZXIgZnVuY3Rpb24sIGVhY2ggbW9kaWZpZXIgY2FuIGhhdmUgYSBmdW5jdGlvbiBvZiB0aGlzIHR5cGUgYXNzaWduZWRcbiAqIHRvIGl0cyBgZm5gIHByb3BlcnR5LjxiciAvPlxuICogVGhlc2UgZnVuY3Rpb25zIHdpbGwgYmUgY2FsbGVkIG9uIGVhY2ggdXBkYXRlLCB0aGlzIG1lYW5zIHRoYXQgeW91IG11c3RcbiAqIG1ha2Ugc3VyZSB0aGV5IGFyZSBwZXJmb3JtYW50IGVub3VnaCB0byBhdm9pZCBwZXJmb3JtYW5jZSBib3R0bGVuZWNrcy5cbiAqXG4gKiBAZnVuY3Rpb24gTW9kaWZpZXJGblxuICogQGFyZ3VtZW50IHtkYXRhT2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cblxuLyoqXG4gKiBNb2RpZmllcnMgYXJlIHBsdWdpbnMgdXNlZCB0byBhbHRlciB0aGUgYmVoYXZpb3Igb2YgeW91ciBwb3BwZXJzLjxiciAvPlxuICogUG9wcGVyLmpzIHVzZXMgYSBzZXQgb2YgOSBtb2RpZmllcnMgdG8gcHJvdmlkZSBhbGwgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllc1xuICogbmVlZGVkIGJ5IHRoZSBsaWJyYXJ5LlxuICpcbiAqIFVzdWFsbHkgeW91IGRvbid0IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGBvcmRlcmAsIGBmbmAgYW5kIGBvbkxvYWRgIHByb3BzLlxuICogQWxsIHRoZSBvdGhlciBwcm9wZXJ0aWVzIGFyZSBjb25maWd1cmF0aW9ucyB0aGF0IGNvdWxkIGJlIHR3ZWFrZWQuXG4gKiBAbmFtZXNwYWNlIG1vZGlmaWVyc1xuICovXG52YXIgbW9kaWZpZXJzID0ge1xuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBzaGlmdCB0aGUgcG9wcGVyIG9uIHRoZSBzdGFydCBvciBlbmQgb2YgaXRzIHJlZmVyZW5jZVxuICAgKiBlbGVtZW50LjxiciAvPlxuICAgKiBJdCB3aWxsIHJlYWQgdGhlIHZhcmlhdGlvbiBvZiB0aGUgYHBsYWNlbWVudGAgcHJvcGVydHkuPGJyIC8+XG4gICAqIEl0IGNhbiBiZSBvbmUgZWl0aGVyIGAtZW5kYCBvciBgLXN0YXJ0YC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHNoaWZ0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTEwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogc2hpZnRcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGBvZmZzZXRgIG1vZGlmaWVyIGNhbiBzaGlmdCB5b3VyIHBvcHBlciBvbiBib3RoIGl0cyBheGlzLlxuICAgKlxuICAgKiBJdCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgdW5pdHM6XG4gICAqIC0gYHB4YCBvciB1bml0LWxlc3MsIGludGVycHJldGVkIGFzIHBpeGVsc1xuICAgKiAtIGAlYCBvciBgJXJgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAqIC0gYCVwYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiAtIGB2d2AsIENTUyB2aWV3cG9ydCB3aWR0aCB1bml0XG4gICAqIC0gYHZoYCwgQ1NTIHZpZXdwb3J0IGhlaWdodCB1bml0XG4gICAqXG4gICAqIEZvciBsZW5ndGggaXMgaW50ZW5kZWQgdGhlIG1haW4gYXhpcyByZWxhdGl2ZSB0byB0aGUgcGxhY2VtZW50IG9mIHRoZSBwb3BwZXIuPGJyIC8+XG4gICAqIFRoaXMgbWVhbnMgdGhhdCBpZiB0aGUgcGxhY2VtZW50IGlzIGB0b3BgIG9yIGBib3R0b21gLCB0aGUgbGVuZ3RoIHdpbGwgYmUgdGhlXG4gICAqIGB3aWR0aGAuIEluIGNhc2Ugb2YgYGxlZnRgIG9yIGByaWdodGAsIGl0IHdpbGwgYmUgdGhlIGBoZWlnaHRgLlxuICAgKlxuICAgKiBZb3UgY2FuIHByb3ZpZGUgYSBzaW5nbGUgdmFsdWUgKGFzIGBOdW1iZXJgIG9yIGBTdHJpbmdgKSwgb3IgYSBwYWlyIG9mIHZhbHVlc1xuICAgKiBhcyBgU3RyaW5nYCBkaXZpZGVkIGJ5IGEgY29tbWEgb3Igb25lIChvciBtb3JlKSB3aGl0ZSBzcGFjZXMuPGJyIC8+XG4gICAqIFRoZSBsYXR0ZXIgaXMgYSBkZXByZWNhdGVkIG1ldGhvZCBiZWNhdXNlIGl0IGxlYWRzIHRvIGNvbmZ1c2lvbiBhbmQgd2lsbCBiZVxuICAgKiByZW1vdmVkIGluIHYyLjxiciAvPlxuICAgKiBBZGRpdGlvbmFsbHksIGl0IGFjY2VwdHMgYWRkaXRpb25zIGFuZCBzdWJ0cmFjdGlvbnMgYmV0d2VlbiBkaWZmZXJlbnQgdW5pdHMuXG4gICAqIE5vdGUgdGhhdCBtdWx0aXBsaWNhdGlvbnMgYW5kIGRpdmlzaW9ucyBhcmVuJ3Qgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBWYWxpZCBleGFtcGxlcyBhcmU6XG4gICAqIGBgYFxuICAgKiAxMFxuICAgKiAnMTAlJ1xuICAgKiAnMTAsIDEwJ1xuICAgKiAnMTAlLCAxMCdcbiAgICogJzEwICsgMTAlJ1xuICAgKiAnMTAgLSA1dmggKyAzJSdcbiAgICogJy0xMHB4ICsgNXZoLCA1cHggLSA2JSdcbiAgICogYGBgXG4gICAqID4gKipOQioqOiBJZiB5b3UgZGVzaXJlIHRvIGFwcGx5IG9mZnNldHMgdG8geW91ciBwb3BwZXJzIGluIGEgd2F5IHRoYXQgbWF5IG1ha2UgdGhlbSBvdmVybGFwXG4gICAqID4gd2l0aCB0aGVpciByZWZlcmVuY2UgZWxlbWVudCwgdW5mb3J0dW5hdGVseSwgeW91IHdpbGwgaGF2ZSB0byBkaXNhYmxlIHRoZSBgZmxpcGAgbW9kaWZpZXIuXG4gICAqID4gWW91IGNhbiByZWFkIG1vcmUgb24gdGhpcyBhdCB0aGlzIFtpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvaXNzdWVzLzM3MykuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBvZmZzZXQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAyMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBvZmZzZXQsXG4gICAgLyoqIEBwcm9wIHtOdW1iZXJ8U3RyaW5nfSBvZmZzZXQ9MFxuICAgICAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICAgICAqL1xuICAgIG9mZnNldDogMFxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHByZXZlbnQgdGhlIHBvcHBlciBmcm9tIGJlaW5nIHBvc2l0aW9uZWQgb3V0c2lkZSB0aGUgYm91bmRhcnkuXG4gICAqXG4gICAqIEEgc2NlbmFyaW8gZXhpc3RzIHdoZXJlIHRoZSByZWZlcmVuY2UgaXRzZWxmIGlzIG5vdCB3aXRoaW4gdGhlIGJvdW5kYXJpZXMuPGJyIC8+XG4gICAqIFdlIGNhbiBzYXkgaXQgaGFzIFwiZXNjYXBlZCB0aGUgYm91bmRhcmllc1wiIOKAlCBvciBqdXN0IFwiZXNjYXBlZFwiLjxiciAvPlxuICAgKiBJbiB0aGlzIGNhc2Ugd2UgbmVlZCB0byBkZWNpZGUgd2hldGhlciB0aGUgcG9wcGVyIHNob3VsZCBlaXRoZXI6XG4gICAqXG4gICAqIC0gZGV0YWNoIGZyb20gdGhlIHJlZmVyZW5jZSBhbmQgcmVtYWluIFwidHJhcHBlZFwiIGluIHRoZSBib3VuZGFyaWVzLCBvclxuICAgKiAtIGlmIGl0IHNob3VsZCBpZ25vcmUgdGhlIGJvdW5kYXJ5IGFuZCBcImVzY2FwZSB3aXRoIGl0cyByZWZlcmVuY2VcIlxuICAgKlxuICAgKiBXaGVuIGBlc2NhcGVXaXRoUmVmZXJlbmNlYCBpcyBzZXQgdG9gdHJ1ZWAgYW5kIHJlZmVyZW5jZSBpcyBjb21wbGV0ZWx5XG4gICAqIG91dHNpZGUgaXRzIGJvdW5kYXJpZXMsIHRoZSBwb3BwZXIgd2lsbCBvdmVyZmxvdyAob3IgY29tcGxldGVseSBsZWF2ZSlcbiAgICogdGhlIGJvdW5kYXJpZXMgaW4gb3JkZXIgdG8gcmVtYWluIGF0dGFjaGVkIHRvIHRoZSBlZGdlIG9mIHRoZSByZWZlcmVuY2UuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAzMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gICAgLyoqXG4gICAgICogQHByb3Age0FycmF5fSBbcHJpb3JpdHk9WydsZWZ0JywncmlnaHQnLCd0b3AnLCdib3R0b20nXV1cbiAgICAgKiBQb3BwZXIgd2lsbCB0cnkgdG8gcHJldmVudCBvdmVyZmxvdyBmb2xsb3dpbmcgdGhlc2UgcHJpb3JpdGllcyBieSBkZWZhdWx0LFxuICAgICAqIHRoZW4sIGl0IGNvdWxkIG92ZXJmbG93IG9uIHRoZSBsZWZ0IGFuZCBvbiB0b3Agb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwcmlvcml0eTogWydsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7bnVtYmVyfSBwYWRkaW5nPTVcbiAgICAgKiBBbW91bnQgb2YgcGl4ZWwgdXNlZCB0byBkZWZpbmUgYSBtaW5pbXVtIGRpc3RhbmNlIGJldHdlZW4gdGhlIGJvdW5kYXJpZXNcbiAgICAgKiBhbmQgdGhlIHBvcHBlci4gVGhpcyBtYWtlcyBzdXJlIHRoZSBwb3BwZXIgYWx3YXlzIGhhcyBhIGxpdHRsZSBwYWRkaW5nXG4gICAgICogYmV0d2VlbiB0aGUgZWRnZXMgb2YgaXRzIGNvbnRhaW5lclxuICAgICAqL1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3Njcm9sbFBhcmVudCdcbiAgICAgKiBCb3VuZGFyaWVzIHVzZWQgYnkgdGhlIG1vZGlmaWVyLiBDYW4gYmUgYHNjcm9sbFBhcmVudGAsIGB3aW5kb3dgLFxuICAgICAqIGB2aWV3cG9ydGAgb3IgYW55IERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAnc2Nyb2xsUGFyZW50J1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgcmVmZXJlbmNlIGFuZCBpdHMgcG9wcGVyIHN0YXkgbmVhciBlYWNoIG90aGVyXG4gICAqIHdpdGhvdXQgbGVhdmluZyBhbnkgZ2FwIGJldHdlZW4gdGhlIHR3by4gRXNwZWNpYWxseSB1c2VmdWwgd2hlbiB0aGUgYXJyb3cgaXNcbiAgICogZW5hYmxlZCBhbmQgeW91IHdhbnQgdG8gZW5zdXJlIHRoYXQgaXQgcG9pbnRzIHRvIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogSXQgY2FyZXMgb25seSBhYm91dCB0aGUgZmlyc3QgYXhpcy4gWW91IGNhbiBzdGlsbCBoYXZlIHBvcHBlcnMgd2l0aCBtYXJnaW5cbiAgICogYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBrZWVwVG9nZXRoZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NDAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA0MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBrZWVwVG9nZXRoZXJcbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBtb2RpZmllciBpcyB1c2VkIHRvIG1vdmUgdGhlIGBhcnJvd0VsZW1lbnRgIG9mIHRoZSBwb3BwZXIgdG8gbWFrZVxuICAgKiBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgYmV0d2VlbiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgYW5kIGl0cyBwb3BwZXIgZWxlbWVudC5cbiAgICogSXQgd2lsbCByZWFkIHRoZSBvdXRlciBzaXplIG9mIHRoZSBgYXJyb3dFbGVtZW50YCBub2RlIHRvIGRldGVjdCBob3cgbWFueVxuICAgKiBwaXhlbHMgb2YgY29uanVuY3Rpb24gYXJlIG5lZWRlZC5cbiAgICpcbiAgICogSXQgaGFzIG5vIGVmZmVjdCBpZiBubyBgYXJyb3dFbGVtZW50YCBpcyBwcm92aWRlZC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFycm93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTUwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXJyb3csXG4gICAgLyoqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGVsZW1lbnQ9J1t4LWFycm93XScgLSBTZWxlY3RvciBvciBub2RlIHVzZWQgYXMgYXJyb3cgKi9cbiAgICBlbGVtZW50OiAnW3gtYXJyb3ddJ1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGZsaXAgdGhlIHBvcHBlcidzIHBsYWNlbWVudCB3aGVuIGl0IHN0YXJ0cyB0byBvdmVybGFwIGl0c1xuICAgKiByZWZlcmVuY2UgZWxlbWVudC5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKlxuICAgKiAqKk5PVEU6KiogdGhpcyBtb2RpZmllciB3aWxsIGludGVycnVwdCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUgYW5kIHdpbGxcbiAgICogcmVzdGFydCBpdCBpZiBpdCBkZXRlY3RzIHRoZSBuZWVkIHRvIGZsaXAgdGhlIHBsYWNlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGZsaXA6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA2MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBmbGlwLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8QXJyYXl9IGJlaGF2aW9yPSdmbGlwJ1xuICAgICAqIFRoZSBiZWhhdmlvciB1c2VkIHRvIGNoYW5nZSB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50LiBJdCBjYW4gYmUgb25lIG9mXG4gICAgICogYGZsaXBgLCBgY2xvY2t3aXNlYCwgYGNvdW50ZXJjbG9ja3dpc2VgIG9yIGFuIGFycmF5IHdpdGggYSBsaXN0IG9mIHZhbGlkXG4gICAgICogcGxhY2VtZW50cyAod2l0aCBvcHRpb25hbCB2YXJpYXRpb25zKVxuICAgICAqL1xuICAgIGJlaGF2aW9yOiAnZmxpcCcsXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogVGhlIHBvcHBlciB3aWxsIGZsaXAgaWYgaXQgaGl0cyB0aGUgZWRnZXMgb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSd2aWV3cG9ydCdcbiAgICAgKiBUaGUgZWxlbWVudCB3aGljaCB3aWxsIGRlZmluZSB0aGUgYm91bmRhcmllcyBvZiB0aGUgcG9wcGVyIHBvc2l0aW9uLlxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBuZXZlciBiZSBwbGFjZWQgb3V0c2lkZSBvZiB0aGUgZGVmaW5lZCBib3VuZGFyaWVzXG4gICAgICogKGV4Y2VwdCBpZiBga2VlcFRvZ2V0aGVyYCBpcyBlbmFibGVkKVxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAndmlld3BvcnQnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBmbGlwVmFyaWF0aW9ucz1mYWxzZVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBzd2l0Y2ggcGxhY2VtZW50IHZhcmlhdGlvbiBiZXR3ZWVuIGAtc3RhcnRgIGFuZCBgLWVuZGAgd2hlblxuICAgICAqIHRoZSByZWZlcmVuY2UgZWxlbWVudCBvdmVybGFwcyBpdHMgYm91bmRhcmllcy5cbiAgICAgKlxuICAgICAqIFRoZSBvcmlnaW5hbCBwbGFjZW1lbnQgc2hvdWxkIGhhdmUgYSBzZXQgdmFyaWF0aW9uLlxuICAgICAqL1xuICAgIGZsaXBWYXJpYXRpb25zOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQ9ZmFsc2VcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgc3dpdGNoIHBsYWNlbWVudCB2YXJpYXRpb24gYmV0d2VlbiBgLXN0YXJ0YCBhbmQgYC1lbmRgIHdoZW5cbiAgICAgKiB0aGUgcG9wcGVyIGVsZW1lbnQgb3ZlcmxhcHMgaXRzIHJlZmVyZW5jZSBib3VuZGFyaWVzLlxuICAgICAqXG4gICAgICogVGhlIG9yaWdpbmFsIHBsYWNlbWVudCBzaG91bGQgaGF2ZSBhIHNldCB2YXJpYXRpb24uXG4gICAgICovXG4gICAgZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQ6IGZhbHNlXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gbWFrZSB0aGUgcG9wcGVyIGZsb3cgdG93YXJkIHRoZSBpbm5lciBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEJ5IGRlZmF1bHQsIHdoZW4gdGhpcyBtb2RpZmllciBpcyBkaXNhYmxlZCwgdGhlIHBvcHBlciB3aWxsIGJlIHBsYWNlZCBvdXRzaWRlXG4gICAqIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGlubmVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTcwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD1mYWxzZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBpbm5lclxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGhpZGUgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXRzaWRlIG9mIHRoZVxuICAgKiBwb3BwZXIgYm91bmRhcmllcy4gSXQgd2lsbCBzZXQgYSBgeC1vdXQtb2YtYm91bmRhcmllc2AgYXR0cmlidXRlIHdoaWNoIGNhblxuICAgKiBiZSB1c2VkIHRvIGhpZGUgd2l0aCBhIENTUyBzZWxlY3RvciB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBpc1xuICAgKiBvdXQgb2YgYm91bmRhcmllcy5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaGlkZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDgwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGhpZGVcbiAgfSxcblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHN0eWxlIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgZWxlbWVudCB0byBnZXRzXG4gICAqIHByb3Blcmx5IHBvc2l0aW9uZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1vZGlmaWVyIHdpbGwgbm90IHRvdWNoIHRoZSBET00sIGl0IGp1c3QgcHJlcGFyZXMgdGhlIHN0eWxlc1xuICAgKiBzbyB0aGF0IGBhcHBseVN0eWxlYCBtb2RpZmllciBjYW4gYXBwbHkgaXQuIFRoaXMgc2VwYXJhdGlvbiBpcyB1c2VmdWxcbiAgICogaW4gY2FzZSB5b3UgbmVlZCB0byByZXBsYWNlIGBhcHBseVN0eWxlYCB3aXRoIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiBUaGlzIG1vZGlmaWVyIGhhcyBgODUwYCBhcyBgb3JkZXJgIHZhbHVlIHRvIG1haW50YWluIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICogd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBQb3BwZXIuanMuIEV4cGVjdCB0aGUgbW9kaWZpZXJzIG9yZGVyaW5nIG1ldGhvZFxuICAgKiB0byBjaGFuZ2UgaW4gZnV0dXJlIG1ham9yIHZlcnNpb25zIG9mIHRoZSBsaWJyYXJ5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgY29tcHV0ZVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTg1MCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODUwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogY29tcHV0ZVN0eWxlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzRCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nYm90dG9tJ11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFggYXhpcyAoYGJvdHRvbWAgb3IgYHRvcGApLiBBS0EgWCBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGBib3R0b21gXG4gICAgICovXG4gICAgeDogJ2JvdHRvbScsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2xlZnQnXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWSBheGlzIChgbGVmdGAgb3IgYHJpZ2h0YCkuIEFLQSBZIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYHJpZ2h0YFxuICAgICAqL1xuICAgIHk6ICdyaWdodCdcbiAgfSxcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgY29tcHV0ZWQgc3R5bGVzIHRvIHRoZSBwb3BwZXIgZWxlbWVudC5cbiAgICpcbiAgICogQWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyBhcmUgbGltaXRlZCB0byB0aGlzIG1vZGlmaWVyLiBUaGlzIGlzIHVzZWZ1bCBpbiBjYXNlXG4gICAqIHlvdSB3YW50IHRvIGludGVncmF0ZSBQb3BwZXIuanMgaW5zaWRlIGEgZnJhbWV3b3JrIG9yIHZpZXcgbGlicmFyeSBhbmQgeW91XG4gICAqIHdhbnQgdG8gZGVsZWdhdGUgYWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyB0byBpdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHlvdSBkaXNhYmxlIHRoaXMgbW9kaWZpZXIsIHlvdSBtdXN0IG1ha2Ugc3VyZSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogaGFzIGl0cyBwb3NpdGlvbiBzZXQgdG8gYGFic29sdXRlYCBiZWZvcmUgUG9wcGVyLmpzIGNhbiBkbyBpdHMgd29yayFcbiAgICpcbiAgICogSnVzdCBkaXNhYmxlIHRoaXMgbW9kaWZpZXIgYW5kIGRlZmluZSB5b3VyIG93biB0byBhY2hpZXZlIHRoZSBkZXNpcmVkIGVmZmVjdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFwcGx5U3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9OTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA5MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBhcHBseVN0eWxlLFxuICAgIC8qKiBAcHJvcCB7RnVuY3Rpb259ICovXG4gICAgb25Mb2FkOiBhcHBseVN0eWxlT25Mb2FkLFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4xMC4wLCB0aGUgcHJvcGVydHkgbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXJcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM0QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHVuZGVmaW5lZFxuICB9XG59O1xuXG4vKipcbiAqIFRoZSBgZGF0YU9iamVjdGAgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBpbmZvcm1hdGlvbiB1c2VkIGJ5IFBvcHBlci5qcy5cbiAqIFRoaXMgb2JqZWN0IGlzIHBhc3NlZCB0byBtb2RpZmllcnMgYW5kIHRvIHRoZSBgb25DcmVhdGVgIGFuZCBgb25VcGRhdGVgIGNhbGxiYWNrcy5cbiAqIEBuYW1lIGRhdGFPYmplY3RcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmluc3RhbmNlIFRoZSBQb3BwZXIuanMgaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLnBsYWNlbWVudCBQbGFjZW1lbnQgYXBwbGllZCB0byBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50IFBsYWNlbWVudCBvcmlnaW5hbGx5IGRlZmluZWQgb24gaW5pdFxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmZsaXBwZWQgVHJ1ZSBpZiBwb3BwZXIgaGFzIGJlZW4gZmxpcHBlZCBieSBmbGlwIG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRhdGEuaGlkZSBUcnVlIGlmIHRoZSByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXQgb2YgYm91bmRhcmllcywgdXNlZnVsIHRvIGtub3cgd2hlbiB0byBoaWRlIHRoZSBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGRhdGEuYXJyb3dFbGVtZW50IE5vZGUgdXNlZCBhcyBhcnJvdyBieSBhcnJvdyBtb2RpZmllclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuc3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLiBJdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYXJyb3dTdHlsZXMgQW55IENTUyBwcm9wZXJ0eSBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgYXJyb3cuIEl0IGV4cGVjdHMgdGhlIEphdmFTY3JpcHQgbm9tZW5jbGF0dXJlIChlZy4gYG1hcmdpbkJvdHRvbWApXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5ib3VuZGFyaWVzIE9mZnNldHMgb2YgdGhlIHBvcHBlciBib3VuZGFyaWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzIFRoZSBtZWFzdXJlbWVudHMgb2YgcG9wcGVyLCByZWZlcmVuY2UgYW5kIGFycm93IGVsZW1lbnRzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnBvcHBlciBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucmVmZXJlbmNlIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5hcnJvd10gYHRvcGAgYW5kIGBsZWZ0YCBvZmZzZXRzLCBvbmx5IG9uZSBvZiB0aGVtIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gMFxuICovXG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIHByb3ZpZGVkIHRvIFBvcHBlci5qcyBjb25zdHJ1Y3Rvci48YnIgLz5cbiAqIFRoZXNlIGNhbiBiZSBvdmVycmlkZGVuIHVzaW5nIHRoZSBgb3B0aW9uc2AgYXJndW1lbnQgb2YgUG9wcGVyLmpzLjxiciAvPlxuICogVG8gb3ZlcnJpZGUgYW4gb3B0aW9uLCBzaW1wbHkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZVxuICogc3RydWN0dXJlIG9mIHRoZSBgb3B0aW9uc2Agb2JqZWN0LCBhcyB0aGUgM3JkIGFyZ3VtZW50LiBGb3IgZXhhbXBsZTpcbiAqIGBgYFxuICogbmV3IFBvcHBlcihyZWYsIHBvcCwge1xuICogICBtb2RpZmllcnM6IHtcbiAqICAgICBwcmV2ZW50T3ZlcmZsb3c6IHsgZW5hYmxlZDogZmFsc2UgfVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG52YXIgRGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBQb3BwZXIncyBwbGFjZW1lbnQuXG4gICAqIEBwcm9wIHtQb3BwZXIucGxhY2VtZW50c30gcGxhY2VtZW50PSdib3R0b20nXG4gICAqL1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuXG4gIC8qKlxuICAgKiBTZXQgdGhpcyB0byB0cnVlIGlmIHlvdSB3YW50IHBvcHBlciB0byBwb3NpdGlvbiBpdCBzZWxmIGluICdmaXhlZCcgbW9kZVxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gcG9zaXRpb25GaXhlZD1mYWxzZVxuICAgKi9cbiAgcG9zaXRpb25GaXhlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgZXZlbnRzIChyZXNpemUsIHNjcm9sbCkgYXJlIGluaXRpYWxseSBlbmFibGVkLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gZXZlbnRzRW5hYmxlZD10cnVlXG4gICAqL1xuICBldmVudHNFbmFibGVkOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlbW92ZSB0aGUgcG9wcGVyIHdoZW5cbiAgICogeW91IGNhbGwgdGhlIGBkZXN0cm95YCBtZXRob2QuXG4gICAqIEBwcm9wIHtCb29sZWFufSByZW1vdmVPbkRlc3Ryb3k9ZmFsc2VcbiAgICovXG4gIHJlbW92ZU9uRGVzdHJveTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgY3JlYXRlZC48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25DcmVhdGV9XG4gICAqL1xuICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoKSB7fSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyB1cGRhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5vdCBjYWxsZWRcbiAgICogb24gdGhlIGluaXRpYWxpemF0aW9uL2NyZWF0aW9uIG9mIHRoZSBwb3BwZXIsIGJ1dCBvbmx5IG9uIHN1YnNlcXVlbnRcbiAgICogdXBkYXRlcy48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25VcGRhdGV9XG4gICAqL1xuICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoKSB7fSxcblxuICAvKipcbiAgICogTGlzdCBvZiBtb2RpZmllcnMgdXNlZCB0byBtb2RpZnkgdGhlIG9mZnNldHMgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci5cbiAgICogVGhleSBwcm92aWRlIG1vc3Qgb2YgdGhlIGZ1bmN0aW9uYWxpdGllcyBvZiBQb3BwZXIuanMuXG4gICAqIEBwcm9wIHttb2RpZmllcnN9XG4gICAqL1xuICBtb2RpZmllcnM6IG1vZGlmaWVyc1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgb25DcmVhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIG9uVXBkYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vLyBVdGlsc1xuLy8gTWV0aG9kc1xudmFyIFBvcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUG9wcGVyLmpzIGluc3RhbmNlLlxuICAgKiBAY2xhc3MgUG9wcGVyXG4gICAqIEBwYXJhbSB7RWxlbWVudHxyZWZlcmVuY2VPYmplY3R9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSBUaGUgSFRNTCAvIFhNTCBlbGVtZW50IHVzZWQgYXMgdGhlIHBvcHBlclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFlvdXIgY3VzdG9tIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIG9uZXMgZGVmaW5lZCBpbiBbRGVmYXVsdHNdKCNkZWZhdWx0cylcbiAgICogQHJldHVybiB7T2JqZWN0fSBpbnN0YW5jZSAtIFRoZSBnZW5lcmF0ZWQgUG9wcGVyLmpzIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBvcHBlcik7XG5cbiAgICB0aGlzLnNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShfdGhpcy51cGRhdGUpO1xuICAgIH07XG5cbiAgICAvLyBtYWtlIHVwZGF0ZSgpIGRlYm91bmNlZCwgc28gdGhhdCBpdCBvbmx5IHJ1bnMgYXQgbW9zdCBvbmNlLXBlci10aWNrXG4gICAgdGhpcy51cGRhdGUgPSBkZWJvdW5jZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIHdpdGgge30gd2UgY3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvcHRpb25zIGluc2lkZSBpdFxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgLy8gaW5pdCBzdGF0ZVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc0Rlc3Ryb3llZDogZmFsc2UsXG4gICAgICBpc0NyZWF0ZWQ6IGZhbHNlLFxuICAgICAgc2Nyb2xsUGFyZW50czogW11cbiAgICB9O1xuXG4gICAgLy8gZ2V0IHJlZmVyZW5jZSBhbmQgcG9wcGVyIGVsZW1lbnRzIChhbGxvdyBqUXVlcnkgd3JhcHBlcnMpXG4gICAgdGhpcy5yZWZlcmVuY2UgPSByZWZlcmVuY2UgJiYgcmVmZXJlbmNlLmpxdWVyeSA/IHJlZmVyZW5jZVswXSA6IHJlZmVyZW5jZTtcbiAgICB0aGlzLnBvcHBlciA9IHBvcHBlciAmJiBwb3BwZXIuanF1ZXJ5ID8gcG9wcGVyWzBdIDogcG9wcGVyO1xuXG4gICAgLy8gRGVlcCBtZXJnZSBtb2RpZmllcnMgb3B0aW9uc1xuICAgIHRoaXMub3B0aW9ucy5tb2RpZmllcnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLm1vZGlmaWVycywgb3B0aW9ucy5tb2RpZmllcnMpKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBfdGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA9IF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzW25hbWVdIHx8IHt9LCBvcHRpb25zLm1vZGlmaWVycyA/IG9wdGlvbnMubW9kaWZpZXJzW25hbWVdIDoge30pO1xuICAgIH0pO1xuXG4gICAgLy8gUmVmYWN0b3JpbmcgbW9kaWZpZXJzJyBsaXN0IChPYmplY3QgPT4gQXJyYXkpXG4gICAgdGhpcy5tb2RpZmllcnMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMubW9kaWZpZXJzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIG5hbWU6IG5hbWVcbiAgICAgIH0sIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdKTtcbiAgICB9KVxuICAgIC8vIHNvcnQgdGhlIG1vZGlmaWVycyBieSBvcmRlclxuICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5vcmRlciAtIGIub3JkZXI7XG4gICAgfSk7XG5cbiAgICAvLyBtb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIHdoZW4gUG9wcGVyLmpzIGdldCBpbml0ZWRcbiAgICAvLyBzdWNoIGNvZGUgaXMgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgb2YgaXRzIG1vZGlmaWVyXG4gICAgLy8gdGhleSBjb3VsZCBhZGQgbmV3IHByb3BlcnRpZXMgdG8gdGhlaXIgb3B0aW9ucyBjb25maWd1cmF0aW9uXG4gICAgLy8gQkUgQVdBUkU6IGRvbid0IGFkZCBvcHRpb25zIHRvIGBvcHRpb25zLm1vZGlmaWVycy5uYW1lYCBidXQgdG8gYG1vZGlmaWVyT3B0aW9uc2AhXG4gICAgdGhpcy5tb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXJPcHRpb25zKSB7XG4gICAgICBpZiAobW9kaWZpZXJPcHRpb25zLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihtb2RpZmllck9wdGlvbnMub25Mb2FkKSkge1xuICAgICAgICBtb2RpZmllck9wdGlvbnMub25Mb2FkKF90aGlzLnJlZmVyZW5jZSwgX3RoaXMucG9wcGVyLCBfdGhpcy5vcHRpb25zLCBtb2RpZmllck9wdGlvbnMsIF90aGlzLnN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGZpcmUgdGhlIGZpcnN0IHVwZGF0ZSB0byBwb3NpdGlvbiB0aGUgcG9wcGVyIGluIHRoZSByaWdodCBwbGFjZVxuICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICB2YXIgZXZlbnRzRW5hYmxlZCA9IHRoaXMub3B0aW9ucy5ldmVudHNFbmFibGVkO1xuICAgIGlmIChldmVudHNFbmFibGVkKSB7XG4gICAgICAvLyBzZXR1cCBldmVudCBsaXN0ZW5lcnMsIHRoZXkgd2lsbCB0YWtlIGNhcmUgb2YgdXBkYXRlIHRoZSBwb3NpdGlvbiBpbiBzcGVjaWZpYyBzaXR1YXRpb25zXG4gICAgICB0aGlzLmVuYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkID0gZXZlbnRzRW5hYmxlZDtcbiAgfVxuXG4gIC8vIFdlIGNhbid0IHVzZSBjbGFzcyBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBkb24ndCBnZXQgbGlzdGVkIGluIHRoZVxuICAvLyBjbGFzcyBwcm90b3R5cGUgYW5kIGJyZWFrIHN0dWZmIGxpa2UgU2lub24gc3R1YnNcblxuXG4gIGNyZWF0ZUNsYXNzKFBvcHBlciwgW3tcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUkJDEoKSB7XG4gICAgICByZXR1cm4gdXBkYXRlLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3kkJDEoKSB7XG4gICAgICByZXR1cm4gZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VuYWJsZUV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlRXZlbnRMaXN0ZW5lcnMkJDEoKSB7XG4gICAgICByZXR1cm4gZW5hYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkaXNhYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMkJDEoKSB7XG4gICAgICByZXR1cm4gZGlzYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGFuIHVwZGF0ZS4gSXQgd2lsbCBydW4gb24gdGhlIG5leHQgVUkgdXBkYXRlIGF2YWlsYWJsZS5cbiAgICAgKiBAbWV0aG9kIHNjaGVkdWxlVXBkYXRlXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0aW9uIG9mIHV0aWxpdGllcyB1c2VmdWwgd2hlbiB3cml0aW5nIGN1c3RvbSBtb2RpZmllcnMuXG4gICAgICogU3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDEuNywgdGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIG9ubHkgaWYgeW91XG4gICAgICogaW5jbHVkZSBgcG9wcGVyLXV0aWxzLmpzYCBiZWZvcmUgYHBvcHBlci5qc2AuXG4gICAgICpcbiAgICAgKiAqKkRFUFJFQ0FUSU9OKio6IFRoaXMgd2F5IHRvIGFjY2VzcyBQb3BwZXJVdGlscyBpcyBkZXByZWNhdGVkXG4gICAgICogYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MiEgVXNlIHRoZSBQb3BwZXJVdGlscyBtb2R1bGUgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgKiBEdWUgdG8gdGhlIGhpZ2ggaW5zdGFiaWxpdHkgb2YgdGhlIG1ldGhvZHMgY29udGFpbmVkIGluIFV0aWxzLCB3ZSBjYW4ndFxuICAgICAqIGd1YXJhbnRlZSB0aGVtIHRvIGZvbGxvdyBzZW12ZXIuIFVzZSB0aGVtIGF0IHlvdXIgb3duIHJpc2shXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuOFxuICAgICAqIEBtZW1iZXIgVXRpbHNcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cbiAgfV0pO1xuICByZXR1cm4gUG9wcGVyO1xufSgpO1xuXG4vKipcbiAqIFRoZSBgcmVmZXJlbmNlT2JqZWN0YCBpcyBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgY29tcGF0aWJsZSB3aXRoIFBvcHBlci5qc1xuICogYW5kIGxldHMgeW91IHVzZSBpdCBhcyByZXBsYWNlbWVudCBvZiBhIHJlYWwgRE9NIG5vZGUuPGJyIC8+XG4gKiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCB0byBwb3NpdGlvbiBhIHBvcHBlciByZWxhdGl2ZWx5IHRvIGEgc2V0IG9mIGNvb3JkaW5hdGVzXG4gKiBpbiBjYXNlIHlvdSBkb24ndCBoYXZlIGEgRE9NIG5vZGUgdG8gdXNlIGFzIHJlZmVyZW5jZS5cbiAqXG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmZXJlbmNlT2JqZWN0LCBwb3BwZXJOb2RlKTtcbiAqIGBgYFxuICpcbiAqIE5COiBUaGlzIGZlYXR1cmUgaXNuJ3Qgc3VwcG9ydGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwLlxuICogQG5hbWUgcmVmZXJlbmNlT2JqZWN0XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkYXRhLmdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzZXQgb2YgY29vcmRpbmF0ZXMgY29tcGF0aWJsZSB3aXRoIHRoZSBuYXRpdmUgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgbWV0aG9kLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGEuY2xpZW50V2lkdGhcbiAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgd2lkdGggb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRIZWlnaHRcbiAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgaGVpZ2h0IG9mIHRoZSB2aXJ0dWFsIHJlZmVyZW5jZSBlbGVtZW50LlxuICovXG5cblxuUG9wcGVyLlV0aWxzID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKS5Qb3BwZXJVdGlscztcblBvcHBlci5wbGFjZW1lbnRzID0gcGxhY2VtZW50cztcblBvcHBlci5EZWZhdWx0cyA9IERlZmF1bHRzO1xuXG5yZXR1cm4gUG9wcGVyO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9wcGVyLmpzLm1hcFxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB2YXIgaGFzID0gcmVxdWlyZSgnLi9saWIvaGFzJyk7XG5cbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHsgLyoqLyB9XG4gIH07XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihcbiAgICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICtcbiAgICAgICAgICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArXG4gICAgICAgICAgICAgICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVzZXRzIHdhcm5pbmcgY2FjaGUgd2hlbiB0ZXN0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9XG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uV2l0aFJlc2V0KCkge31cbmVtcHR5RnVuY3Rpb25XaXRoUmVzZXQucmVzZXRXYXJuaW5nQ2FjaGUgPSBlbXB0eUZ1bmN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgdGhyb3cgZXJyO1xuICB9O1xuICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xuICBmdW5jdGlvbiBnZXRTaGltKCkge1xuICAgIHJldHVybiBzaGltO1xuICB9O1xuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IHNoaW0sXG4gICAgYmlnaW50OiBzaGltLFxuICAgIGJvb2w6IHNoaW0sXG4gICAgZnVuYzogc2hpbSxcbiAgICBudW1iZXI6IHNoaW0sXG4gICAgb2JqZWN0OiBzaGltLFxuICAgIHN0cmluZzogc2hpbSxcbiAgICBzeW1ib2w6IHNoaW0sXG5cbiAgICBhbnk6IHNoaW0sXG4gICAgYXJyYXlPZjogZ2V0U2hpbSxcbiAgICBlbGVtZW50OiBzaGltLFxuICAgIGVsZW1lbnRUeXBlOiBzaGltLFxuICAgIGluc3RhbmNlT2Y6IGdldFNoaW0sXG4gICAgbm9kZTogc2hpbSxcbiAgICBvYmplY3RPZjogZ2V0U2hpbSxcbiAgICBvbmVPZjogZ2V0U2hpbSxcbiAgICBvbmVPZlR5cGU6IGdldFNoaW0sXG4gICAgc2hhcGU6IGdldFNoaW0sXG4gICAgZXhhY3Q6IGdldFNoaW0sXG5cbiAgICBjaGVja1Byb3BUeXBlczogZW1wdHlGdW5jdGlvbldpdGhSZXNldCxcbiAgICByZXNldFdhcm5pbmdDYWNoZTogZW1wdHlGdW5jdGlvblxuICB9O1xuXG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL2xpYi9oYXMnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBiaWdpbnQ6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdiaWdpbnQnKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBlbGVtZW50VHlwZTogY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSwgZGF0YSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5kYXRhID0gZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgPyBkYXRhOiB7fTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSBlbHNlIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpLFxuICAgICAgICAgIHtleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZX1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFSZWFjdElzLmlzVmFsaWRFbGVtZW50VHlwZShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudCB0eXBlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgPyBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAnICsgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpICsgJyBhdCBpbmRleCAnICsgaSArICcuJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICB2YXIgY2hlY2tlclJlc3VsdCA9IGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChjaGVja2VyUmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hlY2tlclJlc3VsdC5kYXRhICYmIGhhcyhjaGVja2VyUmVzdWx0LmRhdGEsICdleHBlY3RlZFR5cGUnKSkge1xuICAgICAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChjaGVja2VyUmVzdWx0LmRhdGEuZXhwZWN0ZWRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGV4cGVjdGVkVHlwZXNNZXNzYWdlID0gKGV4cGVjdGVkVHlwZXMubGVuZ3RoID4gMCkgPyAnLCBleHBlY3RlZCBvbmUgb2YgdHlwZSBbJyArIGV4cGVjdGVkVHlwZXMuam9pbignLCAnKSArICddJzogJyc7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgJyArIGV4cGVjdGVkVHlwZXNNZXNzYWdlICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCB0eXBlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXkgKyAnYCBpcyBpbnZhbGlkOyAnICtcbiAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGUgKyAnYC4nXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgZ2V0UHJlY2lzZVR5cGUoY2hlY2tlcikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tIHByb3BzLlxuICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKGhhcyhzaGFwZVR5cGVzLCBrZXkpICYmIHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIGdldFByZWNpc2VUeXBlKGNoZWNrZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBmYWxzeSB2YWx1ZSBjYW4ndCBiZSBhIFN5bWJvbFxuICAgIGlmICghcHJvcFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBjaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZTtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcbiIsIm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy51bmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24gPSB2b2lkIDA7XG52YXIgVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uXzEgPSByZXF1aXJlKFwiLi9VbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25cIik7XG5mdW5jdGlvbiB1bmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24oZnJvbSwgdG8sIHJuZykge1xuICAgIGlmIChybmcgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IHJuZy5jbG9uZSgpO1xuICAgICAgICByZXR1cm4gWygwLCBVbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25fMS51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24pKGZyb20sIHRvLCBuZXh0Um5nKSwgbmV4dFJuZ107XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAocm5nKSB7XG4gICAgICAgIHZhciBuZXh0Um5nID0gcm5nLmNsb25lKCk7XG4gICAgICAgIHJldHVybiBbKDAsIFVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbl8xLnVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbikoZnJvbSwgdG8sIG5leHRSbmcpLCBuZXh0Um5nXTtcbiAgICB9O1xufVxuZXhwb3J0cy51bmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24gPSB1bmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24gPSB2b2lkIDA7XG52YXIgVW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbl8xID0gcmVxdWlyZShcIi4vVW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvblwiKTtcbmZ1bmN0aW9uIHVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24oZnJvbSwgdG8sIHJuZykge1xuICAgIGlmIChybmcgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IHJuZy5jbG9uZSgpO1xuICAgICAgICByZXR1cm4gWygwLCBVbnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uXzEudW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbikoZnJvbSwgdG8sIG5leHRSbmcpLCBuZXh0Um5nXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChybmcpIHtcbiAgICAgICAgdmFyIG5leHRSbmcgPSBybmcuY2xvbmUoKTtcbiAgICAgICAgcmV0dXJuIFsoMCwgVW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbl8xLnVuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24pKGZyb20sIHRvLCBuZXh0Um5nKSwgbmV4dFJuZ107XG4gICAgfTtcbn1cbmV4cG9ydHMudW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbiA9IHVuaWZvcm1CaWdJbnREaXN0cmlidXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnVuaWZvcm1JbnREaXN0cmlidXRpb24gPSB2b2lkIDA7XG52YXIgVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbl8xID0gcmVxdWlyZShcIi4vVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvblwiKTtcbmZ1bmN0aW9uIHVuaWZvcm1JbnREaXN0cmlidXRpb24oZnJvbSwgdG8sIHJuZykge1xuICAgIGlmIChybmcgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IHJuZy5jbG9uZSgpO1xuICAgICAgICByZXR1cm4gWygwLCBVbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uXzEudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbikoZnJvbSwgdG8sIG5leHRSbmcpLCBuZXh0Um5nXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChybmcpIHtcbiAgICAgICAgdmFyIG5leHRSbmcgPSBybmcuY2xvbmUoKTtcbiAgICAgICAgcmV0dXJuIFsoMCwgVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbl8xLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb24pKGZyb20sIHRvLCBuZXh0Um5nKSwgbmV4dFJuZ107XG4gICAgfTtcbn1cbmV4cG9ydHMudW5pZm9ybUludERpc3RyaWJ1dGlvbiA9IHVuaWZvcm1JbnREaXN0cmlidXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbiA9IHZvaWQgMDtcbnZhciBBcnJheUludF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxzL0FycmF5SW50XCIpO1xudmFyIFVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbkludGVybmFsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbHMvVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uSW50ZXJuYWxcIik7XG5mdW5jdGlvbiB1bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24oZnJvbSwgdG8sIHJuZykge1xuICAgIHZhciByYW5nZVNpemUgPSAoMCwgQXJyYXlJbnRfMS50cmltQXJyYXlJbnRJbnBsYWNlKSgoMCwgQXJyYXlJbnRfMS5hZGRPbmVUb1Bvc2l0aXZlQXJyYXlJbnQpKCgwLCBBcnJheUludF8xLnN1YnN0cmFjdEFycmF5SW50VG9OZXcpKHRvLCBmcm9tKSkpO1xuICAgIHZhciBlbXB0eUFycmF5SW50RGF0YSA9IHJhbmdlU2l6ZS5kYXRhLnNsaWNlKDApO1xuICAgIHZhciBnID0gKDAsIFVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbkludGVybmFsXzEudW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uSW50ZXJuYWwpKGVtcHR5QXJyYXlJbnREYXRhLCByYW5nZVNpemUuZGF0YSwgcm5nKTtcbiAgICByZXR1cm4gKDAsIEFycmF5SW50XzEudHJpbUFycmF5SW50SW5wbGFjZSkoKDAsIEFycmF5SW50XzEuYWRkQXJyYXlJbnRUb05ldykoeyBzaWduOiAxLCBkYXRhOiBnIH0sIGZyb20pKTtcbn1cbmV4cG9ydHMudW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uID0gdW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy51bnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uID0gdm9pZCAwO1xudmFyIFNCaWdJbnQgPSB0eXBlb2YgQmlnSW50ICE9PSAndW5kZWZpbmVkJyA/IEJpZ0ludCA6IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIHVuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24oZnJvbSwgdG8sIHJuZykge1xuICAgIHZhciBkaWZmID0gdG8gLSBmcm9tICsgU0JpZ0ludCgxKTtcbiAgICB2YXIgTWluUm5nID0gU0JpZ0ludChybmcubWluKCkpO1xuICAgIHZhciBOdW1WYWx1ZXMgPSBTQmlnSW50KHJuZy5tYXgoKSAtIHJuZy5taW4oKSArIDEpO1xuICAgIHZhciBGaW5hbE51bVZhbHVlcyA9IE51bVZhbHVlcztcbiAgICB2YXIgTnVtSXRlcmF0aW9ucyA9IFNCaWdJbnQoMSk7XG4gICAgd2hpbGUgKEZpbmFsTnVtVmFsdWVzIDwgZGlmZikge1xuICAgICAgICBGaW5hbE51bVZhbHVlcyAqPSBOdW1WYWx1ZXM7XG4gICAgICAgICsrTnVtSXRlcmF0aW9ucztcbiAgICB9XG4gICAgdmFyIE1heEFjY2VwdGVkUmFuZG9tID0gRmluYWxOdW1WYWx1ZXMgLSAoRmluYWxOdW1WYWx1ZXMgJSBkaWZmKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBTQmlnSW50KDApO1xuICAgICAgICBmb3IgKHZhciBudW0gPSBTQmlnSW50KDApOyBudW0gIT09IE51bUl0ZXJhdGlvbnM7ICsrbnVtKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gcm5nLnVuc2FmZU5leHQoKTtcbiAgICAgICAgICAgIHZhbHVlID0gTnVtVmFsdWVzICogdmFsdWUgKyAoU0JpZ0ludChvdXQpIC0gTWluUm5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPCBNYXhBY2NlcHRlZFJhbmRvbSkge1xuICAgICAgICAgICAgdmFyIGluRGlmZiA9IHZhbHVlICUgZGlmZjtcbiAgICAgICAgICAgIHJldHVybiBpbkRpZmYgKyBmcm9tO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy51bnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uID0gdW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbiA9IHZvaWQgMDtcbnZhciBVbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uSW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFscy9VbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uSW50ZXJuYWxcIik7XG52YXIgQXJyYXlJbnRfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFscy9BcnJheUludFwiKTtcbnZhciBVbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxzL1Vuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbkludGVybmFsXCIpO1xudmFyIHNhZmVOdW1iZXJNYXhTYWZlSW50ZWdlciA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xudmFyIHNoYXJlZEEgPSB7IHNpZ246IDEsIGRhdGE6IFswLCAwXSB9O1xudmFyIHNoYXJlZEIgPSB7IHNpZ246IDEsIGRhdGE6IFswLCAwXSB9O1xudmFyIHNoYXJlZEMgPSB7IHNpZ246IDEsIGRhdGE6IFswLCAwXSB9O1xudmFyIHNoYXJlZERhdGEgPSBbMCwgMF07XG5mdW5jdGlvbiB1bmlmb3JtTGFyZ2VJbnRJbnRlcm5hbChmcm9tLCB0bywgcmFuZ2VTaXplLCBybmcpIHtcbiAgICB2YXIgcmFuZ2VTaXplQXJyYXlJbnRWYWx1ZSA9IHJhbmdlU2l6ZSA8PSBzYWZlTnVtYmVyTWF4U2FmZUludGVnZXJcbiAgICAgICAgPyAoMCwgQXJyYXlJbnRfMS5mcm9tTnVtYmVyVG9BcnJheUludDY0KShzaGFyZWRDLCByYW5nZVNpemUpXG4gICAgICAgIDogKDAsIEFycmF5SW50XzEuc3Vic3RyYWN0QXJyYXlJbnQ2NCkoc2hhcmVkQywgKDAsIEFycmF5SW50XzEuZnJvbU51bWJlclRvQXJyYXlJbnQ2NCkoc2hhcmVkQSwgdG8pLCAoMCwgQXJyYXlJbnRfMS5mcm9tTnVtYmVyVG9BcnJheUludDY0KShzaGFyZWRCLCBmcm9tKSk7XG4gICAgaWYgKHJhbmdlU2l6ZUFycmF5SW50VmFsdWUuZGF0YVsxXSA9PT0gMHhmZmZmZmZmZikge1xuICAgICAgICByYW5nZVNpemVBcnJheUludFZhbHVlLmRhdGFbMF0gKz0gMTtcbiAgICAgICAgcmFuZ2VTaXplQXJyYXlJbnRWYWx1ZS5kYXRhWzFdID0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJhbmdlU2l6ZUFycmF5SW50VmFsdWUuZGF0YVsxXSArPSAxO1xuICAgIH1cbiAgICAoMCwgVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uSW50ZXJuYWxfMS51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbCkoc2hhcmVkRGF0YSwgcmFuZ2VTaXplQXJyYXlJbnRWYWx1ZS5kYXRhLCBybmcpO1xuICAgIHJldHVybiBzaGFyZWREYXRhWzBdICogMHgxMDAwMDAwMDAgKyBzaGFyZWREYXRhWzFdICsgZnJvbTtcbn1cbmZ1bmN0aW9uIHVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb24oZnJvbSwgdG8sIHJuZykge1xuICAgIHZhciByYW5nZVNpemUgPSB0byAtIGZyb207XG4gICAgaWYgKHJhbmdlU2l6ZSA8PSAweGZmZmZmZmZmKSB7XG4gICAgICAgIHZhciBnID0gKDAsIFVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbF8xLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbCkocmFuZ2VTaXplICsgMSwgcm5nKTtcbiAgICAgICAgcmV0dXJuIGcgKyBmcm9tO1xuICAgIH1cbiAgICByZXR1cm4gdW5pZm9ybUxhcmdlSW50SW50ZXJuYWwoZnJvbSwgdG8sIHJhbmdlU2l6ZSwgcm5nKTtcbn1cbmV4cG9ydHMudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbiA9IHVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnN1YnN0cmFjdEFycmF5SW50NjQgPSBleHBvcnRzLmZyb21OdW1iZXJUb0FycmF5SW50NjQgPSBleHBvcnRzLnRyaW1BcnJheUludElucGxhY2UgPSBleHBvcnRzLnN1YnN0cmFjdEFycmF5SW50VG9OZXcgPSBleHBvcnRzLmFkZE9uZVRvUG9zaXRpdmVBcnJheUludCA9IGV4cG9ydHMuYWRkQXJyYXlJbnRUb05ldyA9IHZvaWQgMDtcbmZ1bmN0aW9uIGFkZEFycmF5SW50VG9OZXcoYXJyYXlJbnRBLCBhcnJheUludEIpIHtcbiAgICBpZiAoYXJyYXlJbnRBLnNpZ24gIT09IGFycmF5SW50Qi5zaWduKSB7XG4gICAgICAgIHJldHVybiBzdWJzdHJhY3RBcnJheUludFRvTmV3KGFycmF5SW50QSwgeyBzaWduOiAtYXJyYXlJbnRCLnNpZ24sIGRhdGE6IGFycmF5SW50Qi5kYXRhIH0pO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IFtdO1xuICAgIHZhciByZW1pbmRlciA9IDA7XG4gICAgdmFyIGRhdGFBID0gYXJyYXlJbnRBLmRhdGE7XG4gICAgdmFyIGRhdGFCID0gYXJyYXlJbnRCLmRhdGE7XG4gICAgZm9yICh2YXIgaW5kZXhBID0gZGF0YUEubGVuZ3RoIC0gMSwgaW5kZXhCID0gZGF0YUIubGVuZ3RoIC0gMTsgaW5kZXhBID49IDAgfHwgaW5kZXhCID49IDA7IC0taW5kZXhBLCAtLWluZGV4Qikge1xuICAgICAgICB2YXIgdkEgPSBpbmRleEEgPj0gMCA/IGRhdGFBW2luZGV4QV0gOiAwO1xuICAgICAgICB2YXIgdkIgPSBpbmRleEIgPj0gMCA/IGRhdGFCW2luZGV4Ql0gOiAwO1xuICAgICAgICB2YXIgY3VycmVudCA9IHZBICsgdkIgKyByZW1pbmRlcjtcbiAgICAgICAgZGF0YS5wdXNoKGN1cnJlbnQgPj4+IDApO1xuICAgICAgICByZW1pbmRlciA9IH5+KGN1cnJlbnQgLyAweDEwMDAwMDAwMCk7XG4gICAgfVxuICAgIGlmIChyZW1pbmRlciAhPT0gMCkge1xuICAgICAgICBkYXRhLnB1c2gocmVtaW5kZXIpO1xuICAgIH1cbiAgICByZXR1cm4geyBzaWduOiBhcnJheUludEEuc2lnbiwgZGF0YTogZGF0YS5yZXZlcnNlKCkgfTtcbn1cbmV4cG9ydHMuYWRkQXJyYXlJbnRUb05ldyA9IGFkZEFycmF5SW50VG9OZXc7XG5mdW5jdGlvbiBhZGRPbmVUb1Bvc2l0aXZlQXJyYXlJbnQoYXJyYXlJbnQpIHtcbiAgICBhcnJheUludC5zaWduID0gMTtcbiAgICB2YXIgZGF0YSA9IGFycmF5SW50LmRhdGE7XG4gICAgZm9yICh2YXIgaW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7IGluZGV4ID49IDA7IC0taW5kZXgpIHtcbiAgICAgICAgaWYgKGRhdGFbaW5kZXhdID09PSAweGZmZmZmZmZmKSB7XG4gICAgICAgICAgICBkYXRhW2luZGV4XSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhW2luZGV4XSArPSAxO1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5SW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGRhdGEudW5zaGlmdCgxKTtcbiAgICByZXR1cm4gYXJyYXlJbnQ7XG59XG5leHBvcnRzLmFkZE9uZVRvUG9zaXRpdmVBcnJheUludCA9IGFkZE9uZVRvUG9zaXRpdmVBcnJheUludDtcbmZ1bmN0aW9uIGlzU3RyaWN0bHlTbWFsbGVyKGRhdGFBLCBkYXRhQikge1xuICAgIHZhciBtYXhMZW5ndGggPSBNYXRoLm1heChkYXRhQS5sZW5ndGgsIGRhdGFCLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IG1heExlbmd0aDsgKytpbmRleCkge1xuICAgICAgICB2YXIgaW5kZXhBID0gaW5kZXggKyBkYXRhQS5sZW5ndGggLSBtYXhMZW5ndGg7XG4gICAgICAgIHZhciBpbmRleEIgPSBpbmRleCArIGRhdGFCLmxlbmd0aCAtIG1heExlbmd0aDtcbiAgICAgICAgdmFyIHZBID0gaW5kZXhBID49IDAgPyBkYXRhQVtpbmRleEFdIDogMDtcbiAgICAgICAgdmFyIHZCID0gaW5kZXhCID49IDAgPyBkYXRhQltpbmRleEJdIDogMDtcbiAgICAgICAgaWYgKHZBIDwgdkIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHZBID4gdkIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHN1YnN0cmFjdEFycmF5SW50VG9OZXcoYXJyYXlJbnRBLCBhcnJheUludEIpIHtcbiAgICBpZiAoYXJyYXlJbnRBLnNpZ24gIT09IGFycmF5SW50Qi5zaWduKSB7XG4gICAgICAgIHJldHVybiBhZGRBcnJheUludFRvTmV3KGFycmF5SW50QSwgeyBzaWduOiAtYXJyYXlJbnRCLnNpZ24sIGRhdGE6IGFycmF5SW50Qi5kYXRhIH0pO1xuICAgIH1cbiAgICB2YXIgZGF0YUEgPSBhcnJheUludEEuZGF0YTtcbiAgICB2YXIgZGF0YUIgPSBhcnJheUludEIuZGF0YTtcbiAgICBpZiAoaXNTdHJpY3RseVNtYWxsZXIoZGF0YUEsIGRhdGFCKSkge1xuICAgICAgICB2YXIgb3V0ID0gc3Vic3RyYWN0QXJyYXlJbnRUb05ldyhhcnJheUludEIsIGFycmF5SW50QSk7XG4gICAgICAgIG91dC5zaWduID0gLW91dC5zaWduO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IFtdO1xuICAgIHZhciByZW1pbmRlciA9IDA7XG4gICAgZm9yICh2YXIgaW5kZXhBID0gZGF0YUEubGVuZ3RoIC0gMSwgaW5kZXhCID0gZGF0YUIubGVuZ3RoIC0gMTsgaW5kZXhBID49IDAgfHwgaW5kZXhCID49IDA7IC0taW5kZXhBLCAtLWluZGV4Qikge1xuICAgICAgICB2YXIgdkEgPSBpbmRleEEgPj0gMCA/IGRhdGFBW2luZGV4QV0gOiAwO1xuICAgICAgICB2YXIgdkIgPSBpbmRleEIgPj0gMCA/IGRhdGFCW2luZGV4Ql0gOiAwO1xuICAgICAgICB2YXIgY3VycmVudCA9IHZBIC0gdkIgLSByZW1pbmRlcjtcbiAgICAgICAgZGF0YS5wdXNoKGN1cnJlbnQgPj4+IDApO1xuICAgICAgICByZW1pbmRlciA9IGN1cnJlbnQgPCAwID8gMSA6IDA7XG4gICAgfVxuICAgIHJldHVybiB7IHNpZ246IGFycmF5SW50QS5zaWduLCBkYXRhOiBkYXRhLnJldmVyc2UoKSB9O1xufVxuZXhwb3J0cy5zdWJzdHJhY3RBcnJheUludFRvTmV3ID0gc3Vic3RyYWN0QXJyYXlJbnRUb05ldztcbmZ1bmN0aW9uIHRyaW1BcnJheUludElucGxhY2UoYXJyYXlJbnQpIHtcbiAgICB2YXIgZGF0YSA9IGFycmF5SW50LmRhdGE7XG4gICAgdmFyIGZpcnN0Tm9uWmVybyA9IDA7XG4gICAgZm9yICg7IGZpcnN0Tm9uWmVybyAhPT0gZGF0YS5sZW5ndGggJiYgZGF0YVtmaXJzdE5vblplcm9dID09PSAwOyArK2ZpcnN0Tm9uWmVybykgeyB9XG4gICAgaWYgKGZpcnN0Tm9uWmVybyA9PT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgYXJyYXlJbnQuc2lnbiA9IDE7XG4gICAgICAgIGFycmF5SW50LmRhdGEgPSBbMF07XG4gICAgICAgIHJldHVybiBhcnJheUludDtcbiAgICB9XG4gICAgZGF0YS5zcGxpY2UoMCwgZmlyc3ROb25aZXJvKTtcbiAgICByZXR1cm4gYXJyYXlJbnQ7XG59XG5leHBvcnRzLnRyaW1BcnJheUludElucGxhY2UgPSB0cmltQXJyYXlJbnRJbnBsYWNlO1xuZnVuY3Rpb24gZnJvbU51bWJlclRvQXJyYXlJbnQ2NChvdXQsIG4pIHtcbiAgICBpZiAobiA8IDApIHtcbiAgICAgICAgdmFyIHBvc04gPSAtbjtcbiAgICAgICAgb3V0LnNpZ24gPSAtMTtcbiAgICAgICAgb3V0LmRhdGFbMF0gPSB+fihwb3NOIC8gMHgxMDAwMDAwMDApO1xuICAgICAgICBvdXQuZGF0YVsxXSA9IHBvc04gPj4+IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvdXQuc2lnbiA9IDE7XG4gICAgICAgIG91dC5kYXRhWzBdID0gfn4obiAvIDB4MTAwMDAwMDAwKTtcbiAgICAgICAgb3V0LmRhdGFbMV0gPSBuID4+PiAwO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuZXhwb3J0cy5mcm9tTnVtYmVyVG9BcnJheUludDY0ID0gZnJvbU51bWJlclRvQXJyYXlJbnQ2NDtcbmZ1bmN0aW9uIHN1YnN0cmFjdEFycmF5SW50NjQob3V0LCBhcnJheUludEEsIGFycmF5SW50Qikge1xuICAgIHZhciBsb3dBID0gYXJyYXlJbnRBLmRhdGFbMV07XG4gICAgdmFyIGhpZ2hBID0gYXJyYXlJbnRBLmRhdGFbMF07XG4gICAgdmFyIHNpZ25BID0gYXJyYXlJbnRBLnNpZ247XG4gICAgdmFyIGxvd0IgPSBhcnJheUludEIuZGF0YVsxXTtcbiAgICB2YXIgaGlnaEIgPSBhcnJheUludEIuZGF0YVswXTtcbiAgICB2YXIgc2lnbkIgPSBhcnJheUludEIuc2lnbjtcbiAgICBvdXQuc2lnbiA9IDE7XG4gICAgaWYgKHNpZ25BID09PSAxICYmIHNpZ25CID09PSAtMSkge1xuICAgICAgICB2YXIgbG93XzEgPSBsb3dBICsgbG93QjtcbiAgICAgICAgdmFyIGhpZ2ggPSBoaWdoQSArIGhpZ2hCICsgKGxvd18xID4gMHhmZmZmZmZmZiA/IDEgOiAwKTtcbiAgICAgICAgb3V0LmRhdGFbMF0gPSBoaWdoID4+PiAwO1xuICAgICAgICBvdXQuZGF0YVsxXSA9IGxvd18xID4+PiAwO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB2YXIgbG93Rmlyc3QgPSBsb3dBO1xuICAgIHZhciBoaWdoRmlyc3QgPSBoaWdoQTtcbiAgICB2YXIgbG93U2Vjb25kID0gbG93QjtcbiAgICB2YXIgaGlnaFNlY29uZCA9IGhpZ2hCO1xuICAgIGlmIChzaWduQSA9PT0gLTEpIHtcbiAgICAgICAgbG93Rmlyc3QgPSBsb3dCO1xuICAgICAgICBoaWdoRmlyc3QgPSBoaWdoQjtcbiAgICAgICAgbG93U2Vjb25kID0gbG93QTtcbiAgICAgICAgaGlnaFNlY29uZCA9IGhpZ2hBO1xuICAgIH1cbiAgICB2YXIgcmVtaW5kZXJMb3cgPSAwO1xuICAgIHZhciBsb3cgPSBsb3dGaXJzdCAtIGxvd1NlY29uZDtcbiAgICBpZiAobG93IDwgMCkge1xuICAgICAgICByZW1pbmRlckxvdyA9IDE7XG4gICAgICAgIGxvdyA9IGxvdyA+Pj4gMDtcbiAgICB9XG4gICAgb3V0LmRhdGFbMF0gPSBoaWdoRmlyc3QgLSBoaWdoU2Vjb25kIC0gcmVtaW5kZXJMb3c7XG4gICAgb3V0LmRhdGFbMV0gPSBsb3c7XG4gICAgcmV0dXJuIG91dDtcbn1cbmV4cG9ydHMuc3Vic3RyYWN0QXJyYXlJbnQ2NCA9IHN1YnN0cmFjdEFycmF5SW50NjQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbkludGVybmFsID0gdm9pZCAwO1xudmFyIFVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsXCIpO1xuZnVuY3Rpb24gdW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uSW50ZXJuYWwob3V0LCByYW5nZVNpemUsIHJuZykge1xuICAgIHZhciByYW5nZUxlbmd0aCA9IHJhbmdlU2l6ZS5sZW5ndGg7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCAhPT0gcmFuZ2VMZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBpbmRleFJhbmdlU2l6ZSA9IGluZGV4ID09PSAwID8gcmFuZ2VTaXplWzBdICsgMSA6IDB4MTAwMDAwMDAwO1xuICAgICAgICAgICAgdmFyIGcgPSAoMCwgVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsXzEudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsKShpbmRleFJhbmdlU2l6ZSwgcm5nKTtcbiAgICAgICAgICAgIG91dFtpbmRleF0gPSBnO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggIT09IHJhbmdlTGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IG91dFtpbmRleF07XG4gICAgICAgICAgICB2YXIgY3VycmVudEluUmFuZ2UgPSByYW5nZVNpemVbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPCBjdXJyZW50SW5SYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50ID4gY3VycmVudEluUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uSW50ZXJuYWwgPSB1bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsID0gdm9pZCAwO1xuZnVuY3Rpb24gdW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsKHJhbmdlU2l6ZSwgcm5nKSB7XG4gICAgdmFyIE1pblJuZyA9IHJuZy5taW4oKTtcbiAgICB2YXIgTnVtVmFsdWVzID0gcm5nLm1heCgpIC0gcm5nLm1pbigpICsgMTtcbiAgICBpZiAocmFuZ2VTaXplIDw9IE51bVZhbHVlcykge1xuICAgICAgICB2YXIgbnJuZ18xID0gcm5nO1xuICAgICAgICB2YXIgTWF4QWxsb3dlZCA9IE51bVZhbHVlcyAtIChOdW1WYWx1ZXMgJSByYW5nZVNpemUpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIG91dCA9IG5ybmdfMS51bnNhZmVOZXh0KCk7XG4gICAgICAgICAgICB2YXIgZGVsdGFWID0gb3V0IC0gTWluUm5nO1xuICAgICAgICAgICAgaWYgKGRlbHRhViA8IE1heEFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsdGFWICUgcmFuZ2VTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBGaW5hbE51bVZhbHVlcyA9IE51bVZhbHVlcyAqIE51bVZhbHVlcztcbiAgICB2YXIgTnVtSXRlcmF0aW9ucyA9IDI7XG4gICAgd2hpbGUgKEZpbmFsTnVtVmFsdWVzIDwgcmFuZ2VTaXplKSB7XG4gICAgICAgIEZpbmFsTnVtVmFsdWVzICo9IE51bVZhbHVlcztcbiAgICAgICAgKytOdW1JdGVyYXRpb25zO1xuICAgIH1cbiAgICB2YXIgTWF4QWNjZXB0ZWRSYW5kb20gPSByYW5nZVNpemUgKiBNYXRoLmZsb29yKCgxICogRmluYWxOdW1WYWx1ZXMpIC8gcmFuZ2VTaXplKTtcbiAgICB2YXIgbnJuZyA9IHJuZztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSAwO1xuICAgICAgICBmb3IgKHZhciBudW0gPSAwOyBudW0gIT09IE51bUl0ZXJhdGlvbnM7ICsrbnVtKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gbnJuZy51bnNhZmVOZXh0KCk7XG4gICAgICAgICAgICB2YWx1ZSA9IE51bVZhbHVlcyAqIHZhbHVlICsgKG91dCAtIE1pblJuZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgTWF4QWNjZXB0ZWRSYW5kb20pIHtcbiAgICAgICAgICAgIHZhciBpbkRpZmYgPSB2YWx1ZSAtIHJhbmdlU2l6ZSAqIE1hdGguZmxvb3IoKDEgKiB2YWx1ZSkgLyByYW5nZVNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIGluRGlmZjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsID0gdW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jb25ncnVlbnRpYWwzMiA9IGV4cG9ydHMuY29uZ3J1ZW50aWFsID0gdm9pZCAwO1xudmFyIE1VTFRJUExJRVIgPSAweDAwMDM0M2ZkO1xudmFyIElOQ1JFTUVOVCA9IDB4MDAyNjllYzM7XG52YXIgTUFTSyA9IDB4ZmZmZmZmZmY7XG52YXIgTUFTS18yID0gKDEgPDwgMzEpIC0gMTtcbnZhciBjb21wdXRlTmV4dFNlZWQgPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgIHJldHVybiAoc2VlZCAqIE1VTFRJUExJRVIgKyBJTkNSRU1FTlQpICYgTUFTSztcbn07XG52YXIgY29tcHV0ZVZhbHVlRnJvbU5leHRTZWVkID0gZnVuY3Rpb24gKG5leHRzZWVkKSB7XG4gICAgcmV0dXJuIChuZXh0c2VlZCAmIE1BU0tfMikgPj4gMTY7XG59O1xudmFyIExpbmVhckNvbmdydWVudGlhbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGluZWFyQ29uZ3J1ZW50aWFsKHNlZWQpIHtcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICB9XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBMaW5lYXJDb25ncnVlbnRpYWwubWluO1xuICAgIH07XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBMaW5lYXJDb25ncnVlbnRpYWwubWF4O1xuICAgIH07XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lYXJDb25ncnVlbnRpYWwodGhpcy5zZWVkKTtcbiAgICB9O1xuICAgIExpbmVhckNvbmdydWVudGlhbC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHRSbmcgPSBuZXcgTGluZWFyQ29uZ3J1ZW50aWFsKHRoaXMuc2VlZCk7XG4gICAgICAgIHZhciBvdXQgPSBuZXh0Um5nLnVuc2FmZU5leHQoKTtcbiAgICAgICAgcmV0dXJuIFtvdXQsIG5leHRSbmddO1xuICAgIH07XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsLnByb3RvdHlwZS51bnNhZmVOZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNlZWQgPSBjb21wdXRlTmV4dFNlZWQodGhpcy5zZWVkKTtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVWYWx1ZUZyb21OZXh0U2VlZCh0aGlzLnNlZWQpO1xuICAgIH07XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsLm1pbiA9IDA7XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsLm1heCA9IE1hdGgucG93KDIsIDE1KSAtIDE7XG4gICAgcmV0dXJuIExpbmVhckNvbmdydWVudGlhbDtcbn0oKSk7XG52YXIgTGluZWFyQ29uZ3J1ZW50aWFsMzIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpbmVhckNvbmdydWVudGlhbDMyKHNlZWQpIHtcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICB9XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsMzIucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIExpbmVhckNvbmdydWVudGlhbDMyLm1pbjtcbiAgICB9O1xuICAgIExpbmVhckNvbmdydWVudGlhbDMyLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBMaW5lYXJDb25ncnVlbnRpYWwzMi5tYXg7XG4gICAgfTtcbiAgICBMaW5lYXJDb25ncnVlbnRpYWwzMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluZWFyQ29uZ3J1ZW50aWFsMzIodGhpcy5zZWVkKTtcbiAgICB9O1xuICAgIExpbmVhckNvbmdydWVudGlhbDMyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IG5ldyBMaW5lYXJDb25ncnVlbnRpYWwzMih0aGlzLnNlZWQpO1xuICAgICAgICB2YXIgb3V0ID0gbmV4dFJuZy51bnNhZmVOZXh0KCk7XG4gICAgICAgIHJldHVybiBbb3V0LCBuZXh0Um5nXTtcbiAgICB9O1xuICAgIExpbmVhckNvbmdydWVudGlhbDMyLnByb3RvdHlwZS51bnNhZmVOZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgczEgPSBjb21wdXRlTmV4dFNlZWQodGhpcy5zZWVkKTtcbiAgICAgICAgdmFyIHYxID0gY29tcHV0ZVZhbHVlRnJvbU5leHRTZWVkKHMxKTtcbiAgICAgICAgdmFyIHMyID0gY29tcHV0ZU5leHRTZWVkKHMxKTtcbiAgICAgICAgdmFyIHYyID0gY29tcHV0ZVZhbHVlRnJvbU5leHRTZWVkKHMyKTtcbiAgICAgICAgdGhpcy5zZWVkID0gY29tcHV0ZU5leHRTZWVkKHMyKTtcbiAgICAgICAgdmFyIHYzID0gY29tcHV0ZVZhbHVlRnJvbU5leHRTZWVkKHRoaXMuc2VlZCk7XG4gICAgICAgIHZhciB2bmV4dCA9IHYzICsgKCh2MiArICh2MSA8PCAxNSkpIDw8IDE1KTtcbiAgICAgICAgcmV0dXJuICgodm5leHQgKyAweDgwMDAwMDAwKSB8IDApICsgMHg4MDAwMDAwMDtcbiAgICB9O1xuICAgIExpbmVhckNvbmdydWVudGlhbDMyLm1pbiA9IDA7XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsMzIubWF4ID0gMHhmZmZmZmZmZjtcbiAgICByZXR1cm4gTGluZWFyQ29uZ3J1ZW50aWFsMzI7XG59KCkpO1xudmFyIGNvbmdydWVudGlhbCA9IGZ1bmN0aW9uIChzZWVkKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5lYXJDb25ncnVlbnRpYWwoc2VlZCk7XG59O1xuZXhwb3J0cy5jb25ncnVlbnRpYWwgPSBjb25ncnVlbnRpYWw7XG52YXIgY29uZ3J1ZW50aWFsMzIgPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgIHJldHVybiBuZXcgTGluZWFyQ29uZ3J1ZW50aWFsMzIoc2VlZCk7XG59O1xuZXhwb3J0cy5jb25ncnVlbnRpYWwzMiA9IGNvbmdydWVudGlhbDMyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIE1lcnNlbm5lVHdpc3RlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVyc2VubmVUd2lzdGVyKHN0YXRlcywgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBzdGF0ZXM7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB9XG4gICAgTWVyc2VubmVUd2lzdGVyLnR3aXN0ID0gZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgICAgdmFyIG10ID0gcHJldi5zbGljZSgpO1xuICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggIT09IE1lcnNlbm5lVHdpc3Rlci5OIC0gTWVyc2VubmVUd2lzdGVyLk07ICsraWR4KSB7XG4gICAgICAgICAgICB2YXIgeV8xID0gKG10W2lkeF0gJiBNZXJzZW5uZVR3aXN0ZXIuTUFTS19VUFBFUikgKyAobXRbaWR4ICsgMV0gJiBNZXJzZW5uZVR3aXN0ZXIuTUFTS19MT1dFUik7XG4gICAgICAgICAgICBtdFtpZHhdID0gbXRbaWR4ICsgTWVyc2VubmVUd2lzdGVyLk1dIF4gKHlfMSA+Pj4gMSkgXiAoLSh5XzEgJiAxKSAmIE1lcnNlbm5lVHdpc3Rlci5BKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpZHggPSBNZXJzZW5uZVR3aXN0ZXIuTiAtIE1lcnNlbm5lVHdpc3Rlci5NOyBpZHggIT09IE1lcnNlbm5lVHdpc3Rlci5OIC0gMTsgKytpZHgpIHtcbiAgICAgICAgICAgIHZhciB5XzIgPSAobXRbaWR4XSAmIE1lcnNlbm5lVHdpc3Rlci5NQVNLX1VQUEVSKSArIChtdFtpZHggKyAxXSAmIE1lcnNlbm5lVHdpc3Rlci5NQVNLX0xPV0VSKTtcbiAgICAgICAgICAgIG10W2lkeF0gPSBtdFtpZHggKyBNZXJzZW5uZVR3aXN0ZXIuTSAtIE1lcnNlbm5lVHdpc3Rlci5OXSBeICh5XzIgPj4+IDEpIF4gKC0oeV8yICYgMSkgJiBNZXJzZW5uZVR3aXN0ZXIuQSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHkgPSAobXRbTWVyc2VubmVUd2lzdGVyLk4gLSAxXSAmIE1lcnNlbm5lVHdpc3Rlci5NQVNLX1VQUEVSKSArIChtdFswXSAmIE1lcnNlbm5lVHdpc3Rlci5NQVNLX0xPV0VSKTtcbiAgICAgICAgbXRbTWVyc2VubmVUd2lzdGVyLk4gLSAxXSA9IG10W01lcnNlbm5lVHdpc3Rlci5NIC0gMV0gXiAoeSA+Pj4gMSkgXiAoLSh5ICYgMSkgJiBNZXJzZW5uZVR3aXN0ZXIuQSk7XG4gICAgICAgIHJldHVybiBtdDtcbiAgICB9O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5zZWVkZWQgPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgICAgICB2YXIgb3V0ID0gQXJyYXkoTWVyc2VubmVUd2lzdGVyLk4pO1xuICAgICAgICBvdXRbMF0gPSBzZWVkO1xuICAgICAgICBmb3IgKHZhciBpZHggPSAxOyBpZHggIT09IE1lcnNlbm5lVHdpc3Rlci5OOyArK2lkeCkge1xuICAgICAgICAgICAgdmFyIHhvcmVkID0gb3V0W2lkeCAtIDFdIF4gKG91dFtpZHggLSAxXSA+Pj4gMzApO1xuICAgICAgICAgICAgb3V0W2lkeF0gPSAoTWF0aC5pbXVsKE1lcnNlbm5lVHdpc3Rlci5GLCB4b3JlZCkgKyBpZHgpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgTWVyc2VubmVUd2lzdGVyLmZyb20gPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgICAgICByZXR1cm4gbmV3IE1lcnNlbm5lVHdpc3RlcihNZXJzZW5uZVR3aXN0ZXIudHdpc3QoTWVyc2VubmVUd2lzdGVyLnNlZWRlZChzZWVkKSksIDApO1xuICAgIH07XG4gICAgTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBNZXJzZW5uZVR3aXN0ZXIubWluO1xuICAgIH07XG4gICAgTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBNZXJzZW5uZVR3aXN0ZXIubWF4O1xuICAgIH07XG4gICAgTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXJzZW5uZVR3aXN0ZXIodGhpcy5zdGF0ZXMsIHRoaXMuaW5kZXgpO1xuICAgIH07XG4gICAgTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IG5ldyBNZXJzZW5uZVR3aXN0ZXIodGhpcy5zdGF0ZXMsIHRoaXMuaW5kZXgpO1xuICAgICAgICB2YXIgb3V0ID0gbmV4dFJuZy51bnNhZmVOZXh0KCk7XG4gICAgICAgIHJldHVybiBbb3V0LCBuZXh0Um5nXTtcbiAgICB9O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5wcm90b3R5cGUudW5zYWZlTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnN0YXRlc1t0aGlzLmluZGV4XTtcbiAgICAgICAgeSBePSB0aGlzLnN0YXRlc1t0aGlzLmluZGV4XSA+Pj4gTWVyc2VubmVUd2lzdGVyLlU7XG4gICAgICAgIHkgXj0gKHkgPDwgTWVyc2VubmVUd2lzdGVyLlMpICYgTWVyc2VubmVUd2lzdGVyLkI7XG4gICAgICAgIHkgXj0gKHkgPDwgTWVyc2VubmVUd2lzdGVyLlQpICYgTWVyc2VubmVUd2lzdGVyLkM7XG4gICAgICAgIHkgXj0geSA+Pj4gTWVyc2VubmVUd2lzdGVyLkw7XG4gICAgICAgIGlmICgrK3RoaXMuaW5kZXggPj0gTWVyc2VubmVUd2lzdGVyLk4pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzID0gTWVyc2VubmVUd2lzdGVyLnR3aXN0KHRoaXMuc3RhdGVzKTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5ID4+PiAwO1xuICAgIH07XG4gICAgTWVyc2VubmVUd2lzdGVyLm1pbiA9IDA7XG4gICAgTWVyc2VubmVUd2lzdGVyLm1heCA9IDB4ZmZmZmZmZmY7XG4gICAgTWVyc2VubmVUd2lzdGVyLk4gPSA2MjQ7XG4gICAgTWVyc2VubmVUd2lzdGVyLk0gPSAzOTc7XG4gICAgTWVyc2VubmVUd2lzdGVyLlIgPSAzMTtcbiAgICBNZXJzZW5uZVR3aXN0ZXIuQSA9IDB4OTkwOGIwZGY7XG4gICAgTWVyc2VubmVUd2lzdGVyLkYgPSAxODEyNDMzMjUzO1xuICAgIE1lcnNlbm5lVHdpc3Rlci5VID0gMTE7XG4gICAgTWVyc2VubmVUd2lzdGVyLlMgPSA3O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5CID0gMHg5ZDJjNTY4MDtcbiAgICBNZXJzZW5uZVR3aXN0ZXIuVCA9IDE1O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5DID0gMHhlZmM2MDAwMDtcbiAgICBNZXJzZW5uZVR3aXN0ZXIuTCA9IDE4O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5NQVNLX0xPV0VSID0gTWF0aC5wb3coMiwgTWVyc2VubmVUd2lzdGVyLlIpIC0gMTtcbiAgICBNZXJzZW5uZVR3aXN0ZXIuTUFTS19VUFBFUiA9IE1hdGgucG93KDIsIE1lcnNlbm5lVHdpc3Rlci5SKTtcbiAgICByZXR1cm4gTWVyc2VubmVUd2lzdGVyO1xufSgpKTtcbmZ1bmN0aW9uIGRlZmF1bHRfMShzZWVkKSB7XG4gICAgcmV0dXJuIE1lcnNlbm5lVHdpc3Rlci5mcm9tKHNlZWQpO1xufVxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBkZWZhdWx0XzE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnNraXBOID0gZXhwb3J0cy51bnNhZmVTa2lwTiA9IGV4cG9ydHMuZ2VuZXJhdGVOID0gZXhwb3J0cy51bnNhZmVHZW5lcmF0ZU4gPSB2b2lkIDA7XG5mdW5jdGlvbiB1bnNhZmVHZW5lcmF0ZU4ocm5nLCBudW0pIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4ICE9IG51bTsgKytpZHgpIHtcbiAgICAgICAgb3V0LnB1c2gocm5nLnVuc2FmZU5leHQoKSk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnRzLnVuc2FmZUdlbmVyYXRlTiA9IHVuc2FmZUdlbmVyYXRlTjtcbmZ1bmN0aW9uIGdlbmVyYXRlTihybmcsIG51bSkge1xuICAgIHZhciBuZXh0Um5nID0gcm5nLmNsb25lKCk7XG4gICAgdmFyIG91dCA9IHVuc2FmZUdlbmVyYXRlTihuZXh0Um5nLCBudW0pO1xuICAgIHJldHVybiBbb3V0LCBuZXh0Um5nXTtcbn1cbmV4cG9ydHMuZ2VuZXJhdGVOID0gZ2VuZXJhdGVOO1xuZnVuY3Rpb24gdW5zYWZlU2tpcE4ocm5nLCBudW0pIHtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggIT0gbnVtOyArK2lkeCkge1xuICAgICAgICBybmcudW5zYWZlTmV4dCgpO1xuICAgIH1cbn1cbmV4cG9ydHMudW5zYWZlU2tpcE4gPSB1bnNhZmVTa2lwTjtcbmZ1bmN0aW9uIHNraXBOKHJuZywgbnVtKSB7XG4gICAgdmFyIG5leHRSbmcgPSBybmcuY2xvbmUoKTtcbiAgICB1bnNhZmVTa2lwTihuZXh0Um5nLCBudW0pO1xuICAgIHJldHVybiBuZXh0Um5nO1xufVxuZXhwb3J0cy5za2lwTiA9IHNraXBOO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy54b3JzaGlmdDEyOHBsdXMgPSB2b2lkIDA7XG52YXIgWG9yU2hpZnQxMjhQbHVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYb3JTaGlmdDEyOFBsdXMoczAxLCBzMDAsIHMxMSwgczEwKSB7XG4gICAgICAgIHRoaXMuczAxID0gczAxO1xuICAgICAgICB0aGlzLnMwMCA9IHMwMDtcbiAgICAgICAgdGhpcy5zMTEgPSBzMTE7XG4gICAgICAgIHRoaXMuczEwID0gczEwO1xuICAgIH1cbiAgICBYb3JTaGlmdDEyOFBsdXMucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIC0weDgwMDAwMDAwO1xuICAgIH07XG4gICAgWG9yU2hpZnQxMjhQbHVzLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAweDdmZmZmZmZmO1xuICAgIH07XG4gICAgWG9yU2hpZnQxMjhQbHVzLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBYb3JTaGlmdDEyOFBsdXModGhpcy5zMDEsIHRoaXMuczAwLCB0aGlzLnMxMSwgdGhpcy5zMTApO1xuICAgIH07XG4gICAgWG9yU2hpZnQxMjhQbHVzLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IG5ldyBYb3JTaGlmdDEyOFBsdXModGhpcy5zMDEsIHRoaXMuczAwLCB0aGlzLnMxMSwgdGhpcy5zMTApO1xuICAgICAgICB2YXIgb3V0ID0gbmV4dFJuZy51bnNhZmVOZXh0KCk7XG4gICAgICAgIHJldHVybiBbb3V0LCBuZXh0Um5nXTtcbiAgICB9O1xuICAgIFhvclNoaWZ0MTI4UGx1cy5wcm90b3R5cGUudW5zYWZlTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEwID0gdGhpcy5zMDAgXiAodGhpcy5zMDAgPDwgMjMpO1xuICAgICAgICB2YXIgYTEgPSB0aGlzLnMwMSBeICgodGhpcy5zMDEgPDwgMjMpIHwgKHRoaXMuczAwID4+PiA5KSk7XG4gICAgICAgIHZhciBiMCA9IGEwIF4gdGhpcy5zMTAgXiAoKGEwID4+PiAxOCkgfCAoYTEgPDwgMTQpKSBeICgodGhpcy5zMTAgPj4+IDUpIHwgKHRoaXMuczExIDw8IDI3KSk7XG4gICAgICAgIHZhciBiMSA9IGExIF4gdGhpcy5zMTEgXiAoYTEgPj4+IDE4KSBeICh0aGlzLnMxMSA+Pj4gNSk7XG4gICAgICAgIHZhciBvdXQgPSAodGhpcy5zMDAgKyB0aGlzLnMxMCkgfCAwO1xuICAgICAgICB0aGlzLnMwMSA9IHRoaXMuczExO1xuICAgICAgICB0aGlzLnMwMCA9IHRoaXMuczEwO1xuICAgICAgICB0aGlzLnMxMSA9IGIxO1xuICAgICAgICB0aGlzLnMxMCA9IGIwO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgWG9yU2hpZnQxMjhQbHVzLnByb3RvdHlwZS5qdW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IG5ldyBYb3JTaGlmdDEyOFBsdXModGhpcy5zMDEsIHRoaXMuczAwLCB0aGlzLnMxMSwgdGhpcy5zMTApO1xuICAgICAgICBuZXh0Um5nLnVuc2FmZUp1bXAoKTtcbiAgICAgICAgcmV0dXJuIG5leHRSbmc7XG4gICAgfTtcbiAgICBYb3JTaGlmdDEyOFBsdXMucHJvdG90eXBlLnVuc2FmZUp1bXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuczAxID0gMDtcbiAgICAgICAgdmFyIG5zMDAgPSAwO1xuICAgICAgICB2YXIgbnMxMSA9IDA7XG4gICAgICAgIHZhciBuczEwID0gMDtcbiAgICAgICAgdmFyIGp1bXAgPSBbMHg2MzVkMmRmZiwgMHg4YTVjZDc4OSwgMHg1YzQ3MmY5NiwgMHgxMjFmZDIxNV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSA0OyArK2kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG1hc2sgPSAxOyBtYXNrOyBtYXNrIDw8PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGp1bXBbaV0gJiBtYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5zMDEgXj0gdGhpcy5zMDE7XG4gICAgICAgICAgICAgICAgICAgIG5zMDAgXj0gdGhpcy5zMDA7XG4gICAgICAgICAgICAgICAgICAgIG5zMTEgXj0gdGhpcy5zMTE7XG4gICAgICAgICAgICAgICAgICAgIG5zMTAgXj0gdGhpcy5zMTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudW5zYWZlTmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuczAxID0gbnMwMTtcbiAgICAgICAgdGhpcy5zMDAgPSBuczAwO1xuICAgICAgICB0aGlzLnMxMSA9IG5zMTE7XG4gICAgICAgIHRoaXMuczEwID0gbnMxMDtcbiAgICB9O1xuICAgIHJldHVybiBYb3JTaGlmdDEyOFBsdXM7XG59KCkpO1xudmFyIHhvcnNoaWZ0MTI4cGx1cyA9IGZ1bmN0aW9uIChzZWVkKSB7XG4gICAgcmV0dXJuIG5ldyBYb3JTaGlmdDEyOFBsdXMoLTEsIH5zZWVkLCBzZWVkIHwgMCwgMCk7XG59O1xuZXhwb3J0cy54b3JzaGlmdDEyOHBsdXMgPSB4b3JzaGlmdDEyOHBsdXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnhvcm9zaGlybzEyOHBsdXMgPSB2b2lkIDA7XG52YXIgWG9yb1NoaXJvMTI4UGx1cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWG9yb1NoaXJvMTI4UGx1cyhzMDEsIHMwMCwgczExLCBzMTApIHtcbiAgICAgICAgdGhpcy5zMDEgPSBzMDE7XG4gICAgICAgIHRoaXMuczAwID0gczAwO1xuICAgICAgICB0aGlzLnMxMSA9IHMxMTtcbiAgICAgICAgdGhpcy5zMTAgPSBzMTA7XG4gICAgfVxuICAgIFhvcm9TaGlybzEyOFBsdXMucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIC0weDgwMDAwMDAwO1xuICAgIH07XG4gICAgWG9yb1NoaXJvMTI4UGx1cy5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMHg3ZmZmZmZmZjtcbiAgICB9O1xuICAgIFhvcm9TaGlybzEyOFBsdXMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFhvcm9TaGlybzEyOFBsdXModGhpcy5zMDEsIHRoaXMuczAwLCB0aGlzLnMxMSwgdGhpcy5zMTApO1xuICAgIH07XG4gICAgWG9yb1NoaXJvMTI4UGx1cy5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHRSbmcgPSBuZXcgWG9yb1NoaXJvMTI4UGx1cyh0aGlzLnMwMSwgdGhpcy5zMDAsIHRoaXMuczExLCB0aGlzLnMxMCk7XG4gICAgICAgIHZhciBvdXQgPSBuZXh0Um5nLnVuc2FmZU5leHQoKTtcbiAgICAgICAgcmV0dXJuIFtvdXQsIG5leHRSbmddO1xuICAgIH07XG4gICAgWG9yb1NoaXJvMTI4UGx1cy5wcm90b3R5cGUudW5zYWZlTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dCA9ICh0aGlzLnMwMCArIHRoaXMuczEwKSB8IDA7XG4gICAgICAgIHZhciBhMCA9IHRoaXMuczEwIF4gdGhpcy5zMDA7XG4gICAgICAgIHZhciBhMSA9IHRoaXMuczExIF4gdGhpcy5zMDE7XG4gICAgICAgIHZhciBzMDAgPSB0aGlzLnMwMDtcbiAgICAgICAgdmFyIHMwMSA9IHRoaXMuczAxO1xuICAgICAgICB0aGlzLnMwMCA9IChzMDAgPDwgMjQpIF4gKHMwMSA+Pj4gOCkgXiBhMCBeIChhMCA8PCAxNik7XG4gICAgICAgIHRoaXMuczAxID0gKHMwMSA8PCAyNCkgXiAoczAwID4+PiA4KSBeIGExIF4gKChhMSA8PCAxNikgfCAoYTAgPj4+IDE2KSk7XG4gICAgICAgIHRoaXMuczEwID0gKGExIDw8IDUpIF4gKGEwID4+PiAyNyk7XG4gICAgICAgIHRoaXMuczExID0gKGEwIDw8IDUpIF4gKGExID4+PiAyNyk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBYb3JvU2hpcm8xMjhQbHVzLnByb3RvdHlwZS5qdW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IG5ldyBYb3JvU2hpcm8xMjhQbHVzKHRoaXMuczAxLCB0aGlzLnMwMCwgdGhpcy5zMTEsIHRoaXMuczEwKTtcbiAgICAgICAgbmV4dFJuZy51bnNhZmVKdW1wKCk7XG4gICAgICAgIHJldHVybiBuZXh0Um5nO1xuICAgIH07XG4gICAgWG9yb1NoaXJvMTI4UGx1cy5wcm90b3R5cGUudW5zYWZlSnVtcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5zMDEgPSAwO1xuICAgICAgICB2YXIgbnMwMCA9IDA7XG4gICAgICAgIHZhciBuczExID0gMDtcbiAgICAgICAgdmFyIG5zMTAgPSAwO1xuICAgICAgICB2YXIganVtcCA9IFsweGQ4ZjU1NGE1LCAweGRmOTAwMjk0LCAweDRiMzIwMWZjLCAweDE3MDg2NWRmXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IDQ7ICsraSkge1xuICAgICAgICAgICAgZm9yICh2YXIgbWFzayA9IDE7IG1hc2s7IG1hc2sgPDw9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoanVtcFtpXSAmIG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgbnMwMSBePSB0aGlzLnMwMTtcbiAgICAgICAgICAgICAgICAgICAgbnMwMCBePSB0aGlzLnMwMDtcbiAgICAgICAgICAgICAgICAgICAgbnMxMSBePSB0aGlzLnMxMTtcbiAgICAgICAgICAgICAgICAgICAgbnMxMCBePSB0aGlzLnMxMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51bnNhZmVOZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zMDEgPSBuczAxO1xuICAgICAgICB0aGlzLnMwMCA9IG5zMDA7XG4gICAgICAgIHRoaXMuczExID0gbnMxMTtcbiAgICAgICAgdGhpcy5zMTAgPSBuczEwO1xuICAgIH07XG4gICAgcmV0dXJuIFhvcm9TaGlybzEyOFBsdXM7XG59KCkpO1xudmFyIHhvcm9zaGlybzEyOHBsdXMgPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgIHJldHVybiBuZXcgWG9yb1NoaXJvMTI4UGx1cygtMSwgfnNlZWQsIHNlZWQgfCAwLCAwKTtcbn07XG5leHBvcnRzLnhvcm9zaGlybzEyOHBsdXMgPSB4b3Jvc2hpcm8xMjhwbHVzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy51bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uID0gZXhwb3J0cy51bnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uID0gZXhwb3J0cy51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24gPSBleHBvcnRzLnVuaWZvcm1JbnREaXN0cmlidXRpb24gPSBleHBvcnRzLnVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24gPSBleHBvcnRzLnVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbiA9IGV4cG9ydHMueG9yb3NoaXJvMTI4cGx1cyA9IGV4cG9ydHMueG9yc2hpZnQxMjhwbHVzID0gZXhwb3J0cy5tZXJzZW5uZSA9IGV4cG9ydHMuY29uZ3J1ZW50aWFsMzIgPSBleHBvcnRzLmNvbmdydWVudGlhbCA9IGV4cG9ydHMudW5zYWZlU2tpcE4gPSBleHBvcnRzLnVuc2FmZUdlbmVyYXRlTiA9IGV4cG9ydHMuc2tpcE4gPSBleHBvcnRzLmdlbmVyYXRlTiA9IGV4cG9ydHMuX19jb21taXRIYXNoID0gZXhwb3J0cy5fX3ZlcnNpb24gPSBleHBvcnRzLl9fdHlwZSA9IHZvaWQgMDtcbnZhciBSYW5kb21HZW5lcmF0b3JfMSA9IHJlcXVpcmUoXCIuL2dlbmVyYXRvci9SYW5kb21HZW5lcmF0b3JcIik7XG5leHBvcnRzLmdlbmVyYXRlTiA9IFJhbmRvbUdlbmVyYXRvcl8xLmdlbmVyYXRlTjtcbmV4cG9ydHMuc2tpcE4gPSBSYW5kb21HZW5lcmF0b3JfMS5za2lwTjtcbmV4cG9ydHMudW5zYWZlR2VuZXJhdGVOID0gUmFuZG9tR2VuZXJhdG9yXzEudW5zYWZlR2VuZXJhdGVOO1xuZXhwb3J0cy51bnNhZmVTa2lwTiA9IFJhbmRvbUdlbmVyYXRvcl8xLnVuc2FmZVNraXBOO1xudmFyIExpbmVhckNvbmdydWVudGlhbF8xID0gcmVxdWlyZShcIi4vZ2VuZXJhdG9yL0xpbmVhckNvbmdydWVudGlhbFwiKTtcbmV4cG9ydHMuY29uZ3J1ZW50aWFsID0gTGluZWFyQ29uZ3J1ZW50aWFsXzEuY29uZ3J1ZW50aWFsO1xuZXhwb3J0cy5jb25ncnVlbnRpYWwzMiA9IExpbmVhckNvbmdydWVudGlhbF8xLmNvbmdydWVudGlhbDMyO1xudmFyIE1lcnNlbm5lVHdpc3Rlcl8xID0gcmVxdWlyZShcIi4vZ2VuZXJhdG9yL01lcnNlbm5lVHdpc3RlclwiKTtcbmV4cG9ydHMubWVyc2VubmUgPSBNZXJzZW5uZVR3aXN0ZXJfMVtcImRlZmF1bHRcIl07XG52YXIgWG9yU2hpZnRfMSA9IHJlcXVpcmUoXCIuL2dlbmVyYXRvci9Yb3JTaGlmdFwiKTtcbmV4cG9ydHMueG9yc2hpZnQxMjhwbHVzID0gWG9yU2hpZnRfMS54b3JzaGlmdDEyOHBsdXM7XG52YXIgWG9yb1NoaXJvXzEgPSByZXF1aXJlKFwiLi9nZW5lcmF0b3IvWG9yb1NoaXJvXCIpO1xuZXhwb3J0cy54b3Jvc2hpcm8xMjhwbHVzID0gWG9yb1NoaXJvXzEueG9yb3NoaXJvMTI4cGx1cztcbnZhciBVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25fMSA9IHJlcXVpcmUoXCIuL2Rpc3RyaWJ1dGlvbi9Vbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25cIik7XG5leHBvcnRzLnVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbiA9IFVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbl8xLnVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbjtcbnZhciBVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uXzEgPSByZXF1aXJlKFwiLi9kaXN0cmlidXRpb24vVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvblwiKTtcbmV4cG9ydHMudW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbiA9IFVuaWZvcm1CaWdJbnREaXN0cmlidXRpb25fMS51bmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uO1xudmFyIFVuaWZvcm1JbnREaXN0cmlidXRpb25fMSA9IHJlcXVpcmUoXCIuL2Rpc3RyaWJ1dGlvbi9Vbmlmb3JtSW50RGlzdHJpYnV0aW9uXCIpO1xuZXhwb3J0cy51bmlmb3JtSW50RGlzdHJpYnV0aW9uID0gVW5pZm9ybUludERpc3RyaWJ1dGlvbl8xLnVuaWZvcm1JbnREaXN0cmlidXRpb247XG52YXIgVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uXzEgPSByZXF1aXJlKFwiLi9kaXN0cmlidXRpb24vVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uXCIpO1xuZXhwb3J0cy51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24gPSBVbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25fMS51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb247XG52YXIgVW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbl8xID0gcmVxdWlyZShcIi4vZGlzdHJpYnV0aW9uL1Vuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb25cIik7XG5leHBvcnRzLnVuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24gPSBVbnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uXzEudW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbjtcbnZhciBVbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uXzEgPSByZXF1aXJlKFwiLi9kaXN0cmlidXRpb24vVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvblwiKTtcbmV4cG9ydHMudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbiA9IFVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25fMS51bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uO1xudmFyIF9fdHlwZSA9ICdjb21tb25qcyc7XG5leHBvcnRzLl9fdHlwZSA9IF9fdHlwZTtcbnZhciBfX3ZlcnNpb24gPSAnNS4wLjUnO1xuZXhwb3J0cy5fX3ZlcnNpb24gPSBfX3ZlcnNpb247XG52YXIgX19jb21taXRIYXNoID0gJzhiODEyZDk2NTFiNGExOGU5MTE1YWExM2Q4NGZlMWI1ZWI5YjA2OGQnO1xuZXhwb3J0cy5fX2NvbW1pdEhhc2ggPSBfX2NvbW1pdEhhc2g7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBwcmFuZCA9IHJlcXVpcmUoXCIuL3B1cmUtcmFuZC1kZWZhdWx0XCIpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBwcmFuZDtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wdXJlLXJhbmQtZGVmYXVsdFwiKSwgZXhwb3J0cyk7XG4iLCJ2YXIgbW9kZSA9IHJlcXVpcmUoJy4vbW9kZScpO1xuXG5mdW5jdGlvbiBRUjhiaXRCeXRlKGRhdGEpIHtcblx0dGhpcy5tb2RlID0gbW9kZS5NT0RFXzhCSVRfQllURTtcblx0dGhpcy5kYXRhID0gZGF0YTtcbn1cblxuUVI4Yml0Qnl0ZS5wcm90b3R5cGUgPSB7XG5cblx0Z2V0TGVuZ3RoIDogZnVuY3Rpb24oYnVmZmVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5sZW5ndGg7XG5cdH0sXG5cdFxuXHR3cml0ZSA6IGZ1bmN0aW9uKGJ1ZmZlcikge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHQvLyBub3QgSklTIC4uLlxuXHRcdFx0YnVmZmVyLnB1dCh0aGlzLmRhdGEuY2hhckNvZGVBdChpKSwgOCk7XG5cdFx0fVxuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFFSOGJpdEJ5dGU7XG5cbiIsImZ1bmN0aW9uIFFSQml0QnVmZmVyKCkge1xuXHR0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheSgpO1xuXHR0aGlzLmxlbmd0aCA9IDA7XG59XG5cblFSQml0QnVmZmVyLnByb3RvdHlwZSA9IHtcblxuXHRnZXQgOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciBidWZJbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyA4KTtcblx0XHRyZXR1cm4gKCAodGhpcy5idWZmZXJbYnVmSW5kZXhdID4+PiAoNyAtIGluZGV4ICUgOCkgKSAmIDEpID09IDE7XG5cdH0sXG5cdFxuXHRwdXQgOiBmdW5jdGlvbihudW0sIGxlbmd0aCkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMucHV0Qml0KCAoIChudW0gPj4+IChsZW5ndGggLSBpIC0gMSkgKSAmIDEpID09IDEpO1xuXHRcdH1cblx0fSxcblx0XG5cdGdldExlbmd0aEluQml0cyA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmxlbmd0aDtcblx0fSxcblx0XG5cdHB1dEJpdCA6IGZ1bmN0aW9uKGJpdCkge1xuXHRcblx0XHR2YXIgYnVmSW5kZXggPSBNYXRoLmZsb29yKHRoaXMubGVuZ3RoIC8gOCk7XG5cdFx0aWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA8PSBidWZJbmRleCkge1xuXHRcdFx0dGhpcy5idWZmZXIucHVzaCgwKTtcblx0XHR9XG5cdFxuXHRcdGlmIChiaXQpIHtcblx0XHRcdHRoaXMuYnVmZmVyW2J1ZkluZGV4XSB8PSAoMHg4MCA+Pj4gKHRoaXMubGVuZ3RoICUgOCkgKTtcblx0XHR9XG5cdFxuXHRcdHRoaXMubGVuZ3RoKys7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUVJCaXRCdWZmZXI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0TCA6IDEsXG5cdE0gOiAwLFxuXHRRIDogMyxcblx0SCA6IDJcbn07XG5cbiIsInZhciBtYXRoID0gcmVxdWlyZSgnLi9tYXRoJyk7XG5cbmZ1bmN0aW9uIFFSUG9seW5vbWlhbChudW0sIHNoaWZ0KSB7XG5cblx0aWYgKG51bS5sZW5ndGggPT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKG51bS5sZW5ndGggKyBcIi9cIiArIHNoaWZ0KTtcblx0fVxuXG5cdHZhciBvZmZzZXQgPSAwO1xuXG5cdHdoaWxlIChvZmZzZXQgPCBudW0ubGVuZ3RoICYmIG51bVtvZmZzZXRdID09IDApIHtcblx0XHRvZmZzZXQrKztcblx0fVxuXG5cdHRoaXMubnVtID0gbmV3IEFycmF5KG51bS5sZW5ndGggLSBvZmZzZXQgKyBzaGlmdCk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aCAtIG9mZnNldDsgaSsrKSB7XG5cdFx0dGhpcy5udW1baV0gPSBudW1baSArIG9mZnNldF07XG5cdH1cbn1cblxuUVJQb2x5bm9taWFsLnByb3RvdHlwZSA9IHtcblxuXHRnZXQgOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHJldHVybiB0aGlzLm51bVtpbmRleF07XG5cdH0sXG5cdFxuXHRnZXRMZW5ndGggOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5udW0ubGVuZ3RoO1xuXHR9LFxuXHRcblx0bXVsdGlwbHkgOiBmdW5jdGlvbihlKSB7XG5cdFxuXHRcdHZhciBudW0gPSBuZXcgQXJyYXkodGhpcy5nZXRMZW5ndGgoKSArIGUuZ2V0TGVuZ3RoKCkgLSAxKTtcblx0XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdldExlbmd0aCgpOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZS5nZXRMZW5ndGgoKTsgaisrKSB7XG5cdFx0XHRcdG51bVtpICsgal0gXj0gbWF0aC5nZXhwKG1hdGguZ2xvZyh0aGlzLmdldChpKSApICsgbWF0aC5nbG9nKGUuZ2V0KGopICkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBuZXcgUVJQb2x5bm9taWFsKG51bSwgMCk7XG5cdH0sXG5cdFxuXHRtb2QgOiBmdW5jdGlvbihlKSB7XG5cdFxuXHRcdGlmICh0aGlzLmdldExlbmd0aCgpIC0gZS5nZXRMZW5ndGgoKSA8IDApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XG5cdFx0dmFyIHJhdGlvID0gbWF0aC5nbG9nKHRoaXMuZ2V0KDApICkgLSBtYXRoLmdsb2coZS5nZXQoMCkgKTtcblx0XG5cdFx0dmFyIG51bSA9IG5ldyBBcnJheSh0aGlzLmdldExlbmd0aCgpICk7XG5cdFx0XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdldExlbmd0aCgpOyBpKyspIHtcblx0XHRcdG51bVtpXSA9IHRoaXMuZ2V0KGkpO1xuXHRcdH1cblx0XHRcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGUuZ2V0TGVuZ3RoKCk7IGkrKykge1xuXHRcdFx0bnVtW2ldIF49IG1hdGguZ2V4cChtYXRoLmdsb2coZS5nZXQoaSkgKSArIHJhdGlvKTtcblx0XHR9XG5cdFxuXHRcdC8vIHJlY3Vyc2l2ZSBjYWxsXG5cdFx0cmV0dXJuIG5ldyBRUlBvbHlub21pYWwobnVtLCAwKS5tb2QoZSk7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUVJQb2x5bm9taWFsO1xuIiwidmFyIEJpdEJ5dGUgPSByZXF1aXJlKCcuLzhCaXRCeXRlJyk7XG52YXIgUlNCbG9jayA9IHJlcXVpcmUoJy4vUlNCbG9jaycpO1xudmFyIEJpdEJ1ZmZlciA9IHJlcXVpcmUoJy4vQml0QnVmZmVyJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIFBvbHlub21pYWwgPSByZXF1aXJlKCcuL1BvbHlub21pYWwnKTtcblxuZnVuY3Rpb24gUVJDb2RlKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdExldmVsKSB7XG5cdHRoaXMudHlwZU51bWJlciA9IHR5cGVOdW1iZXI7XG5cdHRoaXMuZXJyb3JDb3JyZWN0TGV2ZWwgPSBlcnJvckNvcnJlY3RMZXZlbDtcblx0dGhpcy5tb2R1bGVzID0gbnVsbDtcblx0dGhpcy5tb2R1bGVDb3VudCA9IDA7XG5cdHRoaXMuZGF0YUNhY2hlID0gbnVsbDtcblx0dGhpcy5kYXRhTGlzdCA9IFtdO1xufVxuXG4vLyBmb3IgY2xpZW50IHNpZGUgbWluaWZpY2F0aW9uXG52YXIgcHJvdG8gPSBRUkNvZGUucHJvdG90eXBlO1xuXG5wcm90by5hZGREYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuXHR2YXIgbmV3RGF0YSA9IG5ldyBCaXRCeXRlKGRhdGEpO1xuXHR0aGlzLmRhdGFMaXN0LnB1c2gobmV3RGF0YSk7XG5cdHRoaXMuZGF0YUNhY2hlID0gbnVsbDtcbn07XG5cbnByb3RvLmlzRGFyayA9IGZ1bmN0aW9uKHJvdywgY29sKSB7XG5cdGlmIChyb3cgPCAwIHx8IHRoaXMubW9kdWxlQ291bnQgPD0gcm93IHx8IGNvbCA8IDAgfHwgdGhpcy5tb2R1bGVDb3VudCA8PSBjb2wpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3Iocm93ICsgXCIsXCIgKyBjb2wpO1xuXHR9XG5cdHJldHVybiB0aGlzLm1vZHVsZXNbcm93XVtjb2xdO1xufTtcblxucHJvdG8uZ2V0TW9kdWxlQ291bnQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMubW9kdWxlQ291bnQ7XG59O1xuXG5wcm90by5tYWtlID0gZnVuY3Rpb24oKSB7XG5cdC8vIENhbGN1bGF0ZSBhdXRvbWF0aWNhbGx5IHR5cGVOdW1iZXIgaWYgcHJvdmlkZWQgaXMgPCAxXG5cdGlmICh0aGlzLnR5cGVOdW1iZXIgPCAxICl7XG5cdFx0dmFyIHR5cGVOdW1iZXIgPSAxO1xuXHRcdGZvciAodHlwZU51bWJlciA9IDE7IHR5cGVOdW1iZXIgPCA0MDsgdHlwZU51bWJlcisrKSB7XG5cdFx0XHR2YXIgcnNCbG9ja3MgPSBSU0Jsb2NrLmdldFJTQmxvY2tzKHR5cGVOdW1iZXIsIHRoaXMuZXJyb3JDb3JyZWN0TGV2ZWwpO1xuXG5cdFx0XHR2YXIgYnVmZmVyID0gbmV3IEJpdEJ1ZmZlcigpO1xuXHRcdFx0dmFyIHRvdGFsRGF0YUNvdW50ID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcnNCbG9ja3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dG90YWxEYXRhQ291bnQgKz0gcnNCbG9ja3NbaV0uZGF0YUNvdW50O1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YUxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGRhdGEgPSB0aGlzLmRhdGFMaXN0W2ldO1xuXHRcdFx0XHRidWZmZXIucHV0KGRhdGEubW9kZSwgNCk7XG5cdFx0XHRcdGJ1ZmZlci5wdXQoZGF0YS5nZXRMZW5ndGgoKSwgdXRpbC5nZXRMZW5ndGhJbkJpdHMoZGF0YS5tb2RlLCB0eXBlTnVtYmVyKSApO1xuXHRcdFx0XHRkYXRhLndyaXRlKGJ1ZmZlcik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpIDw9IHRvdGFsRGF0YUNvdW50ICogOClcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdHRoaXMudHlwZU51bWJlciA9IHR5cGVOdW1iZXI7XG5cdH1cblx0dGhpcy5tYWtlSW1wbChmYWxzZSwgdGhpcy5nZXRCZXN0TWFza1BhdHRlcm4oKSApO1xufTtcblxucHJvdG8ubWFrZUltcGwgPSBmdW5jdGlvbih0ZXN0LCBtYXNrUGF0dGVybikge1xuXHRcblx0dGhpcy5tb2R1bGVDb3VudCA9IHRoaXMudHlwZU51bWJlciAqIDQgKyAxNztcblx0dGhpcy5tb2R1bGVzID0gbmV3IEFycmF5KHRoaXMubW9kdWxlQ291bnQpO1xuXHRcblx0Zm9yICh2YXIgcm93ID0gMDsgcm93IDwgdGhpcy5tb2R1bGVDb3VudDsgcm93KyspIHtcblx0XHRcblx0XHR0aGlzLm1vZHVsZXNbcm93XSA9IG5ldyBBcnJheSh0aGlzLm1vZHVsZUNvdW50KTtcblx0XHRcblx0XHRmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCB0aGlzLm1vZHVsZUNvdW50OyBjb2wrKykge1xuXHRcdFx0dGhpcy5tb2R1bGVzW3Jvd11bY29sXSA9IG51bGw7Ly8oY29sICsgcm93KSAlIDM7XG5cdFx0fVxuXHR9XG5cblx0dGhpcy5zZXR1cFBvc2l0aW9uUHJvYmVQYXR0ZXJuKDAsIDApO1xuXHR0aGlzLnNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4odGhpcy5tb2R1bGVDb3VudCAtIDcsIDApO1xuXHR0aGlzLnNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4oMCwgdGhpcy5tb2R1bGVDb3VudCAtIDcpO1xuXHR0aGlzLnNldHVwUG9zaXRpb25BZGp1c3RQYXR0ZXJuKCk7XG5cdHRoaXMuc2V0dXBUaW1pbmdQYXR0ZXJuKCk7XG5cdHRoaXMuc2V0dXBUeXBlSW5mbyh0ZXN0LCBtYXNrUGF0dGVybik7XG5cdFxuXHRpZiAodGhpcy50eXBlTnVtYmVyID49IDcpIHtcblx0XHR0aGlzLnNldHVwVHlwZU51bWJlcih0ZXN0KTtcblx0fVxuXG5cdGlmICh0aGlzLmRhdGFDYWNoZSA9PSBudWxsKSB7XG5cdFx0dGhpcy5kYXRhQ2FjaGUgPSBRUkNvZGUuY3JlYXRlRGF0YSh0aGlzLnR5cGVOdW1iZXIsIHRoaXMuZXJyb3JDb3JyZWN0TGV2ZWwsIHRoaXMuZGF0YUxpc3QpO1xuXHR9XG5cblx0dGhpcy5tYXBEYXRhKHRoaXMuZGF0YUNhY2hlLCBtYXNrUGF0dGVybik7XG59O1xuXG5wcm90by5zZXR1cFBvc2l0aW9uUHJvYmVQYXR0ZXJuID0gZnVuY3Rpb24ocm93LCBjb2wpICB7XG5cdFxuXHRmb3IgKHZhciByID0gLTE7IHIgPD0gNzsgcisrKSB7XG5cdFx0XG5cdFx0aWYgKHJvdyArIHIgPD0gLTEgfHwgdGhpcy5tb2R1bGVDb3VudCA8PSByb3cgKyByKSBjb250aW51ZTtcblx0XHRcblx0XHRmb3IgKHZhciBjID0gLTE7IGMgPD0gNzsgYysrKSB7XG5cdFx0XHRcblx0XHRcdGlmIChjb2wgKyBjIDw9IC0xIHx8IHRoaXMubW9kdWxlQ291bnQgPD0gY29sICsgYykgY29udGludWU7XG5cdFx0XHRcblx0XHRcdGlmICggKDAgPD0gciAmJiByIDw9IDYgJiYgKGMgPT0gMCB8fCBjID09IDYpIClcblx0XHRcdFx0XHR8fCAoMCA8PSBjICYmIGMgPD0gNiAmJiAociA9PSAwIHx8IHIgPT0gNikgKVxuXHRcdFx0XHRcdHx8ICgyIDw9IHIgJiYgciA8PSA0ICYmIDIgPD0gYyAmJiBjIDw9IDQpICkge1xuXHRcdFx0XHR0aGlzLm1vZHVsZXNbcm93ICsgcl1bY29sICsgY10gPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5tb2R1bGVzW3JvdyArIHJdW2NvbCArIGNdID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVx0XHRcblx0fVx0XHRcbn07XG5cbnByb3RvLmdldEJlc3RNYXNrUGF0dGVybiA9IGZ1bmN0aW9uKCkge1xuXG5cdHZhciBtaW5Mb3N0UG9pbnQgPSAwO1xuXHR2YXIgcGF0dGVybiA9IDA7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0XHRcblx0XHR0aGlzLm1ha2VJbXBsKHRydWUsIGkpO1xuXG5cdFx0dmFyIGxvc3RQb2ludCA9IHV0aWwuZ2V0TG9zdFBvaW50KHRoaXMpO1xuXG5cdFx0aWYgKGkgPT0gMCB8fCBtaW5Mb3N0UG9pbnQgPiAgbG9zdFBvaW50KSB7XG5cdFx0XHRtaW5Mb3N0UG9pbnQgPSBsb3N0UG9pbnQ7XG5cdFx0XHRwYXR0ZXJuID0gaTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcGF0dGVybjtcbn07XG5cbnByb3RvLmNyZWF0ZU1vdmllQ2xpcCA9IGZ1bmN0aW9uKHRhcmdldF9tYywgaW5zdGFuY2VfbmFtZSwgZGVwdGgpIHtcblxuXHR2YXIgcXJfbWMgPSB0YXJnZXRfbWMuY3JlYXRlRW1wdHlNb3ZpZUNsaXAoaW5zdGFuY2VfbmFtZSwgZGVwdGgpO1xuXHR2YXIgY3MgPSAxO1xuXG5cdHRoaXMubWFrZSgpO1xuXG5cdGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHRoaXMubW9kdWxlcy5sZW5ndGg7IHJvdysrKSB7XG5cdFx0XG5cdFx0dmFyIHkgPSByb3cgKiBjcztcblx0XHRcblx0XHRmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCB0aGlzLm1vZHVsZXNbcm93XS5sZW5ndGg7IGNvbCsrKSB7XG5cblx0XHRcdHZhciB4ID0gY29sICogY3M7XG5cdFx0XHR2YXIgZGFyayA9IHRoaXMubW9kdWxlc1tyb3ddW2NvbF07XG5cdFx0XG5cdFx0XHRpZiAoZGFyaykge1xuXHRcdFx0XHRxcl9tYy5iZWdpbkZpbGwoMCwgMTAwKTtcblx0XHRcdFx0cXJfbWMubW92ZVRvKHgsIHkpO1xuXHRcdFx0XHRxcl9tYy5saW5lVG8oeCArIGNzLCB5KTtcblx0XHRcdFx0cXJfbWMubGluZVRvKHggKyBjcywgeSArIGNzKTtcblx0XHRcdFx0cXJfbWMubGluZVRvKHgsIHkgKyBjcyk7XG5cdFx0XHRcdHFyX21jLmVuZEZpbGwoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdHJldHVybiBxcl9tYztcbn07XG5cbnByb3RvLnNldHVwVGltaW5nUGF0dGVybiA9IGZ1bmN0aW9uKCkge1xuXHRcblx0Zm9yICh2YXIgciA9IDg7IHIgPCB0aGlzLm1vZHVsZUNvdW50IC0gODsgcisrKSB7XG5cdFx0aWYgKHRoaXMubW9kdWxlc1tyXVs2XSAhPSBudWxsKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0dGhpcy5tb2R1bGVzW3JdWzZdID0gKHIgJSAyID09IDApO1xuXHR9XG5cblx0Zm9yICh2YXIgYyA9IDg7IGMgPCB0aGlzLm1vZHVsZUNvdW50IC0gODsgYysrKSB7XG5cdFx0aWYgKHRoaXMubW9kdWxlc1s2XVtjXSAhPSBudWxsKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0dGhpcy5tb2R1bGVzWzZdW2NdID0gKGMgJSAyID09IDApO1xuXHR9XG59O1xuXG5wcm90by5zZXR1cFBvc2l0aW9uQWRqdXN0UGF0dGVybiA9IGZ1bmN0aW9uKCkge1xuXG5cdHZhciBwb3MgPSB1dGlsLmdldFBhdHRlcm5Qb3NpdGlvbih0aGlzLnR5cGVOdW1iZXIpO1xuXHRcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwb3MubGVuZ3RoOyBpKyspIHtcblx0XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBwb3MubGVuZ3RoOyBqKyspIHtcblx0XHRcblx0XHRcdHZhciByb3cgPSBwb3NbaV07XG5cdFx0XHR2YXIgY29sID0gcG9zW2pdO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5tb2R1bGVzW3Jvd11bY29sXSAhPSBudWxsKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciByID0gLTI7IHIgPD0gMjsgcisrKSB7XG5cdFx0XHRcblx0XHRcdFx0Zm9yICh2YXIgYyA9IC0yOyBjIDw9IDI7IGMrKykge1xuXHRcdFx0XHRcblx0XHRcdFx0XHRpZiAociA9PSAtMiB8fCByID09IDIgfHwgYyA9PSAtMiB8fCBjID09IDJcblx0XHRcdFx0XHRcdFx0fHwgKHIgPT0gMCAmJiBjID09IDApICkge1xuXHRcdFx0XHRcdFx0dGhpcy5tb2R1bGVzW3JvdyArIHJdW2NvbCArIGNdID0gdHJ1ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5tb2R1bGVzW3JvdyArIHJdW2NvbCArIGNdID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5wcm90by5zZXR1cFR5cGVOdW1iZXIgPSBmdW5jdGlvbih0ZXN0KSB7XG5cblx0dmFyIGJpdHMgPSB1dGlsLmdldEJDSFR5cGVOdW1iZXIodGhpcy50eXBlTnVtYmVyKTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IDE4OyBpKyspIHtcblx0XHR2YXIgbW9kID0gKCF0ZXN0ICYmICggKGJpdHMgPj4gaSkgJiAxKSA9PSAxKTtcblx0XHR0aGlzLm1vZHVsZXNbTWF0aC5mbG9vcihpIC8gMyldW2kgJSAzICsgdGhpcy5tb2R1bGVDb3VudCAtIDggLSAzXSA9IG1vZDtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgMTg7IGkrKykge1xuXHRcdHZhciBtb2QgPSAoIXRlc3QgJiYgKCAoYml0cyA+PiBpKSAmIDEpID09IDEpO1xuXHRcdHRoaXMubW9kdWxlc1tpICUgMyArIHRoaXMubW9kdWxlQ291bnQgLSA4IC0gM11bTWF0aC5mbG9vcihpIC8gMyldID0gbW9kO1xuXHR9XG59O1xuXG5wcm90by5zZXR1cFR5cGVJbmZvID0gZnVuY3Rpb24odGVzdCwgbWFza1BhdHRlcm4pIHtcblxuXHR2YXIgZGF0YSA9ICh0aGlzLmVycm9yQ29ycmVjdExldmVsIDw8IDMpIHwgbWFza1BhdHRlcm47XG5cdHZhciBiaXRzID0gdXRpbC5nZXRCQ0hUeXBlSW5mbyhkYXRhKTtcblxuXHQvLyB2ZXJ0aWNhbFx0XHRcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxNTsgaSsrKSB7XG5cblx0XHR2YXIgbW9kID0gKCF0ZXN0ICYmICggKGJpdHMgPj4gaSkgJiAxKSA9PSAxKTtcblxuXHRcdGlmIChpIDwgNikge1xuXHRcdFx0dGhpcy5tb2R1bGVzW2ldWzhdID0gbW9kO1xuXHRcdH0gZWxzZSBpZiAoaSA8IDgpIHtcblx0XHRcdHRoaXMubW9kdWxlc1tpICsgMV1bOF0gPSBtb2Q7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubW9kdWxlc1t0aGlzLm1vZHVsZUNvdW50IC0gMTUgKyBpXVs4XSA9IG1vZDtcblx0XHR9XG5cdH1cblxuXHQvLyBob3Jpem9udGFsXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgMTU7IGkrKykge1xuXG5cdFx0dmFyIG1vZCA9ICghdGVzdCAmJiAoIChiaXRzID4+IGkpICYgMSkgPT0gMSk7XG5cdFx0XG5cdFx0aWYgKGkgPCA4KSB7XG5cdFx0XHR0aGlzLm1vZHVsZXNbOF1bdGhpcy5tb2R1bGVDb3VudCAtIGkgLSAxXSA9IG1vZDtcblx0XHR9IGVsc2UgaWYgKGkgPCA5KSB7XG5cdFx0XHR0aGlzLm1vZHVsZXNbOF1bMTUgLSBpIC0gMSArIDFdID0gbW9kO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm1vZHVsZXNbOF1bMTUgLSBpIC0gMV0gPSBtb2Q7XG5cdFx0fVxuXHR9XG5cblx0Ly8gZml4ZWQgbW9kdWxlXG5cdHRoaXMubW9kdWxlc1t0aGlzLm1vZHVsZUNvdW50IC0gOF1bOF0gPSAoIXRlc3QpO1xufTtcblxucHJvdG8ubWFwRGF0YSA9IGZ1bmN0aW9uKGRhdGEsIG1hc2tQYXR0ZXJuKSB7XG5cdFxuXHR2YXIgaW5jID0gLTE7XG5cdHZhciByb3cgPSB0aGlzLm1vZHVsZUNvdW50IC0gMTtcblx0dmFyIGJpdEluZGV4ID0gNztcblx0dmFyIGJ5dGVJbmRleCA9IDA7XG5cdFxuXHRmb3IgKHZhciBjb2wgPSB0aGlzLm1vZHVsZUNvdW50IC0gMTsgY29sID4gMDsgY29sIC09IDIpIHtcblxuXHRcdGlmIChjb2wgPT0gNikgY29sLS07XG5cblx0XHR3aGlsZSAodHJ1ZSkge1xuXG5cdFx0XHRmb3IgKHZhciBjID0gMDsgYyA8IDI7IGMrKykge1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHRoaXMubW9kdWxlc1tyb3ddW2NvbCAtIGNdID09IG51bGwpIHtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR2YXIgZGFyayA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKGJ5dGVJbmRleCA8IGRhdGEubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRkYXJrID0gKCAoIChkYXRhW2J5dGVJbmRleF0gPj4+IGJpdEluZGV4KSAmIDEpID09IDEpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBtYXNrID0gdXRpbC5nZXRNYXNrKG1hc2tQYXR0ZXJuLCByb3csIGNvbCAtIGMpO1xuXG5cdFx0XHRcdFx0aWYgKG1hc2spIHtcblx0XHRcdFx0XHRcdGRhcmsgPSAhZGFyaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dGhpcy5tb2R1bGVzW3Jvd11bY29sIC0gY10gPSBkYXJrO1xuXHRcdFx0XHRcdGJpdEluZGV4LS07XG5cblx0XHRcdFx0XHRpZiAoYml0SW5kZXggPT0gLTEpIHtcblx0XHRcdFx0XHRcdGJ5dGVJbmRleCsrO1xuXHRcdFx0XHRcdFx0Yml0SW5kZXggPSA3O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcblx0XHRcdHJvdyArPSBpbmM7XG5cblx0XHRcdGlmIChyb3cgPCAwIHx8IHRoaXMubW9kdWxlQ291bnQgPD0gcm93KSB7XG5cdFx0XHRcdHJvdyAtPSBpbmM7XG5cdFx0XHRcdGluYyA9IC1pbmM7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuUVJDb2RlLlBBRDAgPSAweEVDO1xuUVJDb2RlLlBBRDEgPSAweDExO1xuXG5RUkNvZGUuY3JlYXRlRGF0YSA9IGZ1bmN0aW9uKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdExldmVsLCBkYXRhTGlzdCkge1xuXHRcblx0dmFyIHJzQmxvY2tzID0gUlNCbG9jay5nZXRSU0Jsb2Nrcyh0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3RMZXZlbCk7XG5cdFxuXHR2YXIgYnVmZmVyID0gbmV3IEJpdEJ1ZmZlcigpO1xuXHRcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhTGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBkYXRhID0gZGF0YUxpc3RbaV07XG5cdFx0YnVmZmVyLnB1dChkYXRhLm1vZGUsIDQpO1xuXHRcdGJ1ZmZlci5wdXQoZGF0YS5nZXRMZW5ndGgoKSwgdXRpbC5nZXRMZW5ndGhJbkJpdHMoZGF0YS5tb2RlLCB0eXBlTnVtYmVyKSApO1xuXHRcdGRhdGEud3JpdGUoYnVmZmVyKTtcblx0fVxuXG5cdC8vIGNhbGMgbnVtIG1heCBkYXRhLlxuXHR2YXIgdG90YWxEYXRhQ291bnQgPSAwO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHJzQmxvY2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dG90YWxEYXRhQ291bnQgKz0gcnNCbG9ja3NbaV0uZGF0YUNvdW50O1xuXHR9XG5cblx0aWYgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSA+IHRvdGFsRGF0YUNvdW50ICogOCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcImNvZGUgbGVuZ3RoIG92ZXJmbG93LiAoXCJcblx0XHRcdCsgYnVmZmVyLmdldExlbmd0aEluQml0cygpXG5cdFx0XHQrIFwiPlwiXG5cdFx0XHQrICB0b3RhbERhdGFDb3VudCAqIDhcblx0XHRcdCsgXCIpXCIpO1xuXHR9XG5cblx0Ly8gZW5kIGNvZGVcblx0aWYgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSArIDQgPD0gdG90YWxEYXRhQ291bnQgKiA4KSB7XG5cdFx0YnVmZmVyLnB1dCgwLCA0KTtcblx0fVxuXG5cdC8vIHBhZGRpbmdcblx0d2hpbGUgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSAlIDggIT0gMCkge1xuXHRcdGJ1ZmZlci5wdXRCaXQoZmFsc2UpO1xuXHR9XG5cblx0Ly8gcGFkZGluZ1xuXHR3aGlsZSAodHJ1ZSkge1xuXHRcdFxuXHRcdGlmIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgPj0gdG90YWxEYXRhQ291bnQgKiA4KSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0YnVmZmVyLnB1dChRUkNvZGUuUEFEMCwgOCk7XG5cdFx0XG5cdFx0aWYgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSA+PSB0b3RhbERhdGFDb3VudCAqIDgpIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRidWZmZXIucHV0KFFSQ29kZS5QQUQxLCA4KTtcblx0fVxuXG5cdHJldHVybiBRUkNvZGUuY3JlYXRlQnl0ZXMoYnVmZmVyLCByc0Jsb2Nrcyk7XG59O1xuXG5RUkNvZGUuY3JlYXRlQnl0ZXMgPSBmdW5jdGlvbihidWZmZXIsIHJzQmxvY2tzKSB7XG5cblx0dmFyIG9mZnNldCA9IDA7XG5cdFxuXHR2YXIgbWF4RGNDb3VudCA9IDA7XG5cdHZhciBtYXhFY0NvdW50ID0gMDtcblx0XG5cdHZhciBkY2RhdGEgPSBuZXcgQXJyYXkocnNCbG9ja3MubGVuZ3RoKTtcblx0dmFyIGVjZGF0YSA9IG5ldyBBcnJheShyc0Jsb2Nrcy5sZW5ndGgpO1xuXHRcblx0Zm9yICh2YXIgciA9IDA7IHIgPCByc0Jsb2Nrcy5sZW5ndGg7IHIrKykge1xuXG5cdFx0dmFyIGRjQ291bnQgPSByc0Jsb2Nrc1tyXS5kYXRhQ291bnQ7XG5cdFx0dmFyIGVjQ291bnQgPSByc0Jsb2Nrc1tyXS50b3RhbENvdW50IC0gZGNDb3VudDtcblxuXHRcdG1heERjQ291bnQgPSBNYXRoLm1heChtYXhEY0NvdW50LCBkY0NvdW50KTtcblx0XHRtYXhFY0NvdW50ID0gTWF0aC5tYXgobWF4RWNDb3VudCwgZWNDb3VudCk7XG5cdFx0XG5cdFx0ZGNkYXRhW3JdID0gbmV3IEFycmF5KGRjQ291bnQpO1xuXHRcdFxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGNkYXRhW3JdLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRkY2RhdGFbcl1baV0gPSAweGZmICYgYnVmZmVyLmJ1ZmZlcltpICsgb2Zmc2V0XTtcblx0XHR9XG5cdFx0b2Zmc2V0ICs9IGRjQ291bnQ7XG5cdFx0XG5cdFx0dmFyIHJzUG9seSA9IHV0aWwuZ2V0RXJyb3JDb3JyZWN0UG9seW5vbWlhbChlY0NvdW50KTtcblx0XHR2YXIgcmF3UG9seSA9IG5ldyBQb2x5bm9taWFsKGRjZGF0YVtyXSwgcnNQb2x5LmdldExlbmd0aCgpIC0gMSk7XG5cblx0XHR2YXIgbW9kUG9seSA9IHJhd1BvbHkubW9kKHJzUG9seSk7XG5cdFx0ZWNkYXRhW3JdID0gbmV3IEFycmF5KHJzUG9seS5nZXRMZW5ndGgoKSAtIDEpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZWNkYXRhW3JdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbW9kSW5kZXggPSBpICsgbW9kUG9seS5nZXRMZW5ndGgoKSAtIGVjZGF0YVtyXS5sZW5ndGg7XG5cdFx0XHRlY2RhdGFbcl1baV0gPSAobW9kSW5kZXggPj0gMCk/IG1vZFBvbHkuZ2V0KG1vZEluZGV4KSA6IDA7XG5cdFx0fVxuXG5cdH1cblx0XG5cdHZhciB0b3RhbENvZGVDb3VudCA9IDA7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcnNCbG9ja3MubGVuZ3RoOyBpKyspIHtcblx0XHR0b3RhbENvZGVDb3VudCArPSByc0Jsb2Nrc1tpXS50b3RhbENvdW50O1xuXHR9XG5cblx0dmFyIGRhdGEgPSBuZXcgQXJyYXkodG90YWxDb2RlQ291bnQpO1xuXHR2YXIgaW5kZXggPSAwO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbWF4RGNDb3VudDsgaSsrKSB7XG5cdFx0Zm9yICh2YXIgciA9IDA7IHIgPCByc0Jsb2Nrcy5sZW5ndGg7IHIrKykge1xuXHRcdFx0aWYgKGkgPCBkY2RhdGFbcl0ubGVuZ3RoKSB7XG5cdFx0XHRcdGRhdGFbaW5kZXgrK10gPSBkY2RhdGFbcl1baV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXhFY0NvdW50OyBpKyspIHtcblx0XHRmb3IgKHZhciByID0gMDsgciA8IHJzQmxvY2tzLmxlbmd0aDsgcisrKSB7XG5cdFx0XHRpZiAoaSA8IGVjZGF0YVtyXS5sZW5ndGgpIHtcblx0XHRcdFx0ZGF0YVtpbmRleCsrXSA9IGVjZGF0YVtyXVtpXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUVJDb2RlO1xuXG4iLCIvLyBFcnJvckNvcnJlY3RMZXZlbFxudmFyIEVDTCA9IHJlcXVpcmUoJy4vRXJyb3JDb3JyZWN0TGV2ZWwnKTtcblxuZnVuY3Rpb24gUVJSU0Jsb2NrKHRvdGFsQ291bnQsIGRhdGFDb3VudCkge1xuXHR0aGlzLnRvdGFsQ291bnQgPSB0b3RhbENvdW50O1xuXHR0aGlzLmRhdGFDb3VudCAgPSBkYXRhQ291bnQ7XG59XG5cblFSUlNCbG9jay5SU19CTE9DS19UQUJMRSA9IFtcblxuXHQvLyBMXG5cdC8vIE1cblx0Ly8gUVxuXHQvLyBIXG5cblx0Ly8gMVxuXHRbMSwgMjYsIDE5XSxcblx0WzEsIDI2LCAxNl0sXG5cdFsxLCAyNiwgMTNdLFxuXHRbMSwgMjYsIDldLFxuXHRcblx0Ly8gMlxuXHRbMSwgNDQsIDM0XSxcblx0WzEsIDQ0LCAyOF0sXG5cdFsxLCA0NCwgMjJdLFxuXHRbMSwgNDQsIDE2XSxcblxuXHQvLyAzXG5cdFsxLCA3MCwgNTVdLFxuXHRbMSwgNzAsIDQ0XSxcblx0WzIsIDM1LCAxN10sXG5cdFsyLCAzNSwgMTNdLFxuXG5cdC8vIDRcdFx0XG5cdFsxLCAxMDAsIDgwXSxcblx0WzIsIDUwLCAzMl0sXG5cdFsyLCA1MCwgMjRdLFxuXHRbNCwgMjUsIDldLFxuXHRcblx0Ly8gNVxuXHRbMSwgMTM0LCAxMDhdLFxuXHRbMiwgNjcsIDQzXSxcblx0WzIsIDMzLCAxNSwgMiwgMzQsIDE2XSxcblx0WzIsIDMzLCAxMSwgMiwgMzQsIDEyXSxcblx0XG5cdC8vIDZcblx0WzIsIDg2LCA2OF0sXG5cdFs0LCA0MywgMjddLFxuXHRbNCwgNDMsIDE5XSxcblx0WzQsIDQzLCAxNV0sXG5cdFxuXHQvLyA3XHRcdFxuXHRbMiwgOTgsIDc4XSxcblx0WzQsIDQ5LCAzMV0sXG5cdFsyLCAzMiwgMTQsIDQsIDMzLCAxNV0sXG5cdFs0LCAzOSwgMTMsIDEsIDQwLCAxNF0sXG5cdFxuXHQvLyA4XG5cdFsyLCAxMjEsIDk3XSxcblx0WzIsIDYwLCAzOCwgMiwgNjEsIDM5XSxcblx0WzQsIDQwLCAxOCwgMiwgNDEsIDE5XSxcblx0WzQsIDQwLCAxNCwgMiwgNDEsIDE1XSxcblx0XG5cdC8vIDlcblx0WzIsIDE0NiwgMTE2XSxcblx0WzMsIDU4LCAzNiwgMiwgNTksIDM3XSxcblx0WzQsIDM2LCAxNiwgNCwgMzcsIDE3XSxcblx0WzQsIDM2LCAxMiwgNCwgMzcsIDEzXSxcblx0XG5cdC8vIDEwXHRcdFxuXHRbMiwgODYsIDY4LCAyLCA4NywgNjldLFxuXHRbNCwgNjksIDQzLCAxLCA3MCwgNDRdLFxuXHRbNiwgNDMsIDE5LCAyLCA0NCwgMjBdLFxuXHRbNiwgNDMsIDE1LCAyLCA0NCwgMTZdLFxuXG5cdC8vIDExXG5cdFs0LCAxMDEsIDgxXSxcblx0WzEsIDgwLCA1MCwgNCwgODEsIDUxXSxcblx0WzQsIDUwLCAyMiwgNCwgNTEsIDIzXSxcblx0WzMsIDM2LCAxMiwgOCwgMzcsIDEzXSxcblxuXHQvLyAxMlxuXHRbMiwgMTE2LCA5MiwgMiwgMTE3LCA5M10sXG5cdFs2LCA1OCwgMzYsIDIsIDU5LCAzN10sXG5cdFs0LCA0NiwgMjAsIDYsIDQ3LCAyMV0sXG5cdFs3LCA0MiwgMTQsIDQsIDQzLCAxNV0sXG5cblx0Ly8gMTNcblx0WzQsIDEzMywgMTA3XSxcblx0WzgsIDU5LCAzNywgMSwgNjAsIDM4XSxcblx0WzgsIDQ0LCAyMCwgNCwgNDUsIDIxXSxcblx0WzEyLCAzMywgMTEsIDQsIDM0LCAxMl0sXG5cblx0Ly8gMTRcblx0WzMsIDE0NSwgMTE1LCAxLCAxNDYsIDExNl0sXG5cdFs0LCA2NCwgNDAsIDUsIDY1LCA0MV0sXG5cdFsxMSwgMzYsIDE2LCA1LCAzNywgMTddLFxuXHRbMTEsIDM2LCAxMiwgNSwgMzcsIDEzXSxcblxuXHQvLyAxNVxuXHRbNSwgMTA5LCA4NywgMSwgMTEwLCA4OF0sXG5cdFs1LCA2NSwgNDEsIDUsIDY2LCA0Ml0sXG5cdFs1LCA1NCwgMjQsIDcsIDU1LCAyNV0sXG5cdFsxMSwgMzYsIDEyXSxcblxuXHQvLyAxNlxuXHRbNSwgMTIyLCA5OCwgMSwgMTIzLCA5OV0sXG5cdFs3LCA3MywgNDUsIDMsIDc0LCA0Nl0sXG5cdFsxNSwgNDMsIDE5LCAyLCA0NCwgMjBdLFxuXHRbMywgNDUsIDE1LCAxMywgNDYsIDE2XSxcblxuXHQvLyAxN1xuXHRbMSwgMTM1LCAxMDcsIDUsIDEzNiwgMTA4XSxcblx0WzEwLCA3NCwgNDYsIDEsIDc1LCA0N10sXG5cdFsxLCA1MCwgMjIsIDE1LCA1MSwgMjNdLFxuXHRbMiwgNDIsIDE0LCAxNywgNDMsIDE1XSxcblxuXHQvLyAxOFxuXHRbNSwgMTUwLCAxMjAsIDEsIDE1MSwgMTIxXSxcblx0WzksIDY5LCA0MywgNCwgNzAsIDQ0XSxcblx0WzE3LCA1MCwgMjIsIDEsIDUxLCAyM10sXG5cdFsyLCA0MiwgMTQsIDE5LCA0MywgMTVdLFxuXG5cdC8vIDE5XG5cdFszLCAxNDEsIDExMywgNCwgMTQyLCAxMTRdLFxuXHRbMywgNzAsIDQ0LCAxMSwgNzEsIDQ1XSxcblx0WzE3LCA0NywgMjEsIDQsIDQ4LCAyMl0sXG5cdFs5LCAzOSwgMTMsIDE2LCA0MCwgMTRdLFxuXG5cdC8vIDIwXG5cdFszLCAxMzUsIDEwNywgNSwgMTM2LCAxMDhdLFxuXHRbMywgNjcsIDQxLCAxMywgNjgsIDQyXSxcblx0WzE1LCA1NCwgMjQsIDUsIDU1LCAyNV0sXG5cdFsxNSwgNDMsIDE1LCAxMCwgNDQsIDE2XSxcblxuXHQvLyAyMVxuXHRbNCwgMTQ0LCAxMTYsIDQsIDE0NSwgMTE3XSxcblx0WzE3LCA2OCwgNDJdLFxuXHRbMTcsIDUwLCAyMiwgNiwgNTEsIDIzXSxcblx0WzE5LCA0NiwgMTYsIDYsIDQ3LCAxN10sXG5cblx0Ly8gMjJcblx0WzIsIDEzOSwgMTExLCA3LCAxNDAsIDExMl0sXG5cdFsxNywgNzQsIDQ2XSxcblx0WzcsIDU0LCAyNCwgMTYsIDU1LCAyNV0sXG5cdFszNCwgMzcsIDEzXSxcblxuXHQvLyAyM1xuXHRbNCwgMTUxLCAxMjEsIDUsIDE1MiwgMTIyXSxcblx0WzQsIDc1LCA0NywgMTQsIDc2LCA0OF0sXG5cdFsxMSwgNTQsIDI0LCAxNCwgNTUsIDI1XSxcblx0WzE2LCA0NSwgMTUsIDE0LCA0NiwgMTZdLFxuXG5cdC8vIDI0XG5cdFs2LCAxNDcsIDExNywgNCwgMTQ4LCAxMThdLFxuXHRbNiwgNzMsIDQ1LCAxNCwgNzQsIDQ2XSxcblx0WzExLCA1NCwgMjQsIDE2LCA1NSwgMjVdLFxuXHRbMzAsIDQ2LCAxNiwgMiwgNDcsIDE3XSxcblxuXHQvLyAyNVxuXHRbOCwgMTMyLCAxMDYsIDQsIDEzMywgMTA3XSxcblx0WzgsIDc1LCA0NywgMTMsIDc2LCA0OF0sXG5cdFs3LCA1NCwgMjQsIDIyLCA1NSwgMjVdLFxuXHRbMjIsIDQ1LCAxNSwgMTMsIDQ2LCAxNl0sXG5cblx0Ly8gMjZcblx0WzEwLCAxNDIsIDExNCwgMiwgMTQzLCAxMTVdLFxuXHRbMTksIDc0LCA0NiwgNCwgNzUsIDQ3XSxcblx0WzI4LCA1MCwgMjIsIDYsIDUxLCAyM10sXG5cdFszMywgNDYsIDE2LCA0LCA0NywgMTddLFxuXG5cdC8vIDI3XG5cdFs4LCAxNTIsIDEyMiwgNCwgMTUzLCAxMjNdLFxuXHRbMjIsIDczLCA0NSwgMywgNzQsIDQ2XSxcblx0WzgsIDUzLCAyMywgMjYsIDU0LCAyNF0sXG5cdFsxMiwgNDUsIDE1LCAyOCwgNDYsIDE2XSxcblxuXHQvLyAyOFxuXHRbMywgMTQ3LCAxMTcsIDEwLCAxNDgsIDExOF0sXG5cdFszLCA3MywgNDUsIDIzLCA3NCwgNDZdLFxuXHRbNCwgNTQsIDI0LCAzMSwgNTUsIDI1XSxcblx0WzExLCA0NSwgMTUsIDMxLCA0NiwgMTZdLFxuXG5cdC8vIDI5XG5cdFs3LCAxNDYsIDExNiwgNywgMTQ3LCAxMTddLFxuXHRbMjEsIDczLCA0NSwgNywgNzQsIDQ2XSxcblx0WzEsIDUzLCAyMywgMzcsIDU0LCAyNF0sXG5cdFsxOSwgNDUsIDE1LCAyNiwgNDYsIDE2XSxcblxuXHQvLyAzMFxuXHRbNSwgMTQ1LCAxMTUsIDEwLCAxNDYsIDExNl0sXG5cdFsxOSwgNzUsIDQ3LCAxMCwgNzYsIDQ4XSxcblx0WzE1LCA1NCwgMjQsIDI1LCA1NSwgMjVdLFxuXHRbMjMsIDQ1LCAxNSwgMjUsIDQ2LCAxNl0sXG5cblx0Ly8gMzFcblx0WzEzLCAxNDUsIDExNSwgMywgMTQ2LCAxMTZdLFxuXHRbMiwgNzQsIDQ2LCAyOSwgNzUsIDQ3XSxcblx0WzQyLCA1NCwgMjQsIDEsIDU1LCAyNV0sXG5cdFsyMywgNDUsIDE1LCAyOCwgNDYsIDE2XSxcblxuXHQvLyAzMlxuXHRbMTcsIDE0NSwgMTE1XSxcblx0WzEwLCA3NCwgNDYsIDIzLCA3NSwgNDddLFxuXHRbMTAsIDU0LCAyNCwgMzUsIDU1LCAyNV0sXG5cdFsxOSwgNDUsIDE1LCAzNSwgNDYsIDE2XSxcblxuXHQvLyAzM1xuXHRbMTcsIDE0NSwgMTE1LCAxLCAxNDYsIDExNl0sXG5cdFsxNCwgNzQsIDQ2LCAyMSwgNzUsIDQ3XSxcblx0WzI5LCA1NCwgMjQsIDE5LCA1NSwgMjVdLFxuXHRbMTEsIDQ1LCAxNSwgNDYsIDQ2LCAxNl0sXG5cblx0Ly8gMzRcblx0WzEzLCAxNDUsIDExNSwgNiwgMTQ2LCAxMTZdLFxuXHRbMTQsIDc0LCA0NiwgMjMsIDc1LCA0N10sXG5cdFs0NCwgNTQsIDI0LCA3LCA1NSwgMjVdLFxuXHRbNTksIDQ2LCAxNiwgMSwgNDcsIDE3XSxcblxuXHQvLyAzNVxuXHRbMTIsIDE1MSwgMTIxLCA3LCAxNTIsIDEyMl0sXG5cdFsxMiwgNzUsIDQ3LCAyNiwgNzYsIDQ4XSxcblx0WzM5LCA1NCwgMjQsIDE0LCA1NSwgMjVdLFxuXHRbMjIsIDQ1LCAxNSwgNDEsIDQ2LCAxNl0sXG5cblx0Ly8gMzZcblx0WzYsIDE1MSwgMTIxLCAxNCwgMTUyLCAxMjJdLFxuXHRbNiwgNzUsIDQ3LCAzNCwgNzYsIDQ4XSxcblx0WzQ2LCA1NCwgMjQsIDEwLCA1NSwgMjVdLFxuXHRbMiwgNDUsIDE1LCA2NCwgNDYsIDE2XSxcblxuXHQvLyAzN1xuXHRbMTcsIDE1MiwgMTIyLCA0LCAxNTMsIDEyM10sXG5cdFsyOSwgNzQsIDQ2LCAxNCwgNzUsIDQ3XSxcblx0WzQ5LCA1NCwgMjQsIDEwLCA1NSwgMjVdLFxuXHRbMjQsIDQ1LCAxNSwgNDYsIDQ2LCAxNl0sXG5cblx0Ly8gMzhcblx0WzQsIDE1MiwgMTIyLCAxOCwgMTUzLCAxMjNdLFxuXHRbMTMsIDc0LCA0NiwgMzIsIDc1LCA0N10sXG5cdFs0OCwgNTQsIDI0LCAxNCwgNTUsIDI1XSxcblx0WzQyLCA0NSwgMTUsIDMyLCA0NiwgMTZdLFxuXG5cdC8vIDM5XG5cdFsyMCwgMTQ3LCAxMTcsIDQsIDE0OCwgMTE4XSxcblx0WzQwLCA3NSwgNDcsIDcsIDc2LCA0OF0sXG5cdFs0MywgNTQsIDI0LCAyMiwgNTUsIDI1XSxcblx0WzEwLCA0NSwgMTUsIDY3LCA0NiwgMTZdLFxuXG5cdC8vIDQwXG5cdFsxOSwgMTQ4LCAxMTgsIDYsIDE0OSwgMTE5XSxcblx0WzE4LCA3NSwgNDcsIDMxLCA3NiwgNDhdLFxuXHRbMzQsIDU0LCAyNCwgMzQsIDU1LCAyNV0sXG5cdFsyMCwgNDUsIDE1LCA2MSwgNDYsIDE2XVxuXTtcblxuUVJSU0Jsb2NrLmdldFJTQmxvY2tzID0gZnVuY3Rpb24odHlwZU51bWJlciwgZXJyb3JDb3JyZWN0TGV2ZWwpIHtcblx0XG5cdHZhciByc0Jsb2NrID0gUVJSU0Jsb2NrLmdldFJzQmxvY2tUYWJsZSh0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3RMZXZlbCk7XG5cdFxuXHRpZiAocnNCbG9jayA9PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcnMgYmxvY2sgQCB0eXBlTnVtYmVyOlwiICsgdHlwZU51bWJlciArIFwiL2Vycm9yQ29ycmVjdExldmVsOlwiICsgZXJyb3JDb3JyZWN0TGV2ZWwpO1xuXHR9XG5cblx0dmFyIGxlbmd0aCA9IHJzQmxvY2subGVuZ3RoIC8gMztcblx0XG5cdHZhciBsaXN0ID0gbmV3IEFycmF5KCk7XG5cdFxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cblx0XHR2YXIgY291bnQgPSByc0Jsb2NrW2kgKiAzICsgMF07XG5cdFx0dmFyIHRvdGFsQ291bnQgPSByc0Jsb2NrW2kgKiAzICsgMV07XG5cdFx0dmFyIGRhdGFDb3VudCAgPSByc0Jsb2NrW2kgKiAzICsgMl07XG5cblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcblx0XHRcdGxpc3QucHVzaChuZXcgUVJSU0Jsb2NrKHRvdGFsQ291bnQsIGRhdGFDb3VudCkgKTtcdFxuXHRcdH1cblx0fVxuXHRcblx0cmV0dXJuIGxpc3Q7XG59XG5cblFSUlNCbG9jay5nZXRSc0Jsb2NrVGFibGUgPSBmdW5jdGlvbih0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3RMZXZlbCkge1xuXG5cdHN3aXRjaChlcnJvckNvcnJlY3RMZXZlbCkge1xuXHRjYXNlIEVDTC5MIDpcblx0XHRyZXR1cm4gUVJSU0Jsb2NrLlJTX0JMT0NLX1RBQkxFWyh0eXBlTnVtYmVyIC0gMSkgKiA0ICsgMF07XG5cdGNhc2UgRUNMLk0gOlxuXHRcdHJldHVybiBRUlJTQmxvY2suUlNfQkxPQ0tfVEFCTEVbKHR5cGVOdW1iZXIgLSAxKSAqIDQgKyAxXTtcblx0Y2FzZSBFQ0wuUSA6XG5cdFx0cmV0dXJuIFFSUlNCbG9jay5SU19CTE9DS19UQUJMRVsodHlwZU51bWJlciAtIDEpICogNCArIDJdO1xuXHRjYXNlIEVDTC5IIDpcblx0XHRyZXR1cm4gUVJSU0Jsb2NrLlJTX0JMT0NLX1RBQkxFWyh0eXBlTnVtYmVyIC0gMSkgKiA0ICsgM107XG5cdGRlZmF1bHQgOlxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBRUlJTQmxvY2s7XG4iLCJ2YXIgUVJNYXRoID0ge1xuXG5cdGdsb2cgOiBmdW5jdGlvbihuKSB7XG5cdFxuXHRcdGlmIChuIDwgMSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZ2xvZyhcIiArIG4gKyBcIilcIik7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBRUk1hdGguTE9HX1RBQkxFW25dO1xuXHR9LFxuXHRcblx0Z2V4cCA6IGZ1bmN0aW9uKG4pIHtcblx0XG5cdFx0d2hpbGUgKG4gPCAwKSB7XG5cdFx0XHRuICs9IDI1NTtcblx0XHR9XG5cdFxuXHRcdHdoaWxlIChuID49IDI1Nikge1xuXHRcdFx0biAtPSAyNTU7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gUVJNYXRoLkVYUF9UQUJMRVtuXTtcblx0fSxcblx0XG5cdEVYUF9UQUJMRSA6IG5ldyBBcnJheSgyNTYpLFxuXHRcblx0TE9HX1RBQkxFIDogbmV3IEFycmF5KDI1NilcblxufTtcblx0XG5mb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuXHRRUk1hdGguRVhQX1RBQkxFW2ldID0gMSA8PCBpO1xufVxuZm9yICh2YXIgaSA9IDg7IGkgPCAyNTY7IGkrKykge1xuXHRRUk1hdGguRVhQX1RBQkxFW2ldID0gUVJNYXRoLkVYUF9UQUJMRVtpIC0gNF1cblx0XHReIFFSTWF0aC5FWFBfVEFCTEVbaSAtIDVdXG5cdFx0XiBRUk1hdGguRVhQX1RBQkxFW2kgLSA2XVxuXHRcdF4gUVJNYXRoLkVYUF9UQUJMRVtpIC0gOF07XG59XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NTsgaSsrKSB7XG5cdFFSTWF0aC5MT0dfVEFCTEVbUVJNYXRoLkVYUF9UQUJMRVtpXSBdID0gaTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBRUk1hdGg7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0TU9ERV9OVU1CRVIgOlx0XHQxIDw8IDAsXG5cdE1PREVfQUxQSEFfTlVNIDogXHQxIDw8IDEsXG5cdE1PREVfOEJJVF9CWVRFIDogXHQxIDw8IDIsXG5cdE1PREVfS0FOSkkgOlx0XHQxIDw8IDNcbn07XG4iLCJ2YXIgTW9kZSA9IHJlcXVpcmUoJy4vbW9kZScpO1xudmFyIFBvbHlub21pYWwgPSByZXF1aXJlKCcuL1BvbHlub21pYWwnKTtcbnZhciBtYXRoID0gcmVxdWlyZSgnLi9tYXRoJyk7XG5cbnZhciBRUk1hc2tQYXR0ZXJuID0ge1xuXHRQQVRURVJOMDAwIDogMCxcblx0UEFUVEVSTjAwMSA6IDEsXG5cdFBBVFRFUk4wMTAgOiAyLFxuXHRQQVRURVJOMDExIDogMyxcblx0UEFUVEVSTjEwMCA6IDQsXG5cdFBBVFRFUk4xMDEgOiA1LFxuXHRQQVRURVJOMTEwIDogNixcblx0UEFUVEVSTjExMSA6IDdcbn07XG5cbnZhciBRUlV0aWwgPSB7XG5cbiAgICBQQVRURVJOX1BPU0lUSU9OX1RBQkxFIDogW1xuXHQgICAgW10sXG5cdCAgICBbNiwgMThdLFxuXHQgICAgWzYsIDIyXSxcblx0ICAgIFs2LCAyNl0sXG5cdCAgICBbNiwgMzBdLFxuXHQgICAgWzYsIDM0XSxcblx0ICAgIFs2LCAyMiwgMzhdLFxuXHQgICAgWzYsIDI0LCA0Ml0sXG5cdCAgICBbNiwgMjYsIDQ2XSxcblx0ICAgIFs2LCAyOCwgNTBdLFxuXHQgICAgWzYsIDMwLCA1NF0sXHRcdFxuXHQgICAgWzYsIDMyLCA1OF0sXG5cdCAgICBbNiwgMzQsIDYyXSxcblx0ICAgIFs2LCAyNiwgNDYsIDY2XSxcblx0ICAgIFs2LCAyNiwgNDgsIDcwXSxcblx0ICAgIFs2LCAyNiwgNTAsIDc0XSxcblx0ICAgIFs2LCAzMCwgNTQsIDc4XSxcblx0ICAgIFs2LCAzMCwgNTYsIDgyXSxcblx0ICAgIFs2LCAzMCwgNTgsIDg2XSxcblx0ICAgIFs2LCAzNCwgNjIsIDkwXSxcblx0ICAgIFs2LCAyOCwgNTAsIDcyLCA5NF0sXG5cdCAgICBbNiwgMjYsIDUwLCA3NCwgOThdLFxuXHQgICAgWzYsIDMwLCA1NCwgNzgsIDEwMl0sXG5cdCAgICBbNiwgMjgsIDU0LCA4MCwgMTA2XSxcblx0ICAgIFs2LCAzMiwgNTgsIDg0LCAxMTBdLFxuXHQgICAgWzYsIDMwLCA1OCwgODYsIDExNF0sXG5cdCAgICBbNiwgMzQsIDYyLCA5MCwgMTE4XSxcblx0ICAgIFs2LCAyNiwgNTAsIDc0LCA5OCwgMTIyXSxcblx0ICAgIFs2LCAzMCwgNTQsIDc4LCAxMDIsIDEyNl0sXG5cdCAgICBbNiwgMjYsIDUyLCA3OCwgMTA0LCAxMzBdLFxuXHQgICAgWzYsIDMwLCA1NiwgODIsIDEwOCwgMTM0XSxcblx0ICAgIFs2LCAzNCwgNjAsIDg2LCAxMTIsIDEzOF0sXG5cdCAgICBbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDJdLFxuXHQgICAgWzYsIDM0LCA2MiwgOTAsIDExOCwgMTQ2XSxcblx0ICAgIFs2LCAzMCwgNTQsIDc4LCAxMDIsIDEyNiwgMTUwXSxcblx0ICAgIFs2LCAyNCwgNTAsIDc2LCAxMDIsIDEyOCwgMTU0XSxcblx0ICAgIFs2LCAyOCwgNTQsIDgwLCAxMDYsIDEzMiwgMTU4XSxcblx0ICAgIFs2LCAzMiwgNTgsIDg0LCAxMTAsIDEzNiwgMTYyXSxcblx0ICAgIFs2LCAyNiwgNTQsIDgyLCAxMTAsIDEzOCwgMTY2XSxcblx0ICAgIFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0MiwgMTcwXVxuICAgIF0sXG5cbiAgICBHMTUgOiAoMSA8PCAxMCkgfCAoMSA8PCA4KSB8ICgxIDw8IDUpIHwgKDEgPDwgNCkgfCAoMSA8PCAyKSB8ICgxIDw8IDEpIHwgKDEgPDwgMCksXG4gICAgRzE4IDogKDEgPDwgMTIpIHwgKDEgPDwgMTEpIHwgKDEgPDwgMTApIHwgKDEgPDwgOSkgfCAoMSA8PCA4KSB8ICgxIDw8IDUpIHwgKDEgPDwgMikgfCAoMSA8PCAwKSxcbiAgICBHMTVfTUFTSyA6ICgxIDw8IDE0KSB8ICgxIDw8IDEyKSB8ICgxIDw8IDEwKVx0fCAoMSA8PCA0KSB8ICgxIDw8IDEpLFxuXG4gICAgZ2V0QkNIVHlwZUluZm8gOiBmdW5jdGlvbihkYXRhKSB7XG5cdCAgICB2YXIgZCA9IGRhdGEgPDwgMTA7XG5cdCAgICB3aGlsZSAoUVJVdGlsLmdldEJDSERpZ2l0KGQpIC0gUVJVdGlsLmdldEJDSERpZ2l0KFFSVXRpbC5HMTUpID49IDApIHtcblx0XHQgICAgZCBePSAoUVJVdGlsLkcxNSA8PCAoUVJVdGlsLmdldEJDSERpZ2l0KGQpIC0gUVJVdGlsLmdldEJDSERpZ2l0KFFSVXRpbC5HMTUpICkgKTsgXHRcblx0ICAgIH1cblx0ICAgIHJldHVybiAoIChkYXRhIDw8IDEwKSB8IGQpIF4gUVJVdGlsLkcxNV9NQVNLO1xuICAgIH0sXG5cbiAgICBnZXRCQ0hUeXBlTnVtYmVyIDogZnVuY3Rpb24oZGF0YSkge1xuXHQgICAgdmFyIGQgPSBkYXRhIDw8IDEyO1xuXHQgICAgd2hpbGUgKFFSVXRpbC5nZXRCQ0hEaWdpdChkKSAtIFFSVXRpbC5nZXRCQ0hEaWdpdChRUlV0aWwuRzE4KSA+PSAwKSB7XG5cdFx0ICAgIGQgXj0gKFFSVXRpbC5HMTggPDwgKFFSVXRpbC5nZXRCQ0hEaWdpdChkKSAtIFFSVXRpbC5nZXRCQ0hEaWdpdChRUlV0aWwuRzE4KSApICk7IFx0XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKGRhdGEgPDwgMTIpIHwgZDtcbiAgICB9LFxuXG4gICAgZ2V0QkNIRGlnaXQgOiBmdW5jdGlvbihkYXRhKSB7XG5cblx0ICAgIHZhciBkaWdpdCA9IDA7XG5cblx0ICAgIHdoaWxlIChkYXRhICE9IDApIHtcblx0XHQgICAgZGlnaXQrKztcblx0XHQgICAgZGF0YSA+Pj49IDE7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBkaWdpdDtcbiAgICB9LFxuXG4gICAgZ2V0UGF0dGVyblBvc2l0aW9uIDogZnVuY3Rpb24odHlwZU51bWJlcikge1xuXHQgICAgcmV0dXJuIFFSVXRpbC5QQVRURVJOX1BPU0lUSU9OX1RBQkxFW3R5cGVOdW1iZXIgLSAxXTtcbiAgICB9LFxuXG4gICAgZ2V0TWFzayA6IGZ1bmN0aW9uKG1hc2tQYXR0ZXJuLCBpLCBqKSB7XG5cdCAgICBcblx0ICAgIHN3aXRjaCAobWFza1BhdHRlcm4pIHtcblx0XHQgICAgXG5cdCAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjAwMCA6IHJldHVybiAoaSArIGopICUgMiA9PSAwO1xuXHQgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4wMDEgOiByZXR1cm4gaSAlIDIgPT0gMDtcblx0ICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMDEwIDogcmV0dXJuIGogJSAzID09IDA7XG5cdCAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjAxMSA6IHJldHVybiAoaSArIGopICUgMyA9PSAwO1xuXHQgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4xMDAgOiByZXR1cm4gKE1hdGguZmxvb3IoaSAvIDIpICsgTWF0aC5mbG9vcihqIC8gMykgKSAlIDIgPT0gMDtcblx0ICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMTAxIDogcmV0dXJuIChpICogaikgJSAyICsgKGkgKiBqKSAlIDMgPT0gMDtcblx0ICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMTEwIDogcmV0dXJuICggKGkgKiBqKSAlIDIgKyAoaSAqIGopICUgMykgJSAyID09IDA7XG5cdCAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjExMSA6IHJldHVybiAoIChpICogaikgJSAzICsgKGkgKyBqKSAlIDIpICUgMiA9PSAwO1xuXG5cdCAgICBkZWZhdWx0IDpcblx0XHQgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIG1hc2tQYXR0ZXJuOlwiICsgbWFza1BhdHRlcm4pO1xuXHQgICAgfVxuICAgIH0sXG5cbiAgICBnZXRFcnJvckNvcnJlY3RQb2x5bm9taWFsIDogZnVuY3Rpb24oZXJyb3JDb3JyZWN0TGVuZ3RoKSB7XG5cblx0ICAgIHZhciBhID0gbmV3IFBvbHlub21pYWwoWzFdLCAwKTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlcnJvckNvcnJlY3RMZW5ndGg7IGkrKykge1xuXHRcdCAgICBhID0gYS5tdWx0aXBseShuZXcgUG9seW5vbWlhbChbMSwgbWF0aC5nZXhwKGkpXSwgMCkgKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGE7XG4gICAgfSxcblxuICAgIGdldExlbmd0aEluQml0cyA6IGZ1bmN0aW9uKG1vZGUsIHR5cGUpIHtcblxuXHQgICAgaWYgKDEgPD0gdHlwZSAmJiB0eXBlIDwgMTApIHtcblxuXHRcdCAgICAvLyAxIC0gOVxuXG5cdFx0ICAgIHN3aXRjaChtb2RlKSB7XG5cdFx0ICAgIGNhc2UgTW9kZS5NT0RFX05VTUJFUiBcdDogcmV0dXJuIDEwO1xuXHRcdCAgICBjYXNlIE1vZGUuTU9ERV9BTFBIQV9OVU0gXHQ6IHJldHVybiA5O1xuXHRcdCAgICBjYXNlIE1vZGUuTU9ERV84QklUX0JZVEVcdDogcmV0dXJuIDg7XG5cdFx0ICAgIGNhc2UgTW9kZS5NT0RFX0tBTkpJICBcdDogcmV0dXJuIDg7XG5cdFx0ICAgIGRlZmF1bHQgOlxuXHRcdFx0ICAgIHRocm93IG5ldyBFcnJvcihcIm1vZGU6XCIgKyBtb2RlKTtcblx0XHQgICAgfVxuXG5cdCAgICB9IGVsc2UgaWYgKHR5cGUgPCAyNykge1xuXG5cdFx0ICAgIC8vIDEwIC0gMjZcblxuXHRcdCAgICBzd2l0Y2gobW9kZSkge1xuXHRcdCAgICBjYXNlIE1vZGUuTU9ERV9OVU1CRVIgXHQ6IHJldHVybiAxMjtcblx0XHQgICAgY2FzZSBNb2RlLk1PREVfQUxQSEFfTlVNIFx0OiByZXR1cm4gMTE7XG5cdFx0ICAgIGNhc2UgTW9kZS5NT0RFXzhCSVRfQllURVx0OiByZXR1cm4gMTY7XG5cdFx0ICAgIGNhc2UgTW9kZS5NT0RFX0tBTkpJICBcdDogcmV0dXJuIDEwO1xuXHRcdCAgICBkZWZhdWx0IDpcblx0XHRcdCAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb2RlOlwiICsgbW9kZSk7XG5cdFx0ICAgIH1cblxuXHQgICAgfSBlbHNlIGlmICh0eXBlIDwgNDEpIHtcblxuXHRcdCAgICAvLyAyNyAtIDQwXG5cblx0XHQgICAgc3dpdGNoKG1vZGUpIHtcblx0XHQgICAgY2FzZSBNb2RlLk1PREVfTlVNQkVSIFx0OiByZXR1cm4gMTQ7XG5cdFx0ICAgIGNhc2UgTW9kZS5NT0RFX0FMUEhBX05VTVx0OiByZXR1cm4gMTM7XG5cdFx0ICAgIGNhc2UgTW9kZS5NT0RFXzhCSVRfQllURVx0OiByZXR1cm4gMTY7XG5cdFx0ICAgIGNhc2UgTW9kZS5NT0RFX0tBTkpJICBcdDogcmV0dXJuIDEyO1xuXHRcdCAgICBkZWZhdWx0IDpcblx0XHRcdCAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb2RlOlwiICsgbW9kZSk7XG5cdFx0ICAgIH1cblxuXHQgICAgfSBlbHNlIHtcblx0XHQgICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZTpcIiArIHR5cGUpO1xuXHQgICAgfVxuICAgIH0sXG5cbiAgICBnZXRMb3N0UG9pbnQgOiBmdW5jdGlvbihxckNvZGUpIHtcblx0ICAgIFxuXHQgICAgdmFyIG1vZHVsZUNvdW50ID0gcXJDb2RlLmdldE1vZHVsZUNvdW50KCk7XG5cdCAgICBcblx0ICAgIHZhciBsb3N0UG9pbnQgPSAwO1xuXHQgICAgXG5cdCAgICAvLyBMRVZFTDFcblx0ICAgIFxuXHQgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQ7IHJvdysrKSB7XG5cblx0XHQgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQ7IGNvbCsrKSB7XG5cblx0XHRcdCAgICB2YXIgc2FtZUNvdW50ID0gMDtcblx0XHRcdCAgICB2YXIgZGFyayA9IHFyQ29kZS5pc0Rhcmsocm93LCBjb2wpO1xuXG5cdFx0XHRcdGZvciAodmFyIHIgPSAtMTsgciA8PSAxOyByKyspIHtcblxuXHRcdFx0XHQgICAgaWYgKHJvdyArIHIgPCAwIHx8IG1vZHVsZUNvdW50IDw9IHJvdyArIHIpIHtcblx0XHRcdFx0XHQgICAgY29udGludWU7XG5cdFx0XHRcdCAgICB9XG5cblx0XHRcdFx0ICAgIGZvciAodmFyIGMgPSAtMTsgYyA8PSAxOyBjKyspIHtcblxuXHRcdFx0XHRcdCAgICBpZiAoY29sICsgYyA8IDAgfHwgbW9kdWxlQ291bnQgPD0gY29sICsgYykge1xuXHRcdFx0XHRcdFx0ICAgIGNvbnRpbnVlO1xuXHRcdFx0XHRcdCAgICB9XG5cblx0XHRcdFx0XHQgICAgaWYgKHIgPT0gMCAmJiBjID09IDApIHtcblx0XHRcdFx0XHRcdCAgICBjb250aW51ZTtcblx0XHRcdFx0XHQgICAgfVxuXG5cdFx0XHRcdFx0ICAgIGlmIChkYXJrID09IHFyQ29kZS5pc0Rhcmsocm93ICsgciwgY29sICsgYykgKSB7XG5cdFx0XHRcdFx0XHQgICAgc2FtZUNvdW50Kys7XG5cdFx0XHRcdFx0ICAgIH1cblx0XHRcdFx0ICAgIH1cblx0XHRcdCAgICB9XG5cblx0XHRcdCAgICBpZiAoc2FtZUNvdW50ID4gNSkge1xuXHRcdFx0XHQgICAgbG9zdFBvaW50ICs9ICgzICsgc2FtZUNvdW50IC0gNSk7XG5cdFx0XHQgICAgfVxuXHRcdCAgICB9XG5cdCAgICB9XG5cblx0ICAgIC8vIExFVkVMMlxuXG5cdCAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudCAtIDE7IHJvdysrKSB7XG5cdFx0ICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50IC0gMTsgY29sKyspIHtcblx0XHRcdCAgICB2YXIgY291bnQgPSAwO1xuXHRcdFx0ICAgIGlmIChxckNvZGUuaXNEYXJrKHJvdywgICAgIGNvbCAgICApICkgY291bnQrKztcblx0XHRcdCAgICBpZiAocXJDb2RlLmlzRGFyayhyb3cgKyAxLCBjb2wgICAgKSApIGNvdW50Kys7XG5cdFx0XHQgICAgaWYgKHFyQ29kZS5pc0Rhcmsocm93LCAgICAgY29sICsgMSkgKSBjb3VudCsrO1xuXHRcdFx0ICAgIGlmIChxckNvZGUuaXNEYXJrKHJvdyArIDEsIGNvbCArIDEpICkgY291bnQrKztcblx0XHRcdCAgICBpZiAoY291bnQgPT0gMCB8fCBjb3VudCA9PSA0KSB7XG5cdFx0XHRcdCAgICBsb3N0UG9pbnQgKz0gMztcblx0XHRcdCAgICB9XG5cdFx0ICAgIH1cblx0ICAgIH1cblxuXHQgICAgLy8gTEVWRUwzXG5cblx0ICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vZHVsZUNvdW50OyByb3crKykge1xuXHRcdCAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudCAtIDY7IGNvbCsrKSB7XG5cdFx0XHQgICAgaWYgKHFyQ29kZS5pc0Rhcmsocm93LCBjb2wpXG5cdFx0XHRcdFx0ICAgICYmICFxckNvZGUuaXNEYXJrKHJvdywgY29sICsgMSlcblx0XHRcdFx0XHQgICAgJiYgIHFyQ29kZS5pc0Rhcmsocm93LCBjb2wgKyAyKVxuXHRcdFx0XHRcdCAgICAmJiAgcXJDb2RlLmlzRGFyayhyb3csIGNvbCArIDMpXG5cdFx0XHRcdFx0ICAgICYmICBxckNvZGUuaXNEYXJrKHJvdywgY29sICsgNClcblx0XHRcdFx0XHQgICAgJiYgIXFyQ29kZS5pc0Rhcmsocm93LCBjb2wgKyA1KVxuXHRcdFx0XHRcdCAgICAmJiAgcXJDb2RlLmlzRGFyayhyb3csIGNvbCArIDYpICkge1xuXHRcdFx0XHQgICAgbG9zdFBvaW50ICs9IDQwO1xuXHRcdFx0ICAgIH1cblx0XHQgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudDsgY29sKyspIHtcblx0XHQgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQgLSA2OyByb3crKykge1xuXHRcdFx0ICAgIGlmIChxckNvZGUuaXNEYXJrKHJvdywgY29sKVxuXHRcdFx0XHRcdCAgICAmJiAhcXJDb2RlLmlzRGFyayhyb3cgKyAxLCBjb2wpXG5cdFx0XHRcdFx0ICAgICYmICBxckNvZGUuaXNEYXJrKHJvdyArIDIsIGNvbClcblx0XHRcdFx0XHQgICAgJiYgIHFyQ29kZS5pc0Rhcmsocm93ICsgMywgY29sKVxuXHRcdFx0XHRcdCAgICAmJiAgcXJDb2RlLmlzRGFyayhyb3cgKyA0LCBjb2wpXG5cdFx0XHRcdFx0ICAgICYmICFxckNvZGUuaXNEYXJrKHJvdyArIDUsIGNvbClcblx0XHRcdFx0XHQgICAgJiYgIHFyQ29kZS5pc0Rhcmsocm93ICsgNiwgY29sKSApIHtcblx0XHRcdFx0ICAgIGxvc3RQb2ludCArPSA0MDtcblx0XHRcdCAgICB9XG5cdFx0ICAgIH1cblx0ICAgIH1cblxuXHQgICAgLy8gTEVWRUw0XG5cdCAgICBcblx0ICAgIHZhciBkYXJrQ291bnQgPSAwO1xuXG5cdCAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudDsgY29sKyspIHtcblx0XHQgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQ7IHJvdysrKSB7XG5cdFx0XHQgICAgaWYgKHFyQ29kZS5pc0Rhcmsocm93LCBjb2wpICkge1xuXHRcdFx0XHQgICAgZGFya0NvdW50Kys7XG5cdFx0XHQgICAgfVxuXHRcdCAgICB9XG5cdCAgICB9XG5cdCAgICBcblx0ICAgIHZhciByYXRpbyA9IE1hdGguYWJzKDEwMCAqIGRhcmtDb3VudCAvIG1vZHVsZUNvdW50IC8gbW9kdWxlQ291bnQgLSA1MCkgLyA1O1xuXHQgICAgbG9zdFBvaW50ICs9IHJhdGlvICogMTA7XG5cblx0ICAgIHJldHVybiBsb3N0UG9pbnQ7XHRcdFxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUVJVdGlsO1xuIiwiLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vXG4vLyBRUiBDb2RlIEdlbmVyYXRvciBmb3IgSmF2YVNjcmlwdFxuLy9cbi8vIENvcHlyaWdodCAoYykgMjAwOSBLYXp1aGlrbyBBcmFzZVxuLy9cbi8vIFVSTDogaHR0cDovL3d3dy5kLXByb2plY3QuY29tL1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbi8vICBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuLy9cbi8vIFRoZSB3b3JkICdRUiBDb2RlJyBpcyByZWdpc3RlcmVkIHRyYWRlbWFyayBvZlxuLy8gREVOU08gV0FWRSBJTkNPUlBPUkFURURcbi8vICBodHRwOi8vd3d3LmRlbnNvLXdhdmUuY29tL3FyY29kZS9mYXFwYXRlbnQtZS5odG1sXG4vL1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIHFyY29kZSA9IGZ1bmN0aW9uKCkge1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHFyY29kZVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBxcmNvZGVcbiAgICogQHBhcmFtIHR5cGVOdW1iZXIgMSB0byA0MFxuICAgKiBAcGFyYW0gZXJyb3JDb3JyZWN0aW9uTGV2ZWwgJ0wnLCdNJywnUScsJ0gnXG4gICAqL1xuICB2YXIgcXJjb2RlID0gZnVuY3Rpb24odHlwZU51bWJlciwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpIHtcblxuICAgIHZhciBQQUQwID0gMHhFQztcbiAgICB2YXIgUEFEMSA9IDB4MTE7XG5cbiAgICB2YXIgX3R5cGVOdW1iZXIgPSB0eXBlTnVtYmVyO1xuICAgIHZhciBfZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBRUkVycm9yQ29ycmVjdGlvbkxldmVsW2Vycm9yQ29ycmVjdGlvbkxldmVsXTtcbiAgICB2YXIgX21vZHVsZXMgPSBudWxsO1xuICAgIHZhciBfbW9kdWxlQ291bnQgPSAwO1xuICAgIHZhciBfZGF0YUNhY2hlID0gbnVsbDtcbiAgICB2YXIgX2RhdGFMaXN0ID0gW107XG5cbiAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgIHZhciBtYWtlSW1wbCA9IGZ1bmN0aW9uKHRlc3QsIG1hc2tQYXR0ZXJuKSB7XG5cbiAgICAgIF9tb2R1bGVDb3VudCA9IF90eXBlTnVtYmVyICogNCArIDE3O1xuICAgICAgX21vZHVsZXMgPSBmdW5jdGlvbihtb2R1bGVDb3VudCkge1xuICAgICAgICB2YXIgbW9kdWxlcyA9IG5ldyBBcnJheShtb2R1bGVDb3VudCk7XG4gICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vZHVsZUNvdW50OyByb3cgKz0gMSkge1xuICAgICAgICAgIG1vZHVsZXNbcm93XSA9IG5ldyBBcnJheShtb2R1bGVDb3VudCk7XG4gICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICBtb2R1bGVzW3Jvd11bY29sXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGVzO1xuICAgICAgfShfbW9kdWxlQ291bnQpO1xuXG4gICAgICBzZXR1cFBvc2l0aW9uUHJvYmVQYXR0ZXJuKDAsIDApO1xuICAgICAgc2V0dXBQb3NpdGlvblByb2JlUGF0dGVybihfbW9kdWxlQ291bnQgLSA3LCAwKTtcbiAgICAgIHNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4oMCwgX21vZHVsZUNvdW50IC0gNyk7XG4gICAgICBzZXR1cFBvc2l0aW9uQWRqdXN0UGF0dGVybigpO1xuICAgICAgc2V0dXBUaW1pbmdQYXR0ZXJuKCk7XG4gICAgICBzZXR1cFR5cGVJbmZvKHRlc3QsIG1hc2tQYXR0ZXJuKTtcblxuICAgICAgaWYgKF90eXBlTnVtYmVyID49IDcpIHtcbiAgICAgICAgc2V0dXBUeXBlTnVtYmVyKHRlc3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2RhdGFDYWNoZSA9PSBudWxsKSB7XG4gICAgICAgIF9kYXRhQ2FjaGUgPSBjcmVhdGVEYXRhKF90eXBlTnVtYmVyLCBfZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIF9kYXRhTGlzdCk7XG4gICAgICB9XG5cbiAgICAgIG1hcERhdGEoX2RhdGFDYWNoZSwgbWFza1BhdHRlcm4pO1xuICAgIH07XG5cbiAgICB2YXIgc2V0dXBQb3NpdGlvblByb2JlUGF0dGVybiA9IGZ1bmN0aW9uKHJvdywgY29sKSB7XG5cbiAgICAgIGZvciAodmFyIHIgPSAtMTsgciA8PSA3OyByICs9IDEpIHtcblxuICAgICAgICBpZiAocm93ICsgciA8PSAtMSB8fCBfbW9kdWxlQ291bnQgPD0gcm93ICsgcikgY29udGludWU7XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IC0xOyBjIDw9IDc7IGMgKz0gMSkge1xuXG4gICAgICAgICAgaWYgKGNvbCArIGMgPD0gLTEgfHwgX21vZHVsZUNvdW50IDw9IGNvbCArIGMpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgaWYgKCAoMCA8PSByICYmIHIgPD0gNiAmJiAoYyA9PSAwIHx8IGMgPT0gNikgKVxuICAgICAgICAgICAgICB8fCAoMCA8PSBjICYmIGMgPD0gNiAmJiAociA9PSAwIHx8IHIgPT0gNikgKVxuICAgICAgICAgICAgICB8fCAoMiA8PSByICYmIHIgPD0gNCAmJiAyIDw9IGMgJiYgYyA8PSA0KSApIHtcbiAgICAgICAgICAgIF9tb2R1bGVzW3JvdyArIHJdW2NvbCArIGNdID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX21vZHVsZXNbcm93ICsgcl1bY29sICsgY10gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGdldEJlc3RNYXNrUGF0dGVybiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgbWluTG9zdFBvaW50ID0gMDtcbiAgICAgIHZhciBwYXR0ZXJuID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcblxuICAgICAgICBtYWtlSW1wbCh0cnVlLCBpKTtcblxuICAgICAgICB2YXIgbG9zdFBvaW50ID0gUVJVdGlsLmdldExvc3RQb2ludChfdGhpcyk7XG5cbiAgICAgICAgaWYgKGkgPT0gMCB8fCBtaW5Mb3N0UG9pbnQgPiBsb3N0UG9pbnQpIHtcbiAgICAgICAgICBtaW5Mb3N0UG9pbnQgPSBsb3N0UG9pbnQ7XG4gICAgICAgICAgcGF0dGVybiA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgfTtcblxuICAgIHZhciBzZXR1cFRpbWluZ1BhdHRlcm4gPSBmdW5jdGlvbigpIHtcblxuICAgICAgZm9yICh2YXIgciA9IDg7IHIgPCBfbW9kdWxlQ291bnQgLSA4OyByICs9IDEpIHtcbiAgICAgICAgaWYgKF9tb2R1bGVzW3JdWzZdICE9IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBfbW9kdWxlc1tyXVs2XSA9IChyICUgMiA9PSAwKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgYyA9IDg7IGMgPCBfbW9kdWxlQ291bnQgLSA4OyBjICs9IDEpIHtcbiAgICAgICAgaWYgKF9tb2R1bGVzWzZdW2NdICE9IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBfbW9kdWxlc1s2XVtjXSA9IChjICUgMiA9PSAwKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHNldHVwUG9zaXRpb25BZGp1c3RQYXR0ZXJuID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBwb3MgPSBRUlV0aWwuZ2V0UGF0dGVyblBvc2l0aW9uKF90eXBlTnVtYmVyKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3MubGVuZ3RoOyBpICs9IDEpIHtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvcy5sZW5ndGg7IGogKz0gMSkge1xuXG4gICAgICAgICAgdmFyIHJvdyA9IHBvc1tpXTtcbiAgICAgICAgICB2YXIgY29sID0gcG9zW2pdO1xuXG4gICAgICAgICAgaWYgKF9tb2R1bGVzW3Jvd11bY29sXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciByID0gLTI7IHIgPD0gMjsgciArPSAxKSB7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAtMjsgYyA8PSAyOyBjICs9IDEpIHtcblxuICAgICAgICAgICAgICBpZiAociA9PSAtMiB8fCByID09IDIgfHwgYyA9PSAtMiB8fCBjID09IDJcbiAgICAgICAgICAgICAgICAgIHx8IChyID09IDAgJiYgYyA9PSAwKSApIHtcbiAgICAgICAgICAgICAgICBfbW9kdWxlc1tyb3cgKyByXVtjb2wgKyBjXSA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX21vZHVsZXNbcm93ICsgcl1bY29sICsgY10gPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc2V0dXBUeXBlTnVtYmVyID0gZnVuY3Rpb24odGVzdCkge1xuXG4gICAgICB2YXIgYml0cyA9IFFSVXRpbC5nZXRCQ0hUeXBlTnVtYmVyKF90eXBlTnVtYmVyKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxODsgaSArPSAxKSB7XG4gICAgICAgIHZhciBtb2QgPSAoIXRlc3QgJiYgKCAoYml0cyA+PiBpKSAmIDEpID09IDEpO1xuICAgICAgICBfbW9kdWxlc1tNYXRoLmZsb29yKGkgLyAzKV1baSAlIDMgKyBfbW9kdWxlQ291bnQgLSA4IC0gM10gPSBtb2Q7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbW9kID0gKCF0ZXN0ICYmICggKGJpdHMgPj4gaSkgJiAxKSA9PSAxKTtcbiAgICAgICAgX21vZHVsZXNbaSAlIDMgKyBfbW9kdWxlQ291bnQgLSA4IC0gM11bTWF0aC5mbG9vcihpIC8gMyldID0gbW9kO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc2V0dXBUeXBlSW5mbyA9IGZ1bmN0aW9uKHRlc3QsIG1hc2tQYXR0ZXJuKSB7XG5cbiAgICAgIHZhciBkYXRhID0gKF9lcnJvckNvcnJlY3Rpb25MZXZlbCA8PCAzKSB8IG1hc2tQYXR0ZXJuO1xuICAgICAgdmFyIGJpdHMgPSBRUlV0aWwuZ2V0QkNIVHlwZUluZm8oZGF0YSk7XG5cbiAgICAgIC8vIHZlcnRpY2FsXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE1OyBpICs9IDEpIHtcblxuICAgICAgICB2YXIgbW9kID0gKCF0ZXN0ICYmICggKGJpdHMgPj4gaSkgJiAxKSA9PSAxKTtcblxuICAgICAgICBpZiAoaSA8IDYpIHtcbiAgICAgICAgICBfbW9kdWxlc1tpXVs4XSA9IG1vZDtcbiAgICAgICAgfSBlbHNlIGlmIChpIDwgOCkge1xuICAgICAgICAgIF9tb2R1bGVzW2kgKyAxXVs4XSA9IG1vZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfbW9kdWxlc1tfbW9kdWxlQ291bnQgLSAxNSArIGldWzhdID0gbW9kO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGhvcml6b250YWxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTU7IGkgKz0gMSkge1xuXG4gICAgICAgIHZhciBtb2QgPSAoIXRlc3QgJiYgKCAoYml0cyA+PiBpKSAmIDEpID09IDEpO1xuXG4gICAgICAgIGlmIChpIDwgOCkge1xuICAgICAgICAgIF9tb2R1bGVzWzhdW19tb2R1bGVDb3VudCAtIGkgLSAxXSA9IG1vZDtcbiAgICAgICAgfSBlbHNlIGlmIChpIDwgOSkge1xuICAgICAgICAgIF9tb2R1bGVzWzhdWzE1IC0gaSAtIDEgKyAxXSA9IG1vZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfbW9kdWxlc1s4XVsxNSAtIGkgLSAxXSA9IG1vZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBmaXhlZCBtb2R1bGVcbiAgICAgIF9tb2R1bGVzW19tb2R1bGVDb3VudCAtIDhdWzhdID0gKCF0ZXN0KTtcbiAgICB9O1xuXG4gICAgdmFyIG1hcERhdGEgPSBmdW5jdGlvbihkYXRhLCBtYXNrUGF0dGVybikge1xuXG4gICAgICB2YXIgaW5jID0gLTE7XG4gICAgICB2YXIgcm93ID0gX21vZHVsZUNvdW50IC0gMTtcbiAgICAgIHZhciBiaXRJbmRleCA9IDc7XG4gICAgICB2YXIgYnl0ZUluZGV4ID0gMDtcbiAgICAgIHZhciBtYXNrRnVuYyA9IFFSVXRpbC5nZXRNYXNrRnVuY3Rpb24obWFza1BhdHRlcm4pO1xuXG4gICAgICBmb3IgKHZhciBjb2wgPSBfbW9kdWxlQ291bnQgLSAxOyBjb2wgPiAwOyBjb2wgLT0gMikge1xuXG4gICAgICAgIGlmIChjb2wgPT0gNikgY29sIC09IDE7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcblxuICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgMjsgYyArPSAxKSB7XG5cbiAgICAgICAgICAgIGlmIChfbW9kdWxlc1tyb3ddW2NvbCAtIGNdID09IG51bGwpIHtcblxuICAgICAgICAgICAgICB2YXIgZGFyayA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIGlmIChieXRlSW5kZXggPCBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRhcmsgPSAoICggKGRhdGFbYnl0ZUluZGV4XSA+Pj4gYml0SW5kZXgpICYgMSkgPT0gMSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgbWFzayA9IG1hc2tGdW5jKHJvdywgY29sIC0gYyk7XG5cbiAgICAgICAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgICAgICBkYXJrID0gIWRhcms7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfbW9kdWxlc1tyb3ddW2NvbCAtIGNdID0gZGFyaztcbiAgICAgICAgICAgICAgYml0SW5kZXggLT0gMTtcblxuICAgICAgICAgICAgICBpZiAoYml0SW5kZXggPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBieXRlSW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICBiaXRJbmRleCA9IDc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3cgKz0gaW5jO1xuXG4gICAgICAgICAgaWYgKHJvdyA8IDAgfHwgX21vZHVsZUNvdW50IDw9IHJvdykge1xuICAgICAgICAgICAgcm93IC09IGluYztcbiAgICAgICAgICAgIGluYyA9IC1pbmM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUJ5dGVzID0gZnVuY3Rpb24oYnVmZmVyLCByc0Jsb2Nrcykge1xuXG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgICAgdmFyIG1heERjQ291bnQgPSAwO1xuICAgICAgdmFyIG1heEVjQ291bnQgPSAwO1xuXG4gICAgICB2YXIgZGNkYXRhID0gbmV3IEFycmF5KHJzQmxvY2tzLmxlbmd0aCk7XG4gICAgICB2YXIgZWNkYXRhID0gbmV3IEFycmF5KHJzQmxvY2tzLmxlbmd0aCk7XG5cbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcnNCbG9ja3MubGVuZ3RoOyByICs9IDEpIHtcblxuICAgICAgICB2YXIgZGNDb3VudCA9IHJzQmxvY2tzW3JdLmRhdGFDb3VudDtcbiAgICAgICAgdmFyIGVjQ291bnQgPSByc0Jsb2Nrc1tyXS50b3RhbENvdW50IC0gZGNDb3VudDtcblxuICAgICAgICBtYXhEY0NvdW50ID0gTWF0aC5tYXgobWF4RGNDb3VudCwgZGNDb3VudCk7XG4gICAgICAgIG1heEVjQ291bnQgPSBNYXRoLm1heChtYXhFY0NvdW50LCBlY0NvdW50KTtcblxuICAgICAgICBkY2RhdGFbcl0gPSBuZXcgQXJyYXkoZGNDb3VudCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkY2RhdGFbcl0ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBkY2RhdGFbcl1baV0gPSAweGZmICYgYnVmZmVyLmdldEJ1ZmZlcigpW2kgKyBvZmZzZXRdO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBkY0NvdW50O1xuXG4gICAgICAgIHZhciByc1BvbHkgPSBRUlV0aWwuZ2V0RXJyb3JDb3JyZWN0UG9seW5vbWlhbChlY0NvdW50KTtcbiAgICAgICAgdmFyIHJhd1BvbHkgPSBxclBvbHlub21pYWwoZGNkYXRhW3JdLCByc1BvbHkuZ2V0TGVuZ3RoKCkgLSAxKTtcblxuICAgICAgICB2YXIgbW9kUG9seSA9IHJhd1BvbHkubW9kKHJzUG9seSk7XG4gICAgICAgIGVjZGF0YVtyXSA9IG5ldyBBcnJheShyc1BvbHkuZ2V0TGVuZ3RoKCkgLSAxKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlY2RhdGFbcl0ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICB2YXIgbW9kSW5kZXggPSBpICsgbW9kUG9seS5nZXRMZW5ndGgoKSAtIGVjZGF0YVtyXS5sZW5ndGg7XG4gICAgICAgICAgZWNkYXRhW3JdW2ldID0gKG1vZEluZGV4ID49IDApPyBtb2RQb2x5LmdldEF0KG1vZEluZGV4KSA6IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRvdGFsQ29kZUNvdW50ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnNCbG9ja3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdG90YWxDb2RlQ291bnQgKz0gcnNCbG9ja3NbaV0udG90YWxDb3VudDtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGEgPSBuZXcgQXJyYXkodG90YWxDb2RlQ291bnQpO1xuICAgICAgdmFyIGluZGV4ID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhEY0NvdW50OyBpICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCByc0Jsb2Nrcy5sZW5ndGg7IHIgKz0gMSkge1xuICAgICAgICAgIGlmIChpIDwgZGNkYXRhW3JdLmxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YVtpbmRleF0gPSBkY2RhdGFbcl1baV07XG4gICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heEVjQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHJzQmxvY2tzLmxlbmd0aDsgciArPSAxKSB7XG4gICAgICAgICAgaWYgKGkgPCBlY2RhdGFbcl0ubGVuZ3RoKSB7XG4gICAgICAgICAgICBkYXRhW2luZGV4XSA9IGVjZGF0YVtyXVtpXTtcbiAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRGF0YSA9IGZ1bmN0aW9uKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdGlvbkxldmVsLCBkYXRhTGlzdCkge1xuXG4gICAgICB2YXIgcnNCbG9ja3MgPSBRUlJTQmxvY2suZ2V0UlNCbG9ja3ModHlwZU51bWJlciwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpO1xuXG4gICAgICB2YXIgYnVmZmVyID0gcXJCaXRCdWZmZXIoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhTGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZGF0YSA9IGRhdGFMaXN0W2ldO1xuICAgICAgICBidWZmZXIucHV0KGRhdGEuZ2V0TW9kZSgpLCA0KTtcbiAgICAgICAgYnVmZmVyLnB1dChkYXRhLmdldExlbmd0aCgpLCBRUlV0aWwuZ2V0TGVuZ3RoSW5CaXRzKGRhdGEuZ2V0TW9kZSgpLCB0eXBlTnVtYmVyKSApO1xuICAgICAgICBkYXRhLndyaXRlKGJ1ZmZlcik7XG4gICAgICB9XG5cbiAgICAgIC8vIGNhbGMgbnVtIG1heCBkYXRhLlxuICAgICAgdmFyIHRvdGFsRGF0YUNvdW50ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnNCbG9ja3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdG90YWxEYXRhQ291bnQgKz0gcnNCbG9ja3NbaV0uZGF0YUNvdW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpID4gdG90YWxEYXRhQ291bnQgKiA4KSB7XG4gICAgICAgIHRocm93ICdjb2RlIGxlbmd0aCBvdmVyZmxvdy4gKCdcbiAgICAgICAgICArIGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKVxuICAgICAgICAgICsgJz4nXG4gICAgICAgICAgKyB0b3RhbERhdGFDb3VudCAqIDhcbiAgICAgICAgICArICcpJztcbiAgICAgIH1cblxuICAgICAgLy8gZW5kIGNvZGVcbiAgICAgIGlmIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgKyA0IDw9IHRvdGFsRGF0YUNvdW50ICogOCkge1xuICAgICAgICBidWZmZXIucHV0KDAsIDQpO1xuICAgICAgfVxuXG4gICAgICAvLyBwYWRkaW5nXG4gICAgICB3aGlsZSAoYnVmZmVyLmdldExlbmd0aEluQml0cygpICUgOCAhPSAwKSB7XG4gICAgICAgIGJ1ZmZlci5wdXRCaXQoZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBwYWRkaW5nXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuXG4gICAgICAgIGlmIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgPj0gdG90YWxEYXRhQ291bnQgKiA4KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyLnB1dChQQUQwLCA4KTtcblxuICAgICAgICBpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpID49IHRvdGFsRGF0YUNvdW50ICogOCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5wdXQoUEFEMSwgOCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmVhdGVCeXRlcyhidWZmZXIsIHJzQmxvY2tzKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuYWRkRGF0YSA9IGZ1bmN0aW9uKGRhdGEsIG1vZGUpIHtcblxuICAgICAgbW9kZSA9IG1vZGUgfHwgJ0J5dGUnO1xuXG4gICAgICB2YXIgbmV3RGF0YSA9IG51bGw7XG5cbiAgICAgIHN3aXRjaChtb2RlKSB7XG4gICAgICBjYXNlICdOdW1lcmljJyA6XG4gICAgICAgIG5ld0RhdGEgPSBxck51bWJlcihkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBbHBoYW51bWVyaWMnIDpcbiAgICAgICAgbmV3RGF0YSA9IHFyQWxwaGFOdW0oZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQnl0ZScgOlxuICAgICAgICBuZXdEYXRhID0gcXI4Qml0Qnl0ZShkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdLYW5qaScgOlxuICAgICAgICBuZXdEYXRhID0gcXJLYW5qaShkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0IDpcbiAgICAgICAgdGhyb3cgJ21vZGU6JyArIG1vZGU7XG4gICAgICB9XG5cbiAgICAgIF9kYXRhTGlzdC5wdXNoKG5ld0RhdGEpO1xuICAgICAgX2RhdGFDYWNoZSA9IG51bGw7XG4gICAgfTtcblxuICAgIF90aGlzLmlzRGFyayA9IGZ1bmN0aW9uKHJvdywgY29sKSB7XG4gICAgICBpZiAocm93IDwgMCB8fCBfbW9kdWxlQ291bnQgPD0gcm93IHx8IGNvbCA8IDAgfHwgX21vZHVsZUNvdW50IDw9IGNvbCkge1xuICAgICAgICB0aHJvdyByb3cgKyAnLCcgKyBjb2w7XG4gICAgICB9XG4gICAgICByZXR1cm4gX21vZHVsZXNbcm93XVtjb2xdO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRNb2R1bGVDb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF9tb2R1bGVDb3VudDtcbiAgICB9O1xuXG4gICAgX3RoaXMubWFrZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKF90eXBlTnVtYmVyIDwgMSkge1xuICAgICAgICB2YXIgdHlwZU51bWJlciA9IDE7XG5cbiAgICAgICAgZm9yICg7IHR5cGVOdW1iZXIgPCA0MDsgdHlwZU51bWJlcisrKSB7XG4gICAgICAgICAgdmFyIHJzQmxvY2tzID0gUVJSU0Jsb2NrLmdldFJTQmxvY2tzKHR5cGVOdW1iZXIsIF9lcnJvckNvcnJlY3Rpb25MZXZlbCk7XG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IHFyQml0QnVmZmVyKCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9kYXRhTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBfZGF0YUxpc3RbaV07XG4gICAgICAgICAgICBidWZmZXIucHV0KGRhdGEuZ2V0TW9kZSgpLCA0KTtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXQoZGF0YS5nZXRMZW5ndGgoKSwgUVJVdGlsLmdldExlbmd0aEluQml0cyhkYXRhLmdldE1vZGUoKSwgdHlwZU51bWJlcikgKTtcbiAgICAgICAgICAgIGRhdGEud3JpdGUoYnVmZmVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdG90YWxEYXRhQ291bnQgPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnNCbG9ja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRvdGFsRGF0YUNvdW50ICs9IHJzQmxvY2tzW2ldLmRhdGFDb3VudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpIDw9IHRvdGFsRGF0YUNvdW50ICogOCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3R5cGVOdW1iZXIgPSB0eXBlTnVtYmVyO1xuICAgICAgfVxuXG4gICAgICBtYWtlSW1wbChmYWxzZSwgZ2V0QmVzdE1hc2tQYXR0ZXJuKCkgKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuY3JlYXRlVGFibGVUYWcgPSBmdW5jdGlvbihjZWxsU2l6ZSwgbWFyZ2luKSB7XG5cbiAgICAgIGNlbGxTaXplID0gY2VsbFNpemUgfHwgMjtcbiAgICAgIG1hcmdpbiA9ICh0eXBlb2YgbWFyZ2luID09ICd1bmRlZmluZWQnKT8gY2VsbFNpemUgKiA0IDogbWFyZ2luO1xuXG4gICAgICB2YXIgcXJIdG1sID0gJyc7XG5cbiAgICAgIHFySHRtbCArPSAnPHRhYmxlIHN0eWxlPVwiJztcbiAgICAgIHFySHRtbCArPSAnIGJvcmRlci13aWR0aDogMHB4OyBib3JkZXItc3R5bGU6IG5vbmU7JztcbiAgICAgIHFySHRtbCArPSAnIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7JztcbiAgICAgIHFySHRtbCArPSAnIHBhZGRpbmc6IDBweDsgbWFyZ2luOiAnICsgbWFyZ2luICsgJ3B4Oyc7XG4gICAgICBxckh0bWwgKz0gJ1wiPic7XG4gICAgICBxckh0bWwgKz0gJzx0Ym9keT4nO1xuXG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IF90aGlzLmdldE1vZHVsZUNvdW50KCk7IHIgKz0gMSkge1xuXG4gICAgICAgIHFySHRtbCArPSAnPHRyPic7XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBfdGhpcy5nZXRNb2R1bGVDb3VudCgpOyBjICs9IDEpIHtcbiAgICAgICAgICBxckh0bWwgKz0gJzx0ZCBzdHlsZT1cIic7XG4gICAgICAgICAgcXJIdG1sICs9ICcgYm9yZGVyLXdpZHRoOiAwcHg7IGJvcmRlci1zdHlsZTogbm9uZTsnO1xuICAgICAgICAgIHFySHRtbCArPSAnIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7JztcbiAgICAgICAgICBxckh0bWwgKz0gJyBwYWRkaW5nOiAwcHg7IG1hcmdpbjogMHB4Oyc7XG4gICAgICAgICAgcXJIdG1sICs9ICcgd2lkdGg6ICcgKyBjZWxsU2l6ZSArICdweDsnO1xuICAgICAgICAgIHFySHRtbCArPSAnIGhlaWdodDogJyArIGNlbGxTaXplICsgJ3B4Oyc7XG4gICAgICAgICAgcXJIdG1sICs9ICcgYmFja2dyb3VuZC1jb2xvcjogJztcbiAgICAgICAgICBxckh0bWwgKz0gX3RoaXMuaXNEYXJrKHIsIGMpPyAnIzAwMDAwMCcgOiAnI2ZmZmZmZic7XG4gICAgICAgICAgcXJIdG1sICs9ICc7JztcbiAgICAgICAgICBxckh0bWwgKz0gJ1wiLz4nO1xuICAgICAgICB9XG5cbiAgICAgICAgcXJIdG1sICs9ICc8L3RyPic7XG4gICAgICB9XG5cbiAgICAgIHFySHRtbCArPSAnPC90Ym9keT4nO1xuICAgICAgcXJIdG1sICs9ICc8L3RhYmxlPic7XG5cbiAgICAgIHJldHVybiBxckh0bWw7XG4gICAgfTtcblxuICAgIF90aGlzLmNyZWF0ZVN2Z1RhZyA9IGZ1bmN0aW9uKGNlbGxTaXplLCBtYXJnaW4pIHtcblxuICAgICAgY2VsbFNpemUgPSBjZWxsU2l6ZSB8fCAyO1xuICAgICAgbWFyZ2luID0gKHR5cGVvZiBtYXJnaW4gPT0gJ3VuZGVmaW5lZCcpPyBjZWxsU2l6ZSAqIDQgOiBtYXJnaW47XG4gICAgICB2YXIgc2l6ZSA9IF90aGlzLmdldE1vZHVsZUNvdW50KCkgKiBjZWxsU2l6ZSArIG1hcmdpbiAqIDI7XG4gICAgICB2YXIgYywgbWMsIHIsIG1yLCBxclN2Zz0nJywgcmVjdDtcblxuICAgICAgcmVjdCA9ICdsJyArIGNlbGxTaXplICsgJywwIDAsJyArIGNlbGxTaXplICtcbiAgICAgICAgJyAtJyArIGNlbGxTaXplICsgJywwIDAsLScgKyBjZWxsU2l6ZSArICd6ICc7XG5cbiAgICAgIHFyU3ZnICs9ICc8c3ZnIHZlcnNpb249XCIxLjFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCInO1xuICAgICAgcXJTdmcgKz0gJyB3aWR0aD1cIicgKyBzaXplICsgJ3B4XCInO1xuICAgICAgcXJTdmcgKz0gJyBoZWlnaHQ9XCInICsgc2l6ZSArICdweFwiJztcbiAgICAgIHFyU3ZnICs9ICcgdmlld0JveD1cIjAgMCAnICsgc2l6ZSArICcgJyArIHNpemUgKyAnXCIgJztcbiAgICAgIHFyU3ZnICs9ICcgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaW5ZTWluIG1lZXRcIj4nO1xuICAgICAgcXJTdmcgKz0gJzxyZWN0IHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiBmaWxsPVwid2hpdGVcIiBjeD1cIjBcIiBjeT1cIjBcIi8+JztcbiAgICAgIHFyU3ZnICs9ICc8cGF0aCBkPVwiJztcblxuICAgICAgZm9yIChyID0gMDsgciA8IF90aGlzLmdldE1vZHVsZUNvdW50KCk7IHIgKz0gMSkge1xuICAgICAgICBtciA9IHIgKiBjZWxsU2l6ZSArIG1hcmdpbjtcbiAgICAgICAgZm9yIChjID0gMDsgYyA8IF90aGlzLmdldE1vZHVsZUNvdW50KCk7IGMgKz0gMSkge1xuICAgICAgICAgIGlmIChfdGhpcy5pc0RhcmsociwgYykgKSB7XG4gICAgICAgICAgICBtYyA9IGMqY2VsbFNpemUrbWFyZ2luO1xuICAgICAgICAgICAgcXJTdmcgKz0gJ00nICsgbWMgKyAnLCcgKyBtciArIHJlY3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHFyU3ZnICs9ICdcIiBzdHJva2U9XCJ0cmFuc3BhcmVudFwiIGZpbGw9XCJibGFja1wiLz4nO1xuICAgICAgcXJTdmcgKz0gJzwvc3ZnPic7XG5cbiAgICAgIHJldHVybiBxclN2ZztcbiAgICB9O1xuXG4gICAgX3RoaXMuY3JlYXRlRGF0YVVSTCA9IGZ1bmN0aW9uKGNlbGxTaXplLCBtYXJnaW4pIHtcblxuICAgICAgY2VsbFNpemUgPSBjZWxsU2l6ZSB8fCAyO1xuICAgICAgbWFyZ2luID0gKHR5cGVvZiBtYXJnaW4gPT0gJ3VuZGVmaW5lZCcpPyBjZWxsU2l6ZSAqIDQgOiBtYXJnaW47XG5cbiAgICAgIHZhciBzaXplID0gX3RoaXMuZ2V0TW9kdWxlQ291bnQoKSAqIGNlbGxTaXplICsgbWFyZ2luICogMjtcbiAgICAgIHZhciBtaW4gPSBtYXJnaW47XG4gICAgICB2YXIgbWF4ID0gc2l6ZSAtIG1hcmdpbjtcblxuICAgICAgcmV0dXJuIGNyZWF0ZURhdGFVUkwoc2l6ZSwgc2l6ZSwgZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBpZiAobWluIDw9IHggJiYgeCA8IG1heCAmJiBtaW4gPD0geSAmJiB5IDwgbWF4KSB7XG4gICAgICAgICAgdmFyIGMgPSBNYXRoLmZsb29yKCAoeCAtIG1pbikgLyBjZWxsU2l6ZSk7XG4gICAgICAgICAgdmFyIHIgPSBNYXRoLmZsb29yKCAoeSAtIG1pbikgLyBjZWxsU2l6ZSk7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmlzRGFyayhyLCBjKT8gMCA6IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH0gKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuY3JlYXRlSW1nVGFnID0gZnVuY3Rpb24oY2VsbFNpemUsIG1hcmdpbiwgYWx0KSB7XG5cbiAgICAgIGNlbGxTaXplID0gY2VsbFNpemUgfHwgMjtcbiAgICAgIG1hcmdpbiA9ICh0eXBlb2YgbWFyZ2luID09ICd1bmRlZmluZWQnKT8gY2VsbFNpemUgKiA0IDogbWFyZ2luO1xuXG4gICAgICB2YXIgc2l6ZSA9IF90aGlzLmdldE1vZHVsZUNvdW50KCkgKiBjZWxsU2l6ZSArIG1hcmdpbiAqIDI7XG5cbiAgICAgIHZhciBpbWcgPSAnJztcbiAgICAgIGltZyArPSAnPGltZyc7XG4gICAgICBpbWcgKz0gJ1xcdTAwMjBzcmM9XCInO1xuICAgICAgaW1nICs9IF90aGlzLmNyZWF0ZURhdGFVUkwoY2VsbFNpemUsIG1hcmdpbik7XG4gICAgICBpbWcgKz0gJ1wiJztcbiAgICAgIGltZyArPSAnXFx1MDAyMHdpZHRoPVwiJztcbiAgICAgIGltZyArPSBzaXplO1xuICAgICAgaW1nICs9ICdcIic7XG4gICAgICBpbWcgKz0gJ1xcdTAwMjBoZWlnaHQ9XCInO1xuICAgICAgaW1nICs9IHNpemU7XG4gICAgICBpbWcgKz0gJ1wiJztcbiAgICAgIGlmIChhbHQpIHtcbiAgICAgICAgaW1nICs9ICdcXHUwMDIwYWx0PVwiJztcbiAgICAgICAgaW1nICs9IGFsdDtcbiAgICAgICAgaW1nICs9ICdcIic7XG4gICAgICB9XG4gICAgICBpbWcgKz0gJy8+JztcblxuICAgICAgcmV0dXJuIGltZztcbiAgICB9O1xuXG4gICAgdmFyIF9jcmVhdGVIYWxmQVNDSUkgPSBmdW5jdGlvbihtYXJnaW4pIHtcbiAgICAgIHZhciBjZWxsU2l6ZSA9IDE7XG4gICAgICBtYXJnaW4gPSAodHlwZW9mIG1hcmdpbiA9PSAndW5kZWZpbmVkJyk/IGNlbGxTaXplICogMiA6IG1hcmdpbjtcblxuICAgICAgdmFyIHNpemUgPSBfdGhpcy5nZXRNb2R1bGVDb3VudCgpICogY2VsbFNpemUgKyBtYXJnaW4gKiAyO1xuICAgICAgdmFyIG1pbiA9IG1hcmdpbjtcbiAgICAgIHZhciBtYXggPSBzaXplIC0gbWFyZ2luO1xuXG4gICAgICB2YXIgeSwgeCwgcjEsIHIyLCBwO1xuXG4gICAgICB2YXIgYmxvY2tzID0ge1xuICAgICAgICAn4paI4paIJzogJ+KWiCcsXG4gICAgICAgICfiloggJzogJ+KWgCcsXG4gICAgICAgICcg4paIJzogJ+KWhCcsXG4gICAgICAgICcgICc6ICcgJ1xuICAgICAgfTtcblxuICAgICAgdmFyIGFzY2lpID0gJyc7XG4gICAgICBmb3IgKHkgPSAwOyB5IDwgc2l6ZTsgeSArPSAyKSB7XG4gICAgICAgIHIxID0gTWF0aC5mbG9vcigoeSAtIG1pbikgLyBjZWxsU2l6ZSk7XG4gICAgICAgIHIyID0gTWF0aC5mbG9vcigoeSArIDEgLSBtaW4pIC8gY2VsbFNpemUpO1xuICAgICAgICBmb3IgKHggPSAwOyB4IDwgc2l6ZTsgeCArPSAxKSB7XG4gICAgICAgICAgcCA9ICfilognO1xuXG4gICAgICAgICAgaWYgKG1pbiA8PSB4ICYmIHggPCBtYXggJiYgbWluIDw9IHkgJiYgeSA8IG1heCAmJiBfdGhpcy5pc0RhcmsocjEsIE1hdGguZmxvb3IoKHggLSBtaW4pIC8gY2VsbFNpemUpKSkge1xuICAgICAgICAgICAgcCA9ICcgJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWluIDw9IHggJiYgeCA8IG1heCAmJiBtaW4gPD0geSsxICYmIHkrMSA8IG1heCAmJiBfdGhpcy5pc0RhcmsocjIsIE1hdGguZmxvb3IoKHggLSBtaW4pIC8gY2VsbFNpemUpKSkge1xuICAgICAgICAgICAgcCArPSAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcCArPSAn4paIJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBPdXRwdXQgMiBjaGFyYWN0ZXJzIHBlciBwaXhlbCwgdG8gY3JlYXRlIGZ1bGwgc3F1YXJlLiAxIGNoYXJhY3RlciBwZXIgcGl4ZWxzIGdpdmVzIG9ubHkgaGFsZiB3aWR0aCBvZiBzcXVhcmUuXG4gICAgICAgICAgYXNjaWkgKz0gYmxvY2tzW3BdO1xuICAgICAgICB9XG5cbiAgICAgICAgYXNjaWkgKz0gJ1xcbic7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaXplICUgMikge1xuICAgICAgICByZXR1cm4gYXNjaWkuc3Vic3RyaW5nKDAsIGFzY2lpLmxlbmd0aCAtIHNpemUgLSAxKSArIEFycmF5KHNpemUrMSkuam9pbign4paAJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhc2NpaS5zdWJzdHJpbmcoMCwgYXNjaWkubGVuZ3RoLTEpO1xuICAgIH07XG5cbiAgICBfdGhpcy5jcmVhdGVBU0NJSSA9IGZ1bmN0aW9uKGNlbGxTaXplLCBtYXJnaW4pIHtcbiAgICAgIGNlbGxTaXplID0gY2VsbFNpemUgfHwgMTtcblxuICAgICAgaWYgKGNlbGxTaXplIDwgMikge1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUhhbGZBU0NJSShtYXJnaW4pO1xuICAgICAgfVxuXG4gICAgICBjZWxsU2l6ZSAtPSAxO1xuICAgICAgbWFyZ2luID0gKHR5cGVvZiBtYXJnaW4gPT0gJ3VuZGVmaW5lZCcpPyBjZWxsU2l6ZSAqIDIgOiBtYXJnaW47XG5cbiAgICAgIHZhciBzaXplID0gX3RoaXMuZ2V0TW9kdWxlQ291bnQoKSAqIGNlbGxTaXplICsgbWFyZ2luICogMjtcbiAgICAgIHZhciBtaW4gPSBtYXJnaW47XG4gICAgICB2YXIgbWF4ID0gc2l6ZSAtIG1hcmdpbjtcblxuICAgICAgdmFyIHksIHgsIHIsIHA7XG5cbiAgICAgIHZhciB3aGl0ZSA9IEFycmF5KGNlbGxTaXplKzEpLmpvaW4oJ+KWiOKWiCcpO1xuICAgICAgdmFyIGJsYWNrID0gQXJyYXkoY2VsbFNpemUrMSkuam9pbignICAnKTtcblxuICAgICAgdmFyIGFzY2lpID0gJyc7XG4gICAgICB2YXIgbGluZSA9ICcnO1xuICAgICAgZm9yICh5ID0gMDsgeSA8IHNpemU7IHkgKz0gMSkge1xuICAgICAgICByID0gTWF0aC5mbG9vciggKHkgLSBtaW4pIC8gY2VsbFNpemUpO1xuICAgICAgICBsaW5lID0gJyc7XG4gICAgICAgIGZvciAoeCA9IDA7IHggPCBzaXplOyB4ICs9IDEpIHtcbiAgICAgICAgICBwID0gMTtcblxuICAgICAgICAgIGlmIChtaW4gPD0geCAmJiB4IDwgbWF4ICYmIG1pbiA8PSB5ICYmIHkgPCBtYXggJiYgX3RoaXMuaXNEYXJrKHIsIE1hdGguZmxvb3IoKHggLSBtaW4pIC8gY2VsbFNpemUpKSkge1xuICAgICAgICAgICAgcCA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gT3V0cHV0IDIgY2hhcmFjdGVycyBwZXIgcGl4ZWwsIHRvIGNyZWF0ZSBmdWxsIHNxdWFyZS4gMSBjaGFyYWN0ZXIgcGVyIHBpeGVscyBnaXZlcyBvbmx5IGhhbGYgd2lkdGggb2Ygc3F1YXJlLlxuICAgICAgICAgIGxpbmUgKz0gcCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHIgPSAwOyByIDwgY2VsbFNpemU7IHIgKz0gMSkge1xuICAgICAgICAgIGFzY2lpICs9IGxpbmUgKyAnXFxuJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXNjaWkuc3Vic3RyaW5nKDAsIGFzY2lpLmxlbmd0aC0xKTtcbiAgICB9O1xuXG4gICAgX3RoaXMucmVuZGVyVG8yZENvbnRleHQgPSBmdW5jdGlvbihjb250ZXh0LCBjZWxsU2l6ZSkge1xuICAgICAgY2VsbFNpemUgPSBjZWxsU2l6ZSB8fCAyO1xuICAgICAgdmFyIGxlbmd0aCA9IF90aGlzLmdldE1vZHVsZUNvdW50KCk7XG4gICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBsZW5ndGg7IHJvdysrKSB7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGxlbmd0aDsgY29sKyspIHtcbiAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IF90aGlzLmlzRGFyayhyb3csIGNvbCkgPyAnYmxhY2snIDogJ3doaXRlJztcbiAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHJvdyAqIGNlbGxTaXplLCBjb2wgKiBjZWxsU2l6ZSwgY2VsbFNpemUsIGNlbGxTaXplKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBxcmNvZGUuc3RyaW5nVG9CeXRlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHFyY29kZS5zdHJpbmdUb0J5dGVzRnVuY3MgPSB7XG4gICAgJ2RlZmF1bHQnIDogZnVuY3Rpb24ocykge1xuICAgICAgdmFyIGJ5dGVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGJ5dGVzLnB1c2goYyAmIDB4ZmYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgfTtcblxuICBxcmNvZGUuc3RyaW5nVG9CeXRlcyA9IHFyY29kZS5zdHJpbmdUb0J5dGVzRnVuY3NbJ2RlZmF1bHQnXTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBxcmNvZGUuY3JlYXRlU3RyaW5nVG9CeXRlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gdW5pY29kZURhdGEgYmFzZTY0IHN0cmluZyBvZiBieXRlIGFycmF5LlxuICAgKiBbMTZiaXQgVW5pY29kZV0sWzE2Yml0IEJ5dGVzXSwgLi4uXG4gICAqIEBwYXJhbSBudW1DaGFyc1xuICAgKi9cbiAgcXJjb2RlLmNyZWF0ZVN0cmluZ1RvQnl0ZXMgPSBmdW5jdGlvbih1bmljb2RlRGF0YSwgbnVtQ2hhcnMpIHtcblxuICAgIC8vIGNyZWF0ZSBjb252ZXJzaW9uIG1hcC5cblxuICAgIHZhciB1bmljb2RlTWFwID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBiaW4gPSBiYXNlNjREZWNvZGVJbnB1dFN0cmVhbSh1bmljb2RlRGF0YSk7XG4gICAgICB2YXIgcmVhZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYiA9IGJpbi5yZWFkKCk7XG4gICAgICAgIGlmIChiID09IC0xKSB0aHJvdyAnZW9mJztcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9O1xuXG4gICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgdmFyIHVuaWNvZGVNYXAgPSB7fTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBiMCA9IGJpbi5yZWFkKCk7XG4gICAgICAgIGlmIChiMCA9PSAtMSkgYnJlYWs7XG4gICAgICAgIHZhciBiMSA9IHJlYWQoKTtcbiAgICAgICAgdmFyIGIyID0gcmVhZCgpO1xuICAgICAgICB2YXIgYjMgPSByZWFkKCk7XG4gICAgICAgIHZhciBrID0gU3RyaW5nLmZyb21DaGFyQ29kZSggKGIwIDw8IDgpIHwgYjEpO1xuICAgICAgICB2YXIgdiA9IChiMiA8PCA4KSB8IGIzO1xuICAgICAgICB1bmljb2RlTWFwW2tdID0gdjtcbiAgICAgICAgY291bnQgKz0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChjb3VudCAhPSBudW1DaGFycykge1xuICAgICAgICB0aHJvdyBjb3VudCArICcgIT0gJyArIG51bUNoYXJzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5pY29kZU1hcDtcbiAgICB9KCk7XG5cbiAgICB2YXIgdW5rbm93bkNoYXIgPSAnPycuY2hhckNvZGVBdCgwKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihzKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICBieXRlcy5wdXNoKGMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBiID0gdW5pY29kZU1hcFtzLmNoYXJBdChpKV07XG4gICAgICAgICAgaWYgKHR5cGVvZiBiID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAoIChiICYgMHhmZikgPT0gYikge1xuICAgICAgICAgICAgICAvLyAxYnl0ZVxuICAgICAgICAgICAgICBieXRlcy5wdXNoKGIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gMmJ5dGVzXG4gICAgICAgICAgICAgIGJ5dGVzLnB1c2goYiA+Pj4gOCk7XG4gICAgICAgICAgICAgIGJ5dGVzLnB1c2goYiAmIDB4ZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKHVua25vd25DaGFyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9O1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFFSTW9kZVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBRUk1vZGUgPSB7XG4gICAgTU9ERV9OVU1CRVIgOiAgICAxIDw8IDAsXG4gICAgTU9ERV9BTFBIQV9OVU0gOiAxIDw8IDEsXG4gICAgTU9ERV84QklUX0JZVEUgOiAxIDw8IDIsXG4gICAgTU9ERV9LQU5KSSA6ICAgICAxIDw8IDNcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBRUkVycm9yQ29ycmVjdGlvbkxldmVsXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIFFSRXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSB7XG4gICAgTCA6IDEsXG4gICAgTSA6IDAsXG4gICAgUSA6IDMsXG4gICAgSCA6IDJcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBRUk1hc2tQYXR0ZXJuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIFFSTWFza1BhdHRlcm4gPSB7XG4gICAgUEFUVEVSTjAwMCA6IDAsXG4gICAgUEFUVEVSTjAwMSA6IDEsXG4gICAgUEFUVEVSTjAxMCA6IDIsXG4gICAgUEFUVEVSTjAxMSA6IDMsXG4gICAgUEFUVEVSTjEwMCA6IDQsXG4gICAgUEFUVEVSTjEwMSA6IDUsXG4gICAgUEFUVEVSTjExMCA6IDYsXG4gICAgUEFUVEVSTjExMSA6IDdcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBRUlV0aWxcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgUVJVdGlsID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgUEFUVEVSTl9QT1NJVElPTl9UQUJMRSA9IFtcbiAgICAgIFtdLFxuICAgICAgWzYsIDE4XSxcbiAgICAgIFs2LCAyMl0sXG4gICAgICBbNiwgMjZdLFxuICAgICAgWzYsIDMwXSxcbiAgICAgIFs2LCAzNF0sXG4gICAgICBbNiwgMjIsIDM4XSxcbiAgICAgIFs2LCAyNCwgNDJdLFxuICAgICAgWzYsIDI2LCA0Nl0sXG4gICAgICBbNiwgMjgsIDUwXSxcbiAgICAgIFs2LCAzMCwgNTRdLFxuICAgICAgWzYsIDMyLCA1OF0sXG4gICAgICBbNiwgMzQsIDYyXSxcbiAgICAgIFs2LCAyNiwgNDYsIDY2XSxcbiAgICAgIFs2LCAyNiwgNDgsIDcwXSxcbiAgICAgIFs2LCAyNiwgNTAsIDc0XSxcbiAgICAgIFs2LCAzMCwgNTQsIDc4XSxcbiAgICAgIFs2LCAzMCwgNTYsIDgyXSxcbiAgICAgIFs2LCAzMCwgNTgsIDg2XSxcbiAgICAgIFs2LCAzNCwgNjIsIDkwXSxcbiAgICAgIFs2LCAyOCwgNTAsIDcyLCA5NF0sXG4gICAgICBbNiwgMjYsIDUwLCA3NCwgOThdLFxuICAgICAgWzYsIDMwLCA1NCwgNzgsIDEwMl0sXG4gICAgICBbNiwgMjgsIDU0LCA4MCwgMTA2XSxcbiAgICAgIFs2LCAzMiwgNTgsIDg0LCAxMTBdLFxuICAgICAgWzYsIDMwLCA1OCwgODYsIDExNF0sXG4gICAgICBbNiwgMzQsIDYyLCA5MCwgMTE4XSxcbiAgICAgIFs2LCAyNiwgNTAsIDc0LCA5OCwgMTIyXSxcbiAgICAgIFs2LCAzMCwgNTQsIDc4LCAxMDIsIDEyNl0sXG4gICAgICBbNiwgMjYsIDUyLCA3OCwgMTA0LCAxMzBdLFxuICAgICAgWzYsIDMwLCA1NiwgODIsIDEwOCwgMTM0XSxcbiAgICAgIFs2LCAzNCwgNjAsIDg2LCAxMTIsIDEzOF0sXG4gICAgICBbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDJdLFxuICAgICAgWzYsIDM0LCA2MiwgOTAsIDExOCwgMTQ2XSxcbiAgICAgIFs2LCAzMCwgNTQsIDc4LCAxMDIsIDEyNiwgMTUwXSxcbiAgICAgIFs2LCAyNCwgNTAsIDc2LCAxMDIsIDEyOCwgMTU0XSxcbiAgICAgIFs2LCAyOCwgNTQsIDgwLCAxMDYsIDEzMiwgMTU4XSxcbiAgICAgIFs2LCAzMiwgNTgsIDg0LCAxMTAsIDEzNiwgMTYyXSxcbiAgICAgIFs2LCAyNiwgNTQsIDgyLCAxMTAsIDEzOCwgMTY2XSxcbiAgICAgIFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0MiwgMTcwXVxuICAgIF07XG4gICAgdmFyIEcxNSA9ICgxIDw8IDEwKSB8ICgxIDw8IDgpIHwgKDEgPDwgNSkgfCAoMSA8PCA0KSB8ICgxIDw8IDIpIHwgKDEgPDwgMSkgfCAoMSA8PCAwKTtcbiAgICB2YXIgRzE4ID0gKDEgPDwgMTIpIHwgKDEgPDwgMTEpIHwgKDEgPDwgMTApIHwgKDEgPDwgOSkgfCAoMSA8PCA4KSB8ICgxIDw8IDUpIHwgKDEgPDwgMikgfCAoMSA8PCAwKTtcbiAgICB2YXIgRzE1X01BU0sgPSAoMSA8PCAxNCkgfCAoMSA8PCAxMikgfCAoMSA8PCAxMCkgfCAoMSA8PCA0KSB8ICgxIDw8IDEpO1xuXG4gICAgdmFyIF90aGlzID0ge307XG5cbiAgICB2YXIgZ2V0QkNIRGlnaXQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgZGlnaXQgPSAwO1xuICAgICAgd2hpbGUgKGRhdGEgIT0gMCkge1xuICAgICAgICBkaWdpdCArPSAxO1xuICAgICAgICBkYXRhID4+Pj0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaWdpdDtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0QkNIVHlwZUluZm8gPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgZCA9IGRhdGEgPDwgMTA7XG4gICAgICB3aGlsZSAoZ2V0QkNIRGlnaXQoZCkgLSBnZXRCQ0hEaWdpdChHMTUpID49IDApIHtcbiAgICAgICAgZCBePSAoRzE1IDw8IChnZXRCQ0hEaWdpdChkKSAtIGdldEJDSERpZ2l0KEcxNSkgKSApO1xuICAgICAgfVxuICAgICAgcmV0dXJuICggKGRhdGEgPDwgMTApIHwgZCkgXiBHMTVfTUFTSztcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0QkNIVHlwZU51bWJlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBkID0gZGF0YSA8PCAxMjtcbiAgICAgIHdoaWxlIChnZXRCQ0hEaWdpdChkKSAtIGdldEJDSERpZ2l0KEcxOCkgPj0gMCkge1xuICAgICAgICBkIF49IChHMTggPDwgKGdldEJDSERpZ2l0KGQpIC0gZ2V0QkNIRGlnaXQoRzE4KSApICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKGRhdGEgPDwgMTIpIHwgZDtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0UGF0dGVyblBvc2l0aW9uID0gZnVuY3Rpb24odHlwZU51bWJlcikge1xuICAgICAgcmV0dXJuIFBBVFRFUk5fUE9TSVRJT05fVEFCTEVbdHlwZU51bWJlciAtIDFdO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRNYXNrRnVuY3Rpb24gPSBmdW5jdGlvbihtYXNrUGF0dGVybikge1xuXG4gICAgICBzd2l0Y2ggKG1hc2tQYXR0ZXJuKSB7XG5cbiAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMDAwIDpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuIChpICsgaikgJSAyID09IDA7IH07XG4gICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjAwMSA6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihpLCBqKSB7IHJldHVybiBpICUgMiA9PSAwOyB9O1xuICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4wMTAgOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gaiAlIDMgPT0gMDsgfTtcbiAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMDExIDpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuIChpICsgaikgJSAzID09IDA7IH07XG4gICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjEwMCA6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihpLCBqKSB7IHJldHVybiAoTWF0aC5mbG9vcihpIC8gMikgKyBNYXRoLmZsb29yKGogLyAzKSApICUgMiA9PSAwOyB9O1xuICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4xMDEgOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gKGkgKiBqKSAlIDIgKyAoaSAqIGopICUgMyA9PSAwOyB9O1xuICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4xMTAgOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gKCAoaSAqIGopICUgMiArIChpICogaikgJSAzKSAlIDIgPT0gMDsgfTtcbiAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMTExIDpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuICggKGkgKiBqKSAlIDMgKyAoaSArIGopICUgMikgJSAyID09IDA7IH07XG5cbiAgICAgIGRlZmF1bHQgOlxuICAgICAgICB0aHJvdyAnYmFkIG1hc2tQYXR0ZXJuOicgKyBtYXNrUGF0dGVybjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0RXJyb3JDb3JyZWN0UG9seW5vbWlhbCA9IGZ1bmN0aW9uKGVycm9yQ29ycmVjdExlbmd0aCkge1xuICAgICAgdmFyIGEgPSBxclBvbHlub21pYWwoWzFdLCAwKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXJyb3JDb3JyZWN0TGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYSA9IGEubXVsdGlwbHkocXJQb2x5bm9taWFsKFsxLCBRUk1hdGguZ2V4cChpKV0sIDApICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0TGVuZ3RoSW5CaXRzID0gZnVuY3Rpb24obW9kZSwgdHlwZSkge1xuXG4gICAgICBpZiAoMSA8PSB0eXBlICYmIHR5cGUgPCAxMCkge1xuXG4gICAgICAgIC8vIDEgLSA5XG5cbiAgICAgICAgc3dpdGNoKG1vZGUpIHtcbiAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9OVU1CRVIgICAgOiByZXR1cm4gMTA7XG4gICAgICAgIGNhc2UgUVJNb2RlLk1PREVfQUxQSEFfTlVNIDogcmV0dXJuIDk7XG4gICAgICAgIGNhc2UgUVJNb2RlLk1PREVfOEJJVF9CWVRFIDogcmV0dXJuIDg7XG4gICAgICAgIGNhc2UgUVJNb2RlLk1PREVfS0FOSkkgICAgIDogcmV0dXJuIDg7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgIHRocm93ICdtb2RlOicgKyBtb2RlO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAodHlwZSA8IDI3KSB7XG5cbiAgICAgICAgLy8gMTAgLSAyNlxuXG4gICAgICAgIHN3aXRjaChtb2RlKSB7XG4gICAgICAgIGNhc2UgUVJNb2RlLk1PREVfTlVNQkVSICAgIDogcmV0dXJuIDEyO1xuICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX0FMUEhBX05VTSA6IHJldHVybiAxMTtcbiAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV84QklUX0JZVEUgOiByZXR1cm4gMTY7XG4gICAgICAgIGNhc2UgUVJNb2RlLk1PREVfS0FOSkkgICAgIDogcmV0dXJuIDEwO1xuICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICB0aHJvdyAnbW9kZTonICsgbW9kZTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPCA0MSkge1xuXG4gICAgICAgIC8vIDI3IC0gNDBcblxuICAgICAgICBzd2l0Y2gobW9kZSkge1xuICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX05VTUJFUiAgICA6IHJldHVybiAxNDtcbiAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9BTFBIQV9OVU0gOiByZXR1cm4gMTM7XG4gICAgICAgIGNhc2UgUVJNb2RlLk1PREVfOEJJVF9CWVRFIDogcmV0dXJuIDE2O1xuICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX0tBTkpJICAgICA6IHJldHVybiAxMjtcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgdGhyb3cgJ21vZGU6JyArIG1vZGU7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgJ3R5cGU6JyArIHR5cGU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmdldExvc3RQb2ludCA9IGZ1bmN0aW9uKHFyY29kZSkge1xuXG4gICAgICB2YXIgbW9kdWxlQ291bnQgPSBxcmNvZGUuZ2V0TW9kdWxlQ291bnQoKTtcblxuICAgICAgdmFyIGxvc3RQb2ludCA9IDA7XG5cbiAgICAgIC8vIExFVkVMMVxuXG4gICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudDsgcm93ICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQ7IGNvbCArPSAxKSB7XG5cbiAgICAgICAgICB2YXIgc2FtZUNvdW50ID0gMDtcbiAgICAgICAgICB2YXIgZGFyayA9IHFyY29kZS5pc0Rhcmsocm93LCBjb2wpO1xuXG4gICAgICAgICAgZm9yICh2YXIgciA9IC0xOyByIDw9IDE7IHIgKz0gMSkge1xuXG4gICAgICAgICAgICBpZiAocm93ICsgciA8IDAgfHwgbW9kdWxlQ291bnQgPD0gcm93ICsgcikge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgYyA9IC0xOyBjIDw9IDE7IGMgKz0gMSkge1xuXG4gICAgICAgICAgICAgIGlmIChjb2wgKyBjIDwgMCB8fCBtb2R1bGVDb3VudCA8PSBjb2wgKyBjKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAociA9PSAwICYmIGMgPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGRhcmsgPT0gcXJjb2RlLmlzRGFyayhyb3cgKyByLCBjb2wgKyBjKSApIHtcbiAgICAgICAgICAgICAgICBzYW1lQ291bnQgKz0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzYW1lQ291bnQgPiA1KSB7XG4gICAgICAgICAgICBsb3N0UG9pbnQgKz0gKDMgKyBzYW1lQ291bnQgLSA1KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIExFVkVMMlxuXG4gICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudCAtIDE7IHJvdyArPSAxKSB7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50IC0gMTsgY29sICs9IDEpIHtcbiAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgIGlmIChxcmNvZGUuaXNEYXJrKHJvdywgY29sKSApIGNvdW50ICs9IDE7XG4gICAgICAgICAgaWYgKHFyY29kZS5pc0Rhcmsocm93ICsgMSwgY29sKSApIGNvdW50ICs9IDE7XG4gICAgICAgICAgaWYgKHFyY29kZS5pc0Rhcmsocm93LCBjb2wgKyAxKSApIGNvdW50ICs9IDE7XG4gICAgICAgICAgaWYgKHFyY29kZS5pc0Rhcmsocm93ICsgMSwgY29sICsgMSkgKSBjb3VudCArPSAxO1xuICAgICAgICAgIGlmIChjb3VudCA9PSAwIHx8IGNvdW50ID09IDQpIHtcbiAgICAgICAgICAgIGxvc3RQb2ludCArPSAzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBMRVZFTDNcblxuICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQ7IHJvdyArPSAxKSB7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50IC0gNjsgY29sICs9IDEpIHtcbiAgICAgICAgICBpZiAocXJjb2RlLmlzRGFyayhyb3csIGNvbClcbiAgICAgICAgICAgICAgJiYgIXFyY29kZS5pc0Rhcmsocm93LCBjb2wgKyAxKVxuICAgICAgICAgICAgICAmJiAgcXJjb2RlLmlzRGFyayhyb3csIGNvbCArIDIpXG4gICAgICAgICAgICAgICYmICBxcmNvZGUuaXNEYXJrKHJvdywgY29sICsgMylcbiAgICAgICAgICAgICAgJiYgIHFyY29kZS5pc0Rhcmsocm93LCBjb2wgKyA0KVxuICAgICAgICAgICAgICAmJiAhcXJjb2RlLmlzRGFyayhyb3csIGNvbCArIDUpXG4gICAgICAgICAgICAgICYmICBxcmNvZGUuaXNEYXJrKHJvdywgY29sICsgNikgKSB7XG4gICAgICAgICAgICBsb3N0UG9pbnQgKz0gNDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50OyBjb2wgKz0gMSkge1xuICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudCAtIDY7IHJvdyArPSAxKSB7XG4gICAgICAgICAgaWYgKHFyY29kZS5pc0Rhcmsocm93LCBjb2wpXG4gICAgICAgICAgICAgICYmICFxcmNvZGUuaXNEYXJrKHJvdyArIDEsIGNvbClcbiAgICAgICAgICAgICAgJiYgIHFyY29kZS5pc0Rhcmsocm93ICsgMiwgY29sKVxuICAgICAgICAgICAgICAmJiAgcXJjb2RlLmlzRGFyayhyb3cgKyAzLCBjb2wpXG4gICAgICAgICAgICAgICYmICBxcmNvZGUuaXNEYXJrKHJvdyArIDQsIGNvbClcbiAgICAgICAgICAgICAgJiYgIXFyY29kZS5pc0Rhcmsocm93ICsgNSwgY29sKVxuICAgICAgICAgICAgICAmJiAgcXJjb2RlLmlzRGFyayhyb3cgKyA2LCBjb2wpICkge1xuICAgICAgICAgICAgbG9zdFBvaW50ICs9IDQwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBMRVZFTDRcblxuICAgICAgdmFyIGRhcmtDb3VudCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50OyBjb2wgKz0gMSkge1xuICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudDsgcm93ICs9IDEpIHtcbiAgICAgICAgICBpZiAocXJjb2RlLmlzRGFyayhyb3csIGNvbCkgKSB7XG4gICAgICAgICAgICBkYXJrQ291bnQgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJhdGlvID0gTWF0aC5hYnMoMTAwICogZGFya0NvdW50IC8gbW9kdWxlQ291bnQgLyBtb2R1bGVDb3VudCAtIDUwKSAvIDU7XG4gICAgICBsb3N0UG9pbnQgKz0gcmF0aW8gKiAxMDtcblxuICAgICAgcmV0dXJuIGxvc3RQb2ludDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9KCk7XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUVJNYXRoXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIFFSTWF0aCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIEVYUF9UQUJMRSA9IG5ldyBBcnJheSgyNTYpO1xuICAgIHZhciBMT0dfVEFCTEUgPSBuZXcgQXJyYXkoMjU2KTtcblxuICAgIC8vIGluaXRpYWxpemUgdGFibGVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcbiAgICAgIEVYUF9UQUJMRVtpXSA9IDEgPDwgaTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDg7IGkgPCAyNTY7IGkgKz0gMSkge1xuICAgICAgRVhQX1RBQkxFW2ldID0gRVhQX1RBQkxFW2kgLSA0XVxuICAgICAgICBeIEVYUF9UQUJMRVtpIC0gNV1cbiAgICAgICAgXiBFWFBfVEFCTEVbaSAtIDZdXG4gICAgICAgIF4gRVhQX1RBQkxFW2kgLSA4XTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTU7IGkgKz0gMSkge1xuICAgICAgTE9HX1RBQkxFW0VYUF9UQUJMRVtpXSBdID0gaTtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgIF90aGlzLmdsb2cgPSBmdW5jdGlvbihuKSB7XG5cbiAgICAgIGlmIChuIDwgMSkge1xuICAgICAgICB0aHJvdyAnZ2xvZygnICsgbiArICcpJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIExPR19UQUJMRVtuXTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V4cCA9IGZ1bmN0aW9uKG4pIHtcblxuICAgICAgd2hpbGUgKG4gPCAwKSB7XG4gICAgICAgIG4gKz0gMjU1O1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobiA+PSAyNTYpIHtcbiAgICAgICAgbiAtPSAyNTU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBFWFBfVEFCTEVbbl07XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfSgpO1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHFyUG9seW5vbWlhbFxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGZ1bmN0aW9uIHFyUG9seW5vbWlhbChudW0sIHNoaWZ0KSB7XG5cbiAgICBpZiAodHlwZW9mIG51bS5sZW5ndGggPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG51bS5sZW5ndGggKyAnLycgKyBzaGlmdDtcbiAgICB9XG5cbiAgICB2YXIgX251bSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICB3aGlsZSAob2Zmc2V0IDwgbnVtLmxlbmd0aCAmJiBudW1bb2Zmc2V0XSA9PSAwKSB7XG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgfVxuICAgICAgdmFyIF9udW0gPSBuZXcgQXJyYXkobnVtLmxlbmd0aCAtIG9mZnNldCArIHNoaWZ0KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aCAtIG9mZnNldDsgaSArPSAxKSB7XG4gICAgICAgIF9udW1baV0gPSBudW1baSArIG9mZnNldF07XG4gICAgICB9XG4gICAgICByZXR1cm4gX251bTtcbiAgICB9KCk7XG5cbiAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgIF90aGlzLmdldEF0ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIHJldHVybiBfbnVtW2luZGV4XTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX251bS5sZW5ndGg7XG4gICAgfTtcblxuICAgIF90aGlzLm11bHRpcGx5ID0gZnVuY3Rpb24oZSkge1xuXG4gICAgICB2YXIgbnVtID0gbmV3IEFycmF5KF90aGlzLmdldExlbmd0aCgpICsgZS5nZXRMZW5ndGgoKSAtIDEpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLmdldExlbmd0aCgpOyBpICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlLmdldExlbmd0aCgpOyBqICs9IDEpIHtcbiAgICAgICAgICBudW1baSArIGpdIF49IFFSTWF0aC5nZXhwKFFSTWF0aC5nbG9nKF90aGlzLmdldEF0KGkpICkgKyBRUk1hdGguZ2xvZyhlLmdldEF0KGopICkgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcXJQb2x5bm9taWFsKG51bSwgMCk7XG4gICAgfTtcblxuICAgIF90aGlzLm1vZCA9IGZ1bmN0aW9uKGUpIHtcblxuICAgICAgaWYgKF90aGlzLmdldExlbmd0aCgpIC0gZS5nZXRMZW5ndGgoKSA8IDApIHtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmF0aW8gPSBRUk1hdGguZ2xvZyhfdGhpcy5nZXRBdCgwKSApIC0gUVJNYXRoLmdsb2coZS5nZXRBdCgwKSApO1xuXG4gICAgICB2YXIgbnVtID0gbmV3IEFycmF5KF90aGlzLmdldExlbmd0aCgpICk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLmdldExlbmd0aCgpOyBpICs9IDEpIHtcbiAgICAgICAgbnVtW2ldID0gX3RoaXMuZ2V0QXQoaSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5nZXRMZW5ndGgoKTsgaSArPSAxKSB7XG4gICAgICAgIG51bVtpXSBePSBRUk1hdGguZ2V4cChRUk1hdGguZ2xvZyhlLmdldEF0KGkpICkgKyByYXRpbyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlY3Vyc2l2ZSBjYWxsXG4gICAgICByZXR1cm4gcXJQb2x5bm9taWFsKG51bSwgMCkubW9kKGUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUVJSU0Jsb2NrXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIFFSUlNCbG9jayA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIFJTX0JMT0NLX1RBQkxFID0gW1xuXG4gICAgICAvLyBMXG4gICAgICAvLyBNXG4gICAgICAvLyBRXG4gICAgICAvLyBIXG5cbiAgICAgIC8vIDFcbiAgICAgIFsxLCAyNiwgMTldLFxuICAgICAgWzEsIDI2LCAxNl0sXG4gICAgICBbMSwgMjYsIDEzXSxcbiAgICAgIFsxLCAyNiwgOV0sXG5cbiAgICAgIC8vIDJcbiAgICAgIFsxLCA0NCwgMzRdLFxuICAgICAgWzEsIDQ0LCAyOF0sXG4gICAgICBbMSwgNDQsIDIyXSxcbiAgICAgIFsxLCA0NCwgMTZdLFxuXG4gICAgICAvLyAzXG4gICAgICBbMSwgNzAsIDU1XSxcbiAgICAgIFsxLCA3MCwgNDRdLFxuICAgICAgWzIsIDM1LCAxN10sXG4gICAgICBbMiwgMzUsIDEzXSxcblxuICAgICAgLy8gNFxuICAgICAgWzEsIDEwMCwgODBdLFxuICAgICAgWzIsIDUwLCAzMl0sXG4gICAgICBbMiwgNTAsIDI0XSxcbiAgICAgIFs0LCAyNSwgOV0sXG5cbiAgICAgIC8vIDVcbiAgICAgIFsxLCAxMzQsIDEwOF0sXG4gICAgICBbMiwgNjcsIDQzXSxcbiAgICAgIFsyLCAzMywgMTUsIDIsIDM0LCAxNl0sXG4gICAgICBbMiwgMzMsIDExLCAyLCAzNCwgMTJdLFxuXG4gICAgICAvLyA2XG4gICAgICBbMiwgODYsIDY4XSxcbiAgICAgIFs0LCA0MywgMjddLFxuICAgICAgWzQsIDQzLCAxOV0sXG4gICAgICBbNCwgNDMsIDE1XSxcblxuICAgICAgLy8gN1xuICAgICAgWzIsIDk4LCA3OF0sXG4gICAgICBbNCwgNDksIDMxXSxcbiAgICAgIFsyLCAzMiwgMTQsIDQsIDMzLCAxNV0sXG4gICAgICBbNCwgMzksIDEzLCAxLCA0MCwgMTRdLFxuXG4gICAgICAvLyA4XG4gICAgICBbMiwgMTIxLCA5N10sXG4gICAgICBbMiwgNjAsIDM4LCAyLCA2MSwgMzldLFxuICAgICAgWzQsIDQwLCAxOCwgMiwgNDEsIDE5XSxcbiAgICAgIFs0LCA0MCwgMTQsIDIsIDQxLCAxNV0sXG5cbiAgICAgIC8vIDlcbiAgICAgIFsyLCAxNDYsIDExNl0sXG4gICAgICBbMywgNTgsIDM2LCAyLCA1OSwgMzddLFxuICAgICAgWzQsIDM2LCAxNiwgNCwgMzcsIDE3XSxcbiAgICAgIFs0LCAzNiwgMTIsIDQsIDM3LCAxM10sXG5cbiAgICAgIC8vIDEwXG4gICAgICBbMiwgODYsIDY4LCAyLCA4NywgNjldLFxuICAgICAgWzQsIDY5LCA0MywgMSwgNzAsIDQ0XSxcbiAgICAgIFs2LCA0MywgMTksIDIsIDQ0LCAyMF0sXG4gICAgICBbNiwgNDMsIDE1LCAyLCA0NCwgMTZdLFxuXG4gICAgICAvLyAxMVxuICAgICAgWzQsIDEwMSwgODFdLFxuICAgICAgWzEsIDgwLCA1MCwgNCwgODEsIDUxXSxcbiAgICAgIFs0LCA1MCwgMjIsIDQsIDUxLCAyM10sXG4gICAgICBbMywgMzYsIDEyLCA4LCAzNywgMTNdLFxuXG4gICAgICAvLyAxMlxuICAgICAgWzIsIDExNiwgOTIsIDIsIDExNywgOTNdLFxuICAgICAgWzYsIDU4LCAzNiwgMiwgNTksIDM3XSxcbiAgICAgIFs0LCA0NiwgMjAsIDYsIDQ3LCAyMV0sXG4gICAgICBbNywgNDIsIDE0LCA0LCA0MywgMTVdLFxuXG4gICAgICAvLyAxM1xuICAgICAgWzQsIDEzMywgMTA3XSxcbiAgICAgIFs4LCA1OSwgMzcsIDEsIDYwLCAzOF0sXG4gICAgICBbOCwgNDQsIDIwLCA0LCA0NSwgMjFdLFxuICAgICAgWzEyLCAzMywgMTEsIDQsIDM0LCAxMl0sXG5cbiAgICAgIC8vIDE0XG4gICAgICBbMywgMTQ1LCAxMTUsIDEsIDE0NiwgMTE2XSxcbiAgICAgIFs0LCA2NCwgNDAsIDUsIDY1LCA0MV0sXG4gICAgICBbMTEsIDM2LCAxNiwgNSwgMzcsIDE3XSxcbiAgICAgIFsxMSwgMzYsIDEyLCA1LCAzNywgMTNdLFxuXG4gICAgICAvLyAxNVxuICAgICAgWzUsIDEwOSwgODcsIDEsIDExMCwgODhdLFxuICAgICAgWzUsIDY1LCA0MSwgNSwgNjYsIDQyXSxcbiAgICAgIFs1LCA1NCwgMjQsIDcsIDU1LCAyNV0sXG4gICAgICBbMTEsIDM2LCAxMiwgNywgMzcsIDEzXSxcblxuICAgICAgLy8gMTZcbiAgICAgIFs1LCAxMjIsIDk4LCAxLCAxMjMsIDk5XSxcbiAgICAgIFs3LCA3MywgNDUsIDMsIDc0LCA0Nl0sXG4gICAgICBbMTUsIDQzLCAxOSwgMiwgNDQsIDIwXSxcbiAgICAgIFszLCA0NSwgMTUsIDEzLCA0NiwgMTZdLFxuXG4gICAgICAvLyAxN1xuICAgICAgWzEsIDEzNSwgMTA3LCA1LCAxMzYsIDEwOF0sXG4gICAgICBbMTAsIDc0LCA0NiwgMSwgNzUsIDQ3XSxcbiAgICAgIFsxLCA1MCwgMjIsIDE1LCA1MSwgMjNdLFxuICAgICAgWzIsIDQyLCAxNCwgMTcsIDQzLCAxNV0sXG5cbiAgICAgIC8vIDE4XG4gICAgICBbNSwgMTUwLCAxMjAsIDEsIDE1MSwgMTIxXSxcbiAgICAgIFs5LCA2OSwgNDMsIDQsIDcwLCA0NF0sXG4gICAgICBbMTcsIDUwLCAyMiwgMSwgNTEsIDIzXSxcbiAgICAgIFsyLCA0MiwgMTQsIDE5LCA0MywgMTVdLFxuXG4gICAgICAvLyAxOVxuICAgICAgWzMsIDE0MSwgMTEzLCA0LCAxNDIsIDExNF0sXG4gICAgICBbMywgNzAsIDQ0LCAxMSwgNzEsIDQ1XSxcbiAgICAgIFsxNywgNDcsIDIxLCA0LCA0OCwgMjJdLFxuICAgICAgWzksIDM5LCAxMywgMTYsIDQwLCAxNF0sXG5cbiAgICAgIC8vIDIwXG4gICAgICBbMywgMTM1LCAxMDcsIDUsIDEzNiwgMTA4XSxcbiAgICAgIFszLCA2NywgNDEsIDEzLCA2OCwgNDJdLFxuICAgICAgWzE1LCA1NCwgMjQsIDUsIDU1LCAyNV0sXG4gICAgICBbMTUsIDQzLCAxNSwgMTAsIDQ0LCAxNl0sXG5cbiAgICAgIC8vIDIxXG4gICAgICBbNCwgMTQ0LCAxMTYsIDQsIDE0NSwgMTE3XSxcbiAgICAgIFsxNywgNjgsIDQyXSxcbiAgICAgIFsxNywgNTAsIDIyLCA2LCA1MSwgMjNdLFxuICAgICAgWzE5LCA0NiwgMTYsIDYsIDQ3LCAxN10sXG5cbiAgICAgIC8vIDIyXG4gICAgICBbMiwgMTM5LCAxMTEsIDcsIDE0MCwgMTEyXSxcbiAgICAgIFsxNywgNzQsIDQ2XSxcbiAgICAgIFs3LCA1NCwgMjQsIDE2LCA1NSwgMjVdLFxuICAgICAgWzM0LCAzNywgMTNdLFxuXG4gICAgICAvLyAyM1xuICAgICAgWzQsIDE1MSwgMTIxLCA1LCAxNTIsIDEyMl0sXG4gICAgICBbNCwgNzUsIDQ3LCAxNCwgNzYsIDQ4XSxcbiAgICAgIFsxMSwgNTQsIDI0LCAxNCwgNTUsIDI1XSxcbiAgICAgIFsxNiwgNDUsIDE1LCAxNCwgNDYsIDE2XSxcblxuICAgICAgLy8gMjRcbiAgICAgIFs2LCAxNDcsIDExNywgNCwgMTQ4LCAxMThdLFxuICAgICAgWzYsIDczLCA0NSwgMTQsIDc0LCA0Nl0sXG4gICAgICBbMTEsIDU0LCAyNCwgMTYsIDU1LCAyNV0sXG4gICAgICBbMzAsIDQ2LCAxNiwgMiwgNDcsIDE3XSxcblxuICAgICAgLy8gMjVcbiAgICAgIFs4LCAxMzIsIDEwNiwgNCwgMTMzLCAxMDddLFxuICAgICAgWzgsIDc1LCA0NywgMTMsIDc2LCA0OF0sXG4gICAgICBbNywgNTQsIDI0LCAyMiwgNTUsIDI1XSxcbiAgICAgIFsyMiwgNDUsIDE1LCAxMywgNDYsIDE2XSxcblxuICAgICAgLy8gMjZcbiAgICAgIFsxMCwgMTQyLCAxMTQsIDIsIDE0MywgMTE1XSxcbiAgICAgIFsxOSwgNzQsIDQ2LCA0LCA3NSwgNDddLFxuICAgICAgWzI4LCA1MCwgMjIsIDYsIDUxLCAyM10sXG4gICAgICBbMzMsIDQ2LCAxNiwgNCwgNDcsIDE3XSxcblxuICAgICAgLy8gMjdcbiAgICAgIFs4LCAxNTIsIDEyMiwgNCwgMTUzLCAxMjNdLFxuICAgICAgWzIyLCA3MywgNDUsIDMsIDc0LCA0Nl0sXG4gICAgICBbOCwgNTMsIDIzLCAyNiwgNTQsIDI0XSxcbiAgICAgIFsxMiwgNDUsIDE1LCAyOCwgNDYsIDE2XSxcblxuICAgICAgLy8gMjhcbiAgICAgIFszLCAxNDcsIDExNywgMTAsIDE0OCwgMTE4XSxcbiAgICAgIFszLCA3MywgNDUsIDIzLCA3NCwgNDZdLFxuICAgICAgWzQsIDU0LCAyNCwgMzEsIDU1LCAyNV0sXG4gICAgICBbMTEsIDQ1LCAxNSwgMzEsIDQ2LCAxNl0sXG5cbiAgICAgIC8vIDI5XG4gICAgICBbNywgMTQ2LCAxMTYsIDcsIDE0NywgMTE3XSxcbiAgICAgIFsyMSwgNzMsIDQ1LCA3LCA3NCwgNDZdLFxuICAgICAgWzEsIDUzLCAyMywgMzcsIDU0LCAyNF0sXG4gICAgICBbMTksIDQ1LCAxNSwgMjYsIDQ2LCAxNl0sXG5cbiAgICAgIC8vIDMwXG4gICAgICBbNSwgMTQ1LCAxMTUsIDEwLCAxNDYsIDExNl0sXG4gICAgICBbMTksIDc1LCA0NywgMTAsIDc2LCA0OF0sXG4gICAgICBbMTUsIDU0LCAyNCwgMjUsIDU1LCAyNV0sXG4gICAgICBbMjMsIDQ1LCAxNSwgMjUsIDQ2LCAxNl0sXG5cbiAgICAgIC8vIDMxXG4gICAgICBbMTMsIDE0NSwgMTE1LCAzLCAxNDYsIDExNl0sXG4gICAgICBbMiwgNzQsIDQ2LCAyOSwgNzUsIDQ3XSxcbiAgICAgIFs0MiwgNTQsIDI0LCAxLCA1NSwgMjVdLFxuICAgICAgWzIzLCA0NSwgMTUsIDI4LCA0NiwgMTZdLFxuXG4gICAgICAvLyAzMlxuICAgICAgWzE3LCAxNDUsIDExNV0sXG4gICAgICBbMTAsIDc0LCA0NiwgMjMsIDc1LCA0N10sXG4gICAgICBbMTAsIDU0LCAyNCwgMzUsIDU1LCAyNV0sXG4gICAgICBbMTksIDQ1LCAxNSwgMzUsIDQ2LCAxNl0sXG5cbiAgICAgIC8vIDMzXG4gICAgICBbMTcsIDE0NSwgMTE1LCAxLCAxNDYsIDExNl0sXG4gICAgICBbMTQsIDc0LCA0NiwgMjEsIDc1LCA0N10sXG4gICAgICBbMjksIDU0LCAyNCwgMTksIDU1LCAyNV0sXG4gICAgICBbMTEsIDQ1LCAxNSwgNDYsIDQ2LCAxNl0sXG5cbiAgICAgIC8vIDM0XG4gICAgICBbMTMsIDE0NSwgMTE1LCA2LCAxNDYsIDExNl0sXG4gICAgICBbMTQsIDc0LCA0NiwgMjMsIDc1LCA0N10sXG4gICAgICBbNDQsIDU0LCAyNCwgNywgNTUsIDI1XSxcbiAgICAgIFs1OSwgNDYsIDE2LCAxLCA0NywgMTddLFxuXG4gICAgICAvLyAzNVxuICAgICAgWzEyLCAxNTEsIDEyMSwgNywgMTUyLCAxMjJdLFxuICAgICAgWzEyLCA3NSwgNDcsIDI2LCA3NiwgNDhdLFxuICAgICAgWzM5LCA1NCwgMjQsIDE0LCA1NSwgMjVdLFxuICAgICAgWzIyLCA0NSwgMTUsIDQxLCA0NiwgMTZdLFxuXG4gICAgICAvLyAzNlxuICAgICAgWzYsIDE1MSwgMTIxLCAxNCwgMTUyLCAxMjJdLFxuICAgICAgWzYsIDc1LCA0NywgMzQsIDc2LCA0OF0sXG4gICAgICBbNDYsIDU0LCAyNCwgMTAsIDU1LCAyNV0sXG4gICAgICBbMiwgNDUsIDE1LCA2NCwgNDYsIDE2XSxcblxuICAgICAgLy8gMzdcbiAgICAgIFsxNywgMTUyLCAxMjIsIDQsIDE1MywgMTIzXSxcbiAgICAgIFsyOSwgNzQsIDQ2LCAxNCwgNzUsIDQ3XSxcbiAgICAgIFs0OSwgNTQsIDI0LCAxMCwgNTUsIDI1XSxcbiAgICAgIFsyNCwgNDUsIDE1LCA0NiwgNDYsIDE2XSxcblxuICAgICAgLy8gMzhcbiAgICAgIFs0LCAxNTIsIDEyMiwgMTgsIDE1MywgMTIzXSxcbiAgICAgIFsxMywgNzQsIDQ2LCAzMiwgNzUsIDQ3XSxcbiAgICAgIFs0OCwgNTQsIDI0LCAxNCwgNTUsIDI1XSxcbiAgICAgIFs0MiwgNDUsIDE1LCAzMiwgNDYsIDE2XSxcblxuICAgICAgLy8gMzlcbiAgICAgIFsyMCwgMTQ3LCAxMTcsIDQsIDE0OCwgMTE4XSxcbiAgICAgIFs0MCwgNzUsIDQ3LCA3LCA3NiwgNDhdLFxuICAgICAgWzQzLCA1NCwgMjQsIDIyLCA1NSwgMjVdLFxuICAgICAgWzEwLCA0NSwgMTUsIDY3LCA0NiwgMTZdLFxuXG4gICAgICAvLyA0MFxuICAgICAgWzE5LCAxNDgsIDExOCwgNiwgMTQ5LCAxMTldLFxuICAgICAgWzE4LCA3NSwgNDcsIDMxLCA3NiwgNDhdLFxuICAgICAgWzM0LCA1NCwgMjQsIDM0LCA1NSwgMjVdLFxuICAgICAgWzIwLCA0NSwgMTUsIDYxLCA0NiwgMTZdXG4gICAgXTtcblxuICAgIHZhciBxclJTQmxvY2sgPSBmdW5jdGlvbih0b3RhbENvdW50LCBkYXRhQ291bnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHt9O1xuICAgICAgX3RoaXMudG90YWxDb3VudCA9IHRvdGFsQ291bnQ7XG4gICAgICBfdGhpcy5kYXRhQ291bnQgPSBkYXRhQ291bnQ7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgdmFyIGdldFJzQmxvY2tUYWJsZSA9IGZ1bmN0aW9uKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdGlvbkxldmVsKSB7XG5cbiAgICAgIHN3aXRjaChlcnJvckNvcnJlY3Rpb25MZXZlbCkge1xuICAgICAgY2FzZSBRUkVycm9yQ29ycmVjdGlvbkxldmVsLkwgOlxuICAgICAgICByZXR1cm4gUlNfQkxPQ0tfVEFCTEVbKHR5cGVOdW1iZXIgLSAxKSAqIDQgKyAwXTtcbiAgICAgIGNhc2UgUVJFcnJvckNvcnJlY3Rpb25MZXZlbC5NIDpcbiAgICAgICAgcmV0dXJuIFJTX0JMT0NLX1RBQkxFWyh0eXBlTnVtYmVyIC0gMSkgKiA0ICsgMV07XG4gICAgICBjYXNlIFFSRXJyb3JDb3JyZWN0aW9uTGV2ZWwuUSA6XG4gICAgICAgIHJldHVybiBSU19CTE9DS19UQUJMRVsodHlwZU51bWJlciAtIDEpICogNCArIDJdO1xuICAgICAgY2FzZSBRUkVycm9yQ29ycmVjdGlvbkxldmVsLkggOlxuICAgICAgICByZXR1cm4gUlNfQkxPQ0tfVEFCTEVbKHR5cGVOdW1iZXIgLSAxKSAqIDQgKyAzXTtcbiAgICAgIGRlZmF1bHQgOlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5nZXRSU0Jsb2NrcyA9IGZ1bmN0aW9uKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdGlvbkxldmVsKSB7XG5cbiAgICAgIHZhciByc0Jsb2NrID0gZ2V0UnNCbG9ja1RhYmxlKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdGlvbkxldmVsKTtcblxuICAgICAgaWYgKHR5cGVvZiByc0Jsb2NrID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93ICdiYWQgcnMgYmxvY2sgQCB0eXBlTnVtYmVyOicgKyB0eXBlTnVtYmVyICtcbiAgICAgICAgICAgICcvZXJyb3JDb3JyZWN0aW9uTGV2ZWw6JyArIGVycm9yQ29ycmVjdGlvbkxldmVsO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuZ3RoID0gcnNCbG9jay5sZW5ndGggLyAzO1xuXG4gICAgICB2YXIgbGlzdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG5cbiAgICAgICAgdmFyIGNvdW50ID0gcnNCbG9ja1tpICogMyArIDBdO1xuICAgICAgICB2YXIgdG90YWxDb3VudCA9IHJzQmxvY2tbaSAqIDMgKyAxXTtcbiAgICAgICAgdmFyIGRhdGFDb3VudCA9IHJzQmxvY2tbaSAqIDMgKyAyXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50OyBqICs9IDEpIHtcbiAgICAgICAgICBsaXN0LnB1c2gocXJSU0Jsb2NrKHRvdGFsQ291bnQsIGRhdGFDb3VudCkgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9KCk7XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gcXJCaXRCdWZmZXJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgcXJCaXRCdWZmZXIgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBfYnVmZmVyID0gW107XG4gICAgdmFyIF9sZW5ndGggPSAwO1xuXG4gICAgdmFyIF90aGlzID0ge307XG5cbiAgICBfdGhpcy5nZXRCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfYnVmZmVyO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRBdCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICB2YXIgYnVmSW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gOCk7XG4gICAgICByZXR1cm4gKCAoX2J1ZmZlcltidWZJbmRleF0gPj4+ICg3IC0gaW5kZXggJSA4KSApICYgMSkgPT0gMTtcbiAgICB9O1xuXG4gICAgX3RoaXMucHV0ID0gZnVuY3Rpb24obnVtLCBsZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgX3RoaXMucHV0Qml0KCAoIChudW0gPj4+IChsZW5ndGggLSBpIC0gMSkgKSAmIDEpID09IDEpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5nZXRMZW5ndGhJbkJpdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfbGVuZ3RoO1xuICAgIH07XG5cbiAgICBfdGhpcy5wdXRCaXQgPSBmdW5jdGlvbihiaXQpIHtcblxuICAgICAgdmFyIGJ1ZkluZGV4ID0gTWF0aC5mbG9vcihfbGVuZ3RoIC8gOCk7XG4gICAgICBpZiAoX2J1ZmZlci5sZW5ndGggPD0gYnVmSW5kZXgpIHtcbiAgICAgICAgX2J1ZmZlci5wdXNoKDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoYml0KSB7XG4gICAgICAgIF9idWZmZXJbYnVmSW5kZXhdIHw9ICgweDgwID4+PiAoX2xlbmd0aCAlIDgpICk7XG4gICAgICB9XG5cbiAgICAgIF9sZW5ndGggKz0gMTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHFyTnVtYmVyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIHFyTnVtYmVyID0gZnVuY3Rpb24oZGF0YSkge1xuXG4gICAgdmFyIF9tb2RlID0gUVJNb2RlLk1PREVfTlVNQkVSO1xuICAgIHZhciBfZGF0YSA9IGRhdGE7XG5cbiAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgIF90aGlzLmdldE1vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfbW9kZTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICByZXR1cm4gX2RhdGEubGVuZ3RoO1xuICAgIH07XG5cbiAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuXG4gICAgICB2YXIgZGF0YSA9IF9kYXRhO1xuXG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChpICsgMiA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGJ1ZmZlci5wdXQoc3RyVG9OdW0oZGF0YS5zdWJzdHJpbmcoaSwgaSArIDMpICksIDEwKTtcbiAgICAgICAgaSArPSAzO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAtIGkgPT0gMSkge1xuICAgICAgICAgIGJ1ZmZlci5wdXQoc3RyVG9OdW0oZGF0YS5zdWJzdHJpbmcoaSwgaSArIDEpICksIDQpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEubGVuZ3RoIC0gaSA9PSAyKSB7XG4gICAgICAgICAgYnVmZmVyLnB1dChzdHJUb051bShkYXRhLnN1YnN0cmluZyhpLCBpICsgMikgKSwgNyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHN0clRvTnVtID0gZnVuY3Rpb24ocykge1xuICAgICAgdmFyIG51bSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbnVtID0gbnVtICogMTAgKyBjaGF0VG9OdW0ocy5jaGFyQXQoaSkgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudW07XG4gICAgfTtcblxuICAgIHZhciBjaGF0VG9OdW0gPSBmdW5jdGlvbihjKSB7XG4gICAgICBpZiAoJzAnIDw9IGMgJiYgYyA8PSAnOScpIHtcbiAgICAgICAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKSAtICcwJy5jaGFyQ29kZUF0KDApO1xuICAgICAgfVxuICAgICAgdGhyb3cgJ2lsbGVnYWwgY2hhciA6JyArIGM7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBxckFscGhhTnVtXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIHFyQWxwaGFOdW0gPSBmdW5jdGlvbihkYXRhKSB7XG5cbiAgICB2YXIgX21vZGUgPSBRUk1vZGUuTU9ERV9BTFBIQV9OVU07XG4gICAgdmFyIF9kYXRhID0gZGF0YTtcblxuICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgX3RoaXMuZ2V0TW9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF9tb2RlO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIHJldHVybiBfZGF0YS5sZW5ndGg7XG4gICAgfTtcblxuICAgIF90aGlzLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG5cbiAgICAgIHZhciBzID0gX2RhdGE7XG5cbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKGkgKyAxIDwgcy5sZW5ndGgpIHtcbiAgICAgICAgYnVmZmVyLnB1dChcbiAgICAgICAgICBnZXRDb2RlKHMuY2hhckF0KGkpICkgKiA0NSArXG4gICAgICAgICAgZ2V0Q29kZShzLmNoYXJBdChpICsgMSkgKSwgMTEpO1xuICAgICAgICBpICs9IDI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpIDwgcy5sZW5ndGgpIHtcbiAgICAgICAgYnVmZmVyLnB1dChnZXRDb2RlKHMuY2hhckF0KGkpICksIDYpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZ2V0Q29kZSA9IGZ1bmN0aW9uKGMpIHtcblxuICAgICAgaWYgKCcwJyA8PSBjICYmIGMgPD0gJzknKSB7XG4gICAgICAgIHJldHVybiBjLmNoYXJDb2RlQXQoMCkgLSAnMCcuY2hhckNvZGVBdCgwKTtcbiAgICAgIH0gZWxzZSBpZiAoJ0EnIDw9IGMgJiYgYyA8PSAnWicpIHtcbiAgICAgICAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKSAtICdBJy5jaGFyQ29kZUF0KDApICsgMTA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAnICcgOiByZXR1cm4gMzY7XG4gICAgICAgIGNhc2UgJyQnIDogcmV0dXJuIDM3O1xuICAgICAgICBjYXNlICclJyA6IHJldHVybiAzODtcbiAgICAgICAgY2FzZSAnKicgOiByZXR1cm4gMzk7XG4gICAgICAgIGNhc2UgJysnIDogcmV0dXJuIDQwO1xuICAgICAgICBjYXNlICctJyA6IHJldHVybiA0MTtcbiAgICAgICAgY2FzZSAnLicgOiByZXR1cm4gNDI7XG4gICAgICAgIGNhc2UgJy8nIDogcmV0dXJuIDQzO1xuICAgICAgICBjYXNlICc6JyA6IHJldHVybiA0NDtcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgdGhyb3cgJ2lsbGVnYWwgY2hhciA6JyArIGM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHFyOEJpdEJ5dGVcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgcXI4Qml0Qnl0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgIHZhciBfbW9kZSA9IFFSTW9kZS5NT0RFXzhCSVRfQllURTtcbiAgICB2YXIgX2RhdGEgPSBkYXRhO1xuICAgIHZhciBfYnl0ZXMgPSBxcmNvZGUuc3RyaW5nVG9CeXRlcyhkYXRhKTtcblxuICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgX3RoaXMuZ2V0TW9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF9tb2RlO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIHJldHVybiBfYnl0ZXMubGVuZ3RoO1xuICAgIH07XG5cbiAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfYnl0ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYnVmZmVyLnB1dChfYnl0ZXNbaV0sIDgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gcXJLYW5qaVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBxckthbmppID0gZnVuY3Rpb24oZGF0YSkge1xuXG4gICAgdmFyIF9tb2RlID0gUVJNb2RlLk1PREVfS0FOSkk7XG4gICAgdmFyIF9kYXRhID0gZGF0YTtcblxuICAgIHZhciBzdHJpbmdUb0J5dGVzID0gcXJjb2RlLnN0cmluZ1RvQnl0ZXNGdW5jc1snU0pJUyddO1xuICAgIGlmICghc3RyaW5nVG9CeXRlcykge1xuICAgICAgdGhyb3cgJ3NqaXMgbm90IHN1cHBvcnRlZC4nO1xuICAgIH1cbiAgICAhZnVuY3Rpb24oYywgY29kZSkge1xuICAgICAgLy8gc2VsZiB0ZXN0IGZvciBzamlzIHN1cHBvcnQuXG4gICAgICB2YXIgdGVzdCA9IHN0cmluZ1RvQnl0ZXMoYyk7XG4gICAgICBpZiAodGVzdC5sZW5ndGggIT0gMiB8fCAoICh0ZXN0WzBdIDw8IDgpIHwgdGVzdFsxXSkgIT0gY29kZSkge1xuICAgICAgICB0aHJvdyAnc2ppcyBub3Qgc3VwcG9ydGVkLic7XG4gICAgICB9XG4gICAgfSgnXFx1NTNjYicsIDB4OTc0Nik7XG5cbiAgICB2YXIgX2J5dGVzID0gc3RyaW5nVG9CeXRlcyhkYXRhKTtcblxuICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgX3RoaXMuZ2V0TW9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF9tb2RlO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIHJldHVybiB+fihfYnl0ZXMubGVuZ3RoIC8gMik7XG4gICAgfTtcblxuICAgIF90aGlzLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG5cbiAgICAgIHZhciBkYXRhID0gX2J5dGVzO1xuXG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChpICsgMSA8IGRhdGEubGVuZ3RoKSB7XG5cbiAgICAgICAgdmFyIGMgPSAoICgweGZmICYgZGF0YVtpXSkgPDwgOCkgfCAoMHhmZiAmIGRhdGFbaSArIDFdKTtcblxuICAgICAgICBpZiAoMHg4MTQwIDw9IGMgJiYgYyA8PSAweDlGRkMpIHtcbiAgICAgICAgICBjIC09IDB4ODE0MDtcbiAgICAgICAgfSBlbHNlIGlmICgweEUwNDAgPD0gYyAmJiBjIDw9IDB4RUJCRikge1xuICAgICAgICAgIGMgLT0gMHhDMTQwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93ICdpbGxlZ2FsIGNoYXIgYXQgJyArIChpICsgMSkgKyAnLycgKyBjO1xuICAgICAgICB9XG5cbiAgICAgICAgYyA9ICggKGMgPj4+IDgpICYgMHhmZikgKiAweEMwICsgKGMgJiAweGZmKTtcblxuICAgICAgICBidWZmZXIucHV0KGMsIDEzKTtcblxuICAgICAgICBpICs9IDI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpIDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgJ2lsbGVnYWwgY2hhciBhdCAnICsgKGkgKyAxKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9O1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEdJRiBTdXBwb3J0IGV0Yy5cbiAgLy9cblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBieXRlQXJyYXlPdXRwdXRTdHJlYW1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgYnl0ZUFycmF5T3V0cHV0U3RyZWFtID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgX2J5dGVzID0gW107XG5cbiAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgIF90aGlzLndyaXRlQnl0ZSA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgIF9ieXRlcy5wdXNoKGIgJiAweGZmKTtcbiAgICB9O1xuXG4gICAgX3RoaXMud3JpdGVTaG9ydCA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgIF90aGlzLndyaXRlQnl0ZShpKTtcbiAgICAgIF90aGlzLndyaXRlQnl0ZShpID4+PiA4KTtcbiAgICB9O1xuXG4gICAgX3RoaXMud3JpdGVCeXRlcyA9IGZ1bmN0aW9uKGIsIG9mZiwgbGVuKSB7XG4gICAgICBvZmYgPSBvZmYgfHwgMDtcbiAgICAgIGxlbiA9IGxlbiB8fCBiLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgX3RoaXMud3JpdGVCeXRlKGJbaSArIG9mZl0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy53cml0ZVN0cmluZyA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBfdGhpcy53cml0ZUJ5dGUocy5jaGFyQ29kZUF0KGkpICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLnRvQnl0ZUFycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX2J5dGVzO1xuICAgIH07XG5cbiAgICBfdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHMgPSAnJztcbiAgICAgIHMgKz0gJ1snO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfYnl0ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgcyArPSAnLCc7XG4gICAgICAgIH1cbiAgICAgICAgcyArPSBfYnl0ZXNbaV07XG4gICAgICB9XG4gICAgICBzICs9ICddJztcbiAgICAgIHJldHVybiBzO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gYmFzZTY0RW5jb2RlT3V0cHV0U3RyZWFtXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIGJhc2U2NEVuY29kZU91dHB1dFN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIF9idWZmZXIgPSAwO1xuICAgIHZhciBfYnVmbGVuID0gMDtcbiAgICB2YXIgX2xlbmd0aCA9IDA7XG4gICAgdmFyIF9iYXNlNjQgPSAnJztcblxuICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgdmFyIHdyaXRlRW5jb2RlZCA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgIF9iYXNlNjQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShlbmNvZGUoYiAmIDB4M2YpICk7XG4gICAgfTtcblxuICAgIHZhciBlbmNvZGUgPSBmdW5jdGlvbihuKSB7XG4gICAgICBpZiAobiA8IDApIHtcbiAgICAgICAgLy8gZXJyb3IuXG4gICAgICB9IGVsc2UgaWYgKG4gPCAyNikge1xuICAgICAgICByZXR1cm4gMHg0MSArIG47XG4gICAgICB9IGVsc2UgaWYgKG4gPCA1Mikge1xuICAgICAgICByZXR1cm4gMHg2MSArIChuIC0gMjYpO1xuICAgICAgfSBlbHNlIGlmIChuIDwgNjIpIHtcbiAgICAgICAgcmV0dXJuIDB4MzAgKyAobiAtIDUyKTtcbiAgICAgIH0gZWxzZSBpZiAobiA9PSA2Mikge1xuICAgICAgICByZXR1cm4gMHgyYjtcbiAgICAgIH0gZWxzZSBpZiAobiA9PSA2Mykge1xuICAgICAgICByZXR1cm4gMHgyZjtcbiAgICAgIH1cbiAgICAgIHRocm93ICduOicgKyBuO1xuICAgIH07XG5cbiAgICBfdGhpcy53cml0ZUJ5dGUgPSBmdW5jdGlvbihuKSB7XG5cbiAgICAgIF9idWZmZXIgPSAoX2J1ZmZlciA8PCA4KSB8IChuICYgMHhmZik7XG4gICAgICBfYnVmbGVuICs9IDg7XG4gICAgICBfbGVuZ3RoICs9IDE7XG5cbiAgICAgIHdoaWxlIChfYnVmbGVuID49IDYpIHtcbiAgICAgICAgd3JpdGVFbmNvZGVkKF9idWZmZXIgPj4+IChfYnVmbGVuIC0gNikgKTtcbiAgICAgICAgX2J1ZmxlbiAtPSA2O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAoX2J1ZmxlbiA+IDApIHtcbiAgICAgICAgd3JpdGVFbmNvZGVkKF9idWZmZXIgPDwgKDYgLSBfYnVmbGVuKSApO1xuICAgICAgICBfYnVmZmVyID0gMDtcbiAgICAgICAgX2J1ZmxlbiA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChfbGVuZ3RoICUgMyAhPSAwKSB7XG4gICAgICAgIC8vIHBhZGRpbmdcbiAgICAgICAgdmFyIHBhZGxlbiA9IDMgLSBfbGVuZ3RoICUgMztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWRsZW47IGkgKz0gMSkge1xuICAgICAgICAgIF9iYXNlNjQgKz0gJz0nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX2Jhc2U2NDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIGJhc2U2NERlY29kZUlucHV0U3RyZWFtXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIGJhc2U2NERlY29kZUlucHV0U3RyZWFtID0gZnVuY3Rpb24oc3RyKSB7XG5cbiAgICB2YXIgX3N0ciA9IHN0cjtcbiAgICB2YXIgX3BvcyA9IDA7XG4gICAgdmFyIF9idWZmZXIgPSAwO1xuICAgIHZhciBfYnVmbGVuID0gMDtcblxuICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgX3RoaXMucmVhZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICB3aGlsZSAoX2J1ZmxlbiA8IDgpIHtcblxuICAgICAgICBpZiAoX3BvcyA+PSBfc3RyLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChfYnVmbGVuID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgJ3VuZXhwZWN0ZWQgZW5kIG9mIGZpbGUuLycgKyBfYnVmbGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGMgPSBfc3RyLmNoYXJBdChfcG9zKTtcbiAgICAgICAgX3BvcyArPSAxO1xuXG4gICAgICAgIGlmIChjID09ICc9Jykge1xuICAgICAgICAgIF9idWZsZW4gPSAwO1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChjLm1hdGNoKC9eXFxzJC8pICkge1xuICAgICAgICAgIC8vIGlnbm9yZSBpZiB3aGl0ZXNwYWNlLlxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgX2J1ZmZlciA9IChfYnVmZmVyIDw8IDYpIHwgZGVjb2RlKGMuY2hhckNvZGVBdCgwKSApO1xuICAgICAgICBfYnVmbGVuICs9IDY7XG4gICAgICB9XG5cbiAgICAgIHZhciBuID0gKF9idWZmZXIgPj4+IChfYnVmbGVuIC0gOCkgKSAmIDB4ZmY7XG4gICAgICBfYnVmbGVuIC09IDg7XG4gICAgICByZXR1cm4gbjtcbiAgICB9O1xuXG4gICAgdmFyIGRlY29kZSA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIGlmICgweDQxIDw9IGMgJiYgYyA8PSAweDVhKSB7XG4gICAgICAgIHJldHVybiBjIC0gMHg0MTtcbiAgICAgIH0gZWxzZSBpZiAoMHg2MSA8PSBjICYmIGMgPD0gMHg3YSkge1xuICAgICAgICByZXR1cm4gYyAtIDB4NjEgKyAyNjtcbiAgICAgIH0gZWxzZSBpZiAoMHgzMCA8PSBjICYmIGMgPD0gMHgzOSkge1xuICAgICAgICByZXR1cm4gYyAtIDB4MzAgKyA1MjtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PSAweDJiKSB7XG4gICAgICAgIHJldHVybiA2MjtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PSAweDJmKSB7XG4gICAgICAgIHJldHVybiA2MztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93ICdjOicgKyBjO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gZ2lmSW1hZ2UgKEIvVylcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgZ2lmSW1hZ2UgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgICB2YXIgX3dpZHRoID0gd2lkdGg7XG4gICAgdmFyIF9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdmFyIF9kYXRhID0gbmV3IEFycmF5KHdpZHRoICogaGVpZ2h0KTtcblxuICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgX3RoaXMuc2V0UGl4ZWwgPSBmdW5jdGlvbih4LCB5LCBwaXhlbCkge1xuICAgICAgX2RhdGFbeSAqIF93aWR0aCArIHhdID0gcGl4ZWw7XG4gICAgfTtcblxuICAgIF90aGlzLndyaXRlID0gZnVuY3Rpb24ob3V0KSB7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBHSUYgU2lnbmF0dXJlXG5cbiAgICAgIG91dC53cml0ZVN0cmluZygnR0lGODdhJyk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTY3JlZW4gRGVzY3JpcHRvclxuXG4gICAgICBvdXQud3JpdGVTaG9ydChfd2lkdGgpO1xuICAgICAgb3V0LndyaXRlU2hvcnQoX2hlaWdodCk7XG5cbiAgICAgIG91dC53cml0ZUJ5dGUoMHg4MCk7IC8vIDJiaXRcbiAgICAgIG91dC53cml0ZUJ5dGUoMCk7XG4gICAgICBvdXQud3JpdGVCeXRlKDApO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gR2xvYmFsIENvbG9yIE1hcFxuXG4gICAgICAvLyBibGFja1xuICAgICAgb3V0LndyaXRlQnl0ZSgweDAwKTtcbiAgICAgIG91dC53cml0ZUJ5dGUoMHgwMCk7XG4gICAgICBvdXQud3JpdGVCeXRlKDB4MDApO1xuXG4gICAgICAvLyB3aGl0ZVxuICAgICAgb3V0LndyaXRlQnl0ZSgweGZmKTtcbiAgICAgIG91dC53cml0ZUJ5dGUoMHhmZik7XG4gICAgICBvdXQud3JpdGVCeXRlKDB4ZmYpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gSW1hZ2UgRGVzY3JpcHRvclxuXG4gICAgICBvdXQud3JpdGVTdHJpbmcoJywnKTtcbiAgICAgIG91dC53cml0ZVNob3J0KDApO1xuICAgICAgb3V0LndyaXRlU2hvcnQoMCk7XG4gICAgICBvdXQud3JpdGVTaG9ydChfd2lkdGgpO1xuICAgICAgb3V0LndyaXRlU2hvcnQoX2hlaWdodCk7XG4gICAgICBvdXQud3JpdGVCeXRlKDApO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gTG9jYWwgQ29sb3IgTWFwXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBSYXN0ZXIgRGF0YVxuXG4gICAgICB2YXIgbHp3TWluQ29kZVNpemUgPSAyO1xuICAgICAgdmFyIHJhc3RlciA9IGdldExaV1Jhc3RlcihsendNaW5Db2RlU2l6ZSk7XG5cbiAgICAgIG91dC53cml0ZUJ5dGUobHp3TWluQ29kZVNpemUpO1xuXG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgICAgd2hpbGUgKHJhc3Rlci5sZW5ndGggLSBvZmZzZXQgPiAyNTUpIHtcbiAgICAgICAgb3V0LndyaXRlQnl0ZSgyNTUpO1xuICAgICAgICBvdXQud3JpdGVCeXRlcyhyYXN0ZXIsIG9mZnNldCwgMjU1KTtcbiAgICAgICAgb2Zmc2V0ICs9IDI1NTtcbiAgICAgIH1cblxuICAgICAgb3V0LndyaXRlQnl0ZShyYXN0ZXIubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgICAgIG91dC53cml0ZUJ5dGVzKHJhc3Rlciwgb2Zmc2V0LCByYXN0ZXIubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgICAgIG91dC53cml0ZUJ5dGUoMHgwMCk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBHSUYgVGVybWluYXRvclxuICAgICAgb3V0LndyaXRlU3RyaW5nKCc7Jyk7XG4gICAgfTtcblxuICAgIHZhciBiaXRPdXRwdXRTdHJlYW0gPSBmdW5jdGlvbihvdXQpIHtcblxuICAgICAgdmFyIF9vdXQgPSBvdXQ7XG4gICAgICB2YXIgX2JpdExlbmd0aCA9IDA7XG4gICAgICB2YXIgX2JpdEJ1ZmZlciA9IDA7XG5cbiAgICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uKGRhdGEsIGxlbmd0aCkge1xuXG4gICAgICAgIGlmICggKGRhdGEgPj4+IGxlbmd0aCkgIT0gMCkge1xuICAgICAgICAgIHRocm93ICdsZW5ndGggb3Zlcic7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoX2JpdExlbmd0aCArIGxlbmd0aCA+PSA4KSB7XG4gICAgICAgICAgX291dC53cml0ZUJ5dGUoMHhmZiAmICggKGRhdGEgPDwgX2JpdExlbmd0aCkgfCBfYml0QnVmZmVyKSApO1xuICAgICAgICAgIGxlbmd0aCAtPSAoOCAtIF9iaXRMZW5ndGgpO1xuICAgICAgICAgIGRhdGEgPj4+PSAoOCAtIF9iaXRMZW5ndGgpO1xuICAgICAgICAgIF9iaXRCdWZmZXIgPSAwO1xuICAgICAgICAgIF9iaXRMZW5ndGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgX2JpdEJ1ZmZlciA9IChkYXRhIDw8IF9iaXRMZW5ndGgpIHwgX2JpdEJ1ZmZlcjtcbiAgICAgICAgX2JpdExlbmd0aCA9IF9iaXRMZW5ndGggKyBsZW5ndGg7XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoX2JpdExlbmd0aCA+IDApIHtcbiAgICAgICAgICBfb3V0LndyaXRlQnl0ZShfYml0QnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0TFpXUmFzdGVyID0gZnVuY3Rpb24obHp3TWluQ29kZVNpemUpIHtcblxuICAgICAgdmFyIGNsZWFyQ29kZSA9IDEgPDwgbHp3TWluQ29kZVNpemU7XG4gICAgICB2YXIgZW5kQ29kZSA9ICgxIDw8IGx6d01pbkNvZGVTaXplKSArIDE7XG4gICAgICB2YXIgYml0TGVuZ3RoID0gbHp3TWluQ29kZVNpemUgKyAxO1xuXG4gICAgICAvLyBTZXR1cCBMWldUYWJsZVxuICAgICAgdmFyIHRhYmxlID0gbHp3VGFibGUoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGVhckNvZGU7IGkgKz0gMSkge1xuICAgICAgICB0YWJsZS5hZGQoU3RyaW5nLmZyb21DaGFyQ29kZShpKSApO1xuICAgICAgfVxuICAgICAgdGFibGUuYWRkKFN0cmluZy5mcm9tQ2hhckNvZGUoY2xlYXJDb2RlKSApO1xuICAgICAgdGFibGUuYWRkKFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kQ29kZSkgKTtcblxuICAgICAgdmFyIGJ5dGVPdXQgPSBieXRlQXJyYXlPdXRwdXRTdHJlYW0oKTtcbiAgICAgIHZhciBiaXRPdXQgPSBiaXRPdXRwdXRTdHJlYW0oYnl0ZU91dCk7XG5cbiAgICAgIC8vIGNsZWFyIGNvZGVcbiAgICAgIGJpdE91dC53cml0ZShjbGVhckNvZGUsIGJpdExlbmd0aCk7XG5cbiAgICAgIHZhciBkYXRhSW5kZXggPSAwO1xuXG4gICAgICB2YXIgcyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoX2RhdGFbZGF0YUluZGV4XSk7XG4gICAgICBkYXRhSW5kZXggKz0gMTtcblxuICAgICAgd2hpbGUgKGRhdGFJbmRleCA8IF9kYXRhLmxlbmd0aCkge1xuXG4gICAgICAgIHZhciBjID0gU3RyaW5nLmZyb21DaGFyQ29kZShfZGF0YVtkYXRhSW5kZXhdKTtcbiAgICAgICAgZGF0YUluZGV4ICs9IDE7XG5cbiAgICAgICAgaWYgKHRhYmxlLmNvbnRhaW5zKHMgKyBjKSApIHtcblxuICAgICAgICAgIHMgPSBzICsgYztcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgYml0T3V0LndyaXRlKHRhYmxlLmluZGV4T2YocyksIGJpdExlbmd0aCk7XG5cbiAgICAgICAgICBpZiAodGFibGUuc2l6ZSgpIDwgMHhmZmYpIHtcblxuICAgICAgICAgICAgaWYgKHRhYmxlLnNpemUoKSA9PSAoMSA8PCBiaXRMZW5ndGgpICkge1xuICAgICAgICAgICAgICBiaXRMZW5ndGggKz0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFibGUuYWRkKHMgKyBjKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzID0gYztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBiaXRPdXQud3JpdGUodGFibGUuaW5kZXhPZihzKSwgYml0TGVuZ3RoKTtcblxuICAgICAgLy8gZW5kIGNvZGVcbiAgICAgIGJpdE91dC53cml0ZShlbmRDb2RlLCBiaXRMZW5ndGgpO1xuXG4gICAgICBiaXRPdXQuZmx1c2goKTtcblxuICAgICAgcmV0dXJuIGJ5dGVPdXQudG9CeXRlQXJyYXkoKTtcbiAgICB9O1xuXG4gICAgdmFyIGx6d1RhYmxlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBfbWFwID0ge307XG4gICAgICB2YXIgX3NpemUgPSAwO1xuXG4gICAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgICAgX3RoaXMuYWRkID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChfdGhpcy5jb250YWlucyhrZXkpICkge1xuICAgICAgICAgIHRocm93ICdkdXAga2V5OicgKyBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgX21hcFtrZXldID0gX3NpemU7XG4gICAgICAgIF9zaXplICs9IDE7XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy5zaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfc2l6ZTtcbiAgICAgIH07XG5cbiAgICAgIF90aGlzLmluZGV4T2YgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9tYXBba2V5XTtcbiAgICAgIH07XG5cbiAgICAgIF90aGlzLmNvbnRhaW5zID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgX21hcFtrZXldICE9ICd1bmRlZmluZWQnO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZURhdGFVUkwgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBnZXRQaXhlbCkge1xuICAgIHZhciBnaWYgPSBnaWZJbWFnZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSArPSAxKSB7XG4gICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4ICs9IDEpIHtcbiAgICAgICAgZ2lmLnNldFBpeGVsKHgsIHksIGdldFBpeGVsKHgsIHkpICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGIgPSBieXRlQXJyYXlPdXRwdXRTdHJlYW0oKTtcbiAgICBnaWYud3JpdGUoYik7XG5cbiAgICB2YXIgYmFzZTY0ID0gYmFzZTY0RW5jb2RlT3V0cHV0U3RyZWFtKCk7XG4gICAgdmFyIGJ5dGVzID0gYi50b0J5dGVBcnJheSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGJhc2U2NC53cml0ZUJ5dGUoYnl0ZXNbaV0pO1xuICAgIH1cbiAgICBiYXNlNjQuZmx1c2goKTtcblxuICAgIHJldHVybiAnZGF0YTppbWFnZS9naWY7YmFzZTY0LCcgKyBiYXNlNjQ7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gcmV0dXJucyBxcmNvZGUgZnVuY3Rpb24uXG5cbiAgcmV0dXJuIHFyY29kZTtcbn0oKTtcblxuLy8gbXVsdGlieXRlIHN1cHBvcnRcbiFmdW5jdGlvbigpIHtcblxuICBxcmNvZGUuc3RyaW5nVG9CeXRlc0Z1bmNzWydVVEYtOCddID0gZnVuY3Rpb24ocykge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTg3Mjk0MDUvaG93LXRvLWNvbnZlcnQtdXRmOC1zdHJpbmctdG8tYnl0ZS1hcnJheVxuICAgIGZ1bmN0aW9uIHRvVVRGOEFycmF5KHN0cikge1xuICAgICAgdmFyIHV0ZjggPSBbXTtcbiAgICAgIGZvciAodmFyIGk9MDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hhcmNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoYXJjb2RlIDwgMHg4MCkgdXRmOC5wdXNoKGNoYXJjb2RlKTtcbiAgICAgICAgZWxzZSBpZiAoY2hhcmNvZGUgPCAweDgwMCkge1xuICAgICAgICAgIHV0ZjgucHVzaCgweGMwIHwgKGNoYXJjb2RlID4+IDYpLFxuICAgICAgICAgICAgICAweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYXJjb2RlIDwgMHhkODAwIHx8IGNoYXJjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgIHV0ZjgucHVzaCgweGUwIHwgKGNoYXJjb2RlID4+IDEyKSxcbiAgICAgICAgICAgICAgMHg4MCB8ICgoY2hhcmNvZGU+PjYpICYgMHgzZiksXG4gICAgICAgICAgICAgIDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIC8vIFVURi0xNiBlbmNvZGVzIDB4MTAwMDAtMHgxMEZGRkYgYnlcbiAgICAgICAgICAvLyBzdWJ0cmFjdGluZyAweDEwMDAwIGFuZCBzcGxpdHRpbmcgdGhlXG4gICAgICAgICAgLy8gMjAgYml0cyBvZiAweDAtMHhGRkZGRiBpbnRvIHR3byBoYWx2ZXNcbiAgICAgICAgICBjaGFyY29kZSA9IDB4MTAwMDAgKyAoKChjaGFyY29kZSAmIDB4M2ZmKTw8MTApXG4gICAgICAgICAgICB8IChzdHIuY2hhckNvZGVBdChpKSAmIDB4M2ZmKSk7XG4gICAgICAgICAgdXRmOC5wdXNoKDB4ZjAgfCAoY2hhcmNvZGUgPj4xOCksXG4gICAgICAgICAgICAgIDB4ODAgfCAoKGNoYXJjb2RlPj4xMikgJiAweDNmKSxcbiAgICAgICAgICAgICAgMHg4MCB8ICgoY2hhcmNvZGU+PjYpICYgMHgzZiksXG4gICAgICAgICAgICAgIDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1dGY4O1xuICAgIH1cbiAgICByZXR1cm4gdG9VVEY4QXJyYXkocyk7XG4gIH07XG5cbn0oKTtcblxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfVxufShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHFyY29kZTtcbn0pKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzJyk7IC8vIHFyLmpzIGRvZXNuJ3QgaGFuZGxlIGVycm9yIGxldmVsIG9mIHplcm8gKE0pIHNvIHdlIG5lZWQgdG8gZG8gaXQgcmlnaHQsXG4vLyB0aHVzIHRoZSBkZWVwIHJlcXVpcmUuXG5cblxudmFyIFFSQ29kZUltcGwgPSByZXF1aXJlKCdxci5qcy9saWIvUVJDb2RlJyk7XG5cbnZhciBFcnJvckNvcnJlY3RMZXZlbCA9IHJlcXVpcmUoJ3FyLmpzL2xpYi9FcnJvckNvcnJlY3RMZXZlbCcpOyAvLyBUT0RPOiBwdWxsIHRoaXMgb2ZmIG9mIHRoZSBRUkNvZGUgY2xhc3MgdHlwZSBzbyBpdCBtYXRjaGVzLlxuXG5cbi8vIENvbnZlcnQgZnJvbSBVVEYtMTYsIGZvcmNpbmcgdGhlIHVzZSBvZiBieXRlLW1vZGUgZW5jb2RpbmcgaW4gb3VyIFFSIENvZGUuXG4vLyBUaGlzIGFsbG93cyB1cyB0byBlbmNvZGUgSGFuamksIEthbmppLCBlbW9qaSwgZXRjLiBJZGVhbGx5IHdlJ2QgZG8gbW9yZVxuLy8gZGV0ZWN0aW9uIGFuZCBub3QgcmVzb3J0IHRvIGJ5dGUtbW9kZSBpZiBwb3NzaWJsZSwgYnV0IHdlJ3JlIHRyYWRpbmcgb2ZmXG4vLyBhIHNtYWxsZXIgbGlicmFyeSBmb3IgYSBzbWFsbGVyIGFtb3VudCBvZiBkYXRhIHdlIGNhbiBwb3RlbnRpYWxseSBlbmNvZGUuXG4vLyBCYXNlZCBvbiBodHRwOi8vam9uaXNhbG9uZW4uY29tLzIwMTIvZnJvbS11dGYtMTYtdG8tdXRmLTgtaW4tamF2YXNjcmlwdC9cbmZ1bmN0aW9uIGNvbnZlcnRTdHIoc3RyKSB7XG4gIHZhciBvdXQgPSAnJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGFyY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGNoYXJjb2RlIDwgMHgwMDgwKSB7XG4gICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyY29kZSk7XG4gICAgfSBlbHNlIGlmIChjaGFyY29kZSA8IDB4MDgwMCkge1xuICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhjMCB8IGNoYXJjb2RlID4+IDYpO1xuICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8IGNoYXJjb2RlICYgMHgzZik7XG4gICAgfSBlbHNlIGlmIChjaGFyY29kZSA8IDB4ZDgwMCB8fCBjaGFyY29kZSA+PSAweGUwMDApIHtcbiAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTAgfCBjaGFyY29kZSA+PiAxMik7XG4gICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDgwIHwgY2hhcmNvZGUgPj4gNiAmIDB4M2YpO1xuICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8IGNoYXJjb2RlICYgMHgzZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzdXJyb2dhdGUgcGFpciwgc28gd2UnbGwgcmVjb25zaXR1dGUgdGhlIHBpZWNlcyBhbmQgd29ya1xuICAgICAgLy8gZnJvbSB0aGF0XG4gICAgICBpKys7XG4gICAgICBjaGFyY29kZSA9IDB4MTAwMDAgKyAoKGNoYXJjb2RlICYgMHgzZmYpIDw8IDEwIHwgc3RyLmNoYXJDb2RlQXQoaSkgJiAweDNmZik7XG4gICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGYwIHwgY2hhcmNvZGUgPj4gMTgpO1xuICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8IGNoYXJjb2RlID4+IDEyICYgMHgzZik7XG4gICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDgwIHwgY2hhcmNvZGUgPj4gNiAmIDB4M2YpO1xuICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8IGNoYXJjb2RlICYgMHgzZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxudmFyIERFRkFVTFRfUFJPUFMgPSB7XG4gIHNpemU6IDEyOCxcbiAgbGV2ZWw6ICdMJyxcbiAgYmdDb2xvcjogJyNGRkZGRkYnLFxuICBmZ0NvbG9yOiAnIzAwMDAwMCcsXG4gIGluY2x1ZGVNYXJnaW46IGZhbHNlXG59O1xudmFyIFBST1BfVFlQRVMgPSBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyA/IHtcbiAgdmFsdWU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgc2l6ZTogUHJvcFR5cGVzLm51bWJlcixcbiAgbGV2ZWw6IFByb3BUeXBlcy5vbmVPZihbJ0wnLCAnTScsICdRJywgJ0gnXSksXG4gIGJnQ29sb3I6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGZnQ29sb3I6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGluY2x1ZGVNYXJnaW46IFByb3BUeXBlcy5ib29sLFxuICBpbWFnZVNldHRpbmdzOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIHNyYzogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgZXhjYXZhdGU6IFByb3BUeXBlcy5ib29sLFxuICAgIHg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgeTogUHJvcFR5cGVzLm51bWJlclxuICB9KVxufSA6IHt9O1xudmFyIE1BUkdJTl9TSVpFID0gNDsgLy8gVGhpcyBpcyAqdmVyeSogcm91Z2ggZXN0aW1hdGUgb2YgbWF4IGFtb3VudCBvZiBRUkNvZGUgYWxsb3dlZCB0byBiZSBjb3ZlcmVkLlxuLy8gSXQgaXMgXCJ3cm9uZ1wiIGluIGEgbG90IG9mIHdheXMgKGFyZWEgaXMgYSB0ZXJyaWJsZSB3YXkgdG8gZXN0aW1hdGUsIGl0XG4vLyByZWFsbHkgc2hvdWxkIGJlIG51bWJlciBvZiBtb2R1bGVzIGNvdmVyZWQpLCBidXQgaWYgZm9yIHNvbWUgcmVhc29uIHdlIGRvbid0XG4vLyBnZXQgYW4gZXhwbGljaXQgaGVpZ2h0IG9yIHdpZHRoLCBJJ2QgcmF0aGVyIGRlZmF1bHQgdG8gc29tZXRoaW5nIHRoYW4gdGhyb3cuXG5cbnZhciBERUZBVUxUX0lNR19TQ0FMRSA9IDAuMTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVQYXRoKG1vZHVsZXMpIHtcbiAgdmFyIG1hcmdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgdmFyIG9wcyA9IFtdO1xuICBtb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKHJvdywgeSkge1xuICAgIHZhciBzdGFydCA9IG51bGw7XG4gICAgcm93LmZvckVhY2goZnVuY3Rpb24gKGNlbGwsIHgpIHtcbiAgICAgIGlmICghY2VsbCAmJiBzdGFydCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBNMCAwaDd2MUgweiBpbmplY3RzIHRoZSBzcGFjZSB3aXRoIHRoZSBtb3ZlIGFuZCBkcm9wcyB0aGUgY29tbWEsXG4gICAgICAgIC8vIHNhdmluZyBhIGNoYXIgcGVyIG9wZXJhdGlvblxuICAgICAgICBvcHMucHVzaChcIk1cIi5jb25jYXQoc3RhcnQgKyBtYXJnaW4sIFwiIFwiKS5jb25jYXQoeSArIG1hcmdpbiwgXCJoXCIpLmNvbmNhdCh4IC0gc3RhcnQsIFwidjFIXCIpLmNvbmNhdChzdGFydCArIG1hcmdpbiwgXCJ6XCIpKTtcbiAgICAgICAgc3RhcnQgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGVuZCBvZiByb3csIGNsZWFuIHVwIG9yIHNraXBcblxuXG4gICAgICBpZiAoeCA9PT0gcm93Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgICAgLy8gV2Ugd291bGQgaGF2ZSBjbG9zZWQgdGhlIG9wIGFib3ZlIGFscmVhZHkgc28gdGhpcyBjYW4gb25seSBtZWFuXG4gICAgICAgICAgLy8gMisgbGlnaHQgbW9kdWxlcyBpbiBhIHJvdy5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBKdXN0IGEgc2luZ2xlIGRhcmsgbW9kdWxlLlxuICAgICAgICAgIG9wcy5wdXNoKFwiTVwiLmNvbmNhdCh4ICsgbWFyZ2luLCBcIixcIikuY29uY2F0KHkgKyBtYXJnaW4sIFwiIGgxdjFIXCIpLmNvbmNhdCh4ICsgbWFyZ2luLCBcInpcIikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBmaW5pc2ggdGhlIGN1cnJlbnQgbGluZS5cbiAgICAgICAgICBvcHMucHVzaChcIk1cIi5jb25jYXQoc3RhcnQgKyBtYXJnaW4sIFwiLFwiKS5jb25jYXQoeSArIG1hcmdpbiwgXCIgaFwiKS5jb25jYXQoeCArIDEgLSBzdGFydCwgXCJ2MUhcIikuY29uY2F0KHN0YXJ0ICsgbWFyZ2luLCBcInpcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2VsbCAmJiBzdGFydCA9PT0gbnVsbCkge1xuICAgICAgICBzdGFydCA9IHg7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb3BzLmpvaW4oJycpO1xufSAvLyBXZSBjb3VsZCBqdXN0IGRvIHRoaXMgaW4gZ2VuZXJhdGVQYXRoLCBleGNlcHQgdGhhdCB3ZSB3YW50IHRvIHN1cHBvcnRcbi8vIG5vbi1QYXRoMkQgY2FudmFzLCBzbyB3ZSBuZWVkIHRvIGtlZXAgaXQgYW4gZXhwbGljaXQgc3RlcC5cblxuXG5mdW5jdGlvbiBleGNhdmF0ZU1vZHVsZXMobW9kdWxlcywgZXhjYXZhdGlvbikge1xuICByZXR1cm4gbW9kdWxlcy5zbGljZSgpLm1hcChmdW5jdGlvbiAocm93LCB5KSB7XG4gICAgaWYgKHkgPCBleGNhdmF0aW9uLnkgfHwgeSA+PSBleGNhdmF0aW9uLnkgKyBleGNhdmF0aW9uLmgpIHtcbiAgICAgIHJldHVybiByb3c7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvdy5tYXAoZnVuY3Rpb24gKGNlbGwsIHgpIHtcbiAgICAgIGlmICh4IDwgZXhjYXZhdGlvbi54IHx8IHggPj0gZXhjYXZhdGlvbi54ICsgZXhjYXZhdGlvbi53KSB7XG4gICAgICAgIHJldHVybiBjZWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRJbWFnZVNldHRpbmdzKHByb3BzLCBjZWxscykge1xuICB2YXIgaW1hZ2VTZXR0aW5ncyA9IHByb3BzLmltYWdlU2V0dGluZ3MsXG4gICAgICBzaXplID0gcHJvcHMuc2l6ZSxcbiAgICAgIGluY2x1ZGVNYXJnaW4gPSBwcm9wcy5pbmNsdWRlTWFyZ2luO1xuXG4gIGlmIChpbWFnZVNldHRpbmdzID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXJnaW4gPSBpbmNsdWRlTWFyZ2luID8gTUFSR0lOX1NJWkUgOiAwO1xuICB2YXIgbnVtQ2VsbHMgPSBjZWxscy5sZW5ndGggKyBtYXJnaW4gKiAyO1xuICB2YXIgZGVmYXVsdFNpemUgPSBNYXRoLmZsb29yKHNpemUgKiBERUZBVUxUX0lNR19TQ0FMRSk7XG4gIHZhciBzY2FsZSA9IG51bUNlbGxzIC8gc2l6ZTtcbiAgdmFyIHcgPSAoaW1hZ2VTZXR0aW5ncy53aWR0aCB8fCBkZWZhdWx0U2l6ZSkgKiBzY2FsZTtcbiAgdmFyIGggPSAoaW1hZ2VTZXR0aW5ncy5oZWlnaHQgfHwgZGVmYXVsdFNpemUpICogc2NhbGU7XG4gIHZhciB4ID0gaW1hZ2VTZXR0aW5ncy54ID09IG51bGwgPyBjZWxscy5sZW5ndGggLyAyIC0gdyAvIDIgOiBpbWFnZVNldHRpbmdzLnggKiBzY2FsZTtcbiAgdmFyIHkgPSBpbWFnZVNldHRpbmdzLnkgPT0gbnVsbCA/IGNlbGxzLmxlbmd0aCAvIDIgLSBoIC8gMiA6IGltYWdlU2V0dGluZ3MueSAqIHNjYWxlO1xuICB2YXIgZXhjYXZhdGlvbiA9IG51bGw7XG5cbiAgaWYgKGltYWdlU2V0dGluZ3MuZXhjYXZhdGUpIHtcbiAgICB2YXIgZmxvb3JYID0gTWF0aC5mbG9vcih4KTtcbiAgICB2YXIgZmxvb3JZID0gTWF0aC5mbG9vcih5KTtcbiAgICB2YXIgY2VpbFcgPSBNYXRoLmNlaWwodyArIHggLSBmbG9vclgpO1xuICAgIHZhciBjZWlsSCA9IE1hdGguY2VpbChoICsgeSAtIGZsb29yWSk7XG4gICAgZXhjYXZhdGlvbiA9IHtcbiAgICAgIHg6IGZsb29yWCxcbiAgICAgIHk6IGZsb29yWSxcbiAgICAgIHc6IGNlaWxXLFxuICAgICAgaDogY2VpbEhcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgaDogaCxcbiAgICB3OiB3LFxuICAgIGV4Y2F2YXRpb246IGV4Y2F2YXRpb25cbiAgfTtcbn0gLy8gRm9yIGNhbnZhcyB3ZSdyZSBnb2luZyB0byBzd2l0Y2ggb3VyIGRyYXdpbmcgbW9kZSBiYXNlZCBvbiB3aGV0aGVyIG9yIG5vdFxuLy8gdGhlIGVudmlyb25tZW50IHN1cHBvcnRzIFBhdGgyRC4gV2Ugb25seSBuZWVkIHRoZSBjb25zdHJ1Y3RvciB0byBiZVxuLy8gc3VwcG9ydGVkLCBidXQgRWRnZSBkb2Vzbid0IGFjdHVhbGx5IHN1cHBvcnQgdGhlIHBhdGggKHN0cmluZykgdHlwZVxuLy8gYXJndW1lbnQuIEx1Y2tpbHkgaXQgYWxzbyBkb2Vzbid0IHN1cHBvcnQgdGhlIGFkZFBhdGgoKSBtZXRob2QuIFdlIGNhblxuLy8gdHJlYXQgdGhhdCBhcyB0aGUgc2FtZSB0aGluZy5cblxuXG52YXIgU1VQUE9SVFNfUEFUSDJEID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIG5ldyBQYXRoMkQoKS5hZGRQYXRoKG5ldyBQYXRoMkQoKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn0oKTtcblxudmFyIFFSQ29kZUNhbnZhcyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JFB1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFFSQ29kZUNhbnZhcywgX1JlYWN0JFB1cmVDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFFSQ29kZUNhbnZhcygpIHtcbiAgICB2YXIgX2dldFByb3RvdHlwZU9mMjtcblxuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBRUkNvZGVDYW52YXMpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9nZXRQcm90b3R5cGVPZjIgPSBfZ2V0UHJvdG90eXBlT2YoUVJDb2RlQ2FudmFzKSkuY2FsbC5hcHBseShfZ2V0UHJvdG90eXBlT2YyLCBbdGhpc10uY29uY2F0KGFyZ3MpKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX2NhbnZhc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9pbWFnZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInN0YXRlXCIsIHtcbiAgICAgIGltZ0xvYWRlZDogZmFsc2VcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJoYW5kbGVJbWFnZUxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpbWdMb2FkZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFFSQ29kZUNhbnZhcywgW3tcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICBpZiAodGhpcy5faW1hZ2UgJiYgdGhpcy5faW1hZ2UuY29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVJbWFnZUxvYWQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgdmFyIF90aGlzJHByb3BzJGltYWdlU2V0dCwgX25leHRQcm9wcyRpbWFnZVNldHRpO1xuXG4gICAgICB2YXIgY3VycmVudFNyYyA9IChfdGhpcyRwcm9wcyRpbWFnZVNldHQgPSB0aGlzLnByb3BzLmltYWdlU2V0dGluZ3MpID09PSBudWxsIHx8IF90aGlzJHByb3BzJGltYWdlU2V0dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcHJvcHMkaW1hZ2VTZXR0LnNyYztcbiAgICAgIHZhciBuZXh0U3JjID0gKF9uZXh0UHJvcHMkaW1hZ2VTZXR0aSA9IG5leHRQcm9wcy5pbWFnZVNldHRpbmdzKSA9PT0gbnVsbCB8fCBfbmV4dFByb3BzJGltYWdlU2V0dGkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9uZXh0UHJvcHMkaW1hZ2VTZXR0aS5zcmM7XG5cbiAgICAgIGlmIChjdXJyZW50U3JjICE9PSBuZXh0U3JjKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGltZ0xvYWRlZDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudERpZFVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICB2YWx1ZSA9IF90aGlzJHByb3BzLnZhbHVlLFxuICAgICAgICAgIHNpemUgPSBfdGhpcyRwcm9wcy5zaXplLFxuICAgICAgICAgIGxldmVsID0gX3RoaXMkcHJvcHMubGV2ZWwsXG4gICAgICAgICAgYmdDb2xvciA9IF90aGlzJHByb3BzLmJnQ29sb3IsXG4gICAgICAgICAgZmdDb2xvciA9IF90aGlzJHByb3BzLmZnQ29sb3IsXG4gICAgICAgICAgaW5jbHVkZU1hcmdpbiA9IF90aGlzJHByb3BzLmluY2x1ZGVNYXJnaW4sXG4gICAgICAgICAgaW1hZ2VTZXR0aW5ncyA9IF90aGlzJHByb3BzLmltYWdlU2V0dGluZ3M7IC8vIFdlJ2xsIHVzZSB0eXBlPT09LTEgdG8gZm9yY2UgUVJDb2RlIHRvIGF1dG9tYXRpY2FsbHkgcGljayB0aGUgYmVzdCB0eXBlXG5cbiAgICAgIHZhciBxcmNvZGUgPSBuZXcgUVJDb2RlSW1wbCgtMSwgRXJyb3JDb3JyZWN0TGV2ZWxbbGV2ZWxdKTtcbiAgICAgIHFyY29kZS5hZGREYXRhKGNvbnZlcnRTdHIodmFsdWUpKTtcbiAgICAgIHFyY29kZS5tYWtlKCk7XG5cbiAgICAgIGlmICh0aGlzLl9jYW52YXMgIT0gbnVsbCkge1xuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzO1xuICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2VsbHMgPSBxcmNvZGUubW9kdWxlcztcblxuICAgICAgICBpZiAoY2VsbHMgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWFyZ2luID0gaW5jbHVkZU1hcmdpbiA/IE1BUkdJTl9TSVpFIDogMDtcbiAgICAgICAgdmFyIG51bUNlbGxzID0gY2VsbHMubGVuZ3RoICsgbWFyZ2luICogMjtcbiAgICAgICAgdmFyIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzID0gZ2V0SW1hZ2VTZXR0aW5ncyh0aGlzLnByb3BzLCBjZWxscyk7XG5cbiAgICAgICAgaWYgKGltYWdlU2V0dGluZ3MgIT0gbnVsbCAmJiBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLmV4Y2F2YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgY2VsbHMgPSBleGNhdmF0ZU1vZHVsZXMoY2VsbHMsIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLmV4Y2F2YXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBXZSdyZSBnb2luZyB0byBzY2FsZSB0aGlzIHNvIHRoYXQgdGhlIG51bWJlciBvZiBkcmF3YWJsZSB1bml0c1xuICAgICAgICAvLyBtYXRjaGVzIHRoZSBudW1iZXIgb2YgY2VsbHMuIFRoaXMgYXZvaWRzIHJvdW5kaW5nIGlzc3VlcywgYnV0IGRvZXNcbiAgICAgICAgLy8gcmVzdWx0IGluIHNvbWUgcG90ZW50aWFsbHkgdW53YW50ZWQgc2luZ2xlIHBpeGVsIGlzc3VlcyBiZXR3ZWVuXG4gICAgICAgIC8vIGJsb2Nrcywgb25seSBpbiBlbnZpcm9ubWVudHMgdGhhdCBkb24ndCBzdXBwb3J0IFBhdGgyRC5cblxuXG4gICAgICAgIHZhciBwaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCA9IHNpemUgKiBwaXhlbFJhdGlvO1xuICAgICAgICB2YXIgc2NhbGUgPSBzaXplIC8gbnVtQ2VsbHMgKiBwaXhlbFJhdGlvO1xuICAgICAgICBjdHguc2NhbGUoc2NhbGUsIHNjYWxlKTsgLy8gRHJhdyBzb2xpZCBiYWNrZ3JvdW5kLCBvbmx5IHBhaW50IGRhcmsgbW9kdWxlcy5cblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gYmdDb2xvcjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIG51bUNlbGxzLCBudW1DZWxscyk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBmZ0NvbG9yO1xuXG4gICAgICAgIGlmIChTVVBQT1JUU19QQVRIMkQpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lOiBQYXRoMkQgYyd0b3IgZG9lc24ndCBzdXBwb3J0IGFyZ3MgeWV0LlxuICAgICAgICAgIGN0eC5maWxsKG5ldyBQYXRoMkQoZ2VuZXJhdGVQYXRoKGNlbGxzLCBtYXJnaW4pKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2VsbHMuZm9yRWFjaChmdW5jdGlvbiAocm93LCByZHgpIHtcbiAgICAgICAgICAgIHJvdy5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsLCBjZHgpIHtcbiAgICAgICAgICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoY2R4ICsgbWFyZ2luLCByZHggKyBtYXJnaW4sIDEsIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmltZ0xvYWRlZCAmJiB0aGlzLl9pbWFnZSAmJiBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLl9pbWFnZSwgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MueCArIG1hcmdpbiwgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MueSArIG1hcmdpbiwgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MudywgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MuaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICB2YWx1ZSA9IF90aGlzJHByb3BzMi52YWx1ZSxcbiAgICAgICAgICBzaXplID0gX3RoaXMkcHJvcHMyLnNpemUsXG4gICAgICAgICAgbGV2ZWwgPSBfdGhpcyRwcm9wczIubGV2ZWwsXG4gICAgICAgICAgYmdDb2xvciA9IF90aGlzJHByb3BzMi5iZ0NvbG9yLFxuICAgICAgICAgIGZnQ29sb3IgPSBfdGhpcyRwcm9wczIuZmdDb2xvcixcbiAgICAgICAgICBzdHlsZSA9IF90aGlzJHByb3BzMi5zdHlsZSxcbiAgICAgICAgICBpbmNsdWRlTWFyZ2luID0gX3RoaXMkcHJvcHMyLmluY2x1ZGVNYXJnaW4sXG4gICAgICAgICAgaW1hZ2VTZXR0aW5ncyA9IF90aGlzJHByb3BzMi5pbWFnZVNldHRpbmdzLFxuICAgICAgICAgIG90aGVyUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkcHJvcHMyLCBbXCJ2YWx1ZVwiLCBcInNpemVcIiwgXCJsZXZlbFwiLCBcImJnQ29sb3JcIiwgXCJmZ0NvbG9yXCIsIFwic3R5bGVcIiwgXCJpbmNsdWRlTWFyZ2luXCIsIFwiaW1hZ2VTZXR0aW5nc1wiXSk7XG5cbiAgICAgIHZhciBjYW52YXNTdHlsZSA9IF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBoZWlnaHQ6IHNpemUsXG4gICAgICAgIHdpZHRoOiBzaXplXG4gICAgICB9LCBzdHlsZSk7XG5cbiAgICAgIHZhciBpbWcgPSBudWxsO1xuICAgICAgdmFyIGltZ1NyYyA9IGltYWdlU2V0dGluZ3MgJiYgaW1hZ2VTZXR0aW5ncy5zcmM7XG5cbiAgICAgIGlmIChpbWFnZVNldHRpbmdzICE9IG51bGwgJiYgaW1nU3JjICE9IG51bGwpIHtcbiAgICAgICAgaW1nID0gUmVhY3QuY3JlYXRlRWxlbWVudChcImltZ1wiLCB7XG4gICAgICAgICAgc3JjOiBpbWdTcmMsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25Mb2FkOiB0aGlzLmhhbmRsZUltYWdlTG9hZCxcbiAgICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihfcmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLl9pbWFnZSA9IF9yZWY7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiwgX2V4dGVuZHMoe1xuICAgICAgICBzdHlsZTogY2FudmFzU3R5bGUsXG4gICAgICAgIGhlaWdodDogc2l6ZSxcbiAgICAgICAgd2lkdGg6IHNpemUsXG4gICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKF9yZWYyKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5fY2FudmFzID0gX3JlZjI7XG4gICAgICAgIH1cbiAgICAgIH0sIG90aGVyUHJvcHMpKSwgaW1nKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUVJDb2RlQ2FudmFzO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KTtcblxuX2RlZmluZVByb3BlcnR5KFFSQ29kZUNhbnZhcywgXCJkZWZhdWx0UHJvcHNcIiwgREVGQVVMVF9QUk9QUyk7XG5cbmlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICBRUkNvZGVDYW52YXMucHJvcFR5cGVzID0gUFJPUF9UWVBFUztcbn1cblxudmFyIFFSQ29kZVNWRyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JFB1cmVDb21wb25lbnQyKSB7XG4gIF9pbmhlcml0cyhRUkNvZGVTVkcsIF9SZWFjdCRQdXJlQ29tcG9uZW50Mik7XG5cbiAgZnVuY3Rpb24gUVJDb2RlU1ZHKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBRUkNvZGVTVkcpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihRUkNvZGVTVkcpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFFSQ29kZVNWRywgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIHZhbHVlID0gX3RoaXMkcHJvcHMzLnZhbHVlLFxuICAgICAgICAgIHNpemUgPSBfdGhpcyRwcm9wczMuc2l6ZSxcbiAgICAgICAgICBsZXZlbCA9IF90aGlzJHByb3BzMy5sZXZlbCxcbiAgICAgICAgICBiZ0NvbG9yID0gX3RoaXMkcHJvcHMzLmJnQ29sb3IsXG4gICAgICAgICAgZmdDb2xvciA9IF90aGlzJHByb3BzMy5mZ0NvbG9yLFxuICAgICAgICAgIGluY2x1ZGVNYXJnaW4gPSBfdGhpcyRwcm9wczMuaW5jbHVkZU1hcmdpbixcbiAgICAgICAgICBpbWFnZVNldHRpbmdzID0gX3RoaXMkcHJvcHMzLmltYWdlU2V0dGluZ3MsXG4gICAgICAgICAgb3RoZXJQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdGhpcyRwcm9wczMsIFtcInZhbHVlXCIsIFwic2l6ZVwiLCBcImxldmVsXCIsIFwiYmdDb2xvclwiLCBcImZnQ29sb3JcIiwgXCJpbmNsdWRlTWFyZ2luXCIsIFwiaW1hZ2VTZXR0aW5nc1wiXSk7IC8vIFdlJ2xsIHVzZSB0eXBlPT09LTEgdG8gZm9yY2UgUVJDb2RlIHRvIGF1dG9tYXRpY2FsbHkgcGljayB0aGUgYmVzdCB0eXBlXG5cblxuICAgICAgdmFyIHFyY29kZSA9IG5ldyBRUkNvZGVJbXBsKC0xLCBFcnJvckNvcnJlY3RMZXZlbFtsZXZlbF0pO1xuICAgICAgcXJjb2RlLmFkZERhdGEoY29udmVydFN0cih2YWx1ZSkpO1xuICAgICAgcXJjb2RlLm1ha2UoKTtcbiAgICAgIHZhciBjZWxscyA9IHFyY29kZS5tb2R1bGVzO1xuXG4gICAgICBpZiAoY2VsbHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXJnaW4gPSBpbmNsdWRlTWFyZ2luID8gTUFSR0lOX1NJWkUgOiAwO1xuICAgICAgdmFyIG51bUNlbGxzID0gY2VsbHMubGVuZ3RoICsgbWFyZ2luICogMjtcbiAgICAgIHZhciBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncyA9IGdldEltYWdlU2V0dGluZ3ModGhpcy5wcm9wcywgY2VsbHMpO1xuICAgICAgdmFyIGltYWdlID0gbnVsbDtcblxuICAgICAgaWYgKGltYWdlU2V0dGluZ3MgIT0gbnVsbCAmJiBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy5leGNhdmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICBjZWxscyA9IGV4Y2F2YXRlTW9kdWxlcyhjZWxscywgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MuZXhjYXZhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpbWFnZSA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbWFnZVwiLCB7XG4gICAgICAgICAgeGxpbmtIcmVmOiBpbWFnZVNldHRpbmdzLnNyYyxcbiAgICAgICAgICBoZWlnaHQ6IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLmgsXG4gICAgICAgICAgd2lkdGg6IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLncsXG4gICAgICAgICAgeDogY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MueCArIG1hcmdpbixcbiAgICAgICAgICB5OiBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy55ICsgbWFyZ2luLFxuICAgICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IFwibm9uZVwiXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBEcmF3aW5nIHN0cmF0ZWd5OiBpbnN0ZWFkIG9mIGEgcmVjdCBwZXIgbW9kdWxlLCB3ZSdyZSBnb2luZyB0byBjcmVhdGUgYVxuICAgICAgLy8gc2luZ2xlIHBhdGggZm9yIHRoZSBkYXJrIG1vZHVsZXMgYW5kIGxheWVyIHRoYXQgb24gdG9wIG9mIGEgbGlnaHQgcmVjdCxcbiAgICAgIC8vIGZvciBhIHRvdGFsIG9mIDIgRE9NIG5vZGVzLiBXZSBwYXkgYSBiaXQgbW9yZSBpbiBzdHJpbmcgY29uY2F0IGJ1dCB0aGF0J3NcbiAgICAgIC8vIHdheSBmYXN0ZXIgdGhhbiBET00gb3BzLlxuICAgICAgLy8gRm9yIGxldmVsIDEsIDQ0MSBub2RlcyAtPiAyXG4gICAgICAvLyBGb3IgbGV2ZWwgNDAsIDMxMzI5IC0+IDJcblxuXG4gICAgICB2YXIgZmdQYXRoID0gZ2VuZXJhdGVQYXRoKGNlbGxzLCBtYXJnaW4pO1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgX2V4dGVuZHMoe1xuICAgICAgICBzaGFwZVJlbmRlcmluZzogXCJjcmlzcEVkZ2VzXCIsXG4gICAgICAgIGhlaWdodDogc2l6ZSxcbiAgICAgICAgd2lkdGg6IHNpemUsXG4gICAgICAgIHZpZXdCb3g6IFwiMCAwIFwiLmNvbmNhdChudW1DZWxscywgXCIgXCIpLmNvbmNhdChudW1DZWxscylcbiAgICAgIH0sIG90aGVyUHJvcHMpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgIGZpbGw6IGJnQ29sb3IsXG4gICAgICAgIGQ6IFwiTTAsMCBoXCIuY29uY2F0KG51bUNlbGxzLCBcInZcIikuY29uY2F0KG51bUNlbGxzLCBcIkgwelwiKVxuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgZmlsbDogZmdDb2xvcixcbiAgICAgICAgZDogZmdQYXRoXG4gICAgICB9KSwgaW1hZ2UpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBRUkNvZGVTVkc7XG59KFJlYWN0LlB1cmVDb21wb25lbnQpO1xuXG5fZGVmaW5lUHJvcGVydHkoUVJDb2RlU1ZHLCBcImRlZmF1bHRQcm9wc1wiLCBERUZBVUxUX1BST1BTKTtcblxuaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFFSQ29kZVNWRy5wcm9wVHlwZXMgPSBQUk9QX1RZUEVTO1xufVxuXG52YXIgUVJDb2RlID0gZnVuY3Rpb24gUVJDb2RlKHByb3BzKSB7XG4gIHZhciByZW5kZXJBcyA9IHByb3BzLnJlbmRlckFzLFxuICAgICAgb3RoZXJQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wicmVuZGVyQXNcIl0pO1xuXG4gIHZhciBDb21wb25lbnQgPSByZW5kZXJBcyA9PT0gJ3N2ZycgPyBRUkNvZGVTVkcgOiBRUkNvZGVDYW52YXM7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgb3RoZXJQcm9wcyk7XG59O1xuXG5RUkNvZGUuZGVmYXVsdFByb3BzID0gX29iamVjdFNwcmVhZCh7XG4gIHJlbmRlckFzOiAnY2FudmFzJ1xufSwgREVGQVVMVF9QUk9QUyk7XG5tb2R1bGUuZXhwb3J0cyA9IFFSQ29kZTsiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgX2luaGVyaXRzTG9vc2UgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c0xvb3NlJykpO1xudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5JykpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdF9fZGVmYXVsdCA9IF9pbnRlcm9wRGVmYXVsdChSZWFjdCk7XG5cbmZ1bmN0aW9uIHdpdGhTaWRlRWZmZWN0KHJlZHVjZVByb3BzVG9TdGF0ZSwgaGFuZGxlU3RhdGVDaGFuZ2VPbkNsaWVudCkge1xuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICh0eXBlb2YgcmVkdWNlUHJvcHNUb1N0YXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHJlZHVjZVByb3BzVG9TdGF0ZSB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFuZGxlU3RhdGVDaGFuZ2VPbkNsaWVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBoYW5kbGVTdGF0ZUNoYW5nZU9uQ2xpZW50IHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUoV3JhcHBlZENvbXBvbmVudCkge1xuICAgIHJldHVybiBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JztcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKFdyYXBwZWRDb21wb25lbnQpIHtcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKHR5cGVvZiBXcmFwcGVkQ29tcG9uZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgV3JhcHBlZENvbXBvbmVudCB0byBiZSBhIFJlYWN0IGNvbXBvbmVudC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbW91bnRlZEluc3RhbmNlcyA9IFtdO1xuICAgIHZhciBzdGF0ZTtcblxuICAgIGZ1bmN0aW9uIGVtaXRDaGFuZ2UoKSB7XG4gICAgICBzdGF0ZSA9IHJlZHVjZVByb3BzVG9TdGF0ZShtb3VudGVkSW5zdGFuY2VzLm1hcChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnByb3BzO1xuICAgICAgfSkpO1xuICAgICAgaGFuZGxlU3RhdGVDaGFuZ2VPbkNsaWVudChzdGF0ZSk7XG4gICAgfVxuXG4gICAgdmFyIFNpZGVFZmZlY3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QdXJlQ29tcG9uZW50KSB7XG4gICAgICBfaW5oZXJpdHNMb29zZShTaWRlRWZmZWN0LCBfUHVyZUNvbXBvbmVudCk7XG5cbiAgICAgIGZ1bmN0aW9uIFNpZGVFZmZlY3QoKSB7XG4gICAgICAgIHJldHVybiBfUHVyZUNvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyeSB0byB1c2UgZGlzcGxheU5hbWUgb2Ygd3JhcHBlZCBjb21wb25lbnRcbiAgICAgIFNpZGVFZmZlY3QucGVlayA9IGZ1bmN0aW9uIHBlZWsoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBfcHJvdG8gPSBTaWRlRWZmZWN0LnByb3RvdHlwZTtcblxuICAgICAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIG1vdW50ZWRJbnN0YW5jZXMucHVzaCh0aGlzKTtcbiAgICAgICAgZW1pdENoYW5nZSgpO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgZW1pdENoYW5nZSgpO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IG1vdW50ZWRJbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgbW91bnRlZEluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBlbWl0Q2hhbmdlKCk7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoV3JhcHBlZENvbXBvbmVudCwgdGhpcy5wcm9wcyk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gU2lkZUVmZmVjdDtcbiAgICB9KFJlYWN0LlB1cmVDb21wb25lbnQpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KFNpZGVFZmZlY3QsIFwiZGlzcGxheU5hbWVcIiwgXCJTaWRlRWZmZWN0KFwiICsgZ2V0RGlzcGxheU5hbWUoV3JhcHBlZENvbXBvbmVudCkgKyBcIilcIik7XG5cbiAgICByZXR1cm4gU2lkZUVmZmVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3aXRoU2lkZUVmZmVjdDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2JhY2tlbmQnKTtcbiIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlJlYWN0RGV2VG9vbHNCYWNrZW5kXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlJlYWN0RGV2VG9vbHNCYWNrZW5kXCJdID0gZmFjdG9yeSgpO1xufSkod2luZG93LCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDI4KTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24ocHJvY2Vzcykgey8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBhbHBoYVNvcnRLZXlzICovXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldEFsbEVudW1lcmFibGVLZXlzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJsXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0V3JhcHBlZERpc3BsYXlOYW1lOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0RGlzcGxheU5hbWU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImtcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRVSUQ7IH0pO1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IHV0ZkRlY29kZVN0cmluZyAqL1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB1dGZFbmNvZGVTdHJpbmc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm1cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwcmludE9wZXJhdGlvbnNBcnJheTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldERlZmF1bHRDb21wb25lbnRGaWx0ZXJzOyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBnZXRTYXZlZENvbXBvbmVudEZpbHRlcnMgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBzZXRTYXZlZENvbXBvbmVudEZpbHRlcnMgKi9cbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2FzdEJvb2w7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjYXN0QnJvd3NlclRoZW1lOyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBnZXRBcHBlbmRDb21wb25lbnRTdGFjayAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IGdldEJyZWFrT25Db25zb2xlRXJyb3JzICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgZ2V0SGlkZUNvbnNvbGVMb2dzSW5TdHJpY3RNb2RlICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgZ2V0U2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgZ2V0RGVmYXVsdE9wZW5JbkVkaXRvclVSTCAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IGdldE9wZW5JbkVkaXRvclVSTCAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IHNlcGFyYXRlRGlzcGxheU5hbWVBbmRIT0NzICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgc2hhbGxvd0RpZmZlcnMgKi9cbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJqXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0SW5PYmplY3Q7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkZWxldGVQYXRoSW5PYmplY3Q7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiByZW5hbWVQYXRoSW5PYmplY3Q7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm9cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzZXRJbk9iamVjdDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldERhdGFUeXBlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0RGlzcGxheU5hbWVGb3JSZWFjdEVsZW1lbnQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmb3JtYXREYXRhRm9yUHJldmlldzsgfSk7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgaXNQbGFpbk9iamVjdCAqL1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGxydV9jYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbHJ1X2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obHJ1X2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHJlYWN0X2lzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHJlYWN0X2lzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ocmVhY3RfaXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgc2hhcmVkX1JlYWN0U3ltYm9sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnN0YW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2h5ZHJhdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2lzQXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cblxuXG5cblxuXG5cblxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGNhY2hlZERpc3BsYXlOYW1lcyA9IG5ldyBXZWFrTWFwKCk7IC8vIE9uIGxhcmdlIHRyZWVzLCBlbmNvZGluZyB0YWtlcyBzaWduaWZpY2FudCB0aW1lLlxuLy8gVHJ5IHRvIHJldXNlIHRoZSBhbHJlYWR5IGVuY29kZWQgc3RyaW5ncy5cblxudmFyIGVuY29kZWRTdHJpbmdDYWNoZSA9IG5ldyBscnVfY2FjaGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEoe1xuICBtYXg6IDEwMDBcbn0pO1xuZnVuY3Rpb24gYWxwaGFTb3J0S2V5cyhhLCBiKSB7XG4gIGlmIChhLnRvU3RyaW5nKCkgPiBiLnRvU3RyaW5nKCkpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChiLnRvU3RyaW5nKCkgPiBhLnRvU3RyaW5nKCkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEFsbEVudW1lcmFibGVLZXlzKG9iaikge1xuICB2YXIga2V5cyA9IG5ldyBTZXQoKTtcbiAgdmFyIGN1cnJlbnQgPSBvYmo7XG5cbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgdmFyIGN1cnJlbnRLZXlzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShPYmplY3Qua2V5cyhjdXJyZW50KSksIF90b0NvbnN1bWFibGVBcnJheShPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGN1cnJlbnQpKSk7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoY3VycmVudCk7XG4gICAgY3VycmVudEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXToga2V5IGNhbiBiZSBhIFN5bWJvbCBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG4gICAgICBpZiAoZGVzY3JpcHRvcnNba2V5XS5lbnVtZXJhYmxlKSB7XG4gICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY3VycmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdXJyZW50KTtcbiAgfTtcblxuICB3aGlsZSAoY3VycmVudCAhPSBudWxsKSB7XG4gICAgX2xvb3AoKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufSAvLyBNaXJyb3IgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvN2MyMWJmNzJhY2U3NzA5NGZkMTkxMGNjMzUwYTU0ODI4N2VmODM1MC9wYWNrYWdlcy9zaGFyZWQvZ2V0Q29tcG9uZW50TmFtZS5qcyNMMjctTDM3XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWREaXNwbGF5TmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUsIGZhbGxiYWNrTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG4gIHJldHVybiBkaXNwbGF5TmFtZSB8fCBcIlwiLmNvbmNhdCh3cmFwcGVyTmFtZSwgXCIoXCIpLmNvbmNhdChnZXREaXNwbGF5TmFtZShpbm5lclR5cGUsIGZhbGxiYWNrTmFtZSksIFwiKVwiKTtcbn1cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKHR5cGUpIHtcbiAgdmFyIGZhbGxiYWNrTmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ0Fub255bW91cyc7XG4gIHZhciBuYW1lRnJvbUNhY2hlID0gY2FjaGVkRGlzcGxheU5hbWVzLmdldCh0eXBlKTtcblxuICBpZiAobmFtZUZyb21DYWNoZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIG5hbWVGcm9tQ2FjaGU7XG4gIH1cblxuICB2YXIgZGlzcGxheU5hbWUgPSBmYWxsYmFja05hbWU7IC8vIFRoZSBkaXNwbGF5TmFtZSBwcm9wZXJ0eSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBhIHN0cmluZy5cbiAgLy8gSXQncyBvbmx5IHNhZmUgdG8gdXNlIGZvciBvdXIgcHVycG9zZXMgaWYgaXQncyBhIHN0cmluZy5cbiAgLy8gZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1kZXZ0b29scy9pc3N1ZXMvODAzXG5cbiAgaWYgKHR5cGVvZiB0eXBlLmRpc3BsYXlOYW1lID09PSAnc3RyaW5nJykge1xuICAgIGRpc3BsYXlOYW1lID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZS5uYW1lID09PSAnc3RyaW5nJyAmJiB0eXBlLm5hbWUgIT09ICcnKSB7XG4gICAgZGlzcGxheU5hbWUgPSB0eXBlLm5hbWU7XG4gIH1cblxuICBjYWNoZWREaXNwbGF5TmFtZXMuc2V0KHR5cGUsIGRpc3BsYXlOYW1lKTtcbiAgcmV0dXJuIGRpc3BsYXlOYW1lO1xufVxudmFyIHVpZENvdW50ZXIgPSAwO1xuZnVuY3Rpb24gZ2V0VUlEKCkge1xuICByZXR1cm4gKyt1aWRDb3VudGVyO1xufVxuZnVuY3Rpb24gdXRmRGVjb2RlU3RyaW5nKGFycmF5KSB7XG4gIC8vIEF2b2lkIHNwcmVhZGluZyB0aGUgYXJyYXkgKGUuZy4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uYXJyYXkpKVxuICAvLyBGdW5jdGlvbnMgYXJndW1lbnRzIGFyZSBmaXJzdCBwbGFjZWQgb24gdGhlIHN0YWNrIGJlZm9yZSB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkXG4gIC8vIHdoaWNoIHRocm93cyBhIFJhbmdlRXJyb3IgZm9yIGxhcmdlIGFycmF5cy5cbiAgLy8gU2VlIGdpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIyMjkzXG4gIHZhciBzdHJpbmcgPSAnJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoYXIgPSBhcnJheVtpXTtcbiAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY2hhcik7XG4gIH1cblxuICByZXR1cm4gc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBzdXJyb2dhdGVQYWlyVG9Db2RlUG9pbnQoY2hhckNvZGUxLCBjaGFyQ29kZTIpIHtcbiAgcmV0dXJuICgoY2hhckNvZGUxICYgMHgzZmYpIDw8IDEwKSArIChjaGFyQ29kZTIgJiAweDNmZikgKyAweDEwMDAwO1xufSAvLyBDcmVkaXQgZm9yIHRoaXMgZW5jb2RpbmcgYXBwcm9hY2ggZ29lcyB0byBUaW0gRG93bjpcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ4NzczMjYvaG93LWNhbi1pLXRlbGwtaWYtYS1zdHJpbmctY29udGFpbnMtbXVsdGlieXRlLWNoYXJhY3RlcnMtaW4tamF2YXNjcmlwdFxuXG5cbmZ1bmN0aW9uIHV0ZkVuY29kZVN0cmluZyhzdHJpbmcpIHtcbiAgdmFyIGNhY2hlZCA9IGVuY29kZWRTdHJpbmdDYWNoZS5nZXQoc3RyaW5nKTtcblxuICBpZiAoY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG5cbiAgdmFyIGVuY29kZWQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgY2hhckNvZGU7XG5cbiAgd2hpbGUgKGkgPCBzdHJpbmcubGVuZ3RoKSB7XG4gICAgY2hhckNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTsgLy8gSGFuZGxlIG11bHRpYnl0ZSB1bmljb2RlIGNoYXJhY3RlcnMgKGxpa2UgZW1vamkpLlxuXG4gICAgaWYgKChjaGFyQ29kZSAmIDB4ZjgwMCkgPT09IDB4ZDgwMCkge1xuICAgICAgZW5jb2RlZC5wdXNoKHN1cnJvZ2F0ZVBhaXJUb0NvZGVQb2ludChjaGFyQ29kZSwgc3RyaW5nLmNoYXJDb2RlQXQoKytpKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGVkLnB1c2goY2hhckNvZGUpO1xuICAgIH1cblxuICAgICsraTtcbiAgfVxuXG4gIGVuY29kZWRTdHJpbmdDYWNoZS5zZXQoc3RyaW5nLCBlbmNvZGVkKTtcbiAgcmV0dXJuIGVuY29kZWQ7XG59XG5mdW5jdGlvbiBwcmludE9wZXJhdGlvbnNBcnJheShvcGVyYXRpb25zKSB7XG4gIC8vIFRoZSBmaXJzdCB0d28gdmFsdWVzIGFyZSBhbHdheXMgcmVuZGVyZXJJRCBhbmQgcm9vdElEXG4gIHZhciByZW5kZXJlcklEID0gb3BlcmF0aW9uc1swXTtcbiAgdmFyIHJvb3RJRCA9IG9wZXJhdGlvbnNbMV07XG4gIHZhciBsb2dzID0gW1wib3BlcmF0aW9ucyBmb3IgcmVuZGVyZXI6XCIuY29uY2F0KHJlbmRlcmVySUQsIFwiIGFuZCByb290OlwiKS5jb25jYXQocm9vdElEKV07XG4gIHZhciBpID0gMjsgLy8gUmVhc3NlbWJsZSB0aGUgc3RyaW5nIHRhYmxlLlxuXG4gIHZhciBzdHJpbmdUYWJsZSA9IFtudWxsIC8vIElEID0gMCBjb3JyZXNwb25kcyB0byB0aGUgbnVsbCBzdHJpbmcuXG4gIF07XG4gIHZhciBzdHJpbmdUYWJsZVNpemUgPSBvcGVyYXRpb25zW2krK107XG4gIHZhciBzdHJpbmdUYWJsZUVuZCA9IGkgKyBzdHJpbmdUYWJsZVNpemU7XG5cbiAgd2hpbGUgKGkgPCBzdHJpbmdUYWJsZUVuZCkge1xuICAgIHZhciBuZXh0TGVuZ3RoID0gb3BlcmF0aW9uc1tpKytdO1xuICAgIHZhciBuZXh0U3RyaW5nID0gdXRmRGVjb2RlU3RyaW5nKG9wZXJhdGlvbnMuc2xpY2UoaSwgaSArIG5leHRMZW5ndGgpKTtcbiAgICBzdHJpbmdUYWJsZS5wdXNoKG5leHRTdHJpbmcpO1xuICAgIGkgKz0gbmV4dExlbmd0aDtcbiAgfVxuXG4gIHdoaWxlIChpIDwgb3BlcmF0aW9ucy5sZW5ndGgpIHtcbiAgICB2YXIgb3BlcmF0aW9uID0gb3BlcmF0aW9uc1tpXTtcblxuICAgIHN3aXRjaCAob3BlcmF0aW9uKSB7XG4gICAgICBjYXNlIF9jb25zdGFudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBUUkVFX09QRVJBVElPTl9BREQgKi8gXCJsXCJdOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9pZCA9IG9wZXJhdGlvbnNbaSArIDFdO1xuICAgICAgICAgIHZhciB0eXBlID0gb3BlcmF0aW9uc1tpICsgMl07XG4gICAgICAgICAgaSArPSAzO1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT09IF90eXBlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIEVsZW1lbnRUeXBlUm9vdCAqLyBcIm1cIl0pIHtcbiAgICAgICAgICAgIGxvZ3MucHVzaChcIkFkZCBuZXcgcm9vdCBub2RlIFwiLmNvbmNhdChfaWQpKTtcbiAgICAgICAgICAgIGkrKzsgLy8gaXNTdHJpY3RNb2RlQ29tcGxpYW50XG5cbiAgICAgICAgICAgIGkrKzsgLy8gc3VwcG9ydHNQcm9maWxpbmdcblxuICAgICAgICAgICAgaSsrOyAvLyBzdXBwb3J0c1N0cmljdE1vZGVcblxuICAgICAgICAgICAgaSsrOyAvLyBoYXNPd25lck1ldGFkYXRhXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRJRCA9IG9wZXJhdGlvbnNbaV07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBpKys7IC8vIG93bmVySURcblxuICAgICAgICAgICAgdmFyIGRpc3BsYXlOYW1lU3RyaW5nSUQgPSBvcGVyYXRpb25zW2ldO1xuICAgICAgICAgICAgdmFyIGRpc3BsYXlOYW1lID0gc3RyaW5nVGFibGVbZGlzcGxheU5hbWVTdHJpbmdJRF07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBpKys7IC8vIGtleVxuXG4gICAgICAgICAgICBsb2dzLnB1c2goXCJBZGQgbm9kZSBcIi5jb25jYXQoX2lkLCBcIiAoXCIpLmNvbmNhdChkaXNwbGF5TmFtZSB8fCAnbnVsbCcsIFwiKSBhcyBjaGlsZCBvZiBcIikuY29uY2F0KHBhcmVudElEKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBfY29uc3RhbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogVFJFRV9PUEVSQVRJT05fUkVNT1ZFICovIFwibVwiXTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciByZW1vdmVMZW5ndGggPSBvcGVyYXRpb25zW2kgKyAxXTtcbiAgICAgICAgICBpICs9IDI7XG5cbiAgICAgICAgICBmb3IgKHZhciByZW1vdmVJbmRleCA9IDA7IHJlbW92ZUluZGV4IDwgcmVtb3ZlTGVuZ3RoOyByZW1vdmVJbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgX2lkMiA9IG9wZXJhdGlvbnNbaV07XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICBsb2dzLnB1c2goXCJSZW1vdmUgbm9kZSBcIi5jb25jYXQoX2lkMikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgX2NvbnN0YW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIFRSRUVfT1BFUkFUSU9OX1JFTU9WRV9ST09UICovIFwiblwiXTpcbiAgICAgICAge1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICBsb2dzLnB1c2goXCJSZW1vdmUgcm9vdCBcIi5jb25jYXQocm9vdElEKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBfY29uc3RhbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogVFJFRV9PUEVSQVRJT05fU0VUX1NVQlRSRUVfTU9ERSAqLyBcInBcIl06XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2lkMyA9IG9wZXJhdGlvbnNbaSArIDFdO1xuICAgICAgICAgIHZhciBtb2RlID0gb3BlcmF0aW9uc1tpICsgMV07XG4gICAgICAgICAgaSArPSAzO1xuICAgICAgICAgIGxvZ3MucHVzaChcIk1vZGUgXCIuY29uY2F0KG1vZGUsIFwiIHNldCBmb3Igc3VidHJlZSB3aXRoIHJvb3QgXCIpLmNvbmNhdChfaWQzKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBfY29uc3RhbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogVFJFRV9PUEVSQVRJT05fUkVPUkRFUl9DSElMRFJFTiAqLyBcIm9cIl06XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2lkNCA9IG9wZXJhdGlvbnNbaSArIDFdO1xuICAgICAgICAgIHZhciBudW1DaGlsZHJlbiA9IG9wZXJhdGlvbnNbaSArIDJdO1xuICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBvcGVyYXRpb25zLnNsaWNlKGksIGkgKyBudW1DaGlsZHJlbik7XG4gICAgICAgICAgaSArPSBudW1DaGlsZHJlbjtcbiAgICAgICAgICBsb2dzLnB1c2goXCJSZS1vcmRlciBub2RlIFwiLmNvbmNhdChfaWQ0LCBcIiBjaGlsZHJlbiBcIikuY29uY2F0KGNoaWxkcmVuLmpvaW4oJywnKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgX2NvbnN0YW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIFRSRUVfT1BFUkFUSU9OX1VQREFURV9UUkVFX0JBU0VfRFVSQVRJT04gKi8gXCJyXCJdOlxuICAgICAgICAvLyBCYXNlIGR1cmF0aW9uIHVwZGF0ZXMgYXJlIG9ubHkgc2VudCB3aGlsZSBwcm9maWxpbmcgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICAgIC8vIFdlIGNhbiBpZ25vcmUgdGhlbSBhdCB0aGlzIHBvaW50LlxuICAgICAgICAvLyBUaGUgcHJvZmlsZXIgVUkgdXNlcyB0aGVtIGxhemlseSBpbiBvcmRlciB0byBnZW5lcmF0ZSB0aGUgdHJlZS5cbiAgICAgICAgaSArPSAzO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBfY29uc3RhbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogVFJFRV9PUEVSQVRJT05fVVBEQVRFX0VSUk9SU19PUl9XQVJOSU5HUyAqLyBcInFcIl06XG4gICAgICAgIHZhciBpZCA9IG9wZXJhdGlvbnNbaSArIDFdO1xuICAgICAgICB2YXIgbnVtRXJyb3JzID0gb3BlcmF0aW9uc1tpICsgMl07XG4gICAgICAgIHZhciBudW1XYXJuaW5ncyA9IG9wZXJhdGlvbnNbaSArIDNdO1xuICAgICAgICBpICs9IDQ7XG4gICAgICAgIGxvZ3MucHVzaChcIk5vZGUgXCIuY29uY2F0KGlkLCBcIiBoYXMgXCIpLmNvbmNhdChudW1FcnJvcnMsIFwiIGVycm9ycyBhbmQgXCIpLmNvbmNhdChudW1XYXJuaW5ncywgXCIgd2FybmluZ3NcIikpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJVbnN1cHBvcnRlZCBCcmlkZ2Ugb3BlcmF0aW9uIFxcXCJcIi5jb25jYXQob3BlcmF0aW9uLCBcIlxcXCJcIikpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnNvbGUubG9nKGxvZ3Muam9pbignXFxuICAnKSk7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0Q29tcG9uZW50RmlsdGVycygpIHtcbiAgcmV0dXJuIFt7XG4gICAgdHlwZTogX3R5cGVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogQ29tcG9uZW50RmlsdGVyRWxlbWVudFR5cGUgKi8gXCJiXCJdLFxuICAgIHZhbHVlOiBfdHlwZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBFbGVtZW50VHlwZUhvc3RDb21wb25lbnQgKi8gXCJpXCJdLFxuICAgIGlzRW5hYmxlZDogdHJ1ZVxuICB9XTtcbn1cbmZ1bmN0aW9uIGdldFNhdmVkQ29tcG9uZW50RmlsdGVycygpIHtcbiAgdHJ5IHtcbiAgICB2YXIgcmF3ID0gT2JqZWN0KF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogbG9jYWxTdG9yYWdlR2V0SXRlbSAqLyBcImFcIl0pKF9jb25zdGFudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBMT0NBTF9TVE9SQUdFX0NPTVBPTkVOVF9GSUxURVJfUFJFRkVSRU5DRVNfS0VZICovIFwiYVwiXSk7XG5cbiAgICBpZiAocmF3ICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHJhdyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge31cblxuICByZXR1cm4gZ2V0RGVmYXVsdENvbXBvbmVudEZpbHRlcnMoKTtcbn1cbmZ1bmN0aW9uIHNldFNhdmVkQ29tcG9uZW50RmlsdGVycyhjb21wb25lbnRGaWx0ZXJzKSB7XG4gIE9iamVjdChfc3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGxvY2FsU3RvcmFnZVNldEl0ZW0gKi8gXCJiXCJdKShfY29uc3RhbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogTE9DQUxfU1RPUkFHRV9DT01QT05FTlRfRklMVEVSX1BSRUZFUkVOQ0VTX0tFWSAqLyBcImFcIl0sIEpTT04uc3RyaW5naWZ5KGNvbXBvbmVudEZpbHRlcnMpKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VCb29sKHMpIHtcbiAgaWYgKHMgPT09ICd0cnVlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHMgPT09ICdmYWxzZScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FzdEJvb2wodikge1xuICBpZiAodiA9PT0gdHJ1ZSB8fCB2ID09PSBmYWxzZSkge1xuICAgIHJldHVybiB2O1xuICB9XG59XG5mdW5jdGlvbiBjYXN0QnJvd3NlclRoZW1lKHYpIHtcbiAgaWYgKHYgPT09ICdsaWdodCcgfHwgdiA9PT0gJ2RhcmsnIHx8IHYgPT09ICdhdXRvJykge1xuICAgIHJldHVybiB2O1xuICB9XG59XG5mdW5jdGlvbiBnZXRBcHBlbmRDb21wb25lbnRTdGFjaygpIHtcbiAgdmFyIF9wYXJzZUJvb2w7XG5cbiAgdmFyIHJhdyA9IE9iamVjdChfc3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGxvY2FsU3RvcmFnZUdldEl0ZW0gKi8gXCJhXCJdKShfY29uc3RhbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogTE9DQUxfU1RPUkFHRV9TSE9VTERfQVBQRU5EX0NPTVBPTkVOVF9TVEFDS19LRVkgKi8gXCJkXCJdKTtcbiAgcmV0dXJuIChfcGFyc2VCb29sID0gcGFyc2VCb29sKHJhdykpICE9PSBudWxsICYmIF9wYXJzZUJvb2wgIT09IHZvaWQgMCA/IF9wYXJzZUJvb2wgOiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0QnJlYWtPbkNvbnNvbGVFcnJvcnMoKSB7XG4gIHZhciBfcGFyc2VCb29sMjtcblxuICB2YXIgcmF3ID0gT2JqZWN0KF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogbG9jYWxTdG9yYWdlR2V0SXRlbSAqLyBcImFcIl0pKF9jb25zdGFudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBMT0NBTF9TVE9SQUdFX1NIT1VMRF9CUkVBS19PTl9DT05TT0xFX0VSUk9SUyAqLyBcImVcIl0pO1xuICByZXR1cm4gKF9wYXJzZUJvb2wyID0gcGFyc2VCb29sKHJhdykpICE9PSBudWxsICYmIF9wYXJzZUJvb2wyICE9PSB2b2lkIDAgPyBfcGFyc2VCb29sMiA6IGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0SGlkZUNvbnNvbGVMb2dzSW5TdHJpY3RNb2RlKCkge1xuICB2YXIgX3BhcnNlQm9vbDM7XG5cbiAgdmFyIHJhdyA9IE9iamVjdChfc3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGxvY2FsU3RvcmFnZUdldEl0ZW0gKi8gXCJhXCJdKShfY29uc3RhbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogTE9DQUxfU1RPUkFHRV9ISURFX0NPTlNPTEVfTE9HU19JTl9TVFJJQ1RfTU9ERSAqLyBcImJcIl0pO1xuICByZXR1cm4gKF9wYXJzZUJvb2wzID0gcGFyc2VCb29sKHJhdykpICE9PSBudWxsICYmIF9wYXJzZUJvb2wzICE9PSB2b2lkIDAgPyBfcGFyc2VCb29sMyA6IGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0U2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzKCkge1xuICB2YXIgX3BhcnNlQm9vbDQ7XG5cbiAgdmFyIHJhdyA9IE9iamVjdChfc3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGxvY2FsU3RvcmFnZUdldEl0ZW0gKi8gXCJhXCJdKShfY29uc3RhbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogTE9DQUxfU1RPUkFHRV9TSE9XX0lOTElORV9XQVJOSU5HU19BTkRfRVJST1JTX0tFWSAqLyBcImZcIl0pO1xuICByZXR1cm4gKF9wYXJzZUJvb2w0ID0gcGFyc2VCb29sKHJhdykpICE9PSBudWxsICYmIF9wYXJzZUJvb2w0ICE9PSB2b2lkIDAgPyBfcGFyc2VCb29sNCA6IHRydWU7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0T3BlbkluRWRpdG9yVVJMKCkge1xuICByZXR1cm4gdHlwZW9mIFwiXCIgPT09ICdzdHJpbmcnID8gXCJcIiA6ICcnO1xufVxuZnVuY3Rpb24gZ2V0T3BlbkluRWRpdG9yVVJMKCkge1xuICB0cnkge1xuICAgIHZhciByYXcgPSBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBsb2NhbFN0b3JhZ2VHZXRJdGVtICovIFwiYVwiXSkoX2NvbnN0YW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIExPQ0FMX1NUT1JBR0VfT1BFTl9JTl9FRElUT1JfVVJMICovIFwiY1wiXSk7XG5cbiAgICBpZiAocmF3ICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHJhdyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge31cblxuICByZXR1cm4gZ2V0RGVmYXVsdE9wZW5JbkVkaXRvclVSTCgpO1xufVxuZnVuY3Rpb24gc2VwYXJhdGVEaXNwbGF5TmFtZUFuZEhPQ3MoZGlzcGxheU5hbWUsIHR5cGUpIHtcbiAgaWYgKGRpc3BsYXlOYW1lID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgfVxuXG4gIHZhciBob2NEaXNwbGF5TmFtZXMgPSBudWxsO1xuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgX3R5cGVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogRWxlbWVudFR5cGVDbGFzcyAqLyBcImVcIl06XG4gICAgY2FzZSBfdHlwZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBFbGVtZW50VHlwZUZvcndhcmRSZWYgKi8gXCJnXCJdOlxuICAgIGNhc2UgX3R5cGVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogRWxlbWVudFR5cGVGdW5jdGlvbiAqLyBcImhcIl06XG4gICAgY2FzZSBfdHlwZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBFbGVtZW50VHlwZU1lbW8gKi8gXCJqXCJdOlxuICAgICAgaWYgKGRpc3BsYXlOYW1lLmluZGV4T2YoJygnKSA+PSAwKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gZGlzcGxheU5hbWUubWF0Y2goL1teKCldKy9nKTtcblxuICAgICAgICBpZiAobWF0Y2hlcyAhPSBudWxsKSB7XG4gICAgICAgICAgZGlzcGxheU5hbWUgPSBtYXRjaGVzLnBvcCgpO1xuICAgICAgICAgIGhvY0Rpc3BsYXlOYW1lcyA9IG1hdGNoZXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gW2Rpc3BsYXlOYW1lLCBob2NEaXNwbGF5TmFtZXNdO1xufSAvLyBQdWxsZWQgZnJvbSByZWFjdC1jb21wYXRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZlbG9waXQvcHJlYWN0LWNvbXBhdC9ibG9iLzdjNWRlMDBlN2M4NWUyZmZkMDExYmYzYWYwMjg5OWI2M2Y2OTlkM2Evc3JjL2luZGV4LmpzI0wzNDlcblxuZnVuY3Rpb24gc2hhbGxvd0RpZmZlcnMocHJldiwgbmV4dCkge1xuICBmb3IgKHZhciBhdHRyaWJ1dGUgaW4gcHJldikge1xuICAgIGlmICghKGF0dHJpYnV0ZSBpbiBuZXh0KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX2F0dHJpYnV0ZSBpbiBuZXh0KSB7XG4gICAgaWYgKHByZXZbX2F0dHJpYnV0ZV0gIT09IG5leHRbX2F0dHJpYnV0ZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldEluT2JqZWN0KG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKHJlZHVjZWQsIGF0dHIpIHtcbiAgICBpZiAocmVkdWNlZCkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVkdWNlZCwgYXR0cikpIHtcbiAgICAgICAgcmV0dXJuIHJlZHVjZWRbYXR0cl07XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgcmVkdWNlZFtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIENvbnZlcnQgaXRlcmFibGUgdG8gYXJyYXkgYW5kIHJldHVybiBhcnJheVtpbmRleF1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVFJJQ0tZXG4gICAgICAgIC8vIERvbid0IHVzZSBbLi4uc3ByZWFkXSBzeW50YXggZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgLy8gVGhpcyBwcm9qZWN0IHVzZXMgQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tc3ByZWFkIGluIFwibG9vc2VcIiBtb2RlIHdoaWNoIG9ubHkgd29ya3Mgd2l0aCBBcnJheSB2YWx1ZXMuXG4gICAgICAgIC8vIE90aGVyIHR5cGVzIChlLmcuIHR5cGVkIGFycmF5cywgU2V0cykgd2lsbCBub3Qgc3ByZWFkIGNvcnJlY3RseS5cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ocmVkdWNlZClbYXR0cl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sIG9iamVjdCk7XG59XG5mdW5jdGlvbiBkZWxldGVQYXRoSW5PYmplY3Qob2JqZWN0LCBwYXRoKSB7XG4gIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgdmFyIGxhc3QgPSBwYXRoW2xlbmd0aCAtIDFdO1xuXG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIHZhciBwYXJlbnQgPSBnZXRJbk9iamVjdChvYmplY3QsIHBhdGguc2xpY2UoMCwgbGVuZ3RoIC0gMSkpO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgaWYgKE9iamVjdChfaXNBcnJheV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKShwYXJlbnQpKSB7XG4gICAgICAgIHBhcmVudC5zcGxpY2UobGFzdCwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgcGFyZW50W2xhc3RdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVuYW1lUGF0aEluT2JqZWN0KG9iamVjdCwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICB2YXIgbGVuZ3RoID0gb2xkUGF0aC5sZW5ndGg7XG5cbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgdmFyIHBhcmVudCA9IGdldEluT2JqZWN0KG9iamVjdCwgb2xkUGF0aC5zbGljZSgwLCBsZW5ndGggLSAxKSk7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICB2YXIgbGFzdE9sZCA9IG9sZFBhdGhbbGVuZ3RoIC0gMV07XG4gICAgICB2YXIgbGFzdE5ldyA9IG5ld1BhdGhbbGVuZ3RoIC0gMV07XG4gICAgICBwYXJlbnRbbGFzdE5ld10gPSBwYXJlbnRbbGFzdE9sZF07XG5cbiAgICAgIGlmIChPYmplY3QoX2lzQXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkocGFyZW50KSkge1xuICAgICAgICBwYXJlbnQuc3BsaWNlKGxhc3RPbGQsIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHBhcmVudFtsYXN0T2xkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEluT2JqZWN0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcbiAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICB2YXIgbGFzdCA9IHBhdGhbbGVuZ3RoIC0gMV07XG5cbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgdmFyIHBhcmVudCA9IGdldEluT2JqZWN0KG9iamVjdCwgcGF0aC5zbGljZSgwLCBsZW5ndGggLSAxKSk7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnRbbGFzdF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYSBlbmhhbmNlZC9hcnRpZmljaWFsIHR5cGUgc3RyaW5nIGJhc2VkIG9uIHRoZSBvYmplY3QgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gZ2V0RGF0YVR5cGUoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnbnVsbCc7XG4gIH0gZWxzZSBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICB9XG5cbiAgaWYgKE9iamVjdChyZWFjdF9pc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiaXNFbGVtZW50XCJdKShkYXRhKSkge1xuICAgIHJldHVybiAncmVhY3RfZWxlbWVudCc7XG4gIH1cblxuICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICByZXR1cm4gJ2h0bWxfZWxlbWVudCc7XG4gIH1cblxuICB2YXIgdHlwZSA9IF90eXBlb2YoZGF0YSk7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYmlnaW50JzpcbiAgICAgIHJldHVybiAnYmlnaW50JztcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuICdib29sZWFuJztcblxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiAnZnVuY3Rpb24nO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4oZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuICduYW4nO1xuICAgICAgfSBlbHNlIGlmICghTnVtYmVyLmlzRmluaXRlKGRhdGEpKSB7XG4gICAgICAgIHJldHVybiAnaW5maW5pdHknO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdudW1iZXInO1xuICAgICAgfVxuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChPYmplY3QoX2lzQXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLmNvbnN0cnVjdG9yLCAnQllURVNfUEVSX0VMRU1FTlQnKSA/ICd0eXBlZF9hcnJheScgOiAnZGF0YV92aWV3JztcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS5jb25zdHJ1Y3RvciAmJiBkYXRhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBcnJheUJ1ZmZlcicpIHtcbiAgICAgICAgLy8gSEFDSyBUaGlzIEFycmF5QnVmZmVyIGNoZWNrIGlzIGdyb3NzOyBpcyB0aGVyZSBhIGJldHRlciB3YXk/XG4gICAgICAgIC8vIFdlIGNvdWxkIHRyeSB0byBjcmVhdGUgYSBuZXcgRGF0YVZpZXcgd2l0aCB0aGUgdmFsdWUuXG4gICAgICAgIC8vIElmIGl0IGRvZXNuJ3QgZXJyb3IsIHdlIGtub3cgaXQncyBhbiBBcnJheUJ1ZmZlcixcbiAgICAgICAgLy8gYnV0IHRoaXMgc2VlbXMga2luZCBvZiBhd2t3YXJkIGFuZCBleHBlbnNpdmUuXG4gICAgICAgIHJldHVybiAnYXJyYXlfYnVmZmVyJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGFbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBkYXRhW1N5bWJvbC5pdGVyYXRvcl0oKTtcblxuICAgICAgICBpZiAoIWl0ZXJhdG9yKSB7Ly8gUHJveGllcyBtaWdodCBicmVhayBhc3N1bXB0b2lucyBhYm91dCBpdGVyYXRvcnMuXG4gICAgICAgICAgLy8gU2VlIGdpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIxNjU0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yID09PSBkYXRhID8gJ29wYXF1ZV9pdGVyYXRvcicgOiAnaXRlcmF0b3InO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEuY29uc3RydWN0b3IgJiYgZGF0YS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnUmVnRXhwJykge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gICAgICAgIHZhciB0b1N0cmluZ1ZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpO1xuXG4gICAgICAgIGlmICh0b1N0cmluZ1ZhbHVlID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IEhUTUxBbGxDb2xsZWN0aW9uXScpIHtcbiAgICAgICAgICByZXR1cm4gJ2h0bWxfYWxsX2NvbGxlY3Rpb24nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgICByZXR1cm4gJ2NsYXNzX2luc3RhbmNlJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiAnc3RyaW5nJztcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG5cbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgaWYgKCAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEhUTUxBbGxDb2xsZWN0aW9uXScpIHtcbiAgICAgICAgcmV0dXJuICdodG1sX2FsbF9jb2xsZWN0aW9uJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAndW5rbm93bic7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lRm9yUmVhY3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgdmFyIGVsZW1lbnRUeXBlID0gT2JqZWN0KHJlYWN0X2lzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJ0eXBlT2ZcIl0pKGVsZW1lbnQpO1xuXG4gIHN3aXRjaCAoZWxlbWVudFR5cGUpIHtcbiAgICBjYXNlIHJlYWN0X2lzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJDb250ZXh0Q29uc3VtZXJcIl06XG4gICAgICByZXR1cm4gJ0NvbnRleHRDb25zdW1lcic7XG5cbiAgICBjYXNlIHJlYWN0X2lzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJDb250ZXh0UHJvdmlkZXJcIl06XG4gICAgICByZXR1cm4gJ0NvbnRleHRQcm92aWRlcic7XG5cbiAgICBjYXNlIHJlYWN0X2lzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJGb3J3YXJkUmVmXCJdOlxuICAgICAgcmV0dXJuICdGb3J3YXJkUmVmJztcblxuICAgIGNhc2UgcmVhY3RfaXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkZyYWdtZW50XCJdOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIHJlYWN0X2lzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJMYXp5XCJdOlxuICAgICAgcmV0dXJuICdMYXp5JztcblxuICAgIGNhc2UgcmVhY3RfaXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIk1lbW9cIl06XG4gICAgICByZXR1cm4gJ01lbW8nO1xuXG4gICAgY2FzZSByZWFjdF9pc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiUG9ydGFsXCJdOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSByZWFjdF9pc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiUHJvZmlsZXJcIl06XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgcmVhY3RfaXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0cmljdE1vZGVcIl06XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSByZWFjdF9pc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3VzcGVuc2VcIl06XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2Ugc2hhcmVkX1JlYWN0U3ltYm9sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSAqLyBcImFcIl06XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgICBjYXNlIHNoYXJlZF9SZWFjdFN5bWJvbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBSRUFDVF9UUkFDSU5HX01BUktFUl9UWVBFICovIFwiYlwiXTpcbiAgICAgIHJldHVybiAnVHJhY2luZ01hcmtlcic7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNwbGF5TmFtZSh0eXBlLCAnQW5vbnltb3VzJyk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ05vdEltcGxlbWVudGVkSW5EZXZ0b29scyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ0VsZW1lbnQnO1xuICAgICAgfVxuXG4gIH1cbn1cbnZhciBNQVhfUFJFVklFV19TVFJJTkdfTEVOR1RIID0gNTA7XG5cbmZ1bmN0aW9uIHRydW5jYXRlRm9yRGlzcGxheShzdHJpbmcpIHtcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogTUFYX1BSRVZJRVdfU1RSSU5HX0xFTkdUSDtcblxuICBpZiAoc3RyaW5nLmxlbmd0aCA+IGxlbmd0aCkge1xuICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgbGVuZ3RoKSArICfigKYnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cbn0gLy8gQXR0ZW1wdHMgdG8gbWltaWMgQ2hyb21lJ3MgaW5saW5lIHByZXZpZXcgZm9yIHZhbHVlcy5cbi8vIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIHZhbHVlLi4uXG4vLyAgIHtcbi8vICAgICAgZm9vOiAxMjMsXG4vLyAgICAgIGJhcjogXCJhYmNcIixcbi8vICAgICAgYmF6OiBbdHJ1ZSwgZmFsc2VdLFxuLy8gICAgICBxdXg6IHsgYWI6IDEsIGNkOiAyIH1cbi8vICAgfTtcbi8vXG4vLyBXb3VsZCBzaG93IGEgcHJldmlldyBvZi4uLlxuLy8gICB7Zm9vOiAxMjMsIGJhcjogXCJhYmNcIiwgYmF6OiBBcnJheSgyKSwgcXV4OiB74oCmfX1cbi8vXG4vLyBBbmQgdGhlIGZvbGxvd2luZyB2YWx1ZS4uLlxuLy8gICBbXG4vLyAgICAgMTIzLFxuLy8gICAgIFwiYWJjXCIsXG4vLyAgICAgW3RydWUsIGZhbHNlXSxcbi8vICAgICB7IGZvbzogMTIzLCBiYXI6IFwiYWJjXCIgfVxuLy8gICBdO1xuLy9cbi8vIFdvdWxkIHNob3cgYSBwcmV2aWV3IG9mLi4uXG4vLyAgIFsxMjMsIFwiYWJjXCIsIEFycmF5KDIpLCB74oCmfV1cblxuXG5mdW5jdGlvbiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCBzaG93Rm9ybWF0dGVkVmFsdWUpIHtcbiAgaWYgKGRhdGEgIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIF9oeWRyYXRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1svKiBtZXRhICovIFwiYlwiXS50eXBlKSkge1xuICAgIHJldHVybiBzaG93Rm9ybWF0dGVkVmFsdWUgPyBkYXRhW19oeWRyYXRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1svKiBtZXRhICovIFwiYlwiXS5wcmV2aWV3X2xvbmddIDogZGF0YVtfaHlkcmF0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogbWV0YSAqLyBcImJcIl0ucHJldmlld19zaG9ydF07XG4gIH1cblxuICB2YXIgdHlwZSA9IGdldERhdGFUeXBlKGRhdGEpO1xuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2h0bWxfZWxlbWVudCc6XG4gICAgICByZXR1cm4gXCI8XCIuY29uY2F0KHRydW5jYXRlRm9yRGlzcGxheShkYXRhLnRhZ05hbWUudG9Mb3dlckNhc2UoKSksIFwiIC8+XCIpO1xuXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIHRydW5jYXRlRm9yRGlzcGxheShcIlxcdTAxOTIgXCIuY29uY2F0KHR5cGVvZiBkYXRhLm5hbWUgPT09ICdmdW5jdGlvbicgPyAnJyA6IGRhdGEubmFtZSwgXCIoKSB7fVwiKSk7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdChkYXRhLCBcIlxcXCJcIik7XG5cbiAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgcmV0dXJuIHRydW5jYXRlRm9yRGlzcGxheShkYXRhLnRvU3RyaW5nKCkgKyAnbicpO1xuXG4gICAgY2FzZSAncmVnZXhwJzpcbiAgICAgIHJldHVybiB0cnVuY2F0ZUZvckRpc3BsYXkoZGF0YS50b1N0cmluZygpKTtcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm4gdHJ1bmNhdGVGb3JEaXNwbGF5KGRhdGEudG9TdHJpbmcoKSk7XG5cbiAgICBjYXNlICdyZWFjdF9lbGVtZW50JzpcbiAgICAgIHJldHVybiBcIjxcIi5jb25jYXQodHJ1bmNhdGVGb3JEaXNwbGF5KGdldERpc3BsYXlOYW1lRm9yUmVhY3RFbGVtZW50KGRhdGEpIHx8ICdVbmtub3duJyksIFwiIC8+XCIpO1xuXG4gICAgY2FzZSAnYXJyYXlfYnVmZmVyJzpcbiAgICAgIHJldHVybiBcIkFycmF5QnVmZmVyKFwiLmNvbmNhdChkYXRhLmJ5dGVMZW5ndGgsIFwiKVwiKTtcblxuICAgIGNhc2UgJ2RhdGFfdmlldyc6XG4gICAgICByZXR1cm4gXCJEYXRhVmlldyhcIi5jb25jYXQoZGF0YS5idWZmZXIuYnl0ZUxlbmd0aCwgXCIpXCIpO1xuXG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgaWYgKHNob3dGb3JtYXR0ZWRWYWx1ZSkge1xuICAgICAgICB2YXIgZm9ybWF0dGVkID0gJyc7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWQgKz0gJywgJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3JtYXR0ZWQgKz0gZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YVtpXSwgZmFsc2UpO1xuXG4gICAgICAgICAgaWYgKGZvcm1hdHRlZC5sZW5ndGggPiBNQVhfUFJFVklFV19TVFJJTkdfTEVOR1RIKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGRvaW5nIGEgbG90IG9mIHVubmVjZXNzYXJ5IGl0ZXJhdGlvbi4uLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwiW1wiLmNvbmNhdCh0cnVuY2F0ZUZvckRpc3BsYXkoZm9ybWF0dGVkKSwgXCJdXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgX2h5ZHJhdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fWy8qIG1ldGEgKi8gXCJiXCJdLnNpemUpID8gZGF0YVtfaHlkcmF0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogbWV0YSAqLyBcImJcIl0uc2l6ZV0gOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIFwiQXJyYXkoXCIuY29uY2F0KGxlbmd0aCwgXCIpXCIpO1xuICAgICAgfVxuXG4gICAgY2FzZSAndHlwZWRfYXJyYXknOlxuICAgICAgdmFyIHNob3J0TmFtZSA9IFwiXCIuY29uY2F0KGRhdGEuY29uc3RydWN0b3IubmFtZSwgXCIoXCIpLmNvbmNhdChkYXRhLmxlbmd0aCwgXCIpXCIpO1xuXG4gICAgICBpZiAoc2hvd0Zvcm1hdHRlZFZhbHVlKSB7XG4gICAgICAgIHZhciBfZm9ybWF0dGVkID0gJyc7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGRhdGEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgaWYgKF9pID4gMCkge1xuICAgICAgICAgICAgX2Zvcm1hdHRlZCArPSAnLCAnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9mb3JtYXR0ZWQgKz0gZGF0YVtfaV07XG5cbiAgICAgICAgICBpZiAoX2Zvcm1hdHRlZC5sZW5ndGggPiBNQVhfUFJFVklFV19TVFJJTkdfTEVOR1RIKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGRvaW5nIGEgbG90IG9mIHVubmVjZXNzYXJ5IGl0ZXJhdGlvbi4uLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHNob3J0TmFtZSwgXCIgW1wiKS5jb25jYXQodHJ1bmNhdGVGb3JEaXNwbGF5KF9mb3JtYXR0ZWQpLCBcIl1cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2hvcnROYW1lO1xuICAgICAgfVxuXG4gICAgY2FzZSAnaXRlcmF0b3InOlxuICAgICAgdmFyIG5hbWUgPSBkYXRhLmNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgICAgIGlmIChzaG93Rm9ybWF0dGVkVmFsdWUpIHtcbiAgICAgICAgLy8gVFJJQ0tZXG4gICAgICAgIC8vIERvbid0IHVzZSBbLi4uc3ByZWFkXSBzeW50YXggZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgLy8gVGhpcyBwcm9qZWN0IHVzZXMgQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tc3ByZWFkIGluIFwibG9vc2VcIiBtb2RlIHdoaWNoIG9ubHkgd29ya3Mgd2l0aCBBcnJheSB2YWx1ZXMuXG4gICAgICAgIC8vIE90aGVyIHR5cGVzIChlLmcuIHR5cGVkIGFycmF5cywgU2V0cykgd2lsbCBub3Qgc3ByZWFkIGNvcnJlY3RseS5cbiAgICAgICAgdmFyIGFycmF5ID0gQXJyYXkuZnJvbShkYXRhKTtcbiAgICAgICAgdmFyIF9mb3JtYXR0ZWQyID0gJyc7XG5cbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgYXJyYXkubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIHZhciBlbnRyeU9yRW50cmllcyA9IGFycmF5W19pMl07XG5cbiAgICAgICAgICBpZiAoX2kyID4gMCkge1xuICAgICAgICAgICAgX2Zvcm1hdHRlZDIgKz0gJywgJztcbiAgICAgICAgICB9IC8vIFRSSUNLWVxuICAgICAgICAgIC8vIEJyb3dzZXJzIGRpc3BsYXkgTWFwcyBhbmQgU2V0cyBkaWZmZXJlbnRseS5cbiAgICAgICAgICAvLyBUbyBtaW1pYyB0aGVpciBiZWhhdmlvciwgZGV0ZWN0IGlmIHdlJ3ZlIGJlZW4gZ2l2ZW4gYW4gZW50cmllcyB0dXBsZS5cbiAgICAgICAgICAvLyAgIE1hcCgyKSB7XCJhYmNcIiA9PiAxMjMsIFwiZGVmXCIgPT4gMTIzfVxuICAgICAgICAgIC8vICAgU2V0KDIpIHtcImFiY1wiLCAxMjN9XG5cblxuICAgICAgICAgIGlmIChPYmplY3QoX2lzQXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkoZW50cnlPckVudHJpZXMpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gZm9ybWF0RGF0YUZvclByZXZpZXcoZW50cnlPckVudHJpZXNbMF0sIHRydWUpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZm9ybWF0RGF0YUZvclByZXZpZXcoZW50cnlPckVudHJpZXNbMV0sIGZhbHNlKTtcbiAgICAgICAgICAgIF9mb3JtYXR0ZWQyICs9IFwiXCIuY29uY2F0KGtleSwgXCIgPT4gXCIpLmNvbmNhdCh2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9mb3JtYXR0ZWQyICs9IGZvcm1hdERhdGFGb3JQcmV2aWV3KGVudHJ5T3JFbnRyaWVzLCBmYWxzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9mb3JtYXR0ZWQyLmxlbmd0aCA+IE1BWF9QUkVWSUVXX1NUUklOR19MRU5HVEgpIHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgZG9pbmcgYSBsb3Qgb2YgdW5uZWNlc3NhcnkgaXRlcmF0aW9uLi4uXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQobmFtZSwgXCIoXCIpLmNvbmNhdChkYXRhLnNpemUsIFwiKSB7XCIpLmNvbmNhdCh0cnVuY2F0ZUZvckRpc3BsYXkoX2Zvcm1hdHRlZDIpLCBcIn1cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQobmFtZSwgXCIoXCIpLmNvbmNhdChkYXRhLnNpemUsIFwiKVwiKTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ29wYXF1ZV9pdGVyYXRvcic6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBkYXRhW1N5bWJvbC50b1N0cmluZ1RhZ107XG4gICAgICB9XG5cbiAgICBjYXNlICdkYXRlJzpcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBjYXNlICdjbGFzc19pbnN0YW5jZSc6XG4gICAgICByZXR1cm4gZGF0YS5jb25zdHJ1Y3Rvci5uYW1lO1xuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChzaG93Rm9ybWF0dGVkVmFsdWUpIHtcbiAgICAgICAgdmFyIGtleXMgPSBBcnJheS5mcm9tKGdldEFsbEVudW1lcmFibGVLZXlzKGRhdGEpKS5zb3J0KGFscGhhU29ydEtleXMpO1xuICAgICAgICB2YXIgX2Zvcm1hdHRlZDMgPSAnJztcblxuICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBrZXlzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICB2YXIgX2tleSA9IGtleXNbX2kzXTtcblxuICAgICAgICAgIGlmIChfaTMgPiAwKSB7XG4gICAgICAgICAgICBfZm9ybWF0dGVkMyArPSAnLCAnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9mb3JtYXR0ZWQzICs9IFwiXCIuY29uY2F0KF9rZXkudG9TdHJpbmcoKSwgXCI6IFwiKS5jb25jYXQoZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YVtfa2V5XSwgZmFsc2UpKTtcblxuICAgICAgICAgIGlmIChfZm9ybWF0dGVkMy5sZW5ndGggPiBNQVhfUFJFVklFV19TVFJJTkdfTEVOR1RIKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGRvaW5nIGEgbG90IG9mIHVubmVjZXNzYXJ5IGl0ZXJhdGlvbi4uLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwie1wiLmNvbmNhdCh0cnVuY2F0ZUZvckRpc3BsYXkoX2Zvcm1hdHRlZDMpLCBcIn1cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ3vigKZ9JztcbiAgICAgIH1cblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnaW5maW5pdHknOlxuICAgIGNhc2UgJ25hbic6XG4gICAgY2FzZSAnbnVsbCc6XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiBkYXRhO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0cnVuY2F0ZUZvckRpc3BsYXkoU3RyaW5nKGRhdGEpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiAndW5zZXJpYWxpemFibGUnO1xuICAgICAgfVxuXG4gIH1cbn0gLy8gQmFzaWNhbGx5IGNoZWNraW5nIHRoYXQgdGhlIG9iamVjdCBvbmx5IGhhcyBPYmplY3QgaW4gaXRzIHByb3RvdHlwZSBjaGFpblxuXG52YXIgaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqZWN0KSB7XG4gIHZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgaWYgKCFvYmplY3RQcm90b3R5cGUpIHJldHVybiB0cnVlO1xuICB2YXIgb2JqZWN0UGFyZW50UHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdFByb3RvdHlwZSk7XG4gIHJldHVybiAhb2JqZWN0UGFyZW50UHJvdG90eXBlO1xufTtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KSkpXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRWxlbWVudFR5cGVDbGFzczsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEVsZW1lbnRUeXBlQ29udGV4dDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEVsZW1lbnRUeXBlRnVuY3Rpb247IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFbGVtZW50VHlwZUZvcndhcmRSZWY7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFbGVtZW50VHlwZUhvc3RDb21wb25lbnQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImpcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFbGVtZW50VHlwZU1lbW87IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImtcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFbGVtZW50VHlwZU90aGVyT3JVbmtub3duOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJsXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRWxlbWVudFR5cGVQcm9maWxlcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEVsZW1lbnRUeXBlUm9vdDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEVsZW1lbnRUeXBlU3VzcGVuc2U7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm9cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFbGVtZW50VHlwZVN1c3BlbnNlTGlzdDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEVsZW1lbnRUeXBlVHJhY2luZ01hcmtlcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENvbXBvbmVudEZpbHRlckVsZW1lbnRUeXBlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ29tcG9uZW50RmlsdGVyRGlzcGxheU5hbWU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDb21wb25lbnRGaWx0ZXJMb2NhdGlvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENvbXBvbmVudEZpbHRlckhPQzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFN0cmljdE1vZGU7IH0pO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbi8qKlxuICogV0FSTklORzpcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0eXBlcyB0aGF0IGFyZSBkZXNpZ25lZCBmb3IgUmVhY3QgRGV2VG9vbHMgVUkgYW5kIGhvdyBpdCBpbnRlcmFjdHMgd2l0aCB0aGUgYmFja2VuZC5cbiAqIFRoZXkgbWlnaHQgYmUgdXNlZCBpbiBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgRGV2VG9vbHMgYmFja2VuZHMuXG4gKiBCZSBtaW5kZnVsIG9mIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdoZW4gbWFraW5nIGNoYW5nZXMuXG4gKi9cbi8vIFdBUk5JTkdcbi8vIFRoZSB2YWx1ZXMgYmVsb3cgYXJlIHJlZmVyZW5jZWQgYnkgQ29tcG9uZW50RmlsdGVycyAod2hpY2ggYXJlIHNhdmVkIHZpYSBsb2NhbFN0b3JhZ2UpLlxuLy8gRG8gbm90IGNoYW5nZSB0aGVtIG9yIGl0IHdpbGwgYnJlYWsgcHJldmlvdXNseSBzYXZlZCB1c2VyIGN1c3RvbWl6YXRpb25zLlxuLy8gSWYgbmV3IGVsZW1lbnQgdHlwZXMgYXJlIGFkZGVkLCB1c2UgbmV3IG51bWJlcnMgcmF0aGVyIHRoYW4gcmUtb3JkZXJpbmcgZXhpc3Rpbmcgb25lcy5cbi8vXG4vLyBDaGFuZ2luZyB0aGVzZSB0eXBlcyBpcyBhbHNvIGEgYmFja3dhcmRzIGJyZWFraW5nIGNoYW5nZSBmb3IgdGhlIHN0YW5kYWxvbmUgc2hlbGwsXG4vLyBzaW5jZSB0aGUgZnJvbnRlbmQgYW5kIGJhY2tlbmQgbXVzdCBzaGFyZSB0aGUgc2FtZSB2YWx1ZXMtXG4vLyBhbmQgdGhlIGJhY2tlbmQgaXMgZW1iZWRkZWQgaW4gY2VydGFpbiBlbnZpcm9ubWVudHMgKGxpa2UgUmVhY3QgTmF0aXZlKS5cbnZhciBFbGVtZW50VHlwZUNsYXNzID0gMTtcbnZhciBFbGVtZW50VHlwZUNvbnRleHQgPSAyO1xudmFyIEVsZW1lbnRUeXBlRnVuY3Rpb24gPSA1O1xudmFyIEVsZW1lbnRUeXBlRm9yd2FyZFJlZiA9IDY7XG52YXIgRWxlbWVudFR5cGVIb3N0Q29tcG9uZW50ID0gNztcbnZhciBFbGVtZW50VHlwZU1lbW8gPSA4O1xudmFyIEVsZW1lbnRUeXBlT3RoZXJPclVua25vd24gPSA5O1xudmFyIEVsZW1lbnRUeXBlUHJvZmlsZXIgPSAxMDtcbnZhciBFbGVtZW50VHlwZVJvb3QgPSAxMTtcbnZhciBFbGVtZW50VHlwZVN1c3BlbnNlID0gMTI7XG52YXIgRWxlbWVudFR5cGVTdXNwZW5zZUxpc3QgPSAxMztcbnZhciBFbGVtZW50VHlwZVRyYWNpbmdNYXJrZXIgPSAxNDsgLy8gRGlmZmVyZW50IHR5cGVzIG9mIGVsZW1lbnRzIGRpc3BsYXllZCBpbiB0aGUgRWxlbWVudHMgdHJlZS5cbi8vIFRoZXNlIHR5cGVzIG1heSBiZSB1c2VkIHRvIHZpc3VhbGx5IGRpc3Rpbmd1aXNoIHR5cGVzLFxuLy8gb3IgdG8gZW5hYmxlL2Rpc2FibGUgY2VydGFpbiBmdW5jdGlvbmFsaXR5LlxuXG4vLyBXQVJOSU5HXG4vLyBUaGUgdmFsdWVzIGJlbG93IGFyZSByZWZlcmVuY2VkIGJ5IENvbXBvbmVudEZpbHRlcnMgKHdoaWNoIGFyZSBzYXZlZCB2aWEgbG9jYWxTdG9yYWdlKS5cbi8vIERvIG5vdCBjaGFuZ2UgdGhlbSBvciBpdCB3aWxsIGJyZWFrIHByZXZpb3VzbHkgc2F2ZWQgdXNlciBjdXN0b21pemF0aW9ucy5cbi8vIElmIG5ldyBmaWx0ZXIgdHlwZXMgYXJlIGFkZGVkLCB1c2UgbmV3IG51bWJlcnMgcmF0aGVyIHRoYW4gcmUtb3JkZXJpbmcgZXhpc3Rpbmcgb25lcy5cbnZhciBDb21wb25lbnRGaWx0ZXJFbGVtZW50VHlwZSA9IDE7XG52YXIgQ29tcG9uZW50RmlsdGVyRGlzcGxheU5hbWUgPSAyO1xudmFyIENvbXBvbmVudEZpbHRlckxvY2F0aW9uID0gMztcbnZhciBDb21wb25lbnRGaWx0ZXJIT0MgPSA0O1xudmFyIFN0cmljdE1vZGUgPSAxO1xuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgQ0hST01FX1dFQlNUT1JFX0VYVEVOU0lPTl9JRCAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IElOVEVSTkFMX0VYVEVOU0lPTl9JRCAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IExPQ0FMX0VYVEVOU0lPTl9JRCAqL1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX0RFQlVHX187IH0pO1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IF9fUEVSRk9STUFOQ0VfUFJPRklMRV9fICovXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRSRUVfT1BFUkFUSU9OX0FERDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRSRUVfT1BFUkFUSU9OX1JFTU9WRTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwib1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRSRUVfT1BFUkFUSU9OX1JFT1JERVJfQ0hJTERSRU47IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUUkVFX09QRVJBVElPTl9VUERBVEVfVFJFRV9CQVNFX0RVUkFUSU9OOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJxXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVFJFRV9PUEVSQVRJT05fVVBEQVRFX0VSUk9SU19PUl9XQVJOSU5HUzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRSRUVfT1BFUkFUSU9OX1JFTU9WRV9ST09UOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJwXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVFJFRV9PUEVSQVRJT05fU0VUX1NVQlRSRUVfTU9ERTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFBST0ZJTElOR19GTEFHX0JBU0lDX1NVUFBPUlQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImhcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBQUk9GSUxJTkdfRkxBR19USU1FTElORV9TVVBQT1JUOyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBMT0NBTF9TVE9SQUdFX0RFRkFVTFRfVEFCX0tFWSAqL1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBMT0NBTF9TVE9SQUdFX0NPTVBPTkVOVF9GSUxURVJfUFJFRkVSRU5DRVNfS0VZOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU0VTU0lPTl9TVE9SQUdFX0xBU1RfU0VMRUNUSU9OX0tFWTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIExPQ0FMX1NUT1JBR0VfT1BFTl9JTl9FRElUT1JfVVJMOyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBMT0NBTF9TVE9SQUdFX1BBUlNFX0hPT0tfTkFNRVNfS0VZICovXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwialwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFNFU1NJT05fU1RPUkFHRV9SRUNPUkRfQ0hBTkdFX0RFU0NSSVBUSU9OU19LRVk7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImtcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTRVNTSU9OX1NUT1JBR0VfUkVMT0FEX0FORF9QUk9GSUxFX0tFWTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIExPQ0FMX1NUT1JBR0VfU0hPVUxEX0JSRUFLX09OX0NPTlNPTEVfRVJST1JTOyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBMT0NBTF9TVE9SQUdFX0JST1dTRVJfVEhFTUUgKi9cbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTE9DQUxfU1RPUkFHRV9TSE9VTERfQVBQRU5EX0NPTVBPTkVOVF9TVEFDS19LRVk7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBMT0NBTF9TVE9SQUdFX1NIT1dfSU5MSU5FX1dBUk5JTkdTX0FORF9FUlJPUlNfS0VZOyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBMT0NBTF9TVE9SQUdFX1RSQUNFX1VQREFURVNfRU5BQkxFRF9LRVkgKi9cbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJiXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTE9DQUxfU1RPUkFHRV9ISURFX0NPTlNPTEVfTE9HU19JTl9TVFJJQ1RfTU9ERTsgfSk7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgUFJPRklMRVJfRVhQT1JUX1ZFUlNJT04gKi9cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xudmFyIENIUk9NRV9XRUJTVE9SRV9FWFRFTlNJT05fSUQgPSAnZm1rYWRtYXBnb2ZhZG9wbGpiamZrYXBka29pZW5paGknO1xudmFyIElOVEVSTkFMX0VYVEVOU0lPTl9JRCA9ICdkbmpuamdiZmlsZnBobW9qbm1obGllaG9nbW9qaGNsYyc7XG52YXIgTE9DQUxfRVhURU5TSU9OX0lEID0gJ2lraWFobmFwbGRqbWRtcGttZmhqZGppbG9qamhnY2JmJzsgLy8gRmxpcCB0aGlzIGZsYWcgdG8gdHJ1ZSB0byBlbmFibGUgdmVyYm9zZSBjb25zb2xlIGRlYnVnIGxvZ2dpbmcuXG5cbnZhciBfX0RFQlVHX18gPSBmYWxzZTsgLy8gRmxpcCB0aGlzIGZsYWcgdG8gdHJ1ZSB0byBlbmFibGUgcGVyZm9ybWFuY2UubWFyaygpIGFuZCBwZXJmb3JtYW5jZS5tZWFzdXJlKCkgdGltaW5ncy5cblxudmFyIF9fUEVSRk9STUFOQ0VfUFJPRklMRV9fID0gZmFsc2U7XG52YXIgVFJFRV9PUEVSQVRJT05fQUREID0gMTtcbnZhciBUUkVFX09QRVJBVElPTl9SRU1PVkUgPSAyO1xudmFyIFRSRUVfT1BFUkFUSU9OX1JFT1JERVJfQ0hJTERSRU4gPSAzO1xudmFyIFRSRUVfT1BFUkFUSU9OX1VQREFURV9UUkVFX0JBU0VfRFVSQVRJT04gPSA0O1xudmFyIFRSRUVfT1BFUkFUSU9OX1VQREFURV9FUlJPUlNfT1JfV0FSTklOR1MgPSA1O1xudmFyIFRSRUVfT1BFUkFUSU9OX1JFTU9WRV9ST09UID0gNjtcbnZhciBUUkVFX09QRVJBVElPTl9TRVRfU1VCVFJFRV9NT0RFID0gNztcbnZhciBQUk9GSUxJTkdfRkxBR19CQVNJQ19TVVBQT1JUID0gMTtcbnZhciBQUk9GSUxJTkdfRkxBR19USU1FTElORV9TVVBQT1JUID0gMjtcbnZhciBMT0NBTF9TVE9SQUdFX0RFRkFVTFRfVEFCX0tFWSA9ICdSZWFjdDo6RGV2VG9vbHM6OmRlZmF1bHRUYWInO1xudmFyIExPQ0FMX1NUT1JBR0VfQ09NUE9ORU5UX0ZJTFRFUl9QUkVGRVJFTkNFU19LRVkgPSAnUmVhY3Q6OkRldlRvb2xzOjpjb21wb25lbnRGaWx0ZXJzJztcbnZhciBTRVNTSU9OX1NUT1JBR0VfTEFTVF9TRUxFQ1RJT05fS0VZID0gJ1JlYWN0OjpEZXZUb29sczo6bGFzdFNlbGVjdGlvbic7XG52YXIgTE9DQUxfU1RPUkFHRV9PUEVOX0lOX0VESVRPUl9VUkwgPSAnUmVhY3Q6OkRldlRvb2xzOjpvcGVuSW5FZGl0b3JVcmwnO1xudmFyIExPQ0FMX1NUT1JBR0VfUEFSU0VfSE9PS19OQU1FU19LRVkgPSAnUmVhY3Q6OkRldlRvb2xzOjpwYXJzZUhvb2tOYW1lcyc7XG52YXIgU0VTU0lPTl9TVE9SQUdFX1JFQ09SRF9DSEFOR0VfREVTQ1JJUFRJT05TX0tFWSA9ICdSZWFjdDo6RGV2VG9vbHM6OnJlY29yZENoYW5nZURlc2NyaXB0aW9ucyc7XG52YXIgU0VTU0lPTl9TVE9SQUdFX1JFTE9BRF9BTkRfUFJPRklMRV9LRVkgPSAnUmVhY3Q6OkRldlRvb2xzOjpyZWxvYWRBbmRQcm9maWxlJztcbnZhciBMT0NBTF9TVE9SQUdFX1NIT1VMRF9CUkVBS19PTl9DT05TT0xFX0VSUk9SUyA9ICdSZWFjdDo6RGV2VG9vbHM6OmJyZWFrT25Db25zb2xlRXJyb3JzJztcbnZhciBMT0NBTF9TVE9SQUdFX0JST1dTRVJfVEhFTUUgPSAnUmVhY3Q6OkRldlRvb2xzOjp0aGVtZSc7XG52YXIgTE9DQUxfU1RPUkFHRV9TSE9VTERfQVBQRU5EX0NPTVBPTkVOVF9TVEFDS19LRVkgPSAnUmVhY3Q6OkRldlRvb2xzOjphcHBlbmRDb21wb25lbnRTdGFjayc7XG52YXIgTE9DQUxfU1RPUkFHRV9TSE9XX0lOTElORV9XQVJOSU5HU19BTkRfRVJST1JTX0tFWSA9ICdSZWFjdDo6RGV2VG9vbHM6OnNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycyc7XG52YXIgTE9DQUxfU1RPUkFHRV9UUkFDRV9VUERBVEVTX0VOQUJMRURfS0VZID0gJ1JlYWN0OjpEZXZUb29sczo6dHJhY2VVcGRhdGVzRW5hYmxlZCc7XG52YXIgTE9DQUxfU1RPUkFHRV9ISURFX0NPTlNPTEVfTE9HU19JTl9TVFJJQ1RfTU9ERSA9ICdSZWFjdDo6RGV2VG9vbHM6OmhpZGVDb25zb2xlTG9nc0luU3RyaWN0TW9kZSc7XG52YXIgUFJPRklMRVJfRVhQT1JUX1ZFUlNJT04gPSA1O1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENPTkNVUlJFTlRfTU9ERV9OVU1CRVI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDT05DVVJSRU5UX01PREVfU1lNQk9MX1NUUklORzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENPTlRFWFRfTlVNQkVSOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ09OVEVYVF9TWU1CT0xfU1RSSU5HOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU0VSVkVSX0NPTlRFWFRfU1lNQk9MX1NUUklORzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERFUFJFQ0FURURfQVNZTkNfTU9ERV9TWU1CT0xfU1RSSU5HOyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBFTEVNRU5UX05VTUJFUiAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IEVMRU1FTlRfU1lNQk9MX1NUUklORyAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IERFQlVHX1RSQUNJTkdfTU9ERV9OVU1CRVIgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBERUJVR19UUkFDSU5HX01PREVfU1lNQk9MX1NUUklORyAqL1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBGT1JXQVJEX1JFRl9OVU1CRVI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBGT1JXQVJEX1JFRl9TWU1CT0xfU1RSSU5HOyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBGUkFHTUVOVF9OVU1CRVIgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBGUkFHTUVOVF9TWU1CT0xfU1RSSU5HICovXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIExBWllfTlVNQkVSOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTEFaWV9TWU1CT0xfU1RSSU5HOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJqXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTUVNT19OVU1CRVI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImtcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBNRU1PX1NZTUJPTF9TVFJJTkc7IH0pO1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IFBPUlRBTF9OVU1CRVIgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBQT1JUQUxfU1lNQk9MX1NUUklORyAqL1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBQUk9GSUxFUl9OVU1CRVI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm1cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBQUk9GSUxFUl9TWU1CT0xfU1RSSU5HOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJuXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUFJPVklERVJfTlVNQkVSOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJvXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUFJPVklERVJfU1lNQk9MX1NUUklORzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFNDT1BFX05VTUJFUjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFNDT1BFX1NZTUJPTF9TVFJJTkc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTVFJJQ1RfTU9ERV9OVU1CRVI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTVFJJQ1RfTU9ERV9TWU1CT0xfU1RSSU5HOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ3XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU1VTUEVOU0VfTlVNQkVSOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ4XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU1VTUEVOU0VfU1lNQk9MX1NUUklORzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFNVU1BFTlNFX0xJU1RfTlVNQkVSOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ2XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU1VTUEVOU0VfTElTVF9TWU1CT0xfU1RSSU5HOyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBTRVJWRVJfQ09OVEVYVF9ERUZBVUxUX1ZBTFVFX05PVF9MT0FERURfU1lNQk9MX1NUUklORyAqL1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG4vLyBUaGlzIGxpc3Qgc2hvdWxkIGJlIGtlcHQgdXBkYXRlZCB0byByZWZsZWN0IGFkZGl0aW9ucyB0byAnc2hhcmVkL1JlYWN0U3ltYm9scycuXG4vLyBEZXZUb29scyBjYW4ndCBpbXBvcnQgc3ltYm9scyBmcm9tICdzaGFyZWQvUmVhY3RTeW1ib2xzJyBkaXJlY3RseSBmb3IgdHdvIHJlYXNvbnM6XG4vLyAxLiBEZXZUb29scyByZXF1aXJlcyBzeW1ib2xzIHdoaWNoIG1heSBoYXZlIGJlZW4gZGVsZXRlZCBpbiBtb3JlIHJlY2VudCB2ZXJzaW9ucyAoZS5nLiBjb25jdXJyZW50IG1vZGUpXG4vLyAyLiBEZXZUb29scyBtdXN0IHN1cHBvcnQgYm90aCBTeW1ib2wgYW5kIG51bWVyaWMgZm9ybXMgb2YgZWFjaCBzeW1ib2w7XG4vLyAgICBTaW5jZSBlLmcuIHN0YW5kYWxvbmUgRGV2VG9vbHMgcnVucyBpbiBhIHNlcGFyYXRlIHByb2Nlc3MsIGl0IGNhbid0IHJlbHkgb24gaXRzIG93biBFUyBjYXBhYmlsaXRpZXMuXG52YXIgQ09OQ1VSUkVOVF9NT0RFX05VTUJFUiA9IDB4ZWFjZjtcbnZhciBDT05DVVJSRU5UX01PREVfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3QuY29uY3VycmVudF9tb2RlKSc7XG52YXIgQ09OVEVYVF9OVU1CRVIgPSAweGVhY2U7XG52YXIgQ09OVEVYVF9TWU1CT0xfU1RSSU5HID0gJ1N5bWJvbChyZWFjdC5jb250ZXh0KSc7XG52YXIgU0VSVkVSX0NPTlRFWFRfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3Quc2VydmVyX2NvbnRleHQpJztcbnZhciBERVBSRUNBVEVEX0FTWU5DX01PREVfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3QuYXN5bmNfbW9kZSknO1xudmFyIEVMRU1FTlRfTlVNQkVSID0gMHhlYWM3O1xudmFyIEVMRU1FTlRfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3QuZWxlbWVudCknO1xudmFyIERFQlVHX1RSQUNJTkdfTU9ERV9OVU1CRVIgPSAweGVhZTE7XG52YXIgREVCVUdfVFJBQ0lOR19NT0RFX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LmRlYnVnX3RyYWNlX21vZGUpJztcbnZhciBGT1JXQVJEX1JFRl9OVU1CRVIgPSAweGVhZDA7XG52YXIgRk9SV0FSRF9SRUZfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3QuZm9yd2FyZF9yZWYpJztcbnZhciBGUkFHTUVOVF9OVU1CRVIgPSAweGVhY2I7XG52YXIgRlJBR01FTlRfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3QuZnJhZ21lbnQpJztcbnZhciBMQVpZX05VTUJFUiA9IDB4ZWFkNDtcbnZhciBMQVpZX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LmxhenkpJztcbnZhciBNRU1PX05VTUJFUiA9IDB4ZWFkMztcbnZhciBNRU1PX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0Lm1lbW8pJztcbnZhciBQT1JUQUxfTlVNQkVSID0gMHhlYWNhO1xudmFyIFBPUlRBTF9TWU1CT0xfU1RSSU5HID0gJ1N5bWJvbChyZWFjdC5wb3J0YWwpJztcbnZhciBQUk9GSUxFUl9OVU1CRVIgPSAweGVhZDI7XG52YXIgUFJPRklMRVJfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3QucHJvZmlsZXIpJztcbnZhciBQUk9WSURFUl9OVU1CRVIgPSAweGVhY2Q7XG52YXIgUFJPVklERVJfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3QucHJvdmlkZXIpJztcbnZhciBTQ09QRV9OVU1CRVIgPSAweGVhZDc7XG52YXIgU0NPUEVfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3Quc2NvcGUpJztcbnZhciBTVFJJQ1RfTU9ERV9OVU1CRVIgPSAweGVhY2M7XG52YXIgU1RSSUNUX01PREVfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3Quc3RyaWN0X21vZGUpJztcbnZhciBTVVNQRU5TRV9OVU1CRVIgPSAweGVhZDE7XG52YXIgU1VTUEVOU0VfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3Quc3VzcGVuc2UpJztcbnZhciBTVVNQRU5TRV9MSVNUX05VTUJFUiA9IDB4ZWFkODtcbnZhciBTVVNQRU5TRV9MSVNUX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LnN1c3BlbnNlX2xpc3QpJztcbnZhciBTRVJWRVJfQ09OVEVYVF9ERUZBVUxUX1ZBTFVFX05PVF9MT0FERURfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3Quc2VydmVyX2NvbnRleHQuZGVmYXVsdFZhbHVlKSc7XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwialwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gaGFzQXNzaWduZWRCYWNrZW5kOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGNsZWFuRm9yQnJpZGdlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGNvcHlXaXRoRGVsZXRlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGNvcHlXaXRoUmVuYW1lOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGNvcHlXaXRoU2V0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGdldEVmZmVjdER1cmF0aW9uczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJsXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBzZXJpYWxpemVUb1N0cmluZzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJmXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBmb3JtYXRXaXRoU3R5bGVzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGZvcm1hdDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJrXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBpc1N5bmNocm9ub3VzWEhSU3VwcG9ydGVkOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImhcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGd0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGd0ZTsgfSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC9Vc2Vycy9ob3h5L3JlcG9zL3JlYWN0L25vZGVfbW9kdWxlcy9jb21wYXJlLXZlcnNpb25zL2xpYi9lc20vaW5kZXguanNcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuLyoqXG4gKiBDb21wYXJlIFtzZW12ZXJdKGh0dHBzOi8vc2VtdmVyLm9yZy8pIHZlcnNpb24gc3RyaW5ncyB0byBmaW5kIGdyZWF0ZXIsIGVxdWFsIG9yIGxlc3Nlci5cbiAqIFRoaXMgbGlicmFyeSBzdXBwb3J0cyB0aGUgZnVsbCBzZW12ZXIgc3BlY2lmaWNhdGlvbiwgaW5jbHVkaW5nIGNvbXBhcmluZyB2ZXJzaW9ucyB3aXRoIGRpZmZlcmVudCBudW1iZXIgb2YgZGlnaXRzIGxpa2UgYDEuMC4wYCwgYDEuMGAsIGAxYCwgYW5kIHByZS1yZWxlYXNlIHZlcnNpb25zIGxpa2UgYDEuMC4wLWFscGhhYC5cbiAqIEBwYXJhbSB2MSAtIEZpcnN0IHZlcnNpb24gdG8gY29tcGFyZVxuICogQHBhcmFtIHYyIC0gU2Vjb25kIHZlcnNpb24gdG8gY29tcGFyZVxuICogQHJldHVybnMgTnVtZXJpYyB2YWx1ZSBjb21wYXRpYmxlIHdpdGggdGhlIFtBcnJheS5zb3J0KGZuKSBpbnRlcmZhY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQjUGFyYW1ldGVycykuXG4gKi9cbnZhciBjb21wYXJlVmVyc2lvbnMgPSBmdW5jdGlvbiBjb21wYXJlVmVyc2lvbnModjEsIHYyKSB7XG4gIC8vIHZhbGlkYXRlIGlucHV0IGFuZCBzcGxpdCBpbnRvIHNlZ21lbnRzXG4gIHZhciBuMSA9IHZhbGlkYXRlQW5kUGFyc2UodjEpO1xuICB2YXIgbjIgPSB2YWxpZGF0ZUFuZFBhcnNlKHYyKTsgLy8gcG9wIG9mZiB0aGUgcGF0Y2hcblxuICB2YXIgcDEgPSBuMS5wb3AoKTtcbiAgdmFyIHAyID0gbjIucG9wKCk7IC8vIHZhbGlkYXRlIG51bWJlcnNcblxuICB2YXIgciA9IGNvbXBhcmVTZWdtZW50cyhuMSwgbjIpO1xuICBpZiAociAhPT0gMCkgcmV0dXJuIHI7IC8vIHZhbGlkYXRlIHByZS1yZWxlYXNlXG5cbiAgaWYgKHAxICYmIHAyKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVTZWdtZW50cyhwMS5zcGxpdCgnLicpLCBwMi5zcGxpdCgnLicpKTtcbiAgfSBlbHNlIGlmIChwMSB8fCBwMikge1xuICAgIHJldHVybiBwMSA/IC0xIDogMTtcbiAgfVxuXG4gIHJldHVybiAwO1xufTtcbi8qKlxuICogVmFsaWRhdGUgW3NlbXZlcl0oaHR0cHM6Ly9zZW12ZXIub3JnLykgdmVyc2lvbiBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIFZlcnNpb24gbnVtYmVyIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZlcnNpb24gbnVtYmVyIGlzIGEgdmFsaWQgc2VtdmVyIHZlcnNpb24gbnVtYmVyLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiB2YWxpZGF0ZSgnMS4wLjAtcmMuMScpOyAvLyByZXR1cm4gdHJ1ZVxuICogdmFsaWRhdGUoJzEuMC1yYy4xJyk7IC8vIHJldHVybiBmYWxzZVxuICogdmFsaWRhdGUoJ2ZvbycpOyAvLyByZXR1cm4gZmFsc2VcbiAqIGBgYFxuICovXG5cbnZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKHZlcnNpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJyAmJiAvXlt2XFxkXS8udGVzdCh2ZXJzaW9uKSAmJiBzZW12ZXIudGVzdCh2ZXJzaW9uKTtcbn07XG4vKipcbiAqIENvbXBhcmUgW3NlbXZlcl0oaHR0cHM6Ly9zZW12ZXIub3JnLykgdmVyc2lvbiBzdHJpbmdzIHVzaW5nIHRoZSBzcGVjaWZpZWQgb3BlcmF0b3IuXG4gKlxuICogQHBhcmFtIHYxIEZpcnN0IHZlcnNpb24gdG8gY29tcGFyZVxuICogQHBhcmFtIHYyIFNlY29uZCB2ZXJzaW9uIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSBvcGVyYXRvciBBbGxvd2VkIGFyaXRobWV0aWMgb3BlcmF0b3IgdG8gdXNlXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvbXBhcmlzb24gYmV0d2VlbiB0aGUgZmlyc3RWZXJzaW9uIGFuZCB0aGUgc2Vjb25kVmVyc2lvbiBzYXRpc2ZpZXMgdGhlIG9wZXJhdG9yLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBjb21wYXJlKCcxMC4xLjgnLCAnMTAuMC40JywgJz4nKTsgLy8gcmV0dXJuIHRydWVcbiAqIGNvbXBhcmUoJzEwLjAuMScsICcxMC4wLjEnLCAnPScpOyAvLyByZXR1cm4gdHJ1ZVxuICogY29tcGFyZSgnMTAuMS4xJywgJzEwLjIuMicsICc8Jyk7IC8vIHJldHVybiB0cnVlXG4gKiBjb21wYXJlKCcxMC4xLjEnLCAnMTAuMi4yJywgJzw9Jyk7IC8vIHJldHVybiB0cnVlXG4gKiBjb21wYXJlKCcxMC4xLjEnLCAnMTAuMi4yJywgJz49Jyk7IC8vIHJldHVybiBmYWxzZVxuICogYGBgXG4gKi9cblxudmFyIGNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKHYxLCB2Miwgb3BlcmF0b3IpIHtcbiAgLy8gdmFsaWRhdGUgaW5wdXQgb3BlcmF0b3JcbiAgYXNzZXJ0VmFsaWRPcGVyYXRvcihvcGVyYXRvcik7IC8vIHNpbmNlIHJlc3VsdCBvZiBjb21wYXJlVmVyc2lvbnMgY2FuIG9ubHkgYmUgLTEgb3IgMCBvciAxXG4gIC8vIGEgc2ltcGxlIG1hcCBjYW4gYmUgdXNlZCB0byByZXBsYWNlIHN3aXRjaFxuXG4gIHZhciByZXMgPSBjb21wYXJlVmVyc2lvbnModjEsIHYyKTtcbiAgcmV0dXJuIG9wZXJhdG9yUmVzTWFwW29wZXJhdG9yXS5pbmNsdWRlcyhyZXMpO1xufTtcbi8qKlxuICogTWF0Y2ggW25wbSBzZW12ZXJdKGh0dHBzOi8vZG9jcy5ucG1qcy5jb20vY2xpL3Y2L3VzaW5nLW5wbS9zZW12ZXIpIHZlcnNpb24gcmFuZ2UuXG4gKlxuICogQHBhcmFtIHZlcnNpb24gVmVyc2lvbiBudW1iZXIgdG8gbWF0Y2hcbiAqIEBwYXJhbSByYW5nZSBSYW5nZSBwYXR0ZXJuIGZvciB2ZXJzaW9uXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZlcnNpb24gbnVtYmVyIGlzIHdpdGhpbiB0aGUgcmFuZ2UsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIHNhdGlzZmllcygnMS4xLjAnLCAnXjEuMC4wJyk7IC8vIHJldHVybiB0cnVlXG4gKiBzYXRpc2ZpZXMoJzEuMS4wJywgJ34xLjAuMCcpOyAvLyByZXR1cm4gZmFsc2VcbiAqIGBgYFxuICovXG5cbnZhciBzYXRpc2ZpZXMgPSBmdW5jdGlvbiBzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UpIHtcbiAgLy8gaWYgbm8gcmFuZ2Ugb3BlcmF0b3IgdGhlbiBcIj1cIlxuICB2YXIgbSA9IHJhbmdlLm1hdGNoKC9eKFs8Pj1+Xl0rKS8pO1xuICB2YXIgb3AgPSBtID8gbVsxXSA6ICc9JzsgLy8gaWYgZ3QvbHQvZXEgdGhlbiBvcGVyYXRvciBjb21wYXJlXG5cbiAgaWYgKG9wICE9PSAnXicgJiYgb3AgIT09ICd+JykgcmV0dXJuIGNvbXBhcmUodmVyc2lvbiwgcmFuZ2UsIG9wKTsgLy8gZWxzZSByYW5nZSBvZiBlaXRoZXIgXCJ+XCIgb3IgXCJeXCIgaXMgYXNzdW1lZFxuXG4gIHZhciBfdmFsaWRhdGVBbmRQYXJzZSA9IHZhbGlkYXRlQW5kUGFyc2UodmVyc2lvbiksXG4gICAgICBfdmFsaWRhdGVBbmRQYXJzZTIgPSBfc2xpY2VkVG9BcnJheShfdmFsaWRhdGVBbmRQYXJzZSwgNSksXG4gICAgICB2MSA9IF92YWxpZGF0ZUFuZFBhcnNlMlswXSxcbiAgICAgIHYyID0gX3ZhbGlkYXRlQW5kUGFyc2UyWzFdLFxuICAgICAgdjMgPSBfdmFsaWRhdGVBbmRQYXJzZTJbMl0sXG4gICAgICB2cCA9IF92YWxpZGF0ZUFuZFBhcnNlMls0XTtcblxuICB2YXIgX3ZhbGlkYXRlQW5kUGFyc2UzID0gdmFsaWRhdGVBbmRQYXJzZShyYW5nZSksXG4gICAgICBfdmFsaWRhdGVBbmRQYXJzZTQgPSBfc2xpY2VkVG9BcnJheShfdmFsaWRhdGVBbmRQYXJzZTMsIDUpLFxuICAgICAgcjEgPSBfdmFsaWRhdGVBbmRQYXJzZTRbMF0sXG4gICAgICByMiA9IF92YWxpZGF0ZUFuZFBhcnNlNFsxXSxcbiAgICAgIHIzID0gX3ZhbGlkYXRlQW5kUGFyc2U0WzJdLFxuICAgICAgcnAgPSBfdmFsaWRhdGVBbmRQYXJzZTRbNF07XG5cbiAgdmFyIHYgPSBbdjEsIHYyLCB2M107XG4gIHZhciByID0gW3IxLCByMiAhPT0gbnVsbCAmJiByMiAhPT0gdm9pZCAwID8gcjIgOiAneCcsIHIzICE9PSBudWxsICYmIHIzICE9PSB2b2lkIDAgPyByMyA6ICd4J107IC8vIHZhbGlkYXRlIHByZS1yZWxlYXNlXG5cbiAgaWYgKHJwKSB7XG4gICAgaWYgKCF2cCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChjb21wYXJlU2VnbWVudHModiwgcikgIT09IDApIHJldHVybiBmYWxzZTtcbiAgICBpZiAoY29tcGFyZVNlZ21lbnRzKHZwLnNwbGl0KCcuJyksIHJwLnNwbGl0KCcuJykpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICB9IC8vIGZpcnN0IG5vbi16ZXJvIG51bWJlclxuXG5cbiAgdmFyIG5vblplcm8gPSByLmZpbmRJbmRleChmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2ICE9PSAnMCc7XG4gIH0pICsgMTsgLy8gcG9pbnRlciB0byB3aGVyZSBzZWdtZW50cyBjYW4gYmUgPj1cblxuICB2YXIgaSA9IG9wID09PSAnficgPyAyIDogbm9uWmVybyA+IDEgPyBub25aZXJvIDogMTsgLy8gYmVmb3JlIHBvaW50ZXIgbXVzdCBiZSBlcXVhbFxuXG4gIGlmIChjb21wYXJlU2VnbWVudHModi5zbGljZSgwLCBpKSwgci5zbGljZSgwLCBpKSkgIT09IDApIHJldHVybiBmYWxzZTsgLy8gYWZ0ZXIgcG9pbnRlciBtdXN0IGJlID49XG5cbiAgaWYgKGNvbXBhcmVTZWdtZW50cyh2LnNsaWNlKGkpLCByLnNsaWNlKGkpKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIHNlbXZlciA9IC9eW3Zefjw+PV0qPyhcXGQrKSg/OlxcLihbeCpdfFxcZCspKD86XFwuKFt4Kl18XFxkKykoPzpcXC4oW3gqXXxcXGQrKSk/KD86LShbXFxkYS16XFwtXSsoPzpcXC5bXFxkYS16XFwtXSspKikpPyg/OlxcK1tcXGRhLXpcXC1dKyg/OlxcLltcXGRhLXpcXC1dKykqKT8pPyk/JC9pO1xuXG52YXIgdmFsaWRhdGVBbmRQYXJzZSA9IGZ1bmN0aW9uIHZhbGlkYXRlQW5kUGFyc2UodmVyc2lvbikge1xuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCBleHBlY3RlZCBzdHJpbmcnKTtcbiAgfVxuXG4gIHZhciBtYXRjaCA9IHZlcnNpb24ubWF0Y2goc2VtdmVyKTtcblxuICBpZiAoIW1hdGNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudCBub3QgdmFsaWQgc2VtdmVyICgnXCIuY29uY2F0KHZlcnNpb24sIFwiJyByZWNlaXZlZClcIikpO1xuICB9XG5cbiAgbWF0Y2guc2hpZnQoKTtcbiAgcmV0dXJuIG1hdGNoO1xufTtcblxudmFyIGlzV2lsZGNhcmQgPSBmdW5jdGlvbiBpc1dpbGRjYXJkKHMpIHtcbiAgcmV0dXJuIHMgPT09ICcqJyB8fCBzID09PSAneCcgfHwgcyA9PT0gJ1gnO1xufTtcblxudmFyIHRyeVBhcnNlID0gZnVuY3Rpb24gdHJ5UGFyc2Uodikge1xuICB2YXIgbiA9IHBhcnNlSW50KHYsIDEwKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdiA6IG47XG59O1xuXG52YXIgZm9yY2VUeXBlID0gZnVuY3Rpb24gZm9yY2VUeXBlKGEsIGIpIHtcbiAgcmV0dXJuIF90eXBlb2YoYSkgIT09IF90eXBlb2YoYikgPyBbU3RyaW5nKGEpLCBTdHJpbmcoYildIDogW2EsIGJdO1xufTtcblxudmFyIGNvbXBhcmVTdHJpbmdzID0gZnVuY3Rpb24gY29tcGFyZVN0cmluZ3MoYSwgYikge1xuICBpZiAoaXNXaWxkY2FyZChhKSB8fCBpc1dpbGRjYXJkKGIpKSByZXR1cm4gMDtcblxuICB2YXIgX2ZvcmNlVHlwZSA9IGZvcmNlVHlwZSh0cnlQYXJzZShhKSwgdHJ5UGFyc2UoYikpLFxuICAgICAgX2ZvcmNlVHlwZTIgPSBfc2xpY2VkVG9BcnJheShfZm9yY2VUeXBlLCAyKSxcbiAgICAgIGFwID0gX2ZvcmNlVHlwZTJbMF0sXG4gICAgICBicCA9IF9mb3JjZVR5cGUyWzFdO1xuXG4gIGlmIChhcCA+IGJwKSByZXR1cm4gMTtcbiAgaWYgKGFwIDwgYnApIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59O1xuXG52YXIgY29tcGFyZVNlZ21lbnRzID0gZnVuY3Rpb24gY29tcGFyZVNlZ21lbnRzKGEsIGIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLm1heChhLmxlbmd0aCwgYi5sZW5ndGgpOyBpKyspIHtcbiAgICB2YXIgciA9IGNvbXBhcmVTdHJpbmdzKGFbaV0gfHwgJzAnLCBiW2ldIHx8ICcwJyk7XG4gICAgaWYgKHIgIT09IDApIHJldHVybiByO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59O1xuXG52YXIgb3BlcmF0b3JSZXNNYXAgPSB7XG4gICc+JzogWzFdLFxuICAnPj0nOiBbMCwgMV0sXG4gICc9JzogWzBdLFxuICAnPD0nOiBbLTEsIDBdLFxuICAnPCc6IFstMV1cbn07XG52YXIgYWxsb3dlZE9wZXJhdG9ycyA9IE9iamVjdC5rZXlzKG9wZXJhdG9yUmVzTWFwKTtcblxudmFyIGFzc2VydFZhbGlkT3BlcmF0b3IgPSBmdW5jdGlvbiBhc3NlcnRWYWxpZE9wZXJhdG9yKG9wKSB7XG4gIGlmICh0eXBlb2Ygb3AgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgb3BlcmF0b3IgdHlwZSwgZXhwZWN0ZWQgc3RyaW5nIGJ1dCBnb3QgXCIuY29uY2F0KF90eXBlb2Yob3ApKSk7XG4gIH1cblxuICBpZiAoYWxsb3dlZE9wZXJhdG9ycy5pbmRleE9mKG9wKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9wZXJhdG9yLCBleHBlY3RlZCBvbmUgb2YgXCIuY29uY2F0KGFsbG93ZWRPcGVyYXRvcnMuam9pbignfCcpKSk7XG4gIH1cbn07XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvaHlkcmF0aW9uLmpzXG52YXIgaHlkcmF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vc2hhcmVkL2lzQXJyYXkuanNcbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3V0aWxzLmpzXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgdXRpbHNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIHV0aWxzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gdXRpbHNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIHV0aWxzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gdXRpbHNfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbmZ1bmN0aW9uIHV0aWxzX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIHV0aWxzX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgdXRpbHNfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IHV0aWxzX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiB1dGlsc190eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLyoqXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuXG5cbi8vIFRPRE86IHVwZGF0ZSB0aGlzIHRvIHRoZSBmaXJzdCBSZWFjdCB2ZXJzaW9uIHRoYXQgaGFzIGEgY29ycmVzcG9uZGluZyBEZXZUb29scyBiYWNrZW5kXG52YXIgRklSU1RfREVWVE9PTFNfQkFDS0VORF9MT0NLU1RFUF9WRVIgPSAnOTk5LjkuOSc7XG5mdW5jdGlvbiBoYXNBc3NpZ25lZEJhY2tlbmQodmVyc2lvbikge1xuICBpZiAodmVyc2lvbiA9PSBudWxsIHx8IHZlcnNpb24gPT09ICcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGd0ZSh2ZXJzaW9uLCBGSVJTVF9ERVZUT09MU19CQUNLRU5EX0xPQ0tTVEVQX1ZFUik7XG59XG5mdW5jdGlvbiBjbGVhbkZvckJyaWRnZShkYXRhLCBpc1BhdGhBbGxvd2VkKSB7XG4gIHZhciBwYXRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbXTtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgIHZhciBjbGVhbmVkUGF0aHMgPSBbXTtcbiAgICB2YXIgdW5zZXJpYWxpemFibGVQYXRocyA9IFtdO1xuICAgIHZhciBjbGVhbmVkRGF0YSA9IE9iamVjdChoeWRyYXRpb25bXCJhXCIgLyogZGVoeWRyYXRlICovXSkoZGF0YSwgY2xlYW5lZFBhdGhzLCB1bnNlcmlhbGl6YWJsZVBhdGhzLCBwYXRoLCBpc1BhdGhBbGxvd2VkKTtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogY2xlYW5lZERhdGEsXG4gICAgICBjbGVhbmVkOiBjbGVhbmVkUGF0aHMsXG4gICAgICB1bnNlcmlhbGl6YWJsZTogdW5zZXJpYWxpemFibGVQYXRoc1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvcHlXaXRoRGVsZXRlKG9iaiwgcGF0aCkge1xuICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gIHZhciBrZXkgPSBwYXRoW2luZGV4XTtcbiAgdmFyIHVwZGF0ZWQgPSBPYmplY3QoaXNBcnJheVtcImFcIiAvKiBkZWZhdWx0ICovXSkob2JqKSA/IG9iai5zbGljZSgpIDogX29iamVjdFNwcmVhZCh7fSwgb2JqKTtcblxuICBpZiAoaW5kZXggKyAxID09PSBwYXRoLmxlbmd0aCkge1xuICAgIGlmIChPYmplY3QoaXNBcnJheVtcImFcIiAvKiBkZWZhdWx0ICovXSkodXBkYXRlZCkpIHtcbiAgICAgIHVwZGF0ZWQuc3BsaWNlKGtleSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB1cGRhdGVkW2tleV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgICB1cGRhdGVkW2tleV0gPSBjb3B5V2l0aERlbGV0ZShvYmpba2V5XSwgcGF0aCwgaW5kZXggKyAxKTtcbiAgfVxuXG4gIHJldHVybiB1cGRhdGVkO1xufSAvLyBUaGlzIGZ1bmN0aW9uIGV4cGVjdHMgcGF0aHMgdG8gYmUgdGhlIHNhbWUgZXhjZXB0IGZvciB0aGUgZmluYWwgdmFsdWUuXG4vLyBlLmcuIFsncGF0aCcsICd0bycsICdmb28nXSBhbmQgWydwYXRoJywgJ3RvJywgJ2JhciddXG5cbmZ1bmN0aW9uIGNvcHlXaXRoUmVuYW1lKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gIHZhciBvbGRLZXkgPSBvbGRQYXRoW2luZGV4XTtcbiAgdmFyIHVwZGF0ZWQgPSBPYmplY3QoaXNBcnJheVtcImFcIiAvKiBkZWZhdWx0ICovXSkob2JqKSA/IG9iai5zbGljZSgpIDogX29iamVjdFNwcmVhZCh7fSwgb2JqKTtcblxuICBpZiAoaW5kZXggKyAxID09PSBvbGRQYXRoLmxlbmd0aCkge1xuICAgIHZhciBuZXdLZXkgPSBuZXdQYXRoW2luZGV4XTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuXG4gICAgdXBkYXRlZFtuZXdLZXldID0gdXBkYXRlZFtvbGRLZXldO1xuXG4gICAgaWYgKE9iamVjdChpc0FycmF5W1wiYVwiIC8qIGRlZmF1bHQgKi9dKSh1cGRhdGVkKSkge1xuICAgICAgdXBkYXRlZC5zcGxpY2Uob2xkS2V5LCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHVwZGF0ZWRbb2xkS2V5XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuICAgIHVwZGF0ZWRbb2xkS2V5XSA9IGNvcHlXaXRoUmVuYW1lKG9ialtvbGRLZXldLCBvbGRQYXRoLCBuZXdQYXRoLCBpbmRleCArIDEpO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZWQ7XG59XG5mdW5jdGlvbiBjb3B5V2l0aFNldChvYmosIHBhdGgsIHZhbHVlKSB7XG4gIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcblxuICBpZiAoaW5kZXggPj0gcGF0aC5sZW5ndGgpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICB2YXIga2V5ID0gcGF0aFtpbmRleF07XG4gIHZhciB1cGRhdGVkID0gT2JqZWN0KGlzQXJyYXlbXCJhXCIgLyogZGVmYXVsdCAqL10pKG9iaikgPyBvYmouc2xpY2UoKSA6IF9vYmplY3RTcHJlYWQoe30sIG9iaik7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcblxuICB1cGRhdGVkW2tleV0gPSBjb3B5V2l0aFNldChvYmpba2V5XSwgcGF0aCwgdmFsdWUsIGluZGV4ICsgMSk7XG4gIHJldHVybiB1cGRhdGVkO1xufVxuZnVuY3Rpb24gZ2V0RWZmZWN0RHVyYXRpb25zKHJvb3QpIHtcbiAgLy8gUHJvZmlsaW5nIGR1cmF0aW9ucyBhcmUgb25seSBhdmFpbGFibGUgZm9yIGNlcnRhaW4gYnVpbGRzLlxuICAvLyBJZiBhdmFpbGFibGUsIHRoZXknbGwgYmUgc3RvcmVkIG9uIHRoZSBIb3N0Um9vdC5cbiAgdmFyIGVmZmVjdER1cmF0aW9uID0gbnVsbDtcbiAgdmFyIHBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IG51bGw7XG4gIHZhciBob3N0Um9vdCA9IHJvb3QuY3VycmVudDtcblxuICBpZiAoaG9zdFJvb3QgIT0gbnVsbCkge1xuICAgIHZhciBzdGF0ZU5vZGUgPSBob3N0Um9vdC5zdGF0ZU5vZGU7XG5cbiAgICBpZiAoc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgIGVmZmVjdER1cmF0aW9uID0gc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uICE9IG51bGwgPyBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gOiBudWxsO1xuICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiAhPSBudWxsID8gc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA6IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlZmZlY3REdXJhdGlvbjogZWZmZWN0RHVyYXRpb24sXG4gICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uOiBwYXNzaXZlRWZmZWN0RHVyYXRpb25cbiAgfTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVRvU3RyaW5nKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgfVxuXG4gIHZhciBjYWNoZSA9IG5ldyBTZXQoKTsgLy8gVXNlIGEgY3VzdG9tIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIHByb3RlY3QgYWdhaW5zdCBjaXJjdWxhciByZWZlcmVuY2VzLlxuXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh1dGlsc190eXBlb2YodmFsdWUpID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNhY2hlLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjYWNoZS5hZGQodmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKSArICduJztcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sIDIpO1xufSAvLyBGb3JtYXRzIGFuIGFycmF5IG9mIGFyZ3Mgd2l0aCBhIHN0eWxlIGZvciBjb25zb2xlIG1ldGhvZHMsIHVzaW5nXG4vLyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbi8vICAgICAxLiBUaGUgZmlyc3QgcGFyYW0gaXMgYSBzdHJpbmcgdGhhdCBjb250YWlucyAlY1xuLy8gICAgICAgICAgLSBCYWlsIG91dCBhbmQgcmV0dXJuIHRoZSBhcmdzIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBzdHlsZXMuXG4vLyAgICAgICAgICAgIFdlIGRvbid0IHdhbnQgdG8gYWZmZWN0IHN0eWxlcyB0aGF0IHRoZSBkZXZlbG9wZXIgZGVsaWJlcmF0ZWx5IHNldC5cbi8vICAgICAyLiBUaGUgZmlyc3QgcGFyYW0gaXMgYSBzdHJpbmcgdGhhdCBkb2Vzbid0IGNvbnRhaW4gJWMgYnV0IGNvbnRhaW5zXG4vLyAgICAgICAgc3RyaW5nIGZvcm1hdHRpbmdcbi8vICAgICAgICAgIC0gW2AlYyR7YXJnc1swXX1gLCBzdHlsZSwgLi4uYXJncy5zbGljZSgxKV1cbi8vICAgICAgICAgIC0gTm90ZTogd2UgYXNzdW1lIHRoYXQgdGhlIHN0cmluZyBmb3JtYXR0aW5nIHRoYXQgdGhlIGRldmVsb3BlciB1c2VzXG4vLyAgICAgICAgICAgIGlzIGNvcnJlY3QuXG4vLyAgICAgMy4gVGhlIGZpcnN0IHBhcmFtIGlzIGEgc3RyaW5nIHRoYXQgZG9lc24ndCBjb250YWluIHN0cmluZyBmb3JtYXR0aW5nXG4vLyAgICAgICAgT1IgaXMgbm90IGEgc3RyaW5nXG4vLyAgICAgICAgICAtIENyZWF0ZSBhIGZvcm1hdHRpbmcgc3RyaW5nIHdoZXJlOlxuLy8gICAgICAgICAgICAgICAgIGJvb2xlYW4sIHN0cmluZywgc3ltYm9sIC0+ICVzXG4vLyAgICAgICAgICAgICAgICAgbnVtYmVyIC0+ICVmIE9SICVpIGRlcGVuZGluZyBvbiBpZiBpdCdzIGFuIGludCBvciBmbG9hdFxuLy8gICAgICAgICAgICAgICAgIGRlZmF1bHQgLT4gJW9cblxuZnVuY3Rpb24gZm9ybWF0V2l0aFN0eWxlcyhpbnB1dEFyZ3MsIHN0eWxlKSB7XG4gIGlmIChpbnB1dEFyZ3MgPT09IHVuZGVmaW5lZCB8fCBpbnB1dEFyZ3MgPT09IG51bGwgfHwgaW5wdXRBcmdzLmxlbmd0aCA9PT0gMCB8fCAvLyBNYXRjaGVzIGFueSBvZiAlYyBidXQgbm90ICUlY1xuICB0eXBlb2YgaW5wdXRBcmdzWzBdID09PSAnc3RyaW5nJyAmJiBpbnB1dEFyZ3NbMF0ubWF0Y2goLyhbXiVdfF4pKCVjKS9nKSB8fCBzdHlsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGlucHV0QXJncztcbiAgfSAvLyBNYXRjaGVzIGFueSBvZiAlKG98T3xkfGl8c3xmKSwgYnV0IG5vdCAlJShvfE98ZHxpfHN8ZilcblxuXG4gIHZhciBSRUdFWFAgPSAvKFteJV18XikoKCUlKSopKCUoW29PZGlzZl0pKS9nO1xuXG4gIGlmICh0eXBlb2YgaW5wdXRBcmdzWzBdID09PSAnc3RyaW5nJyAmJiBpbnB1dEFyZ3NbMF0ubWF0Y2goUkVHRVhQKSkge1xuICAgIHJldHVybiBbXCIlY1wiLmNvbmNhdChpbnB1dEFyZ3NbMF0pLCBzdHlsZV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShpbnB1dEFyZ3Muc2xpY2UoMSkpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZmlyc3RBcmcgPSBpbnB1dEFyZ3MucmVkdWNlKGZ1bmN0aW9uIChmb3JtYXRTdHIsIGVsZW0sIGkpIHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBmb3JtYXRTdHIgKz0gJyAnO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHV0aWxzX3R5cGVvZihlbGVtKSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICByZXR1cm4gZm9ybWF0U3RyICs9ICclcyc7XG5cbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICB2YXIgZm9ybWF0dGluZyA9IE51bWJlci5pc0ludGVnZXIoZWxlbSkgPyAnJWknIDogJyVmJztcbiAgICAgICAgICByZXR1cm4gZm9ybWF0U3RyICs9IGZvcm1hdHRpbmc7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZm9ybWF0U3RyICs9ICclbyc7XG4gICAgICB9XG4gICAgfSwgJyVjJyk7XG4gICAgcmV0dXJuIFtmaXJzdEFyZywgc3R5bGVdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoaW5wdXRBcmdzKSk7XG4gIH1cbn0gLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3RtcGZzL2Zvcm1hdC11dGlsL2Jsb2IvMGU2MmQ0MzBlZmIwYTFjNTE0NDg3MDlhYmQzZTI0MDZjMTRkODQwMS9mb3JtYXQuanMjTDFcbi8vIGJhc2VkIG9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9jb25zb2xlI1VzaW5nX3N0cmluZ19zdWJzdGl0dXRpb25zXG4vLyBJbXBsZW1lbnRzIHMsIGQsIGkgYW5kIGYgcGxhY2Vob2xkZXJzXG4vLyBOT1RFOiBLRUVQIElOIFNZTkMgd2l0aCBzcmMvaG9vay5qc1xuXG5mdW5jdGlvbiBmb3JtYXQobWF5YmVNZXNzYWdlKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBpbnB1dEFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGlucHV0QXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgYXJncyA9IGlucHV0QXJncy5zbGljZSgpO1xuICB2YXIgZm9ybWF0dGVkID0gU3RyaW5nKG1heWJlTWVzc2FnZSk7IC8vIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZywgY2hlY2sgZm9yIHN1YnN0aXR1dGlvbnMuXG5cbiAgaWYgKHR5cGVvZiBtYXliZU1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICB2YXIgUkVHRVhQID0gLyglPykoJShbamRzXSkpL2c7XG4gICAgICBmb3JtYXR0ZWQgPSBmb3JtYXR0ZWQucmVwbGFjZShSRUdFWFAsIGZ1bmN0aW9uIChtYXRjaCwgZXNjYXBlZCwgcHRuLCBmbGFnKSB7XG4gICAgICAgIHZhciBhcmcgPSBhcmdzLnNoaWZ0KCk7XG5cbiAgICAgICAgc3dpdGNoIChmbGFnKSB7XG4gICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICBhcmcgKz0gJyc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgIGNhc2UgJ2knOlxuICAgICAgICAgICAgYXJnID0gcGFyc2VJbnQoYXJnLCAxMCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICBhcmcgPSBwYXJzZUZsb2F0KGFyZykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlc2NhcGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ3MudW5zaGlmdChhcmcpO1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gLy8gQXJndW1lbnRzIHRoYXQgcmVtYWluIGFmdGVyIGZvcm1hdHRpbmcuXG5cblxuICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvcm1hdHRlZCArPSAnICcgKyBTdHJpbmcoYXJnc1tpXSk7XG4gICAgfVxuICB9IC8vIFVwZGF0ZSBlc2NhcGVkICUlIHZhbHVlcy5cblxuXG4gIGZvcm1hdHRlZCA9IGZvcm1hdHRlZC5yZXBsYWNlKC8lezIsMn0vZywgJyUnKTtcbiAgcmV0dXJuIFN0cmluZyhmb3JtYXR0ZWQpO1xufVxuZnVuY3Rpb24gaXNTeW5jaHJvbm91c1hIUlN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuICEhKHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuZmVhdHVyZVBvbGljeSAmJiB3aW5kb3cuZG9jdW1lbnQuZmVhdHVyZVBvbGljeS5hbGxvd3NGZWF0dXJlKCdzeW5jLXhocicpKTtcbn1cbmZ1bmN0aW9uIGd0KCkge1xuICB2YXIgYSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG4gIHZhciBiID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcbiAgcmV0dXJuIGNvbXBhcmVWZXJzaW9ucyhhLCBiKSA9PT0gMTtcbn1cbmZ1bmN0aW9uIGd0ZSgpIHtcbiAgdmFyIGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICB2YXIgYiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG4gIHJldHVybiBjb21wYXJlVmVyc2lvbnMoYSwgYikgPiAtMTtcbn1cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2NhbFN0b3JhZ2VHZXRJdGVtOyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBsb2NhbFN0b3JhZ2VSZW1vdmVJdGVtICovXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvY2FsU3RvcmFnZVNldEl0ZW07IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzZXNzaW9uU3RvcmFnZUdldEl0ZW07IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzZXNzaW9uU3RvcmFnZVJlbW92ZUl0ZW07IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzZXNzaW9uU3RvcmFnZVNldEl0ZW07IH0pO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5mdW5jdGlvbiBsb2NhbFN0b3JhZ2VHZXRJdGVtKGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBsb2NhbFN0b3JhZ2VSZW1vdmVJdGVtKGtleSkge1xuICB0cnkge1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxufVxuZnVuY3Rpb24gbG9jYWxTdG9yYWdlU2V0SXRlbShrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge31cbn1cbmZ1bmN0aW9uIHNlc3Npb25TdG9yYWdlR2V0SXRlbShrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBzZXNzaW9uU3RvcmFnZVJlbW92ZUl0ZW0oa2V5KSB7XG4gIHRyeSB7XG4gICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICB9IGNhdGNoIChlcnJvcikge31cbn1cbmZ1bmN0aW9uIHNlc3Npb25TdG9yYWdlU2V0SXRlbShrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxufVxuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoaXNBcnJheSk7XG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5pZiAodHJ1ZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xufSBlbHNlIHt9XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgaXNTdHJpbmdDb21wb25lbnRTdGFjayAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IGRhbmdlcm91c19zZXRUYXJnZXRDb25zb2xlRm9yVGVzdGluZyAqL1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiByZWdpc3RlclJlbmRlcmVyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJiXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcGF0Y2g7IH0pO1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IHVucGF0Y2ggKi9cbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcGF0Y2hGb3JTdHJpY3RNb2RlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJmXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdW5wYXRjaEZvclN0cmljdE1vZGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwYXRjaENvbnNvbGVVc2luZ1dpbmRvd1ZhbHVlczsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHdyaXRlQ29uc29sZVBhdGNoU2V0dGluZ3NUb1dpbmRvdzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGluc3RhbGxDb25zb2xlRnVuY3Rpb25zVG9XaW5kb3c7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcmVuZGVyZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9EZXZUb29sc0ZpYmVyQ29tcG9uZW50U3RhY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHJlYWN0X2RldnRvb2xzX2ZlYXR1cmVfZmxhZ3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cblxuXG5cblxudmFyIE9WRVJSSURFX0NPTlNPTEVfTUVUSE9EUyA9IFsnZXJyb3InLCAndHJhY2UnLCAnd2FybiddO1xudmFyIERJTU1FRF9OT0RFX0NPTlNPTEVfQ09MT1IgPSAnXFx4MWJbMm0lc1xceDFiWzBtJzsgLy8gUmVhY3QncyBjdXN0b20gYnVpbHQgY29tcG9uZW50IHN0YWNrIHN0cmluZ3MgbWF0Y2ggXCJcXHN7NH1pblwiXG4vLyBDaHJvbWUncyBwcmVmaXggbWF0Y2hlcyBcIlxcc3s0fWF0XCJcblxudmFyIFBSRUZJWF9SRUdFWCA9IC9cXHN7NH0oaW58YXQpXFxzezF9LzsgLy8gRmlyZWZveCBhbmQgU2FmYXJpIGhhdmUgbm8gcHJlZml4IChcIlwiKVxuLy8gYnV0IHdlIGNhbiBmYWxsYmFjayB0byBsb29raW5nIGZvciBsb2NhdGlvbiBpbmZvIChlLmcuIFwiZm9vLmpzOjEyOjM0NVwiKVxuXG52YXIgUk9XX0NPTFVNTl9OVU1CRVJfUkVHRVggPSAvOlxcZCs6XFxkKyhcXG58JCkvO1xuZnVuY3Rpb24gaXNTdHJpbmdDb21wb25lbnRTdGFjayh0ZXh0KSB7XG4gIHJldHVybiBQUkVGSVhfUkVHRVgudGVzdCh0ZXh0KSB8fCBST1dfQ09MVU1OX05VTUJFUl9SRUdFWC50ZXN0KHRleHQpO1xufVxudmFyIFNUWUxFX0RJUkVDVElWRV9SRUdFWCA9IC9eJWMvOyAvLyBUaGlzIGZ1bmN0aW9uIHRlbGxzIHdoZXRoZXIgb3Igbm90IHRoZSBhcmd1bWVudHMgZm9yIGEgY29uc29sZVxuLy8gbWV0aG9kIGhhcyBiZWVuIG92ZXJyaWRkZW4gYnkgdGhlIHBhdGNoRm9yU3RyaWN0TW9kZSBmdW5jdGlvbi5cbi8vIElmIGl0IGhhcyB3ZSdsbCBuZWVkIHRvIGRvIHNvbWUgc3BlY2lhbCBmb3JtYXR0aW5nIG9mIHRoZSBhcmd1bWVudHNcbi8vIHNvIHRoZSBjb25zb2xlIGNvbG9yIHN0YXlzIGNvbnNpc3RlbnRcblxuZnVuY3Rpb24gaXNTdHJpY3RNb2RlT3ZlcnJpZGUoYXJncywgbWV0aG9kKSB7XG4gIHJldHVybiBhcmdzLmxlbmd0aCA+PSAyICYmIFNUWUxFX0RJUkVDVElWRV9SRUdFWC50ZXN0KGFyZ3NbMF0pICYmIGFyZ3NbMV0gPT09IFwiY29sb3I6IFwiLmNvbmNhdChnZXRDb25zb2xlQ29sb3IobWV0aG9kKSB8fCAnJyk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnNvbGVDb2xvcihtZXRob2QpIHtcbiAgc3dpdGNoIChtZXRob2QpIHtcbiAgICBjYXNlICd3YXJuJzpcbiAgICAgIHJldHVybiBjb25zb2xlU2V0dGluZ3NSZWYuYnJvd3NlclRoZW1lID09PSAnbGlnaHQnID8gXCJyZ2JhKDI1MCwgMTgwLCA1MCwgMC43NSlcIiA6IFwicmdiYSgyNTAsIDE4MCwgNTAsIDAuNSlcIjtcblxuICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgIHJldHVybiBjb25zb2xlU2V0dGluZ3NSZWYuYnJvd3NlclRoZW1lID09PSAnbGlnaHQnID8gXCJyZ2JhKDI1MCwgMTIzLCAxMzAsIDAuNzUpXCIgOiBcInJnYmEoMjUwLCAxMjMsIDEzMCwgMC41KVwiO1xuXG4gICAgY2FzZSAnbG9nJzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGNvbnNvbGVTZXR0aW5nc1JlZi5icm93c2VyVGhlbWUgPT09ICdsaWdodCcgPyBcInJnYmEoMTI1LCAxMjUsIDEyNSwgMC43NSlcIiA6IFwicmdiYSgxMjUsIDEyNSwgMTI1LCAwLjUpXCI7XG4gIH1cbn1cblxudmFyIGluamVjdGVkUmVuZGVyZXJzID0gbmV3IE1hcCgpO1xudmFyIHRhcmdldENvbnNvbGUgPSBjb25zb2xlO1xudmFyIHRhcmdldENvbnNvbGVNZXRob2RzID0ge307XG5cbmZvciAodmFyIG1ldGhvZCBpbiBjb25zb2xlKSB7XG4gIHRhcmdldENvbnNvbGVNZXRob2RzW21ldGhvZF0gPSBjb25zb2xlW21ldGhvZF07XG59XG5cbnZhciB1bnBhdGNoRm4gPSBudWxsO1xudmFyIGlzTm9kZSA9IGZhbHNlO1xuXG50cnkge1xuICBpc05vZGUgPSB1bmRlZmluZWQgPT09IGdsb2JhbDtcbn0gY2F0Y2ggKGVycm9yKSB7fSAvLyBFbmFibGVzIGUuZy4gSmVzdCB0ZXN0cyB0byBpbmplY3QgYSBtb2NrIGNvbnNvbGUgb2JqZWN0LlxuXG5cbmZ1bmN0aW9uIGRhbmdlcm91c19zZXRUYXJnZXRDb25zb2xlRm9yVGVzdGluZyh0YXJnZXRDb25zb2xlRm9yVGVzdGluZykge1xuICB0YXJnZXRDb25zb2xlID0gdGFyZ2V0Q29uc29sZUZvclRlc3Rpbmc7XG4gIHRhcmdldENvbnNvbGVNZXRob2RzID0ge307XG5cbiAgZm9yICh2YXIgX21ldGhvZCBpbiB0YXJnZXRDb25zb2xlKSB7XG4gICAgdGFyZ2V0Q29uc29sZU1ldGhvZHNbX21ldGhvZF0gPSBjb25zb2xlW19tZXRob2RdO1xuICB9XG59IC8vIHYxNiByZW5kZXJlcnMgc2hvdWxkIHVzZSB0aGlzIG1ldGhvZCB0byBpbmplY3QgaW50ZXJuYWxzIG5lY2Vzc2FyeSB0byBnZW5lcmF0ZSBhIGNvbXBvbmVudCBzdGFjay5cbi8vIFRoZXNlIGludGVybmFscyB3aWxsIGJlIHVzZWQgaWYgdGhlIGNvbnNvbGUgaXMgcGF0Y2hlZC5cbi8vIEluamVjdGluZyB0aGVtIHNlcGFyYXRlbHkgYWxsb3dzIHRoZSBjb25zb2xlIHRvIGVhc2lseSBiZSBwYXRjaGVkIG9yIHVuLXBhdGNoZWQgbGF0ZXIgKGF0IHJ1bnRpbWUpLlxuXG5mdW5jdGlvbiByZWdpc3RlclJlbmRlcmVyKHJlbmRlcmVyLCBvbkVycm9yT3JXYXJuaW5nKSB7XG4gIHZhciBjdXJyZW50RGlzcGF0Y2hlclJlZiA9IHJlbmRlcmVyLmN1cnJlbnREaXNwYXRjaGVyUmVmLFxuICAgICAgZ2V0Q3VycmVudEZpYmVyID0gcmVuZGVyZXIuZ2V0Q3VycmVudEZpYmVyLFxuICAgICAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgPSByZW5kZXJlci5maW5kRmliZXJCeUhvc3RJbnN0YW5jZSxcbiAgICAgIHZlcnNpb24gPSByZW5kZXJlci52ZXJzaW9uOyAvLyBJZ25vcmUgUmVhY3QgdjE1IGFuZCBvbGRlciBiZWNhdXNlIHRoZXkgZG9uJ3QgZXhwb3NlIGEgY29tcG9uZW50IHN0YWNrIGFueXdheS5cblxuICBpZiAodHlwZW9mIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIGN1cnJlbnREaXNwYXRjaGVyUmVmIGdldHMgaW5qZWN0ZWQgZm9yIHYxNi44KyB0byBzdXBwb3J0IGhvb2tzIGluc3BlY3Rpb24uXG4gIC8vIGdldEN1cnJlbnRGaWJlciBnZXRzIGluamVjdGVkIGZvciB2MTYuOSsuXG5cblxuICBpZiAoY3VycmVudERpc3BhdGNoZXJSZWYgIT0gbnVsbCAmJiB0eXBlb2YgZ2V0Q3VycmVudEZpYmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIF9nZXRJbnRlcm5hbFJlYWN0Q29ucyA9IE9iamVjdChfcmVuZGVyZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBnZXRJbnRlcm5hbFJlYWN0Q29uc3RhbnRzICovIFwiYlwiXSkodmVyc2lvbiksXG4gICAgICAgIFJlYWN0VHlwZU9mV29yayA9IF9nZXRJbnRlcm5hbFJlYWN0Q29ucy5SZWFjdFR5cGVPZldvcms7XG5cbiAgICBpbmplY3RlZFJlbmRlcmVycy5zZXQocmVuZGVyZXIsIHtcbiAgICAgIGN1cnJlbnREaXNwYXRjaGVyUmVmOiBjdXJyZW50RGlzcGF0Y2hlclJlZixcbiAgICAgIGdldEN1cnJlbnRGaWJlcjogZ2V0Q3VycmVudEZpYmVyLFxuICAgICAgd29ya1RhZ01hcDogUmVhY3RUeXBlT2ZXb3JrLFxuICAgICAgb25FcnJvck9yV2FybmluZzogb25FcnJvck9yV2FybmluZ1xuICAgIH0pO1xuICB9XG59XG52YXIgY29uc29sZVNldHRpbmdzUmVmID0ge1xuICBhcHBlbmRDb21wb25lbnRTdGFjazogZmFsc2UsXG4gIGJyZWFrT25Db25zb2xlRXJyb3JzOiBmYWxzZSxcbiAgc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzOiBmYWxzZSxcbiAgaGlkZUNvbnNvbGVMb2dzSW5TdHJpY3RNb2RlOiBmYWxzZSxcbiAgYnJvd3NlclRoZW1lOiAnZGFyaydcbn07IC8vIFBhdGNoZXMgY29uc29sZSBtZXRob2RzIHRvIGFwcGVuZCBjb21wb25lbnQgc3RhY2sgZm9yIHRoZSBjdXJyZW50IGZpYmVyLlxuLy8gQ2FsbCB1bnBhdGNoKCkgdG8gcmVtb3ZlIHRoZSBpbmplY3RlZCBiZWhhdmlvci5cblxuZnVuY3Rpb24gcGF0Y2goX3JlZikge1xuICB2YXIgYXBwZW5kQ29tcG9uZW50U3RhY2sgPSBfcmVmLmFwcGVuZENvbXBvbmVudFN0YWNrLFxuICAgICAgYnJlYWtPbkNvbnNvbGVFcnJvcnMgPSBfcmVmLmJyZWFrT25Db25zb2xlRXJyb3JzLFxuICAgICAgc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzID0gX3JlZi5zaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnMsXG4gICAgICBoaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGUgPSBfcmVmLmhpZGVDb25zb2xlTG9nc0luU3RyaWN0TW9kZSxcbiAgICAgIGJyb3dzZXJUaGVtZSA9IF9yZWYuYnJvd3NlclRoZW1lO1xuICAvLyBTZXR0aW5ncyBtYXkgY2hhbmdlIGFmdGVyIHdlJ3ZlIHBhdGNoZWQgdGhlIGNvbnNvbGUuXG4gIC8vIFVzaW5nIGEgc2hhcmVkIHJlZiBhbGxvd3MgdGhlIHBhdGNoIGZ1bmN0aW9uIHRvIHJlYWQgdGhlIGxhdGVzdCB2YWx1ZXMuXG4gIGNvbnNvbGVTZXR0aW5nc1JlZi5hcHBlbmRDb21wb25lbnRTdGFjayA9IGFwcGVuZENvbXBvbmVudFN0YWNrO1xuICBjb25zb2xlU2V0dGluZ3NSZWYuYnJlYWtPbkNvbnNvbGVFcnJvcnMgPSBicmVha09uQ29uc29sZUVycm9ycztcbiAgY29uc29sZVNldHRpbmdzUmVmLnNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycyA9IHNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycztcbiAgY29uc29sZVNldHRpbmdzUmVmLmhpZGVDb25zb2xlTG9nc0luU3RyaWN0TW9kZSA9IGhpZGVDb25zb2xlTG9nc0luU3RyaWN0TW9kZTtcbiAgY29uc29sZVNldHRpbmdzUmVmLmJyb3dzZXJUaGVtZSA9IGJyb3dzZXJUaGVtZTtcblxuICBpZiAoYXBwZW5kQ29tcG9uZW50U3RhY2sgfHwgYnJlYWtPbkNvbnNvbGVFcnJvcnMgfHwgc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzKSB7XG4gICAgaWYgKHVucGF0Y2hGbiAhPT0gbnVsbCkge1xuICAgICAgLy8gRG9uJ3QgcGF0Y2ggdHdpY2UuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9yaWdpbmFsQ29uc29sZU1ldGhvZHMgPSB7fTtcblxuICAgIHVucGF0Y2hGbiA9IGZ1bmN0aW9uIHVucGF0Y2hGbigpIHtcbiAgICAgIGZvciAodmFyIF9tZXRob2QyIGluIG9yaWdpbmFsQ29uc29sZU1ldGhvZHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0YXJnZXRDb25zb2xlW19tZXRob2QyXSA9IG9yaWdpbmFsQ29uc29sZU1ldGhvZHNbX21ldGhvZDJdO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgT1ZFUlJJREVfQ09OU09MRV9NRVRIT0RTLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG9yaWdpbmFsTWV0aG9kID0gb3JpZ2luYWxDb25zb2xlTWV0aG9kc1ttZXRob2RdID0gdGFyZ2V0Q29uc29sZVttZXRob2RdLl9fUkVBQ1RfREVWVE9PTFNfT1JJR0lOQUxfTUVUSE9EX18gPyB0YXJnZXRDb25zb2xlW21ldGhvZF0uX19SRUFDVF9ERVZUT09MU19PUklHSU5BTF9NRVRIT0RfXyA6IHRhcmdldENvbnNvbGVbbWV0aG9kXTsgLy8gJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XVxuXG4gICAgICAgIHZhciBvdmVycmlkZU1ldGhvZCA9IGZ1bmN0aW9uIG92ZXJyaWRlTWV0aG9kKCkge1xuICAgICAgICAgIHZhciBzaG91bGRBcHBlbmRXYXJuaW5nU3RhY2sgPSBmYWxzZTtcblxuICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWV0aG9kICE9PSAnbG9nJykge1xuICAgICAgICAgICAgaWYgKGNvbnNvbGVTZXR0aW5nc1JlZi5hcHBlbmRDb21wb25lbnRTdGFjaykge1xuICAgICAgICAgICAgICB2YXIgbGFzdEFyZyA9IGFyZ3MubGVuZ3RoID4gMCA/IGFyZ3NbYXJncy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgICAgICAgIHZhciBhbHJlYWR5SGFzQ29tcG9uZW50U3RhY2sgPSB0eXBlb2YgbGFzdEFyZyA9PT0gJ3N0cmluZycgJiYgaXNTdHJpbmdDb21wb25lbnRTdGFjayhsYXN0QXJnKTsgLy8gSWYgd2UgYXJlIGV2ZXIgY2FsbGVkIHdpdGggYSBzdHJpbmcgdGhhdCBhbHJlYWR5IGhhcyBhIGNvbXBvbmVudCBzdGFjayxcbiAgICAgICAgICAgICAgLy8gZS5nLiBhIFJlYWN0IGVycm9yL3dhcm5pbmcsIGRvbid0IGFwcGVuZCBhIHNlY29uZCBzdGFjay5cblxuICAgICAgICAgICAgICBzaG91bGRBcHBlbmRXYXJuaW5nU3RhY2sgPSAhYWxyZWFkeUhhc0NvbXBvbmVudFN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzaG91bGRTaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnMgPSBjb25zb2xlU2V0dGluZ3NSZWYuc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzICYmIChtZXRob2QgPT09ICdlcnJvcicgfHwgbWV0aG9kID09PSAnd2FybicpOyAvLyBTZWFyY2ggZm9yIHRoZSBmaXJzdCByZW5kZXJlciB0aGF0IGhhcyBhIGN1cnJlbnQgRmliZXIuXG4gICAgICAgICAgLy8gV2UgZG9uJ3QgaGFuZGxlIHRoZSBlZGdlIGNhc2Ugb2Ygc3RhY2tzIGZvciBtb3JlIHRoYW4gb25lIChlLmcuIGludGVybGVhdmVkIHJlbmRlcmVycz8pXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZvci1vZi1sb29wcy9uby1mb3Itb2YtbG9vcHNcblxuICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpbmplY3RlZFJlbmRlcmVycy52YWx1ZXMoKSksXG4gICAgICAgICAgICAgIF9zdGVwO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zdGVwLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgY3VycmVudERpc3BhdGNoZXJSZWYgPSBfc3RlcCR2YWx1ZS5jdXJyZW50RGlzcGF0Y2hlclJlZixcbiAgICAgICAgICAgICAgICAgIGdldEN1cnJlbnRGaWJlciA9IF9zdGVwJHZhbHVlLmdldEN1cnJlbnRGaWJlcixcbiAgICAgICAgICAgICAgICAgIG9uRXJyb3JPcldhcm5pbmcgPSBfc3RlcCR2YWx1ZS5vbkVycm9yT3JXYXJuaW5nLFxuICAgICAgICAgICAgICAgICAgd29ya1RhZ01hcCA9IF9zdGVwJHZhbHVlLndvcmtUYWdNYXA7XG4gICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudEZpYmVyKCk7XG5cbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhdGNoKCkgaXMgY2FsbGVkIGJ5IHR3byBwbGFjZXM6ICgxKSB0aGUgaG9vayBhbmQgKDIpIHRoZSByZW5kZXJlciBiYWNrZW5kLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYmFja2VuZCBpcyB3aGF0IGltcGxlbWVudHMgYSBtZXNzYWdlIHF1ZXVlLCBzbyBpdCdzIHRoZSBvbmx5IG9uZSB0aGF0IGluamVjdHMgb25FcnJvck9yV2FybmluZy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkVycm9yT3JXYXJuaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgb25FcnJvck9yV2FybmluZyhjdXJyZW50LCBtZXRob2QsIC8vIENvcHkgYXJncyBiZWZvcmUgd2UgbXV0YXRlIHRoZW0gKGUuZy4gYWRkaW5nIHRoZSBjb21wb25lbnQgc3RhY2spXG4gICAgICAgICAgICAgICAgICAgICAgYXJncy5zbGljZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQXBwZW5kV2FybmluZ1N0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRTdGFjayA9IE9iamVjdChfRGV2VG9vbHNGaWJlckNvbXBvbmVudFN0YWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kICovIFwiYlwiXSkod29ya1RhZ01hcCwgY3VycmVudCwgY3VycmVudERpc3BhdGNoZXJSZWYpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRTdGFjayAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpY3RNb2RlT3ZlcnJpZGUoYXJncywgbWV0aG9kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1swXSA9IFwiXCIuY29uY2F0KGFyZ3NbMF0sIFwiICVzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGNvbXBvbmVudFN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGNvbXBvbmVudFN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgbGV0IGEgRGV2VG9vbHMgb3IgUmVhY3QgaW50ZXJuYWwgZXJyb3IgaW50ZXJmZXJlIHdpdGggbG9nZ2luZy5cbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbnNvbGVTZXR0aW5nc1JlZi5icmVha09uQ29uc29sZUVycm9ycykge1xuICAgICAgICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIHdpdGggUmVhY3QgRGV2VG9vbHMgLS0tXG4gICAgICAgICAgICAvLyBUaGlzIGRlYnVnZ2VyIHN0YXRlbWVudCBtZWFucyB0aGF0IHlvdSd2ZSBlbmFibGVkIHRoZSBcImJyZWFrIG9uIHdhcm5pbmdzXCIgZmVhdHVyZS5cbiAgICAgICAgICAgIC8vIFVzZSB0aGUgYnJvd3NlcidzIENhbGwgU3RhY2sgcGFuZWwgdG8gc3RlcCBvdXQgb2YgdGhpcyBvdmVycmlkZSBmdW5jdGlvbi1cbiAgICAgICAgICAgIC8vIHRvIHdoZXJlIHRoZSBvcmlnaW5hbCB3YXJuaW5nIG9yIGVycm9yIHdhcyBsb2dnZWQuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZGVidWdnZXJcbiAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9yaWdpbmFsTWV0aG9kLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb3ZlcnJpZGVNZXRob2QuX19SRUFDVF9ERVZUT09MU19PUklHSU5BTF9NRVRIT0RfXyA9IG9yaWdpbmFsTWV0aG9kO1xuICAgICAgICBvcmlnaW5hbE1ldGhvZC5fX1JFQUNUX0RFVlRPT0xTX09WRVJSSURFX01FVEhPRF9fID0gb3ZlcnJpZGVNZXRob2Q7XG4gICAgICAgIHRhcmdldENvbnNvbGVbbWV0aG9kXSA9IG92ZXJyaWRlTWV0aG9kO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdW5wYXRjaCgpO1xuICB9XG59IC8vIFJlbW92ZWQgY29tcG9uZW50IHN0YWNrIHBhdGNoIGZyb20gY29uc29sZSBtZXRob2RzLlxuXG5mdW5jdGlvbiB1bnBhdGNoKCkge1xuICBpZiAodW5wYXRjaEZuICE9PSBudWxsKSB7XG4gICAgdW5wYXRjaEZuKCk7XG4gICAgdW5wYXRjaEZuID0gbnVsbDtcbiAgfVxufVxudmFyIHVucGF0Y2hGb3JTdHJpY3RNb2RlRm4gPSBudWxsOyAvLyBOT1RFOiBLRUVQIElOIFNZTkMgd2l0aCBzcmMvaG9vay5qczpwYXRjaENvbnNvbGVGb3JJbml0aWFsUmVuZGVySW5TdHJpY3RNb2RlXG5cbmZ1bmN0aW9uIHBhdGNoRm9yU3RyaWN0TW9kZSgpIHtcbiAgaWYgKHJlYWN0X2RldnRvb2xzX2ZlYXR1cmVfZmxhZ3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBjb25zb2xlTWFuYWdlZEJ5RGV2VG9vbHNEdXJpbmdTdHJpY3RNb2RlICovIFwiYVwiXSkge1xuICAgIHZhciBvdmVycmlkZUNvbnNvbGVNZXRob2RzID0gWydlcnJvcicsICdncm91cCcsICdncm91cENvbGxhcHNlZCcsICdpbmZvJywgJ2xvZycsICd0cmFjZScsICd3YXJuJ107XG5cbiAgICBpZiAodW5wYXRjaEZvclN0cmljdE1vZGVGbiAhPT0gbnVsbCkge1xuICAgICAgLy8gRG9uJ3QgcGF0Y2ggdHdpY2UuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9yaWdpbmFsQ29uc29sZU1ldGhvZHMgPSB7fTtcblxuICAgIHVucGF0Y2hGb3JTdHJpY3RNb2RlRm4gPSBmdW5jdGlvbiB1bnBhdGNoRm9yU3RyaWN0TW9kZUZuKCkge1xuICAgICAgZm9yICh2YXIgX21ldGhvZDMgaW4gb3JpZ2luYWxDb25zb2xlTWV0aG9kcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRhcmdldENvbnNvbGVbX21ldGhvZDNdID0gb3JpZ2luYWxDb25zb2xlTWV0aG9kc1tfbWV0aG9kM107XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuICAgICAgfVxuICAgIH07XG5cbiAgICBvdmVycmlkZUNvbnNvbGVNZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG9yaWdpbmFsTWV0aG9kID0gb3JpZ2luYWxDb25zb2xlTWV0aG9kc1ttZXRob2RdID0gdGFyZ2V0Q29uc29sZVttZXRob2RdLl9fUkVBQ1RfREVWVE9PTFNfU1RSSUNUX01PREVfT1JJR0lOQUxfTUVUSE9EX18gPyB0YXJnZXRDb25zb2xlW21ldGhvZF0uX19SRUFDVF9ERVZUT09MU19TVFJJQ1RfTU9ERV9PUklHSU5BTF9NRVRIT0RfXyA6IHRhcmdldENvbnNvbGVbbWV0aG9kXTsgLy8gJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XVxuXG4gICAgICAgIHZhciBvdmVycmlkZU1ldGhvZCA9IGZ1bmN0aW9uIG92ZXJyaWRlTWV0aG9kKCkge1xuICAgICAgICAgIGlmICghY29uc29sZVNldHRpbmdzUmVmLmhpZGVDb25zb2xlTG9nc0luU3RyaWN0TW9kZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGltIHRoZSB0ZXh0IGNvbG9yIG9mIHRoZSBkb3VibGUgbG9ncyBpZiB3ZSdyZSBub3RcbiAgICAgICAgICAgIC8vIGhpZGluZyB0aGVtLlxuICAgICAgICAgICAgaWYgKGlzTm9kZSkge1xuICAgICAgICAgICAgICBvcmlnaW5hbE1ldGhvZChESU1NRURfTk9ERV9DT05TT0xFX0NPTE9SLCBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBmb3JtYXQgKi8gXCJlXCJdLmFwcGx5KHZvaWQgMCwgYXJncykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGNvbG9yID0gZ2V0Q29uc29sZUNvbG9yKG1ldGhvZCk7XG5cbiAgICAgICAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxNZXRob2QuYXBwbHkodm9pZCAwLCBfdG9Db25zdW1hYmxlQXJyYXkoT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGZvcm1hdFdpdGhTdHlsZXMgKi8gXCJmXCJdKShhcmdzLCBcImNvbG9yOiBcIi5jb25jYXQoY29sb3IpKSkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdDb25zb2xlIGNvbG9yIGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgb3ZlcnJpZGVNZXRob2QuX19SRUFDVF9ERVZUT09MU19TVFJJQ1RfTU9ERV9PUklHSU5BTF9NRVRIT0RfXyA9IG9yaWdpbmFsTWV0aG9kO1xuICAgICAgICBvcmlnaW5hbE1ldGhvZC5fX1JFQUNUX0RFVlRPT0xTX1NUUklDVF9NT0RFX09WRVJSSURFX01FVEhPRF9fID0gb3ZlcnJpZGVNZXRob2Q7XG4gICAgICAgIHRhcmdldENvbnNvbGVbbWV0aG9kXSA9IG92ZXJyaWRlTWV0aG9kO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgfSk7XG4gIH1cbn0gLy8gTk9URTogS0VFUCBJTiBTWU5DIHdpdGggc3JjL2hvb2suanM6dW5wYXRjaENvbnNvbGVGb3JJbml0aWFsUmVuZGVySW5TdHJpY3RNb2RlXG5cbmZ1bmN0aW9uIHVucGF0Y2hGb3JTdHJpY3RNb2RlKCkge1xuICBpZiAocmVhY3RfZGV2dG9vbHNfZmVhdHVyZV9mbGFnc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGNvbnNvbGVNYW5hZ2VkQnlEZXZUb29sc0R1cmluZ1N0cmljdE1vZGUgKi8gXCJhXCJdKSB7XG4gICAgaWYgKHVucGF0Y2hGb3JTdHJpY3RNb2RlRm4gIT09IG51bGwpIHtcbiAgICAgIHVucGF0Y2hGb3JTdHJpY3RNb2RlRm4oKTtcbiAgICAgIHVucGF0Y2hGb3JTdHJpY3RNb2RlRm4gPSBudWxsO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcGF0Y2hDb25zb2xlVXNpbmdXaW5kb3dWYWx1ZXMoKSB7XG4gIHZhciBfY2FzdEJvb2wsIF9jYXN0Qm9vbDIsIF9jYXN0Qm9vbDMsIF9jYXN0Qm9vbDQsIF9jYXN0QnJvd3NlclRoZW1lO1xuXG4gIHZhciBhcHBlbmRDb21wb25lbnRTdGFjayA9IChfY2FzdEJvb2wgPSBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogY2FzdEJvb2wgKi8gXCJhXCJdKSh3aW5kb3cuX19SRUFDVF9ERVZUT09MU19BUFBFTkRfQ09NUE9ORU5UX1NUQUNLX18pKSAhPT0gbnVsbCAmJiBfY2FzdEJvb2wgIT09IHZvaWQgMCA/IF9jYXN0Qm9vbCA6IHRydWU7XG4gIHZhciBicmVha09uQ29uc29sZUVycm9ycyA9IChfY2FzdEJvb2wyID0gT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGNhc3RCb29sICovIFwiYVwiXSkod2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfQlJFQUtfT05fQ09OU09MRV9FUlJPUlNfXykpICE9PSBudWxsICYmIF9jYXN0Qm9vbDIgIT09IHZvaWQgMCA/IF9jYXN0Qm9vbDIgOiBmYWxzZTtcbiAgdmFyIHNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycyA9IChfY2FzdEJvb2wzID0gT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGNhc3RCb29sICovIFwiYVwiXSkod2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfU0hPV19JTkxJTkVfV0FSTklOR1NfQU5EX0VSUk9SU19fKSkgIT09IG51bGwgJiYgX2Nhc3RCb29sMyAhPT0gdm9pZCAwID8gX2Nhc3RCb29sMyA6IHRydWU7XG4gIHZhciBoaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGUgPSAoX2Nhc3RCb29sNCA9IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBjYXN0Qm9vbCAqLyBcImFcIl0pKHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0hJREVfQ09OU09MRV9MT0dTX0lOX1NUUklDVF9NT0RFX18pKSAhPT0gbnVsbCAmJiBfY2FzdEJvb2w0ICE9PSB2b2lkIDAgPyBfY2FzdEJvb2w0IDogZmFsc2U7XG4gIHZhciBicm93c2VyVGhlbWUgPSAoX2Nhc3RCcm93c2VyVGhlbWUgPSBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogY2FzdEJyb3dzZXJUaGVtZSAqLyBcImJcIl0pKHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0JST1dTRVJfVEhFTUVfXykpICE9PSBudWxsICYmIF9jYXN0QnJvd3NlclRoZW1lICE9PSB2b2lkIDAgPyBfY2FzdEJyb3dzZXJUaGVtZSA6ICdkYXJrJztcbiAgcGF0Y2goe1xuICAgIGFwcGVuZENvbXBvbmVudFN0YWNrOiBhcHBlbmRDb21wb25lbnRTdGFjayxcbiAgICBicmVha09uQ29uc29sZUVycm9yczogYnJlYWtPbkNvbnNvbGVFcnJvcnMsXG4gICAgc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzOiBzaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnMsXG4gICAgaGlkZUNvbnNvbGVMb2dzSW5TdHJpY3RNb2RlOiBoaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGUsXG4gICAgYnJvd3NlclRoZW1lOiBicm93c2VyVGhlbWVcbiAgfSk7XG59IC8vIEFmdGVyIHJlY2VpdmluZyBjYWNoZWQgY29uc29sZSBwYXRjaCBzZXR0aW5ncyBmcm9tIFJlYWN0IE5hdGl2ZSwgd2Ugc2V0IHRoZW0gb24gd2luZG93LlxuLy8gV2hlbiB0aGUgY29uc29sZSBpcyBpbml0aWFsbHkgcGF0Y2hlZCAoaW4gcmVuZGVyZXIuanMgYW5kIGhvb2suanMpLCB0aGVzZSB2YWx1ZXMgYXJlIHJlYWQuXG4vLyBUaGUgYnJvd3NlciBleHRlbnNpb24gKGV0Yy4pIHNldHMgdGhlc2UgdmFsdWVzIG9uIHdpbmRvdywgYnV0IHRocm91Z2ggYW5vdGhlciBtZXRob2QuXG5cbmZ1bmN0aW9uIHdyaXRlQ29uc29sZVBhdGNoU2V0dGluZ3NUb1dpbmRvdyhzZXR0aW5ncykge1xuICB3aW5kb3cuX19SRUFDVF9ERVZUT09MU19BUFBFTkRfQ09NUE9ORU5UX1NUQUNLX18gPSBzZXR0aW5ncy5hcHBlbmRDb21wb25lbnRTdGFjaztcbiAgd2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfQlJFQUtfT05fQ09OU09MRV9FUlJPUlNfXyA9IHNldHRpbmdzLmJyZWFrT25Db25zb2xlRXJyb3JzO1xuICB3aW5kb3cuX19SRUFDVF9ERVZUT09MU19TSE9XX0lOTElORV9XQVJOSU5HU19BTkRfRVJST1JTX18gPSBzZXR0aW5ncy5zaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnM7XG4gIHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0hJREVfQ09OU09MRV9MT0dTX0lOX1NUUklDVF9NT0RFX18gPSBzZXR0aW5ncy5oaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGU7XG4gIHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0JST1dTRVJfVEhFTUVfXyA9IHNldHRpbmdzLmJyb3dzZXJUaGVtZTtcbn1cbmZ1bmN0aW9uIGluc3RhbGxDb25zb2xlRnVuY3Rpb25zVG9XaW5kb3coKSB7XG4gIHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0NPTlNPTEVfRlVOQ1RJT05TX18gPSB7XG4gICAgcGF0Y2hDb25zb2xlVXNpbmdXaW5kb3dWYWx1ZXM6IHBhdGNoQ29uc29sZVVzaW5nV2luZG93VmFsdWVzLFxuICAgIHJlZ2lzdGVyUmVuZGVyZXJXaXRoQ29uc29sZTogcmVnaXN0ZXJSZW5kZXJlclxuICB9O1xufVxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTYpKSlcblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoaXNBcnJheSk7XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG1ldGE7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkZWh5ZHJhdGU7IH0pO1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IGZpbGxJblBhdGggKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBoeWRyYXRlICovXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG52YXIgbWV0YSA9IHtcbiAgaW5zcGVjdGFibGU6IFN5bWJvbCgnaW5zcGVjdGFibGUnKSxcbiAgaW5zcGVjdGVkOiBTeW1ib2woJ2luc3BlY3RlZCcpLFxuICBuYW1lOiBTeW1ib2woJ25hbWUnKSxcbiAgcHJldmlld19sb25nOiBTeW1ib2woJ3ByZXZpZXdfbG9uZycpLFxuICBwcmV2aWV3X3Nob3J0OiBTeW1ib2woJ3ByZXZpZXdfc2hvcnQnKSxcbiAgcmVhZG9ubHk6IFN5bWJvbCgncmVhZG9ubHknKSxcbiAgc2l6ZTogU3ltYm9sKCdzaXplJyksXG4gIHR5cGU6IFN5bWJvbCgndHlwZScpLFxuICB1bnNlcmlhbGl6YWJsZTogU3ltYm9sKCd1bnNlcmlhbGl6YWJsZScpXG59O1xuLy8gVGhpcyB0aHJlc2hvbGQgZGV0ZXJtaW5lcyB0aGUgZGVwdGggYXQgd2hpY2ggdGhlIGJyaWRnZSBcImRlaHlkcmF0ZXNcIiBuZXN0ZWQgZGF0YS5cbi8vIERlaHlkcmF0aW9uIG1lYW5zIHRoYXQgd2UgZG9uJ3Qgc2VyaWFsaXplIHRoZSBkYXRhIGZvciBlLmcuIHBvc3RNZXNzYWdlIG9yIHN0cmluZ2lmeSxcbi8vIHVubGVzcyB0aGUgZnJvbnRlbmQgZXhwbGljaXRseSByZXF1ZXN0cyBpdCAoZS5nLiBhIHVzZXIgY2xpY2tzIHRvIGV4cGFuZCBhIHByb3BzIG9iamVjdCkuXG4vL1xuLy8gUmVkdWNpbmcgdGhpcyB0aHJlc2hvbGQgd2lsbCBpbXByb3ZlIHRoZSBzcGVlZCBvZiBpbml0aWFsIGNvbXBvbmVudCBpbnNwZWN0aW9uLFxuLy8gYnV0IG1heSBkZWNyZWFzZSB0aGUgcmVzcG9uc2l2ZW5lc3Mgb2YgZXhwYW5kaW5nIG9iamVjdHMvYXJyYXlzIHRvIGluc3BlY3QgZnVydGhlci5cbnZhciBMRVZFTF9USFJFU0hPTEQgPSAyO1xuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgZGVoeWRyYXRlZCBtZXRhZGF0YSBmb3IgY29tcGxleCBvYmplY3QgaW5zdGFuY2VzXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVoeWRyYXRlZCh0eXBlLCBpbnNwZWN0YWJsZSwgZGF0YSwgY2xlYW5lZCwgcGF0aCkge1xuICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gIHZhciBkZWh5ZHJhdGVkID0ge1xuICAgIGluc3BlY3RhYmxlOiBpbnNwZWN0YWJsZSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIHByZXZpZXdfbG9uZzogT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGZvcm1hdERhdGFGb3JQcmV2aWV3ICovIFwiZFwiXSkoZGF0YSwgdHJ1ZSksXG4gICAgcHJldmlld19zaG9ydDogT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGZvcm1hdERhdGFGb3JQcmV2aWV3ICovIFwiZFwiXSkoZGF0YSwgZmFsc2UpLFxuICAgIG5hbWU6ICFkYXRhLmNvbnN0cnVjdG9yIHx8IGRhdGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcgPyAnJyA6IGRhdGEuY29uc3RydWN0b3IubmFtZVxuICB9O1xuXG4gIGlmICh0eXBlID09PSAnYXJyYXknIHx8IHR5cGUgPT09ICd0eXBlZF9hcnJheScpIHtcbiAgICBkZWh5ZHJhdGVkLnNpemUgPSBkYXRhLmxlbmd0aDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIGRlaHlkcmF0ZWQuc2l6ZSA9IE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aDtcbiAgfVxuXG4gIGlmICh0eXBlID09PSAnaXRlcmF0b3InIHx8IHR5cGUgPT09ICd0eXBlZF9hcnJheScpIHtcbiAgICBkZWh5ZHJhdGVkLnJlYWRvbmx5ID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBkZWh5ZHJhdGVkO1xufVxuLyoqXG4gKiBTdHJpcCBvdXQgY29tcGxleCBkYXRhIChpbnN0YW5jZXMsIGZ1bmN0aW9ucywgYW5kIGRhdGEgbmVzdGVkID4gTEVWRUxfVEhSRVNIT0xEIGxldmVscyBkZWVwKS5cbiAqIFRoZSBwYXRocyBvZiB0aGUgc3RyaXBwZWQgb3V0IG9iamVjdHMgYXJlIGFwcGVuZGVkIHRvIHRoZSBgY2xlYW5lZGAgbGlzdC5cbiAqIE9uIHRoZSBvdGhlciBzaWRlIG9mIHRoZSBiYXJyaWVyLCB0aGUgY2xlYW5lZCBsaXN0IGlzIHVzZWQgdG8gXCJyZS1oeWRyYXRlXCIgdGhlIGNsZWFuZWQgcmVwcmVzZW50YXRpb24gaW50b1xuICogYW4gb2JqZWN0IHdpdGggc3ltYm9scyBhcyBhdHRyaWJ1dGVzLCBzbyB0aGF0IGEgc2FuaXRpemVkIG9iamVjdCBjYW4gYmUgZGlzdGluZ3Vpc2hlZCBmcm9tIGEgbm9ybWFsIG9iamVjdC5cbiAqXG4gKiBJbnB1dDoge1wic29tZVwiOiB7XCJhdHRyXCI6IGZuKCl9LCBcIm90aGVyXCI6IEFuSW5zdGFuY2V9XG4gKiBPdXRwdXQ6IHtcbiAqICAgXCJzb21lXCI6IHtcbiAqICAgICBcImF0dHJcIjoge1wibmFtZVwiOiB0aGUgZm4ubmFtZSwgdHlwZTogXCJmdW5jdGlvblwifVxuICogICB9LFxuICogICBcIm90aGVyXCI6IHtcbiAqICAgICBcIm5hbWVcIjogXCJBbkluc3RhbmNlXCIsXG4gKiAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gKiAgIH0sXG4gKiB9XG4gKiBhbmQgY2xlYW5lZCA9IFtbXCJzb21lXCIsIFwiYXR0clwiXSwgW1wib3RoZXJcIl1dXG4gKi9cblxuXG5mdW5jdGlvbiBkZWh5ZHJhdGUoZGF0YSwgY2xlYW5lZCwgdW5zZXJpYWxpemFibGUsIHBhdGgsIGlzUGF0aEFsbG93ZWQpIHtcbiAgdmFyIGxldmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiAwO1xuICB2YXIgdHlwZSA9IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBnZXREYXRhVHlwZSAqLyBcImZcIl0pKGRhdGEpO1xuICB2YXIgaXNQYXRoQWxsb3dlZENoZWNrO1xuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2h0bWxfZWxlbWVudCc6XG4gICAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnNwZWN0YWJsZTogZmFsc2UsXG4gICAgICAgIHByZXZpZXdfc2hvcnQ6IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBmb3JtYXREYXRhRm9yUHJldmlldyAqLyBcImRcIl0pKGRhdGEsIGZhbHNlKSxcbiAgICAgICAgcHJldmlld19sb25nOiBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZm9ybWF0RGF0YUZvclByZXZpZXcgKi8gXCJkXCJdKShkYXRhLCB0cnVlKSxcbiAgICAgICAgbmFtZTogZGF0YS50YWdOYW1lLFxuICAgICAgICB0eXBlOiB0eXBlXG4gICAgICB9O1xuXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5zcGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3X3Nob3J0OiBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZm9ybWF0RGF0YUZvclByZXZpZXcgKi8gXCJkXCJdKShkYXRhLCBmYWxzZSksXG4gICAgICAgIHByZXZpZXdfbG9uZzogT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGZvcm1hdERhdGFGb3JQcmV2aWV3ICovIFwiZFwiXSkoZGF0YSwgdHJ1ZSksXG4gICAgICAgIG5hbWU6IHR5cGVvZiBkYXRhLm5hbWUgPT09ICdmdW5jdGlvbicgfHwgIWRhdGEubmFtZSA/ICdmdW5jdGlvbicgOiBkYXRhLm5hbWUsXG4gICAgICAgIHR5cGU6IHR5cGVcbiAgICAgIH07XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgaXNQYXRoQWxsb3dlZENoZWNrID0gaXNQYXRoQWxsb3dlZChwYXRoKTtcblxuICAgICAgaWYgKGlzUGF0aEFsbG93ZWRDaGVjaykge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aCA8PSA1MDAgPyBkYXRhIDogZGF0YS5zbGljZSgwLCA1MDApICsgJy4uLic7XG4gICAgICB9XG5cbiAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5zcGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3X3Nob3J0OiBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZm9ybWF0RGF0YUZvclByZXZpZXcgKi8gXCJkXCJdKShkYXRhLCBmYWxzZSksXG4gICAgICAgIHByZXZpZXdfbG9uZzogT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGZvcm1hdERhdGFGb3JQcmV2aWV3ICovIFwiZFwiXSkoZGF0YSwgdHJ1ZSksXG4gICAgICAgIG5hbWU6IGRhdGEudG9TdHJpbmcoKSxcbiAgICAgICAgdHlwZTogdHlwZVxuICAgICAgfTtcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnNwZWN0YWJsZTogZmFsc2UsXG4gICAgICAgIHByZXZpZXdfc2hvcnQ6IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBmb3JtYXREYXRhRm9yUHJldmlldyAqLyBcImRcIl0pKGRhdGEsIGZhbHNlKSxcbiAgICAgICAgcHJldmlld19sb25nOiBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZm9ybWF0RGF0YUZvclByZXZpZXcgKi8gXCJkXCJdKShkYXRhLCB0cnVlKSxcbiAgICAgICAgbmFtZTogZGF0YS50b1N0cmluZygpLFxuICAgICAgICB0eXBlOiB0eXBlXG4gICAgICB9O1xuICAgIC8vIFJlYWN0IEVsZW1lbnRzIGFyZW4ndCB2ZXJ5IGluc3BlY3Rvci1mcmllbmRseSxcbiAgICAvLyBhbmQgb2Z0ZW4gY29udGFpbiBwcml2YXRlIGZpZWxkcyBvciBjaXJjdWxhciByZWZlcmVuY2VzLlxuXG4gICAgY2FzZSAncmVhY3RfZWxlbWVudCc6XG4gICAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnNwZWN0YWJsZTogZmFsc2UsXG4gICAgICAgIHByZXZpZXdfc2hvcnQ6IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBmb3JtYXREYXRhRm9yUHJldmlldyAqLyBcImRcIl0pKGRhdGEsIGZhbHNlKSxcbiAgICAgICAgcHJldmlld19sb25nOiBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZm9ybWF0RGF0YUZvclByZXZpZXcgKi8gXCJkXCJdKShkYXRhLCB0cnVlKSxcbiAgICAgICAgbmFtZTogT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGdldERpc3BsYXlOYW1lRm9yUmVhY3RFbGVtZW50ICovIFwiaVwiXSkoZGF0YSkgfHwgJ1Vua25vd24nLFxuICAgICAgICB0eXBlOiB0eXBlXG4gICAgICB9O1xuICAgIC8vIEFycmF5QnVmZmVycyBlcnJvciBpZiB5b3UgdHJ5IHRvIGluc3BlY3QgdGhlbS5cblxuICAgIGNhc2UgJ2FycmF5X2J1ZmZlcic6XG4gICAgY2FzZSAnZGF0YV92aWV3JzpcbiAgICAgIGNsZWFuZWQucHVzaChwYXRoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc3BlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld19zaG9ydDogT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGZvcm1hdERhdGFGb3JQcmV2aWV3ICovIFwiZFwiXSkoZGF0YSwgZmFsc2UpLFxuICAgICAgICBwcmV2aWV3X2xvbmc6IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBmb3JtYXREYXRhRm9yUHJldmlldyAqLyBcImRcIl0pKGRhdGEsIHRydWUpLFxuICAgICAgICBuYW1lOiB0eXBlID09PSAnZGF0YV92aWV3JyA/ICdEYXRhVmlldycgOiAnQXJyYXlCdWZmZXInLFxuICAgICAgICBzaXplOiBkYXRhLmJ5dGVMZW5ndGgsXG4gICAgICAgIHR5cGU6IHR5cGVcbiAgICAgIH07XG5cbiAgICBjYXNlICdhcnJheSc6XG4gICAgICBpc1BhdGhBbGxvd2VkQ2hlY2sgPSBpc1BhdGhBbGxvd2VkKHBhdGgpO1xuXG4gICAgICBpZiAobGV2ZWwgPj0gTEVWRUxfVEhSRVNIT0xEICYmICFpc1BhdGhBbGxvd2VkQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURlaHlkcmF0ZWQodHlwZSwgdHJ1ZSwgZGF0YSwgY2xlYW5lZCwgcGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICByZXR1cm4gZGVoeWRyYXRlKGl0ZW0sIGNsZWFuZWQsIHVuc2VyaWFsaXphYmxlLCBwYXRoLmNvbmNhdChbaV0pLCBpc1BhdGhBbGxvd2VkLCBpc1BhdGhBbGxvd2VkQ2hlY2sgPyAxIDogbGV2ZWwgKyAxKTtcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnaHRtbF9hbGxfY29sbGVjdGlvbic6XG4gICAgY2FzZSAndHlwZWRfYXJyYXknOlxuICAgIGNhc2UgJ2l0ZXJhdG9yJzpcbiAgICAgIGlzUGF0aEFsbG93ZWRDaGVjayA9IGlzUGF0aEFsbG93ZWQocGF0aCk7XG5cbiAgICAgIGlmIChsZXZlbCA+PSBMRVZFTF9USFJFU0hPTEQgJiYgIWlzUGF0aEFsbG93ZWRDaGVjaykge1xuICAgICAgICByZXR1cm4gY3JlYXRlRGVoeWRyYXRlZCh0eXBlLCB0cnVlLCBkYXRhLCBjbGVhbmVkLCBwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB1bnNlcmlhbGl6YWJsZVZhbHVlID0ge1xuICAgICAgICAgIHVuc2VyaWFsaXphYmxlOiB0cnVlLFxuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgc2l6ZTogdHlwZSA9PT0gJ3R5cGVkX2FycmF5JyA/IGRhdGEubGVuZ3RoIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHByZXZpZXdfc2hvcnQ6IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBmb3JtYXREYXRhRm9yUHJldmlldyAqLyBcImRcIl0pKGRhdGEsIGZhbHNlKSxcbiAgICAgICAgICBwcmV2aWV3X2xvbmc6IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBmb3JtYXREYXRhRm9yUHJldmlldyAqLyBcImRcIl0pKGRhdGEsIHRydWUpLFxuICAgICAgICAgIG5hbWU6ICFkYXRhLmNvbnN0cnVjdG9yIHx8IGRhdGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcgPyAnJyA6IGRhdGEuY29uc3RydWN0b3IubmFtZVxuICAgICAgICB9OyAvLyBUUklDS1lcbiAgICAgICAgLy8gRG9uJ3QgdXNlIFsuLi5zcHJlYWRdIHN5bnRheCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICAvLyBUaGlzIHByb2plY3QgdXNlcyBAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS1zcHJlYWQgaW4gXCJsb29zZVwiIG1vZGUgd2hpY2ggb25seSB3b3JrcyB3aXRoIEFycmF5IHZhbHVlcy5cbiAgICAgICAgLy8gT3RoZXIgdHlwZXMgKGUuZy4gdHlwZWQgYXJyYXlzLCBTZXRzKSB3aWxsIG5vdCBzcHJlYWQgY29ycmVjdGx5LlxuXG4gICAgICAgIEFycmF5LmZyb20oZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICAgIHJldHVybiB1bnNlcmlhbGl6YWJsZVZhbHVlW2ldID0gZGVoeWRyYXRlKGl0ZW0sIGNsZWFuZWQsIHVuc2VyaWFsaXphYmxlLCBwYXRoLmNvbmNhdChbaV0pLCBpc1BhdGhBbGxvd2VkLCBpc1BhdGhBbGxvd2VkQ2hlY2sgPyAxIDogbGV2ZWwgKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHVuc2VyaWFsaXphYmxlLnB1c2gocGF0aCk7XG4gICAgICAgIHJldHVybiB1bnNlcmlhbGl6YWJsZVZhbHVlO1xuICAgICAgfVxuXG4gICAgY2FzZSAnb3BhcXVlX2l0ZXJhdG9yJzpcbiAgICAgIGNsZWFuZWQucHVzaChwYXRoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc3BlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld19zaG9ydDogT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGZvcm1hdERhdGFGb3JQcmV2aWV3ICovIFwiZFwiXSkoZGF0YSwgZmFsc2UpLFxuICAgICAgICBwcmV2aWV3X2xvbmc6IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBmb3JtYXREYXRhRm9yUHJldmlldyAqLyBcImRcIl0pKGRhdGEsIHRydWUpLFxuICAgICAgICBuYW1lOiBkYXRhW1N5bWJvbC50b1N0cmluZ1RhZ10sXG4gICAgICAgIHR5cGU6IHR5cGVcbiAgICAgIH07XG5cbiAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNsZWFuZWQucHVzaChwYXRoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc3BlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld19zaG9ydDogT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGZvcm1hdERhdGFGb3JQcmV2aWV3ICovIFwiZFwiXSkoZGF0YSwgZmFsc2UpLFxuICAgICAgICBwcmV2aWV3X2xvbmc6IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBmb3JtYXREYXRhRm9yUHJldmlldyAqLyBcImRcIl0pKGRhdGEsIHRydWUpLFxuICAgICAgICBuYW1lOiBkYXRhLnRvU3RyaW5nKCksXG4gICAgICAgIHR5cGU6IHR5cGVcbiAgICAgIH07XG5cbiAgICBjYXNlICdyZWdleHAnOlxuICAgICAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5zcGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3X3Nob3J0OiBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZm9ybWF0RGF0YUZvclByZXZpZXcgKi8gXCJkXCJdKShkYXRhLCBmYWxzZSksXG4gICAgICAgIHByZXZpZXdfbG9uZzogT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGZvcm1hdERhdGFGb3JQcmV2aWV3ICovIFwiZFwiXSkoZGF0YSwgdHJ1ZSksXG4gICAgICAgIG5hbWU6IGRhdGEudG9TdHJpbmcoKSxcbiAgICAgICAgdHlwZTogdHlwZVxuICAgICAgfTtcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpc1BhdGhBbGxvd2VkQ2hlY2sgPSBpc1BhdGhBbGxvd2VkKHBhdGgpO1xuXG4gICAgICBpZiAobGV2ZWwgPj0gTEVWRUxfVEhSRVNIT0xEICYmICFpc1BhdGhBbGxvd2VkQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURlaHlkcmF0ZWQodHlwZSwgdHJ1ZSwgZGF0YSwgY2xlYW5lZCwgcGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgIE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBnZXRBbGxFbnVtZXJhYmxlS2V5cyAqLyBcImVcIl0pKGRhdGEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHZhciBuYW1lID0ga2V5LnRvU3RyaW5nKCk7XG4gICAgICAgICAgb2JqZWN0W25hbWVdID0gZGVoeWRyYXRlKGRhdGFba2V5XSwgY2xlYW5lZCwgdW5zZXJpYWxpemFibGUsIHBhdGguY29uY2F0KFtuYW1lXSksIGlzUGF0aEFsbG93ZWQsIGlzUGF0aEFsbG93ZWRDaGVjayA/IDEgOiBsZXZlbCArIDEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2NsYXNzX2luc3RhbmNlJzpcbiAgICAgIGlzUGF0aEFsbG93ZWRDaGVjayA9IGlzUGF0aEFsbG93ZWQocGF0aCk7XG5cbiAgICAgIGlmIChsZXZlbCA+PSBMRVZFTF9USFJFU0hPTEQgJiYgIWlzUGF0aEFsbG93ZWRDaGVjaykge1xuICAgICAgICByZXR1cm4gY3JlYXRlRGVoeWRyYXRlZCh0eXBlLCB0cnVlLCBkYXRhLCBjbGVhbmVkLCBwYXRoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0ge1xuICAgICAgICB1bnNlcmlhbGl6YWJsZTogdHJ1ZSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgIHByZXZpZXdfc2hvcnQ6IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBmb3JtYXREYXRhRm9yUHJldmlldyAqLyBcImRcIl0pKGRhdGEsIGZhbHNlKSxcbiAgICAgICAgcHJldmlld19sb25nOiBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZm9ybWF0RGF0YUZvclByZXZpZXcgKi8gXCJkXCJdKShkYXRhLCB0cnVlKSxcbiAgICAgICAgbmFtZTogZGF0YS5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICB9O1xuICAgICAgT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGdldEFsbEVudW1lcmFibGVLZXlzICovIFwiZVwiXSkoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBrZXlBc1N0cmluZyA9IGtleS50b1N0cmluZygpO1xuICAgICAgICB2YWx1ZVtrZXlBc1N0cmluZ10gPSBkZWh5ZHJhdGUoZGF0YVtrZXldLCBjbGVhbmVkLCB1bnNlcmlhbGl6YWJsZSwgcGF0aC5jb25jYXQoW2tleUFzU3RyaW5nXSksIGlzUGF0aEFsbG93ZWQsIGlzUGF0aEFsbG93ZWRDaGVjayA/IDEgOiBsZXZlbCArIDEpO1xuICAgICAgfSk7XG4gICAgICB1bnNlcmlhbGl6YWJsZS5wdXNoKHBhdGgpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuXG4gICAgY2FzZSAnaW5maW5pdHknOlxuICAgIGNhc2UgJ25hbic6XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIC8vIFNvbWUgdmFsdWVzIGFyZSBsb3NzeSB3aGVuIHNlbnQgdGhyb3VnaCBhIFdlYlNvY2tldC5cbiAgICAgIC8vIFdlIGRlaHlkcmF0ZStyZWh5ZHJhdGUgdGhlbSB0byBwcmVzZXJ2ZSB0aGVpciB0eXBlLlxuICAgICAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdHlwZVxuICAgICAgfTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZGF0YTtcbiAgfVxufVxuZnVuY3Rpb24gZmlsbEluUGF0aChvYmplY3QsIGRhdGEsIHBhdGgsIHZhbHVlKSB7XG4gIHZhciB0YXJnZXQgPSBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZ2V0SW5PYmplY3QgKi8gXCJqXCJdKShvYmplY3QsIHBhdGgpO1xuXG4gIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgIGlmICghdGFyZ2V0W21ldGEudW5zZXJpYWxpemFibGVdKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W21ldGEuaW5zcGVjdGFibGVdO1xuICAgICAgZGVsZXRlIHRhcmdldFttZXRhLmluc3BlY3RlZF07XG4gICAgICBkZWxldGUgdGFyZ2V0W21ldGEubmFtZV07XG4gICAgICBkZWxldGUgdGFyZ2V0W21ldGEucHJldmlld19sb25nXTtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbbWV0YS5wcmV2aWV3X3Nob3J0XTtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbbWV0YS5yZWFkb25seV07XG4gICAgICBkZWxldGUgdGFyZ2V0W21ldGEuc2l6ZV07XG4gICAgICBkZWxldGUgdGFyZ2V0W21ldGEudHlwZV07XG4gICAgfVxuICB9XG5cbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIGRhdGEudW5zZXJpYWxpemFibGUubGVuZ3RoID4gMCkge1xuICAgIHZhciB1bnNlcmlhbGl6YWJsZVBhdGggPSBkYXRhLnVuc2VyaWFsaXphYmxlWzBdO1xuICAgIHZhciBpc01hdGNoID0gdW5zZXJpYWxpemFibGVQYXRoLmxlbmd0aCA9PT0gcGF0aC5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwYXRoW2ldICE9PSB1bnNlcmlhbGl6YWJsZVBhdGhbaV0pIHtcbiAgICAgICAgaXNNYXRjaCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgdXBncmFkZVVuc2VyaWFsaXphYmxlKHZhbHVlLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIHNldEluT2JqZWN0ICovIFwib1wiXSkob2JqZWN0LCBwYXRoLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBoeWRyYXRlKG9iamVjdCwgY2xlYW5lZCwgdW5zZXJpYWxpemFibGUpIHtcbiAgY2xlYW5lZC5mb3JFYWNoKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgIHZhciBsYXN0ID0gcGF0aFtsZW5ndGggLSAxXTtcbiAgICB2YXIgcGFyZW50ID0gT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGdldEluT2JqZWN0ICovIFwialwiXSkob2JqZWN0LCBwYXRoLnNsaWNlKDAsIGxlbmd0aCAtIDEpKTtcblxuICAgIGlmICghcGFyZW50IHx8ICFwYXJlbnQuaGFzT3duUHJvcGVydHkobGFzdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBwYXJlbnRbbGFzdF07XG5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh2YWx1ZS50eXBlID09PSAnaW5maW5pdHknKSB7XG4gICAgICBwYXJlbnRbbGFzdF0gPSBJbmZpbml0eTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlLnR5cGUgPT09ICduYW4nKSB7XG4gICAgICBwYXJlbnRbbGFzdF0gPSBOYU47XG4gICAgfSBlbHNlIGlmICh2YWx1ZS50eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcGFyZW50W2xhc3RdID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXBsYWNlIHRoZSBzdHJpbmcga2V5cyB3aXRoIFN5bWJvbHMgc28gdGhleSdyZSBub24tZW51bWVyYWJsZS5cbiAgICAgIHZhciByZXBsYWNlZCA9IHt9O1xuICAgICAgcmVwbGFjZWRbbWV0YS5pbnNwZWN0YWJsZV0gPSAhIXZhbHVlLmluc3BlY3RhYmxlO1xuICAgICAgcmVwbGFjZWRbbWV0YS5pbnNwZWN0ZWRdID0gZmFsc2U7XG4gICAgICByZXBsYWNlZFttZXRhLm5hbWVdID0gdmFsdWUubmFtZTtcbiAgICAgIHJlcGxhY2VkW21ldGEucHJldmlld19sb25nXSA9IHZhbHVlLnByZXZpZXdfbG9uZztcbiAgICAgIHJlcGxhY2VkW21ldGEucHJldmlld19zaG9ydF0gPSB2YWx1ZS5wcmV2aWV3X3Nob3J0O1xuICAgICAgcmVwbGFjZWRbbWV0YS5zaXplXSA9IHZhbHVlLnNpemU7XG4gICAgICByZXBsYWNlZFttZXRhLnJlYWRvbmx5XSA9ICEhdmFsdWUucmVhZG9ubHk7XG4gICAgICByZXBsYWNlZFttZXRhLnR5cGVdID0gdmFsdWUudHlwZTtcbiAgICAgIHBhcmVudFtsYXN0XSA9IHJlcGxhY2VkO1xuICAgIH1cbiAgfSk7XG4gIHVuc2VyaWFsaXphYmxlLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB2YXIgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgdmFyIGxhc3QgPSBwYXRoW2xlbmd0aCAtIDFdO1xuICAgIHZhciBwYXJlbnQgPSBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZ2V0SW5PYmplY3QgKi8gXCJqXCJdKShvYmplY3QsIHBhdGguc2xpY2UoMCwgbGVuZ3RoIC0gMSkpO1xuXG4gICAgaWYgKCFwYXJlbnQgfHwgIXBhcmVudC5oYXNPd25Qcm9wZXJ0eShsYXN0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gcGFyZW50W2xhc3RdO1xuXG4gICAgdmFyIHJlcGxhY2VtZW50ID0gX29iamVjdFNwcmVhZCh7fSwgbm9kZSk7XG5cbiAgICB1cGdyYWRlVW5zZXJpYWxpemFibGUocmVwbGFjZW1lbnQsIG5vZGUpO1xuICAgIHBhcmVudFtsYXN0XSA9IHJlcGxhY2VtZW50O1xuICB9KTtcbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZnVuY3Rpb24gdXBncmFkZVVuc2VyaWFsaXphYmxlKGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgdmFyIF9PYmplY3QkZGVmaW5lUHJvcGVydDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhkZXN0aW5hdGlvbiwgKF9PYmplY3QkZGVmaW5lUHJvcGVydCA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRkZWZpbmVQcm9wZXJ0LCBtZXRhLmluc3BlY3RlZCwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogISFzb3VyY2UuaW5zcGVjdGVkXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRkZWZpbmVQcm9wZXJ0LCBtZXRhLm5hbWUsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IHNvdXJjZS5uYW1lXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRkZWZpbmVQcm9wZXJ0LCBtZXRhLnByZXZpZXdfbG9uZywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogc291cmNlLnByZXZpZXdfbG9uZ1xuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkZGVmaW5lUHJvcGVydCwgbWV0YS5wcmV2aWV3X3Nob3J0LCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBzb3VyY2UucHJldmlld19zaG9ydFxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkZGVmaW5lUHJvcGVydCwgbWV0YS5zaXplLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBzb3VyY2Uuc2l6ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkZGVmaW5lUHJvcGVydCwgbWV0YS5yZWFkb25seSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogISFzb3VyY2UucmVhZG9ubHlcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGRlZmluZVByb3BlcnQsIG1ldGEudHlwZSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogc291cmNlLnR5cGVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGRlZmluZVByb3BlcnQsIG1ldGEudW5zZXJpYWxpemFibGUsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6ICEhc291cmNlLnVuc2VyaWFsaXphYmxlXG4gIH0pLCBfT2JqZWN0JGRlZmluZVByb3BlcnQpKTtcbiAgZGVsZXRlIGRlc3RpbmF0aW9uLmluc3BlY3RlZDtcbiAgZGVsZXRlIGRlc3RpbmF0aW9uLm5hbWU7XG4gIGRlbGV0ZSBkZXN0aW5hdGlvbi5wcmV2aWV3X2xvbmc7XG4gIGRlbGV0ZSBkZXN0aW5hdGlvbi5wcmV2aWV3X3Nob3J0O1xuICBkZWxldGUgZGVzdGluYXRpb24uc2l6ZTtcbiAgZGVsZXRlIGRlc3RpbmF0aW9uLnJlYWRvbmx5O1xuICBkZWxldGUgZGVzdGluYXRpb24udHlwZTtcbiAgZGVsZXRlIGRlc3RpbmF0aW9uLnVuc2VyaWFsaXphYmxlO1xufVxuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb25zb2xlTWFuYWdlZEJ5RGV2VG9vbHNEdXJpbmdTdHJpY3RNb2RlOyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBlbmFibGVMb2dnZXIgKi9cbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJiXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZW5hYmxlU3R5bGVYRmVhdHVyZXM7IH0pO1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IGlzSW50ZXJuYWxGYWNlYm9va0J1aWxkICovXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogVGhpcyBmaWxlIGlzIGZvcmtlZCBiZXR3ZWVuIGRpZmZlcmVudCBEZXZUb29scyBpbXBsZW1lbnRhdGlvbnMuXG4gKiBJdCBzaG91bGQgbmV2ZXIgYmUgaW1wb3J0ZWQgZGlyZWN0bHkhXG4gKiBJdCBzaG91bGQgYWx3YXlzIGJlIGltcG9ydGVkIGZyb20gXCJyZWFjdC1kZXZ0b29scy1mZWF0dXJlLWZsYWdzXCIuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIGNvbnNvbGVNYW5hZ2VkQnlEZXZUb29sc0R1cmluZ1N0cmljdE1vZGUgPSBmYWxzZTtcbnZhciBlbmFibGVMb2dnZXIgPSBmYWxzZTtcbnZhciBlbmFibGVTdHlsZVhGZWF0dXJlcyA9IGZhbHNlO1xudmFyIGlzSW50ZXJuYWxGYWNlYm9va0J1aWxkID0gZmFsc2U7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBEbyBub3QgZWRpdCB0aGUgY29kZSBiZWxvdy5cbiAqIEl0IGVuc3VyZXMgdGhpcyBmb3JrIGV4cG9ydHMgdGhlIHNhbWUgdHlwZXMgYXMgdGhlIGRlZmF1bHQgZmxhZ3MgZmlsZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIEZsb3cgbWFnaWMgdG8gdmVyaWZ5IHRoZSBleHBvcnRzIG9mIHRoaXMgZmlsZSBtYXRjaCB0aGUgb3JpZ2luYWwgdmVyc2lvbi5cbm51bGw7XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge2Z1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG5cbnZhciBOQU4gPSAwIC8gMDtcbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cblxudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cblxudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cblxudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cblxudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cblxudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xuXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xuXG52YXIgZnJlZUdsb2JhbCA9ICh0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoZ2xvYmFsKSkgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xuXG52YXIgZnJlZVNlbGYgPSAodHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihzZWxmKSkgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cblxudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG5cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG5cbnZhciBub3cgPSBmdW5jdGlvbiBub3coKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cblxuXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuXG4gIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuXG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lOyAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTsgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG5cbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICByZXN1bHQgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTsgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cblxuICAgIHJldHVybiBsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCB0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0IHx8IHRpbWVTaW5jZUxhc3RDYWxsIDwgMCB8fCBtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0O1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG5cbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH0gLy8gUmVzdGFydCB0aGUgdGltZXIuXG5cblxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7IC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cblxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICB9XG5cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICpcbiAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICovXG5cblxuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cblxuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICB9KTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cblxuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IF90eXBlb2YodmFsdWUpO1xuXG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiBfdHlwZW9mKHZhbHVlKSA9PSAnb2JqZWN0Jztcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiBfdHlwZW9mKHZhbHVlKSA9PSAnc3ltYm9sJyB8fCBpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZztcbn1cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5cblxuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IG90aGVyICsgJycgOiBvdGhlcjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuXG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOCkgOiByZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRocm90dGxlO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTYpKSlcblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gZ2V0SW50ZXJuYWxSZWFjdENvbnN0YW50czsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBhdHRhY2g7IH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvdHlwZXMuanNcbnZhciB0eXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy91dGlscy5qc1xudmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL3N0b3JhZ2UuanNcbnZhciBzdG9yYWdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvdXRpbHMuanMgKyAxIG1vZHVsZXNcbnZhciBiYWNrZW5kX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2NvbnN0YW50cy5qc1xudmFyIGNvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogL1VzZXJzL2hveHkvcmVwb3MvcmVhY3QvYnVpbGQvb3NzLWV4cGVyaW1lbnRhbC9yZWFjdC1kZWJ1Zy10b29scy9pbmRleC5qc1xudmFyIHJlYWN0X2RlYnVnX3Rvb2xzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2NvbnNvbGUuanNcbnZhciBiYWNrZW5kX2NvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMuanNcbnZhciBSZWFjdFN5bWJvbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvY29uZmlnL0RldlRvb2xzRmVhdHVyZUZsYWdzLmNvcmUtb3NzLmpzXG52YXIgRGV2VG9vbHNGZWF0dXJlRmxhZ3NfY29yZV9vc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vc2hhcmVkL29iamVjdElzLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICByZXR1cm4geCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpIHx8IHggIT09IHggJiYgeSAhPT0geSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICA7XG59XG5cbnZhciBvYmplY3RJcyA9IC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpcztcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNoYXJlZF9vYmplY3RJcyA9IChvYmplY3RJcyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9zaGFyZWQvaGFzT3duUHJvcGVydHkuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxudmFyIGhhc093blByb3BlcnR5X2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNoYXJlZF9oYXNPd25Qcm9wZXJ0eSA9IChoYXNPd25Qcm9wZXJ0eV9oYXNPd25Qcm9wZXJ0eSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvaXNBcnJheS5qc1xudmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvU3R5bGVYL3V0aWxzLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxudmFyIGNhY2hlZFN0eWxlTmFtZVRvVmFsdWVNYXAgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRTdHlsZVhEYXRhKGRhdGEpIHtcbiAgdmFyIHNvdXJjZXMgPSBuZXcgU2V0KCk7XG4gIHZhciByZXNvbHZlZFN0eWxlcyA9IHt9O1xuICBjcmF3bERhdGEoZGF0YSwgc291cmNlcywgcmVzb2x2ZWRTdHlsZXMpO1xuICByZXR1cm4ge1xuICAgIHNvdXJjZXM6IEFycmF5LmZyb20oc291cmNlcykuc29ydCgpLFxuICAgIHJlc29sdmVkU3R5bGVzOiByZXNvbHZlZFN0eWxlc1xuICB9O1xufVxuZnVuY3Rpb24gY3Jhd2xEYXRhKGRhdGEsIHNvdXJjZXMsIHJlc29sdmVkU3R5bGVzKSB7XG4gIGlmIChkYXRhID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoT2JqZWN0KGlzQXJyYXlbXCJhXCIgLyogZGVmYXVsdCAqL10pKGRhdGEpKSB7XG4gICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgaWYgKGVudHJ5ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoT2JqZWN0KGlzQXJyYXlbXCJhXCIgLyogZGVmYXVsdCAqL10pKGVudHJ5KSkge1xuICAgICAgICBjcmF3bERhdGEoZW50cnksIHNvdXJjZXMsIHJlc29sdmVkU3R5bGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyYXdsT2JqZWN0UHJvcGVydGllcyhlbnRyeSwgc291cmNlcywgcmVzb2x2ZWRTdHlsZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNyYXdsT2JqZWN0UHJvcGVydGllcyhkYXRhLCBzb3VyY2VzLCByZXNvbHZlZFN0eWxlcyk7XG4gIH1cblxuICByZXNvbHZlZFN0eWxlcyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhyZXNvbHZlZFN0eWxlcykuc29ydCgpKTtcbn1cblxuZnVuY3Rpb24gY3Jhd2xPYmplY3RQcm9wZXJ0aWVzKGVudHJ5LCBzb3VyY2VzLCByZXNvbHZlZFN0eWxlcykge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGVudHJ5KTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSBlbnRyeVtrZXldO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChrZXkgPT09IHZhbHVlKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZTsgdGhpcyBrZXkgaXMgdGhlIG5hbWUgb2YgdGhlIHN0eWxlJ3Mgc291cmNlL2ZpbGUvbW9kdWxlLlxuICAgICAgICBzb3VyY2VzLmFkZChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByb3BlcnR5VmFsdWUgPSBnZXRQcm9wZXJ0eVZhbHVlRm9yU3R5bGVOYW1lKHZhbHVlKTtcblxuICAgICAgICBpZiAocHJvcGVydHlWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgcmVzb2x2ZWRTdHlsZXNba2V5XSA9IHByb3BlcnR5VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5lc3RlZFN0eWxlID0ge307XG4gICAgICByZXNvbHZlZFN0eWxlc1trZXldID0gbmVzdGVkU3R5bGU7XG4gICAgICBjcmF3bERhdGEoW3ZhbHVlXSwgc291cmNlcywgbmVzdGVkU3R5bGUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnR5VmFsdWVGb3JTdHlsZU5hbWUoc3R5bGVOYW1lKSB7XG4gIGlmIChjYWNoZWRTdHlsZU5hbWVUb1ZhbHVlTWFwLmhhcyhzdHlsZU5hbWUpKSB7XG4gICAgcmV0dXJuIGNhY2hlZFN0eWxlTmFtZVRvVmFsdWVNYXAuZ2V0KHN0eWxlTmFtZSk7XG4gIH1cblxuICBmb3IgKHZhciBzdHlsZVNoZWV0SW5kZXggPSAwOyBzdHlsZVNoZWV0SW5kZXggPCBkb2N1bWVudC5zdHlsZVNoZWV0cy5sZW5ndGg7IHN0eWxlU2hlZXRJbmRleCsrKSB7XG4gICAgdmFyIHN0eWxlU2hlZXQgPSBkb2N1bWVudC5zdHlsZVNoZWV0c1tzdHlsZVNoZWV0SW5kZXhdO1xuICAgIHZhciBydWxlcyA9IG51bGw7IC8vIHRoaXMgbWlnaHQgdGhyb3cgaWYgQ09SUyBydWxlcyBhcmUgZW5mb3JjZWQgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzc29tLTEvI3RoZS1jc3NzdHlsZXNoZWV0LWludGVyZmFjZVxuXG4gICAgdHJ5IHtcbiAgICAgIHJ1bGVzID0gc3R5bGVTaGVldC5jc3NSdWxlcztcbiAgICB9IGNhdGNoIChfZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcnVsZUluZGV4ID0gMDsgcnVsZUluZGV4IDwgcnVsZXMubGVuZ3RoOyBydWxlSW5kZXgrKykge1xuICAgICAgaWYgKCEocnVsZXNbcnVsZUluZGV4XSBpbnN0YW5jZW9mIENTU1N0eWxlUnVsZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBydWxlID0gcnVsZXNbcnVsZUluZGV4XTtcbiAgICAgIHZhciBjc3NUZXh0ID0gcnVsZS5jc3NUZXh0LFxuICAgICAgICAgIHNlbGVjdG9yVGV4dCA9IHJ1bGUuc2VsZWN0b3JUZXh0LFxuICAgICAgICAgIHN0eWxlID0gcnVsZS5zdHlsZTtcblxuICAgICAgaWYgKHNlbGVjdG9yVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChzZWxlY3RvclRleHQuc3RhcnRzV2l0aChcIi5cIi5jb25jYXQoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSBjc3NUZXh0Lm1hdGNoKC97ICooW2EtelxcLV0rKTovKTtcblxuICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbiAgICAgICAgICAgIGNhY2hlZFN0eWxlTmFtZVRvVmFsdWVNYXAuc2V0KHN0eWxlTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vc2hhcmVkL2lzQXJyYXkuanNcbnZhciBzaGFyZWRfaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvZGV2dG9vbHMvY29uc3RhbnRzLmpzXG52YXIgQ0hBTkdFX0xPR19VUkwgPSAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvbWFpbi9wYWNrYWdlcy9yZWFjdC1kZXZ0b29scy9DSEFOR0VMT0cubWQnO1xudmFyIFVOU1VQUE9SVEVEX1ZFUlNJT05fVVJMID0gJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvYmxvZy8yMDE5LzA4LzE1L25ldy1yZWFjdC1kZXZ0b29scy5odG1sI2hvdy1kby1pLWdldC10aGUtb2xkLXZlcnNpb24tYmFjayc7XG52YXIgUkVBQ1RfREVWVE9PTFNfV09SS1BMQUNFX1VSTCA9ICdodHRwczovL2ZidXJsLmNvbS9yZWFjdC1kZXZ0b29scy13b3JrcGxhY2UtZ3JvdXAnO1xudmFyIFRIRU1FX1NUWUxFUyA9IHtcbiAgbGlnaHQ6IHtcbiAgICAnLS1jb2xvci1hdHRyaWJ1dGUtbmFtZSc6ICcjZWY2NjMyJyxcbiAgICAnLS1jb2xvci1hdHRyaWJ1dGUtbmFtZS1ub3QtZWRpdGFibGUnOiAnIzIzMjcyZicsXG4gICAgJy0tY29sb3ItYXR0cmlidXRlLW5hbWUtaW52ZXJ0ZWQnOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpJyxcbiAgICAnLS1jb2xvci1hdHRyaWJ1dGUtdmFsdWUnOiAnIzFhMWFhNicsXG4gICAgJy0tY29sb3ItYXR0cmlidXRlLXZhbHVlLWludmVydGVkJzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLWF0dHJpYnV0ZS1lZGl0YWJsZS12YWx1ZSc6ICcjMWExYWE2JyxcbiAgICAnLS1jb2xvci1iYWNrZ3JvdW5kJzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLWJhY2tncm91bmQtaG92ZXInOiAncmdiYSgwLCAxMzYsIDI1MCwgMC4xKScsXG4gICAgJy0tY29sb3ItYmFja2dyb3VuZC1pbmFjdGl2ZSc6ICcjZTVlNWU1JyxcbiAgICAnLS1jb2xvci1iYWNrZ3JvdW5kLWludmFsaWQnOiAnI2ZmZjBmMCcsXG4gICAgJy0tY29sb3ItYmFja2dyb3VuZC1zZWxlY3RlZCc6ICcjMDA4OGZhJyxcbiAgICAnLS1jb2xvci1idXR0b24tYmFja2dyb3VuZCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci1idXR0b24tYmFja2dyb3VuZC1mb2N1cyc6ICcjZWRlZGVkJyxcbiAgICAnLS1jb2xvci1idXR0b24nOiAnIzVmNjY3MycsXG4gICAgJy0tY29sb3ItYnV0dG9uLWRpc2FibGVkJzogJyNjZmQxZDUnLFxuICAgICctLWNvbG9yLWJ1dHRvbi1hY3RpdmUnOiAnIzAwODhmYScsXG4gICAgJy0tY29sb3ItYnV0dG9uLWZvY3VzJzogJyMyMzI3MmYnLFxuICAgICctLWNvbG9yLWJ1dHRvbi1ob3Zlcic6ICcjMjMyNzJmJyxcbiAgICAnLS1jb2xvci1ib3JkZXInOiAnI2VlZWVlZScsXG4gICAgJy0tY29sb3ItY29tbWl0LWRpZC1ub3QtcmVuZGVyLWZpbGwnOiAnI2NmZDFkNScsXG4gICAgJy0tY29sb3ItY29tbWl0LWRpZC1ub3QtcmVuZGVyLWZpbGwtdGV4dCc6ICcjMDAwMDAwJyxcbiAgICAnLS1jb2xvci1jb21taXQtZGlkLW5vdC1yZW5kZXItcGF0dGVybic6ICcjY2ZkMWQ1JyxcbiAgICAnLS1jb2xvci1jb21taXQtZGlkLW5vdC1yZW5kZXItcGF0dGVybi10ZXh0JzogJyMzMzMzMzMnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC0wJzogJyMzN2FmYTknLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC0xJzogJyM2M2IxOWUnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC0yJzogJyM4MGIzOTMnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC0zJzogJyM5N2I0ODgnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC00JzogJyNhYmI2N2QnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC01JzogJyNiZWI3NzEnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC02JzogJyNjZmI5NjUnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC03JzogJyNkZmJhNTcnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC04JzogJyNlZmJiNDknLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC05JzogJyNmZWJjMzgnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC10ZXh0JzogJyMwMDAwMDAnLFxuICAgICctLWNvbG9yLWNvbXBvbmVudC1uYW1lJzogJyM2YTUxYjInLFxuICAgICctLWNvbG9yLWNvbXBvbmVudC1uYW1lLWludmVydGVkJzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLWNvbXBvbmVudC1iYWRnZS1iYWNrZ3JvdW5kJzogJ3JnYmEoMCwgMCwgMCwgMC4xKScsXG4gICAgJy0tY29sb3ItY29tcG9uZW50LWJhZGdlLWJhY2tncm91bmQtaW52ZXJ0ZWQnOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjI1KScsXG4gICAgJy0tY29sb3ItY29tcG9uZW50LWJhZGdlLWNvdW50JzogJyM3NzdkODgnLFxuICAgICctLWNvbG9yLWNvbXBvbmVudC1iYWRnZS1jb3VudC1pbnZlcnRlZCc6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyknLFxuICAgICctLWNvbG9yLWNvbnNvbGUtZXJyb3ItYmFkZ2UtdGV4dCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLWVycm9yLWJhY2tncm91bmQnOiAnI2ZmZjBmMCcsXG4gICAgJy0tY29sb3ItY29uc29sZS1lcnJvci1ib3JkZXInOiAnI2ZmZDZkNicsXG4gICAgJy0tY29sb3ItY29uc29sZS1lcnJvci1pY29uJzogJyNlYjM5NDEnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtZXJyb3ItdGV4dCc6ICcjZmUyZTMxJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLXdhcm5pbmctYmFkZ2UtdGV4dCc6ICcjMDAwMDAwJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLXdhcm5pbmctYmFja2dyb3VuZCc6ICcjZmZmYmU1JyxcbiAgICAnLS1jb2xvci1jb25zb2xlLXdhcm5pbmctYm9yZGVyJzogJyNmZmY1YzEnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtd2FybmluZy1pY29uJzogJyNmNGJkMDAnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtd2FybmluZy10ZXh0JzogJyM2NDQ2MGMnLFxuICAgICctLWNvbG9yLWNvbnRleHQtYmFja2dyb3VuZCc6ICdyZ2JhKDAsMCwwLC45KScsXG4gICAgJy0tY29sb3ItY29udGV4dC1iYWNrZ3JvdW5kLWhvdmVyJzogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4xKScsXG4gICAgJy0tY29sb3ItY29udGV4dC1iYWNrZ3JvdW5kLXNlbGVjdGVkJzogJyMxNzhmYjknLFxuICAgICctLWNvbG9yLWNvbnRleHQtYm9yZGVyJzogJyMzZDQyNGEnLFxuICAgICctLWNvbG9yLWNvbnRleHQtdGV4dCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci1jb250ZXh0LXRleHQtc2VsZWN0ZWQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3ItZGltJzogJyM3NzdkODgnLFxuICAgICctLWNvbG9yLWRpbW1lcic6ICcjY2ZkMWQ1JyxcbiAgICAnLS1jb2xvci1kaW1tZXN0JzogJyNlZmYwZjEnLFxuICAgICctLWNvbG9yLWVycm9yLWJhY2tncm91bmQnOiAnaHNsKDAsIDEwMCUsIDk3JSknLFxuICAgICctLWNvbG9yLWVycm9yLWJvcmRlcic6ICdoc2woMCwgMTAwJSwgOTIlKScsXG4gICAgJy0tY29sb3ItZXJyb3ItdGV4dCc6ICcjZmYwMDAwJyxcbiAgICAnLS1jb2xvci1leHBhbmQtY29sbGFwc2UtdG9nZ2xlJzogJyM3NzdkODgnLFxuICAgICctLWNvbG9yLWxpbmsnOiAnIzAwMDBmZicsXG4gICAgJy0tY29sb3ItbW9kYWwtYmFja2dyb3VuZCc6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpJyxcbiAgICAnLS1jb2xvci1icmlkZ2UtdmVyc2lvbi1ucG0tYmFja2dyb3VuZCc6ICcjZWZmMGYxJyxcbiAgICAnLS1jb2xvci1icmlkZ2UtdmVyc2lvbi1ucG0tdGV4dCc6ICcjMDAwMDAwJyxcbiAgICAnLS1jb2xvci1icmlkZ2UtdmVyc2lvbi1udW1iZXInOiAnIzAwODhmYScsXG4gICAgJy0tY29sb3ItcHJpbWl0aXZlLWhvb2stYmFkZ2UtYmFja2dyb3VuZCc6ICcjZTVlNWU1JyxcbiAgICAnLS1jb2xvci1wcmltaXRpdmUtaG9vay1iYWRnZS10ZXh0JzogJyM1ZjY2NzMnLFxuICAgICctLWNvbG9yLXJlY29yZC1hY3RpdmUnOiAnI2ZjM2E0YicsXG4gICAgJy0tY29sb3ItcmVjb3JkLWhvdmVyJzogJyMzNTc4ZTUnLFxuICAgICctLWNvbG9yLXJlY29yZC1pbmFjdGl2ZSc6ICcjMDA4OGZhJyxcbiAgICAnLS1jb2xvci1yZXNpemUtYmFyJzogJyNlZWVlZWUnLFxuICAgICctLWNvbG9yLXJlc2l6ZS1iYXItYWN0aXZlJzogJyNkY2RjZGMnLFxuICAgICctLWNvbG9yLXJlc2l6ZS1iYXItYm9yZGVyJzogJyNkMWQxZDEnLFxuICAgICctLWNvbG9yLXJlc2l6ZS1iYXItZG90JzogJyMzMzMzMzMnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLWludGVybmFsLW1vZHVsZSc6ICcjZDFkMWQxJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1pbnRlcm5hbC1tb2R1bGUtaG92ZXInOiAnI2M5YzljOScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtaW50ZXJuYWwtbW9kdWxlLXRleHQnOiAnIzQ0NCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtbmF0aXZlLWV2ZW50JzogJyNjY2MnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLW5hdGl2ZS1ldmVudC1ob3Zlcic6ICcjYWFhJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1uZXR3b3JrLXByaW1hcnknOiAnI2ZjZjNkYycsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtbmV0d29yay1wcmltYXJ5LWhvdmVyJzogJyNmMGU3ZDEnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLW5ldHdvcmstc2Vjb25kYXJ5JzogJyNlZmM0NTcnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLW5ldHdvcmstc2Vjb25kYXJ5LWhvdmVyJzogJyNlM2JhNTInLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXByaW9yaXR5LWJhY2tncm91bmQnOiAnI2Y2ZjZmNicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcHJpb3JpdHktYm9yZGVyJzogJyNlZWVlZWUnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXVzZXItdGltaW5nJzogJyNjOWNhY2QnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXVzZXItdGltaW5nLWhvdmVyJzogJyM5Mzk1OWEnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LWlkbGUnOiAnI2QzZTVmNicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtaWRsZS1ob3Zlcic6ICcjYzNkOWVmJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1yZW5kZXInOiAnIzlmYzNmMycsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtcmVuZGVyLWhvdmVyJzogJyM4M2FmZTknLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXJlbmRlci10ZXh0JzogJyMxMTM2NWUnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LWNvbW1pdCc6ICcjYzg4ZmYwJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1jb21taXQtaG92ZXInOiAnI2IyODFkNicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtY29tbWl0LXRleHQnOiAnIzNlMmM0YScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtbGF5b3V0LWVmZmVjdHMnOiAnI2IyODFkNicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtbGF5b3V0LWVmZmVjdHMtaG92ZXInOiAnIzlkNzFiZCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtbGF5b3V0LWVmZmVjdHMtdGV4dCc6ICcjM2UyYzRhJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1wYXNzaXZlLWVmZmVjdHMnOiAnI2IyODFkNicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtcGFzc2l2ZS1lZmZlY3RzLWhvdmVyJzogJyM5ZDcxYmQnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXBhc3NpdmUtZWZmZWN0cy10ZXh0JzogJyMzZTJjNGEnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXNjaGVkdWxlJzogJyM5ZmMzZjMnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXNjaGVkdWxlLWhvdmVyJzogJyMyNjgzRTInLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXN1c3BlbnNlLXJlamVjdGVkJzogJyNmMWNjMTQnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXN1c3BlbnNlLXJlamVjdGVkLWhvdmVyJzogJyNmZmRmMzcnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXN1c3BlbnNlLXJlc29sdmVkJzogJyNhNmU1OWYnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXN1c3BlbnNlLXJlc29sdmVkLWhvdmVyJzogJyM4OWQyODEnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXN1c3BlbnNlLXVucmVzb2x2ZWQnOiAnI2M5Y2FjZCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc3VzcGVuc2UtdW5yZXNvbHZlZC1ob3Zlcic6ICcjOTM5NTlhJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS10aHJvd24tZXJyb3InOiAnI2VlMTYzOCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtdGhyb3duLWVycm9yLWhvdmVyJzogJyNkYTEwMzAnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXRleHQtY29sb3InOiAnIzAwMDAwMCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtdGV4dC1kaW0tY29sb3InOiAnI2NjYycsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtd29yay1ib3JkZXInOiAnI2VlZWVlZScsXG4gICAgJy0tY29sb3Itc2VhcmNoLW1hdGNoJzogJ3llbGxvdycsXG4gICAgJy0tY29sb3Itc2VhcmNoLW1hdGNoLWN1cnJlbnQnOiAnI2Y3OTIzYicsXG4gICAgJy0tY29sb3Itc2VsZWN0ZWQtdHJlZS1oaWdobGlnaHQtYWN0aXZlJzogJ3JnYmEoMCwgMTM2LCAyNTAsIDAuMSknLFxuICAgICctLWNvbG9yLXNlbGVjdGVkLXRyZWUtaGlnaGxpZ2h0LWluYWN0aXZlJzogJ3JnYmEoMCwgMCwgMCwgMC4wNSknLFxuICAgICctLWNvbG9yLXNjcm9sbC1jYXJldCc6ICdyZ2JhKDE1MCwgMTUwLCAxNTAsIDAuNSknLFxuICAgICctLWNvbG9yLXRhYi1zZWxlY3RlZC1ib3JkZXInOiAnIzAwODhmYScsXG4gICAgJy0tY29sb3ItdGV4dCc6ICcjMDAwMDAwJyxcbiAgICAnLS1jb2xvci10ZXh0LWludmFsaWQnOiAnI2ZmMDAwMCcsXG4gICAgJy0tY29sb3ItdGV4dC1zZWxlY3RlZCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci10b2dnbGUtYmFja2dyb3VuZC1pbnZhbGlkJzogJyNmYzNhNGInLFxuICAgICctLWNvbG9yLXRvZ2dsZS1iYWNrZ3JvdW5kLW9uJzogJyMwMDg4ZmEnLFxuICAgICctLWNvbG9yLXRvZ2dsZS1iYWNrZ3JvdW5kLW9mZic6ICcjY2ZkMWQ1JyxcbiAgICAnLS1jb2xvci10b2dnbGUtdGV4dCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci13YXJuaW5nLWJhY2tncm91bmQnOiAnI2ZiMzY1NScsXG4gICAgJy0tY29sb3Itd2FybmluZy1iYWNrZ3JvdW5kLWhvdmVyJzogJyNmODIwNDInLFxuICAgICctLWNvbG9yLXdhcm5pbmctdGV4dC1jb2xvcic6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci13YXJuaW5nLXRleHQtY29sb3ItaW52ZXJ0ZWQnOiAnI2ZkNGQ2OScsXG4gICAgLy8gVGhlIHN0eWxlcyBiZWxvdyBzaG91bGQgYmUga2VwdCBpbiBzeW5jIHdpdGggJ3Jvb3QuY3NzJ1xuICAgIC8vIFRoZXkgYXJlIHJlcGVhdGVkIHRoZXJlIGJlY2F1c2UgdGhleSdyZSB1c2VkIGJ5IGUuZy4gdG9vbHRpcHMgb3IgY29udGV4dCBtZW51c1xuICAgIC8vIHdoaWNoIGdldCByZW5kZXJlZCBvdXRzaWRlIG9mIHRoZSBET00gc3VidHJlZSAod2hlcmUgbm9ybWFsIHRoZW1lL3N0eWxlcyBhcmUgd3JpdHRlbikuXG4gICAgJy0tY29sb3Itc2Nyb2xsLXRodW1iJzogJyNjMmMyYzInLFxuICAgICctLWNvbG9yLXNjcm9sbC10cmFjayc6ICcjZmFmYWZhJyxcbiAgICAnLS1jb2xvci10b29sdGlwLWJhY2tncm91bmQnOiAncmdiYSgwLCAwLCAwLCAwLjkpJyxcbiAgICAnLS1jb2xvci10b29sdGlwLXRleHQnOiAnI2ZmZmZmZidcbiAgfSxcbiAgZGFyazoge1xuICAgICctLWNvbG9yLWF0dHJpYnV0ZS1uYW1lJzogJyM5ZDg3ZDInLFxuICAgICctLWNvbG9yLWF0dHJpYnV0ZS1uYW1lLW5vdC1lZGl0YWJsZSc6ICcjZWRlZGVkJyxcbiAgICAnLS1jb2xvci1hdHRyaWJ1dGUtbmFtZS1pbnZlcnRlZCc6ICcjMjgyODI4JyxcbiAgICAnLS1jb2xvci1hdHRyaWJ1dGUtdmFsdWUnOiAnI2NlZGFlMCcsXG4gICAgJy0tY29sb3ItYXR0cmlidXRlLXZhbHVlLWludmVydGVkJzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLWF0dHJpYnV0ZS1lZGl0YWJsZS12YWx1ZSc6ICd5ZWxsb3cnLFxuICAgICctLWNvbG9yLWJhY2tncm91bmQnOiAnIzI4MmMzNCcsXG4gICAgJy0tY29sb3ItYmFja2dyb3VuZC1ob3Zlcic6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMSknLFxuICAgICctLWNvbG9yLWJhY2tncm91bmQtaW5hY3RpdmUnOiAnIzNkNDI0YScsXG4gICAgJy0tY29sb3ItYmFja2dyb3VuZC1pbnZhbGlkJzogJyM1YzAwMDAnLFxuICAgICctLWNvbG9yLWJhY2tncm91bmQtc2VsZWN0ZWQnOiAnIzE3OGZiOScsXG4gICAgJy0tY29sb3ItYnV0dG9uLWJhY2tncm91bmQnOiAnIzI4MmMzNCcsXG4gICAgJy0tY29sb3ItYnV0dG9uLWJhY2tncm91bmQtZm9jdXMnOiAnIzNkNDI0YScsXG4gICAgJy0tY29sb3ItYnV0dG9uJzogJyNhZmIzYjknLFxuICAgICctLWNvbG9yLWJ1dHRvbi1hY3RpdmUnOiAnIzYxZGFmYicsXG4gICAgJy0tY29sb3ItYnV0dG9uLWRpc2FibGVkJzogJyM0ZjU3NjYnLFxuICAgICctLWNvbG9yLWJ1dHRvbi1mb2N1cyc6ICcjYTJlOWZjJyxcbiAgICAnLS1jb2xvci1idXR0b24taG92ZXInOiAnI2VkZWRlZCcsXG4gICAgJy0tY29sb3ItYm9yZGVyJzogJyMzZDQyNGEnLFxuICAgICctLWNvbG9yLWNvbW1pdC1kaWQtbm90LXJlbmRlci1maWxsJzogJyM3NzdkODgnLFxuICAgICctLWNvbG9yLWNvbW1pdC1kaWQtbm90LXJlbmRlci1maWxsLXRleHQnOiAnIzAwMDAwMCcsXG4gICAgJy0tY29sb3ItY29tbWl0LWRpZC1ub3QtcmVuZGVyLXBhdHRlcm4nOiAnIzY2NmM3NycsXG4gICAgJy0tY29sb3ItY29tbWl0LWRpZC1ub3QtcmVuZGVyLXBhdHRlcm4tdGV4dCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtMCc6ICcjMzdhZmE5JyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtMSc6ICcjNjNiMTllJyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtMic6ICcjODBiMzkzJyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtMyc6ICcjOTdiNDg4JyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtNCc6ICcjYWJiNjdkJyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtNSc6ICcjYmViNzcxJyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtNic6ICcjY2ZiOTY1JyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtNyc6ICcjZGZiYTU3JyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtOCc6ICcjZWZiYjQ5JyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtOSc6ICcjZmViYzM4JyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtdGV4dCc6ICcjMDAwMDAwJyxcbiAgICAnLS1jb2xvci1jb21wb25lbnQtbmFtZSc6ICcjNjFkYWZiJyxcbiAgICAnLS1jb2xvci1jb21wb25lbnQtbmFtZS1pbnZlcnRlZCc6ICcjMjgyODI4JyxcbiAgICAnLS1jb2xvci1jb21wb25lbnQtYmFkZ2UtYmFja2dyb3VuZCc6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMjUpJyxcbiAgICAnLS1jb2xvci1jb21wb25lbnQtYmFkZ2UtYmFja2dyb3VuZC1pbnZlcnRlZCc6ICdyZ2JhKDAsIDAsIDAsIDAuMjUpJyxcbiAgICAnLS1jb2xvci1jb21wb25lbnQtYmFkZ2UtY291bnQnOiAnIzhmOTQ5ZCcsXG4gICAgJy0tY29sb3ItY29tcG9uZW50LWJhZGdlLWNvdW50LWludmVydGVkJzogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43KScsXG4gICAgJy0tY29sb3ItY29uc29sZS1lcnJvci1iYWRnZS10ZXh0JzogJyMwMDAwMDAnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtZXJyb3ItYmFja2dyb3VuZCc6ICcjMjkwMDAwJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLWVycm9yLWJvcmRlcic6ICcjNWMwMDAwJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLWVycm9yLWljb24nOiAnI2ViMzk0MScsXG4gICAgJy0tY29sb3ItY29uc29sZS1lcnJvci10ZXh0JzogJyNmYzdmN2YnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtd2FybmluZy1iYWRnZS10ZXh0JzogJyMwMDAwMDAnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtd2FybmluZy1iYWNrZ3JvdW5kJzogJyMzMzJiMDAnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtd2FybmluZy1ib3JkZXInOiAnIzY2NTUwMCcsXG4gICAgJy0tY29sb3ItY29uc29sZS13YXJuaW5nLWljb24nOiAnI2Y0YmQwMCcsXG4gICAgJy0tY29sb3ItY29uc29sZS13YXJuaW5nLXRleHQnOiAnI2Y1ZjJlZCcsXG4gICAgJy0tY29sb3ItY29udGV4dC1iYWNrZ3JvdW5kJzogJ3JnYmEoMjU1LDI1NSwyNTUsLjk1KScsXG4gICAgJy0tY29sb3ItY29udGV4dC1iYWNrZ3JvdW5kLWhvdmVyJzogJ3JnYmEoMCwgMTM2LCAyNTAsIDAuMSknLFxuICAgICctLWNvbG9yLWNvbnRleHQtYmFja2dyb3VuZC1zZWxlY3RlZCc6ICcjMDA4OGZhJyxcbiAgICAnLS1jb2xvci1jb250ZXh0LWJvcmRlcic6ICcjZWVlZWVlJyxcbiAgICAnLS1jb2xvci1jb250ZXh0LXRleHQnOiAnIzAwMDAwMCcsXG4gICAgJy0tY29sb3ItY29udGV4dC10ZXh0LXNlbGVjdGVkJzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLWRpbSc6ICcjOGY5NDlkJyxcbiAgICAnLS1jb2xvci1kaW1tZXInOiAnIzc3N2Q4OCcsXG4gICAgJy0tY29sb3ItZGltbWVzdCc6ICcjNGY1NzY2JyxcbiAgICAnLS1jb2xvci1lcnJvci1iYWNrZ3JvdW5kJzogJyMyMDAnLFxuICAgICctLWNvbG9yLWVycm9yLWJvcmRlcic6ICcjOTAwJyxcbiAgICAnLS1jb2xvci1lcnJvci10ZXh0JzogJyNmNTUnLFxuICAgICctLWNvbG9yLWV4cGFuZC1jb2xsYXBzZS10b2dnbGUnOiAnIzhmOTQ5ZCcsXG4gICAgJy0tY29sb3ItbGluayc6ICcjNjFkYWZiJyxcbiAgICAnLS1jb2xvci1tb2RhbC1iYWNrZ3JvdW5kJzogJ3JnYmEoMCwgMCwgMCwgMC43NSknLFxuICAgICctLWNvbG9yLWJyaWRnZS12ZXJzaW9uLW5wbS1iYWNrZ3JvdW5kJzogJ3JnYmEoMCwgMCwgMCwgMC4yNSknLFxuICAgICctLWNvbG9yLWJyaWRnZS12ZXJzaW9uLW5wbS10ZXh0JzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLWJyaWRnZS12ZXJzaW9uLW51bWJlcic6ICd5ZWxsb3cnLFxuICAgICctLWNvbG9yLXByaW1pdGl2ZS1ob29rLWJhZGdlLWJhY2tncm91bmQnOiAncmdiYSgwLCAwLCAwLCAwLjI1KScsXG4gICAgJy0tY29sb3ItcHJpbWl0aXZlLWhvb2stYmFkZ2UtdGV4dCc6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyknLFxuICAgICctLWNvbG9yLXJlY29yZC1hY3RpdmUnOiAnI2ZjM2E0YicsXG4gICAgJy0tY29sb3ItcmVjb3JkLWhvdmVyJzogJyNhMmU5ZmMnLFxuICAgICctLWNvbG9yLXJlY29yZC1pbmFjdGl2ZSc6ICcjNjFkYWZiJyxcbiAgICAnLS1jb2xvci1yZXNpemUtYmFyJzogJyMyODJjMzQnLFxuICAgICctLWNvbG9yLXJlc2l6ZS1iYXItYWN0aXZlJzogJyMzMTM2M2YnLFxuICAgICctLWNvbG9yLXJlc2l6ZS1iYXItYm9yZGVyJzogJyMzZDQyNGEnLFxuICAgICctLWNvbG9yLXJlc2l6ZS1iYXItZG90JzogJyNjZmQxZDUnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLWludGVybmFsLW1vZHVsZSc6ICcjMzAzNTQyJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1pbnRlcm5hbC1tb2R1bGUtaG92ZXInOiAnIzM2M2I0YScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtaW50ZXJuYWwtbW9kdWxlLXRleHQnOiAnIzdmODg5OScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtbmF0aXZlLWV2ZW50JzogJyNiMmIyYjInLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLW5hdGl2ZS1ldmVudC1ob3Zlcic6ICcjOTQ5NDk0JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1uZXR3b3JrLXByaW1hcnknOiAnI2ZjZjNkYycsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtbmV0d29yay1wcmltYXJ5LWhvdmVyJzogJyNlM2RiYzUnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLW5ldHdvcmstc2Vjb25kYXJ5JzogJyNlZmM0NTcnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLW5ldHdvcmstc2Vjb25kYXJ5LWhvdmVyJzogJyNkNmFmNGQnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXByaW9yaXR5LWJhY2tncm91bmQnOiAnIzFkMjEyOScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcHJpb3JpdHktYm9yZGVyJzogJyMyODJjMzQnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXVzZXItdGltaW5nJzogJyNjOWNhY2QnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXVzZXItdGltaW5nLWhvdmVyJzogJyM5Mzk1OWEnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LWlkbGUnOiAnIzNkNDg1YicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtaWRsZS1ob3Zlcic6ICcjNDY1MjY5JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1yZW5kZXInOiAnIzI2ODNFMicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtcmVuZGVyLWhvdmVyJzogJyMxYTc2ZDQnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXJlbmRlci10ZXh0JzogJyMxMTM2NWUnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LWNvbW1pdCc6ICcjNzMxZmFkJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1jb21taXQtaG92ZXInOiAnIzYxMWI5NCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtY29tbWl0LXRleHQnOiAnI2U1YzFmZicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtbGF5b3V0LWVmZmVjdHMnOiAnIzYxMWI5NCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtbGF5b3V0LWVmZmVjdHMtaG92ZXInOiAnIzUxMTY3YScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtbGF5b3V0LWVmZmVjdHMtdGV4dCc6ICcjZTVjMWZmJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1wYXNzaXZlLWVmZmVjdHMnOiAnIzYxMWI5NCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtcGFzc2l2ZS1lZmZlY3RzLWhvdmVyJzogJyM1MTE2N2EnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXBhc3NpdmUtZWZmZWN0cy10ZXh0JzogJyNlNWMxZmYnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXNjaGVkdWxlJzogJyMyNjgzRTInLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXNjaGVkdWxlLWhvdmVyJzogJyMxYTc2ZDQnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXN1c3BlbnNlLXJlamVjdGVkJzogJyNmMWNjMTQnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXN1c3BlbnNlLXJlamVjdGVkLWhvdmVyJzogJyNlNGMwMGYnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXN1c3BlbnNlLXJlc29sdmVkJzogJyNhNmU1OWYnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXN1c3BlbnNlLXJlc29sdmVkLWhvdmVyJzogJyM4OWQyODEnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXN1c3BlbnNlLXVucmVzb2x2ZWQnOiAnI2M5Y2FjZCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc3VzcGVuc2UtdW5yZXNvbHZlZC1ob3Zlcic6ICcjOTM5NTlhJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS10aHJvd24tZXJyb3InOiAnI2ZiMzY1NScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtdGhyb3duLWVycm9yLWhvdmVyJzogJyNmODIwNDInLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXRleHQtY29sb3InOiAnIzI4MmMzNCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtdGV4dC1kaW0tY29sb3InOiAnIzU1NWI2NicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtd29yay1ib3JkZXInOiAnIzNkNDI0YScsXG4gICAgJy0tY29sb3Itc2VhcmNoLW1hdGNoJzogJ3llbGxvdycsXG4gICAgJy0tY29sb3Itc2VhcmNoLW1hdGNoLWN1cnJlbnQnOiAnI2Y3OTIzYicsXG4gICAgJy0tY29sb3Itc2VsZWN0ZWQtdHJlZS1oaWdobGlnaHQtYWN0aXZlJzogJ3JnYmEoMjMsIDE0MywgMTg1LCAwLjE1KScsXG4gICAgJy0tY29sb3Itc2VsZWN0ZWQtdHJlZS1oaWdobGlnaHQtaW5hY3RpdmUnOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjA1KScsXG4gICAgJy0tY29sb3Itc2Nyb2xsLWNhcmV0JzogJyM0ZjU3NjYnLFxuICAgICctLWNvbG9yLXNoYWRvdyc6ICdyZ2JhKDAsIDAsIDAsIDAuNSknLFxuICAgICctLWNvbG9yLXRhYi1zZWxlY3RlZC1ib3JkZXInOiAnIzE3OGZiOScsXG4gICAgJy0tY29sb3ItdGV4dCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci10ZXh0LWludmFsaWQnOiAnI2ZmODA4MCcsXG4gICAgJy0tY29sb3ItdGV4dC1zZWxlY3RlZCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci10b2dnbGUtYmFja2dyb3VuZC1pbnZhbGlkJzogJyNmYzNhNGInLFxuICAgICctLWNvbG9yLXRvZ2dsZS1iYWNrZ3JvdW5kLW9uJzogJyMxNzhmYjknLFxuICAgICctLWNvbG9yLXRvZ2dsZS1iYWNrZ3JvdW5kLW9mZic6ICcjNzc3ZDg4JyxcbiAgICAnLS1jb2xvci10b2dnbGUtdGV4dCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci13YXJuaW5nLWJhY2tncm91bmQnOiAnI2VlMTYzOCcsXG4gICAgJy0tY29sb3Itd2FybmluZy1iYWNrZ3JvdW5kLWhvdmVyJzogJyNkYTEwMzAnLFxuICAgICctLWNvbG9yLXdhcm5pbmctdGV4dC1jb2xvcic6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci13YXJuaW5nLXRleHQtY29sb3ItaW52ZXJ0ZWQnOiAnI2VlMTYzOCcsXG4gICAgLy8gVGhlIHN0eWxlcyBiZWxvdyBzaG91bGQgYmUga2VwdCBpbiBzeW5jIHdpdGggJ3Jvb3QuY3NzJ1xuICAgIC8vIFRoZXkgYXJlIHJlcGVhdGVkIHRoZXJlIGJlY2F1c2UgdGhleSdyZSB1c2VkIGJ5IGUuZy4gdG9vbHRpcHMgb3IgY29udGV4dCBtZW51c1xuICAgIC8vIHdoaWNoIGdldCByZW5kZXJlZCBvdXRzaWRlIG9mIHRoZSBET00gc3VidHJlZSAod2hlcmUgbm9ybWFsIHRoZW1lL3N0eWxlcyBhcmUgd3JpdHRlbikuXG4gICAgJy0tY29sb3Itc2Nyb2xsLXRodW1iJzogJyNhZmIzYjknLFxuICAgICctLWNvbG9yLXNjcm9sbC10cmFjayc6ICcjMzEzNjQwJyxcbiAgICAnLS1jb2xvci10b29sdGlwLWJhY2tncm91bmQnOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjk1KScsXG4gICAgJy0tY29sb3ItdG9vbHRpcC10ZXh0JzogJyMwMDAwMDAnXG4gIH0sXG4gIGNvbXBhY3Q6IHtcbiAgICAnLS1mb250LXNpemUtbW9ub3NwYWNlLXNtYWxsJzogJzlweCcsXG4gICAgJy0tZm9udC1zaXplLW1vbm9zcGFjZS1ub3JtYWwnOiAnMTFweCcsXG4gICAgJy0tZm9udC1zaXplLW1vbm9zcGFjZS1sYXJnZSc6ICcxNXB4JyxcbiAgICAnLS1mb250LXNpemUtc2Fucy1zbWFsbCc6ICcxMHB4JyxcbiAgICAnLS1mb250LXNpemUtc2Fucy1ub3JtYWwnOiAnMTJweCcsXG4gICAgJy0tZm9udC1zaXplLXNhbnMtbGFyZ2UnOiAnMTRweCcsXG4gICAgJy0tbGluZS1oZWlnaHQtZGF0YSc6ICcxOHB4J1xuICB9LFxuICBjb21mb3J0YWJsZToge1xuICAgICctLWZvbnQtc2l6ZS1tb25vc3BhY2Utc21hbGwnOiAnMTBweCcsXG4gICAgJy0tZm9udC1zaXplLW1vbm9zcGFjZS1ub3JtYWwnOiAnMTNweCcsXG4gICAgJy0tZm9udC1zaXplLW1vbm9zcGFjZS1sYXJnZSc6ICcxN3B4JyxcbiAgICAnLS1mb250LXNpemUtc2Fucy1zbWFsbCc6ICcxMnB4JyxcbiAgICAnLS1mb250LXNpemUtc2Fucy1ub3JtYWwnOiAnMTRweCcsXG4gICAgJy0tZm9udC1zaXplLXNhbnMtbGFyZ2UnOiAnMTZweCcsXG4gICAgJy0tbGluZS1oZWlnaHQtZGF0YSc6ICcyMnB4J1xuICB9XG59OyAvLyBIQUNLXG4vL1xuLy8gU29tZXRpbWVzIHRoZSBpbmxpbmUgdGFyZ2V0IGlzIHJlbmRlcmVkIGJlZm9yZSByb290IHN0eWxlcyBhcmUgYXBwbGllZCxcbi8vIHdoaWNoIHdvdWxkIHJlc3VsdCBpbiBlLmcuIE5hTiBpdGVtU2l6ZSBiZWluZyBwYXNzZWQgdG8gcmVhY3Qtd2luZG93IGxpc3QuXG5cbnZhciBDT01GT1JUQUJMRV9MSU5FX0hFSUdIVCA9IHBhcnNlSW50KFRIRU1FX1NUWUxFUy5jb21mb3J0YWJsZVsnLS1saW5lLWhlaWdodC1kYXRhJ10sIDEwKTtcbnZhciBDT01QQUNUX0xJTkVfSEVJR0hUID0gcGFyc2VJbnQoVEhFTUVfU1RZTEVTLmNvbXBhY3RbJy0tbGluZS1oZWlnaHQtZGF0YSddLCAxMCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXRpbWVsaW5lL3NyYy9jb25zdGFudHMuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG52YXIgUkVBQ1RfVE9UQUxfTlVNX0xBTkVTID0gMzE7IC8vIEluY3JlbWVudCB0aGlzIG51bWJlciBhbnkgdGltZSBhIGJhY2t3YXJkcyBicmVha2luZyBjaGFuZ2UgaXMgbWFkZSB0byB0aGUgcHJvZmlsZXIgbWV0YWRhdGEuXG5cbnZhciBTQ0hFRFVMSU5HX1BST0ZJTEVSX1ZFUlNJT04gPSAxO1xudmFyIFNOQVBTSE9UX01BWF9IRUlHSFQgPSA2MDtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL0RldlRvb2xzRmliZXJDb21wb25lbnRTdGFjay5qcyArIDIgbW9kdWxlc1xudmFyIERldlRvb2xzRmliZXJDb21wb25lbnRTdGFjayA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvcHJvZmlsaW5nSG9va3MuanNcbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cblxuIC8vIEFkZCBwYWRkaW5nIHRvIHRoZSBzdGFydC9zdG9wIHRpbWUgb2YgdGhlIHByb2ZpbGUuXG4vLyBUaGlzIG1ha2VzIHRoZSBVSSBuaWNlciB0byB1c2UuXG5cbnZhciBUSU1FX09GRlNFVCA9IDEwO1xudmFyIHBlcmZvcm1hbmNlVGFyZ2V0ID0gbnVsbDsgLy8gSWYgcGVyZm9ybWFuY2UgZXhpc3RzIGFuZCBzdXBwb3J0cyB0aGUgc3Vic2V0IG9mIHRoZSBVc2VyIFRpbWluZyBBUEkgdGhhdCB3ZSByZXF1aXJlLlxuXG52YXIgc3VwcG9ydHNVc2VyVGltaW5nID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG50eXBlb2YgcGVyZm9ybWFuY2UubWFyayA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG50eXBlb2YgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyA9PT0gJ2Z1bmN0aW9uJztcbnZhciBzdXBwb3J0c1VzZXJUaW1pbmdWMyA9IGZhbHNlO1xuXG5pZiAoc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gIHZhciBDSEVDS19WM19NQVJLID0gJ19fdjMnO1xuICB2YXIgbWFya09wdGlvbnMgPSB7fTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1hcmtPcHRpb25zLCAnc3RhcnRUaW1lJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgc3VwcG9ydHNVc2VyVGltaW5nVjMgPSB0cnVlO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCgpIHt9XG4gIH0pO1xuXG4gIHRyeSB7XG4gICAgLy8gJEZsb3dGaXhNZVtleHRyYS1hcmddOiBGbG93IGV4cGVjdHMgdGhlIFVzZXIgVGltaW5nIGxldmVsIDIgQVBJLlxuICAgIHBlcmZvcm1hbmNlLm1hcmsoQ0hFQ0tfVjNfTUFSSywgbWFya09wdGlvbnMpO1xuICB9IGNhdGNoIChlcnJvcikgey8vIElnbm9yZVxuICB9IGZpbmFsbHkge1xuICAgIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MoQ0hFQ0tfVjNfTUFSSyk7XG4gIH1cbn1cblxuaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gIHBlcmZvcm1hbmNlVGFyZ2V0ID0gcGVyZm9ybWFuY2U7XG59IC8vIFNvbWUgZW52aXJvbm1lbnRzIChlLmcuIFJlYWN0IE5hdGl2ZSAvIEhlcm1lcykgZG9uJ3Qgc3VwcG9ydCB0aGUgcGVyZm9ybWFuY2UgQVBJIHlldC5cblxuXG52YXIgZ2V0Q3VycmVudFRpbWUgPSAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4odHlwZW9mIHBlcmZvcm1hbmNlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YocGVyZm9ybWFuY2UpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xufSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIERhdGUubm93KCk7XG59OyAvLyBNb2NraW5nIHRoZSBQZXJmb3JtYW5jZSBPYmplY3QgKGFuZCBVc2VyIFRpbWluZyBBUElzKSBmb3IgdGVzdGluZyBpcyBmcmFnaWxlLlxuLy8gVGhpcyBBUEkgYWxsb3dzIHRlc3RzIHRvIGRpcmVjdGx5IG92ZXJyaWRlIHRoZSBVc2VyIFRpbWluZyBBUElzLlxuXG5mdW5jdGlvbiBzZXRQZXJmb3JtYW5jZU1vY2tfT05MWV9GT1JfVEVTVElORyhwZXJmb3JtYW5jZU1vY2spIHtcbiAgcGVyZm9ybWFuY2VUYXJnZXQgPSBwZXJmb3JtYW5jZU1vY2s7XG4gIHN1cHBvcnRzVXNlclRpbWluZyA9IHBlcmZvcm1hbmNlTW9jayAhPT0gbnVsbDtcbiAgc3VwcG9ydHNVc2VyVGltaW5nVjMgPSBwZXJmb3JtYW5jZU1vY2sgIT09IG51bGw7XG59XG5mdW5jdGlvbiBjcmVhdGVQcm9maWxpbmdIb29rcyhfcmVmKSB7XG4gIHZhciBnZXREaXNwbGF5TmFtZUZvckZpYmVyID0gX3JlZi5nZXREaXNwbGF5TmFtZUZvckZpYmVyLFxuICAgICAgZ2V0SXNQcm9maWxpbmcgPSBfcmVmLmdldElzUHJvZmlsaW5nLFxuICAgICAgZ2V0TGFuZUxhYmVsTWFwID0gX3JlZi5nZXRMYW5lTGFiZWxNYXAsXG4gICAgICB3b3JrVGFnTWFwID0gX3JlZi53b3JrVGFnTWFwLFxuICAgICAgY3VycmVudERpc3BhdGNoZXJSZWYgPSBfcmVmLmN1cnJlbnREaXNwYXRjaGVyUmVmLFxuICAgICAgcmVhY3RWZXJzaW9uID0gX3JlZi5yZWFjdFZlcnNpb247XG4gIHZhciBjdXJyZW50QmF0Y2hVSUQgPSAwO1xuICB2YXIgY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSA9IG51bGw7XG4gIHZhciBjdXJyZW50UmVhY3RNZWFzdXJlc1N0YWNrID0gW107XG4gIHZhciBjdXJyZW50VGltZWxpbmVEYXRhID0gbnVsbDtcbiAgdmFyIGN1cnJlbnRGaWJlclN0YWNrcyA9IG5ldyBNYXAoKTtcbiAgdmFyIGlzUHJvZmlsaW5nID0gZmFsc2U7XG4gIHZhciBuZXh0UmVuZGVyU2hvdWxkU3RhcnROZXdCYXRjaCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGdldFJlbGF0aXZlVGltZSgpIHtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBnZXRDdXJyZW50VGltZSgpO1xuXG4gICAgaWYgKGN1cnJlbnRUaW1lbGluZURhdGEpIHtcbiAgICAgIGlmIChjdXJyZW50VGltZWxpbmVEYXRhLnN0YXJ0VGltZSA9PT0gMCkge1xuICAgICAgICBjdXJyZW50VGltZWxpbmVEYXRhLnN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lIC0gVElNRV9PRkZTRVQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJyZW50VGltZSAtIGN1cnJlbnRUaW1lbGluZURhdGEuc3RhcnRUaW1lO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SW50ZXJuYWxNb2R1bGVSYW5nZXMoKSB7XG4gICAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICAgIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmdldEludGVybmFsTW9kdWxlUmFuZ2VzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBc2sgdGhlIERldlRvb2xzIGhvb2sgZm9yIG1vZHVsZSByYW5nZXMgdGhhdCBtYXkgaGF2ZSBiZWVuIHJlcG9ydGVkIGJ5IHRoZSBjdXJyZW50IHJlbmRlcmVyKHMpLlxuICAgICAgLy8gRG9uJ3QgZG8gdGhpcyBlYWdlcmx5IGxpa2UgdGhlIGxhbmVUb0xhYmVsTWFwLFxuICAgICAgLy8gYmVjYXVzZSBzb21lIG1vZHVsZXMgbWlnaHQgbm90IHlldCBoYXZlIHJlZ2lzdGVyZWQgdGhlaXIgYm91bmRhcmllcyB3aGVuIHRoZSByZW5kZXJlciBpcyBpbmplY3RlZC5cbiAgICAgIHZhciByYW5nZXMgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uZ2V0SW50ZXJuYWxNb2R1bGVSYW5nZXMoKTsgLy8gVGhpcyBjaGVjayB3b3VsZCBub3QgYmUgcmVxdWlyZWQsXG4gICAgICAvLyBleGNlcHQgdGhhdCBpdCdzIHBvc3NpYmxlIGZvciB0aGluZ3MgdG8gb3ZlcnJpZGUgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLlxuXG5cbiAgICAgIGlmIChPYmplY3Qoc2hhcmVkX2lzQXJyYXlbXCJhXCIgLyogZGVmYXVsdCAqL10pKHJhbmdlcykpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRpbWVsaW5lRGF0YSgpIHtcbiAgICByZXR1cm4gY3VycmVudFRpbWVsaW5lRGF0YTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxhbmVUb0xhbmVzQXJyYXkobGFuZXMpIHtcbiAgICB2YXIgbGFuZXNBcnJheSA9IFtdO1xuICAgIHZhciBsYW5lID0gMTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBSRUFDVF9UT1RBTF9OVU1fTEFORVM7IGluZGV4KyspIHtcbiAgICAgIGlmIChsYW5lICYgbGFuZXMpIHtcbiAgICAgICAgbGFuZXNBcnJheS5wdXNoKGxhbmUpO1xuICAgICAgfVxuXG4gICAgICBsYW5lICo9IDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhbmVzQXJyYXk7XG4gIH1cblxuICB2YXIgbGFuZVRvTGFiZWxNYXAgPSB0eXBlb2YgZ2V0TGFuZUxhYmVsTWFwID09PSAnZnVuY3Rpb24nID8gZ2V0TGFuZUxhYmVsTWFwKCkgOiBudWxsO1xuXG4gIGZ1bmN0aW9uIG1hcmtNZXRhZGF0YSgpIHtcbiAgICBtYXJrQW5kQ2xlYXIoXCItLXJlYWN0LXZlcnNpb24tXCIuY29uY2F0KHJlYWN0VmVyc2lvbikpO1xuICAgIG1hcmtBbmRDbGVhcihcIi0tcHJvZmlsZXItdmVyc2lvbi1cIi5jb25jYXQoU0NIRURVTElOR19QUk9GSUxFUl9WRVJTSU9OKSk7XG4gICAgdmFyIHJhbmdlcyA9IGdldEludGVybmFsTW9kdWxlUmFuZ2VzKCk7XG5cbiAgICBpZiAocmFuZ2VzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG5cbiAgICAgICAgaWYgKE9iamVjdChzaGFyZWRfaXNBcnJheVtcImFcIiAvKiBkZWZhdWx0ICovXSkocmFuZ2UpICYmIHJhbmdlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHZhciBfcmFuZ2VzJGkgPSBfc2xpY2VkVG9BcnJheShyYW5nZXNbaV0sIDIpLFxuICAgICAgICAgICAgICBzdGFydFN0YWNrRnJhbWUgPSBfcmFuZ2VzJGlbMF0sXG4gICAgICAgICAgICAgIHN0b3BTdGFja0ZyYW1lID0gX3JhbmdlcyRpWzFdO1xuXG4gICAgICAgICAgbWFya0FuZENsZWFyKFwiLS1yZWFjdC1pbnRlcm5hbC1tb2R1bGUtc3RhcnQtXCIuY29uY2F0KHN0YXJ0U3RhY2tGcmFtZSkpO1xuICAgICAgICAgIG1hcmtBbmRDbGVhcihcIi0tcmVhY3QtaW50ZXJuYWwtbW9kdWxlLXN0b3AtXCIuY29uY2F0KHN0b3BTdGFja0ZyYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGFuZVRvTGFiZWxNYXAgIT0gbnVsbCkge1xuICAgICAgdmFyIGxhYmVscyA9IEFycmF5LmZyb20obGFuZVRvTGFiZWxNYXAudmFsdWVzKCkpLmpvaW4oJywnKTtcbiAgICAgIG1hcmtBbmRDbGVhcihcIi0tcmVhY3QtbGFuZS1sYWJlbHMtXCIuY29uY2F0KGxhYmVscykpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtBbmRDbGVhcihtYXJrTmFtZSkge1xuICAgIC8vIFRoaXMgbWV0aG9kIHdvbid0IGJlIGNhbGxlZCB1bmxlc3MgdGhlc2UgZnVuY3Rpb25zIGFyZSBkZWZpbmVkLCBzbyB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgdHlwZW9mIGNoZWNrLlxuICAgIHBlcmZvcm1hbmNlVGFyZ2V0Lm1hcmsobWFya05hbWUpO1xuICAgIHBlcmZvcm1hbmNlVGFyZ2V0LmNsZWFyTWFya3MobWFya05hbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkUmVhY3RNZWFzdXJlU3RhcnRlZCh0eXBlLCBsYW5lcykge1xuICAgIC8vIERlY2lkZSB3aGF0IGRlcHRoIHRoaSB3b3JrIHNob3VsZCBiZSByZW5kZXJlZCBhdCwgYmFzZWQgb24gd2hhdCdzIG9uIHRoZSB0b3Agb2YgdGhlIHN0YWNrLlxuICAgIC8vIEl0J3Mgb2theSB0byByZW5kZXIgb3ZlciB0b3Agb2YgXCJpZGxlXCIgd29yayBidXQgZXZlcnl0aGluZyBlbHNlIHNob3VsZCBiZSBvbiBpdHMgb3duIHJvdy5cbiAgICB2YXIgZGVwdGggPSAwO1xuXG4gICAgaWYgKGN1cnJlbnRSZWFjdE1lYXN1cmVzU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHRvcCA9IGN1cnJlbnRSZWFjdE1lYXN1cmVzU3RhY2tbY3VycmVudFJlYWN0TWVhc3VyZXNTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGRlcHRoID0gdG9wLnR5cGUgPT09ICdyZW5kZXItaWRsZScgPyB0b3AuZGVwdGggOiB0b3AuZGVwdGggKyAxO1xuICAgIH1cblxuICAgIHZhciBsYW5lc0FycmF5ID0gbGFuZVRvTGFuZXNBcnJheShsYW5lcyk7XG4gICAgdmFyIHJlYWN0TWVhc3VyZSA9IHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBiYXRjaFVJRDogY3VycmVudEJhdGNoVUlELFxuICAgICAgZGVwdGg6IGRlcHRoLFxuICAgICAgbGFuZXM6IGxhbmVzQXJyYXksXG4gICAgICB0aW1lc3RhbXA6IGdldFJlbGF0aXZlVGltZSgpLFxuICAgICAgZHVyYXRpb246IDBcbiAgICB9O1xuICAgIGN1cnJlbnRSZWFjdE1lYXN1cmVzU3RhY2sucHVzaChyZWFjdE1lYXN1cmUpO1xuXG4gICAgaWYgKGN1cnJlbnRUaW1lbGluZURhdGEpIHtcbiAgICAgIHZhciBfY3VycmVudFRpbWVsaW5lRGF0YSA9IGN1cnJlbnRUaW1lbGluZURhdGEsXG4gICAgICAgICAgYmF0Y2hVSURUb01lYXN1cmVzTWFwID0gX2N1cnJlbnRUaW1lbGluZURhdGEuYmF0Y2hVSURUb01lYXN1cmVzTWFwLFxuICAgICAgICAgIGxhbmVUb1JlYWN0TWVhc3VyZU1hcCA9IF9jdXJyZW50VGltZWxpbmVEYXRhLmxhbmVUb1JlYWN0TWVhc3VyZU1hcDtcbiAgICAgIHZhciByZWFjdE1lYXN1cmVzID0gYmF0Y2hVSURUb01lYXN1cmVzTWFwLmdldChjdXJyZW50QmF0Y2hVSUQpO1xuXG4gICAgICBpZiAocmVhY3RNZWFzdXJlcyAhPSBudWxsKSB7XG4gICAgICAgIHJlYWN0TWVhc3VyZXMucHVzaChyZWFjdE1lYXN1cmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmF0Y2hVSURUb01lYXN1cmVzTWFwLnNldChjdXJyZW50QmF0Y2hVSUQsIFtyZWFjdE1lYXN1cmVdKTtcbiAgICAgIH1cblxuICAgICAgbGFuZXNBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChsYW5lKSB7XG4gICAgICAgIHJlYWN0TWVhc3VyZXMgPSBsYW5lVG9SZWFjdE1lYXN1cmVNYXAuZ2V0KGxhbmUpO1xuXG4gICAgICAgIGlmIChyZWFjdE1lYXN1cmVzKSB7XG4gICAgICAgICAgcmVhY3RNZWFzdXJlcy5wdXNoKHJlYWN0TWVhc3VyZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZFJlYWN0TWVhc3VyZUNvbXBsZXRlZCh0eXBlKSB7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gZ2V0UmVsYXRpdmVUaW1lKCk7XG5cbiAgICBpZiAoY3VycmVudFJlYWN0TWVhc3VyZXNTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgdHlwZSBcIiVzXCIgY29tcGxldGVkIGF0ICVzbXMgd2hpbGUgY3VycmVudFJlYWN0TWVhc3VyZXNTdGFjayBpcyBlbXB0eS4nLCB0eXBlLCBjdXJyZW50VGltZSk7IC8vIElnbm9yZSB3b3JrIFwiY29tcGxldGlvblwiIHVzZXIgdGltaW5nIG1hcmsgdGhhdCBkb2Vzbid0IGNvbXBsZXRlIGFueXRoaW5nXG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdG9wID0gY3VycmVudFJlYWN0TWVhc3VyZXNTdGFjay5wb3AoKTtcblxuICAgIGlmICh0b3AudHlwZSAhPT0gdHlwZSkge1xuICAgICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCB0eXBlIFwiJXNcIiBjb21wbGV0ZWQgYXQgJXNtcyBiZWZvcmUgXCIlc1wiIGNvbXBsZXRlZC4nLCB0eXBlLCBjdXJyZW50VGltZSwgdG9wLnR5cGUpO1xuICAgIH0gLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIFRoaXMgcHJvcGVydHkgc2hvdWxkIG5vdCBiZSB3cml0YWJsZSBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24uXG5cblxuICAgIHRvcC5kdXJhdGlvbiA9IGN1cnJlbnRUaW1lIC0gdG9wLnRpbWVzdGFtcDtcblxuICAgIGlmIChjdXJyZW50VGltZWxpbmVEYXRhKSB7XG4gICAgICBjdXJyZW50VGltZWxpbmVEYXRhLmR1cmF0aW9uID0gZ2V0UmVsYXRpdmVUaW1lKCkgKyBUSU1FX09GRlNFVDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrQ29tbWl0U3RhcnRlZChsYW5lcykge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgcmVjb3JkUmVhY3RNZWFzdXJlU3RhcnRlZCgnY29tbWl0JywgbGFuZXMpOyAvLyBUT0RPICh0aW1lbGluZSkgUmUtdGhpbmsgdGhpcyBhcHByb2FjaCB0byBcImJhdGNoaW5nXCI7IEkgZG9uJ3QgdGhpbmsgaXQgd29ya3MgZm9yIFN1c3BlbnNlIG9yIHByZS1yZW5kZXJpbmcuXG4gICAgICAvLyBUaGlzIGlzc3VlIGFwcGxpZXMgdG8gdGhlIFVzZXIgVGltaW5nIGRhdGEgYWxzby5cblxuICAgICAgbmV4dFJlbmRlclNob3VsZFN0YXJ0TmV3QmF0Y2ggPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgbWFya0FuZENsZWFyKFwiLS1jb21taXQtc3RhcnQtXCIuY29uY2F0KGxhbmVzKSk7IC8vIFNvbWUgbWV0YWRhdGEgb25seSBuZWVkcyB0byBiZSBsb2dnZWQgb25jZSBwZXIgc2Vzc2lvbixcbiAgICAgIC8vIGJ1dCBpZiBwcm9maWxpbmcgaW5mb3JtYXRpb24gaXMgYmVpbmcgcmVjb3JkZWQgdmlhIHRoZSBQZXJmb3JtYW5jZSB0YWIsXG4gICAgICAvLyBEZXZUb29scyBoYXMgbm8gd2F5IG9mIGtub3dpbmcgd2hlbiB0aGUgcmVjb3JkaW5nIHN0YXJ0cy5cbiAgICAgIC8vIEJlY2F1c2Ugb2YgdGhhdCwgd2UgbG9nIHRoaWUgdHlwZSBvZiBkYXRhIHBlcmlvZGljYWxseSAob25jZSBwZXIgY29tbWl0KS5cblxuICAgICAgbWFya01ldGFkYXRhKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya0NvbW1pdFN0b3BwZWQoKSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICByZWNvcmRSZWFjdE1lYXN1cmVDb21wbGV0ZWQoJ2NvbW1pdCcpO1xuICAgICAgcmVjb3JkUmVhY3RNZWFzdXJlQ29tcGxldGVkKCdyZW5kZXItaWRsZScpO1xuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgbWFya0FuZENsZWFyKCctLWNvbW1pdC1zdG9wJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQoZmliZXIpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcgfHwgc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihmaWJlcikgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgICAgLy8gVE9ETyAodGltZWxpbmUpIFJlY29yZCBhbmQgY2FjaGUgY29tcG9uZW50IHN0YWNrXG4gICAgICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgICAgIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUgPSB7XG4gICAgICAgICAgICBjb21wb25lbnROYW1lOiBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGdldFJlbGF0aXZlVGltZSgpLFxuICAgICAgICAgICAgdHlwZTogJ3JlbmRlcicsXG4gICAgICAgICAgICB3YXJuaW5nOiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgICAgbWFya0FuZENsZWFyKFwiLS1jb21wb25lbnQtcmVuZGVyLXN0YXJ0LVwiLmNvbmNhdChjb21wb25lbnROYW1lKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICBpZiAoY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSkge1xuICAgICAgICBpZiAoY3VycmVudFRpbWVsaW5lRGF0YSkge1xuICAgICAgICAgIGN1cnJlbnRUaW1lbGluZURhdGEuY29tcG9uZW50TWVhc3VyZXMucHVzaChjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlKTtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUuZHVyYXRpb24gPSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgZ2V0UmVsYXRpdmVUaW1lKCkgLSBjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlLnRpbWVzdGFtcDtcbiAgICAgICAgY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICBtYXJrQW5kQ2xlYXIoJy0tY29tcG9uZW50LXJlbmRlci1zdG9wJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZChmaWJlcikge1xuICAgIGlmIChpc1Byb2ZpbGluZyB8fCBzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXREaXNwbGF5TmFtZUZvckZpYmVyKGZpYmVyKSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgICAvLyBUT0RPICh0aW1lbGluZSkgUmVjb3JkIGFuZCBjYWNoZSBjb21wb25lbnQgc3RhY2tcbiAgICAgICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICAgICAgY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSA9IHtcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWU6IGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogZ2V0UmVsYXRpdmVUaW1lKCksXG4gICAgICAgICAgICB0eXBlOiAnbGF5b3V0LWVmZmVjdC1tb3VudCcsXG4gICAgICAgICAgICB3YXJuaW5nOiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgICAgbWFya0FuZENsZWFyKFwiLS1jb21wb25lbnQtbGF5b3V0LWVmZmVjdC1tb3VudC1zdGFydC1cIi5jb25jYXQoY29tcG9uZW50TmFtZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQoKSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICBpZiAoY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSkge1xuICAgICAgICBpZiAoY3VycmVudFRpbWVsaW5lRGF0YSkge1xuICAgICAgICAgIGN1cnJlbnRUaW1lbGluZURhdGEuY29tcG9uZW50TWVhc3VyZXMucHVzaChjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlKTtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUuZHVyYXRpb24gPSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgZ2V0UmVsYXRpdmVUaW1lKCkgLSBjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlLnRpbWVzdGFtcDtcbiAgICAgICAgY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICBtYXJrQW5kQ2xlYXIoJy0tY29tcG9uZW50LWxheW91dC1lZmZlY3QtbW91bnQtc3RvcCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZChmaWJlcikge1xuICAgIGlmIChpc1Byb2ZpbGluZyB8fCBzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXREaXNwbGF5TmFtZUZvckZpYmVyKGZpYmVyKSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgICAvLyBUT0RPICh0aW1lbGluZSkgUmVjb3JkIGFuZCBjYWNoZSBjb21wb25lbnQgc3RhY2tcbiAgICAgICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICAgICAgY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSA9IHtcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWU6IGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogZ2V0UmVsYXRpdmVUaW1lKCksXG4gICAgICAgICAgICB0eXBlOiAnbGF5b3V0LWVmZmVjdC11bm1vdW50JyxcbiAgICAgICAgICAgIHdhcm5pbmc6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgICBtYXJrQW5kQ2xlYXIoXCItLWNvbXBvbmVudC1sYXlvdXQtZWZmZWN0LXVubW91bnQtc3RhcnQtXCIuY29uY2F0KGNvbXBvbmVudE5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICBpZiAoY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSkge1xuICAgICAgICBpZiAoY3VycmVudFRpbWVsaW5lRGF0YSkge1xuICAgICAgICAgIGN1cnJlbnRUaW1lbGluZURhdGEuY29tcG9uZW50TWVhc3VyZXMucHVzaChjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlKTtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUuZHVyYXRpb24gPSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgZ2V0UmVsYXRpdmVUaW1lKCkgLSBjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlLnRpbWVzdGFtcDtcbiAgICAgICAgY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICBtYXJrQW5kQ2xlYXIoJy0tY29tcG9uZW50LWxheW91dC1lZmZlY3QtdW5tb3VudC1zdG9wJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQoZmliZXIpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcgfHwgc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihmaWJlcikgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgICAgLy8gVE9ETyAodGltZWxpbmUpIFJlY29yZCBhbmQgY2FjaGUgY29tcG9uZW50IHN0YWNrXG4gICAgICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgICAgIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUgPSB7XG4gICAgICAgICAgICBjb21wb25lbnROYW1lOiBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGdldFJlbGF0aXZlVGltZSgpLFxuICAgICAgICAgICAgdHlwZTogJ3Bhc3NpdmUtZWZmZWN0LW1vdW50JyxcbiAgICAgICAgICAgIHdhcm5pbmc6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgICBtYXJrQW5kQ2xlYXIoXCItLWNvbXBvbmVudC1wYXNzaXZlLWVmZmVjdC1tb3VudC1zdGFydC1cIi5jb25jYXQoY29tcG9uZW50TmFtZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkKCkge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgaWYgKGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lbGluZURhdGEpIHtcbiAgICAgICAgICBjdXJyZW50VGltZWxpbmVEYXRhLmNvbXBvbmVudE1lYXN1cmVzLnB1c2goY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSk7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICBjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlLmR1cmF0aW9uID0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgIGdldFJlbGF0aXZlVGltZSgpIC0gY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZS50aW1lc3RhbXA7XG4gICAgICAgIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgbWFya0FuZENsZWFyKCctLWNvbXBvbmVudC1wYXNzaXZlLWVmZmVjdC1tb3VudC1zdG9wJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZChmaWJlcikge1xuICAgIGlmIChpc1Byb2ZpbGluZyB8fCBzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXREaXNwbGF5TmFtZUZvckZpYmVyKGZpYmVyKSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgICAvLyBUT0RPICh0aW1lbGluZSkgUmVjb3JkIGFuZCBjYWNoZSBjb21wb25lbnQgc3RhY2tcbiAgICAgICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICAgICAgY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSA9IHtcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWU6IGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogZ2V0UmVsYXRpdmVUaW1lKCksXG4gICAgICAgICAgICB0eXBlOiAncGFzc2l2ZS1lZmZlY3QtdW5tb3VudCcsXG4gICAgICAgICAgICB3YXJuaW5nOiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgICAgbWFya0FuZENsZWFyKFwiLS1jb21wb25lbnQtcGFzc2l2ZS1lZmZlY3QtdW5tb3VudC1zdGFydC1cIi5jb25jYXQoY29tcG9uZW50TmFtZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQoKSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICBpZiAoY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSkge1xuICAgICAgICBpZiAoY3VycmVudFRpbWVsaW5lRGF0YSkge1xuICAgICAgICAgIGN1cnJlbnRUaW1lbGluZURhdGEuY29tcG9uZW50TWVhc3VyZXMucHVzaChjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlKTtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUuZHVyYXRpb24gPSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgZ2V0UmVsYXRpdmVUaW1lKCkgLSBjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlLnRpbWVzdGFtcDtcbiAgICAgICAgY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICBtYXJrQW5kQ2xlYXIoJy0tY29tcG9uZW50LXBhc3NpdmUtZWZmZWN0LXVubW91bnQtc3RvcCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtDb21wb25lbnRFcnJvcmVkKGZpYmVyLCB0aHJvd25WYWx1ZSwgbGFuZXMpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcgfHwgc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihmaWJlcikgfHwgJ1Vua25vd24nO1xuICAgICAgdmFyIHBoYXNlID0gZmliZXIuYWx0ZXJuYXRlID09PSBudWxsID8gJ21vdW50JyA6ICd1cGRhdGUnO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnJztcblxuICAgICAgaWYgKHRocm93blZhbHVlICE9PSBudWxsICYmIF90eXBlb2YodGhyb3duVmFsdWUpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGhyb3duVmFsdWUubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWVzc2FnZSA9IHRocm93blZhbHVlLm1lc3NhZ2U7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aHJvd25WYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWVzc2FnZSA9IHRocm93blZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgICAgLy8gVE9ETyAodGltZWxpbmUpIFJlY29yZCBhbmQgY2FjaGUgY29tcG9uZW50IHN0YWNrXG4gICAgICAgIGlmIChjdXJyZW50VGltZWxpbmVEYXRhKSB7XG4gICAgICAgICAgY3VycmVudFRpbWVsaW5lRGF0YS50aHJvd25FcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBjb21wb25lbnROYW1lOiBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgIHBoYXNlOiBwaGFzZSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogZ2V0UmVsYXRpdmVUaW1lKCksXG4gICAgICAgICAgICB0eXBlOiAndGhyb3duLWVycm9yJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgICBtYXJrQW5kQ2xlYXIoXCItLWVycm9yLVwiLmNvbmNhdChjb21wb25lbnROYW1lLCBcIi1cIikuY29uY2F0KHBoYXNlLCBcIi1cIikuY29uY2F0KG1lc3NhZ2UpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBjYW5ub3QgaGFuZGxlIHBvbHltb3JwaGljIFdlYWtNYXBzXG5cbiAgdmFyIHdha2VhYmxlSURzID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xuICB2YXIgd2FrZWFibGVJRCA9IDA7XG5cbiAgZnVuY3Rpb24gZ2V0V2FrZWFibGVJRCh3YWtlYWJsZSkge1xuICAgIGlmICghd2FrZWFibGVJRHMuaGFzKHdha2VhYmxlKSkge1xuICAgICAgd2FrZWFibGVJRHMuc2V0KHdha2VhYmxlLCB3YWtlYWJsZUlEKyspO1xuICAgIH1cblxuICAgIHJldHVybiB3YWtlYWJsZUlEcy5nZXQod2FrZWFibGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFya0NvbXBvbmVudFN1c3BlbmRlZChmaWJlciwgd2FrZWFibGUsIGxhbmVzKSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nIHx8IHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICB2YXIgZXZlbnRUeXBlID0gd2FrZWFibGVJRHMuaGFzKHdha2VhYmxlKSA/ICdyZXN1c3BlbmQnIDogJ3N1c3BlbmQnO1xuICAgICAgdmFyIGlkID0gZ2V0V2FrZWFibGVJRCh3YWtlYWJsZSk7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpIHx8ICdVbmtub3duJztcbiAgICAgIHZhciBwaGFzZSA9IGZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCA/ICdtb3VudCcgOiAndXBkYXRlJzsgLy8gRm9sbG93aW5nIHRoZSBub24tc3RhbmRhcmQgZm4uZGlzcGxheU5hbWUgY29udmVudGlvbixcbiAgICAgIC8vIGZyYW1ld29ya3MgbGlrZSBSZWxheSBtYXkgYWxzbyBhbm5vdGF0ZSBQcm9taXNlcyB3aXRoIGEgZGlzcGxheU5hbWUsXG4gICAgICAvLyBkZXNjcmliaW5nIHdoYXQgb3BlcmF0aW9uL2RhdGEgdGhlIHRocm93biBQcm9taXNlIGlzIHJlbGF0ZWQgdG8uXG4gICAgICAvLyBXaGVuIHRoaXMgaXMgYXZhaWxhYmxlIHdlIHNob3VsZCBwYXNzIGl0IGFsb25nIHRvIHRoZSBUaW1lbGluZS5cblxuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gd2FrZWFibGUuZGlzcGxheU5hbWUgfHwgJyc7XG4gICAgICB2YXIgc3VzcGVuc2VFdmVudCA9IG51bGw7XG5cbiAgICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgICAvLyBUT0RPICh0aW1lbGluZSkgUmVjb3JkIGFuZCBjYWNoZSBjb21wb25lbnQgc3RhY2tcbiAgICAgICAgc3VzcGVuc2VFdmVudCA9IHtcbiAgICAgICAgICBjb21wb25lbnROYW1lOiBjb21wb25lbnROYW1lLFxuICAgICAgICAgIGRlcHRoOiAwLFxuICAgICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICAgIGlkOiBcIlwiLmNvbmNhdChpZCksXG4gICAgICAgICAgcGhhc2U6IHBoYXNlLFxuICAgICAgICAgIHByb21pc2VOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgICAgICByZXNvbHV0aW9uOiAndW5yZXNvbHZlZCcsXG4gICAgICAgICAgdGltZXN0YW1wOiBnZXRSZWxhdGl2ZVRpbWUoKSxcbiAgICAgICAgICB0eXBlOiAnc3VzcGVuc2UnLFxuICAgICAgICAgIHdhcm5pbmc6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoY3VycmVudFRpbWVsaW5lRGF0YSkge1xuICAgICAgICAgIGN1cnJlbnRUaW1lbGluZURhdGEuc3VzcGVuc2VFdmVudHMucHVzaChzdXNwZW5zZUV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgICAgbWFya0FuZENsZWFyKFwiLS1zdXNwZW5zZS1cIi5jb25jYXQoZXZlbnRUeXBlLCBcIi1cIikuY29uY2F0KGlkLCBcIi1cIikuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiLVwiKS5jb25jYXQocGhhc2UsIFwiLVwiKS5jb25jYXQobGFuZXMsIFwiLVwiKS5jb25jYXQoZGlzcGxheU5hbWUpKTtcbiAgICAgIH1cblxuICAgICAgd2FrZWFibGUudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzdXNwZW5zZUV2ZW50KSB7XG4gICAgICAgICAgc3VzcGVuc2VFdmVudC5kdXJhdGlvbiA9IGdldFJlbGF0aXZlVGltZSgpIC0gc3VzcGVuc2VFdmVudC50aW1lc3RhbXA7XG4gICAgICAgICAgc3VzcGVuc2VFdmVudC5yZXNvbHV0aW9uID0gJ3Jlc29sdmVkJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgICAgIG1hcmtBbmRDbGVhcihcIi0tc3VzcGVuc2UtcmVzb2x2ZWQtXCIuY29uY2F0KGlkLCBcIi1cIikuY29uY2F0KGNvbXBvbmVudE5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc3VzcGVuc2VFdmVudCkge1xuICAgICAgICAgIHN1c3BlbnNlRXZlbnQuZHVyYXRpb24gPSBnZXRSZWxhdGl2ZVRpbWUoKSAtIHN1c3BlbnNlRXZlbnQudGltZXN0YW1wO1xuICAgICAgICAgIHN1c3BlbnNlRXZlbnQucmVzb2x1dGlvbiA9ICdyZWplY3RlZCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgICAgICBtYXJrQW5kQ2xlYXIoXCItLXN1c3BlbnNlLXJlamVjdGVkLVwiLmNvbmNhdChpZCwgXCItXCIpLmNvbmNhdChjb21wb25lbnROYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZChsYW5lcykge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgcmVjb3JkUmVhY3RNZWFzdXJlU3RhcnRlZCgnbGF5b3V0LWVmZmVjdHMnLCBsYW5lcyk7XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICBtYXJrQW5kQ2xlYXIoXCItLWxheW91dC1lZmZlY3RzLXN0YXJ0LVwiLmNvbmNhdChsYW5lcykpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCgpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIHJlY29yZFJlYWN0TWVhc3VyZUNvbXBsZXRlZCgnbGF5b3V0LWVmZmVjdHMnKTtcbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIG1hcmtBbmRDbGVhcignLS1sYXlvdXQtZWZmZWN0cy1zdG9wJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZChsYW5lcykge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgcmVjb3JkUmVhY3RNZWFzdXJlU3RhcnRlZCgncGFzc2l2ZS1lZmZlY3RzJywgbGFuZXMpO1xuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgbWFya0FuZENsZWFyKFwiLS1wYXNzaXZlLWVmZmVjdHMtc3RhcnQtXCIuY29uY2F0KGxhbmVzKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZCgpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIHJlY29yZFJlYWN0TWVhc3VyZUNvbXBsZXRlZCgncGFzc2l2ZS1lZmZlY3RzJyk7XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICBtYXJrQW5kQ2xlYXIoJy0tcGFzc2l2ZS1lZmZlY3RzLXN0b3AnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrUmVuZGVyU3RhcnRlZChsYW5lcykge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgaWYgKG5leHRSZW5kZXJTaG91bGRTdGFydE5ld0JhdGNoKSB7XG4gICAgICAgIG5leHRSZW5kZXJTaG91bGRTdGFydE5ld0JhdGNoID0gZmFsc2U7XG4gICAgICAgIGN1cnJlbnRCYXRjaFVJRCsrO1xuICAgICAgfSAvLyBJZiB0aGlzIGlzIGEgbmV3IGJhdGNoIG9mIHdvcmssIHdyYXAgYW4gXCJpZGxlXCIgbWVhc3VyZSBhcm91bmQgaXQuXG4gICAgICAvLyBMb2cgaXQgYmVmb3JlIHRoZSBcInJlbmRlclwiIG1lYXN1cmUgdG8gcHJlc2VydmUgdGhlIHN0YWNrIG9yZGVyaW5nLlxuXG5cbiAgICAgIGlmIChjdXJyZW50UmVhY3RNZWFzdXJlc1N0YWNrLmxlbmd0aCA9PT0gMCB8fCBjdXJyZW50UmVhY3RNZWFzdXJlc1N0YWNrW2N1cnJlbnRSZWFjdE1lYXN1cmVzU3RhY2subGVuZ3RoIC0gMV0udHlwZSAhPT0gJ3JlbmRlci1pZGxlJykge1xuICAgICAgICByZWNvcmRSZWFjdE1lYXN1cmVTdGFydGVkKCdyZW5kZXItaWRsZScsIGxhbmVzKTtcbiAgICAgIH1cblxuICAgICAgcmVjb3JkUmVhY3RNZWFzdXJlU3RhcnRlZCgncmVuZGVyJywgbGFuZXMpO1xuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgbWFya0FuZENsZWFyKFwiLS1yZW5kZXItc3RhcnQtXCIuY29uY2F0KGxhbmVzKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya1JlbmRlcllpZWxkZWQoKSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICByZWNvcmRSZWFjdE1lYXN1cmVDb21wbGV0ZWQoJ3JlbmRlcicpO1xuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgbWFya0FuZENsZWFyKCctLXJlbmRlci15aWVsZCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtSZW5kZXJTdG9wcGVkKCkge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgcmVjb3JkUmVhY3RNZWFzdXJlQ29tcGxldGVkKCdyZW5kZXInKTtcbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIG1hcmtBbmRDbGVhcignLS1yZW5kZXItc3RvcCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtSZW5kZXJTY2hlZHVsZWQobGFuZSkge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgaWYgKGN1cnJlbnRUaW1lbGluZURhdGEpIHtcbiAgICAgICAgY3VycmVudFRpbWVsaW5lRGF0YS5zY2hlZHVsaW5nRXZlbnRzLnB1c2goe1xuICAgICAgICAgIGxhbmVzOiBsYW5lVG9MYW5lc0FycmF5KGxhbmUpLFxuICAgICAgICAgIHRpbWVzdGFtcDogZ2V0UmVsYXRpdmVUaW1lKCksXG4gICAgICAgICAgdHlwZTogJ3NjaGVkdWxlLXJlbmRlcicsXG4gICAgICAgICAgd2FybmluZzogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIG1hcmtBbmRDbGVhcihcIi0tc2NoZWR1bGUtcmVuZGVyLVwiLmNvbmNhdChsYW5lKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nIHx8IHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICAgIC8vIFRPRE8gKHRpbWVsaW5lKSBSZWNvcmQgYW5kIGNhY2hlIGNvbXBvbmVudCBzdGFja1xuICAgICAgICBpZiAoY3VycmVudFRpbWVsaW5lRGF0YSkge1xuICAgICAgICAgIGN1cnJlbnRUaW1lbGluZURhdGEuc2NoZWR1bGluZ0V2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWU6IGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICBsYW5lczogbGFuZVRvTGFuZXNBcnJheShsYW5lKSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogZ2V0UmVsYXRpdmVUaW1lKCksXG4gICAgICAgICAgICB0eXBlOiAnc2NoZWR1bGUtZm9yY2UtdXBkYXRlJyxcbiAgICAgICAgICAgIHdhcm5pbmc6IG51bGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgICAgbWFya0FuZENsZWFyKFwiLS1zY2hlZHVsZS1mb3JjZWQtdXBkYXRlLVwiLmNvbmNhdChsYW5lLCBcIi1cIikuY29uY2F0KGNvbXBvbmVudE5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXJlbnRGaWJlcnMoZmliZXIpIHtcbiAgICB2YXIgcGFyZW50cyA9IFtdO1xuICAgIHZhciBwYXJlbnQgPSBmaWJlcjtcblxuICAgIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSkge1xuICAgIGlmIChpc1Byb2ZpbGluZyB8fCBzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXREaXNwbGF5TmFtZUZvckZpYmVyKGZpYmVyKSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgICAvLyBUT0RPICh0aW1lbGluZSkgUmVjb3JkIGFuZCBjYWNoZSBjb21wb25lbnQgc3RhY2tcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lbGluZURhdGEpIHtcbiAgICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICBjb21wb25lbnROYW1lOiBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIHBhcmVudCBmaWJlcnMgc28gd2UgY2FuIHBvc3QgcHJvY2Vzc1xuICAgICAgICAgICAgLy8gdGhlbSBhZnRlciB3ZSBmaW5pc2ggcHJvZmlsaW5nXG4gICAgICAgICAgICBsYW5lczogbGFuZVRvTGFuZXNBcnJheShsYW5lKSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogZ2V0UmVsYXRpdmVUaW1lKCksXG4gICAgICAgICAgICB0eXBlOiAnc2NoZWR1bGUtc3RhdGUtdXBkYXRlJyxcbiAgICAgICAgICAgIHdhcm5pbmc6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGN1cnJlbnRGaWJlclN0YWNrcy5zZXQoZXZlbnQsIGdldFBhcmVudEZpYmVycyhmaWJlcikpOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuICAgICAgICAgIGN1cnJlbnRUaW1lbGluZURhdGEuc2NoZWR1bGluZ0V2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgICAgbWFya0FuZENsZWFyKFwiLS1zY2hlZHVsZS1zdGF0ZS11cGRhdGUtXCIuY29uY2F0KGxhbmUsIFwiLVwiKS5jb25jYXQoY29tcG9uZW50TmFtZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvZ2dsZVByb2ZpbGluZ1N0YXR1cyh2YWx1ZSkge1xuICAgIGlmIChpc1Byb2ZpbGluZyAhPT0gdmFsdWUpIHtcbiAgICAgIGlzUHJvZmlsaW5nID0gdmFsdWU7XG5cbiAgICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgICB2YXIgaW50ZXJuYWxNb2R1bGVTb3VyY2VUb1JhbmdlcyA9IG5ldyBNYXAoKTtcblxuICAgICAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgICAgICB2YXIgcmFuZ2VzID0gZ2V0SW50ZXJuYWxNb2R1bGVSYW5nZXMoKTtcblxuICAgICAgICAgIGlmIChyYW5nZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcblxuICAgICAgICAgICAgICBpZiAoT2JqZWN0KHNoYXJlZF9pc0FycmF5W1wiYVwiIC8qIGRlZmF1bHQgKi9dKShyYW5nZSkgJiYgcmFuZ2UubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yYW5nZXMkaTIgPSBfc2xpY2VkVG9BcnJheShyYW5nZXNbaV0sIDIpLFxuICAgICAgICAgICAgICAgICAgICBzdGFydFN0YWNrRnJhbWUgPSBfcmFuZ2VzJGkyWzBdLFxuICAgICAgICAgICAgICAgICAgICBzdG9wU3RhY2tGcmFtZSA9IF9yYW5nZXMkaTJbMV07XG5cbiAgICAgICAgICAgICAgICBtYXJrQW5kQ2xlYXIoXCItLXJlYWN0LWludGVybmFsLW1vZHVsZS1zdGFydC1cIi5jb25jYXQoc3RhcnRTdGFja0ZyYW1lKSk7XG4gICAgICAgICAgICAgICAgbWFya0FuZENsZWFyKFwiLS1yZWFjdC1pbnRlcm5hbC1tb2R1bGUtc3RvcC1cIi5jb25jYXQoc3RvcFN0YWNrRnJhbWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYW5lVG9SZWFjdE1lYXN1cmVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBsYW5lID0gMTtcblxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgUkVBQ1RfVE9UQUxfTlVNX0xBTkVTOyBpbmRleCsrKSB7XG4gICAgICAgICAgbGFuZVRvUmVhY3RNZWFzdXJlTWFwLnNldChsYW5lLCBbXSk7XG4gICAgICAgICAgbGFuZSAqPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudEJhdGNoVUlEID0gMDtcbiAgICAgICAgY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRSZWFjdE1lYXN1cmVzU3RhY2sgPSBbXTtcbiAgICAgICAgY3VycmVudEZpYmVyU3RhY2tzID0gbmV3IE1hcCgpO1xuICAgICAgICBjdXJyZW50VGltZWxpbmVEYXRhID0ge1xuICAgICAgICAgIC8vIFNlc3Npb24gd2lkZSBtZXRhZGF0YTsgb25seSBjb2xsZWN0ZWQgb25jZS5cbiAgICAgICAgICBpbnRlcm5hbE1vZHVsZVNvdXJjZVRvUmFuZ2VzOiBpbnRlcm5hbE1vZHVsZVNvdXJjZVRvUmFuZ2VzLFxuICAgICAgICAgIGxhbmVUb0xhYmVsTWFwOiBsYW5lVG9MYWJlbE1hcCB8fCBuZXcgTWFwKCksXG4gICAgICAgICAgcmVhY3RWZXJzaW9uOiByZWFjdFZlcnNpb24sXG4gICAgICAgICAgLy8gRGF0YSBsb2dnZWQgYnkgUmVhY3QgZHVyaW5nIHByb2ZpbGluZyBzZXNzaW9uLlxuICAgICAgICAgIGNvbXBvbmVudE1lYXN1cmVzOiBbXSxcbiAgICAgICAgICBzY2hlZHVsaW5nRXZlbnRzOiBbXSxcbiAgICAgICAgICBzdXNwZW5zZUV2ZW50czogW10sXG4gICAgICAgICAgdGhyb3duRXJyb3JzOiBbXSxcbiAgICAgICAgICAvLyBEYXRhIGluZmVycmVkIGJhc2VkIG9uIHdoYXQgUmVhY3QgbG9ncy5cbiAgICAgICAgICBiYXRjaFVJRFRvTWVhc3VyZXNNYXA6IG5ldyBNYXAoKSxcbiAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICBsYW5lVG9SZWFjdE1lYXN1cmVNYXA6IGxhbmVUb1JlYWN0TWVhc3VyZU1hcCxcbiAgICAgICAgICBzdGFydFRpbWU6IDAsXG4gICAgICAgICAgLy8gRGF0YSBvbmx5IGF2YWlsYWJsZSBpbiBDaHJvbWUgcHJvZmlsZXMuXG4gICAgICAgICAgZmxhbWVjaGFydDogW10sXG4gICAgICAgICAgbmF0aXZlRXZlbnRzOiBbXSxcbiAgICAgICAgICBuZXR3b3JrTWVhc3VyZXM6IFtdLFxuICAgICAgICAgIG90aGVyVXNlclRpbWluZ01hcmtzOiBbXSxcbiAgICAgICAgICBzbmFwc2hvdHM6IFtdLFxuICAgICAgICAgIHNuYXBzaG90SGVpZ2h0OiAwXG4gICAgICAgIH07XG4gICAgICAgIG5leHRSZW5kZXJTaG91bGRTdGFydE5ld0JhdGNoID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFBvc3Rwcm9jZXNzIFByb2ZpbGUgZGF0YVxuICAgICAgICBpZiAoY3VycmVudFRpbWVsaW5lRGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgIGN1cnJlbnRUaW1lbGluZURhdGEuc2NoZWR1bGluZ0V2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdzY2hlZHVsZS1zdGF0ZS11cGRhdGUnKSB7XG4gICAgICAgICAgICAgIC8vIFRPRE8obHVuYSk6IFdlIGNhbiBvcHRpbWl6ZSB0aGlzIGJ5IGNyZWF0aW5nIGEgbWFwIG9mXG4gICAgICAgICAgICAgIC8vIGZpYmVyIHRvIGNvbXBvbmVudCBzdGFjayBpbnN0ZWFkIG9mIGdlbmVyYXRpbmcgdGhlIHN0YWNrXG4gICAgICAgICAgICAgIC8vIGZvciBldmVyeSBmaWJlciBldmVyeSB0aW1lXG4gICAgICAgICAgICAgIHZhciBmaWJlclN0YWNrID0gY3VycmVudEZpYmVyU3RhY2tzLmdldChldmVudCk7XG5cbiAgICAgICAgICAgICAgaWYgKGZpYmVyU3RhY2sgJiYgY3VycmVudERpc3BhdGNoZXJSZWYgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LmNvbXBvbmVudFN0YWNrID0gZmliZXJTdGFjay5yZWR1Y2UoZnVuY3Rpb24gKHRyYWNlLCBmaWJlcikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNlICsgT2JqZWN0KERldlRvb2xzRmliZXJDb21wb25lbnRTdGFja1tcImFcIiAvKiBkZXNjcmliZUZpYmVyICovXSkod29ya1RhZ01hcCwgZmliZXIsIGN1cnJlbnREaXNwYXRjaGVyUmVmKTtcbiAgICAgICAgICAgICAgICB9LCAnJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBDbGVhciB0aGUgY3VycmVudCBmaWJlciBzdGFja3Mgc28gd2UgZG9uJ3QgaG9sZCBvbnRvIHRoZSBmaWJlcnNcbiAgICAgICAgLy8gaW4gbWVtb3J5IGFmdGVyIHByb2ZpbGluZyBmaW5pc2hlc1xuXG5cbiAgICAgICAgY3VycmVudEZpYmVyU3RhY2tzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnZXRUaW1lbGluZURhdGE6IGdldFRpbWVsaW5lRGF0YSxcbiAgICBwcm9maWxpbmdIb29rczoge1xuICAgICAgbWFya0NvbW1pdFN0YXJ0ZWQ6IG1hcmtDb21taXRTdGFydGVkLFxuICAgICAgbWFya0NvbW1pdFN0b3BwZWQ6IG1hcmtDb21taXRTdG9wcGVkLFxuICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQ6IG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkLFxuICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQ6IG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkLFxuICAgICAgbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQ6IG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkLFxuICAgICAgbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQ6IG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkLFxuICAgICAgbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZDogbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZCxcbiAgICAgIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQ6IG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQsXG4gICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkOiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkLFxuICAgICAgbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZDogbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCxcbiAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZDogbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkLFxuICAgICAgbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkOiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQsXG4gICAgICBtYXJrQ29tcG9uZW50RXJyb3JlZDogbWFya0NvbXBvbmVudEVycm9yZWQsXG4gICAgICBtYXJrQ29tcG9uZW50U3VzcGVuZGVkOiBtYXJrQ29tcG9uZW50U3VzcGVuZGVkLFxuICAgICAgbWFya0xheW91dEVmZmVjdHNTdGFydGVkOiBtYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQsXG4gICAgICBtYXJrTGF5b3V0RWZmZWN0c1N0b3BwZWQ6IG1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCxcbiAgICAgIG1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQ6IG1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQsXG4gICAgICBtYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkOiBtYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkLFxuICAgICAgbWFya1JlbmRlclN0YXJ0ZWQ6IG1hcmtSZW5kZXJTdGFydGVkLFxuICAgICAgbWFya1JlbmRlcllpZWxkZWQ6IG1hcmtSZW5kZXJZaWVsZGVkLFxuICAgICAgbWFya1JlbmRlclN0b3BwZWQ6IG1hcmtSZW5kZXJTdG9wcGVkLFxuICAgICAgbWFya1JlbmRlclNjaGVkdWxlZDogbWFya1JlbmRlclNjaGVkdWxlZCxcbiAgICAgIG1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZDogbWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkLFxuICAgICAgbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkOiBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWRcbiAgICB9LFxuICAgIHRvZ2dsZVByb2ZpbGluZ1N0YXR1czogdG9nZ2xlUHJvZmlsaW5nU3RhdHVzXG4gIH07XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvcmVuZGVyZXIuanNcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiByZW5kZXJlcl9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gcmVuZGVyZXJfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCByZW5kZXJlcl9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IHJlbmRlcmVyX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgcmVuZGVyZXJfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gcmVuZGVyZXJfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIHJlbmRlcmVyX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIHJlbmRlcmVyX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCByZW5kZXJlcl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIHJlbmRlcmVyX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IHJlbmRlcmVyX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgdGhyb3cgX2UyOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMykgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTM7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gcmVuZGVyZXJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiByZW5kZXJlcl9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gcmVuZGVyZXJfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIHJlbmRlcmVyX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIHJlbmRlcmVyX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgcmVuZGVyZXJfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IHJlbmRlcmVyX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiByZW5kZXJlcl90eXBlb2Yob2JqKTsgfVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gZ2V0RmliZXJGbGFncyhmaWJlcikge1xuICAvLyBUaGUgbmFtZSBvZiB0aGlzIGZpZWxkIGNoYW5nZWQgZnJvbSBcImVmZmVjdFRhZ1wiIHRvIFwiZmxhZ3NcIlxuICByZXR1cm4gZmliZXIuZmxhZ3MgIT09IHVuZGVmaW5lZCA/IGZpYmVyLmZsYWdzIDogZmliZXIuZWZmZWN0VGFnO1xufSAvLyBTb21lIGVudmlyb25tZW50cyAoZS5nLiBSZWFjdCBOYXRpdmUgLyBIZXJtZXMpIGRvbid0IHN1cHBvcnQgdGhlIHBlcmZvcm1hbmNlIEFQSSB5ZXQuXG5cblxudmFyIHJlbmRlcmVyX2dldEN1cnJlbnRUaW1lID0gLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuKHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiByZW5kZXJlcl90eXBlb2YocGVyZm9ybWFuY2UpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xufSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIERhdGUubm93KCk7XG59O1xuZnVuY3Rpb24gZ2V0SW50ZXJuYWxSZWFjdENvbnN0YW50cyh2ZXJzaW9uKSB7XG4gIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgLy8gVGhlIHNlY3Rpb24gYmVsb3cgaXMgY29waWVkIGZyb20gZmlsZXMgaW4gUmVhY3QgcmVwby5cbiAgLy8gS2VlcCBpdCBpbiBzeW5jLCBhbmQgYWRkIHZlcnNpb24gZ3VhcmRzIGlmIGl0IGNoYW5nZXMuXG4gIC8vXG4gIC8vIFRlY2huaWNhbGx5IHRoZXNlIHByaW9yaXR5IGxldmVscyBhcmUgaW52YWxpZCBmb3IgdmVyc2lvbnMgYmVmb3JlIDE2LjksXG4gIC8vIGJ1dCAxNi45IGlzIHRoZSBmaXJzdCB2ZXJzaW9uIHRvIHJlcG9ydCBwcmlvcml0eSBsZXZlbCB0byBEZXZUb29scyxcbiAgLy8gc28gd2UgY2FuIGF2b2lkIGNoZWNraW5nIGZvciBlYXJsaWVyIHZlcnNpb25zIGFuZCBzdXBwb3J0IHByZS0xNi45IGNhbmFyeSByZWxlYXNlcyBpbiB0aGUgcHJvY2Vzcy5cbiAgdmFyIFJlYWN0UHJpb3JpdHlMZXZlbHMgPSB7XG4gICAgSW1tZWRpYXRlUHJpb3JpdHk6IDk5LFxuICAgIFVzZXJCbG9ja2luZ1ByaW9yaXR5OiA5OCxcbiAgICBOb3JtYWxQcmlvcml0eTogOTcsXG4gICAgTG93UHJpb3JpdHk6IDk2LFxuICAgIElkbGVQcmlvcml0eTogOTUsXG4gICAgTm9Qcmlvcml0eTogOTBcbiAgfTtcblxuICBpZiAoT2JqZWN0KGJhY2tlbmRfdXRpbHNbXCJoXCIgLyogZ3QgKi9dKSh2ZXJzaW9uLCAnMTcuMC4yJykpIHtcbiAgICBSZWFjdFByaW9yaXR5TGV2ZWxzID0ge1xuICAgICAgSW1tZWRpYXRlUHJpb3JpdHk6IDEsXG4gICAgICBVc2VyQmxvY2tpbmdQcmlvcml0eTogMixcbiAgICAgIE5vcm1hbFByaW9yaXR5OiAzLFxuICAgICAgTG93UHJpb3JpdHk6IDQsXG4gICAgICBJZGxlUHJpb3JpdHk6IDUsXG4gICAgICBOb1ByaW9yaXR5OiAwXG4gICAgfTtcbiAgfVxuXG4gIHZhciBTdHJpY3RNb2RlQml0cyA9IDA7XG5cbiAgaWYgKE9iamVjdChiYWNrZW5kX3V0aWxzW1wiaVwiIC8qIGd0ZSAqL10pKHZlcnNpb24sICcxOC4wLjAtYWxwaGEnKSkge1xuICAgIC8vIDE4K1xuICAgIFN0cmljdE1vZGVCaXRzID0gMjQ7XG4gIH0gZWxzZSBpZiAoT2JqZWN0KGJhY2tlbmRfdXRpbHNbXCJpXCIgLyogZ3RlICovXSkodmVyc2lvbiwgJzE2LjkuMCcpKSB7XG4gICAgLy8gMTYuOSAtIDE3XG4gICAgU3RyaWN0TW9kZUJpdHMgPSAxO1xuICB9IGVsc2UgaWYgKE9iamVjdChiYWNrZW5kX3V0aWxzW1wiaVwiIC8qIGd0ZSAqL10pKHZlcnNpb24sICcxNi4zLjAnKSkge1xuICAgIC8vIDE2LjMgLSAxNi44XG4gICAgU3RyaWN0TW9kZUJpdHMgPSAyO1xuICB9XG5cbiAgdmFyIFJlYWN0VHlwZU9mV29yayA9IG51bGw7IC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgLy8gVGhlIHNlY3Rpb24gYmVsb3cgaXMgY29waWVkIGZyb20gZmlsZXMgaW4gUmVhY3QgcmVwby5cbiAgLy8gS2VlcCBpdCBpbiBzeW5jLCBhbmQgYWRkIHZlcnNpb24gZ3VhcmRzIGlmIGl0IGNoYW5nZXMuXG4gIC8vXG4gIC8vIFRPRE8gVXBkYXRlIHRoZSBndCgpIGNoZWNrIGJlbG93IHRvIGJlIGd0ZSgpIHdoaWNoZXZlciB0aGUgbmV4dCB2ZXJzaW9uIG51bWJlciBpcy5cbiAgLy8gQ3VycmVudGx5IHRoZSB2ZXJzaW9uIGluIEdpdCBpcyAxNy4wLjIgKGJ1dCB0aGF0IHZlcnNpb24gaGFzIG5vdCBiZWVuL21heSBub3QgZW5kIHVwIGJlaW5nIHJlbGVhc2VkKS5cblxuICBpZiAoT2JqZWN0KGJhY2tlbmRfdXRpbHNbXCJoXCIgLyogZ3QgKi9dKSh2ZXJzaW9uLCAnMTcuMC4xJykpIHtcbiAgICBSZWFjdFR5cGVPZldvcmsgPSB7XG4gICAgICBDYWNoZUNvbXBvbmVudDogMjQsXG4gICAgICAvLyBFeHBlcmltZW50YWxcbiAgICAgIENsYXNzQ29tcG9uZW50OiAxLFxuICAgICAgQ29udGV4dENvbnN1bWVyOiA5LFxuICAgICAgQ29udGV4dFByb3ZpZGVyOiAxMCxcbiAgICAgIENvcm91dGluZUNvbXBvbmVudDogLTEsXG4gICAgICAvLyBSZW1vdmVkXG4gICAgICBDb3JvdXRpbmVIYW5kbGVyUGhhc2U6IC0xLFxuICAgICAgLy8gUmVtb3ZlZFxuICAgICAgRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50OiAxOCxcbiAgICAgIC8vIEJlaGluZCBhIGZsYWdcbiAgICAgIEZvcndhcmRSZWY6IDExLFxuICAgICAgRnJhZ21lbnQ6IDcsXG4gICAgICBGdW5jdGlvbkNvbXBvbmVudDogMCxcbiAgICAgIEhvc3RDb21wb25lbnQ6IDUsXG4gICAgICBIb3N0UG9ydGFsOiA0LFxuICAgICAgSG9zdFJvb3Q6IDMsXG4gICAgICBIb3N0SG9pc3RhYmxlOiAyNixcbiAgICAgIC8vIEluIHJlYWxpdHksIDE4LjIrLiBCdXQgZG9lc24ndCBodXJ0IHRvIGluY2x1ZGUgaXQgaGVyZVxuICAgICAgSG9zdFNpbmdsZXRvbjogMjcsXG4gICAgICAvLyBTYW1lIGFzIGFib3ZlXG4gICAgICBIb3N0VGV4dDogNixcbiAgICAgIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDogMTcsXG4gICAgICBJbmRldGVybWluYXRlQ29tcG9uZW50OiAyLFxuICAgICAgTGF6eUNvbXBvbmVudDogMTYsXG4gICAgICBMZWdhY3lIaWRkZW5Db21wb25lbnQ6IDIzLFxuICAgICAgTWVtb0NvbXBvbmVudDogMTQsXG4gICAgICBNb2RlOiA4LFxuICAgICAgT2Zmc2NyZWVuQ29tcG9uZW50OiAyMixcbiAgICAgIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgUHJvZmlsZXI6IDEyLFxuICAgICAgU2NvcGVDb21wb25lbnQ6IDIxLFxuICAgICAgLy8gRXhwZXJpbWVudGFsXG4gICAgICBTaW1wbGVNZW1vQ29tcG9uZW50OiAxNSxcbiAgICAgIFN1c3BlbnNlQ29tcG9uZW50OiAxMyxcbiAgICAgIFN1c3BlbnNlTGlzdENvbXBvbmVudDogMTksXG4gICAgICAvLyBFeHBlcmltZW50YWxcbiAgICAgIFRyYWNpbmdNYXJrZXJDb21wb25lbnQ6IDI1LFxuICAgICAgLy8gRXhwZXJpbWVudGFsIC0gVGhpcyBpcyB0ZWNobmljYWxseSBpbiAxOCBidXQgd2UgZG9uJ3RcbiAgICAgIC8vIHdhbnQgdG8gZm9yayBhZ2FpbiBzbyB3ZSdyZSBhZGRpbmcgaXQgaGVyZSBpbnN0ZWFkXG4gICAgICBZaWVsZENvbXBvbmVudDogLTEgLy8gUmVtb3ZlZFxuXG4gICAgfTtcbiAgfSBlbHNlIGlmIChPYmplY3QoYmFja2VuZF91dGlsc1tcImlcIiAvKiBndGUgKi9dKSh2ZXJzaW9uLCAnMTcuMC4wLWFscGhhJykpIHtcbiAgICBSZWFjdFR5cGVPZldvcmsgPSB7XG4gICAgICBDYWNoZUNvbXBvbmVudDogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgQ2xhc3NDb21wb25lbnQ6IDEsXG4gICAgICBDb250ZXh0Q29uc3VtZXI6IDksXG4gICAgICBDb250ZXh0UHJvdmlkZXI6IDEwLFxuICAgICAgQ29yb3V0aW5lQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIFJlbW92ZWRcbiAgICAgIENvcm91dGluZUhhbmRsZXJQaGFzZTogLTEsXG4gICAgICAvLyBSZW1vdmVkXG4gICAgICBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQ6IDE4LFxuICAgICAgLy8gQmVoaW5kIGEgZmxhZ1xuICAgICAgRm9yd2FyZFJlZjogMTEsXG4gICAgICBGcmFnbWVudDogNyxcbiAgICAgIEZ1bmN0aW9uQ29tcG9uZW50OiAwLFxuICAgICAgSG9zdENvbXBvbmVudDogNSxcbiAgICAgIEhvc3RQb3J0YWw6IDQsXG4gICAgICBIb3N0Um9vdDogMyxcbiAgICAgIEhvc3RIb2lzdGFibGU6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIEhvc3RTaW5nbGV0b246IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIEhvc3RUZXh0OiA2LFxuICAgICAgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OiAxNyxcbiAgICAgIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6IDIsXG4gICAgICBMYXp5Q29tcG9uZW50OiAxNixcbiAgICAgIExlZ2FjeUhpZGRlbkNvbXBvbmVudDogMjQsXG4gICAgICBNZW1vQ29tcG9uZW50OiAxNCxcbiAgICAgIE1vZGU6IDgsXG4gICAgICBPZmZzY3JlZW5Db21wb25lbnQ6IDIzLFxuICAgICAgLy8gRXhwZXJpbWVudGFsXG4gICAgICBQcm9maWxlcjogMTIsXG4gICAgICBTY29wZUNvbXBvbmVudDogMjEsXG4gICAgICAvLyBFeHBlcmltZW50YWxcbiAgICAgIFNpbXBsZU1lbW9Db21wb25lbnQ6IDE1LFxuICAgICAgU3VzcGVuc2VDb21wb25lbnQ6IDEzLFxuICAgICAgU3VzcGVuc2VMaXN0Q29tcG9uZW50OiAxOSxcbiAgICAgIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgVHJhY2luZ01hcmtlckNvbXBvbmVudDogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgWWllbGRDb21wb25lbnQ6IC0xIC8vIFJlbW92ZWRcblxuICAgIH07XG4gIH0gZWxzZSBpZiAoT2JqZWN0KGJhY2tlbmRfdXRpbHNbXCJpXCIgLyogZ3RlICovXSkodmVyc2lvbiwgJzE2LjYuMC1iZXRhLjAnKSkge1xuICAgIFJlYWN0VHlwZU9mV29yayA9IHtcbiAgICAgIENhY2hlQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBDbGFzc0NvbXBvbmVudDogMSxcbiAgICAgIENvbnRleHRDb25zdW1lcjogOSxcbiAgICAgIENvbnRleHRQcm92aWRlcjogMTAsXG4gICAgICBDb3JvdXRpbmVDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gUmVtb3ZlZFxuICAgICAgQ29yb3V0aW5lSGFuZGxlclBoYXNlOiAtMSxcbiAgICAgIC8vIFJlbW92ZWRcbiAgICAgIERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudDogMTgsXG4gICAgICAvLyBCZWhpbmQgYSBmbGFnXG4gICAgICBGb3J3YXJkUmVmOiAxMSxcbiAgICAgIEZyYWdtZW50OiA3LFxuICAgICAgRnVuY3Rpb25Db21wb25lbnQ6IDAsXG4gICAgICBIb3N0Q29tcG9uZW50OiA1LFxuICAgICAgSG9zdFBvcnRhbDogNCxcbiAgICAgIEhvc3RSb290OiAzLFxuICAgICAgSG9zdEhvaXN0YWJsZTogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgSG9zdFNpbmdsZXRvbjogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgSG9zdFRleHQ6IDYsXG4gICAgICBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6IDE3LFxuICAgICAgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDogMixcbiAgICAgIExhenlDb21wb25lbnQ6IDE2LFxuICAgICAgTGVnYWN5SGlkZGVuQ29tcG9uZW50OiAtMSxcbiAgICAgIE1lbW9Db21wb25lbnQ6IDE0LFxuICAgICAgTW9kZTogOCxcbiAgICAgIE9mZnNjcmVlbkNvbXBvbmVudDogLTEsXG4gICAgICAvLyBFeHBlcmltZW50YWxcbiAgICAgIFByb2ZpbGVyOiAxMixcbiAgICAgIFNjb3BlQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgU2ltcGxlTWVtb0NvbXBvbmVudDogMTUsXG4gICAgICBTdXNwZW5zZUNvbXBvbmVudDogMTMsXG4gICAgICBTdXNwZW5zZUxpc3RDb21wb25lbnQ6IDE5LFxuICAgICAgLy8gRXhwZXJpbWVudGFsXG4gICAgICBUcmFjaW5nTWFya2VyQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBZaWVsZENvbXBvbmVudDogLTEgLy8gUmVtb3ZlZFxuXG4gICAgfTtcbiAgfSBlbHNlIGlmIChPYmplY3QoYmFja2VuZF91dGlsc1tcImlcIiAvKiBndGUgKi9dKSh2ZXJzaW9uLCAnMTYuNC4zLWFscGhhJykpIHtcbiAgICBSZWFjdFR5cGVPZldvcmsgPSB7XG4gICAgICBDYWNoZUNvbXBvbmVudDogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgQ2xhc3NDb21wb25lbnQ6IDIsXG4gICAgICBDb250ZXh0Q29uc3VtZXI6IDExLFxuICAgICAgQ29udGV4dFByb3ZpZGVyOiAxMixcbiAgICAgIENvcm91dGluZUNvbXBvbmVudDogLTEsXG4gICAgICAvLyBSZW1vdmVkXG4gICAgICBDb3JvdXRpbmVIYW5kbGVyUGhhc2U6IC0xLFxuICAgICAgLy8gUmVtb3ZlZFxuICAgICAgRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBGb3J3YXJkUmVmOiAxMyxcbiAgICAgIEZyYWdtZW50OiA5LFxuICAgICAgRnVuY3Rpb25Db21wb25lbnQ6IDAsXG4gICAgICBIb3N0Q29tcG9uZW50OiA3LFxuICAgICAgSG9zdFBvcnRhbDogNixcbiAgICAgIEhvc3RSb290OiA1LFxuICAgICAgSG9zdEhvaXN0YWJsZTogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgSG9zdFNpbmdsZXRvbjogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgSG9zdFRleHQ6IDgsXG4gICAgICBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6IDQsXG4gICAgICBMYXp5Q29tcG9uZW50OiAtMSxcbiAgICAgIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBMZWdhY3lIaWRkZW5Db21wb25lbnQ6IC0xLFxuICAgICAgTWVtb0NvbXBvbmVudDogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgTW9kZTogMTAsXG4gICAgICBPZmZzY3JlZW5Db21wb25lbnQ6IC0xLFxuICAgICAgLy8gRXhwZXJpbWVudGFsXG4gICAgICBQcm9maWxlcjogMTUsXG4gICAgICBTY29wZUNvbXBvbmVudDogLTEsXG4gICAgICAvLyBFeHBlcmltZW50YWxcbiAgICAgIFNpbXBsZU1lbW9Db21wb25lbnQ6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIFN1c3BlbnNlQ29tcG9uZW50OiAxNixcbiAgICAgIFN1c3BlbnNlTGlzdENvbXBvbmVudDogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgVHJhY2luZ01hcmtlckNvbXBvbmVudDogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgWWllbGRDb21wb25lbnQ6IC0xIC8vIFJlbW92ZWRcblxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgUmVhY3RUeXBlT2ZXb3JrID0ge1xuICAgICAgQ2FjaGVDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIENsYXNzQ29tcG9uZW50OiAyLFxuICAgICAgQ29udGV4dENvbnN1bWVyOiAxMixcbiAgICAgIENvbnRleHRQcm92aWRlcjogMTMsXG4gICAgICBDb3JvdXRpbmVDb21wb25lbnQ6IDcsXG4gICAgICBDb3JvdXRpbmVIYW5kbGVyUGhhc2U6IDgsXG4gICAgICBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIEZvcndhcmRSZWY6IDE0LFxuICAgICAgRnJhZ21lbnQ6IDEwLFxuICAgICAgRnVuY3Rpb25Db21wb25lbnQ6IDEsXG4gICAgICBIb3N0Q29tcG9uZW50OiA1LFxuICAgICAgSG9zdFBvcnRhbDogNCxcbiAgICAgIEhvc3RSb290OiAzLFxuICAgICAgSG9zdEhvaXN0YWJsZTogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgSG9zdFNpbmdsZXRvbjogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgSG9zdFRleHQ6IDYsXG4gICAgICBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6IDAsXG4gICAgICBMYXp5Q29tcG9uZW50OiAtMSxcbiAgICAgIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBMZWdhY3lIaWRkZW5Db21wb25lbnQ6IC0xLFxuICAgICAgTWVtb0NvbXBvbmVudDogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgTW9kZTogMTEsXG4gICAgICBPZmZzY3JlZW5Db21wb25lbnQ6IC0xLFxuICAgICAgLy8gRXhwZXJpbWVudGFsXG4gICAgICBQcm9maWxlcjogMTUsXG4gICAgICBTY29wZUNvbXBvbmVudDogLTEsXG4gICAgICAvLyBFeHBlcmltZW50YWxcbiAgICAgIFNpbXBsZU1lbW9Db21wb25lbnQ6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIFN1c3BlbnNlQ29tcG9uZW50OiAxNixcbiAgICAgIFN1c3BlbnNlTGlzdENvbXBvbmVudDogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgVHJhY2luZ01hcmtlckNvbXBvbmVudDogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgWWllbGRDb21wb25lbnQ6IDlcbiAgICB9O1xuICB9IC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgLy8gRW5kIG9mIGNvcGllZCBjb2RlLlxuICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cblxuICBmdW5jdGlvbiBnZXRUeXBlU3ltYm9sKHR5cGUpIHtcbiAgICB2YXIgc3ltYm9sT3JOdW1iZXIgPSByZW5kZXJlcl90eXBlb2YodHlwZSkgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgPyB0eXBlLiQkdHlwZW9mIDogdHlwZTtcbiAgICByZXR1cm4gcmVuZGVyZXJfdHlwZW9mKHN5bWJvbE9yTnVtYmVyKSA9PT0gJ3N5bWJvbCcgPyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIGB0b1N0cmluZygpYCBkb2Vzbid0IG1hdGNoIHRoZSB0eXBlIHNpZ25hdHVyZT9cbiAgICBzeW1ib2xPck51bWJlci50b1N0cmluZygpIDogc3ltYm9sT3JOdW1iZXI7XG4gIH1cblxuICB2YXIgX1JlYWN0VHlwZU9mV29yayA9IFJlYWN0VHlwZU9mV29yayxcbiAgICAgIENhY2hlQ29tcG9uZW50ID0gX1JlYWN0VHlwZU9mV29yay5DYWNoZUNvbXBvbmVudCxcbiAgICAgIENsYXNzQ29tcG9uZW50ID0gX1JlYWN0VHlwZU9mV29yay5DbGFzc0NvbXBvbmVudCxcbiAgICAgIEluY29tcGxldGVDbGFzc0NvbXBvbmVudCA9IF9SZWFjdFR5cGVPZldvcmsuSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50LFxuICAgICAgRnVuY3Rpb25Db21wb25lbnQgPSBfUmVhY3RUeXBlT2ZXb3JrLkZ1bmN0aW9uQ29tcG9uZW50LFxuICAgICAgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCA9IF9SZWFjdFR5cGVPZldvcmsuSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCxcbiAgICAgIEZvcndhcmRSZWYgPSBfUmVhY3RUeXBlT2ZXb3JrLkZvcndhcmRSZWYsXG4gICAgICBIb3N0Um9vdCA9IF9SZWFjdFR5cGVPZldvcmsuSG9zdFJvb3QsXG4gICAgICBIb3N0SG9pc3RhYmxlID0gX1JlYWN0VHlwZU9mV29yay5Ib3N0SG9pc3RhYmxlLFxuICAgICAgSG9zdFNpbmdsZXRvbiA9IF9SZWFjdFR5cGVPZldvcmsuSG9zdFNpbmdsZXRvbixcbiAgICAgIEhvc3RDb21wb25lbnQgPSBfUmVhY3RUeXBlT2ZXb3JrLkhvc3RDb21wb25lbnQsXG4gICAgICBIb3N0UG9ydGFsID0gX1JlYWN0VHlwZU9mV29yay5Ib3N0UG9ydGFsLFxuICAgICAgSG9zdFRleHQgPSBfUmVhY3RUeXBlT2ZXb3JrLkhvc3RUZXh0LFxuICAgICAgRnJhZ21lbnQgPSBfUmVhY3RUeXBlT2ZXb3JrLkZyYWdtZW50LFxuICAgICAgTGF6eUNvbXBvbmVudCA9IF9SZWFjdFR5cGVPZldvcmsuTGF6eUNvbXBvbmVudCxcbiAgICAgIExlZ2FjeUhpZGRlbkNvbXBvbmVudCA9IF9SZWFjdFR5cGVPZldvcmsuTGVnYWN5SGlkZGVuQ29tcG9uZW50LFxuICAgICAgTWVtb0NvbXBvbmVudCA9IF9SZWFjdFR5cGVPZldvcmsuTWVtb0NvbXBvbmVudCxcbiAgICAgIE9mZnNjcmVlbkNvbXBvbmVudCA9IF9SZWFjdFR5cGVPZldvcmsuT2Zmc2NyZWVuQ29tcG9uZW50LFxuICAgICAgUHJvZmlsZXIgPSBfUmVhY3RUeXBlT2ZXb3JrLlByb2ZpbGVyLFxuICAgICAgU2NvcGVDb21wb25lbnQgPSBfUmVhY3RUeXBlT2ZXb3JrLlNjb3BlQ29tcG9uZW50LFxuICAgICAgU2ltcGxlTWVtb0NvbXBvbmVudCA9IF9SZWFjdFR5cGVPZldvcmsuU2ltcGxlTWVtb0NvbXBvbmVudCxcbiAgICAgIFN1c3BlbnNlQ29tcG9uZW50ID0gX1JlYWN0VHlwZU9mV29yay5TdXNwZW5zZUNvbXBvbmVudCxcbiAgICAgIFN1c3BlbnNlTGlzdENvbXBvbmVudCA9IF9SZWFjdFR5cGVPZldvcmsuU3VzcGVuc2VMaXN0Q29tcG9uZW50LFxuICAgICAgVHJhY2luZ01hcmtlckNvbXBvbmVudCA9IF9SZWFjdFR5cGVPZldvcmsuVHJhY2luZ01hcmtlckNvbXBvbmVudDtcblxuICBmdW5jdGlvbiByZXNvbHZlRmliZXJUeXBlKHR5cGUpIHtcbiAgICB2YXIgdHlwZVN5bWJvbCA9IGdldFR5cGVTeW1ib2wodHlwZSk7XG5cbiAgICBzd2l0Y2ggKHR5cGVTeW1ib2wpIHtcbiAgICAgIGNhc2UgUmVhY3RTeW1ib2xzW1wialwiIC8qIE1FTU9fTlVNQkVSICovXTpcbiAgICAgIGNhc2UgUmVhY3RTeW1ib2xzW1wia1wiIC8qIE1FTU9fU1lNQk9MX1NUUklORyAqL106XG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IHJlc29sdmluZyBtZW1vIHR5cGUgaW4gY2FzZSBvZiBtZW1vKGZvcndhcmRSZWYoQ29tcG9uZW50KSlcbiAgICAgICAgcmV0dXJuIHJlc29sdmVGaWJlclR5cGUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJmXCIgLyogRk9SV0FSRF9SRUZfTlVNQkVSICovXTpcbiAgICAgIGNhc2UgUmVhY3RTeW1ib2xzW1wiZ1wiIC8qIEZPUldBUkRfUkVGX1NZTUJPTF9TVFJJTkcgKi9dOlxuICAgICAgICByZXR1cm4gdHlwZS5yZW5kZXI7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfSAvLyBOT1RJQ0UgS2VlcCBpbiBzeW5jIHdpdGggc2hvdWxkRmlsdGVyRmliZXIoKSBhbmQgb3RoZXIgZ2V0KkZvckZpYmVyIG1ldGhvZHNcblxuXG4gIGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpIHtcbiAgICB2YXIgZWxlbWVudFR5cGUgPSBmaWJlci5lbGVtZW50VHlwZSxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGUsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZztcbiAgICB2YXIgcmVzb2x2ZWRUeXBlID0gdHlwZTtcblxuICAgIGlmIChyZW5kZXJlcl90eXBlb2YodHlwZSkgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGaWJlclR5cGUodHlwZSk7XG4gICAgfVxuXG4gICAgdmFyIHJlc29sdmVkQ29udGV4dCA9IG51bGw7XG5cbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG5cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIE9iamVjdCh1dGlsc1tcImhcIiAvKiBnZXREaXNwbGF5TmFtZSAqL10pKHJlc29sdmVkVHlwZSk7XG5cbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBPYmplY3QodXRpbHNbXCJoXCIgLyogZ2V0RGlzcGxheU5hbWUgKi9dKShyZXNvbHZlZFR5cGUpO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIHJldHVybiBPYmplY3QodXRpbHNbXCJsXCIgLyogZ2V0V3JhcHBlZERpc3BsYXlOYW1lICovXSkoZWxlbWVudFR5cGUsIHJlc29sdmVkVHlwZSwgJ0ZvcndhcmRSZWYnLCAnQW5vbnltb3VzJyk7XG5cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHZhciBmaWJlclJvb3QgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKGZpYmVyUm9vdCAhPSBudWxsICYmIGZpYmVyUm9vdC5fZGVidWdSb290VHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmaWJlclJvb3QuX2RlYnVnUm9vdFR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgICAgY2FzZSBIb3N0SG9pc3RhYmxlOlxuICAgICAgICByZXR1cm4gdHlwZTtcblxuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgICBjYXNlIExhenlDb21wb25lbnQ6XG4gICAgICAgIC8vIFRoaXMgZGlzcGxheSBuYW1lIHdpbGwgbm90IGJlIHVzZXIgdmlzaWJsZS5cbiAgICAgICAgLy8gT25jZSBhIExhenkgY29tcG9uZW50IGxvYWRzIGl0cyBpbm5lciBjb21wb25lbnQsIFJlYWN0IHJlcGxhY2VzIHRoZSB0YWcgYW5kIHR5cGUuXG4gICAgICAgIC8vIFRoaXMgZGlzcGxheSBuYW1lIHdpbGwgb25seSBzaG93IHVwIGluIGNvbnNvbGUgbG9ncyB3aGVuIERldlRvb2xzIERFQlVHIG1vZGUgaXMgb24uXG4gICAgICAgIHJldHVybiAnTGF6eSc7XG5cbiAgICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAgLy8gRGlzcGxheSBuYW1lIGluIFJlYWN0IGRvZXMgbm90IHVzZSBgTWVtb2AgYXMgYSB3cmFwcGVyIGJ1dCBmYWxsYmFjayBuYW1lLlxuICAgICAgICByZXR1cm4gT2JqZWN0KHV0aWxzW1wibFwiIC8qIGdldFdyYXBwZWREaXNwbGF5TmFtZSAqL10pKGVsZW1lbnRUeXBlLCByZXNvbHZlZFR5cGUsICdNZW1vJywgJ0Fub255bW91cycpO1xuXG4gICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICAgIHJldHVybiAnTGVnYWN5SGlkZGVuJztcblxuICAgICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICAgIHJldHVybiAnT2Zmc2NyZWVuJztcblxuICAgICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuICdTY29wZSc7XG5cbiAgICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgICBjYXNlIFRyYWNpbmdNYXJrZXJDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiAnVHJhY2luZ01hcmtlcic7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciB0eXBlU3ltYm9sID0gZ2V0VHlwZVN5bWJvbCh0eXBlKTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGVTeW1ib2wpIHtcbiAgICAgICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcImFcIiAvKiBDT05DVVJSRU5UX01PREVfTlVNQkVSICovXTpcbiAgICAgICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcImJcIiAvKiBDT05DVVJSRU5UX01PREVfU1lNQk9MX1NUUklORyAqL106XG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJlXCIgLyogREVQUkVDQVRFRF9BU1lOQ19NT0RFX1NZTUJPTF9TVFJJTkcgKi9dOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcIm5cIiAvKiBQUk9WSURFUl9OVU1CRVIgKi9dOlxuICAgICAgICAgIGNhc2UgUmVhY3RTeW1ib2xzW1wib1wiIC8qIFBST1ZJREVSX1NZTUJPTF9TVFJJTkcgKi9dOlxuICAgICAgICAgICAgLy8gMTYuMy4wIGV4cG9zZWQgdGhlIGNvbnRleHQgb2JqZWN0IGFzIFwiY29udGV4dFwiXG4gICAgICAgICAgICAvLyBQUiAjMTI1MDEgY2hhbmdlZCBpdCB0byBcIl9jb250ZXh0XCIgZm9yIDE2LjMuMStcbiAgICAgICAgICAgIC8vIE5PVEUgS2VlcCBpbiBzeW5jIHdpdGggaW5zcGVjdEVsZW1lbnRSYXcoKVxuICAgICAgICAgICAgcmVzb2x2ZWRDb250ZXh0ID0gZmliZXIudHlwZS5fY29udGV4dCB8fCBmaWJlci50eXBlLmNvbnRleHQ7XG4gICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQocmVzb2x2ZWRDb250ZXh0LmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0JywgXCIuUHJvdmlkZXJcIik7XG5cbiAgICAgICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcImNcIiAvKiBDT05URVhUX05VTUJFUiAqL106XG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJkXCIgLyogQ09OVEVYVF9TWU1CT0xfU1RSSU5HICovXTpcbiAgICAgICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcInJcIiAvKiBTRVJWRVJfQ09OVEVYVF9TWU1CT0xfU1RSSU5HICovXTpcbiAgICAgICAgICAgIC8vIDE2LjMtMTYuNSByZWFkIGZyb20gXCJ0eXBlXCIgYmVjYXVzZSB0aGUgQ29uc3VtZXIgaXMgdGhlIGFjdHVhbCBjb250ZXh0IG9iamVjdC5cbiAgICAgICAgICAgIC8vIDE2LjYrIHNob3VsZCByZWFkIGZyb20gXCJ0eXBlLl9jb250ZXh0XCIgYmVjYXVzZSBDb25zdW1lciBjYW4gYmUgZGlmZmVyZW50IChpbiBERVYpLlxuICAgICAgICAgICAgLy8gTk9URSBLZWVwIGluIHN5bmMgd2l0aCBpbnNwZWN0RWxlbWVudFJhdygpXG4gICAgICAgICAgICByZXNvbHZlZENvbnRleHQgPSBmaWJlci50eXBlLl9jb250ZXh0IHx8IGZpYmVyLnR5cGU7IC8vIE5PVEU6IFRyYWNlVXBkYXRlc0JhY2tlbmRNYW5hZ2VyIGRlcGVuZHMgb24gdGhlIG5hbWUgZW5kaW5nIGluICcuQ29uc3VtZXInXG4gICAgICAgICAgICAvLyBJZiB5b3UgY2hhbmdlIHRoZSBuYW1lLCBmaWd1cmUgb3V0IGEgbW9yZSByZXNpbGllbnQgd2F5IHRvIGRldGVjdCBpdC5cblxuICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHJlc29sdmVkQ29udGV4dC5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCcsIFwiLkNvbnN1bWVyXCIpO1xuXG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJzXCIgLyogU1RSSUNUX01PREVfTlVNQkVSICovXTpcbiAgICAgICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcInRcIiAvKiBTVFJJQ1RfTU9ERV9TWU1CT0xfU1RSSU5HICovXTpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJsXCIgLyogUFJPRklMRVJfTlVNQkVSICovXTpcbiAgICAgICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcIm1cIiAvKiBQUk9GSUxFUl9TWU1CT0xfU1RSSU5HICovXTpcbiAgICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyKFwiLmNvbmNhdChmaWJlci5tZW1vaXplZFByb3BzLmlkLCBcIilcIik7XG5cbiAgICAgICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcInBcIiAvKiBTQ09QRV9OVU1CRVIgKi9dOlxuICAgICAgICAgIGNhc2UgUmVhY3RTeW1ib2xzW1wicVwiIC8qIFNDT1BFX1NZTUJPTF9TVFJJTkcgKi9dOlxuICAgICAgICAgICAgcmV0dXJuICdTY29wZSc7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gVW5rbm93biBlbGVtZW50IHR5cGUuXG4gICAgICAgICAgICAvLyBUaGlzIG1heSBtZWFuIGEgbmV3IGVsZW1lbnQgdHlwZSB0aGF0IGhhcyBub3QgeWV0IGJlZW4gYWRkZWQgdG8gRGV2VG9vbHMuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnZXREaXNwbGF5TmFtZUZvckZpYmVyOiBnZXREaXNwbGF5TmFtZUZvckZpYmVyLFxuICAgIGdldFR5cGVTeW1ib2w6IGdldFR5cGVTeW1ib2wsXG4gICAgUmVhY3RQcmlvcml0eUxldmVsczogUmVhY3RQcmlvcml0eUxldmVscyxcbiAgICBSZWFjdFR5cGVPZldvcms6IFJlYWN0VHlwZU9mV29yayxcbiAgICBTdHJpY3RNb2RlQml0czogU3RyaWN0TW9kZUJpdHNcbiAgfTtcbn0gLy8gTWFwIG9mIG9uZSBvciBtb3JlIEZpYmVycyBpbiBhIHBhaXIgdG8gdGhlaXIgdW5pcXVlIGlkIG51bWJlci5cbi8vIFdlIHRyYWNrIGJvdGggRmliZXJzIHRvIHN1cHBvcnQgRmFzdCBSZWZyZXNoLFxuLy8gd2hpY2ggbWF5IGZvcmNlZnVsbHkgcmVwbGFjZSBvbmUgb2YgdGhlIHBhaXIgYXMgcGFydCBvZiBob3QgcmVsb2FkaW5nLlxuLy8gSW4gdGhhdCBjYXNlIGl0J3Mgc3RpbGwgaW1wb3J0YW50IHRvIGJlIGFibGUgdG8gbG9jYXRlIHRoZSBwcmV2aW91cyBJRCBkdXJpbmcgc3Vic2VxdWVudCByZW5kZXJzLlxuXG52YXIgZmliZXJUb0lETWFwID0gbmV3IE1hcCgpOyAvLyBNYXAgb2YgaWQgdG8gb25lIChhcmJpdHJhcnkpIEZpYmVyIGluIGEgcGFpci5cbi8vIFRoaXMgTWFwIGlzIHVzZWQgdG8gZS5nLiBnZXQgdGhlIGRpc3BsYXkgbmFtZSBmb3IgYSBGaWJlciBvciBzY2hlZHVsZSBhbiB1cGRhdGUsXG4vLyBvcGVyYXRpb25zIHRoYXQgc2hvdWxkIGJlIHRoZSBzYW1lIHdoZXRoZXIgdGhlIGN1cnJlbnQgYW5kIHdvcmstaW4tcHJvZ3Jlc3MgRmliZXIgaXMgdXNlZC5cblxudmFyIGlkVG9BcmJpdHJhcnlGaWJlck1hcCA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGF0dGFjaChob29rLCByZW5kZXJlcklELCByZW5kZXJlciwgZ2xvYmFsKSB7XG4gIC8vIE5ld2VyIHZlcnNpb25zIG9mIHRoZSByZWNvbmNpbGVyIHBhY2thZ2UgYWxzbyBzcGVjaWZpYyByZWNvbmNpbGVyIHZlcnNpb24uXG4gIC8vIElmIHRoYXQgdmVyc2lvbiBudW1iZXIgaXMgcHJlc2VudCwgdXNlIGl0LlxuICAvLyBUaGlyZCBwYXJ0eSByZW5kZXJlciB2ZXJzaW9ucyBtYXkgbm90IG1hdGNoIHRoZSByZWNvbmNpbGVyIHZlcnNpb24sXG4gIC8vIGFuZCB0aGUgbGF0dGVyIGlzIHdoYXQncyBpbXBvcnRhbnQgaW4gdGVybXMgb2YgdGFncyBhbmQgc3ltYm9scy5cbiAgdmFyIHZlcnNpb24gPSByZW5kZXJlci5yZWNvbmNpbGVyVmVyc2lvbiB8fCByZW5kZXJlci52ZXJzaW9uO1xuXG4gIHZhciBfZ2V0SW50ZXJuYWxSZWFjdENvbnMgPSBnZXRJbnRlcm5hbFJlYWN0Q29uc3RhbnRzKHZlcnNpb24pLFxuICAgICAgZ2V0RGlzcGxheU5hbWVGb3JGaWJlciA9IF9nZXRJbnRlcm5hbFJlYWN0Q29ucy5nZXREaXNwbGF5TmFtZUZvckZpYmVyLFxuICAgICAgZ2V0VHlwZVN5bWJvbCA9IF9nZXRJbnRlcm5hbFJlYWN0Q29ucy5nZXRUeXBlU3ltYm9sLFxuICAgICAgUmVhY3RQcmlvcml0eUxldmVscyA9IF9nZXRJbnRlcm5hbFJlYWN0Q29ucy5SZWFjdFByaW9yaXR5TGV2ZWxzLFxuICAgICAgUmVhY3RUeXBlT2ZXb3JrID0gX2dldEludGVybmFsUmVhY3RDb25zLlJlYWN0VHlwZU9mV29yayxcbiAgICAgIFN0cmljdE1vZGVCaXRzID0gX2dldEludGVybmFsUmVhY3RDb25zLlN0cmljdE1vZGVCaXRzO1xuXG4gIHZhciBDYWNoZUNvbXBvbmVudCA9IFJlYWN0VHlwZU9mV29yay5DYWNoZUNvbXBvbmVudCxcbiAgICAgIENsYXNzQ29tcG9uZW50ID0gUmVhY3RUeXBlT2ZXb3JrLkNsYXNzQ29tcG9uZW50LFxuICAgICAgQ29udGV4dENvbnN1bWVyID0gUmVhY3RUeXBlT2ZXb3JrLkNvbnRleHRDb25zdW1lcixcbiAgICAgIERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudCA9IFJlYWN0VHlwZU9mV29yay5EZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQsXG4gICAgICBGb3J3YXJkUmVmID0gUmVhY3RUeXBlT2ZXb3JrLkZvcndhcmRSZWYsXG4gICAgICBGcmFnbWVudCA9IFJlYWN0VHlwZU9mV29yay5GcmFnbWVudCxcbiAgICAgIEZ1bmN0aW9uQ29tcG9uZW50ID0gUmVhY3RUeXBlT2ZXb3JrLkZ1bmN0aW9uQ29tcG9uZW50LFxuICAgICAgSG9zdFJvb3QgPSBSZWFjdFR5cGVPZldvcmsuSG9zdFJvb3QsXG4gICAgICBIb3N0SG9pc3RhYmxlID0gUmVhY3RUeXBlT2ZXb3JrLkhvc3RIb2lzdGFibGUsXG4gICAgICBIb3N0U2luZ2xldG9uID0gUmVhY3RUeXBlT2ZXb3JrLkhvc3RTaW5nbGV0b24sXG4gICAgICBIb3N0UG9ydGFsID0gUmVhY3RUeXBlT2ZXb3JrLkhvc3RQb3J0YWwsXG4gICAgICBIb3N0Q29tcG9uZW50ID0gUmVhY3RUeXBlT2ZXb3JrLkhvc3RDb21wb25lbnQsXG4gICAgICBIb3N0VGV4dCA9IFJlYWN0VHlwZU9mV29yay5Ib3N0VGV4dCxcbiAgICAgIEluY29tcGxldGVDbGFzc0NvbXBvbmVudCA9IFJlYWN0VHlwZU9mV29yay5JbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQsXG4gICAgICBJbmRldGVybWluYXRlQ29tcG9uZW50ID0gUmVhY3RUeXBlT2ZXb3JrLkluZGV0ZXJtaW5hdGVDb21wb25lbnQsXG4gICAgICBMZWdhY3lIaWRkZW5Db21wb25lbnQgPSBSZWFjdFR5cGVPZldvcmsuTGVnYWN5SGlkZGVuQ29tcG9uZW50LFxuICAgICAgTWVtb0NvbXBvbmVudCA9IFJlYWN0VHlwZU9mV29yay5NZW1vQ29tcG9uZW50LFxuICAgICAgT2Zmc2NyZWVuQ29tcG9uZW50ID0gUmVhY3RUeXBlT2ZXb3JrLk9mZnNjcmVlbkNvbXBvbmVudCxcbiAgICAgIFNpbXBsZU1lbW9Db21wb25lbnQgPSBSZWFjdFR5cGVPZldvcmsuU2ltcGxlTWVtb0NvbXBvbmVudCxcbiAgICAgIFN1c3BlbnNlQ29tcG9uZW50ID0gUmVhY3RUeXBlT2ZXb3JrLlN1c3BlbnNlQ29tcG9uZW50LFxuICAgICAgU3VzcGVuc2VMaXN0Q29tcG9uZW50ID0gUmVhY3RUeXBlT2ZXb3JrLlN1c3BlbnNlTGlzdENvbXBvbmVudCxcbiAgICAgIFRyYWNpbmdNYXJrZXJDb21wb25lbnQgPSBSZWFjdFR5cGVPZldvcmsuVHJhY2luZ01hcmtlckNvbXBvbmVudDtcbiAgdmFyIEltbWVkaWF0ZVByaW9yaXR5ID0gUmVhY3RQcmlvcml0eUxldmVscy5JbW1lZGlhdGVQcmlvcml0eSxcbiAgICAgIFVzZXJCbG9ja2luZ1ByaW9yaXR5ID0gUmVhY3RQcmlvcml0eUxldmVscy5Vc2VyQmxvY2tpbmdQcmlvcml0eSxcbiAgICAgIE5vcm1hbFByaW9yaXR5ID0gUmVhY3RQcmlvcml0eUxldmVscy5Ob3JtYWxQcmlvcml0eSxcbiAgICAgIExvd1ByaW9yaXR5ID0gUmVhY3RQcmlvcml0eUxldmVscy5Mb3dQcmlvcml0eSxcbiAgICAgIElkbGVQcmlvcml0eSA9IFJlYWN0UHJpb3JpdHlMZXZlbHMuSWRsZVByaW9yaXR5LFxuICAgICAgTm9Qcmlvcml0eSA9IFJlYWN0UHJpb3JpdHlMZXZlbHMuTm9Qcmlvcml0eTtcbiAgdmFyIGdldExhbmVMYWJlbE1hcCA9IHJlbmRlcmVyLmdldExhbmVMYWJlbE1hcCxcbiAgICAgIGluamVjdFByb2ZpbGluZ0hvb2tzID0gcmVuZGVyZXIuaW5qZWN0UHJvZmlsaW5nSG9va3MsXG4gICAgICBvdmVycmlkZUhvb2tTdGF0ZSA9IHJlbmRlcmVyLm92ZXJyaWRlSG9va1N0YXRlLFxuICAgICAgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoID0gcmVuZGVyZXIub3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoLFxuICAgICAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gcmVuZGVyZXIub3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoLFxuICAgICAgb3ZlcnJpZGVQcm9wcyA9IHJlbmRlcmVyLm92ZXJyaWRlUHJvcHMsXG4gICAgICBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCA9IHJlbmRlcmVyLm92ZXJyaWRlUHJvcHNEZWxldGVQYXRoLFxuICAgICAgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGggPSByZW5kZXJlci5vdmVycmlkZVByb3BzUmVuYW1lUGF0aCxcbiAgICAgIHNjaGVkdWxlUmVmcmVzaCA9IHJlbmRlcmVyLnNjaGVkdWxlUmVmcmVzaCxcbiAgICAgIHNldEVycm9ySGFuZGxlciA9IHJlbmRlcmVyLnNldEVycm9ySGFuZGxlcixcbiAgICAgIHNldFN1c3BlbnNlSGFuZGxlciA9IHJlbmRlcmVyLnNldFN1c3BlbnNlSGFuZGxlcixcbiAgICAgIHNjaGVkdWxlVXBkYXRlID0gcmVuZGVyZXIuc2NoZWR1bGVVcGRhdGU7XG4gIHZhciBzdXBwb3J0c1RvZ2dsaW5nRXJyb3IgPSB0eXBlb2Ygc2V0RXJyb3JIYW5kbGVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzY2hlZHVsZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgdmFyIHN1cHBvcnRzVG9nZ2xpbmdTdXNwZW5zZSA9IHR5cGVvZiBzZXRTdXNwZW5zZUhhbmRsZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNjaGVkdWxlVXBkYXRlID09PSAnZnVuY3Rpb24nO1xuXG4gIGlmICh0eXBlb2Ygc2NoZWR1bGVSZWZyZXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gV2hlbiBGYXN0IFJlZnJlc2ggdXBkYXRlcyBhIGNvbXBvbmVudCwgdGhlIGZyb250ZW5kIG1heSBuZWVkIHRvIHB1cmdlIGNhY2hlZCBpbmZvcm1hdGlvbi5cbiAgICAvLyBGb3IgZXhhbXBsZSwgQVNUcyBjYWNoZWQgZm9yIHRoZSBjb21wb25lbnQgKGZvciBuYW1lZCBob29rcykgbWF5IG5vIGxvbmdlciBiZSB2YWxpZC5cbiAgICAvLyBTZW5kIGEgc2lnbmFsIHRvIHRoZSBmcm9udGVuZCB0byBwdXJnZSB0aGlzIGNhY2hlZCBpbmZvcm1hdGlvbi5cbiAgICAvLyBUaGUgXCJmYXN0UmVmcmVzaFNjaGVkdWxlZFwiIGRpc3BhdGNoZWQgaXMgZ2xvYmFsIChub3QgRmliZXIgb3IgZXZlbiBSZW5kZXJlciBzcGVjaWZpYykuXG4gICAgLy8gVGhpcyBpcyBsZXNzIGVmZmVjaWVudCBzaW5jZSBpdCBtZWFucyB0aGUgZnJvbnQtZW5kIHdpbGwgbmVlZCB0byBwdXJnZSB0aGUgZW50aXJlIGNhY2hlLFxuICAgIC8vIGJ1dCB0aGlzIGlzIHByb2JhYmx5IGFuIG9rYXkgdHJhZGUgb2ZmIGluIG9yZGVyIHRvIHJlZHVjZSBjb3VwbGluZyBiZXR3ZWVuIHRoZSBEZXZUb29scyBhbmQgRmFzdCBSZWZyZXNoLlxuICAgIHJlbmRlcmVyLnNjaGVkdWxlUmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhvb2suZW1pdCgnZmFzdFJlZnJlc2hTY2hlZHVsZWQnKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHJldHVybiBzY2hlZHVsZVJlZnJlc2guYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgZ2V0VGltZWxpbmVEYXRhID0gbnVsbDtcbiAgdmFyIHRvZ2dsZVByb2ZpbGluZ1N0YXR1cyA9IG51bGw7XG5cbiAgaWYgKHR5cGVvZiBpbmplY3RQcm9maWxpbmdIb29rcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciByZXNwb25zZSA9IGNyZWF0ZVByb2ZpbGluZ0hvb2tzKHtcbiAgICAgIGdldERpc3BsYXlOYW1lRm9yRmliZXI6IGdldERpc3BsYXlOYW1lRm9yRmliZXIsXG4gICAgICBnZXRJc1Byb2ZpbGluZzogZnVuY3Rpb24gZ2V0SXNQcm9maWxpbmcoKSB7XG4gICAgICAgIHJldHVybiBpc1Byb2ZpbGluZztcbiAgICAgIH0sXG4gICAgICBnZXRMYW5lTGFiZWxNYXA6IGdldExhbmVMYWJlbE1hcCxcbiAgICAgIGN1cnJlbnREaXNwYXRjaGVyUmVmOiByZW5kZXJlci5jdXJyZW50RGlzcGF0Y2hlclJlZixcbiAgICAgIHdvcmtUYWdNYXA6IFJlYWN0VHlwZU9mV29yayxcbiAgICAgIHJlYWN0VmVyc2lvbjogdmVyc2lvblxuICAgIH0pOyAvLyBQYXNzIHRoZSBQcm9maWxpbmcgaG9va3MgdG8gdGhlIHJlY29uY2lsZXIgZm9yIGl0IHRvIGNhbGwgZHVyaW5nIHJlbmRlci5cblxuICAgIGluamVjdFByb2ZpbGluZ0hvb2tzKHJlc3BvbnNlLnByb2ZpbGluZ0hvb2tzKTsgLy8gSGFuZyBvbnRvIHRoaXMgdG9nZ2xlIHNvIHdlIGNhbiBub3RpZnkgdGhlIGV4dGVybmFsIG1ldGhvZHMgb2YgcHJvZmlsaW5nIHN0YXR1cyBjaGFuZ2VzLlxuXG4gICAgZ2V0VGltZWxpbmVEYXRhID0gcmVzcG9uc2UuZ2V0VGltZWxpbmVEYXRhO1xuICAgIHRvZ2dsZVByb2ZpbGluZ1N0YXR1cyA9IHJlc3BvbnNlLnRvZ2dsZVByb2ZpbGluZ1N0YXR1cztcbiAgfSAvLyBUcmFja3MgRmliZXJzIHdpdGggcmVjZW50bHkgY2hhbmdlZCBudW1iZXIgb2YgZXJyb3Ivd2FybmluZyBtZXNzYWdlcy5cbiAgLy8gVGhlc2UgY29sbGVjdGlvbnMgc3RvcmUgdGhlIEZpYmVyIHJhdGhlciB0aGFuIHRoZSBJRCxcbiAgLy8gaW4gb3JkZXIgdG8gYXZvaWQgZ2VuZXJhdGluZyBhbiBJRCBmb3IgRmliZXJzIHRoYXQgbmV2ZXIgZ2V0IG1vdW50ZWRcbiAgLy8gKGR1ZSB0byBlLmcuIFN1c3BlbnNlIG9yIGVycm9yIGJvdW5kYXJpZXMpLlxuICAvLyBvbkVycm9yT3JXYXJuaW5nKCkgYWRkcyBGaWJlcnMgYW5kIHJlY29yZFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5ncygpIGxhdGVyIGNsZWFycyB0aGVtLlxuXG5cbiAgdmFyIGZpYmVyc1dpdGhDaGFuZ2VkRXJyb3JPcldhcm5pbmdDb3VudHMgPSBuZXcgU2V0KCk7XG4gIHZhciBwZW5kaW5nRmliZXJUb0Vycm9yc01hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIHBlbmRpbmdGaWJlclRvV2FybmluZ3NNYXAgPSBuZXcgTWFwKCk7IC8vIE1hcHBpbmcgb2YgZmliZXIgSURzIHRvIGVycm9yL3dhcm5pbmcgbWVzc2FnZXMgYW5kIGNvdW50cy5cblxuICB2YXIgZmliZXJJRFRvRXJyb3JzTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgZmliZXJJRFRvV2FybmluZ3NNYXAgPSBuZXcgTWFwKCk7XG5cbiAgZnVuY3Rpb24gY2xlYXJFcnJvcnNBbmRXYXJuaW5ncygpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZm9yLW9mLWxvb3BzL25vLWZvci1vZi1sb29wc1xuICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihmaWJlcklEVG9FcnJvcnNNYXAua2V5cygpKSxcbiAgICAgICAgX3N0ZXA7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGlkID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgdmFyIF9maWJlciA9IGlkVG9BcmJpdHJhcnlGaWJlck1hcC5nZXQoaWQpO1xuXG4gICAgICAgIGlmIChfZmliZXIgIT0gbnVsbCkge1xuICAgICAgICAgIGZpYmVyc1dpdGhDaGFuZ2VkRXJyb3JPcldhcm5pbmdDb3VudHMuYWRkKF9maWJlcik7XG4gICAgICAgICAgdXBkYXRlTW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudElmTmVjZXNzYXJ5KGlkKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZm9yLW9mLWxvb3BzL25vLWZvci1vZi1sb29wc1xuXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IuZigpO1xuICAgIH1cblxuICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZmliZXJJRFRvV2FybmluZ3NNYXAua2V5cygpKSxcbiAgICAgICAgX3N0ZXAyO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfaWQgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgdmFyIF9maWJlcjIgPSBpZFRvQXJiaXRyYXJ5RmliZXJNYXAuZ2V0KF9pZCk7XG5cbiAgICAgICAgaWYgKF9maWJlcjIgIT0gbnVsbCkge1xuICAgICAgICAgIGZpYmVyc1dpdGhDaGFuZ2VkRXJyb3JPcldhcm5pbmdDb3VudHMuYWRkKF9maWJlcjIpO1xuICAgICAgICAgIHVwZGF0ZU1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnRJZk5lY2Vzc2FyeShfaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgfVxuXG4gICAgZmliZXJJRFRvRXJyb3JzTWFwLmNsZWFyKCk7XG4gICAgZmliZXJJRFRvV2FybmluZ3NNYXAuY2xlYXIoKTtcbiAgICBmbHVzaFBlbmRpbmdFdmVudHMoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyTWVzc2FnZUNvdW50SGVscGVyKGZpYmVySUQsIHBlbmRpbmdGaWJlclRvTWVzc2FnZUNvdW50TWFwLCBmaWJlcklEVG9NZXNzYWdlQ291bnRNYXApIHtcbiAgICB2YXIgZmliZXIgPSBpZFRvQXJiaXRyYXJ5RmliZXJNYXAuZ2V0KGZpYmVySUQpO1xuXG4gICAgaWYgKGZpYmVyICE9IG51bGwpIHtcbiAgICAgIC8vIFRocm93IG91dCBhbnkgcGVuZGluZyBjaGFuZ2VzLlxuICAgICAgcGVuZGluZ0ZpYmVyVG9FcnJvcnNNYXAuZGVsZXRlKGZpYmVyKTtcblxuICAgICAgaWYgKGZpYmVySURUb01lc3NhZ2VDb3VudE1hcC5oYXMoZmliZXJJRCkpIHtcbiAgICAgICAgZmliZXJJRFRvTWVzc2FnZUNvdW50TWFwLmRlbGV0ZShmaWJlcklEKTsgLy8gSWYgcHJldmlvdXMgZmx1c2hlZCBjb3VudHMgaGF2ZSBjaGFuZ2VkLCBzY2hlZHVsZSBhbiB1cGRhdGUgdG9vLlxuXG4gICAgICAgIGZpYmVyc1dpdGhDaGFuZ2VkRXJyb3JPcldhcm5pbmdDb3VudHMuYWRkKGZpYmVyKTtcbiAgICAgICAgZmx1c2hQZW5kaW5nRXZlbnRzKCk7XG4gICAgICAgIHVwZGF0ZU1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnRJZk5lY2Vzc2FyeShmaWJlcklEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpYmVyc1dpdGhDaGFuZ2VkRXJyb3JPcldhcm5pbmdDb3VudHMuZGVsZXRlKGZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckVycm9yc0ZvckZpYmVySUQoZmliZXJJRCkge1xuICAgIGNsZWFyTWVzc2FnZUNvdW50SGVscGVyKGZpYmVySUQsIHBlbmRpbmdGaWJlclRvRXJyb3JzTWFwLCBmaWJlcklEVG9FcnJvcnNNYXApO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJXYXJuaW5nc0ZvckZpYmVySUQoZmliZXJJRCkge1xuICAgIGNsZWFyTWVzc2FnZUNvdW50SGVscGVyKGZpYmVySUQsIHBlbmRpbmdGaWJlclRvV2FybmluZ3NNYXAsIGZpYmVySURUb1dhcm5pbmdzTWFwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZU1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnRJZk5lY2Vzc2FyeShmaWJlcklEKSB7XG4gICAgaWYgKG1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQgIT09IG51bGwgJiYgbW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudC5pZCA9PT0gZmliZXJJRCkge1xuICAgICAgaGFzRWxlbWVudFVwZGF0ZWRTaW5jZUxhc3RJbnNwZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSAvLyBDYWxsZWQgd2hlbiBhbiBlcnJvciBvciB3YXJuaW5nIGlzIGxvZ2dlZCBkdXJpbmcgcmVuZGVyLCBjb21taXQsIG9yIHBhc3NpdmUgKGluY2x1ZGluZyB1bm1vdW50IGZ1bmN0aW9ucykuXG5cblxuICBmdW5jdGlvbiBvbkVycm9yT3JXYXJuaW5nKGZpYmVyLCB0eXBlLCBhcmdzKSB7XG4gICAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIHZhciBtYXliZUlEID0gZ2V0RmliZXJJRFVuc2FmZShmaWJlcik7IC8vIGlmIHRoaXMgaXMgYW4gZXJyb3Igc2ltdWxhdGVkIGJ5IHVzIHRvIHRyaWdnZXIgZXJyb3IgYm91bmRhcnksIGlnbm9yZVxuXG4gICAgICBpZiAobWF5YmVJRCAhPSBudWxsICYmIGZvcmNlRXJyb3JGb3JGaWJlcklEcy5nZXQobWF5YmVJRCkgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtZXNzYWdlID0gYmFja2VuZF91dGlsc1tcImVcIiAvKiBmb3JtYXQgKi9dLmFwcGx5KHZvaWQgMCwgX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKTtcblxuICAgIGlmIChjb25zdGFudHNbXCJzXCIgLyogX19ERUJVR19fICovXSkge1xuICAgICAgZGVidWcoJ29uRXJyb3JPcldhcm5pbmcnLCBmaWJlciwgbnVsbCwgXCJcIi5jb25jYXQodHlwZSwgXCI6IFxcXCJcIikuY29uY2F0KG1lc3NhZ2UsIFwiXFxcIlwiKSk7XG4gICAgfSAvLyBNYXJrIHRoaXMgRmliZXIgYXMgbmVlZGVkIGl0cyB3YXJuaW5nL2Vycm9yIGNvdW50IHVwZGF0ZWQgZHVyaW5nIHRoZSBuZXh0IGZsdXNoLlxuXG5cbiAgICBmaWJlcnNXaXRoQ2hhbmdlZEVycm9yT3JXYXJuaW5nQ291bnRzLmFkZChmaWJlcik7IC8vIFRyYWNrIHRoZSB3YXJuaW5nL2Vycm9yIGZvciBsYXRlci5cblxuICAgIHZhciBmaWJlck1hcCA9IHR5cGUgPT09ICdlcnJvcicgPyBwZW5kaW5nRmliZXJUb0Vycm9yc01hcCA6IHBlbmRpbmdGaWJlclRvV2FybmluZ3NNYXA7XG4gICAgdmFyIG1lc3NhZ2VNYXAgPSBmaWJlck1hcC5nZXQoZmliZXIpO1xuXG4gICAgaWYgKG1lc3NhZ2VNYXAgIT0gbnVsbCkge1xuICAgICAgdmFyIGNvdW50ID0gbWVzc2FnZU1hcC5nZXQobWVzc2FnZSkgfHwgMDtcbiAgICAgIG1lc3NhZ2VNYXAuc2V0KG1lc3NhZ2UsIGNvdW50ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpYmVyTWFwLnNldChmaWJlciwgbmV3IE1hcChbW21lc3NhZ2UsIDFdXSkpO1xuICAgIH0gLy8gUGFzc2l2ZSBlZmZlY3RzIG1heSB0cmlnZ2VyIGVycm9ycyBvciB3YXJuaW5ncyB0b287XG4gICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBzaG91bGQgd2FpdCB1bnRpbCB0aGUgcmVzdCBvZiB0aGUgcGFzc2l2ZSBlZmZlY3RzIGhhdmUgcnVuLFxuICAgIC8vIGJ1dCB3ZSBzaG91bGRuJ3Qgd2FpdCB1bnRpbCB0aGUgbmV4dCBjb21taXQgYmVjYXVzZSB0aGF0IG1pZ2h0IGJlIGEgbG9uZyB0aW1lLlxuICAgIC8vIFRoaXMgd291bGQgYWxzbyBjYXVzZSBcInRlYXJpbmdcIiBiZXR3ZWVuIGFuIGluc3BlY3RlZCBDb21wb25lbnQgYW5kIHRoZSB0cmVlIHZpZXcuXG4gICAgLy8gVGhlbiBhZ2FpbiB3ZSBkb24ndCB3YW50IHRvIGZsdXNoIHRvbyBzb29uIGJlY2F1c2UgdGhpcyBjb3VsZCBiZSBhbiBlcnJvciBkdXJpbmcgYXN5bmMgcmVuZGVyaW5nLlxuICAgIC8vIFVzZSBhIGRlYm91bmNlIHRlY2huaXF1ZSB0byBlbnN1cmUgdGhhdCB3ZSdsbCBldmVudHVhbGx5IGZsdXNoLlxuXG5cbiAgICBmbHVzaFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5nc0FmdGVyRGVsYXkoKTtcbiAgfSAvLyBQYXRjaGluZyB0aGUgY29uc29sZSBlbmFibGVzIERldlRvb2xzIHRvIGRvIGEgZmV3IHVzZWZ1bCB0aGluZ3M6XG4gIC8vICogQXBwZW5kIGNvbXBvbmVudCBzdGFja3MgdG8gd2FybmluZ3MgYW5kIGVycm9yIG1lc3NhZ2VzXG4gIC8vICogRGlzYWJsZSBsb2dnaW5nIGR1cmluZyByZS1yZW5kZXJzIHRvIGluc3BlY3QgaG9va3MgKHNlZSBpbnNwZWN0SG9va3NPZkZpYmVyKVxuXG5cbiAgT2JqZWN0KGJhY2tlbmRfY29uc29sZVtcImVcIiAvKiByZWdpc3RlclJlbmRlcmVyICovXSkocmVuZGVyZXIsIG9uRXJyb3JPcldhcm5pbmcpOyAvLyBUaGUgcmVuZGVyZXIgaW50ZXJmYWNlIGNhbid0IHJlYWQgdGhlc2UgcHJlZmVyZW5jZXMgZGlyZWN0bHksXG4gIC8vIGJlY2F1c2UgaXQgaXMgc3RvcmVkIGluIGxvY2FsU3RvcmFnZSB3aXRoaW4gdGhlIGNvbnRleHQgb2YgdGhlIGV4dGVuc2lvbi5cbiAgLy8gSXQgcmVsaWVzIG9uIHRoZSBleHRlbnNpb24gdG8gcGFzcyB0aGUgcHJlZmVyZW5jZSB0aHJvdWdoIHZpYSB0aGUgZ2xvYmFsLlxuXG4gIE9iamVjdChiYWNrZW5kX2NvbnNvbGVbXCJjXCIgLyogcGF0Y2hDb25zb2xlVXNpbmdXaW5kb3dWYWx1ZXMgKi9dKSgpO1xuXG4gIHZhciBkZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKG5hbWUsIGZpYmVyLCBwYXJlbnRGaWJlcikge1xuICAgIHZhciBleHRyYVN0cmluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogJyc7XG5cbiAgICBpZiAoY29uc3RhbnRzW1wic1wiIC8qIF9fREVCVUdfXyAqL10pIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IGZpYmVyLnRhZyArICc6JyArIChnZXREaXNwbGF5TmFtZUZvckZpYmVyKGZpYmVyKSB8fCAnbnVsbCcpO1xuICAgICAgdmFyIG1heWJlSUQgPSBnZXRGaWJlcklEVW5zYWZlKGZpYmVyKSB8fCAnPG5vIGlkPic7XG4gICAgICB2YXIgcGFyZW50RGlzcGxheU5hbWUgPSBwYXJlbnRGaWJlciA/IHBhcmVudEZpYmVyLnRhZyArICc6JyArIChnZXREaXNwbGF5TmFtZUZvckZpYmVyKHBhcmVudEZpYmVyKSB8fCAnbnVsbCcpIDogJyc7XG4gICAgICB2YXIgbWF5YmVQYXJlbnRJRCA9IHBhcmVudEZpYmVyID8gZ2V0RmliZXJJRFVuc2FmZShwYXJlbnRGaWJlcikgfHwgJzxuby1pZD4nIDogJyc7XG4gICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKFwiW3JlbmRlcmVyXSAlY1wiLmNvbmNhdChuYW1lLCBcIiAlY1wiKS5jb25jYXQoZGlzcGxheU5hbWUsIFwiIChcIikuY29uY2F0KG1heWJlSUQsIFwiKSAlY1wiKS5jb25jYXQocGFyZW50RmliZXIgPyBcIlwiLmNvbmNhdChwYXJlbnREaXNwbGF5TmFtZSwgXCIgKFwiKS5jb25jYXQobWF5YmVQYXJlbnRJRCwgXCIpXCIpIDogJycsIFwiICVjXCIpLmNvbmNhdChleHRyYVN0cmluZyksICdjb2xvcjogcmVkOyBmb250LXdlaWdodDogYm9sZDsnLCAnY29sb3I6IGJsdWU7JywgJ2NvbG9yOiBwdXJwbGU7JywgJ2NvbG9yOiBibGFjazsnKTtcbiAgICAgIGNvbnNvbGUubG9nKG5ldyBFcnJvcigpLnN0YWNrLnNwbGl0KCdcXG4nKS5zbGljZSgxKS5qb2luKCdcXG4nKSk7XG4gICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgfVxuICB9OyAvLyBDb25maWd1cmFibGUgQ29tcG9uZW50cyB0cmVlIGZpbHRlcnMuXG5cblxuICB2YXIgaGlkZUVsZW1lbnRzV2l0aERpc3BsYXlOYW1lcyA9IG5ldyBTZXQoKTtcbiAgdmFyIGhpZGVFbGVtZW50c1dpdGhQYXRocyA9IG5ldyBTZXQoKTtcbiAgdmFyIGhpZGVFbGVtZW50c1dpdGhUeXBlcyA9IG5ldyBTZXQoKTsgLy8gSGlnaGxpZ2h0IHVwZGF0ZXNcblxuICB2YXIgdHJhY2VVcGRhdGVzRW5hYmxlZCA9IGZhbHNlO1xuICB2YXIgdHJhY2VVcGRhdGVzRm9yTm9kZXMgPSBuZXcgU2V0KCk7XG5cbiAgZnVuY3Rpb24gYXBwbHlDb21wb25lbnRGaWx0ZXJzKGNvbXBvbmVudEZpbHRlcnMpIHtcbiAgICBoaWRlRWxlbWVudHNXaXRoVHlwZXMuY2xlYXIoKTtcbiAgICBoaWRlRWxlbWVudHNXaXRoRGlzcGxheU5hbWVzLmNsZWFyKCk7XG4gICAgaGlkZUVsZW1lbnRzV2l0aFBhdGhzLmNsZWFyKCk7XG4gICAgY29tcG9uZW50RmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnRGaWx0ZXIpIHtcbiAgICAgIGlmICghY29tcG9uZW50RmlsdGVyLmlzRW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoY29tcG9uZW50RmlsdGVyLnR5cGUpIHtcbiAgICAgICAgY2FzZSB0eXBlc1tcImFcIiAvKiBDb21wb25lbnRGaWx0ZXJEaXNwbGF5TmFtZSAqL106XG4gICAgICAgICAgaWYgKGNvbXBvbmVudEZpbHRlci5pc1ZhbGlkICYmIGNvbXBvbmVudEZpbHRlci52YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgIGhpZGVFbGVtZW50c1dpdGhEaXNwbGF5TmFtZXMuYWRkKG5ldyBSZWdFeHAoY29tcG9uZW50RmlsdGVyLnZhbHVlLCAnaScpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIHR5cGVzW1wiYlwiIC8qIENvbXBvbmVudEZpbHRlckVsZW1lbnRUeXBlICovXTpcbiAgICAgICAgICBoaWRlRWxlbWVudHNXaXRoVHlwZXMuYWRkKGNvbXBvbmVudEZpbHRlci52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSB0eXBlc1tcImRcIiAvKiBDb21wb25lbnRGaWx0ZXJMb2NhdGlvbiAqL106XG4gICAgICAgICAgaWYgKGNvbXBvbmVudEZpbHRlci5pc1ZhbGlkICYmIGNvbXBvbmVudEZpbHRlci52YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgIGhpZGVFbGVtZW50c1dpdGhQYXRocy5hZGQobmV3IFJlZ0V4cChjb21wb25lbnRGaWx0ZXIudmFsdWUsICdpJykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgdHlwZXNbXCJjXCIgLyogQ29tcG9uZW50RmlsdGVySE9DICovXTpcbiAgICAgICAgICBoaWRlRWxlbWVudHNXaXRoRGlzcGxheU5hbWVzLmFkZChuZXcgUmVnRXhwKCdcXFxcKCcpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgY29tcG9uZW50IGZpbHRlciB0eXBlIFxcXCJcIi5jb25jYXQoY29tcG9uZW50RmlsdGVyLnR5cGUsIFwiXFxcIlwiKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gLy8gVGhlIHJlbmRlcmVyIGludGVyZmFjZSBjYW4ndCByZWFkIHNhdmVkIGNvbXBvbmVudCBmaWx0ZXJzIGRpcmVjdGx5LFxuICAvLyBiZWNhdXNlIHRoZXkgYXJlIHN0b3JlZCBpbiBsb2NhbFN0b3JhZ2Ugd2l0aGluIHRoZSBjb250ZXh0IG9mIHRoZSBleHRlbnNpb24uXG4gIC8vIEluc3RlYWQgaXQgcmVsaWVzIG9uIHRoZSBleHRlbnNpb24gdG8gcGFzcyBmaWx0ZXJzIHRocm91Z2guXG5cblxuICBpZiAod2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfQ09NUE9ORU5UX0ZJTFRFUlNfXyAhPSBudWxsKSB7XG4gICAgYXBwbHlDb21wb25lbnRGaWx0ZXJzKHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0NPTVBPTkVOVF9GSUxURVJTX18pO1xuICB9IGVsc2Uge1xuICAgIC8vIFVuZm9ydHVuYXRlbHkgdGhpcyBmZWF0dXJlIGlzIG5vdCBleHBlY3RlZCB0byB3b3JrIGZvciBSZWFjdCBOYXRpdmUgZm9yIG5vdy5cbiAgICAvLyBJdCB3b3VsZCBiZSBhbm5veWluZyBmb3IgdXMgdG8gc3BhbSBZZWxsb3dCb3ggd2FybmluZ3Mgd2l0aCB1bmFjdGlvbmFibGUgc3R1ZmYsXG4gICAgLy8gc28gZm9yIG5vdyBqdXN0IHNraXAgdGhpcyBtZXNzYWdlLi4uXG4gICAgLy9jb25zb2xlLndhcm4oJ+Kam++4jyBEZXZUb29sczogQ291bGQgbm90IGxvY2F0ZSBzYXZlZCBjb21wb25lbnQgZmlsdGVycycpO1xuICAgIC8vIEZhbGxiYWNrIHRvIGFzc3VtaW5nIHRoZSBkZWZhdWx0IGZpbHRlcnMgaW4gdGhpcyBjYXNlLlxuICAgIGFwcGx5Q29tcG9uZW50RmlsdGVycyhPYmplY3QodXRpbHNbXCJnXCIgLyogZ2V0RGVmYXVsdENvbXBvbmVudEZpbHRlcnMgKi9dKSgpKTtcbiAgfSAvLyBJZiBuZWNlc3NhcnksIHdlIGNhbiByZXZpc2l0IG9wdGltaXppbmcgdGhpcyBvcGVyYXRpb24uXG4gIC8vIEZvciBleGFtcGxlLCB3ZSBjb3VsZCBhZGQgYSBuZXcgcmVjdXJzaXZlIHVubW91bnQgdHJlZSBvcGVyYXRpb24uXG4gIC8vIFRoZSB1bm1vdW50IG9wZXJhdGlvbnMgYXJlIGFscmVhZHkgc2lnbmlmaWNhbnRseSBzbWFsbGVyIHRoYW4gbW91bnQgb3BlcmF0aW9ucyB0aG91Z2guXG4gIC8vIFRoaXMgaXMgc29tZXRoaW5nIHRvIGtlZXAgaW4gbWluZCBmb3IgbGF0ZXIuXG5cblxuICBmdW5jdGlvbiB1cGRhdGVDb21wb25lbnRGaWx0ZXJzKGNvbXBvbmVudEZpbHRlcnMpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIC8vIFJlLW1vdW50aW5nIGEgdHJlZSB3aGlsZSBwcm9maWxpbmcgaXMgaW4gcHJvZ3Jlc3MgbWlnaHQgYnJlYWsgYSBsb3Qgb2YgYXNzdW1wdGlvbnMuXG4gICAgICAvLyBJZiBuZWNlc3NhcnksIHdlIGNvdWxkIHN1cHBvcnQgdGhpcy0gYnV0IGl0IGRvZXNuJ3Qgc2VlbSBsaWtlIGEgbmVjZXNzYXJ5IHVzZSBjYXNlLlxuICAgICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBtb2RpZnkgZmlsdGVyIHByZWZlcmVuY2VzIHdoaWxlIHByb2ZpbGluZycpO1xuICAgIH0gLy8gUmVjdXJzaXZlbHkgdW5tb3VudCBhbGwgcm9vdHMuXG5cblxuICAgIGhvb2suZ2V0RmliZXJSb290cyhyZW5kZXJlcklEKS5mb3JFYWNoKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICBjdXJyZW50Um9vdElEID0gZ2V0T3JHZW5lcmF0ZUZpYmVySUQocm9vdC5jdXJyZW50KTsgLy8gVGhlIFRSRUVfT1BFUkFUSU9OX1JFTU9WRV9ST09UIG9wZXJhdGlvbiBzZXJ2ZXMgdHdvIHB1cnBvc2VzOlxuICAgICAgLy8gMS4gSXQgYXZvaWRzIHNlbmRpbmcgdW5uZWNlc3NhcnkgYnJpZGdlIHRyYWZmaWMgdG8gY2xlYXIgYSByb290LlxuICAgICAgLy8gMi4gSXQgcHJlc2VydmVzIEZpYmVyIElEcyB3aGVuIHJlbW91bnRpbmcgKGJlbG93KSB3aGljaCBpbiB0dXJuIElEIHRvIGVycm9yL3dhcm5pbmcgbWFwcGluZy5cblxuICAgICAgcHVzaE9wZXJhdGlvbihjb25zdGFudHNbXCJuXCIgLyogVFJFRV9PUEVSQVRJT05fUkVNT1ZFX1JPT1QgKi9dKTtcbiAgICAgIGZsdXNoUGVuZGluZ0V2ZW50cyhyb290KTtcbiAgICAgIGN1cnJlbnRSb290SUQgPSAtMTtcbiAgICB9KTtcbiAgICBhcHBseUNvbXBvbmVudEZpbHRlcnMoY29tcG9uZW50RmlsdGVycyk7IC8vIFJlc2V0IHBzZXVkbyBjb3VudGVycyBzbyB0aGF0IG5ldyBwYXRoIHNlbGVjdGlvbnMgd2lsbCBiZSBwZXJzaXN0ZWQuXG5cbiAgICByb290RGlzcGxheU5hbWVDb3VudGVyLmNsZWFyKCk7IC8vIFJlY3Vyc2l2ZWx5IHJlLW1vdW50IGFsbCByb290cyB3aXRoIG5ldyBmaWx0ZXIgY3JpdGVyaWEgYXBwbGllZC5cblxuICAgIGhvb2suZ2V0RmliZXJSb290cyhyZW5kZXJlcklEKS5mb3JFYWNoKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICBjdXJyZW50Um9vdElEID0gZ2V0T3JHZW5lcmF0ZUZpYmVySUQocm9vdC5jdXJyZW50KTtcbiAgICAgIHNldFJvb3RQc2V1ZG9LZXkoY3VycmVudFJvb3RJRCwgcm9vdC5jdXJyZW50KTtcbiAgICAgIG1vdW50RmliZXJSZWN1cnNpdmVseShyb290LmN1cnJlbnQsIG51bGwsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBmbHVzaFBlbmRpbmdFdmVudHMocm9vdCk7XG4gICAgICBjdXJyZW50Um9vdElEID0gLTE7XG4gICAgfSk7IC8vIEFsc28gcmUtZXZhbHVhdGUgYWxsIGVycm9yIGFuZCB3YXJuaW5nIGNvdW50cyBnaXZlbiB0aGUgbmV3IGZpbHRlcnMuXG5cbiAgICByZWV2YWx1YXRlRXJyb3JzQW5kV2FybmluZ3MoKTtcbiAgICBmbHVzaFBlbmRpbmdFdmVudHMoKTtcbiAgfSAvLyBOT1RJQ0UgS2VlcCBpbiBzeW5jIHdpdGggZ2V0KkZvckZpYmVyIG1ldGhvZHNcblxuXG4gIGZ1bmN0aW9uIHNob3VsZEZpbHRlckZpYmVyKGZpYmVyKSB7XG4gICAgdmFyIF9kZWJ1Z1NvdXJjZSA9IGZpYmVyLl9kZWJ1Z1NvdXJjZSxcbiAgICAgICAgdGFnID0gZmliZXIudGFnLFxuICAgICAgICB0eXBlID0gZmliZXIudHlwZSxcbiAgICAgICAga2V5ID0gZmliZXIua2V5O1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICAvLyBUT0RPOiBpZGVhbGx5IHdlIHdvdWxkIHNob3cgZGVoeWRyYXRlZCBTdXNwZW5zZSBpbW1lZGlhdGVseS5cbiAgICAgICAgLy8gSG93ZXZlciwgaXQgaGFzIHNvbWUgc3BlY2lhbCBiZWhhdmlvciAobGlrZSBkaXNjb25uZWN0aW5nXG4gICAgICAgIC8vIGFuIGFsdGVybmF0ZSBhbmQgdHVybmluZyBpbnRvIHJlYWwgU3VzcGVuc2UpIHdoaWNoIGJyZWFrcyBEZXZUb29scy5cbiAgICAgICAgLy8gRm9yIG5vdywgaWdub3JlIGl0LCBhbmQgb25seSBzaG93IGl0IG9uY2UgaXQgZ2V0cyBoeWRyYXRlZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2J2YXVnaG4vcmVhY3QtZGV2dG9vbHMtZXhwZXJpbWVudGFsL2lzc3Vlcy8xOTdcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgLy8gSXQgaXMgbmV2ZXIgdmFsaWQgdG8gZmlsdGVyIHRoZSByb290IGVsZW1lbnQuXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgY2FzZSBGcmFnbWVudDpcbiAgICAgICAgcmV0dXJuIGtleSA9PT0gbnVsbDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIHR5cGVTeW1ib2wgPSBnZXRUeXBlU3ltYm9sKHR5cGUpO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZVN5bWJvbCkge1xuICAgICAgICAgIGNhc2UgUmVhY3RTeW1ib2xzW1wiYVwiIC8qIENPTkNVUlJFTlRfTU9ERV9OVU1CRVIgKi9dOlxuICAgICAgICAgIGNhc2UgUmVhY3RTeW1ib2xzW1wiYlwiIC8qIENPTkNVUlJFTlRfTU9ERV9TWU1CT0xfU1RSSU5HICovXTpcbiAgICAgICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcImVcIiAvKiBERVBSRUNBVEVEX0FTWU5DX01PREVfU1lNQk9MX1NUUklORyAqL106XG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJzXCIgLyogU1RSSUNUX01PREVfTlVNQkVSICovXTpcbiAgICAgICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcInRcIiAvKiBTVFJJQ1RfTU9ERV9TWU1CT0xfU1RSSU5HICovXTpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudFR5cGUgPSBnZXRFbGVtZW50VHlwZUZvckZpYmVyKGZpYmVyKTtcblxuICAgIGlmIChoaWRlRWxlbWVudHNXaXRoVHlwZXMuaGFzKGVsZW1lbnRUeXBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGhpZGVFbGVtZW50c1dpdGhEaXNwbGF5TmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpO1xuXG4gICAgICBpZiAoZGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZm9yLW9mLWxvb3BzL25vLWZvci1vZi1sb29wc1xuICAgICAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGhpZGVFbGVtZW50c1dpdGhEaXNwbGF5TmFtZXMpLFxuICAgICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBkaXNwbGF5TmFtZVJlZ0V4cCA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKGRpc3BsYXlOYW1lUmVnRXhwLnRlc3QoZGlzcGxheU5hbWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX2RlYnVnU291cmNlICE9IG51bGwgJiYgaGlkZUVsZW1lbnRzV2l0aFBhdGhzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBfZGVidWdTb3VyY2UuZmlsZU5hbWU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mb3Itb2YtbG9vcHMvbm8tZm9yLW9mLWxvb3BzXG5cbiAgICAgIHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoaGlkZUVsZW1lbnRzV2l0aFBhdGhzKSxcbiAgICAgICAgICBfc3RlcDQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHBhdGhSZWdFeHAgPSBfc3RlcDQudmFsdWU7XG5cbiAgICAgICAgICBpZiAocGF0aFJlZ0V4cC50ZXN0KGZpbGVOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I0LmYoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gTk9USUNFIEtlZXAgaW4gc3luYyB3aXRoIHNob3VsZEZpbHRlckZpYmVyKCkgYW5kIG90aGVyIGdldCpGb3JGaWJlciBtZXRob2RzXG5cblxuICBmdW5jdGlvbiBnZXRFbGVtZW50VHlwZUZvckZpYmVyKGZpYmVyKSB7XG4gICAgdmFyIHR5cGUgPSBmaWJlci50eXBlLFxuICAgICAgICB0YWcgPSBmaWJlci50YWc7XG5cbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdHlwZXNbXCJlXCIgLyogRWxlbWVudFR5cGVDbGFzcyAqL107XG5cbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiB0eXBlc1tcImhcIiAvKiBFbGVtZW50VHlwZUZ1bmN0aW9uICovXTtcblxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICByZXR1cm4gdHlwZXNbXCJnXCIgLyogRWxlbWVudFR5cGVGb3J3YXJkUmVmICovXTtcblxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgcmV0dXJuIHR5cGVzW1wibVwiIC8qIEVsZW1lbnRUeXBlUm9vdCAqL107XG5cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICAgICAgcmV0dXJuIHR5cGVzW1wiaVwiIC8qIEVsZW1lbnRUeXBlSG9zdENvbXBvbmVudCAqL107XG5cbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gdHlwZXNbXCJrXCIgLyogRWxlbWVudFR5cGVPdGhlck9yVW5rbm93biAqL107XG5cbiAgICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHR5cGVzW1wialwiIC8qIEVsZW1lbnRUeXBlTWVtbyAqL107XG5cbiAgICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiB0eXBlc1tcIm5cIiAvKiBFbGVtZW50VHlwZVN1c3BlbnNlICovXTtcblxuICAgICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiB0eXBlc1tcIm9cIiAvKiBFbGVtZW50VHlwZVN1c3BlbnNlTGlzdCAqL107XG5cbiAgICAgIGNhc2UgVHJhY2luZ01hcmtlckNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHR5cGVzW1wicFwiIC8qIEVsZW1lbnRUeXBlVHJhY2luZ01hcmtlciAqL107XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciB0eXBlU3ltYm9sID0gZ2V0VHlwZVN5bWJvbCh0eXBlKTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGVTeW1ib2wpIHtcbiAgICAgICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcImFcIiAvKiBDT05DVVJSRU5UX01PREVfTlVNQkVSICovXTpcbiAgICAgICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcImJcIiAvKiBDT05DVVJSRU5UX01PREVfU1lNQk9MX1NUUklORyAqL106XG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJlXCIgLyogREVQUkVDQVRFRF9BU1lOQ19NT0RFX1NZTUJPTF9TVFJJTkcgKi9dOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVzW1wia1wiIC8qIEVsZW1lbnRUeXBlT3RoZXJPclVua25vd24gKi9dO1xuXG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJuXCIgLyogUFJPVklERVJfTlVNQkVSICovXTpcbiAgICAgICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcIm9cIiAvKiBQUk9WSURFUl9TWU1CT0xfU1RSSU5HICovXTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlc1tcImZcIiAvKiBFbGVtZW50VHlwZUNvbnRleHQgKi9dO1xuXG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJjXCIgLyogQ09OVEVYVF9OVU1CRVIgKi9dOlxuICAgICAgICAgIGNhc2UgUmVhY3RTeW1ib2xzW1wiZFwiIC8qIENPTlRFWFRfU1lNQk9MX1NUUklORyAqL106XG4gICAgICAgICAgICByZXR1cm4gdHlwZXNbXCJmXCIgLyogRWxlbWVudFR5cGVDb250ZXh0ICovXTtcblxuICAgICAgICAgIGNhc2UgUmVhY3RTeW1ib2xzW1wic1wiIC8qIFNUUklDVF9NT0RFX05VTUJFUiAqL106XG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJ0XCIgLyogU1RSSUNUX01PREVfU1lNQk9MX1NUUklORyAqL106XG4gICAgICAgICAgICByZXR1cm4gdHlwZXNbXCJrXCIgLyogRWxlbWVudFR5cGVPdGhlck9yVW5rbm93biAqL107XG5cbiAgICAgICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcImxcIiAvKiBQUk9GSUxFUl9OVU1CRVIgKi9dOlxuICAgICAgICAgIGNhc2UgUmVhY3RTeW1ib2xzW1wibVwiIC8qIFBST0ZJTEVSX1NZTUJPTF9TVFJJTkcgKi9dOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVzW1wibFwiIC8qIEVsZW1lbnRUeXBlUHJvZmlsZXIgKi9dO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0eXBlc1tcImtcIiAvKiBFbGVtZW50VHlwZU90aGVyT3JVbmtub3duICovXTtcbiAgICAgICAgfVxuXG4gICAgfVxuICB9IC8vIFdoZW4gcHJvZmlsaW5nIGlzIHN1cHBvcnRlZCwgd2Ugc3RvcmUgdGhlIGxhdGVzdCB0cmVlIGJhc2UgZHVyYXRpb25zIGZvciBlYWNoIEZpYmVyLlxuICAvLyBUaGlzIGlzIHNvIHRoYXQgd2UgY2FuIHF1aWNrbHkgY2FwdHVyZSBhIHNuYXBzaG90IG9mIHRob3NlIHZhbHVlcyBpZiBwcm9maWxpbmcgc3RhcnRzLlxuICAvLyBJZiB3ZSBkaWRuJ3Qgc3RvcmUgdGhlc2UgdmFsdWVzLCB3ZSdkIGhhdmUgdG8gY3Jhd2wgdGhlIHRyZWUgd2hlbiBwcm9maWxpbmcgc3RhcnRlZCxcbiAgLy8gYW5kIHVzZSBhIHNsb3cgcGF0aCB0byBmaW5kIGVhY2ggb2YgdGhlIGN1cnJlbnQgRmliZXJzLlxuXG5cbiAgdmFyIGlkVG9UcmVlQmFzZUR1cmF0aW9uTWFwID0gbmV3IE1hcCgpOyAvLyBXaGVuIHByb2ZpbGluZyBpcyBzdXBwb3J0ZWQsIHdlIHN0b3JlIHRoZSBsYXRlc3QgdHJlZSBiYXNlIGR1cmF0aW9ucyBmb3IgZWFjaCBGaWJlci5cbiAgLy8gVGhpcyBtYXAgZW5hYmxlcyB1cyB0byBmaWx0ZXIgdGhlc2UgdGltZXMgYnkgcm9vdCB3aGVuIHNlbmRpbmcgdGhlbSB0byB0aGUgZnJvbnRlbmQuXG5cbiAgdmFyIGlkVG9Sb290TWFwID0gbmV3IE1hcCgpOyAvLyBXaGVuIGEgbW91bnQgb3IgdXBkYXRlIGlzIGluIHByb2dyZXNzLCB0aGlzIHZhbHVlIHRyYWNrcyB0aGUgcm9vdCB0aGF0IGlzIGJlaW5nIG9wZXJhdGVkIG9uLlxuXG4gIHZhciBjdXJyZW50Um9vdElEID0gLTE7IC8vIFJldHVybnMgdGhlIHVuaXF1ZSBJRCBmb3IgYSBGaWJlciBvciBnZW5lcmF0ZXMgYW5kIGNhY2hlcyBhIG5ldyBvbmUgaWYgdGhlIEZpYmVyIGhhc24ndCBiZWVuIHNlZW4gYmVmb3JlLlxuICAvLyBPbmNlIHRoaXMgbWV0aG9kIGhhcyBiZWVuIGNhbGxlZCBmb3IgYSBGaWJlciwgdW50cmFja0ZpYmVySUQoKSBzaG91bGQgYWx3YXlzIGJlIGNhbGxlZCBsYXRlciB0byBhdm9pZCBsZWFraW5nLlxuXG4gIGZ1bmN0aW9uIGdldE9yR2VuZXJhdGVGaWJlcklEKGZpYmVyKSB7XG4gICAgdmFyIGlkID0gbnVsbDtcblxuICAgIGlmIChmaWJlclRvSURNYXAuaGFzKGZpYmVyKSkge1xuICAgICAgaWQgPSBmaWJlclRvSURNYXAuZ2V0KGZpYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9hbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChfYWx0ZXJuYXRlICE9PSBudWxsICYmIGZpYmVyVG9JRE1hcC5oYXMoX2FsdGVybmF0ZSkpIHtcbiAgICAgICAgaWQgPSBmaWJlclRvSURNYXAuZ2V0KF9hbHRlcm5hdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkaWRHZW5lcmF0ZUlEID0gZmFsc2U7XG5cbiAgICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICAgIGRpZEdlbmVyYXRlSUQgPSB0cnVlO1xuICAgICAgaWQgPSBPYmplY3QodXRpbHNbXCJrXCIgLyogZ2V0VUlEICovXSkoKTtcbiAgICB9IC8vIFRoaXMgcmVmaW5lbWVudCBpcyBmb3IgRmxvdyBwdXJwb3NlcyBvbmx5LlxuXG5cbiAgICB2YXIgcmVmaW5lZElEID0gaWQ7IC8vIE1ha2Ugc3VyZSB3ZSdyZSB0cmFja2luZyB0aGlzIEZpYmVyXG4gICAgLy8gZS5nLiBpZiBpdCBqdXN0IG1vdW50ZWQgb3IgYW4gZXJyb3Igd2FzIGxvZ2dlZCBkdXJpbmcgaW5pdGlhbCByZW5kZXIuXG5cbiAgICBpZiAoIWZpYmVyVG9JRE1hcC5oYXMoZmliZXIpKSB7XG4gICAgICBmaWJlclRvSURNYXAuc2V0KGZpYmVyLCByZWZpbmVkSUQpO1xuICAgICAgaWRUb0FyYml0cmFyeUZpYmVyTWFwLnNldChyZWZpbmVkSUQsIGZpYmVyKTtcbiAgICB9IC8vIEFsc28gbWFrZSBzdXJlIHdlJ3JlIHRyYWNraW5nIGl0cyBhbHRlcm5hdGUsXG4gICAgLy8gZS5nLiBpbiBjYXNlIHRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZSBhZnRlciBtb3VudC5cblxuXG4gICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgIGlmICghZmliZXJUb0lETWFwLmhhcyhhbHRlcm5hdGUpKSB7XG4gICAgICAgIGZpYmVyVG9JRE1hcC5zZXQoYWx0ZXJuYXRlLCByZWZpbmVkSUQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb25zdGFudHNbXCJzXCIgLyogX19ERUJVR19fICovXSkge1xuICAgICAgaWYgKGRpZEdlbmVyYXRlSUQpIHtcbiAgICAgICAgZGVidWcoJ2dldE9yR2VuZXJhdGVGaWJlcklEKCknLCBmaWJlciwgZmliZXIucmV0dXJuLCAnR2VuZXJhdGVkIGEgbmV3IFVJRCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZWZpbmVkSUQ7XG4gIH0gLy8gUmV0dXJucyBhbiBJRCBpZiBvbmUgaGFzIGFscmVhZHkgYmVlbiBnZW5lcmF0ZWQgZm9yIHRoZSBGaWJlciBvciB0aHJvd3MuXG5cblxuICBmdW5jdGlvbiBnZXRGaWJlcklEVGhyb3dzKGZpYmVyKSB7XG4gICAgdmFyIG1heWJlSUQgPSBnZXRGaWJlcklEVW5zYWZlKGZpYmVyKTtcblxuICAgIGlmIChtYXliZUlEICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbWF5YmVJRDtcbiAgICB9XG5cbiAgICB0aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIElEIGZvciBGaWJlciBcXFwiXCIuY29uY2F0KGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpIHx8ICcnLCBcIlxcXCJcIikpO1xuICB9IC8vIFJldHVybnMgYW4gSUQgaWYgb25lIGhhcyBhbHJlYWR5IGJlZW4gZ2VuZXJhdGVkIGZvciB0aGUgRmliZXIgb3IgbnVsbCBpZiBvbmUgaGFzIG5vdCBiZWVuIGdlbmVyYXRlZC5cbiAgLy8gVXNlIHRoaXMgbWV0aG9kIHdoaWxlIGUuZy4gbG9nZ2luZyB0byBhdm9pZCBvdmVyLXJldGFpbmluZyBGaWJlcnMuXG5cblxuICBmdW5jdGlvbiBnZXRGaWJlcklEVW5zYWZlKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyVG9JRE1hcC5oYXMoZmliZXIpKSB7XG4gICAgICByZXR1cm4gZmliZXJUb0lETWFwLmdldChmaWJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwgJiYgZmliZXJUb0lETWFwLmhhcyhhbHRlcm5hdGUpKSB7XG4gICAgICAgIHJldHVybiBmaWJlclRvSURNYXAuZ2V0KGFsdGVybmF0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gUmVtb3ZlcyBhIEZpYmVyIChhbmQgaXRzIGFsdGVybmF0ZSkgZnJvbSB0aGUgTWFwcyB1c2VkIHRvIHRyYWNrIHRoZWlyIGlkLlxuICAvLyBUaGlzIG1ldGhvZCBzaG91bGQgYWx3YXlzIGJlIGNhbGxlZCB3aGVuIGEgRmliZXIgaXMgdW5tb3VudGluZy5cblxuXG4gIGZ1bmN0aW9uIHVudHJhY2tGaWJlcklEKGZpYmVyKSB7XG4gICAgaWYgKGNvbnN0YW50c1tcInNcIiAvKiBfX0RFQlVHX18gKi9dKSB7XG4gICAgICBkZWJ1ZygndW50cmFja0ZpYmVySUQoKScsIGZpYmVyLCBmaWJlci5yZXR1cm4sICdzY2hlZHVsZSBhZnRlciBkZWxheScpO1xuICAgIH0gLy8gVW50cmFjayBGaWJlcnMgYWZ0ZXIgYSBzbGlnaHQgZGVsYXkgaW4gb3JkZXIgdG8gc3VwcG9ydCBhIEZhc3QgUmVmcmVzaCBlZGdlIGNhc2U6XG4gICAgLy8gMS4gQ29tcG9uZW50IHR5cGUgaXMgdXBkYXRlZCBhbmQgRmFzdCBSZWZyZXNoIHNjaGVkdWxlcyBhbiB1cGRhdGUrcmVtb3VudC5cbiAgICAvLyAyLiBmbHVzaFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5nc0FmdGVyRGVsYXkoKSBydW5zLCBzZWVzIHRoZSBvbGQgRmliZXIgaXMgbm8gbG9uZ2VyIG1vdW50ZWRcbiAgICAvLyAgICAoaXQncyBiZWVuIGRpc2Nvbm5lY3RlZCBieSBGYXN0IFJlZnJlc2gpLCBhbmQgY2FsbHMgdW50cmFja0ZpYmVySUQoKSB0byBjbGVhciBpdCBmcm9tIHRoZSBNYXAuXG4gICAgLy8gMy4gUmVhY3QgZmx1c2hlcyBwZW5kaW5nIHBhc3NpdmUgZWZmZWN0cyBiZWZvcmUgaXQgcnVucyB0aGUgbmV4dCByZW5kZXIsXG4gICAgLy8gICAgd2hpY2ggbG9ncyBhbiBlcnJvciBvciB3YXJuaW5nLCB3aGljaCBjYXVzZXMgYSBuZXcgSUQgdG8gYmUgZ2VuZXJhdGVkIGZvciB0aGlzIEZpYmVyLlxuICAgIC8vIDQuIERldlRvb2xzIG5vdyB0cmllcyB0byB1bm1vdW50IHRoZSBvbGQgQ29tcG9uZW50IHdpdGggdGhlIG5ldyBJRC5cbiAgICAvL1xuICAgIC8vIFRoZSB1bmRlcmx5aW5nIHByb2JsZW0gaGVyZSBpcyB0aGUgcHJlbWF0dXJlIGNsZWFyaW5nIG9mIHRoZSBGaWJlciBJRCxcbiAgICAvLyBidXQgRGV2VG9vbHMgaGFzIG5vIHdheSB0byBkZXRlY3QgdGhhdCBhIGdpdmVuIEZpYmVyIGhhcyBiZWVuIHNjaGVkdWxlZCBmb3IgRmFzdCBSZWZyZXNoLlxuICAgIC8vIChUaGUgXCJfZGVidWdOZWVkc1JlbW91bnRcIiBmbGFnIHdvbid0IG5lY2Vzc2FyaWx5IGJlIHNldC4pXG4gICAgLy9cbiAgICAvLyBUaGUgYmVzdCB3ZSBjYW4gZG8gaXMgdG8gZGVsYXkgdW50cmFja2luZyBieSBhIHNtYWxsIGFtb3VudCxcbiAgICAvLyBhbmQgZ2l2ZSBSZWFjdCB0aW1lIHRvIHByb2Nlc3MgdGhlIEZhc3QgUmVmcmVzaCBkZWxheS5cblxuXG4gICAgdW50cmFja0ZpYmVyc1NldC5hZGQoZmliZXIpOyAvLyBSZWFjdCBtYXkgZGV0YWNoIGFsdGVybmF0ZSBwb2ludGVycyBkdXJpbmcgdW5tb3VudDtcbiAgICAvLyBTaW5jZSBvdXIgdW50cmFja2luZyBjb2RlIGlzIGFzeW5jLCB3ZSBzaG91bGQgZXhwbGljaWx5IHRyYWNrIHRoZSBwZW5kaW5nIGFsdGVybmF0ZSBoZXJlIGFzIHdlbGwuXG5cbiAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgdW50cmFja0ZpYmVyc1NldC5hZGQoYWx0ZXJuYXRlKTtcbiAgICB9XG5cbiAgICBpZiAodW50cmFja0ZpYmVyc1RpbWVvdXRJRCA9PT0gbnVsbCkge1xuICAgICAgdW50cmFja0ZpYmVyc1RpbWVvdXRJRCA9IHNldFRpbWVvdXQodW50cmFja0ZpYmVycywgMTAwMCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVudHJhY2tGaWJlcnNTZXQgPSBuZXcgU2V0KCk7XG4gIHZhciB1bnRyYWNrRmliZXJzVGltZW91dElEID0gbnVsbDtcblxuICBmdW5jdGlvbiB1bnRyYWNrRmliZXJzKCkge1xuICAgIGlmICh1bnRyYWNrRmliZXJzVGltZW91dElEICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodW50cmFja0ZpYmVyc1RpbWVvdXRJRCk7XG4gICAgICB1bnRyYWNrRmliZXJzVGltZW91dElEID0gbnVsbDtcbiAgICB9XG5cbiAgICB1bnRyYWNrRmliZXJzU2V0LmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICB2YXIgZmliZXJJRCA9IGdldEZpYmVySURVbnNhZmUoZmliZXIpO1xuXG4gICAgICBpZiAoZmliZXJJRCAhPT0gbnVsbCkge1xuICAgICAgICBpZFRvQXJiaXRyYXJ5RmliZXJNYXAuZGVsZXRlKGZpYmVySUQpOyAvLyBBbHNvIGNsZWFyIGFueSBlcnJvcnMvd2FybmluZ3MgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZmliZXIuXG5cbiAgICAgICAgY2xlYXJFcnJvcnNGb3JGaWJlcklEKGZpYmVySUQpO1xuICAgICAgICBjbGVhcldhcm5pbmdzRm9yRmliZXJJRChmaWJlcklEKTtcbiAgICAgIH1cblxuICAgICAgZmliZXJUb0lETWFwLmRlbGV0ZShmaWJlcik7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgIGZpYmVyVG9JRE1hcC5kZWxldGUoYWx0ZXJuYXRlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcmNlRXJyb3JGb3JGaWJlcklEcy5oYXMoZmliZXJJRCkpIHtcbiAgICAgICAgZm9yY2VFcnJvckZvckZpYmVySURzLmRlbGV0ZShmaWJlcklEKTtcblxuICAgICAgICBpZiAoZm9yY2VFcnJvckZvckZpYmVySURzLnNpemUgPT09IDAgJiYgc2V0RXJyb3JIYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICBzZXRFcnJvckhhbmRsZXIoc2hvdWxkRXJyb3JGaWJlckFsd2F5c051bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdW50cmFja0ZpYmVyc1NldC5jbGVhcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2hhbmdlRGVzY3JpcHRpb24ocHJldkZpYmVyLCBuZXh0RmliZXIpIHtcbiAgICBzd2l0Y2ggKGdldEVsZW1lbnRUeXBlRm9yRmliZXIobmV4dEZpYmVyKSkge1xuICAgICAgY2FzZSB0eXBlc1tcImVcIiAvKiBFbGVtZW50VHlwZUNsYXNzICovXTpcbiAgICAgIGNhc2UgdHlwZXNbXCJoXCIgLyogRWxlbWVudFR5cGVGdW5jdGlvbiAqL106XG4gICAgICBjYXNlIHR5cGVzW1wialwiIC8qIEVsZW1lbnRUeXBlTWVtbyAqL106XG4gICAgICBjYXNlIHR5cGVzW1wiZ1wiIC8qIEVsZW1lbnRUeXBlRm9yd2FyZFJlZiAqL106XG4gICAgICAgIGlmIChwcmV2RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGV4dDogbnVsbCxcbiAgICAgICAgICAgIGRpZEhvb2tzQ2hhbmdlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzRmlyc3RNb3VudDogdHJ1ZSxcbiAgICAgICAgICAgIHByb3BzOiBudWxsLFxuICAgICAgICAgICAgc3RhdGU6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgY29udGV4dDogZ2V0Q29udGV4dENoYW5nZWRLZXlzKG5leHRGaWJlciksXG4gICAgICAgICAgICBkaWRIb29rc0NoYW5nZTogZmFsc2UsXG4gICAgICAgICAgICBpc0ZpcnN0TW91bnQ6IGZhbHNlLFxuICAgICAgICAgICAgcHJvcHM6IGdldENoYW5nZWRLZXlzKHByZXZGaWJlci5tZW1vaXplZFByb3BzLCBuZXh0RmliZXIubWVtb2l6ZWRQcm9wcyksXG4gICAgICAgICAgICBzdGF0ZTogZ2V0Q2hhbmdlZEtleXMocHJldkZpYmVyLm1lbW9pemVkU3RhdGUsIG5leHRGaWJlci5tZW1vaXplZFN0YXRlKVxuICAgICAgICAgIH07IC8vIE9ubHkgdHJhdmVyc2UgdGhlIGhvb2tzIGxpc3Qgb25jZSwgZGVwZW5kaW5nIG9uIHdoYXQgaW5mbyB3ZSdyZSByZXR1cm5pbmcuXG5cbiAgICAgICAgICB2YXIgaW5kaWNlcyA9IGdldENoYW5nZWRIb29rc0luZGljZXMocHJldkZpYmVyLm1lbW9pemVkU3RhdGUsIG5leHRGaWJlci5tZW1vaXplZFN0YXRlKTtcbiAgICAgICAgICBkYXRhLmhvb2tzID0gaW5kaWNlcztcbiAgICAgICAgICBkYXRhLmRpZEhvb2tzQ2hhbmdlID0gaW5kaWNlcyAhPT0gbnVsbCAmJiBpbmRpY2VzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ29udGV4dHNGb3JGaWJlcihmaWJlcikge1xuICAgIHN3aXRjaCAoZ2V0RWxlbWVudFR5cGVGb3JGaWJlcihmaWJlcikpIHtcbiAgICAgIGNhc2UgdHlwZXNbXCJlXCIgLyogRWxlbWVudFR5cGVDbGFzcyAqL106XG4gICAgICBjYXNlIHR5cGVzW1wiZ1wiIC8qIEVsZW1lbnRUeXBlRm9yd2FyZFJlZiAqL106XG4gICAgICBjYXNlIHR5cGVzW1wiaFwiIC8qIEVsZW1lbnRUeXBlRnVuY3Rpb24gKi9dOlxuICAgICAgY2FzZSB0eXBlc1tcImpcIiAvKiBFbGVtZW50VHlwZU1lbW8gKi9dOlxuICAgICAgICBpZiAoaWRUb0NvbnRleHRzTWFwICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGlkID0gZ2V0RmliZXJJRFRocm93cyhmaWJlcik7XG4gICAgICAgICAgdmFyIGNvbnRleHRzID0gZ2V0Q29udGV4dHNGb3JGaWJlcihmaWJlcik7XG5cbiAgICAgICAgICBpZiAoY29udGV4dHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICAgICAgaWRUb0NvbnRleHRzTWFwLnNldChpZCwgY29udGV4dHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gLy8gRGlmZmVyZW50aWF0ZXMgYmV0d2VlbiBhIG51bGwgY29udGV4dCB2YWx1ZSBhbmQgbm8gY29udGV4dC5cblxuXG4gIHZhciBOT19DT05URVhUID0ge307XG5cbiAgZnVuY3Rpb24gZ2V0Q29udGV4dHNGb3JGaWJlcihmaWJlcikge1xuICAgIHZhciBsZWdhY3lDb250ZXh0ID0gTk9fQ09OVEVYVDtcbiAgICB2YXIgbW9kZXJuQ29udGV4dCA9IE5PX0NPTlRFWFQ7XG5cbiAgICBzd2l0Y2ggKGdldEVsZW1lbnRUeXBlRm9yRmliZXIoZmliZXIpKSB7XG4gICAgICBjYXNlIHR5cGVzW1wiZVwiIC8qIEVsZW1lbnRUeXBlQ2xhc3MgKi9dOlxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UuY29uc3RydWN0b3IgJiYgaW5zdGFuY2UuY29uc3RydWN0b3IuY29udGV4dFR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbW9kZXJuQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZ2FjeUNvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuXG4gICAgICAgICAgICBpZiAobGVnYWN5Q29udGV4dCAmJiBPYmplY3Qua2V5cyhsZWdhY3lDb250ZXh0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgbGVnYWN5Q29udGV4dCA9IE5PX0NPTlRFWFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtsZWdhY3lDb250ZXh0LCBtb2Rlcm5Db250ZXh0XTtcblxuICAgICAgY2FzZSB0eXBlc1tcImdcIiAvKiBFbGVtZW50VHlwZUZvcndhcmRSZWYgKi9dOlxuICAgICAgY2FzZSB0eXBlc1tcImhcIiAvKiBFbGVtZW50VHlwZUZ1bmN0aW9uICovXTpcbiAgICAgIGNhc2UgdHlwZXNbXCJqXCIgLyogRWxlbWVudFR5cGVNZW1vICovXTpcbiAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IGZpYmVyLmRlcGVuZGVuY2llcztcblxuICAgICAgICBpZiAoZGVwZW5kZW5jaWVzICYmIGRlcGVuZGVuY2llcy5maXJzdENvbnRleHQpIHtcbiAgICAgICAgICBtb2Rlcm5Db250ZXh0ID0gZGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbbGVnYWN5Q29udGV4dCwgbW9kZXJuQ29udGV4dF07XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSAvLyBSZWNvcmQgYWxsIGNvbnRleHRzIGF0IHRoZSB0aW1lIHByb2ZpbGluZyBpcyBzdGFydGVkLlxuICAvLyBGaWJlcnMgb25seSBzdG9yZSB0aGUgY3VycmVudCBjb250ZXh0IHZhbHVlLFxuICAvLyBzbyB3ZSBuZWVkIHRvIHRyYWNrIHRoZW0gc2VwYXJhdGVseSBpbiBvcmRlciB0byBkZXRlcm1pbmUgY2hhbmdlZCBrZXlzLlxuXG5cbiAgZnVuY3Rpb24gY3Jhd2xUb0luaXRpYWxpemVDb250ZXh0c01hcChmaWJlcikge1xuICAgIHZhciBpZCA9IGdldEZpYmVySURVbnNhZmUoZmliZXIpOyAvLyBOb3QgYWxsIEZpYmVycyBpbiB0aGUgc3VidHJlZSBoYXZlIG1vdW50ZWQgeWV0LlxuICAgIC8vIEZvciBleGFtcGxlLCBPZmZzY3JlZW4gKGhpZGRlbikgb3IgU3VzcGVuc2UgKHN1c3BlbmRlZCkgc3VidHJlZXMgd29uJ3QgeWV0IGJlIHRyYWNrZWQuXG4gICAgLy8gV2UgY2FuIHNhZmVseSBza2lwIHRoZXNlIHN1YnRyZWVzLlxuXG4gICAgaWYgKGlkICE9PSBudWxsKSB7XG4gICAgICB1cGRhdGVDb250ZXh0c0ZvckZpYmVyKGZpYmVyKTtcbiAgICAgIHZhciBjdXJyZW50ID0gZmliZXIuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGNyYXdsVG9Jbml0aWFsaXplQ29udGV4dHNNYXAoY3VycmVudCk7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q29udGV4dENoYW5nZWRLZXlzKGZpYmVyKSB7XG4gICAgaWYgKGlkVG9Db250ZXh0c01hcCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGlkID0gZ2V0RmliZXJJRFRocm93cyhmaWJlcik7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG4gICAgICB2YXIgcHJldkNvbnRleHRzID0gaWRUb0NvbnRleHRzTWFwLmhhcyhpZCkgPyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgIGlkVG9Db250ZXh0c01hcC5nZXQoaWQpIDogbnVsbDtcbiAgICAgIHZhciBuZXh0Q29udGV4dHMgPSBnZXRDb250ZXh0c0ZvckZpYmVyKGZpYmVyKTtcblxuICAgICAgaWYgKHByZXZDb250ZXh0cyA9PSBudWxsIHx8IG5leHRDb250ZXh0cyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3ByZXZDb250ZXh0cyA9IHJlbmRlcmVyX3NsaWNlZFRvQXJyYXkocHJldkNvbnRleHRzLCAyKSxcbiAgICAgICAgICBwcmV2TGVnYWN5Q29udGV4dCA9IF9wcmV2Q29udGV4dHNbMF0sXG4gICAgICAgICAgcHJldk1vZGVybkNvbnRleHQgPSBfcHJldkNvbnRleHRzWzFdO1xuXG4gICAgICB2YXIgX25leHRDb250ZXh0cyA9IHJlbmRlcmVyX3NsaWNlZFRvQXJyYXkobmV4dENvbnRleHRzLCAyKSxcbiAgICAgICAgICBuZXh0TGVnYWN5Q29udGV4dCA9IF9uZXh0Q29udGV4dHNbMF0sXG4gICAgICAgICAgbmV4dE1vZGVybkNvbnRleHQgPSBfbmV4dENvbnRleHRzWzFdO1xuXG4gICAgICBzd2l0Y2ggKGdldEVsZW1lbnRUeXBlRm9yRmliZXIoZmliZXIpKSB7XG4gICAgICAgIGNhc2UgdHlwZXNbXCJlXCIgLyogRWxlbWVudFR5cGVDbGFzcyAqL106XG4gICAgICAgICAgaWYgKHByZXZDb250ZXh0cyAmJiBuZXh0Q29udGV4dHMpIHtcbiAgICAgICAgICAgIGlmIChuZXh0TGVnYWN5Q29udGV4dCAhPT0gTk9fQ09OVEVYVCkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q2hhbmdlZEtleXMocHJldkxlZ2FjeUNvbnRleHQsIG5leHRMZWdhY3lDb250ZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dE1vZGVybkNvbnRleHQgIT09IE5PX0NPTlRFWFQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByZXZNb2Rlcm5Db250ZXh0ICE9PSBuZXh0TW9kZXJuQ29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIHR5cGVzW1wiZ1wiIC8qIEVsZW1lbnRUeXBlRm9yd2FyZFJlZiAqL106XG4gICAgICAgIGNhc2UgdHlwZXNbXCJoXCIgLyogRWxlbWVudFR5cGVGdW5jdGlvbiAqL106XG4gICAgICAgIGNhc2UgdHlwZXNbXCJqXCIgLyogRWxlbWVudFR5cGVNZW1vICovXTpcbiAgICAgICAgICBpZiAobmV4dE1vZGVybkNvbnRleHQgIT09IE5PX0NPTlRFWFQpIHtcbiAgICAgICAgICAgIHZhciBwcmV2Q29udGV4dCA9IHByZXZNb2Rlcm5Db250ZXh0O1xuICAgICAgICAgICAgdmFyIG5leHRDb250ZXh0ID0gbmV4dE1vZGVybkNvbnRleHQ7XG5cbiAgICAgICAgICAgIHdoaWxlIChwcmV2Q29udGV4dCAmJiBuZXh0Q29udGV4dCkge1xuICAgICAgICAgICAgICAvLyBOb3RlIHRoaXMgb25seSB3b3JrcyBmb3IgdmVyc2lvbnMgb2YgUmVhY3QgdGhhdCBzdXBwb3J0IHRoaXMga2V5IChlLnYuIDE4KylcbiAgICAgICAgICAgICAgLy8gRm9yIG9sZGVyIHZlcnNpb25zLCB0aGVyZSdzIG5vIGdvb2Qgd2F5IHRvIHJlYWQgdGhlIGN1cnJlbnQgY29udGV4dCB2YWx1ZSBhZnRlciByZW5kZXIgaGFzIGNvbXBsZXRlZC5cbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIFJlYWN0IG1haW50YWlucyBhIHN0YWNrIG9mIGNvbnRleHQgdmFsdWVzIGR1cmluZyByZW5kZXIsXG4gICAgICAgICAgICAgIC8vIGJ1dCBieSB0aGUgdGltZSBEZXZUb29scyBpcyBjYWxsZWQsIHJlbmRlciBoYXMgZmluaXNoZWQgYW5kIHRoZSBzdGFjayBpcyBlbXB0eS5cbiAgICAgICAgICAgICAgaWYgKCFzaGFyZWRfb2JqZWN0SXMocHJldkNvbnRleHQubWVtb2l6ZWRWYWx1ZSwgbmV4dENvbnRleHQubWVtb2l6ZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHByZXZDb250ZXh0ID0gcHJldkNvbnRleHQubmV4dDtcbiAgICAgICAgICAgICAgbmV4dENvbnRleHQgPSBuZXh0Q29udGV4dC5uZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSG9va1RoYXRDYW5TY2hlZHVsZVVwZGF0ZShob29rT2JqZWN0KSB7XG4gICAgdmFyIHF1ZXVlID0gaG9va09iamVjdC5xdWV1ZTtcblxuICAgIGlmICghcXVldWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgYm91bmRIYXNPd25Qcm9wZXJ0eSA9IHNoYXJlZF9oYXNPd25Qcm9wZXJ0eS5iaW5kKHF1ZXVlKTsgLy8gRGV0ZWN0IHRoZSBzaGFwZSBvZiB1c2VTdGF0ZSgpIG9yIHVzZVJlZHVjZXIoKVxuICAgIC8vIHVzaW5nIHRoZSBhdHRyaWJ1dGVzIHRoYXQgYXJlIHVuaXF1ZSB0byB0aGVzZSBob29rc1xuICAgIC8vIGJ1dCBhbHNvIHN0YWJsZSAoZS5nLiBub3QgdGllZCB0byBjdXJyZW50IExhbmVzIGltcGxlbWVudGF0aW9uKVxuXG4gICAgdmFyIGlzU3RhdGVPclJlZHVjZXIgPSBib3VuZEhhc093blByb3BlcnR5KCdwZW5kaW5nJykgJiYgYm91bmRIYXNPd25Qcm9wZXJ0eSgnZGlzcGF0Y2gnKSAmJiB0eXBlb2YgcXVldWUuZGlzcGF0Y2ggPT09ICdmdW5jdGlvbic7IC8vIERldGVjdCB1c2VTeW5jRXh0ZXJuYWxTdG9yZSgpXG5cbiAgICB2YXIgaXNTeW5jRXh0ZXJuYWxTdG9yZSA9IGJvdW5kSGFzT3duUHJvcGVydHkoJ3ZhbHVlJykgJiYgYm91bmRIYXNPd25Qcm9wZXJ0eSgnZ2V0U25hcHNob3QnKSAmJiB0eXBlb2YgcXVldWUuZ2V0U25hcHNob3QgPT09ICdmdW5jdGlvbic7IC8vIFRoZXNlIGFyZSB0aGUgb25seSB0eXBlcyBvZiBob29rcyB0aGF0IGNhbiBzY2hlZHVsZSBhbiB1cGRhdGUuXG5cbiAgICByZXR1cm4gaXNTdGF0ZU9yUmVkdWNlciB8fCBpc1N5bmNFeHRlcm5hbFN0b3JlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGlkU3RhdGVmdWxIb29rQ2hhbmdlKHByZXYsIG5leHQpIHtcbiAgICB2YXIgcHJldk1lbW9pemVkU3RhdGUgPSBwcmV2Lm1lbW9pemVkU3RhdGU7XG4gICAgdmFyIG5leHRNZW1vaXplZFN0YXRlID0gbmV4dC5tZW1vaXplZFN0YXRlO1xuXG4gICAgaWYgKGlzSG9va1RoYXRDYW5TY2hlZHVsZVVwZGF0ZShwcmV2KSkge1xuICAgICAgcmV0dXJuIHByZXZNZW1vaXplZFN0YXRlICE9PSBuZXh0TWVtb2l6ZWRTdGF0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDaGFuZ2VkSG9va3NJbmRpY2VzKHByZXYsIG5leHQpIHtcbiAgICBpZiAocHJldiA9PSBudWxsIHx8IG5leHQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICB2YXIgaW5kZXggPSAwO1xuXG4gICAgaWYgKG5leHQuaGFzT3duUHJvcGVydHkoJ2Jhc2VTdGF0ZScpICYmIG5leHQuaGFzT3duUHJvcGVydHkoJ21lbW9pemVkU3RhdGUnKSAmJiBuZXh0Lmhhc093blByb3BlcnR5KCduZXh0JykgJiYgbmV4dC5oYXNPd25Qcm9wZXJ0eSgncXVldWUnKSkge1xuICAgICAgd2hpbGUgKG5leHQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKGRpZFN0YXRlZnVsSG9va0NoYW5nZShwcmV2LCBuZXh0KSkge1xuICAgICAgICAgIGluZGljZXMucHVzaChpbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0ID0gbmV4dC5uZXh0O1xuICAgICAgICBwcmV2ID0gcHJldi5uZXh0O1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmRpY2VzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2hhbmdlZEtleXMocHJldiwgbmV4dCkge1xuICAgIGlmIChwcmV2ID09IG51bGwgfHwgbmV4dCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIFdlIGNhbid0IHJlcG9ydCBhbnl0aGluZyBtZWFuaW5nZnVsIGZvciBob29rcyBjaGFuZ2VzLlxuXG5cbiAgICBpZiAobmV4dC5oYXNPd25Qcm9wZXJ0eSgnYmFzZVN0YXRlJykgJiYgbmV4dC5oYXNPd25Qcm9wZXJ0eSgnbWVtb2l6ZWRTdGF0ZScpICYmIG5leHQuaGFzT3duUHJvcGVydHkoJ25leHQnKSAmJiBuZXh0Lmhhc093blByb3BlcnR5KCdxdWV1ZScpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IG5ldyBTZXQoW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShPYmplY3Qua2V5cyhwcmV2KSksIF90b0NvbnN1bWFibGVBcnJheShPYmplY3Qua2V5cyhuZXh0KSkpKTtcbiAgICB2YXIgY2hhbmdlZEtleXMgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZvci1vZi1sb29wcy9uby1mb3Itb2YtbG9vcHNcblxuICAgIHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoa2V5cyksXG4gICAgICAgIF9zdGVwNTtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgICB2YXIga2V5ID0gX3N0ZXA1LnZhbHVlO1xuXG4gICAgICAgIGlmIChwcmV2W2tleV0gIT09IG5leHRba2V5XSkge1xuICAgICAgICAgIGNoYW5nZWRLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yNS5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjUuZigpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2VkS2V5cztcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxuXG4gIGZ1bmN0aW9uIGRpZEZpYmVyUmVuZGVyKHByZXZGaWJlciwgbmV4dEZpYmVyKSB7XG4gICAgc3dpdGNoIChuZXh0RmliZXIudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICAvLyBGb3IgdHlwZXMgdGhhdCBleGVjdXRlIHVzZXIgY29kZSwgd2UgY2hlY2sgUGVyZm9ybWVkV29yayBlZmZlY3QuXG4gICAgICAgIC8vIFdlIGRvbid0IHJlZmxlY3QgYmFpbG91dHMgKGVpdGhlciByZWZlcmVudGlhbCBvciBzQ1UpIGluIERldlRvb2xzLlxuICAgICAgICAvLyBUT0RPOiBUaGlzIGZsYWcgaXMgYSBsZWFrZWQgaW1wbGVtZW50YXRpb24gZGV0YWlsLiBPbmNlIHdlIHN0YXJ0XG4gICAgICAgIC8vIHJlbGVhc2luZyBEZXZUb29scyBpbiBsb2Nrc3RlcCB3aXRoIFJlYWN0LCB3ZSBzaG91bGQgaW1wb3J0IGFcbiAgICAgICAgLy8gZnVuY3Rpb24gZnJvbSB0aGUgcmVjb25jaWxlciBpbnN0ZWFkLlxuICAgICAgICB2YXIgUGVyZm9ybWVkV29yayA9IDE7XG4gICAgICAgIHJldHVybiAoZ2V0RmliZXJGbGFncyhuZXh0RmliZXIpICYgUGVyZm9ybWVkV29yaykgPT09IFBlcmZvcm1lZFdvcms7XG4gICAgICAvLyBOb3RlOiBDb250ZXh0Q29uc3VtZXIgb25seSBnZXRzIFBlcmZvcm1lZFdvcmsgZWZmZWN0IGluIDE2LjMuMytcbiAgICAgIC8vIHNvIGl0IHdvbid0IGdldCBoaWdobGlnaHRlZCB3aXRoIFJlYWN0IDE2LjMuMCB0byAxNi4zLjIuXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIEZvciBob3N0IGNvbXBvbmVudHMgYW5kIG90aGVyIHR5cGVzLCB3ZSBjb21wYXJlIGlucHV0c1xuICAgICAgICAvLyB0byBkZXRlcm1pbmUgd2hldGhlciBzb21ldGhpbmcgaXMgYW4gdXBkYXRlLlxuICAgICAgICByZXR1cm4gcHJldkZpYmVyLm1lbW9pemVkUHJvcHMgIT09IG5leHRGaWJlci5tZW1vaXplZFByb3BzIHx8IHByZXZGaWJlci5tZW1vaXplZFN0YXRlICE9PSBuZXh0RmliZXIubWVtb2l6ZWRTdGF0ZSB8fCBwcmV2RmliZXIucmVmICE9PSBuZXh0RmliZXIucmVmO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwZW5kaW5nT3BlcmF0aW9ucyA9IFtdO1xuICB2YXIgcGVuZGluZ1JlYWxVbm1vdW50ZWRJRHMgPSBbXTtcbiAgdmFyIHBlbmRpbmdTaW11bGF0ZWRVbm1vdW50ZWRJRHMgPSBbXTtcbiAgdmFyIHBlbmRpbmdPcGVyYXRpb25zUXVldWUgPSBbXTtcbiAgdmFyIHBlbmRpbmdTdHJpbmdUYWJsZSA9IG5ldyBNYXAoKTtcbiAgdmFyIHBlbmRpbmdTdHJpbmdUYWJsZUxlbmd0aCA9IDA7XG4gIHZhciBwZW5kaW5nVW5tb3VudGVkUm9vdElEID0gbnVsbDtcblxuICBmdW5jdGlvbiBwdXNoT3BlcmF0aW9uKG9wKSB7XG4gICAgaWYgKGZhbHNlKSB7fVxuXG4gICAgcGVuZGluZ09wZXJhdGlvbnMucHVzaChvcCk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRCYWlsb3V0V2l0aFBlbmRpbmdPcGVyYXRpb25zKCkge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgaWYgKGN1cnJlbnRDb21taXRQcm9maWxpbmdNZXRhZGF0YSAhPSBudWxsICYmIGN1cnJlbnRDb21taXRQcm9maWxpbmdNZXRhZGF0YS5kdXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBlbmRpbmdPcGVyYXRpb25zLmxlbmd0aCA9PT0gMCAmJiBwZW5kaW5nUmVhbFVubW91bnRlZElEcy5sZW5ndGggPT09IDAgJiYgcGVuZGluZ1NpbXVsYXRlZFVubW91bnRlZElEcy5sZW5ndGggPT09IDAgJiYgcGVuZGluZ1VubW91bnRlZFJvb3RJRCA9PT0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoT3JRdWV1ZU9wZXJhdGlvbnMob3BlcmF0aW9ucykge1xuICAgIGlmIChzaG91bGRCYWlsb3V0V2l0aFBlbmRpbmdPcGVyYXRpb25zKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocGVuZGluZ09wZXJhdGlvbnNRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgcGVuZGluZ09wZXJhdGlvbnNRdWV1ZS5wdXNoKG9wZXJhdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBob29rLmVtaXQoJ29wZXJhdGlvbnMnLCBvcGVyYXRpb25zKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmx1c2hQZW5kaW5nRXJyb3JzQW5kV2FybmluZ3NBZnRlckRlbGF5VGltZW91dElEID0gbnVsbDtcblxuICBmdW5jdGlvbiBjbGVhclBlbmRpbmdFcnJvcnNBbmRXYXJuaW5nc0FmdGVyRGVsYXkoKSB7XG4gICAgaWYgKGZsdXNoUGVuZGluZ0Vycm9yc0FuZFdhcm5pbmdzQWZ0ZXJEZWxheVRpbWVvdXRJRCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGZsdXNoUGVuZGluZ0Vycm9yc0FuZFdhcm5pbmdzQWZ0ZXJEZWxheVRpbWVvdXRJRCk7XG4gICAgICBmbHVzaFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5nc0FmdGVyRGVsYXlUaW1lb3V0SUQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoUGVuZGluZ0Vycm9yc0FuZFdhcm5pbmdzQWZ0ZXJEZWxheSgpIHtcbiAgICBjbGVhclBlbmRpbmdFcnJvcnNBbmRXYXJuaW5nc0FmdGVyRGVsYXkoKTtcbiAgICBmbHVzaFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5nc0FmdGVyRGVsYXlUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGZsdXNoUGVuZGluZ0Vycm9yc0FuZFdhcm5pbmdzQWZ0ZXJEZWxheVRpbWVvdXRJRCA9IG51bGw7XG5cbiAgICAgIGlmIChwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIE9uIHRoZSBvZmYgY2hhbmNlIHRoYXQgc29tZXRoaW5nIGVsc2UgaGFzIHB1c2hlZCBwZW5kaW5nIG9wZXJhdGlvbnMsXG4gICAgICAgIC8vIHdlIHNob3VsZCBiYWlsIG9uIHdhcm5pbmdzOyBpdCdzIHByb2JhYmx5IG5vdCBzYWZlIHRvIHB1c2ggbWlkd2F5LlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlY29yZFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5ncygpO1xuXG4gICAgICBpZiAoc2hvdWxkQmFpbG91dFdpdGhQZW5kaW5nT3BlcmF0aW9ucygpKSB7XG4gICAgICAgIC8vIE5vIHdhcm5pbmdzIG9yIGVycm9ycyB0byBmbHVzaDsgd2UgY2FuIGJhaWwgb3V0IGVhcmx5IGhlcmUgdG9vLlxuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFdlIGNhbiBjcmVhdGUgYSBzbWFsbGVyIG9wZXJhdGlvbnMgYXJyYXkgdGhhbiBmbHVzaFBlbmRpbmdFdmVudHMoKVxuICAgICAgLy8gYmVjYXVzZSB3ZSBvbmx5IG5lZWQgdG8gZmx1c2ggd2FybmluZyBhbmQgZXJyb3IgY291bnRzLlxuICAgICAgLy8gT25seSBhIGZldyBwaWVjZXMgb2YgZml4ZWQgaW5mb3JtYXRpb24gYXJlIHJlcXVpcmVkIHVwIGZyb250LlxuXG5cbiAgICAgIHZhciBvcGVyYXRpb25zID0gbmV3IEFycmF5KDMgKyBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGgpO1xuICAgICAgb3BlcmF0aW9uc1swXSA9IHJlbmRlcmVySUQ7XG4gICAgICBvcGVyYXRpb25zWzFdID0gY3VycmVudFJvb3RJRDtcbiAgICAgIG9wZXJhdGlvbnNbMl0gPSAwOyAvLyBTdHJpbmcgdGFibGUgc2l6ZVxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBlbmRpbmdPcGVyYXRpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG9wZXJhdGlvbnNbMyArIGpdID0gcGVuZGluZ09wZXJhdGlvbnNbal07XG4gICAgICB9XG5cbiAgICAgIGZsdXNoT3JRdWV1ZU9wZXJhdGlvbnMob3BlcmF0aW9ucyk7XG4gICAgICBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGggPSAwO1xuICAgIH0sIDEwMDApO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVldmFsdWF0ZUVycm9yc0FuZFdhcm5pbmdzKCkge1xuICAgIGZpYmVyc1dpdGhDaGFuZ2VkRXJyb3JPcldhcm5pbmdDb3VudHMuY2xlYXIoKTtcbiAgICBmaWJlcklEVG9FcnJvcnNNYXAuZm9yRWFjaChmdW5jdGlvbiAoY291bnRNYXAsIGZpYmVySUQpIHtcbiAgICAgIHZhciBmaWJlciA9IGlkVG9BcmJpdHJhcnlGaWJlck1hcC5nZXQoZmliZXJJRCk7XG5cbiAgICAgIGlmIChmaWJlciAhPSBudWxsKSB7XG4gICAgICAgIGZpYmVyc1dpdGhDaGFuZ2VkRXJyb3JPcldhcm5pbmdDb3VudHMuYWRkKGZpYmVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmaWJlcklEVG9XYXJuaW5nc01hcC5mb3JFYWNoKGZ1bmN0aW9uIChjb3VudE1hcCwgZmliZXJJRCkge1xuICAgICAgdmFyIGZpYmVyID0gaWRUb0FyYml0cmFyeUZpYmVyTWFwLmdldChmaWJlcklEKTtcblxuICAgICAgaWYgKGZpYmVyICE9IG51bGwpIHtcbiAgICAgICAgZmliZXJzV2l0aENoYW5nZWRFcnJvck9yV2FybmluZ0NvdW50cy5hZGQoZmliZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJlY29yZFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5ncygpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VNYXBzQW5kR2V0Q291bnRIZWxwZXIoZmliZXIsIGZpYmVySUQsIHBlbmRpbmdGaWJlclRvTWVzc2FnZUNvdW50TWFwLCBmaWJlcklEVG9NZXNzYWdlQ291bnRNYXApIHtcbiAgICB2YXIgbmV3Q291bnQgPSAwO1xuICAgIHZhciBtZXNzYWdlQ291bnRNYXAgPSBmaWJlcklEVG9NZXNzYWdlQ291bnRNYXAuZ2V0KGZpYmVySUQpO1xuICAgIHZhciBwZW5kaW5nTWVzc2FnZUNvdW50TWFwID0gcGVuZGluZ0ZpYmVyVG9NZXNzYWdlQ291bnRNYXAuZ2V0KGZpYmVyKTtcblxuICAgIGlmIChwZW5kaW5nTWVzc2FnZUNvdW50TWFwICE9IG51bGwpIHtcbiAgICAgIGlmIChtZXNzYWdlQ291bnRNYXAgPT0gbnVsbCkge1xuICAgICAgICBtZXNzYWdlQ291bnRNYXAgPSBwZW5kaW5nTWVzc2FnZUNvdW50TWFwO1xuICAgICAgICBmaWJlcklEVG9NZXNzYWdlQ291bnRNYXAuc2V0KGZpYmVySUQsIHBlbmRpbmdNZXNzYWdlQ291bnRNYXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBGbG93IHJlZmluZW1lbnQgc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnkgYW5kIHlldC4uLlxuICAgICAgICB2YXIgcmVmaW5lZE1lc3NhZ2VDb3VudE1hcCA9IG1lc3NhZ2VDb3VudE1hcDtcbiAgICAgICAgcGVuZGluZ01lc3NhZ2VDb3VudE1hcC5mb3JFYWNoKGZ1bmN0aW9uIChwZW5kaW5nQ291bnQsIG1lc3NhZ2UpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXNDb3VudCA9IHJlZmluZWRNZXNzYWdlQ291bnRNYXAuZ2V0KG1lc3NhZ2UpIHx8IDA7XG4gICAgICAgICAgcmVmaW5lZE1lc3NhZ2VDb3VudE1hcC5zZXQobWVzc2FnZSwgcHJldmlvdXNDb3VudCArIHBlbmRpbmdDb3VudCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2hvdWxkRmlsdGVyRmliZXIoZmliZXIpKSB7XG4gICAgICBpZiAobWVzc2FnZUNvdW50TWFwICE9IG51bGwpIHtcbiAgICAgICAgbWVzc2FnZUNvdW50TWFwLmZvckVhY2goZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgICAgICAgbmV3Q291bnQgKz0gY291bnQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBlbmRpbmdGaWJlclRvTWVzc2FnZUNvdW50TWFwLmRlbGV0ZShmaWJlcik7XG4gICAgcmV0dXJuIG5ld0NvdW50O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkUGVuZGluZ0Vycm9yc0FuZFdhcm5pbmdzKCkge1xuICAgIGNsZWFyUGVuZGluZ0Vycm9yc0FuZFdhcm5pbmdzQWZ0ZXJEZWxheSgpO1xuICAgIGZpYmVyc1dpdGhDaGFuZ2VkRXJyb3JPcldhcm5pbmdDb3VudHMuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIHZhciBmaWJlcklEID0gZ2V0RmliZXJJRFVuc2FmZShmaWJlcik7XG5cbiAgICAgIGlmIChmaWJlcklEID09PSBudWxsKSB7Ly8gRG9uJ3Qgc2VuZCB1cGRhdGVzIGZvciBGaWJlcnMgdGhhdCBkaWRuJ3QgbW91bnQgZHVlIHRvIGUuZy4gU3VzcGVuc2Ugb3IgYW4gZXJyb3IgYm91bmRhcnkuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXJyb3JDb3VudCA9IG1lcmdlTWFwc0FuZEdldENvdW50SGVscGVyKGZpYmVyLCBmaWJlcklELCBwZW5kaW5nRmliZXJUb0Vycm9yc01hcCwgZmliZXJJRFRvRXJyb3JzTWFwKTtcbiAgICAgICAgdmFyIHdhcm5pbmdDb3VudCA9IG1lcmdlTWFwc0FuZEdldENvdW50SGVscGVyKGZpYmVyLCBmaWJlcklELCBwZW5kaW5nRmliZXJUb1dhcm5pbmdzTWFwLCBmaWJlcklEVG9XYXJuaW5nc01hcCk7XG4gICAgICAgIHB1c2hPcGVyYXRpb24oY29uc3RhbnRzW1wicVwiIC8qIFRSRUVfT1BFUkFUSU9OX1VQREFURV9FUlJPUlNfT1JfV0FSTklOR1MgKi9dKTtcbiAgICAgICAgcHVzaE9wZXJhdGlvbihmaWJlcklEKTtcbiAgICAgICAgcHVzaE9wZXJhdGlvbihlcnJvckNvdW50KTtcbiAgICAgICAgcHVzaE9wZXJhdGlvbih3YXJuaW5nQ291bnQpO1xuICAgICAgfSAvLyBBbHdheXMgY2xlYW4gdXAgc28gdGhhdCB3ZSBkb24ndCBsZWFrLlxuXG5cbiAgICAgIHBlbmRpbmdGaWJlclRvRXJyb3JzTWFwLmRlbGV0ZShmaWJlcik7XG4gICAgICBwZW5kaW5nRmliZXJUb1dhcm5pbmdzTWFwLmRlbGV0ZShmaWJlcik7XG4gICAgfSk7XG4gICAgZmliZXJzV2l0aENoYW5nZWRFcnJvck9yV2FybmluZ0NvdW50cy5jbGVhcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2hQZW5kaW5nRXZlbnRzKHJvb3QpIHtcbiAgICAvLyBBZGQgYW55IHBlbmRpbmcgZXJyb3JzIGFuZCB3YXJuaW5ncyB0byB0aGUgb3BlcmF0aW9ucyBhcnJheS5cbiAgICAvLyBXZSBkbyB0aGlzIGp1c3QgYmVmb3JlIGZsdXNoaW5nLCBzbyB3ZSBjYW4gaWdub3JlIGVycm9ycyBmb3Igbm8tbG9uZ2VyLW1vdW50ZWQgRmliZXJzLlxuICAgIHJlY29yZFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5ncygpO1xuXG4gICAgaWYgKHNob3VsZEJhaWxvdXRXaXRoUGVuZGluZ09wZXJhdGlvbnMoKSkge1xuICAgICAgLy8gSWYgd2UgYXJlbid0IHByb2ZpbGluZywgd2UgY2FuIGp1c3QgYmFpbCBvdXQgaGVyZS5cbiAgICAgIC8vIE5vIHVzZSBzZW5kaW5nIGFuIGVtcHR5IHVwZGF0ZSBvdmVyIHRoZSBicmlkZ2UuXG4gICAgICAvL1xuICAgICAgLy8gVGhlIFByb2ZpbGVyIHN0b3JlcyBtZXRhZGF0YSBmb3IgZWFjaCBjb21taXQgYW5kIHJlY29uc3RydWN0cyB0aGUgYXBwIHRyZWUgcGVyIGNvbW1pdCB1c2luZzpcbiAgICAgIC8vICgxKSBhbiBpbml0aWFsIHRyZWUgc25hcHNob3QgYW5kXG4gICAgICAvLyAoMikgdGhlIG9wZXJhdGlvbnMgYXJyYXkgZm9yIGVhY2ggY29tbWl0XG4gICAgICAvLyBCZWNhdXNlIG9mIHRoaXMsIGl0J3MgaW1wb3J0YW50IHRoYXQgdGhlIG9wZXJhdGlvbnMgYW5kIG1ldGFkYXRhIGFycmF5cyBhbGlnbixcbiAgICAgIC8vIFNvIGl0J3MgaW1wb3J0YW50IG5vdCB0byBvbWl0IGV2ZW4gZW1wdHkgb3BlcmF0aW9ucyB3aGlsZSBwcm9maWxpbmcgaXMgYWN0aXZlLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBudW1Vbm1vdW50SURzID0gcGVuZGluZ1JlYWxVbm1vdW50ZWRJRHMubGVuZ3RoICsgcGVuZGluZ1NpbXVsYXRlZFVubW91bnRlZElEcy5sZW5ndGggKyAocGVuZGluZ1VubW91bnRlZFJvb3RJRCA9PT0gbnVsbCA/IDAgOiAxKTtcbiAgICB2YXIgb3BlcmF0aW9ucyA9IG5ldyBBcnJheSggLy8gSWRlbnRpZnkgd2hpY2ggcmVuZGVyZXIgdGhpcyB1cGRhdGUgaXMgY29taW5nIGZyb20uXG4gICAgMiArIC8vIFtyZW5kZXJlcklELCByb290RmliZXJJRF1cbiAgICAvLyBIb3cgYmlnIGlzIHRoZSBzdHJpbmcgdGFibGU/XG4gICAgMSArIC8vIFtzdHJpbmdUYWJsZUxlbmd0aF1cbiAgICAvLyBUaGVuIGdvZXMgdGhlIGFjdHVhbCBzdHJpbmcgdGFibGUuXG4gICAgcGVuZGluZ1N0cmluZ1RhYmxlTGVuZ3RoICsgKCAvLyBBbGwgdW5tb3VudHMgYXJlIGJhdGNoZWQgaW4gYSBzaW5nbGUgbWVzc2FnZS5cbiAgICAvLyBbVFJFRV9PUEVSQVRJT05fUkVNT1ZFLCByZW1vdmVkSURMZW5ndGgsIC4uLmlkc11cbiAgICBudW1Vbm1vdW50SURzID4gMCA/IDIgKyBudW1Vbm1vdW50SURzIDogMCkgKyAvLyBSZWd1bGFyIG9wZXJhdGlvbnNcbiAgICBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGgpOyAvLyBJZGVudGlmeSB3aGljaCByZW5kZXJlciB0aGlzIHVwZGF0ZSBpcyBjb21pbmcgZnJvbS5cbiAgICAvLyBUaGlzIGVuYWJsZXMgcm9vdHMgdG8gYmUgbWFwcGVkIHRvIHJlbmRlcmVycyxcbiAgICAvLyBXaGljaCBpbiB0dXJuIGVuYWJsZXMgZmliZXIgcHJvcHMsIHN0YXRlcywgYW5kIGhvb2tzIHRvIGJlIGluc3BlY3RlZC5cblxuICAgIHZhciBpID0gMDtcbiAgICBvcGVyYXRpb25zW2krK10gPSByZW5kZXJlcklEO1xuICAgIG9wZXJhdGlvbnNbaSsrXSA9IGN1cnJlbnRSb290SUQ7IC8vIE5vdyBmaWxsIGluIHRoZSBzdHJpbmcgdGFibGUuXG4gICAgLy8gW3N0cmluZ1RhYmxlTGVuZ3RoLCBzdHIxTGVuZ3RoLCAuLi5zdHIxLCBzdHIyTGVuZ3RoLCAuLi5zdHIyLCAuLi5dXG5cbiAgICBvcGVyYXRpb25zW2krK10gPSBwZW5kaW5nU3RyaW5nVGFibGVMZW5ndGg7XG4gICAgcGVuZGluZ1N0cmluZ1RhYmxlLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5LCBzdHJpbmdLZXkpIHtcbiAgICAgIHZhciBlbmNvZGVkU3RyaW5nID0gZW50cnkuZW5jb2RlZFN0cmluZzsgLy8gRG9uJ3QgdXNlIHRoZSBzdHJpbmcgbGVuZ3RoLlxuICAgICAgLy8gSXQgd29uJ3Qgd29yayBmb3IgbXVsdGlieXRlIGNoYXJhY3RlcnMgKGxpa2UgZW1vamkpLlxuXG4gICAgICB2YXIgbGVuZ3RoID0gZW5jb2RlZFN0cmluZy5sZW5ndGg7XG4gICAgICBvcGVyYXRpb25zW2krK10gPSBsZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcbiAgICAgICAgb3BlcmF0aW9uc1tpICsgal0gPSBlbmNvZGVkU3RyaW5nW2pdO1xuICAgICAgfVxuXG4gICAgICBpICs9IGxlbmd0aDtcbiAgICB9KTtcblxuICAgIGlmIChudW1Vbm1vdW50SURzID4gMCkge1xuICAgICAgLy8gQWxsIHVubW91bnRzIGV4Y2VwdCByb290cyBhcmUgYmF0Y2hlZCBpbiBhIHNpbmdsZSBtZXNzYWdlLlxuICAgICAgb3BlcmF0aW9uc1tpKytdID0gY29uc3RhbnRzW1wibVwiIC8qIFRSRUVfT1BFUkFUSU9OX1JFTU9WRSAqL107IC8vIFRoZSBmaXJzdCBudW1iZXIgaXMgaG93IG1hbnkgdW5tb3VudGVkIElEcyB3ZSdyZSBnb25uYSBzZW5kLlxuXG4gICAgICBvcGVyYXRpb25zW2krK10gPSBudW1Vbm1vdW50SURzOyAvLyBGaWxsIGluIHRoZSByZWFsIHVubW91bnRzIGluIHRoZSByZXZlcnNlIG9yZGVyLlxuICAgICAgLy8gVGhleSB3ZXJlIGluc2VydGVkIHBhcmVudHMtZmlyc3QgYnkgUmVhY3QsIGJ1dCB3ZSB3YW50IGNoaWxkcmVuLWZpcnN0LlxuICAgICAgLy8gU28gd2UgdHJhdmVyc2Ugb3VyIGFycmF5IGJhY2t3YXJkcy5cblxuICAgICAgZm9yICh2YXIgaiA9IHBlbmRpbmdSZWFsVW5tb3VudGVkSURzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIG9wZXJhdGlvbnNbaSsrXSA9IHBlbmRpbmdSZWFsVW5tb3VudGVkSURzW2pdO1xuICAgICAgfSAvLyBGaWxsIGluIHRoZSBzaW11bGF0ZWQgdW5tb3VudHMgKGhpZGRlbiBTdXNwZW5zZSBzdWJ0cmVlcykgaW4gdGhlaXIgb3JkZXIuXG4gICAgICAvLyAoV2Ugd2FudCBjaGlsZHJlbiB0byBnbyBiZWZvcmUgcGFyZW50cy4pXG4gICAgICAvLyBUaGV5IGdvICphZnRlciogdGhlIHJlYWwgdW5tb3VudHMgYmVjYXVzZSB3ZSBrbm93IGZvciBzdXJlIHRoZXkgd29uJ3QgYmVcbiAgICAgIC8vIGNoaWxkcmVuIG9mIGFscmVhZHkgcHVzaGVkIFwicmVhbFwiIElEcy4gSWYgdGhleSB3ZXJlLCB3ZSB3b3VsZG4ndCBiZSBhYmxlXG4gICAgICAvLyB0byBkaXNjb3ZlciB0aGVtIGR1cmluZyB0aGUgdHJhdmVyc2FsLCBhcyB0aGV5IHdvdWxkIGhhdmUgYmVlbiBkZWxldGVkLlxuXG5cbiAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBwZW5kaW5nU2ltdWxhdGVkVW5tb3VudGVkSURzLmxlbmd0aDsgX2orKykge1xuICAgICAgICBvcGVyYXRpb25zW2kgKyBfal0gPSBwZW5kaW5nU2ltdWxhdGVkVW5tb3VudGVkSURzW19qXTtcbiAgICAgIH1cblxuICAgICAgaSArPSBwZW5kaW5nU2ltdWxhdGVkVW5tb3VudGVkSURzLmxlbmd0aDsgLy8gVGhlIHJvb3QgSUQgc2hvdWxkIGFsd2F5cyBiZSB1bm1vdW50ZWQgbGFzdC5cblxuICAgICAgaWYgKHBlbmRpbmdVbm1vdW50ZWRSb290SUQgIT09IG51bGwpIHtcbiAgICAgICAgb3BlcmF0aW9uc1tpXSA9IHBlbmRpbmdVbm1vdW50ZWRSb290SUQ7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9IC8vIEZpbGwgaW4gdGhlIHJlc3Qgb2YgdGhlIG9wZXJhdGlvbnMuXG5cblxuICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IHBlbmRpbmdPcGVyYXRpb25zLmxlbmd0aDsgX2oyKyspIHtcbiAgICAgIG9wZXJhdGlvbnNbaSArIF9qMl0gPSBwZW5kaW5nT3BlcmF0aW9uc1tfajJdO1xuICAgIH1cblxuICAgIGkgKz0gcGVuZGluZ09wZXJhdGlvbnMubGVuZ3RoOyAvLyBMZXQgdGhlIGZyb250ZW5kIGtub3cgYWJvdXQgdHJlZSBvcGVyYXRpb25zLlxuXG4gICAgZmx1c2hPclF1ZXVlT3BlcmF0aW9ucyhvcGVyYXRpb25zKTsgLy8gUmVzZXQgYWxsIG9mIHRoZSBwZW5kaW5nIHN0YXRlIG5vdyB0aGF0IHdlJ3ZlIHRvbGQgdGhlIGZyb250ZW5kIGFib3V0IGl0LlxuXG4gICAgcGVuZGluZ09wZXJhdGlvbnMubGVuZ3RoID0gMDtcbiAgICBwZW5kaW5nUmVhbFVubW91bnRlZElEcy5sZW5ndGggPSAwO1xuICAgIHBlbmRpbmdTaW11bGF0ZWRVbm1vdW50ZWRJRHMubGVuZ3RoID0gMDtcbiAgICBwZW5kaW5nVW5tb3VudGVkUm9vdElEID0gbnVsbDtcbiAgICBwZW5kaW5nU3RyaW5nVGFibGUuY2xlYXIoKTtcbiAgICBwZW5kaW5nU3RyaW5nVGFibGVMZW5ndGggPSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U3RyaW5nSUQoc3RyaW5nKSB7XG4gICAgaWYgKHN0cmluZyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIGV4aXN0aW5nRW50cnkgPSBwZW5kaW5nU3RyaW5nVGFibGUuZ2V0KHN0cmluZyk7XG5cbiAgICBpZiAoZXhpc3RpbmdFbnRyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXhpc3RpbmdFbnRyeS5pZDtcbiAgICB9XG5cbiAgICB2YXIgaWQgPSBwZW5kaW5nU3RyaW5nVGFibGUuc2l6ZSArIDE7XG4gICAgdmFyIGVuY29kZWRTdHJpbmcgPSBPYmplY3QodXRpbHNbXCJwXCIgLyogdXRmRW5jb2RlU3RyaW5nICovXSkoc3RyaW5nKTtcbiAgICBwZW5kaW5nU3RyaW5nVGFibGUuc2V0KHN0cmluZywge1xuICAgICAgZW5jb2RlZFN0cmluZzogZW5jb2RlZFN0cmluZyxcbiAgICAgIGlkOiBpZFxuICAgIH0pOyAvLyBUaGUgc3RyaW5nIHRhYmxlIHRvdGFsIGxlbmd0aCBuZWVkcyB0byBhY2NvdW50IGJvdGggZm9yIHRoZSBzdHJpbmcgbGVuZ3RoLFxuICAgIC8vIGFuZCBmb3IgdGhlIGFycmF5IGl0ZW0gdGhhdCBjb250YWlucyB0aGUgbGVuZ3RoIGl0c2VsZi5cbiAgICAvL1xuICAgIC8vIERvbid0IHVzZSBzdHJpbmcgbGVuZ3RoIGZvciB0aGlzIHRhYmxlLlxuICAgIC8vIEl0IHdvbid0IHdvcmsgZm9yIG11bHRpYnl0ZSBjaGFyYWN0ZXJzIChsaWtlIGVtb2ppKS5cblxuICAgIHBlbmRpbmdTdHJpbmdUYWJsZUxlbmd0aCArPSBlbmNvZGVkU3RyaW5nLmxlbmd0aCArIDE7XG4gICAgcmV0dXJuIGlkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkTW91bnQoZmliZXIsIHBhcmVudEZpYmVyKSB7XG4gICAgdmFyIGlzUm9vdCA9IGZpYmVyLnRhZyA9PT0gSG9zdFJvb3Q7XG4gICAgdmFyIGlkID0gZ2V0T3JHZW5lcmF0ZUZpYmVySUQoZmliZXIpO1xuXG4gICAgaWYgKGNvbnN0YW50c1tcInNcIiAvKiBfX0RFQlVHX18gKi9dKSB7XG4gICAgICBkZWJ1ZygncmVjb3JkTW91bnQoKScsIGZpYmVyLCBwYXJlbnRGaWJlcik7XG4gICAgfVxuXG4gICAgdmFyIGhhc093bmVyTWV0YWRhdGEgPSBmaWJlci5oYXNPd25Qcm9wZXJ0eSgnX2RlYnVnT3duZXInKTtcbiAgICB2YXIgaXNQcm9maWxpbmdTdXBwb3J0ZWQgPSBmaWJlci5oYXNPd25Qcm9wZXJ0eSgndHJlZUJhc2VEdXJhdGlvbicpOyAvLyBBZGRpbmcgYSBuZXcgZmllbGQgaGVyZSB3b3VsZCByZXF1aXJlIGEgYnJpZGdlIHByb3RvY29sIHZlcnNpb24gYnVtcCAoYSBiYWNrd2FkcyBicmVha2luZyBjaGFuZ2UpLlxuICAgIC8vIEluc3RlYWQgbGV0J3MgcmUtcHVycG9zZSBhIHByZS1leGlzdGluZyBmaWVsZCB0byBjYXJyeSBtb3JlIGluZm9ybWF0aW9uLlxuXG4gICAgdmFyIHByb2ZpbGluZ0ZsYWdzID0gMDtcblxuICAgIGlmIChpc1Byb2ZpbGluZ1N1cHBvcnRlZCkge1xuICAgICAgcHJvZmlsaW5nRmxhZ3MgPSBjb25zdGFudHNbXCJnXCIgLyogUFJPRklMSU5HX0ZMQUdfQkFTSUNfU1VQUE9SVCAqL107XG5cbiAgICAgIGlmICh0eXBlb2YgaW5qZWN0UHJvZmlsaW5nSG9va3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvZmlsaW5nRmxhZ3MgfD0gY29uc3RhbnRzW1wiaFwiIC8qIFBST0ZJTElOR19GTEFHX1RJTUVMSU5FX1NVUFBPUlQgKi9dO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgIHB1c2hPcGVyYXRpb24oY29uc3RhbnRzW1wibFwiIC8qIFRSRUVfT1BFUkFUSU9OX0FERCAqL10pO1xuICAgICAgcHVzaE9wZXJhdGlvbihpZCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKHR5cGVzW1wibVwiIC8qIEVsZW1lbnRUeXBlUm9vdCAqL10pO1xuICAgICAgcHVzaE9wZXJhdGlvbigoZmliZXIubW9kZSAmIFN0cmljdE1vZGVCaXRzKSAhPT0gMCA/IDEgOiAwKTtcbiAgICAgIHB1c2hPcGVyYXRpb24ocHJvZmlsaW5nRmxhZ3MpO1xuICAgICAgcHVzaE9wZXJhdGlvbihTdHJpY3RNb2RlQml0cyAhPT0gMCA/IDEgOiAwKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oaGFzT3duZXJNZXRhZGF0YSA/IDEgOiAwKTtcblxuICAgICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICAgIGlmIChkaXNwbGF5TmFtZXNCeVJvb3RJRCAhPT0gbnVsbCkge1xuICAgICAgICAgIGRpc3BsYXlOYW1lc0J5Um9vdElELnNldChpZCwgZ2V0RGlzcGxheU5hbWVGb3JSb290KGZpYmVyKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleSA9IGZpYmVyLmtleTtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIGVsZW1lbnRUeXBlID0gZ2V0RWxlbWVudFR5cGVGb3JGaWJlcihmaWJlcik7XG4gICAgICB2YXIgX2RlYnVnT3duZXIgPSBmaWJlci5fZGVidWdPd25lcjsgLy8gSWRlYWxseSB3ZSBzaG91bGQgY2FsbCBnZXRGaWJlcklEVGhyb3dzKCkgZm9yIF9kZWJ1Z093bmVyLFxuICAgICAgLy8gc2luY2Ugb3duZXJzIGFyZSBhbG1vc3QgYWx3YXlzIGhpZ2hlciBpbiB0aGUgdHJlZSAoYW5kIHNvIGhhdmUgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCksXG4gICAgICAvLyBidXQgaW4gc29tZSAocmFyZSkgaW5zdGFuY2VzIHJlcG9ydGVkIGluIG9wZW4gc291cmNlLCBhIGRlc2NlbmRhbnQgbW91bnRzIGJlZm9yZSBhbiBvd25lci5cbiAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSBERVYgb25seSBmaWVsZCBpdCdzIHByb2JhYmx5IG9rYXkgdG8gYWxzbyBqdXN0IGxhemlseSBnZW5lcmF0ZSBhbmQgSUQgaGVyZSBpZiBuZWVkZWQuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMTQ0NVxuXG4gICAgICB2YXIgb3duZXJJRCA9IF9kZWJ1Z093bmVyICE9IG51bGwgPyBnZXRPckdlbmVyYXRlRmliZXJJRChfZGVidWdPd25lcikgOiAwO1xuICAgICAgdmFyIHBhcmVudElEID0gcGFyZW50RmliZXIgPyBnZXRGaWJlcklEVGhyb3dzKHBhcmVudEZpYmVyKSA6IDA7XG4gICAgICB2YXIgZGlzcGxheU5hbWVTdHJpbmdJRCA9IGdldFN0cmluZ0lEKGRpc3BsYXlOYW1lKTsgLy8gVGhpcyBjaGVjayBpcyBhIGd1YXJkIHRvIGhhbmRsZSBhIFJlYWN0IGVsZW1lbnQgdGhhdCBoYXMgYmVlbiBtb2RpZmllZFxuICAgICAgLy8gaW4gc3VjaCBhIHdheSBhcyB0byBieXBhc3MgdGhlIGRlZmF1bHQgc3RyaW5naWZpY2F0aW9uIG9mIHRoZSBcImtleVwiIHByb3BlcnR5LlxuXG4gICAgICB2YXIga2V5U3RyaW5nID0ga2V5ID09PSBudWxsID8gbnVsbCA6IFN0cmluZyhrZXkpO1xuICAgICAgdmFyIGtleVN0cmluZ0lEID0gZ2V0U3RyaW5nSUQoa2V5U3RyaW5nKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oY29uc3RhbnRzW1wibFwiIC8qIFRSRUVfT1BFUkFUSU9OX0FERCAqL10pO1xuICAgICAgcHVzaE9wZXJhdGlvbihpZCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKGVsZW1lbnRUeXBlKTtcbiAgICAgIHB1c2hPcGVyYXRpb24ocGFyZW50SUQpO1xuICAgICAgcHVzaE9wZXJhdGlvbihvd25lcklEKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oZGlzcGxheU5hbWVTdHJpbmdJRCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKGtleVN0cmluZ0lEKTsgLy8gSWYgdGhpcyBzdWJ0cmVlIGhhcyBhIG5ldyBtb2RlLCBsZXQgdGhlIGZyb250ZW5kIGtub3cuXG5cbiAgICAgIGlmICgoZmliZXIubW9kZSAmIFN0cmljdE1vZGVCaXRzKSAhPT0gMCAmJiAocGFyZW50RmliZXIubW9kZSAmIFN0cmljdE1vZGVCaXRzKSA9PT0gMCkge1xuICAgICAgICBwdXNoT3BlcmF0aW9uKGNvbnN0YW50c1tcInBcIiAvKiBUUkVFX09QRVJBVElPTl9TRVRfU1VCVFJFRV9NT0RFICovXSk7XG4gICAgICAgIHB1c2hPcGVyYXRpb24oaWQpO1xuICAgICAgICBwdXNoT3BlcmF0aW9uKHR5cGVzW1wicVwiIC8qIFN0cmljdE1vZGUgKi9dKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNQcm9maWxpbmdTdXBwb3J0ZWQpIHtcbiAgICAgIGlkVG9Sb290TWFwLnNldChpZCwgY3VycmVudFJvb3RJRCk7XG4gICAgICByZWNvcmRQcm9maWxpbmdEdXJhdGlvbnMoZmliZXIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZFVubW91bnQoZmliZXIsIGlzU2ltdWxhdGVkKSB7XG4gICAgaWYgKGNvbnN0YW50c1tcInNcIiAvKiBfX0RFQlVHX18gKi9dKSB7XG4gICAgICBkZWJ1ZygncmVjb3JkVW5tb3VudCgpJywgZmliZXIsIG51bGwsIGlzU2ltdWxhdGVkID8gJ3VubW91bnQgaXMgc2ltdWxhdGVkJyA6ICcnKTtcbiAgICB9XG5cbiAgICBpZiAodHJhY2tlZFBhdGhNYXRjaEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAvLyBXZSdyZSBpbiB0aGUgcHJvY2VzcyBvZiB0cnlpbmcgdG8gcmVzdG9yZSBwcmV2aW91cyBzZWxlY3Rpb24uXG4gICAgICAvLyBJZiB0aGlzIGZpYmVyIG1hdGNoZWQgYnV0IGlzIGJlaW5nIHVubW91bnRlZCwgdGhlcmUncyBubyB1c2UgdHJ5aW5nLlxuICAgICAgLy8gUmVzZXQgdGhlIHN0YXRlIHNvIHdlIGRvbid0IGtlZXAgaG9sZGluZyBvbnRvIGl0LlxuICAgICAgaWYgKGZpYmVyID09PSB0cmFja2VkUGF0aE1hdGNoRmliZXIgfHwgZmliZXIgPT09IHRyYWNrZWRQYXRoTWF0Y2hGaWJlci5hbHRlcm5hdGUpIHtcbiAgICAgICAgc2V0VHJhY2tlZFBhdGgobnVsbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuc2FmZUlEID0gZ2V0RmliZXJJRFVuc2FmZShmaWJlcik7XG5cbiAgICBpZiAodW5zYWZlSUQgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlJ3ZlIG5ldmVyIHNlZW4gdGhpcyBGaWJlciwgaXQgbWlnaHQgYmUgaW5zaWRlIG9mIGEgbGVnYWN5IHJlbmRlciBTdXNwZW5zZSBmcmFnbWVudCAoc28gdGhlIHN0b3JlIGlzIG5vdCBldmVuIGF3YXJlIG9mIGl0KS5cbiAgICAgIC8vIEluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCBpZ25vcmUgaXQgb3IgaXQgd2lsbCBjYXVzZSBlcnJvcnMgbGF0ZXIgb24uXG4gICAgICAvLyBPbmUgZXhhbXBsZSBvZiB0aGlzIGlzIGEgTGF6eSBjb21wb25lbnQgdGhhdCBuZXZlciByZXNvbHZlcyBiZWZvcmUgYmVpbmcgdW5tb3VudGVkLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgYWxzbyBtaWdodCBpbmRpY2F0ZSBhIEZhc3QgUmVmcmVzaCBmb3JjZS1yZW1vdW50IHNjZW5hcmlvLlxuICAgICAgLy9cbiAgICAgIC8vIFRPRE86IFRoaXMgaXMgZnJhZ2lsZSBhbmQgY2FuIG9ic2N1cmUgYWN0dWFsIGJ1Z3MuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGbG93IHJlZmluZW1lbnQuXG5cblxuICAgIHZhciBpZCA9IHVuc2FmZUlEO1xuICAgIHZhciBpc1Jvb3QgPSBmaWJlci50YWcgPT09IEhvc3RSb290O1xuXG4gICAgaWYgKGlzUm9vdCkge1xuICAgICAgLy8gUm9vdHMgbXVzdCBiZSByZW1vdmVkIG9ubHkgYWZ0ZXIgYWxsIGNoaWxkcmVuIChwZW5kaW5nIGFuZCBzaW11bGF0ZWQpIGhhdmUgYmVlbiByZW1vdmVkLlxuICAgICAgLy8gU28gd2UgdHJhY2sgaXQgc2VwYXJhdGVseS5cbiAgICAgIHBlbmRpbmdVbm1vdW50ZWRSb290SUQgPSBpZDtcbiAgICB9IGVsc2UgaWYgKCFzaG91bGRGaWx0ZXJGaWJlcihmaWJlcikpIHtcbiAgICAgIC8vIFRvIG1haW50YWluIGNoaWxkLWZpcnN0IG9yZGVyaW5nLFxuICAgICAgLy8gd2UnbGwgcHVzaCBpdCBpbnRvIG9uZSBvZiB0aGVzZSBxdWV1ZXMsXG4gICAgICAvLyBhbmQgbGF0ZXIgYXJyYW5nZSB0aGVtIGluIHRoZSBjb3JyZWN0IG9yZGVyLlxuICAgICAgaWYgKGlzU2ltdWxhdGVkKSB7XG4gICAgICAgIHBlbmRpbmdTaW11bGF0ZWRVbm1vdW50ZWRJRHMucHVzaChpZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZW5kaW5nUmVhbFVubW91bnRlZElEcy5wdXNoKGlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWZpYmVyLl9kZWJ1Z05lZWRzUmVtb3VudCkge1xuICAgICAgdW50cmFja0ZpYmVySUQoZmliZXIpO1xuICAgICAgdmFyIGlzUHJvZmlsaW5nU3VwcG9ydGVkID0gZmliZXIuaGFzT3duUHJvcGVydHkoJ3RyZWVCYXNlRHVyYXRpb24nKTtcblxuICAgICAgaWYgKGlzUHJvZmlsaW5nU3VwcG9ydGVkKSB7XG4gICAgICAgIGlkVG9Sb290TWFwLmRlbGV0ZShpZCk7XG4gICAgICAgIGlkVG9UcmVlQmFzZUR1cmF0aW9uTWFwLmRlbGV0ZShpZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW91bnRGaWJlclJlY3Vyc2l2ZWx5KGZpcnN0Q2hpbGQsIHBhcmVudEZpYmVyLCB0cmF2ZXJzZVNpYmxpbmdzLCB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIHNpYmxpbmdzIHJhdGhlciB0aGFuIHJlY3Vyc2luZy5cbiAgICAvLyBUaGlzIHJlZHVjZXMgdGhlIGNoYW5jZSBvZiBzdGFjayBvdmVyZmxvdyBmb3Igd2lkZSB0cmVlcyAoZS5nLiBsaXN0cyB3aXRoIG1hbnkgaXRlbXMpLlxuICAgIHZhciBmaWJlciA9IGZpcnN0Q2hpbGQ7XG5cbiAgICB3aGlsZSAoZmliZXIgIT09IG51bGwpIHtcbiAgICAgIC8vIEdlbmVyYXRlIGFuIElEIGV2ZW4gZm9yIGZpbHRlcmVkIEZpYmVycywgaW4gY2FzZSBpdCdzIG5lZWRlZCBsYXRlciAoZS5nLiBmb3IgUHJvZmlsaW5nKS5cbiAgICAgIGdldE9yR2VuZXJhdGVGaWJlcklEKGZpYmVyKTtcblxuICAgICAgaWYgKGNvbnN0YW50c1tcInNcIiAvKiBfX0RFQlVHX18gKi9dKSB7XG4gICAgICAgIGRlYnVnKCdtb3VudEZpYmVyUmVjdXJzaXZlbHkoKScsIGZpYmVyLCBwYXJlbnRGaWJlcik7XG4gICAgICB9IC8vIElmIHdlIGhhdmUgdGhlIHRyZWUgc2VsZWN0aW9uIGZyb20gcHJldmlvdXMgcmVsb2FkLCB0cnkgdG8gbWF0Y2ggdGhpcyBGaWJlci5cbiAgICAgIC8vIEFsc28gcmVtZW1iZXIgd2hldGhlciB0byBkbyB0aGUgc2FtZSBmb3Igc2libGluZ3MuXG5cblxuICAgICAgdmFyIG1pZ2h0U2libGluZ3NCZU9uVHJhY2tlZFBhdGggPSB1cGRhdGVUcmFja2VkUGF0aFN0YXRlQmVmb3JlTW91bnQoZmliZXIpO1xuICAgICAgdmFyIHNob3VsZEluY2x1ZGVJblRyZWUgPSAhc2hvdWxkRmlsdGVyRmliZXIoZmliZXIpO1xuXG4gICAgICBpZiAoc2hvdWxkSW5jbHVkZUluVHJlZSkge1xuICAgICAgICByZWNvcmRNb3VudChmaWJlciwgcGFyZW50RmliZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhY2VVcGRhdGVzRW5hYmxlZCkge1xuICAgICAgICBpZiAodHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSkge1xuICAgICAgICAgIHZhciBlbGVtZW50VHlwZSA9IGdldEVsZW1lbnRUeXBlRm9yRmliZXIoZmliZXIpOyAvLyBJZiBhbiBhbmNlc3RvciB1cGRhdGVkLCB3ZSBzaG91bGQgbWFyayB0aGUgbmVhcmVzdCBob3N0IG5vZGVzIGZvciBoaWdobGlnaHRpbmcuXG5cbiAgICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09IHR5cGVzW1wiaVwiIC8qIEVsZW1lbnRUeXBlSG9zdENvbXBvbmVudCAqL10pIHtcbiAgICAgICAgICAgIHRyYWNlVXBkYXRlc0Zvck5vZGVzLmFkZChmaWJlci5zdGF0ZU5vZGUpO1xuICAgICAgICAgICAgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBXZSBpbnRlbnRpb25hbGx5IGRvIG5vdCByZS1lbmFibGUgdGhlIHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUgZmxhZyBpbiB0aGlzIGJyYW5jaCxcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGhpZ2hsaWdodCBldmVyeSBob3N0IG5vZGUgaW5zaWRlIG9mIGEgbmV3bHkgbW91bnRlZCBzdWJ0cmVlLlxuXG4gICAgICB9XG5cbiAgICAgIHZhciBpc1N1c3BlbnNlID0gZmliZXIudGFnID09PSBSZWFjdFR5cGVPZldvcmsuU3VzcGVuc2VDb21wb25lbnQ7XG5cbiAgICAgIGlmIChpc1N1c3BlbnNlKSB7XG4gICAgICAgIHZhciBpc1RpbWVkT3V0ID0gZmliZXIubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICBpZiAoaXNUaW1lZE91dCkge1xuICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZTogaWYgU3VzcGVuc2UgbW91bnRzIGluIGEgdGltZWQtb3V0IHN0YXRlLFxuICAgICAgICAgIC8vIGdldCB0aGUgZmFsbGJhY2sgY2hpbGQgZnJvbSB0aGUgaW5uZXIgZnJhZ21lbnQgYW5kIG1vdW50XG4gICAgICAgICAgLy8gaXQgYXMgaWYgaXQgd2FzIG91ciBvd24gY2hpbGQuIFVwZGF0ZXMgaGFuZGxlIHRoaXMgdG9vLlxuICAgICAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGZpYmVyLmNoaWxkO1xuICAgICAgICAgIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudCA/IHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgOiBudWxsO1xuICAgICAgICAgIHZhciBmYWxsYmFja0NoaWxkID0gZmFsbGJhY2tDaGlsZEZyYWdtZW50ID8gZmFsbGJhY2tDaGlsZEZyYWdtZW50LmNoaWxkIDogbnVsbDtcblxuICAgICAgICAgIGlmIChmYWxsYmFja0NoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtb3VudEZpYmVyUmVjdXJzaXZlbHkoZmFsbGJhY2tDaGlsZCwgc2hvdWxkSW5jbHVkZUluVHJlZSA/IGZpYmVyIDogcGFyZW50RmliZXIsIHRydWUsIHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJpbWFyeUNoaWxkID0gbnVsbDtcbiAgICAgICAgICB2YXIgYXJlU3VzcGVuc2VDaGlsZHJlbkNvbmRpdGlvbmFsbHlXcmFwcGVkID0gT2Zmc2NyZWVuQ29tcG9uZW50ID09PSAtMTtcblxuICAgICAgICAgIGlmIChhcmVTdXNwZW5zZUNoaWxkcmVuQ29uZGl0aW9uYWxseVdyYXBwZWQpIHtcbiAgICAgICAgICAgIHByaW1hcnlDaGlsZCA9IGZpYmVyLmNoaWxkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZmliZXIuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHByaW1hcnlDaGlsZCA9IGZpYmVyLmNoaWxkLmNoaWxkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwcmltYXJ5Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1vdW50RmliZXJSZWN1cnNpdmVseShwcmltYXJ5Q2hpbGQsIHNob3VsZEluY2x1ZGVJblRyZWUgPyBmaWJlciA6IHBhcmVudEZpYmVyLCB0cnVlLCB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmaWJlci5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG1vdW50RmliZXJSZWN1cnNpdmVseShmaWJlci5jaGlsZCwgc2hvdWxkSW5jbHVkZUluVHJlZSA/IGZpYmVyIDogcGFyZW50RmliZXIsIHRydWUsIHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFdlJ3JlIGV4aXRpbmcgdGhpcyBGaWJlciBub3csIGFuZCBlbnRlcmluZyBpdHMgc2libGluZ3MuXG4gICAgICAvLyBJZiB3ZSBoYXZlIHNlbGVjdGlvbiB0byByZXN0b3JlLCB3ZSBtaWdodCBuZWVkIHRvIHJlLWFjdGl2YXRlIHRyYWNraW5nLlxuXG5cbiAgICAgIHVwZGF0ZVRyYWNrZWRQYXRoU3RhdGVBZnRlck1vdW50KG1pZ2h0U2libGluZ3NCZU9uVHJhY2tlZFBhdGgpO1xuICAgICAgZmliZXIgPSB0cmF2ZXJzZVNpYmxpbmdzID8gZmliZXIuc2libGluZyA6IG51bGw7XG4gICAgfVxuICB9IC8vIFdlIHVzZSB0aGlzIHRvIHNpbXVsYXRlIHVubW91bnRpbmcgZm9yIFN1c3BlbnNlIHRyZWVzXG4gIC8vIHdoZW4gd2Ugc3dpdGNoIGZyb20gcHJpbWFyeSB0byBmYWxsYmFjay5cblxuXG4gIGZ1bmN0aW9uIHVubW91bnRGaWJlckNoaWxkcmVuUmVjdXJzaXZlbHkoZmliZXIpIHtcbiAgICBpZiAoY29uc3RhbnRzW1wic1wiIC8qIF9fREVCVUdfXyAqL10pIHtcbiAgICAgIGRlYnVnKCd1bm1vdW50RmliZXJDaGlsZHJlblJlY3Vyc2l2ZWx5KCknLCBmaWJlcik7XG4gICAgfSAvLyBXZSBtaWdodCBtZWV0IGEgbmVzdGVkIFN1c3BlbnNlIG9uIG91ciB3YXkuXG5cblxuICAgIHZhciBpc1RpbWVkT3V0U3VzcGVuc2UgPSBmaWJlci50YWcgPT09IFJlYWN0VHlwZU9mV29yay5TdXNwZW5zZUNvbXBvbmVudCAmJiBmaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgaWYgKGlzVGltZWRPdXRTdXNwZW5zZSkge1xuICAgICAgLy8gSWYgaXQncyBzaG93aW5nIGZhbGxiYWNrIHRyZWUsIGxldCdzIHRyYXZlcnNlIGl0IGluc3RlYWQuXG4gICAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBmaWJlci5jaGlsZDtcbiAgICAgIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudCA/IHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgOiBudWxsOyAvLyBTa2lwIG92ZXIgdG8gdGhlIHJlYWwgRmliZXIgY2hpbGQuXG5cbiAgICAgIGNoaWxkID0gZmFsbGJhY2tDaGlsZEZyYWdtZW50ID8gZmFsbGJhY2tDaGlsZEZyYWdtZW50LmNoaWxkIDogbnVsbDtcbiAgICB9XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFJlY29yZCBzaW11bGF0ZWQgdW5tb3VudHMgY2hpbGRyZW4tZmlyc3QuXG4gICAgICAvLyBXZSBza2lwIG5vZGVzIHdpdGhvdXQgcmV0dXJuIGJlY2F1c2UgdGhvc2UgYXJlIHJlYWwgdW5tb3VudHMuXG4gICAgICBpZiAoY2hpbGQucmV0dXJuICE9PSBudWxsKSB7XG4gICAgICAgIHVubW91bnRGaWJlckNoaWxkcmVuUmVjdXJzaXZlbHkoY2hpbGQpO1xuICAgICAgICByZWNvcmRVbm1vdW50KGNoaWxkLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZFByb2ZpbGluZ0R1cmF0aW9ucyhmaWJlcikge1xuICAgIHZhciBpZCA9IGdldEZpYmVySURUaHJvd3MoZmliZXIpO1xuICAgIHZhciBhY3R1YWxEdXJhdGlvbiA9IGZpYmVyLmFjdHVhbER1cmF0aW9uLFxuICAgICAgICB0cmVlQmFzZUR1cmF0aW9uID0gZmliZXIudHJlZUJhc2VEdXJhdGlvbjtcbiAgICBpZFRvVHJlZUJhc2VEdXJhdGlvbk1hcC5zZXQoaWQsIHRyZWVCYXNlRHVyYXRpb24gfHwgMCk7XG5cbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7IC8vIEl0J3MgaW1wb3J0YW50IHRvIHVwZGF0ZSB0cmVlQmFzZUR1cmF0aW9uIGV2ZW4gaWYgdGhlIGN1cnJlbnQgRmliZXIgZGlkIG5vdCByZW5kZXIsXG4gICAgICAvLyBiZWNhdXNlIGl0J3MgcG9zc2libGUgdGhhdCBvbmUgb2YgaXRzIGRlc2NlbmRhbnRzIGRpZC5cblxuICAgICAgaWYgKGFsdGVybmF0ZSA9PSBudWxsIHx8IHRyZWVCYXNlRHVyYXRpb24gIT09IGFsdGVybmF0ZS50cmVlQmFzZUR1cmF0aW9uKSB7XG4gICAgICAgIC8vIFRyZWUgYmFzZSBkdXJhdGlvbiB1cGRhdGVzIGFyZSBpbmNsdWRlZCBpbiB0aGUgb3BlcmF0aW9ucyB0eXBlZCBhcnJheS5cbiAgICAgICAgLy8gU28gd2UgaGF2ZSB0byBjb252ZXJ0IHRoZW0gZnJvbSBtaWxsaXNlY29uZHMgdG8gbWljcm9zZWNvbmRzIHNvIHdlIGNhbiBzZW5kIHRoZW0gYXMgaW50cy5cbiAgICAgICAgdmFyIGNvbnZlcnRlZFRyZWVCYXNlRHVyYXRpb24gPSBNYXRoLmZsb29yKCh0cmVlQmFzZUR1cmF0aW9uIHx8IDApICogMTAwMCk7XG4gICAgICAgIHB1c2hPcGVyYXRpb24oY29uc3RhbnRzW1wiclwiIC8qIFRSRUVfT1BFUkFUSU9OX1VQREFURV9UUkVFX0JBU0VfRFVSQVRJT04gKi9dKTtcbiAgICAgICAgcHVzaE9wZXJhdGlvbihpZCk7XG4gICAgICAgIHB1c2hPcGVyYXRpb24oY29udmVydGVkVHJlZUJhc2VEdXJhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbHRlcm5hdGUgPT0gbnVsbCB8fCBkaWRGaWJlclJlbmRlcihhbHRlcm5hdGUsIGZpYmVyKSkge1xuICAgICAgICBpZiAoYWN0dWFsRHVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRoZSBhY3R1YWwgZHVyYXRpb24gcmVwb3J0ZWQgYnkgUmVhY3QgaW5jbHVkZXMgdGltZSBzcGVudCB3b3JraW5nIG9uIGNoaWxkcmVuLlxuICAgICAgICAgIC8vIFRoaXMgaXMgdXNlZnVsIGluZm9ybWF0aW9uLCBidXQgaXQncyBhbHNvIHVzZWZ1bCB0byBiZSBhYmxlIHRvIGV4Y2x1ZGUgY2hpbGQgZHVyYXRpb25zLlxuICAgICAgICAgIC8vIFRoZSBmcm9udGVuZCBjYW4ndCBjb21wdXRlIHRoaXMsIHNpbmNlIHRoZSBpbW1lZGlhdGUgY2hpbGRyZW4gbWF5IGhhdmUgYmVlbiBmaWx0ZXJlZCBvdXQuXG4gICAgICAgICAgLy8gU28gd2UgbmVlZCB0byBkbyB0aGlzIG9uIHRoZSBiYWNrZW5kLlxuICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGNhbGN1bGF0ZWQgc2VsZiBkdXJhdGlvbiBpcyBub3QgdGhlIHNhbWUgdGhpbmcgYXMgdGhlIGJhc2UgZHVyYXRpb24uXG4gICAgICAgICAgLy8gVGhlIHR3byBhcmUgY2FsY3VsYXRlZCBkaWZmZXJlbnRseSAodHJlZSBkdXJhdGlvbiBkb2VzIG5vdCBhY2N1bXVsYXRlKS5cbiAgICAgICAgICB2YXIgc2VsZkR1cmF0aW9uID0gYWN0dWFsRHVyYXRpb247XG4gICAgICAgICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cbiAgICAgICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNlbGZEdXJhdGlvbiAtPSBjaGlsZC5hY3R1YWxEdXJhdGlvbiB8fCAwO1xuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgICAgIH0gLy8gSWYgcHJvZmlsaW5nIGlzIGFjdGl2ZSwgc3RvcmUgZHVyYXRpb25zIGZvciBlbGVtZW50cyB0aGF0IHdlcmUgcmVuZGVyZWQgZHVyaW5nIHRoZSBjb21taXQuXG4gICAgICAgICAgLy8gTm90ZSB0aGF0IHdlIHNob3VsZCBkbyB0aGlzIGZvciBhbnkgZmliZXIgd2UgcGVyZm9ybWVkIHdvcmsgb24sIHJlZ2FyZGxlc3Mgb2YgaXRzIGFjdHVhbER1cmF0aW9uIHZhbHVlLlxuICAgICAgICAgIC8vIEluIHNvbWUgY2FzZXMgYWN0dWFsRHVyYXRpb24gbWlnaHQgYmUgMCBmb3IgZmliZXJzIHdlIHdvcmtlZCBvbiAocGFydGljdWxhcmx5IGlmIHdlJ3JlIHVzaW5nIERhdGUubm93KVxuICAgICAgICAgIC8vIEluIG90aGVyIGNhc2VzIChlLmcuIE1lbW8pIGFjdHVhbER1cmF0aW9uIG1pZ2h0IGJlIGdyZWF0ZXIgdGhhbiAwIGV2ZW4gaWYgd2UgXCJiYWlsZWQgb3V0XCIuXG5cblxuICAgICAgICAgIHZhciBtZXRhZGF0YSA9IGN1cnJlbnRDb21taXRQcm9maWxpbmdNZXRhZGF0YTtcbiAgICAgICAgICBtZXRhZGF0YS5kdXJhdGlvbnMucHVzaChpZCwgYWN0dWFsRHVyYXRpb24sIHNlbGZEdXJhdGlvbik7XG4gICAgICAgICAgbWV0YWRhdGEubWF4QWN0dWFsRHVyYXRpb24gPSBNYXRoLm1heChtZXRhZGF0YS5tYXhBY3R1YWxEdXJhdGlvbiwgYWN0dWFsRHVyYXRpb24pO1xuXG4gICAgICAgICAgaWYgKHJlY29yZENoYW5nZURlc2NyaXB0aW9ucykge1xuICAgICAgICAgICAgdmFyIGNoYW5nZURlc2NyaXB0aW9uID0gZ2V0Q2hhbmdlRGVzY3JpcHRpb24oYWx0ZXJuYXRlLCBmaWJlcik7XG5cbiAgICAgICAgICAgIGlmIChjaGFuZ2VEZXNjcmlwdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAobWV0YWRhdGEuY2hhbmdlRGVzY3JpcHRpb25zICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEuY2hhbmdlRGVzY3JpcHRpb25zLnNldChpZCwgY2hhbmdlRGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVwZGF0ZUNvbnRleHRzRm9yRmliZXIoZmliZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZFJlc2V0Q2hpbGRyZW4oZmliZXIsIGNoaWxkU2V0KSB7XG4gICAgaWYgKGNvbnN0YW50c1tcInNcIiAvKiBfX0RFQlVHX18gKi9dKSB7XG4gICAgICBkZWJ1ZygncmVjb3JkUmVzZXRDaGlsZHJlbigpJywgY2hpbGRTZXQsIGZpYmVyKTtcbiAgICB9IC8vIFRoZSBmcm9udGVuZCBvbmx5IHJlYWxseSBjYXJlcyBhYm91dCB0aGUgZGlzcGxheU5hbWUsIGtleSwgYW5kIGNoaWxkcmVuLlxuICAgIC8vIFRoZSBmaXJzdCB0d28gZG9uJ3QgcmVhbGx5IGNoYW5nZSwgc28gd2UgYXJlIG9ubHkgY29uY2VybmVkIHdpdGggdGhlIG9yZGVyIG9mIGNoaWxkcmVuIGhlcmUuXG4gICAgLy8gVGhpcyBpcyB0cmlja2llciB0aGFuIGEgc2ltcGxlIGNvbXBhcmlzb24gdGhvdWdoLCBzaW5jZSBjZXJ0YWluIHR5cGVzIG9mIGZpYmVycyBhcmUgZmlsdGVyZWQuXG5cblxuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBbXTsgLy8gVGhpcyBpcyBhIG5haXZlIGltcGxlbWVudGF0aW9uIHRoYXQgc2hhbGxvd2x5IHJlY291cnNlcyBjaGlsZHJlbi5cbiAgICAvLyBXZSBtaWdodCB3YW50IHRvIHJldmlzaXQgdGhpcyBpZiBpdCBwcm92ZXMgdG8gYmUgdG9vIGluZWZmaWNpZW50LlxuXG4gICAgdmFyIGNoaWxkID0gY2hpbGRTZXQ7XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGZpbmRSZW9yZGVyZWRDaGlsZHJlblJlY3Vyc2l2ZWx5KGNoaWxkLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBudW1DaGlsZHJlbiA9IG5leHRDaGlsZHJlbi5sZW5ndGg7XG5cbiAgICBpZiAobnVtQ2hpbGRyZW4gPCAyKSB7XG4gICAgICAvLyBObyBuZWVkIHRvIHJlb3JkZXIuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHVzaE9wZXJhdGlvbihjb25zdGFudHNbXCJvXCIgLyogVFJFRV9PUEVSQVRJT05fUkVPUkRFUl9DSElMRFJFTiAqL10pO1xuICAgIHB1c2hPcGVyYXRpb24oZ2V0RmliZXJJRFRocm93cyhmaWJlcikpO1xuICAgIHB1c2hPcGVyYXRpb24obnVtQ2hpbGRyZW4pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXh0Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHB1c2hPcGVyYXRpb24obmV4dENoaWxkcmVuW2ldKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kUmVvcmRlcmVkQ2hpbGRyZW5SZWN1cnNpdmVseShmaWJlciwgbmV4dENoaWxkcmVuKSB7XG4gICAgaWYgKCFzaG91bGRGaWx0ZXJGaWJlcihmaWJlcikpIHtcbiAgICAgIG5leHRDaGlsZHJlbi5wdXNoKGdldEZpYmVySURUaHJvd3MoZmliZXIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG4gICAgICB2YXIgaXNUaW1lZE91dFN1c3BlbnNlID0gZmliZXIudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCAmJiBmaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuXG4gICAgICBpZiAoaXNUaW1lZE91dFN1c3BlbnNlKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZTogaWYgU3VzcGVuc2UgbW91bnRzIGluIGEgdGltZWQtb3V0IHN0YXRlLFxuICAgICAgICAvLyBnZXQgdGhlIGZhbGxiYWNrIGNoaWxkIGZyb20gdGhlIGlubmVyIGZyYWdtZW50LFxuICAgICAgICAvLyBhbmQgc2tpcCBvdmVyIHRoZSBwcmltYXJ5IGNoaWxkLlxuICAgICAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBmaWJlci5jaGlsZDtcbiAgICAgICAgdmFyIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IHByaW1hcnlDaGlsZEZyYWdtZW50ID8gcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA6IG51bGw7XG4gICAgICAgIHZhciBmYWxsYmFja0NoaWxkID0gZmFsbGJhY2tDaGlsZEZyYWdtZW50ID8gZmFsbGJhY2tDaGlsZEZyYWdtZW50LmNoaWxkIDogbnVsbDtcblxuICAgICAgICBpZiAoZmFsbGJhY2tDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNoaWxkID0gZmFsbGJhY2tDaGlsZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgZmluZFJlb3JkZXJlZENoaWxkcmVuUmVjdXJzaXZlbHkoY2hpbGQsIG5leHRDaGlsZHJlbik7XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gUmV0dXJucyB3aGV0aGVyIGNsb3Nlc3QgdW5maWx0ZXJlZCBmaWJlciBwYXJlbnQgbmVlZHMgdG8gcmVzZXQgaXRzIGNoaWxkIGxpc3QuXG5cblxuICBmdW5jdGlvbiB1cGRhdGVGaWJlclJlY3Vyc2l2ZWx5KG5leHRGaWJlciwgcHJldkZpYmVyLCBwYXJlbnRGaWJlciwgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSkge1xuICAgIHZhciBpZCA9IGdldE9yR2VuZXJhdGVGaWJlcklEKG5leHRGaWJlcik7XG5cbiAgICBpZiAoY29uc3RhbnRzW1wic1wiIC8qIF9fREVCVUdfXyAqL10pIHtcbiAgICAgIGRlYnVnKCd1cGRhdGVGaWJlclJlY3Vyc2l2ZWx5KCknLCBuZXh0RmliZXIsIHBhcmVudEZpYmVyKTtcbiAgICB9XG5cbiAgICBpZiAodHJhY2VVcGRhdGVzRW5hYmxlZCkge1xuICAgICAgdmFyIGVsZW1lbnRUeXBlID0gZ2V0RWxlbWVudFR5cGVGb3JGaWJlcihuZXh0RmliZXIpO1xuXG4gICAgICBpZiAodHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSkge1xuICAgICAgICAvLyBJZiBhbiBhbmNlc3RvciB1cGRhdGVkLCB3ZSBzaG91bGQgbWFyayB0aGUgbmVhcmVzdCBob3N0IG5vZGVzIGZvciBoaWdobGlnaHRpbmcuXG4gICAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gdHlwZXNbXCJpXCIgLyogRWxlbWVudFR5cGVIb3N0Q29tcG9uZW50ICovXSkge1xuICAgICAgICAgIHRyYWNlVXBkYXRlc0Zvck5vZGVzLmFkZChuZXh0RmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gdHlwZXNbXCJoXCIgLyogRWxlbWVudFR5cGVGdW5jdGlvbiAqL10gfHwgZWxlbWVudFR5cGUgPT09IHR5cGVzW1wiZVwiIC8qIEVsZW1lbnRUeXBlQ2xhc3MgKi9dIHx8IGVsZW1lbnRUeXBlID09PSB0eXBlc1tcImZcIiAvKiBFbGVtZW50VHlwZUNvbnRleHQgKi9dIHx8IGVsZW1lbnRUeXBlID09PSB0eXBlc1tcImpcIiAvKiBFbGVtZW50VHlwZU1lbW8gKi9dIHx8IGVsZW1lbnRUeXBlID09PSB0eXBlc1tcImdcIiAvKiBFbGVtZW50VHlwZUZvcndhcmRSZWYgKi9dKSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGlmIHRoaXMgaXMgYSB0cmFjZWQgYW5jZXN0b3IsIGZsYWcgZm9yIHRoZSBuZWFyZXN0IGhvc3QgZGVzY2VuZGFudChzKS5cbiAgICAgICAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlID0gZGlkRmliZXJSZW5kZXIocHJldkZpYmVyLCBuZXh0RmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQgIT09IG51bGwgJiYgbW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudC5pZCA9PT0gaWQgJiYgZGlkRmliZXJSZW5kZXIocHJldkZpYmVyLCBuZXh0RmliZXIpKSB7XG4gICAgICAvLyBJZiB0aGlzIEZpYmVyIGhhcyB1cGRhdGVkLCBjbGVhciBjYWNoZWQgaW5zcGVjdGVkIGRhdGEuXG4gICAgICAvLyBJZiBpdCBpcyBpbnNwZWN0ZWQgYWdhaW4sIGl0IG1heSBuZWVkIHRvIGJlIHJlLXJ1biB0byBvYnRhaW4gdXBkYXRlZCBob29rcyB2YWx1ZXMuXG4gICAgICBoYXNFbGVtZW50VXBkYXRlZFNpbmNlTGFzdEluc3BlY3RlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZEluY2x1ZGVJblRyZWUgPSAhc2hvdWxkRmlsdGVyRmliZXIobmV4dEZpYmVyKTtcbiAgICB2YXIgaXNTdXNwZW5zZSA9IG5leHRGaWJlci50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50O1xuICAgIHZhciBzaG91bGRSZXNldENoaWxkcmVuID0gZmFsc2U7IC8vIFRoZSBiZWhhdmlvciBvZiB0aW1lZC1vdXQgU3VzcGVuc2UgdHJlZXMgaXMgdW5pcXVlLlxuICAgIC8vIFJhdGhlciB0aGFuIHVubW91bnQgdGhlIHRpbWVkIG91dCBjb250ZW50IChhbmQgcG9zc2libHkgbG9zZSBpbXBvcnRhbnQgc3RhdGUpLFxuICAgIC8vIFJlYWN0IHJlLXBhcmVudHMgdGhpcyBjb250ZW50IHdpdGhpbiBhIGhpZGRlbiBGcmFnbWVudCB3aGlsZSB0aGUgZmFsbGJhY2sgaXMgc2hvd2luZy5cbiAgICAvLyBUaGlzIGJlaGF2aW9yIGRvZXNuJ3QgbmVlZCB0byBiZSBvYnNlcnZhYmxlIGluIHRoZSBEZXZUb29scyB0aG91Z2guXG4gICAgLy8gSXQgbWlnaHQgZXZlbiByZXN1bHQgaW4gYSBiYWQgdXNlciBleHBlcmllbmNlIGZvciBlLmcuIG5vZGUgc2VsZWN0aW9uIGluIHRoZSBFbGVtZW50cyBwYW5lbC5cbiAgICAvLyBUaGUgZWFzaWVzdCBmaXggaXMgdG8gc3RyaXAgb3V0IHRoZSBpbnRlcm1lZGlhdGUgRnJhZ21lbnQgZmliZXJzLFxuICAgIC8vIHNvIHRoZSBFbGVtZW50cyBwYW5lbCBhbmQgUHJvZmlsZXIgZG9uJ3QgbmVlZCB0byBzcGVjaWFsIGNhc2UgdGhlbS5cbiAgICAvLyBTdXNwZW5zZSBjb21wb25lbnRzIG9ubHkgaGF2ZSBhIG5vbi1udWxsIG1lbW9pemVkU3RhdGUgaWYgdGhleSdyZSB0aW1lZC1vdXQuXG5cbiAgICB2YXIgcHJldkRpZFRpbWVvdXQgPSBpc1N1c3BlbnNlICYmIHByZXZGaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuICAgIHZhciBuZXh0RGlkVGltZU91dCA9IGlzU3VzcGVuc2UgJiYgbmV4dEZpYmVyLm1lbW9pemVkU3RhdGUgIT09IG51bGw7IC8vIFRoZSBsb2dpYyBiZWxvdyBpcyBpbnNwaXJlZCBieSB0aGUgY29kZSBwYXRocyBpbiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudCgpXG4gICAgLy8gaW5zaWRlIFJlYWN0RmliZXJCZWdpbldvcmsgaW4gdGhlIFJlYWN0IHNvdXJjZSBjb2RlLlxuXG4gICAgaWYgKHByZXZEaWRUaW1lb3V0ICYmIG5leHREaWRUaW1lT3V0KSB7XG4gICAgICAvLyBGYWxsYmFjayAtPiBGYWxsYmFjazpcbiAgICAgIC8vIDEuIFJlY29uY2lsZSBmYWxsYmFjayBzZXQuXG4gICAgICB2YXIgbmV4dEZpYmVyQ2hpbGQgPSBuZXh0RmliZXIuY2hpbGQ7XG4gICAgICB2YXIgbmV4dEZhbGxiYWNrQ2hpbGRTZXQgPSBuZXh0RmliZXJDaGlsZCA/IG5leHRGaWJlckNoaWxkLnNpYmxpbmcgOiBudWxsOyAvLyBOb3RlOiBXZSBjYW4ndCB1c2UgbmV4dEZpYmVyLmNoaWxkLnNpYmxpbmcuYWx0ZXJuYXRlXG4gICAgICAvLyBiZWNhdXNlIHRoZSBzZXQgaXMgc3BlY2lhbCBhbmQgYWx0ZXJuYXRlIG1heSBub3QgZXhpc3QuXG5cbiAgICAgIHZhciBwcmV2RmliZXJDaGlsZCA9IHByZXZGaWJlci5jaGlsZDtcbiAgICAgIHZhciBwcmV2RmFsbGJhY2tDaGlsZFNldCA9IHByZXZGaWJlckNoaWxkID8gcHJldkZpYmVyQ2hpbGQuc2libGluZyA6IG51bGw7XG5cbiAgICAgIGlmIChuZXh0RmFsbGJhY2tDaGlsZFNldCAhPSBudWxsICYmIHByZXZGYWxsYmFja0NoaWxkU2V0ICE9IG51bGwgJiYgdXBkYXRlRmliZXJSZWN1cnNpdmVseShuZXh0RmFsbGJhY2tDaGlsZFNldCwgcHJldkZhbGxiYWNrQ2hpbGRTZXQsIG5leHRGaWJlciwgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSkpIHtcbiAgICAgICAgc2hvdWxkUmVzZXRDaGlsZHJlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcmV2RGlkVGltZW91dCAmJiAhbmV4dERpZFRpbWVPdXQpIHtcbiAgICAgIC8vIEZhbGxiYWNrIC0+IFByaW1hcnk6XG4gICAgICAvLyAxLiBVbm1vdW50IGZhbGxiYWNrIHNldFxuICAgICAgLy8gTm90ZTogZG9uJ3QgZW11bGF0ZSBmYWxsYmFjayB1bm1vdW50IGJlY2F1c2UgUmVhY3QgYWN0dWFsbHkgZGlkIGl0LlxuICAgICAgLy8gMi4gTW91bnQgcHJpbWFyeSBzZXRcbiAgICAgIHZhciBuZXh0UHJpbWFyeUNoaWxkU2V0ID0gbmV4dEZpYmVyLmNoaWxkO1xuXG4gICAgICBpZiAobmV4dFByaW1hcnlDaGlsZFNldCAhPT0gbnVsbCkge1xuICAgICAgICBtb3VudEZpYmVyUmVjdXJzaXZlbHkobmV4dFByaW1hcnlDaGlsZFNldCwgc2hvdWxkSW5jbHVkZUluVHJlZSA/IG5leHRGaWJlciA6IHBhcmVudEZpYmVyLCB0cnVlLCB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlKTtcbiAgICAgIH1cblxuICAgICAgc2hvdWxkUmVzZXRDaGlsZHJlbiA9IHRydWU7XG4gICAgfSBlbHNlIGlmICghcHJldkRpZFRpbWVvdXQgJiYgbmV4dERpZFRpbWVPdXQpIHtcbiAgICAgIC8vIFByaW1hcnkgLT4gRmFsbGJhY2s6XG4gICAgICAvLyAxLiBIaWRlIHByaW1hcnkgc2V0XG4gICAgICAvLyBUaGlzIGlzIG5vdCBhIHJlYWwgdW5tb3VudCwgc28gaXQgd29uJ3QgZ2V0IHJlcG9ydGVkIGJ5IFJlYWN0LlxuICAgICAgLy8gV2UgbmVlZCB0byBtYW51YWxseSB3YWxrIHRoZSBwcmV2aW91cyB0cmVlIGFuZCByZWNvcmQgdW5tb3VudHMuXG4gICAgICB1bm1vdW50RmliZXJDaGlsZHJlblJlY3Vyc2l2ZWx5KHByZXZGaWJlcik7IC8vIDIuIE1vdW50IGZhbGxiYWNrIHNldFxuXG4gICAgICB2YXIgX25leHRGaWJlckNoaWxkID0gbmV4dEZpYmVyLmNoaWxkO1xuXG4gICAgICB2YXIgX25leHRGYWxsYmFja0NoaWxkU2V0ID0gX25leHRGaWJlckNoaWxkID8gX25leHRGaWJlckNoaWxkLnNpYmxpbmcgOiBudWxsO1xuXG4gICAgICBpZiAoX25leHRGYWxsYmFja0NoaWxkU2V0ICE9IG51bGwpIHtcbiAgICAgICAgbW91bnRGaWJlclJlY3Vyc2l2ZWx5KF9uZXh0RmFsbGJhY2tDaGlsZFNldCwgc2hvdWxkSW5jbHVkZUluVHJlZSA/IG5leHRGaWJlciA6IHBhcmVudEZpYmVyLCB0cnVlLCB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlKTtcbiAgICAgICAgc2hvdWxkUmVzZXRDaGlsZHJlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbW1vbiBjYXNlOiBQcmltYXJ5IC0+IFByaW1hcnkuXG4gICAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGNvZGUgcGF0aCBhcyBmb3Igbm9uLVN1c3BlbnNlIGZpYmVycy5cbiAgICAgIGlmIChuZXh0RmliZXIuY2hpbGQgIT09IHByZXZGaWJlci5jaGlsZCkge1xuICAgICAgICAvLyBJZiB0aGUgZmlyc3QgY2hpbGQgaXMgZGlmZmVyZW50LCB3ZSBuZWVkIHRvIHRyYXZlcnNlIHRoZW0uXG4gICAgICAgIC8vIEVhY2ggbmV4dCBjaGlsZCB3aWxsIGJlIGVpdGhlciBhIG5ldyBjaGlsZCAobW91bnQpIG9yIGFuIGFsdGVybmF0ZSAodXBkYXRlKS5cbiAgICAgICAgdmFyIG5leHRDaGlsZCA9IG5leHRGaWJlci5jaGlsZDtcbiAgICAgICAgdmFyIHByZXZDaGlsZEF0U2FtZUluZGV4ID0gcHJldkZpYmVyLmNoaWxkO1xuXG4gICAgICAgIHdoaWxlIChuZXh0Q2hpbGQpIHtcbiAgICAgICAgICAvLyBXZSBhbHJlYWR5IGtub3cgY2hpbGRyZW4gd2lsbCBiZSByZWZlcmVudGlhbGx5IGRpZmZlcmVudCBiZWNhdXNlXG4gICAgICAgICAgLy8gdGhleSBhcmUgZWl0aGVyIG5ldyBtb3VudHMgb3IgYWx0ZXJuYXRlcyBvZiBwcmV2aW91cyBjaGlsZHJlbi5cbiAgICAgICAgICAvLyBTY2hlZHVsZSB1cGRhdGVzIGFuZCBtb3VudHMgZGVwZW5kaW5nIG9uIHdoZXRoZXIgYWx0ZXJuYXRlcyBleGlzdC5cbiAgICAgICAgICAvLyBXZSBkb24ndCB0cmFjayBkZWxldGlvbnMgaGVyZSBiZWNhdXNlIHRoZXkgYXJlIHJlcG9ydGVkIHNlcGFyYXRlbHkuXG4gICAgICAgICAgaWYgKG5leHRDaGlsZC5hbHRlcm5hdGUpIHtcbiAgICAgICAgICAgIHZhciBwcmV2Q2hpbGQgPSBuZXh0Q2hpbGQuYWx0ZXJuYXRlO1xuXG4gICAgICAgICAgICBpZiAodXBkYXRlRmliZXJSZWN1cnNpdmVseShuZXh0Q2hpbGQsIHByZXZDaGlsZCwgc2hvdWxkSW5jbHVkZUluVHJlZSA/IG5leHRGaWJlciA6IHBhcmVudEZpYmVyLCB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlKSkge1xuICAgICAgICAgICAgICAvLyBJZiBhIG5lc3RlZCB0cmVlIGNoaWxkIG9yZGVyIGNoYW5nZWQgYnV0IGl0IGNhbid0IGhhbmRsZSBpdHMgb3duXG4gICAgICAgICAgICAgIC8vIGNoaWxkIG9yZGVyIGludmFsaWRhdGlvbiAoZS5nLiBiZWNhdXNlIGl0J3MgZmlsdGVyZWQgb3V0IGxpa2UgaG9zdCBub2RlcyksXG4gICAgICAgICAgICAgIC8vIHByb3BhZ2F0ZSB0aGUgbmVlZCB0byByZXNldCBjaGlsZCBvcmRlciB1cHdhcmRzIHRvIHRoaXMgRmliZXIuXG4gICAgICAgICAgICAgIHNob3VsZFJlc2V0Q2hpbGRyZW4gPSB0cnVlO1xuICAgICAgICAgICAgfSAvLyBIb3dldmVyIHdlIGFsc28ga2VlcCB0cmFjayBpZiB0aGUgb3JkZXIgb2YgdGhlIGNoaWxkcmVuIG1hdGNoZXNcbiAgICAgICAgICAgIC8vIHRoZSBwcmV2aW91cyBvcmRlci4gVGhleSBhcmUgYWx3YXlzIGRpZmZlcmVudCByZWZlcmVudGlhbGx5LCBidXRcbiAgICAgICAgICAgIC8vIGlmIHRoZSBpbnN0YW5jZXMgbGluZSB1cCBjb25jZXB0dWFsbHkgd2UnbGwgd2FudCB0byBrbm93IHRoYXQuXG5cblxuICAgICAgICAgICAgaWYgKHByZXZDaGlsZCAhPT0gcHJldkNoaWxkQXRTYW1lSW5kZXgpIHtcbiAgICAgICAgICAgICAgc2hvdWxkUmVzZXRDaGlsZHJlbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vdW50RmliZXJSZWN1cnNpdmVseShuZXh0Q2hpbGQsIHNob3VsZEluY2x1ZGVJblRyZWUgPyBuZXh0RmliZXIgOiBwYXJlbnRGaWJlciwgZmFsc2UsIHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUpO1xuICAgICAgICAgICAgc2hvdWxkUmVzZXRDaGlsZHJlbiA9IHRydWU7XG4gICAgICAgICAgfSAvLyBUcnkgdGhlIG5leHQgY2hpbGQuXG5cblxuICAgICAgICAgIG5leHRDaGlsZCA9IG5leHRDaGlsZC5zaWJsaW5nOyAvLyBBZHZhbmNlIHRoZSBwb2ludGVyIGluIHRoZSBwcmV2aW91cyBsaXN0IHNvIHRoYXQgd2UgY2FuXG4gICAgICAgICAgLy8ga2VlcCBjb21wYXJpbmcgaWYgdGhleSBsaW5lIHVwLlxuXG4gICAgICAgICAgaWYgKCFzaG91bGRSZXNldENoaWxkcmVuICYmIHByZXZDaGlsZEF0U2FtZUluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwcmV2Q2hpbGRBdFNhbWVJbmRleCA9IHByZXZDaGlsZEF0U2FtZUluZGV4LnNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIElmIHdlIGhhdmUgbm8gbW9yZSBjaGlsZHJlbiwgYnV0IHVzZWQgdG8sIHRoZXkgZG9uJ3QgbGluZSB1cC5cblxuXG4gICAgICAgIGlmIChwcmV2Q2hpbGRBdFNhbWVJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgIHNob3VsZFJlc2V0Q2hpbGRyZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHJhY2VVcGRhdGVzRW5hYmxlZCkge1xuICAgICAgICAgIC8vIElmIHdlJ3JlIHRyYWNpbmcgdXBkYXRlcyBhbmQgd2UndmUgYmFpbGVkIG91dCBiZWZvcmUgcmVhY2hpbmcgYSBob3N0IG5vZGUsXG4gICAgICAgICAgLy8gd2Ugc2hvdWxkIGZhbGwgYmFjayB0byByZWN1cnNpdmVseSBtYXJraW5nIHRoZSBuZWFyZXN0IGhvc3QgZGVzY2VuZGFudHMgZm9yIGhpZ2hsaWdodC5cbiAgICAgICAgICBpZiAodHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIGhvc3RGaWJlcnMgPSBmaW5kQWxsQ3VycmVudEhvc3RGaWJlcnMoZ2V0RmliZXJJRFRocm93cyhuZXh0RmliZXIpKTtcbiAgICAgICAgICAgIGhvc3RGaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaG9zdEZpYmVyKSB7XG4gICAgICAgICAgICAgIHRyYWNlVXBkYXRlc0Zvck5vZGVzLmFkZChob3N0RmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRJbmNsdWRlSW5UcmVlKSB7XG4gICAgICB2YXIgaXNQcm9maWxpbmdTdXBwb3J0ZWQgPSBuZXh0RmliZXIuaGFzT3duUHJvcGVydHkoJ3RyZWVCYXNlRHVyYXRpb24nKTtcblxuICAgICAgaWYgKGlzUHJvZmlsaW5nU3VwcG9ydGVkKSB7XG4gICAgICAgIHJlY29yZFByb2ZpbGluZ0R1cmF0aW9ucyhuZXh0RmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRSZXNldENoaWxkcmVuKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGNyYXdsIHRoZSBzdWJ0cmVlIGZvciBjbG9zZXN0IG5vbi1maWx0ZXJlZCBGaWJlcnNcbiAgICAgIC8vIHNvIHRoYXQgd2UgY2FuIGRpc3BsYXkgdGhlbSBpbiBhIGZsYXQgY2hpbGRyZW4gc2V0LlxuICAgICAgaWYgKHNob3VsZEluY2x1ZGVJblRyZWUpIHtcbiAgICAgICAgLy8gTm9ybWFsbHksIHNlYXJjaCBmb3IgY2hpbGRyZW4gZnJvbSB0aGUgcmVuZGVyZWQgY2hpbGQuXG4gICAgICAgIHZhciBuZXh0Q2hpbGRTZXQgPSBuZXh0RmliZXIuY2hpbGQ7XG5cbiAgICAgICAgaWYgKG5leHREaWRUaW1lT3V0KSB7XG4gICAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiB0aW1lZC1vdXQgU3VzcGVuc2UgcmVuZGVycyB0aGUgZmFsbGJhY2sgc2V0LlxuICAgICAgICAgIHZhciBfbmV4dEZpYmVyQ2hpbGQyID0gbmV4dEZpYmVyLmNoaWxkO1xuICAgICAgICAgIG5leHRDaGlsZFNldCA9IF9uZXh0RmliZXJDaGlsZDIgPyBfbmV4dEZpYmVyQ2hpbGQyLnNpYmxpbmcgOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRDaGlsZFNldCAhPSBudWxsKSB7XG4gICAgICAgICAgcmVjb3JkUmVzZXRDaGlsZHJlbihuZXh0RmliZXIsIG5leHRDaGlsZFNldCk7XG4gICAgICAgIH0gLy8gV2UndmUgaGFuZGxlZCB0aGUgY2hpbGQgb3JkZXIgY2hhbmdlIGZvciB0aGlzIEZpYmVyLlxuICAgICAgICAvLyBTaW5jZSBpdCdzIGluY2x1ZGVkLCB0aGVyZSdzIG5vIG5lZWQgdG8gaW52YWxpZGF0ZSBwYXJlbnQgY2hpbGQgb3JkZXIuXG5cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBMZXQgdGhlIGNsb3Nlc3QgdW5maWx0ZXJlZCBwYXJlbnQgRmliZXIgcmVzZXQgaXRzIGNoaWxkIG9yZGVyIGluc3RlYWQuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHsvLyBXZSBkb24ndCBwYXRjaCBhbnkgbWV0aG9kcyBzbyB0aGVyZSBpcyBubyBjbGVhbnVwLlxuICB9XG5cbiAgZnVuY3Rpb24gcm9vdFN1cHBvcnRzUHJvZmlsaW5nKHJvb3QpIHtcbiAgICBpZiAocm9vdC5tZW1vaXplZEludGVyYWN0aW9ucyAhPSBudWxsKSB7XG4gICAgICAvLyB2MTYgYnVpbGRzIGluY2x1ZGUgdGhpcyBmaWVsZCBmb3IgdGhlIHNjaGVkdWxlci90cmFjaW5nIEFQSS5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocm9vdC5jdXJyZW50ICE9IG51bGwgJiYgcm9vdC5jdXJyZW50Lmhhc093blByb3BlcnR5KCd0cmVlQmFzZUR1cmF0aW9uJykpIHtcbiAgICAgIC8vIFRoZSBzY2hlZHVsZXIvdHJhY2luZyBBUEkgd2FzIHJlbW92ZWQgaW4gdjE3IHRob3VnaFxuICAgICAgLy8gc28gd2UgbmVlZCB0byBjaGVjayBhIG5vbi1yb290IEZpYmVyLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaEluaXRpYWxPcGVyYXRpb25zKCkge1xuICAgIHZhciBsb2NhbFBlbmRpbmdPcGVyYXRpb25zUXVldWUgPSBwZW5kaW5nT3BlcmF0aW9uc1F1ZXVlO1xuICAgIHBlbmRpbmdPcGVyYXRpb25zUXVldWUgPSBudWxsO1xuXG4gICAgaWYgKGxvY2FsUGVuZGluZ09wZXJhdGlvbnNRdWV1ZSAhPT0gbnVsbCAmJiBsb2NhbFBlbmRpbmdPcGVyYXRpb25zUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgLy8gV2UgbWF5IGhhdmUgYWxyZWFkeSBxdWV1ZWQgdXAgc29tZSBvcGVyYXRpb25zIGJlZm9yZSB0aGUgZnJvbnRlbmQgY29ubmVjdGVkXG4gICAgICAvLyBJZiBzbywgbGV0IHRoZSBmcm9udGVuZCBrbm93IGFib3V0IHRoZW0uXG4gICAgICBsb2NhbFBlbmRpbmdPcGVyYXRpb25zUXVldWUuZm9yRWFjaChmdW5jdGlvbiAob3BlcmF0aW9ucykge1xuICAgICAgICBob29rLmVtaXQoJ29wZXJhdGlvbnMnLCBvcGVyYXRpb25zKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCZWZvcmUgdGhlIHRyYXZlcnNhbHMsIHJlbWVtYmVyIHRvIHN0YXJ0IHRyYWNraW5nXG4gICAgICAvLyBvdXIgcGF0aCBpbiBjYXNlIHdlIGhhdmUgc2VsZWN0aW9uIHRvIHJlc3RvcmUuXG4gICAgICBpZiAodHJhY2tlZFBhdGggIT09IG51bGwpIHtcbiAgICAgICAgbWlnaHRCZU9uVHJhY2tlZFBhdGggPSB0cnVlO1xuICAgICAgfSAvLyBJZiB3ZSBoYXZlIG5vdCBiZWVuIHByb2ZpbGluZywgdGhlbiB3ZSBjYW4ganVzdCB3YWxrIHRoZSB0cmVlIGFuZCBidWlsZCB1cCBpdHMgY3VycmVudCBzdGF0ZSBhcy1pcy5cblxuXG4gICAgICBob29rLmdldEZpYmVyUm9vdHMocmVuZGVyZXJJRCkuZm9yRWFjaChmdW5jdGlvbiAocm9vdCkge1xuICAgICAgICBjdXJyZW50Um9vdElEID0gZ2V0T3JHZW5lcmF0ZUZpYmVySUQocm9vdC5jdXJyZW50KTtcbiAgICAgICAgc2V0Um9vdFBzZXVkb0tleShjdXJyZW50Um9vdElELCByb290LmN1cnJlbnQpOyAvLyBIYW5kbGUgbXVsdGktcmVuZGVyZXIgZWRnZS1jYXNlIHdoZXJlIG9ubHkgc29tZSB2MTYgcmVuZGVyZXJzIHN1cHBvcnQgcHJvZmlsaW5nLlxuXG4gICAgICAgIGlmIChpc1Byb2ZpbGluZyAmJiByb290U3VwcG9ydHNQcm9maWxpbmcocm9vdCkpIHtcbiAgICAgICAgICAvLyBJZiBwcm9maWxpbmcgaXMgYWN0aXZlLCBzdG9yZSBjb21taXQgdGltZSBhbmQgZHVyYXRpb24uXG4gICAgICAgICAgLy8gVGhlIGZyb250ZW5kIG1heSByZXF1ZXN0IHRoaXMgaW5mb3JtYXRpb24gYWZ0ZXIgcHJvZmlsaW5nIGhhcyBzdG9wcGVkLlxuICAgICAgICAgIGN1cnJlbnRDb21taXRQcm9maWxpbmdNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIGNoYW5nZURlc2NyaXB0aW9uczogcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zID8gbmV3IE1hcCgpIDogbnVsbCxcbiAgICAgICAgICAgIGR1cmF0aW9uczogW10sXG4gICAgICAgICAgICBjb21taXRUaW1lOiByZW5kZXJlcl9nZXRDdXJyZW50VGltZSgpIC0gcHJvZmlsaW5nU3RhcnRUaW1lLFxuICAgICAgICAgICAgbWF4QWN0dWFsRHVyYXRpb246IDAsXG4gICAgICAgICAgICBwcmlvcml0eUxldmVsOiBudWxsLFxuICAgICAgICAgICAgdXBkYXRlcnM6IGdldFVwZGF0ZXJzTGlzdChyb290KSxcbiAgICAgICAgICAgIGVmZmVjdER1cmF0aW9uOiBudWxsLFxuICAgICAgICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uOiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vdW50RmliZXJSZWN1cnNpdmVseShyb290LmN1cnJlbnQsIG51bGwsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIGZsdXNoUGVuZGluZ0V2ZW50cyhyb290KTtcbiAgICAgICAgY3VycmVudFJvb3RJRCA9IC0xO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VXBkYXRlcnNMaXN0KHJvb3QpIHtcbiAgICByZXR1cm4gcm9vdC5tZW1vaXplZFVwZGF0ZXJzICE9IG51bGwgPyBBcnJheS5mcm9tKHJvb3QubWVtb2l6ZWRVcGRhdGVycykuZmlsdGVyKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgcmV0dXJuIGdldEZpYmVySURVbnNhZmUoZmliZXIpICE9PSBudWxsO1xuICAgIH0pLm1hcChmaWJlclRvU2VyaWFsaXplZEVsZW1lbnQpIDogbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNvbW1pdEZpYmVyVW5tb3VudChmaWJlcikge1xuICAgIC8vIElmIHRoZSB1bnRyYWNrRmliZXJTZXQgYWxyZWFkeSBoYXMgdGhlIHVubW91bnRlZCBGaWJlciwgdGhpcyBtZWFucyB3ZSd2ZSBhbHJlYWR5XG4gICAgLy8gcmVjb3JkZWRVbm1vdW50LCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGl0IGFnYWluLiBJZiB3ZSBkb24ndCBkbyB0aGlzLCB3ZSBtaWdodFxuICAgIC8vIGVuZCB1cCBkb3VibGUtZGVsZXRpbmcgRmliZXJzIGluIHNvbWUgY2FzZXMgKGxpa2UgTGVnYWN5IFN1c3BlbnNlKS5cbiAgICBpZiAoIXVudHJhY2tGaWJlcnNTZXQuaGFzKGZpYmVyKSkge1xuICAgICAgLy8gVGhpcyBpcyBub3QgcmVjdXJzaXZlLlxuICAgICAgLy8gV2UgY2FuJ3QgdHJhdmVyc2UgZmliZXJzIGFmdGVyIHVubW91bnRpbmcgc28gaW5zdGVhZFxuICAgICAgLy8gd2UgcmVseSBvbiBSZWFjdCB0ZWxsaW5nIHVzIGFib3V0IGVhY2ggdW5tb3VudC5cbiAgICAgIHJlY29yZFVubW91bnQoZmliZXIsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVQb3N0Q29tbWl0RmliZXJSb290KHJvb3QpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcgJiYgcm9vdFN1cHBvcnRzUHJvZmlsaW5nKHJvb3QpKSB7XG4gICAgICBpZiAoY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfZ2V0RWZmZWN0RHVyYXRpb25zID0gT2JqZWN0KGJhY2tlbmRfdXRpbHNbXCJnXCIgLyogZ2V0RWZmZWN0RHVyYXRpb25zICovXSkocm9vdCksXG4gICAgICAgICAgICBlZmZlY3REdXJhdGlvbiA9IF9nZXRFZmZlY3REdXJhdGlvbnMuZWZmZWN0RHVyYXRpb24sXG4gICAgICAgICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb24gPSBfZ2V0RWZmZWN0RHVyYXRpb25zLnBhc3NpdmVFZmZlY3REdXJhdGlvbjsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICBjdXJyZW50Q29tbWl0UHJvZmlsaW5nTWV0YWRhdGEuZWZmZWN0RHVyYXRpb24gPSBlZmZlY3REdXJhdGlvbjsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cbiAgICAgICAgY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IHBhc3NpdmVFZmZlY3REdXJhdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDb21taXRGaWJlclJvb3Qocm9vdCwgcHJpb3JpdHlMZXZlbCkge1xuICAgIHZhciBjdXJyZW50ID0gcm9vdC5jdXJyZW50O1xuICAgIHZhciBhbHRlcm5hdGUgPSBjdXJyZW50LmFsdGVybmF0ZTsgLy8gRmx1c2ggYW55IHBlbmRpbmcgRmliZXJzIHRoYXQgd2UgYXJlIHVudHJhY2tpbmcgYmVmb3JlIHByb2Nlc3NpbmcgdGhlIG5ldyBjb21taXQuXG4gICAgLy8gSWYgd2UgZG9uJ3QgZG8gdGhpcywgd2UgbWlnaHQgZW5kIHVwIGRvdWJsZS1kZWxldGluZyBGaWJlcnMgaW4gc29tZSBjYXNlcyAobGlrZSBMZWdhY3kgU3VzcGVuc2UpLlxuXG4gICAgdW50cmFja0ZpYmVycygpO1xuICAgIGN1cnJlbnRSb290SUQgPSBnZXRPckdlbmVyYXRlRmliZXJJRChjdXJyZW50KTsgLy8gQmVmb3JlIHRoZSB0cmF2ZXJzYWxzLCByZW1lbWJlciB0byBzdGFydCB0cmFja2luZ1xuICAgIC8vIG91ciBwYXRoIGluIGNhc2Ugd2UgaGF2ZSBzZWxlY3Rpb24gdG8gcmVzdG9yZS5cblxuICAgIGlmICh0cmFja2VkUGF0aCAhPT0gbnVsbCkge1xuICAgICAgbWlnaHRCZU9uVHJhY2tlZFBhdGggPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0cmFjZVVwZGF0ZXNFbmFibGVkKSB7XG4gICAgICB0cmFjZVVwZGF0ZXNGb3JOb2Rlcy5jbGVhcigpO1xuICAgIH0gLy8gSGFuZGxlIG11bHRpLXJlbmRlcmVyIGVkZ2UtY2FzZSB3aGVyZSBvbmx5IHNvbWUgdjE2IHJlbmRlcmVycyBzdXBwb3J0IHByb2ZpbGluZy5cblxuXG4gICAgdmFyIGlzUHJvZmlsaW5nU3VwcG9ydGVkID0gcm9vdFN1cHBvcnRzUHJvZmlsaW5nKHJvb3QpO1xuXG4gICAgaWYgKGlzUHJvZmlsaW5nICYmIGlzUHJvZmlsaW5nU3VwcG9ydGVkKSB7XG4gICAgICAvLyBJZiBwcm9maWxpbmcgaXMgYWN0aXZlLCBzdG9yZSBjb21taXQgdGltZSBhbmQgZHVyYXRpb24uXG4gICAgICAvLyBUaGUgZnJvbnRlbmQgbWF5IHJlcXVlc3QgdGhpcyBpbmZvcm1hdGlvbiBhZnRlciBwcm9maWxpbmcgaGFzIHN0b3BwZWQuXG4gICAgICBjdXJyZW50Q29tbWl0UHJvZmlsaW5nTWV0YWRhdGEgPSB7XG4gICAgICAgIGNoYW5nZURlc2NyaXB0aW9uczogcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zID8gbmV3IE1hcCgpIDogbnVsbCxcbiAgICAgICAgZHVyYXRpb25zOiBbXSxcbiAgICAgICAgY29tbWl0VGltZTogcmVuZGVyZXJfZ2V0Q3VycmVudFRpbWUoKSAtIHByb2ZpbGluZ1N0YXJ0VGltZSxcbiAgICAgICAgbWF4QWN0dWFsRHVyYXRpb246IDAsXG4gICAgICAgIHByaW9yaXR5TGV2ZWw6IHByaW9yaXR5TGV2ZWwgPT0gbnVsbCA/IG51bGwgOiBmb3JtYXRQcmlvcml0eUxldmVsKHByaW9yaXR5TGV2ZWwpLFxuICAgICAgICB1cGRhdGVyczogZ2V0VXBkYXRlcnNMaXN0KHJvb3QpLFxuICAgICAgICAvLyBJbml0aWFsaXplIHRvIG51bGw7IGlmIG5ldyBlbm91Z2ggUmVhY3QgdmVyc2lvbiBpcyBydW5uaW5nLFxuICAgICAgICAvLyB0aGVzZSB2YWx1ZXMgd2lsbCBiZSByZWFkIGR1cmluZyBzZXBhcmF0ZSBoYW5kbGVQb3N0Q29tbWl0RmliZXJSb290KCkgY2FsbC5cbiAgICAgICAgZWZmZWN0RHVyYXRpb246IG51bGwsXG4gICAgICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvbjogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoYWx0ZXJuYXRlKSB7XG4gICAgICAvLyBUT0RPOiByZWx5aW5nIG9uIHRoaXMgc2VlbXMgYSBiaXQgZmlzaHkuXG4gICAgICB2YXIgd2FzTW91bnRlZCA9IGFsdGVybmF0ZS5tZW1vaXplZFN0YXRlICE9IG51bGwgJiYgYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuZWxlbWVudCAhPSBudWxsICYmIC8vIEEgZGVoeWRyYXRlZCByb290IGlzIG5vdCBjb25zaWRlcmVkIG1vdW50ZWRcbiAgICAgIGFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZCAhPT0gdHJ1ZTtcbiAgICAgIHZhciBpc01vdW50ZWQgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUuZWxlbWVudCAhPSBudWxsICYmIC8vIEEgZGVoeWRyYXRlZCByb290IGlzIG5vdCBjb25zaWRlcmVkIG1vdW50ZWRcbiAgICAgIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQgIT09IHRydWU7XG5cbiAgICAgIGlmICghd2FzTW91bnRlZCAmJiBpc01vdW50ZWQpIHtcbiAgICAgICAgLy8gTW91bnQgYSBuZXcgcm9vdC5cbiAgICAgICAgc2V0Um9vdFBzZXVkb0tleShjdXJyZW50Um9vdElELCBjdXJyZW50KTtcbiAgICAgICAgbW91bnRGaWJlclJlY3Vyc2l2ZWx5KGN1cnJlbnQsIG51bGwsIGZhbHNlLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKHdhc01vdW50ZWQgJiYgaXNNb3VudGVkKSB7XG4gICAgICAgIC8vIFVwZGF0ZSBhbiBleGlzdGluZyByb290LlxuICAgICAgICB1cGRhdGVGaWJlclJlY3Vyc2l2ZWx5KGN1cnJlbnQsIGFsdGVybmF0ZSwgbnVsbCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh3YXNNb3VudGVkICYmICFpc01vdW50ZWQpIHtcbiAgICAgICAgLy8gVW5tb3VudCBhbiBleGlzdGluZyByb290LlxuICAgICAgICByZW1vdmVSb290UHNldWRvS2V5KGN1cnJlbnRSb290SUQpO1xuICAgICAgICByZWNvcmRVbm1vdW50KGN1cnJlbnQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW91bnQgYSBuZXcgcm9vdC5cbiAgICAgIHNldFJvb3RQc2V1ZG9LZXkoY3VycmVudFJvb3RJRCwgY3VycmVudCk7XG4gICAgICBtb3VudEZpYmVyUmVjdXJzaXZlbHkoY3VycmVudCwgbnVsbCwgZmFsc2UsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAoaXNQcm9maWxpbmcgJiYgaXNQcm9maWxpbmdTdXBwb3J0ZWQpIHtcbiAgICAgIGlmICghc2hvdWxkQmFpbG91dFdpdGhQZW5kaW5nT3BlcmF0aW9ucygpKSB7XG4gICAgICAgIHZhciBjb21taXRQcm9maWxpbmdNZXRhZGF0YSA9IHJvb3RUb0NvbW1pdFByb2ZpbGluZ01ldGFkYXRhTWFwLmdldChjdXJyZW50Um9vdElEKTtcblxuICAgICAgICBpZiAoY29tbWl0UHJvZmlsaW5nTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgIGNvbW1pdFByb2ZpbGluZ01ldGFkYXRhLnB1c2goY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb290VG9Db21taXRQcm9maWxpbmdNZXRhZGF0YU1hcC5zZXQoY3VycmVudFJvb3RJRCwgW2N1cnJlbnRDb21taXRQcm9maWxpbmdNZXRhZGF0YV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBXZSdyZSBkb25lIGhlcmUuXG5cblxuICAgIGZsdXNoUGVuZGluZ0V2ZW50cyhyb290KTtcblxuICAgIGlmICh0cmFjZVVwZGF0ZXNFbmFibGVkKSB7XG4gICAgICBob29rLmVtaXQoJ3RyYWNlVXBkYXRlcycsIHRyYWNlVXBkYXRlc0Zvck5vZGVzKTtcbiAgICB9XG5cbiAgICBjdXJyZW50Um9vdElEID0gLTE7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kQWxsQ3VycmVudEhvc3RGaWJlcnMoaWQpIHtcbiAgICB2YXIgZmliZXJzID0gW107XG4gICAgdmFyIGZpYmVyID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGhCeUlkKGlkKTtcblxuICAgIGlmICghZmliZXIpIHtcbiAgICAgIHJldHVybiBmaWJlcnM7XG4gICAgfSAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCBhbGwgSG9zdENvbXBvbmVudC9UZXh0LlxuXG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgZmliZXJzLnB1c2gobm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSBmaWJlcikge1xuICAgICAgICByZXR1cm4gZmliZXJzO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgICBpZiAoIW5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSBmaWJlcikge1xuICAgICAgICAgIHJldHVybiBmaWJlcnM7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfSAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG5cblxuICAgIHJldHVybiBmaWJlcnM7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kTmF0aXZlTm9kZXNGb3JGaWJlcklEKGlkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfZmliZXIzID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGhCeUlkKGlkKTtcblxuICAgICAgaWYgKF9maWJlcjMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IC8vIFNwZWNpYWwgY2FzZSBmb3IgYSB0aW1lZC1vdXQgU3VzcGVuc2UuXG5cblxuICAgICAgdmFyIGlzVGltZWRPdXRTdXNwZW5zZSA9IF9maWJlcjMudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCAmJiBfZmliZXIzLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICAgIGlmIChpc1RpbWVkT3V0U3VzcGVuc2UpIHtcbiAgICAgICAgLy8gQSB0aW1lZC1vdXQgU3VzcGVuc2UncyBmaW5kRE9NTm9kZSBpcyB1c2VsZXNzLlxuICAgICAgICAvLyBUcnkgb3VyIGJlc3QgdG8gZmluZCB0aGUgZmFsbGJhY2sgZGlyZWN0bHkuXG4gICAgICAgIHZhciBtYXliZUZhbGxiYWNrRmliZXIgPSBfZmliZXIzLmNoaWxkICYmIF9maWJlcjMuY2hpbGQuc2libGluZztcblxuICAgICAgICBpZiAobWF5YmVGYWxsYmFja0ZpYmVyICE9IG51bGwpIHtcbiAgICAgICAgICBfZmliZXIzID0gbWF5YmVGYWxsYmFja0ZpYmVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBob3N0RmliZXJzID0gZmluZEFsbEN1cnJlbnRIb3N0RmliZXJzKGlkKTtcbiAgICAgIHJldHVybiBob3N0RmliZXJzLm1hcChmdW5jdGlvbiAoaG9zdEZpYmVyKSB7XG4gICAgICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICAgICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gVGhlIGZpYmVyIG1pZ2h0IGhhdmUgdW5tb3VudGVkIGJ5IG5vdy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lRm9yRmliZXJJRChpZCkge1xuICAgIHZhciBmaWJlciA9IGlkVG9BcmJpdHJhcnlGaWJlck1hcC5nZXQoaWQpO1xuICAgIHJldHVybiBmaWJlciAhPSBudWxsID8gZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihmaWJlcikgOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RmliZXJGb3JOYXRpdmUoaG9zdEluc3RhbmNlKSB7XG4gICAgcmV0dXJuIHJlbmRlcmVyLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlKGhvc3RJbnN0YW5jZSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGaWJlcklERm9yTmF0aXZlKGhvc3RJbnN0YW5jZSkge1xuICAgIHZhciBmaW5kTmVhcmVzdFVuZmlsdGVyZWRBbmNlc3RvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgdmFyIGZpYmVyID0gcmVuZGVyZXIuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UoaG9zdEluc3RhbmNlKTtcblxuICAgIGlmIChmaWJlciAhPSBudWxsKSB7XG4gICAgICBpZiAoZmluZE5lYXJlc3RVbmZpbHRlcmVkQW5jZXN0b3IpIHtcbiAgICAgICAgd2hpbGUgKGZpYmVyICE9PSBudWxsICYmIHNob3VsZEZpbHRlckZpYmVyKGZpYmVyKSkge1xuICAgICAgICAgIGZpYmVyID0gZmliZXIucmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRGaWJlcklEVGhyb3dzKGZpYmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNvcGllZCBmcm9tIFJlYWN0IGFuZCBzaG91bGQgYmUga2VwdCBpbiBzeW5jOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9tYWluL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJUcmVlUmVmbGVjdGlvbi5qc1xuXG5cbiAgZnVuY3Rpb24gYXNzZXJ0SXNNb3VudGVkKGZpYmVyKSB7XG4gICAgaWYgKGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpICE9PSBmaWJlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfVxuICB9IC8vIFRoaXMgZnVuY3Rpb24gaXMgY29waWVkIGZyb20gUmVhY3QgYW5kIHNob3VsZCBiZSBrZXB0IGluIHN5bmM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21haW4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlclRyZWVSZWZsZWN0aW9uLmpzXG5cblxuICBmdW5jdGlvbiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSB7XG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBmaWJlcjtcblxuICAgIGlmICghZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgICAvLyB5ZXQuIElmIGl0IGlzLCB0aGVuIGl0IHdpbGwgaGF2ZSBhIHBlbmRpbmcgaW5zZXJ0aW9uIGVmZmVjdCBvbiBpdC5cbiAgICAgIHZhciBuZXh0Tm9kZSA9IG5vZGU7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgbm9kZSA9IG5leHROb2RlOyAvLyBUT0RPOiBUaGlzIGZ1bmN0aW9uLCBhbmQgdGhlc2UgZmxhZ3MsIGFyZSBhIGxlYWtlZCBpbXBsZW1lbnRhdGlvblxuICAgICAgICAvLyBkZXRhaWwuIE9uY2Ugd2Ugc3RhcnQgcmVsZWFzaW5nIERldlRvb2xzIGluIGxvY2tzdGVwIHdpdGggUmVhY3QsIHdlXG4gICAgICAgIC8vIHNob3VsZCBpbXBvcnQgYSBmdW5jdGlvbiBmcm9tIHRoZSByZWNvbmNpbGVyIGluc3RlYWQuXG5cbiAgICAgICAgdmFyIFBsYWNlbWVudCA9IDI7XG4gICAgICAgIHZhciBIeWRyYXRpbmcgPSA0MDk2O1xuXG4gICAgICAgIGlmICgobm9kZS5mbGFncyAmIChQbGFjZW1lbnQgfCBIeWRyYXRpbmcpKSAhPT0gMCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYW4gaW5zZXJ0aW9uIG9yIGluLXByb2dyZXNzIGh5ZHJhdGlvbi4gVGhlIG5lYXJlc3QgcG9zc2libGVcbiAgICAgICAgICAvLyBtb3VudGVkIGZpYmVyIGlzIHRoZSBwYXJlbnQgYnV0IHdlIG5lZWQgdG8gY29udGludWUgdG8gZmlndXJlIG91dFxuICAgICAgICAgIC8vIGlmIHRoYXQgb25lIGlzIHN0aWxsIG1vdW50ZWQuXG4gICAgICAgICAgbmVhcmVzdE1vdW50ZWQgPSBub2RlLnJldHVybjtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSB3ZSBiYWlsIG91dCB3aGVuIHdlIGdldCBhIG51bGxcblxuXG4gICAgICAgIG5leHROb2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9IHdoaWxlIChuZXh0Tm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChub2RlLnJldHVybikge1xuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgLy8gVE9ETzogQ2hlY2sgaWYgdGhpcyB3YXMgYSBuZXN0ZWQgSG9zdFJvb3Qgd2hlbiB1c2VkIHdpdGhcbiAgICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgICAgcmV0dXJuIG5lYXJlc3RNb3VudGVkO1xuICAgIH0gLy8gSWYgd2UgZGlkbid0IGhpdCB0aGUgcm9vdCwgdGhhdCBtZWFucyB0aGF0IHdlJ3JlIGluIGFuIGRpc2Nvbm5lY3RlZCB0cmVlXG4gICAgLy8gdGhhdCBoYXMgYmVlbiB1bm1vdW50ZWQuXG5cblxuICAgIHJldHVybiBudWxsO1xuICB9IC8vIFRoaXMgZnVuY3Rpb24gaXMgY29waWVkIGZyb20gUmVhY3QgYW5kIHNob3VsZCBiZSBrZXB0IGluIHN5bmM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21haW4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlclRyZWVSZWZsZWN0aW9uLmpzXG4gIC8vIEl0IHdvdWxkIGJlIG5pY2UgaWYgd2UgdXBkYXRlZCBSZWFjdCB0byBpbmplY3QgdGhpcyBmdW5jdGlvbiBkaXJlY3RseSAodnMganVzdCBpbmRpcmVjdGx5IHZpYSBmaW5kRE9NTm9kZSkuXG4gIC8vIEJFR0lOIGNvcGllZCBjb2RlXG5cblxuICBmdW5jdGlvbiBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aEJ5SWQoaWQpIHtcbiAgICB2YXIgZmliZXIgPSBpZFRvQXJiaXRyYXJ5RmliZXJNYXAuZ2V0KGlkKTtcblxuICAgIGlmIChmaWJlciA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZmluZCBGaWJlciB3aXRoIGlkIFxcXCJcIi5jb25jYXQoaWQsIFwiXFxcIlwiKSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKCFhbHRlcm5hdGUpIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhlbiB3ZSBvbmx5IG5lZWQgdG8gY2hlY2sgaWYgaXQgaXMgbW91bnRlZC5cbiAgICAgIHZhciBuZWFyZXN0TW91bnRlZCA9IGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpO1xuXG4gICAgICBpZiAobmVhcmVzdE1vdW50ZWQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZWFyZXN0TW91bnRlZCAhPT0gZmliZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaWJlcjtcbiAgICB9IC8vIElmIHdlIGhhdmUgdHdvIHBvc3NpYmxlIGJyYW5jaGVzLCB3ZSdsbCB3YWxrIGJhY2t3YXJkcyB1cCB0byB0aGUgcm9vdFxuICAgIC8vIHRvIHNlZSB3aGF0IHBhdGggdGhlIHJvb3QgcG9pbnRzIHRvLiBPbiB0aGUgd2F5IHdlIG1heSBoaXQgb25lIG9mIHRoZVxuICAgIC8vIHNwZWNpYWwgY2FzZXMgYW5kIHdlJ2xsIGRlYWwgd2l0aCB0aGVtLlxuXG5cbiAgICB2YXIgYSA9IGZpYmVyO1xuICAgIHZhciBiID0gYWx0ZXJuYXRlO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHZhciBwYXJlbnRBID0gYS5yZXR1cm47XG5cbiAgICAgIGlmIChwYXJlbnRBID09PSBudWxsKSB7XG4gICAgICAgIC8vIFdlJ3JlIGF0IHRoZSByb290LlxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudEIgPSBwYXJlbnRBLmFsdGVybmF0ZTtcblxuICAgICAgaWYgKHBhcmVudEIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gYWx0ZXJuYXRlLiBUaGlzIGlzIGFuIHVudXN1YWwgY2FzZS4gQ3VycmVudGx5LCBpdCBvbmx5XG4gICAgICAgIC8vIGhhcHBlbnMgd2hlbiBhIFN1c3BlbnNlIGNvbXBvbmVudCBpcyBoaWRkZW4uIEFuIGV4dHJhIGZyYWdtZW50IGZpYmVyXG4gICAgICAgIC8vIGlzIGluc2VydGVkIGluIGJldHdlZW4gdGhlIFN1c3BlbnNlIGZpYmVyIGFuZCBpdHMgY2hpbGRyZW4uIFNraXBcbiAgICAgICAgLy8gb3ZlciB0aGlzIGV4dHJhIGZyYWdtZW50IGZpYmVyIGFuZCBwcm9jZWVkIHRvIHRoZSBuZXh0IHBhcmVudC5cbiAgICAgICAgdmFyIG5leHRQYXJlbnQgPSBwYXJlbnRBLnJldHVybjtcblxuICAgICAgICBpZiAobmV4dFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIGEgPSBiID0gbmV4dFBhcmVudDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBJZiB0aGVyZSdzIG5vIHBhcmVudCwgd2UncmUgYXQgdGhlIHJvb3QuXG5cblxuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gSWYgYm90aCBjb3BpZXMgb2YgdGhlIHBhcmVudCBmaWJlciBwb2ludCB0byB0aGUgc2FtZSBjaGlsZCwgd2UgY2FuXG4gICAgICAvLyBhc3N1bWUgdGhhdCB0aGUgY2hpbGQgaXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW4gd2UgYmFpbG91dCBvbiBsb3dcbiAgICAgIC8vIHByaW9yaXR5OiB0aGUgYmFpbGVkIG91dCBmaWJlcidzIGNoaWxkIHJldXNlcyB0aGUgY3VycmVudCBjaGlsZC5cblxuXG4gICAgICBpZiAocGFyZW50QS5jaGlsZCA9PT0gcGFyZW50Qi5jaGlsZCkge1xuICAgICAgICB2YXIgY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuXG4gICAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICAgIGlmIChjaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEIgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgICAgcmV0dXJuIGFsdGVybmF0ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICAgIH0gLy8gV2Ugc2hvdWxkIG5ldmVyIGhhdmUgYW4gYWx0ZXJuYXRlIGZvciBhbnkgbW91bnRpbmcgbm9kZS4gU28gdGhlIG9ubHlcbiAgICAgICAgLy8gd2F5IHRoaXMgY291bGQgcG9zc2libHkgaGFwcGVuIGlzIGlmIHRoaXMgd2FzIHVubW91bnRlZCwgaWYgYXQgYWxsLlxuXG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhLnJldHVybiAhPT0gYi5yZXR1cm4pIHtcbiAgICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVyIG9mIEEgYW5kIHRoZSByZXR1cm4gcG9pbnRlciBvZiBCIHBvaW50IHRvIGRpZmZlcmVudFxuICAgICAgICAvLyBmaWJlcnMuIFdlIGFzc3VtZSB0aGF0IHJldHVybiBwb2ludGVycyBuZXZlciBjcmlzcy1jcm9zcywgc28gQSBtdXN0XG4gICAgICAgIC8vIGJlbG9uZyB0byB0aGUgY2hpbGQgc2V0IG9mIEEucmV0dXJuLCBhbmQgQiBtdXN0IGJlbG9uZyB0byB0aGUgY2hpbGRcbiAgICAgICAgLy8gc2V0IG9mIEIucmV0dXJuLlxuICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXJzIHBvaW50IHRvIHRoZSBzYW1lIGZpYmVyLiBXZSdsbCBoYXZlIHRvIHVzZSB0aGVcbiAgICAgICAgLy8gZGVmYXVsdCwgc2xvdyBwYXRoOiBzY2FuIHRoZSBjaGlsZCBzZXRzIG9mIGVhY2ggcGFyZW50IGFsdGVybmF0ZSB0byBzZWVcbiAgICAgICAgLy8gd2hpY2ggY2hpbGQgYmVsb25ncyB0byB3aGljaCBzZXQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQSdzIGNoaWxkIHNldFxuICAgICAgICB2YXIgZGlkRmluZENoaWxkID0gZmFsc2U7XG4gICAgICAgIHZhciBfY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuXG4gICAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRpZEZpbmRDaGlsZCkge1xuICAgICAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQidzIGNoaWxkIHNldFxuICAgICAgICAgIF9jaGlsZCA9IHBhcmVudEIuY2hpbGQ7XG5cbiAgICAgICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgJyArICdpbiBSZWFjdCByZWxhdGVkIHRvIHRoZSByZXR1cm4gcG9pbnRlci4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhLmFsdGVybmF0ZSAhPT0gYikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXR1cm4gZmliZXJzIHNob3VsZCBhbHdheXMgYmUgZWFjaCBvdGhlcnMnIGFsdGVybmF0ZXMuIFwiICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICB9XG4gICAgfSAvLyBJZiB0aGUgcm9vdCBpcyBub3QgYSBob3N0IGNvbnRhaW5lciwgd2UncmUgaW4gYSBkaXNjb25uZWN0ZWQgdHJlZS4gSS5lLlxuICAgIC8vIHVubW91bnRlZC5cblxuXG4gICAgaWYgKGEudGFnICE9PSBIb3N0Um9vdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfVxuXG4gICAgaWYgKGEuc3RhdGVOb2RlLmN1cnJlbnQgPT09IGEpIHtcbiAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgIHJldHVybiBmaWJlcjtcbiAgICB9IC8vIE90aGVyd2lzZSBCIGhhcyB0byBiZSBjdXJyZW50IGJyYW5jaC5cblxuXG4gICAgcmV0dXJuIGFsdGVybmF0ZTtcbiAgfSAvLyBFTkQgY29waWVkIGNvZGVcblxuXG4gIGZ1bmN0aW9uIHByZXBhcmVWaWV3QXR0cmlidXRlU291cmNlKGlkLCBwYXRoKSB7XG4gICAgaWYgKGlzTW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudChpZCkpIHtcbiAgICAgIHdpbmRvdy4kYXR0cmlidXRlID0gT2JqZWN0KHV0aWxzW1wialwiIC8qIGdldEluT2JqZWN0ICovXSkobW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudCwgcGF0aCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVZpZXdFbGVtZW50U291cmNlKGlkKSB7XG4gICAgdmFyIGZpYmVyID0gaWRUb0FyYml0cmFyeUZpYmVyTWFwLmdldChpZCk7XG5cbiAgICBpZiAoZmliZXIgPT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGZpbmQgRmliZXIgd2l0aCBpZCBcXFwiXCIuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50VHlwZSA9IGZpYmVyLmVsZW1lbnRUeXBlLFxuICAgICAgICB0YWcgPSBmaWJlci50YWcsXG4gICAgICAgIHR5cGUgPSBmaWJlci50eXBlO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICAgIGdsb2JhbC4kdHlwZSA9IHR5cGU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGdsb2JhbC4kdHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICBnbG9iYWwuJHR5cGUgPSBlbGVtZW50VHlwZSAhPSBudWxsICYmIGVsZW1lbnRUeXBlLnR5cGUgIT0gbnVsbCA/IGVsZW1lbnRUeXBlLnR5cGUgOiB0eXBlO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZ2xvYmFsLiR0eXBlID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmliZXJUb1NlcmlhbGl6ZWRFbGVtZW50KGZpYmVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpc3BsYXlOYW1lOiBnZXREaXNwbGF5TmFtZUZvckZpYmVyKGZpYmVyKSB8fCAnQW5vbnltb3VzJyxcbiAgICAgIGlkOiBnZXRGaWJlcklEVGhyb3dzKGZpYmVyKSxcbiAgICAgIGtleTogZmliZXIua2V5LFxuICAgICAgdHlwZTogZ2V0RWxlbWVudFR5cGVGb3JGaWJlcihmaWJlcilcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0T3duZXJzTGlzdChpZCkge1xuICAgIHZhciBmaWJlciA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoQnlJZChpZCk7XG5cbiAgICBpZiAoZmliZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIF9kZWJ1Z093bmVyID0gZmliZXIuX2RlYnVnT3duZXI7XG4gICAgdmFyIG93bmVycyA9IFtmaWJlclRvU2VyaWFsaXplZEVsZW1lbnQoZmliZXIpXTtcblxuICAgIGlmIChfZGVidWdPd25lcikge1xuICAgICAgdmFyIG93bmVyID0gX2RlYnVnT3duZXI7XG5cbiAgICAgIHdoaWxlIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgICBvd25lcnMudW5zaGlmdChmaWJlclRvU2VyaWFsaXplZEVsZW1lbnQob3duZXIpKTtcbiAgICAgICAgb3duZXIgPSBvd25lci5fZGVidWdPd25lciB8fCBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvd25lcnM7XG4gIH0gLy8gRmFzdCBwYXRoIHByb3BzIGxvb2t1cCBmb3IgUmVhY3QgTmF0aXZlIHN0eWxlIGVkaXRvci5cbiAgLy8gQ291bGQgdXNlIGluc3BlY3RFbGVtZW50UmF3KCkgYnV0IHRoYXQgd291bGQgcmVxdWlyZSBzaGFsbG93IHJlbmRlcmluZyBob29rcyBjb21wb25lbnRzLFxuICAvLyBhbmQgY291bGQgYWxzbyBtZXNzIHdpdGggbWVtb2l6YXRpb24uXG5cblxuICBmdW5jdGlvbiBnZXRJbnN0YW5jZUFuZFN0eWxlKGlkKSB7XG4gICAgdmFyIGluc3RhbmNlID0gbnVsbDtcbiAgICB2YXIgc3R5bGUgPSBudWxsO1xuICAgIHZhciBmaWJlciA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoQnlJZChpZCk7XG5cbiAgICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICBpZiAoZmliZXIubWVtb2l6ZWRQcm9wcyAhPT0gbnVsbCkge1xuICAgICAgICBzdHlsZSA9IGZpYmVyLm1lbW9pemVkUHJvcHMuc3R5bGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgIHN0eWxlOiBzdHlsZVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpc0Vycm9yQm91bmRhcnkoZmliZXIpIHtcbiAgICB2YXIgdGFnID0gZmliZXIudGFnLFxuICAgICAgICB0eXBlID0gZmliZXIudHlwZTtcblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJyB8fCBpbnN0YW5jZSAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbic7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXROZWFyZXN0RXJyb3JCb3VuZGFyeUlEKGZpYmVyKSB7XG4gICAgdmFyIHBhcmVudCA9IGZpYmVyLnJldHVybjtcblxuICAgIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIGlmIChpc0Vycm9yQm91bmRhcnkocGFyZW50KSkge1xuICAgICAgICByZXR1cm4gZ2V0RmliZXJJRFVuc2FmZShwYXJlbnQpO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zcGVjdEVsZW1lbnRSYXcoaWQpIHtcbiAgICB2YXIgZmliZXIgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aEJ5SWQoaWQpO1xuXG4gICAgaWYgKGZpYmVyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBfZGVidWdPd25lciA9IGZpYmVyLl9kZWJ1Z093bmVyLFxuICAgICAgICBfZGVidWdTb3VyY2UgPSBmaWJlci5fZGVidWdTb3VyY2UsXG4gICAgICAgIHN0YXRlTm9kZSA9IGZpYmVyLnN0YXRlTm9kZSxcbiAgICAgICAga2V5ID0gZmliZXIua2V5LFxuICAgICAgICBtZW1vaXplZFByb3BzID0gZmliZXIubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgbWVtb2l6ZWRTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgICAgIGRlcGVuZGVuY2llcyA9IGZpYmVyLmRlcGVuZGVuY2llcyxcbiAgICAgICAgdGFnID0gZmliZXIudGFnLFxuICAgICAgICB0eXBlID0gZmliZXIudHlwZTtcbiAgICB2YXIgZWxlbWVudFR5cGUgPSBnZXRFbGVtZW50VHlwZUZvckZpYmVyKGZpYmVyKTtcbiAgICB2YXIgdXNlc0hvb2tzID0gKHRhZyA9PT0gRnVuY3Rpb25Db21wb25lbnQgfHwgdGFnID09PSBTaW1wbGVNZW1vQ29tcG9uZW50IHx8IHRhZyA9PT0gRm9yd2FyZFJlZikgJiYgKCEhbWVtb2l6ZWRTdGF0ZSB8fCAhIWRlcGVuZGVuY2llcyk7IC8vIFRPRE8gU2hvdyBjdXN0b20gVUkgZm9yIENhY2hlIGxpa2Ugd2UgZG8gZm9yIFN1c3BlbnNlXG4gICAgLy8gRm9yIG5vdywganVzdCBoaWRlIHN0YXRlIGRhdGEgZW50aXJlbHkgc2luY2UgaXQncyBub3QgbWVhbnQgdG8gYmUgaW5zcGVjdGVkLlxuXG4gICAgdmFyIHNob3dTdGF0ZSA9ICF1c2VzSG9va3MgJiYgdGFnICE9PSBDYWNoZUNvbXBvbmVudDtcbiAgICB2YXIgdHlwZVN5bWJvbCA9IGdldFR5cGVTeW1ib2wodHlwZSk7XG4gICAgdmFyIGNhblZpZXdTb3VyY2UgPSBmYWxzZTtcbiAgICB2YXIgY29udGV4dCA9IG51bGw7XG5cbiAgICBpZiAodGFnID09PSBDbGFzc0NvbXBvbmVudCB8fCB0YWcgPT09IEZ1bmN0aW9uQ29tcG9uZW50IHx8IHRhZyA9PT0gSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50IHx8IHRhZyA9PT0gSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCB8fCB0YWcgPT09IE1lbW9Db21wb25lbnQgfHwgdGFnID09PSBGb3J3YXJkUmVmIHx8IHRhZyA9PT0gU2ltcGxlTWVtb0NvbXBvbmVudCkge1xuICAgICAgY2FuVmlld1NvdXJjZSA9IHRydWU7XG5cbiAgICAgIGlmIChzdGF0ZU5vZGUgJiYgc3RhdGVOb2RlLmNvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICAvLyBEb24ndCBzaG93IGFuIGVtcHR5IGNvbnRleHQgb2JqZWN0IGZvciBjbGFzcyBjb21wb25lbnRzIHRoYXQgZG9uJ3QgdXNlIHRoZSBjb250ZXh0IEFQSS5cbiAgICAgICAgdmFyIHNob3VsZEhpZGVDb250ZXh0ID0gZWxlbWVudFR5cGUgPT09IHR5cGVzW1wiZVwiIC8qIEVsZW1lbnRUeXBlQ2xhc3MgKi9dICYmICEodHlwZS5jb250ZXh0VHlwZXMgfHwgdHlwZS5jb250ZXh0VHlwZSk7XG5cbiAgICAgICAgaWYgKCFzaG91bGRIaWRlQ29udGV4dCkge1xuICAgICAgICAgIGNvbnRleHQgPSBzdGF0ZU5vZGUuY29udGV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZVN5bWJvbCA9PT0gUmVhY3RTeW1ib2xzW1wiY1wiIC8qIENPTlRFWFRfTlVNQkVSICovXSB8fCB0eXBlU3ltYm9sID09PSBSZWFjdFN5bWJvbHNbXCJkXCIgLyogQ09OVEVYVF9TWU1CT0xfU1RSSU5HICovXSkge1xuICAgICAgLy8gMTYuMy0xNi41IHJlYWQgZnJvbSBcInR5cGVcIiBiZWNhdXNlIHRoZSBDb25zdW1lciBpcyB0aGUgYWN0dWFsIGNvbnRleHQgb2JqZWN0LlxuICAgICAgLy8gMTYuNisgc2hvdWxkIHJlYWQgZnJvbSBcInR5cGUuX2NvbnRleHRcIiBiZWNhdXNlIENvbnN1bWVyIGNhbiBiZSBkaWZmZXJlbnQgKGluIERFVikuXG4gICAgICAvLyBOT1RFIEtlZXAgaW4gc3luYyB3aXRoIGdldERpc3BsYXlOYW1lRm9yRmliZXIoKVxuICAgICAgdmFyIGNvbnN1bWVyUmVzb2x2ZWRDb250ZXh0ID0gdHlwZS5fY29udGV4dCB8fCB0eXBlOyAvLyBHbG9iYWwgY29udGV4dCB2YWx1ZS5cblxuICAgICAgY29udGV4dCA9IGNvbnN1bWVyUmVzb2x2ZWRDb250ZXh0Ll9jdXJyZW50VmFsdWUgfHwgbnVsbDsgLy8gTG9vayBmb3Igb3ZlcnJpZGRlbiB2YWx1ZS5cblxuICAgICAgdmFyIF9jdXJyZW50ID0gZmliZXIucmV0dXJuO1xuXG4gICAgICB3aGlsZSAoX2N1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRUeXBlID0gX2N1cnJlbnQudHlwZTtcbiAgICAgICAgdmFyIGN1cnJlbnRUeXBlU3ltYm9sID0gZ2V0VHlwZVN5bWJvbChjdXJyZW50VHlwZSk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRUeXBlU3ltYm9sID09PSBSZWFjdFN5bWJvbHNbXCJuXCIgLyogUFJPVklERVJfTlVNQkVSICovXSB8fCBjdXJyZW50VHlwZVN5bWJvbCA9PT0gUmVhY3RTeW1ib2xzW1wib1wiIC8qIFBST1ZJREVSX1NZTUJPTF9TVFJJTkcgKi9dKSB7XG4gICAgICAgICAgLy8gMTYuMy4wIGV4cG9zZWQgdGhlIGNvbnRleHQgb2JqZWN0IGFzIFwiY29udGV4dFwiXG4gICAgICAgICAgLy8gUFIgIzEyNTAxIGNoYW5nZWQgaXQgdG8gXCJfY29udGV4dFwiIGZvciAxNi4zLjErXG4gICAgICAgICAgLy8gTk9URSBLZWVwIGluIHN5bmMgd2l0aCBnZXREaXNwbGF5TmFtZUZvckZpYmVyKClcbiAgICAgICAgICB2YXIgcHJvdmlkZXJSZXNvbHZlZENvbnRleHQgPSBjdXJyZW50VHlwZS5fY29udGV4dCB8fCBjdXJyZW50VHlwZS5jb250ZXh0O1xuXG4gICAgICAgICAgaWYgKHByb3ZpZGVyUmVzb2x2ZWRDb250ZXh0ID09PSBjb25zdW1lclJlc29sdmVkQ29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dCA9IF9jdXJyZW50Lm1lbW9pemVkUHJvcHMudmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfY3VycmVudCA9IF9jdXJyZW50LnJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFzTGVnYWN5Q29udGV4dCA9IGZhbHNlO1xuXG4gICAgaWYgKGNvbnRleHQgIT09IG51bGwpIHtcbiAgICAgIGhhc0xlZ2FjeUNvbnRleHQgPSAhIXR5cGUuY29udGV4dFR5cGVzOyAvLyBUbyBzaW1wbGlmeSBoeWRyYXRpb24gYW5kIGRpc3BsYXkgbG9naWMgZm9yIGNvbnRleHQsIHdyYXAgaW4gYSB2YWx1ZSBvYmplY3QuXG4gICAgICAvLyBPdGhlcndpc2Ugc2ltcGxlIHZhbHVlcyAoZS5nLiBzdHJpbmdzLCBib29sZWFucykgYmVjb21lIGhhcmRlciB0byBoYW5kbGUuXG5cbiAgICAgIGNvbnRleHQgPSB7XG4gICAgICAgIHZhbHVlOiBjb250ZXh0XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBvd25lcnMgPSBudWxsO1xuXG4gICAgaWYgKF9kZWJ1Z093bmVyKSB7XG4gICAgICBvd25lcnMgPSBbXTtcbiAgICAgIHZhciBvd25lciA9IF9kZWJ1Z093bmVyO1xuXG4gICAgICB3aGlsZSAob3duZXIgIT09IG51bGwpIHtcbiAgICAgICAgb3duZXJzLnB1c2goZmliZXJUb1NlcmlhbGl6ZWRFbGVtZW50KG93bmVyKSk7XG4gICAgICAgIG93bmVyID0gb3duZXIuX2RlYnVnT3duZXIgfHwgbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaXNUaW1lZE91dFN1c3BlbnNlID0gdGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCAmJiBtZW1vaXplZFN0YXRlICE9PSBudWxsO1xuICAgIHZhciBob29rcyA9IG51bGw7XG5cbiAgICBpZiAodXNlc0hvb2tzKSB7XG4gICAgICB2YXIgb3JpZ2luYWxDb25zb2xlTWV0aG9kcyA9IHt9OyAvLyBUZW1wb3JhcmlseSBkaXNhYmxlIGFsbCBjb25zb2xlIGxvZ2dpbmcgYmVmb3JlIHJlLXJ1bm5pbmcgdGhlIGhvb2suXG5cbiAgICAgIGZvciAodmFyIG1ldGhvZCBpbiBjb25zb2xlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb3JpZ2luYWxDb25zb2xlTWV0aG9kc1ttZXRob2RdID0gY29uc29sZVttZXRob2RdOyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICAgICAgICAgIGNvbnNvbGVbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgaG9va3MgPSBPYmplY3QocmVhY3RfZGVidWdfdG9vbHNbXCJpbnNwZWN0SG9va3NPZkZpYmVyXCJdKShmaWJlciwgcmVuZGVyZXIuY3VycmVudERpc3BhdGNoZXJSZWYsIHRydWUgLy8gSW5jbHVkZSBzb3VyY2UgbG9jYXRpb24gaW5mbyBmb3IgaG9va3NcbiAgICAgICAgKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgY29uc29sZSBmdW5jdGlvbmFsaXR5LlxuICAgICAgICBmb3IgKHZhciBfbWV0aG9kIGluIG9yaWdpbmFsQ29uc29sZU1ldGhvZHMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICAgICAgICBjb25zb2xlW19tZXRob2RdID0gb3JpZ2luYWxDb25zb2xlTWV0aG9kc1tfbWV0aG9kXTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByb290VHlwZSA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnQgPSBmaWJlcjtcblxuICAgIHdoaWxlIChjdXJyZW50LnJldHVybiAhPT0gbnVsbCkge1xuICAgICAgY3VycmVudCA9IGN1cnJlbnQucmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmaWJlclJvb3QgPSBjdXJyZW50LnN0YXRlTm9kZTtcblxuICAgIGlmIChmaWJlclJvb3QgIT0gbnVsbCAmJiBmaWJlclJvb3QuX2RlYnVnUm9vdFR5cGUgIT09IG51bGwpIHtcbiAgICAgIHJvb3RUeXBlID0gZmliZXJSb290Ll9kZWJ1Z1Jvb3RUeXBlO1xuICAgIH1cblxuICAgIHZhciBlcnJvcnMgPSBmaWJlcklEVG9FcnJvcnNNYXAuZ2V0KGlkKSB8fCBuZXcgTWFwKCk7XG4gICAgdmFyIHdhcm5pbmdzID0gZmliZXJJRFRvV2FybmluZ3NNYXAuZ2V0KGlkKSB8fCBuZXcgTWFwKCk7XG4gICAgdmFyIGlzRXJyb3JlZCA9IGZhbHNlO1xuICAgIHZhciB0YXJnZXRFcnJvckJvdW5kYXJ5SUQ7XG5cbiAgICBpZiAoaXNFcnJvckJvdW5kYXJ5KGZpYmVyKSkge1xuICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgaW5zcGVjdGVkIGVsZW1lbnQgaXMgYW4gZXJyb3IgYm91bmRhcnksXG4gICAgICAvLyBlaXRoZXIgdGhhdCB3ZSB3YW50IHRvIHVzZSBpdCB0byB0b2dnbGUgb2ZmIGVycm9yIHN0YXRlXG4gICAgICAvLyBvciB0aGF0IHdlIGFsbG93IHRvIGZvcmNlIGVycm9yIHN0YXRlIG9uIGl0IGlmIGl0J3Mgd2l0aGluIGFub3RoZXJcbiAgICAgIC8vIGVycm9yIGJvdW5kYXJ5XG4gICAgICAvL1xuICAgICAgLy8gVE9ETzogVGhpcyBmbGFnIGlzIGEgbGVha2VkIGltcGxlbWVudGF0aW9uIGRldGFpbC4gT25jZSB3ZSBzdGFydFxuICAgICAgLy8gcmVsZWFzaW5nIERldlRvb2xzIGluIGxvY2tzdGVwIHdpdGggUmVhY3QsIHdlIHNob3VsZCBpbXBvcnQgYSBmdW5jdGlvblxuICAgICAgLy8gZnJvbSB0aGUgcmVjb25jaWxlciBpbnN0ZWFkLlxuICAgICAgdmFyIERpZENhcHR1cmUgPSAxMjg7XG4gICAgICBpc0Vycm9yZWQgPSAoZmliZXIuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gMCB8fCBmb3JjZUVycm9yRm9yRmliZXJJRHMuZ2V0KGlkKSA9PT0gdHJ1ZTtcbiAgICAgIHRhcmdldEVycm9yQm91bmRhcnlJRCA9IGlzRXJyb3JlZCA/IGlkIDogZ2V0TmVhcmVzdEVycm9yQm91bmRhcnlJRChmaWJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldEVycm9yQm91bmRhcnlJRCA9IGdldE5lYXJlc3RFcnJvckJvdW5kYXJ5SUQoZmliZXIpO1xuICAgIH1cblxuICAgIHZhciBwbHVnaW5zID0ge1xuICAgICAgc3R5bGV4OiBudWxsXG4gICAgfTtcblxuICAgIGlmIChEZXZUb29sc0ZlYXR1cmVGbGFnc19jb3JlX29zc1tcImJcIiAvKiBlbmFibGVTdHlsZVhGZWF0dXJlcyAqL10pIHtcbiAgICAgIGlmIChtZW1vaXplZFByb3BzLmhhc093blByb3BlcnR5KCd4c3R5bGUnKSkge1xuICAgICAgICBwbHVnaW5zLnN0eWxleCA9IGdldFN0eWxlWERhdGEobWVtb2l6ZWRQcm9wcy54c3R5bGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpZDogaWQsXG4gICAgICAvLyBEb2VzIHRoZSBjdXJyZW50IHJlbmRlcmVyIHN1cHBvcnQgZWRpdGFibGUgaG9va3MgYW5kIGZ1bmN0aW9uIHByb3BzP1xuICAgICAgY2FuRWRpdEhvb2tzOiB0eXBlb2Ygb3ZlcnJpZGVIb29rU3RhdGUgPT09ICdmdW5jdGlvbicsXG4gICAgICBjYW5FZGl0RnVuY3Rpb25Qcm9wczogdHlwZW9mIG92ZXJyaWRlUHJvcHMgPT09ICdmdW5jdGlvbicsXG4gICAgICAvLyBEb2VzIHRoZSBjdXJyZW50IHJlbmRlcmVyIHN1cHBvcnQgYWR2YW5jZWQgZWRpdGluZyBpbnRlcmZhY2U/XG4gICAgICBjYW5FZGl0SG9va3NBbmREZWxldGVQYXRoczogdHlwZW9mIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgIGNhbkVkaXRIb29rc0FuZFJlbmFtZVBhdGhzOiB0eXBlb2Ygb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID09PSAnZnVuY3Rpb24nLFxuICAgICAgY2FuRWRpdEZ1bmN0aW9uUHJvcHNEZWxldGVQYXRoczogdHlwZW9mIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoID09PSAnZnVuY3Rpb24nLFxuICAgICAgY2FuRWRpdEZ1bmN0aW9uUHJvcHNSZW5hbWVQYXRoczogdHlwZW9mIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID09PSAnZnVuY3Rpb24nLFxuICAgICAgY2FuVG9nZ2xlRXJyb3I6IHN1cHBvcnRzVG9nZ2xpbmdFcnJvciAmJiB0YXJnZXRFcnJvckJvdW5kYXJ5SUQgIT0gbnVsbCxcbiAgICAgIC8vIElzIHRoaXMgZXJyb3IgYm91bmRhcnkgaW4gZXJyb3Igc3RhdGUuXG4gICAgICBpc0Vycm9yZWQ6IGlzRXJyb3JlZCxcbiAgICAgIHRhcmdldEVycm9yQm91bmRhcnlJRDogdGFyZ2V0RXJyb3JCb3VuZGFyeUlELFxuICAgICAgY2FuVG9nZ2xlU3VzcGVuc2U6IHN1cHBvcnRzVG9nZ2xpbmdTdXNwZW5zZSAmJiAoIC8vIElmIGl0J3Mgc2hvd2luZyB0aGUgcmVhbCBjb250ZW50LCB3ZSBjYW4gYWx3YXlzIGZsaXAgZmFsbGJhY2suXG4gICAgICAhaXNUaW1lZE91dFN1c3BlbnNlIHx8IC8vIElmIGl0J3Mgc2hvd2luZyBmYWxsYmFjayBiZWNhdXNlIHdlIHByZXZpb3VzbHkgZm9yY2VkIGl0IHRvLFxuICAgICAgLy8gYWxsb3cgdG9nZ2xpbmcgaXQgYmFjayB0byByZW1vdmUgdGhlIGZhbGxiYWNrIG92ZXJyaWRlLlxuICAgICAgZm9yY2VGYWxsYmFja0ZvclN1c3BlbnNlSURzLmhhcyhpZCkpLFxuICAgICAgLy8gQ2FuIHZpZXcgY29tcG9uZW50IHNvdXJjZSBsb2NhdGlvbi5cbiAgICAgIGNhblZpZXdTb3VyY2U6IGNhblZpZXdTb3VyY2UsXG4gICAgICAvLyBEb2VzIHRoZSBjb21wb25lbnQgaGF2ZSBsZWdhY3kgY29udGV4dCBhdHRhY2hlZCB0byBpdC5cbiAgICAgIGhhc0xlZ2FjeUNvbnRleHQ6IGhhc0xlZ2FjeUNvbnRleHQsXG4gICAgICBrZXk6IGtleSAhPSBudWxsID8ga2V5IDogbnVsbCxcbiAgICAgIGRpc3BsYXlOYW1lOiBnZXREaXNwbGF5TmFtZUZvckZpYmVyKGZpYmVyKSxcbiAgICAgIHR5cGU6IGVsZW1lbnRUeXBlLFxuICAgICAgLy8gSW5zcGVjdGFibGUgcHJvcGVydGllcy5cbiAgICAgIC8vIFRPRE8gUmV2aWV3IHNhbml0aXphdGlvbiBhcHByb2FjaCBmb3IgdGhlIGJlbG93IGluc3BlY3RhYmxlIHZhbHVlcy5cbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBob29rczogaG9va3MsXG4gICAgICBwcm9wczogbWVtb2l6ZWRQcm9wcyxcbiAgICAgIHN0YXRlOiBzaG93U3RhdGUgPyBtZW1vaXplZFN0YXRlIDogbnVsbCxcbiAgICAgIGVycm9yczogQXJyYXkuZnJvbShlcnJvcnMuZW50cmllcygpKSxcbiAgICAgIHdhcm5pbmdzOiBBcnJheS5mcm9tKHdhcm5pbmdzLmVudHJpZXMoKSksXG4gICAgICAvLyBMaXN0IG9mIG93bmVyc1xuICAgICAgb3duZXJzOiBvd25lcnMsXG4gICAgICAvLyBMb2NhdGlvbiBvZiBjb21wb25lbnQgaW4gc291cmNlIGNvZGUuXG4gICAgICBzb3VyY2U6IF9kZWJ1Z1NvdXJjZSB8fCBudWxsLFxuICAgICAgcm9vdFR5cGU6IHJvb3RUeXBlLFxuICAgICAgcmVuZGVyZXJQYWNrYWdlTmFtZTogcmVuZGVyZXIucmVuZGVyZXJQYWNrYWdlTmFtZSxcbiAgICAgIHJlbmRlcmVyVmVyc2lvbjogcmVuZGVyZXIudmVyc2lvbixcbiAgICAgIHBsdWdpbnM6IHBsdWdpbnNcbiAgICB9O1xuICB9XG5cbiAgdmFyIG1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQgPSBudWxsO1xuICB2YXIgaGFzRWxlbWVudFVwZGF0ZWRTaW5jZUxhc3RJbnNwZWN0ZWQgPSBmYWxzZTtcbiAgdmFyIGN1cnJlbnRseUluc3BlY3RlZFBhdGhzID0ge307XG5cbiAgZnVuY3Rpb24gaXNNb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50KGlkKSB7XG4gICAgcmV0dXJuIG1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQgIT09IG51bGwgJiYgbW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudC5pZCA9PT0gaWQ7XG4gIH1cblxuICBmdW5jdGlvbiBpc01vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnRDdXJyZW50KGlkKSB7XG4gICAgcmV0dXJuIGlzTW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudChpZCkgJiYgIWhhc0VsZW1lbnRVcGRhdGVkU2luY2VMYXN0SW5zcGVjdGVkO1xuICB9IC8vIFRyYWNrIHRoZSBpbnRlcnNlY3Rpb24gb2YgY3VycmVudGx5IGluc3BlY3RlZCBwYXRocyxcbiAgLy8gc28gdGhhdCB3ZSBjYW4gc2VuZCB0aGVpciBkYXRhIGFsb25nIGlmIHRoZSBlbGVtZW50IGlzIHJlLXJlbmRlcmVkLlxuXG5cbiAgZnVuY3Rpb24gbWVyZ2VJbnNwZWN0ZWRQYXRocyhwYXRoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBjdXJyZW50bHlJbnNwZWN0ZWRQYXRocztcbiAgICBwYXRoLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKCFjdXJyZW50W2tleV0pIHtcbiAgICAgICAgY3VycmVudFtrZXldID0ge307XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50W2tleV07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJc1BhdGhBbGxvd2VkKGtleSwgc2Vjb25kYXJ5Q2F0ZWdvcnkpIHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGhlbHBzIHByZXZlbnQgcHJldmlvdXNseS1pbnNwZWN0ZWQgcGF0aHMgZnJvbSBiZWluZyBkZWh5ZHJhdGVkIGluIHVwZGF0ZXMuXG4gICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgdG8gYXZvaWQgYSBiYWQgdXNlciBleHBlcmllbmNlIHdoZXJlIGV4cGFuZGVkIHRvZ2dsZXMgY29sbGFwc2Ugb24gdXBkYXRlLlxuICAgIHJldHVybiBmdW5jdGlvbiBpc1BhdGhBbGxvd2VkKHBhdGgpIHtcbiAgICAgIHN3aXRjaCAoc2Vjb25kYXJ5Q2F0ZWdvcnkpIHtcbiAgICAgICAgY2FzZSAnaG9va3MnOlxuICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gTmV2ZXIgZGVoeWRyYXRlIHRoZSBcImhvb2tzXCIgb2JqZWN0IGF0IHRoZSB0b3AgbGV2ZWxzLlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhdGhbcGF0aC5sZW5ndGggLSAyXSA9PT0gJ2hvb2tTb3VyY2UnICYmIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJ2ZpbGVOYW1lJykge1xuICAgICAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gcHJlc2VydmUgdGhlIGZ1bGwgZmlsZSBuYW1lIChVUkwpIGZvciBob29rIHNvdXJjZXNcbiAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIHVzZXIgaGFzIGVuYWJsZWQgdGhlIG5hbWVkIGhvb2tzIGZlYXR1cmUuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgdGhlIGZyb250ZW5kIG1heSBlbmQgdXAgd2l0aCBhIHBhcnRpYWwgVVJMIHdoaWNoIGl0IGNhbid0IGxvYWQuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSAnc3ViSG9va3MnIHx8IHBhdGhbcGF0aC5sZW5ndGggLSAyXSA9PT0gJ3N1Ykhvb2tzJykge1xuICAgICAgICAgICAgLy8gRGVoeWRyYXRpbmcgdGhlICdzdWJIb29rcycgcHJvcGVydHkgbWFrZXMgdGhlIEhvb2tzVHJlZSBVSSBhIGxvdCBtb3JlIGNvbXBsaWNhdGVkLFxuICAgICAgICAgICAgLy8gc28gaXQncyBlYXNpZXN0IGZvciBub3cgaWYgd2UganVzdCBkb24ndCBicmVhayBvbiB0aGlzIGJvdW5kYXJ5LlxuICAgICAgICAgICAgLy8gV2UgY2FuIGFsd2F5cyBkZWh5ZHJhdGUgYSBsZXZlbCBkZWVwZXIgKGluIHRoZSB2YWx1ZSBvYmplY3QpLlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnQgPSBrZXkgPT09IG51bGwgPyBjdXJyZW50bHlJbnNwZWN0ZWRQYXRocyA6IGN1cnJlbnRseUluc3BlY3RlZFBhdGhzW2tleV07XG5cbiAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwYXRoW2ldXTtcblxuICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGVkRWxlbWVudChpbnNwZWN0ZWRFbGVtZW50KSB7XG4gICAgdmFyIGhvb2tzID0gaW5zcGVjdGVkRWxlbWVudC5ob29rcyxcbiAgICAgICAgaWQgPSBpbnNwZWN0ZWRFbGVtZW50LmlkLFxuICAgICAgICBwcm9wcyA9IGluc3BlY3RlZEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIGZpYmVyID0gaWRUb0FyYml0cmFyeUZpYmVyTWFwLmdldChpZCk7XG5cbiAgICBpZiAoZmliZXIgPT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGZpbmQgRmliZXIgd2l0aCBpZCBcXFwiXCIuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50VHlwZSA9IGZpYmVyLmVsZW1lbnRUeXBlLFxuICAgICAgICBzdGF0ZU5vZGUgPSBmaWJlci5zdGF0ZU5vZGUsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAgICBnbG9iYWwuJHIgPSBzdGF0ZU5vZGU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICBnbG9iYWwuJHIgPSB7XG4gICAgICAgICAgaG9va3M6IGhvb2tzLFxuICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGdsb2JhbC4kciA9IHtcbiAgICAgICAgICBob29rczogaG9va3MsXG4gICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgIHR5cGU6IHR5cGUucmVuZGVyXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIGdsb2JhbC4kciA9IHtcbiAgICAgICAgICBob29rczogaG9va3MsXG4gICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgIHR5cGU6IGVsZW1lbnRUeXBlICE9IG51bGwgJiYgZWxlbWVudFR5cGUudHlwZSAhPSBudWxsID8gZWxlbWVudFR5cGUudHlwZSA6IHR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGdsb2JhbC4kciA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0b3JlQXNHbG9iYWwoaWQsIHBhdGgsIGNvdW50KSB7XG4gICAgaWYgKGlzTW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudChpZCkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IE9iamVjdCh1dGlsc1tcImpcIiAvKiBnZXRJbk9iamVjdCAqL10pKG1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQsIHBhdGgpO1xuICAgICAgdmFyIGtleSA9IFwiJHJlYWN0VGVtcFwiLmNvbmNhdChjb3VudCk7XG4gICAgICB3aW5kb3dba2V5XSA9IHZhbHVlO1xuICAgICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTZXJpYWxpemVkRWxlbWVudFZhbHVlQnlQYXRoKGlkLCBwYXRoKSB7XG4gICAgaWYgKGlzTW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudChpZCkpIHtcbiAgICAgIHZhciB2YWx1ZVRvQ29weSA9IE9iamVjdCh1dGlsc1tcImpcIiAvKiBnZXRJbk9iamVjdCAqL10pKG1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQsIHBhdGgpO1xuICAgICAgcmV0dXJuIE9iamVjdChiYWNrZW5kX3V0aWxzW1wibFwiIC8qIHNlcmlhbGl6ZVRvU3RyaW5nICovXSkodmFsdWVUb0NvcHkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3BlY3RFbGVtZW50KHJlcXVlc3RJRCwgaWQsIHBhdGgsIGZvcmNlRnVsbERhdGEpIHtcbiAgICBpZiAocGF0aCAhPT0gbnVsbCkge1xuICAgICAgbWVyZ2VJbnNwZWN0ZWRQYXRocyhwYXRoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNNb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50KGlkKSAmJiAhZm9yY2VGdWxsRGF0YSkge1xuICAgICAgaWYgKCFoYXNFbGVtZW50VXBkYXRlZFNpbmNlTGFzdEluc3BlY3RlZCkge1xuICAgICAgICBpZiAocGF0aCAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBzZWNvbmRhcnlDYXRlZ29yeSA9IG51bGw7XG5cbiAgICAgICAgICBpZiAocGF0aFswXSA9PT0gJ2hvb2tzJykge1xuICAgICAgICAgICAgc2Vjb25kYXJ5Q2F0ZWdvcnkgPSAnaG9va3MnO1xuICAgICAgICAgIH0gLy8gSWYgdGhpcyBlbGVtZW50IGhhcyBub3QgYmVlbiB1cGRhdGVkIHNpbmNlIGl0IHdhcyBsYXN0IGluc3BlY3RlZCxcbiAgICAgICAgICAvLyB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIHN1YnNldCBvZiBkYXRhIGluIHRoZSBuZXdseS1pbnNwZWN0ZWQgcGF0aC5cblxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHJlc3BvbnNlSUQ6IHJlcXVlc3RJRCxcbiAgICAgICAgICAgIHR5cGU6ICdoeWRyYXRlZC1wYXRoJyxcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICB2YWx1ZTogT2JqZWN0KGJhY2tlbmRfdXRpbHNbXCJhXCIgLyogY2xlYW5Gb3JCcmlkZ2UgKi9dKShPYmplY3QodXRpbHNbXCJqXCIgLyogZ2V0SW5PYmplY3QgKi9dKShtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50LCBwYXRoKSwgY3JlYXRlSXNQYXRoQWxsb3dlZChudWxsLCBzZWNvbmRhcnlDYXRlZ29yeSksIHBhdGgpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGVsZW1lbnQgaGFzIG5vdCBiZWVuIHVwZGF0ZWQgc2luY2UgaXQgd2FzIGxhc3QgaW5zcGVjdGVkLCB3ZSBkb24ndCBuZWVkIHRvIHJldHVybiBpdC5cbiAgICAgICAgICAvLyBJbnN0ZWFkIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgSUQgdG8gaW5kaWNhdGUgdGhhdCBpdCBoYXMgbm90IGNoYW5nZWQuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHJlc3BvbnNlSUQ6IHJlcXVlc3RJRCxcbiAgICAgICAgICAgIHR5cGU6ICduby1jaGFuZ2UnXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50bHlJbnNwZWN0ZWRQYXRocyA9IHt9O1xuICAgIH1cblxuICAgIGhhc0VsZW1lbnRVcGRhdGVkU2luY2VMYXN0SW5zcGVjdGVkID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgbW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudCA9IGluc3BlY3RFbGVtZW50UmF3KGlkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gdGhlIGVycm9yIG5hbWUgaXMgc3luY2VkIHdpdGggUmVhY3REZWJ1Z0hvb2tzXG4gICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ1JlYWN0RGVidWdUb29sc1JlbmRlckVycm9yJykge1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICdFcnJvciByZW5kZXJpbmcgaW5zcGVjdGVkIGVsZW1lbnQuJztcbiAgICAgICAgdmFyIHN0YWNrOyAvLyBMb2cgZXJyb3IgJiBjYXVzZSBmb3IgdXNlciB0byBkZWJ1Z1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSArICdcXG5cXG4nLCBlcnJvcik7XG5cbiAgICAgICAgaWYgKGVycm9yLmNhdXNlICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgX2ZpYmVyNCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoQnlJZChpZCk7XG5cbiAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9maWJlcjQgIT0gbnVsbCA/IGdldERpc3BsYXlOYW1lRm9yRmliZXIoX2ZpYmVyNCkgOiBudWxsO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlYWN0IERldlRvb2xzIGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIHRyeWluZyB0byBpbnNwZWN0IGhvb2tzLiAnICsgJ1RoaXMgaXMgbW9zdCBsaWtlbHkgY2F1c2VkIGJ5IGFuIGVycm9yIGluIGN1cnJlbnQgaW5zcGVjdGVkIGNvbXBvbmVudCcgKyAoY29tcG9uZW50TmFtZSAhPSBudWxsID8gXCI6IFxcXCJcIi5jb25jYXQoY29tcG9uZW50TmFtZSwgXCJcXFwiLlwiKSA6ICcuJykgKyAnXFxuVGhlIGVycm9yIHRocm93biBpbiB0aGUgY29tcG9uZW50IGlzOiBcXG5cXG4nLCBlcnJvci5jYXVzZSk7XG5cbiAgICAgICAgICBpZiAoZXJyb3IuY2F1c2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLmNhdXNlLm1lc3NhZ2UgfHwgbWVzc2FnZTtcbiAgICAgICAgICAgIHN0YWNrID0gZXJyb3IuY2F1c2Uuc3RhY2s7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgIGVycm9yVHlwZTogJ3VzZXInLFxuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICByZXNwb25zZUlEOiByZXF1ZXN0SUQsXG4gICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICBzdGFjazogc3RhY2tcbiAgICAgICAgfTtcbiAgICAgIH0gLy8gdGhlIGVycm9yIG5hbWUgaXMgc3luY2VkIHdpdGggUmVhY3REZWJ1Z0hvb2tzXG5cblxuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdSZWFjdERlYnVnVG9vbHNVbnN1cHBvcnRlZEhvb2tFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgIGVycm9yVHlwZTogJ3Vua25vd24taG9vaycsXG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHJlc3BvbnNlSUQ6IHJlcXVlc3RJRCxcbiAgICAgICAgICBtZXNzYWdlOiAnVW5zdXBwb3J0ZWQgaG9vayBpbiB0aGUgcmVhY3QtZGVidWctdG9vbHMgcGFja2FnZTogJyArIGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfTtcbiAgICAgIH0gLy8gTG9nIFVuY2F1Z2h0IEVycm9yXG5cblxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5zcGVjdGluZyBlbGVtZW50LlxcblxcbicsIGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgIGVycm9yVHlwZTogJ3VuY2F1Z2h0JyxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICByZXNwb25zZUlEOiByZXF1ZXN0SUQsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgIHN0YWNrOiBlcnJvci5zdGFja1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAobW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICByZXNwb25zZUlEOiByZXF1ZXN0SUQsXG4gICAgICAgIHR5cGU6ICdub3QtZm91bmQnXG4gICAgICB9O1xuICAgIH0gLy8gQW55IHRpbWUgYW4gaW5zcGVjdGVkIGVsZW1lbnQgaGFzIGFuIHVwZGF0ZSxcbiAgICAvLyB3ZSBzaG91bGQgdXBkYXRlIHRoZSBzZWxlY3RlZCAkciB2YWx1ZSBhcyB3ZWwuXG4gICAgLy8gRG8gdGhpcyBiZWZvcmUgZGVoeWRyYXRpb24gKGNsZWFuRm9yQnJpZGdlKS5cblxuXG4gICAgdXBkYXRlU2VsZWN0ZWRFbGVtZW50KG1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQpOyAvLyBDbG9uZSBiZWZvcmUgY2xlYW5pbmcgc28gdGhhdCB3ZSBwcmVzZXJ2ZSB0aGUgZnVsbCBkYXRhLlxuICAgIC8vIFRoaXMgd2lsbCBlbmFibGUgdXMgdG8gc2VuZCBwYXRjaGVzIHdpdGhvdXQgcmUtaW5zcGVjdGluZyBpZiBoeWRyYXRlZCBwYXRocyBhcmUgcmVxdWVzdGVkLlxuICAgIC8vIChSZWR1Y2luZyBob3cgb2Z0ZW4gd2Ugc2hhbGxvdy1yZW5kZXIgaXMgYSBiZXR0ZXIgRFggZm9yIGZ1bmN0aW9uIGNvbXBvbmVudHMgdGhhdCB1c2UgaG9va3MuKVxuXG4gICAgdmFyIGNsZWFuZWRJbnNwZWN0ZWRFbGVtZW50ID0gX29iamVjdFNwcmVhZCh7fSwgbW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudCk7IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgIGNsZWFuZWRJbnNwZWN0ZWRFbGVtZW50LmNvbnRleHQgPSBPYmplY3QoYmFja2VuZF91dGlsc1tcImFcIiAvKiBjbGVhbkZvckJyaWRnZSAqL10pKGNsZWFuZWRJbnNwZWN0ZWRFbGVtZW50LmNvbnRleHQsIGNyZWF0ZUlzUGF0aEFsbG93ZWQoJ2NvbnRleHQnLCBudWxsKSk7IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cbiAgICBjbGVhbmVkSW5zcGVjdGVkRWxlbWVudC5ob29rcyA9IE9iamVjdChiYWNrZW5kX3V0aWxzW1wiYVwiIC8qIGNsZWFuRm9yQnJpZGdlICovXSkoY2xlYW5lZEluc3BlY3RlZEVsZW1lbnQuaG9va3MsIGNyZWF0ZUlzUGF0aEFsbG93ZWQoJ2hvb2tzJywgJ2hvb2tzJykpOyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG4gICAgY2xlYW5lZEluc3BlY3RlZEVsZW1lbnQucHJvcHMgPSBPYmplY3QoYmFja2VuZF91dGlsc1tcImFcIiAvKiBjbGVhbkZvckJyaWRnZSAqL10pKGNsZWFuZWRJbnNwZWN0ZWRFbGVtZW50LnByb3BzLCBjcmVhdGVJc1BhdGhBbGxvd2VkKCdwcm9wcycsIG51bGwpKTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuICAgIGNsZWFuZWRJbnNwZWN0ZWRFbGVtZW50LnN0YXRlID0gT2JqZWN0KGJhY2tlbmRfdXRpbHNbXCJhXCIgLyogY2xlYW5Gb3JCcmlkZ2UgKi9dKShjbGVhbmVkSW5zcGVjdGVkRWxlbWVudC5zdGF0ZSwgY3JlYXRlSXNQYXRoQWxsb3dlZCgnc3RhdGUnLCBudWxsKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHJlc3BvbnNlSUQ6IHJlcXVlc3RJRCxcbiAgICAgIHR5cGU6ICdmdWxsLWRhdGEnLFxuICAgICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgIHZhbHVlOiBjbGVhbmVkSW5zcGVjdGVkRWxlbWVudFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBsb2dFbGVtZW50VG9Db25zb2xlKGlkKSB7XG4gICAgdmFyIHJlc3VsdCA9IGlzTW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudEN1cnJlbnQoaWQpID8gbW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudCA6IGluc3BlY3RFbGVtZW50UmF3KGlkKTtcblxuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIEZpYmVyIHdpdGggaWQgXFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3VwcG9ydHNHcm91cCA9IHR5cGVvZiBjb25zb2xlLmdyb3VwQ29sbGFwc2VkID09PSAnZnVuY3Rpb24nO1xuXG4gICAgaWYgKHN1cHBvcnRzR3JvdXApIHtcbiAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXCJbQ2xpY2sgdG8gZXhwYW5kXSAlYzxcIi5jb25jYXQocmVzdWx0LmRpc3BsYXlOYW1lIHx8ICdDb21wb25lbnQnLCBcIiAvPlwiKSwgLy8gLS1kb20tdGFnLW5hbWUtY29sb3IgaXMgdGhlIENTUyB2YXJpYWJsZSBDaHJvbWUgc3R5bGVzIEhUTUwgZWxlbWVudHMgd2l0aCBpbiB0aGUgY29uc29sZS5cbiAgICAgICdjb2xvcjogdmFyKC0tZG9tLXRhZy1uYW1lLWNvbG9yKTsgZm9udC13ZWlnaHQ6IG5vcm1hbDsnKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LnByb3BzICE9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmxvZygnUHJvcHM6JywgcmVzdWx0LnByb3BzKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LnN0YXRlICE9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmxvZygnU3RhdGU6JywgcmVzdWx0LnN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0Lmhvb2tzICE9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmxvZygnSG9va3M6JywgcmVzdWx0Lmhvb2tzKTtcbiAgICB9XG5cbiAgICB2YXIgbmF0aXZlTm9kZXMgPSBmaW5kTmF0aXZlTm9kZXNGb3JGaWJlcklEKGlkKTtcblxuICAgIGlmIChuYXRpdmVOb2RlcyAhPT0gbnVsbCkge1xuICAgICAgY29uc29sZS5sb2coJ05vZGVzOicsIG5hdGl2ZU5vZGVzKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LnNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgY29uc29sZS5sb2coJ0xvY2F0aW9uOicsIHJlc3VsdC5zb3VyY2UpO1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cuY2hyb21lIHx8IC9maXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgY29uc29sZS5sb2coJ1JpZ2h0LWNsaWNrIGFueSB2YWx1ZSB0byBzYXZlIGl0IGFzIGEgZ2xvYmFsIHZhcmlhYmxlIGZvciBmdXJ0aGVyIGluc3BlY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzR3JvdXApIHtcbiAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVQYXRoKHR5cGUsIGlkLCBob29rSUQsIHBhdGgpIHtcbiAgICB2YXIgZmliZXIgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aEJ5SWQoaWQpO1xuXG4gICAgaWYgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdjb250ZXh0JzpcbiAgICAgICAgICAvLyBUbyBzaW1wbGlmeSBoeWRyYXRpb24gYW5kIGRpc3BsYXkgb2YgcHJpbWl0aXZlIGNvbnRleHQgdmFsdWVzIChlLmcuIG51bWJlciwgc3RyaW5nKVxuICAgICAgICAgIC8vIHRoZSBpbnNwZWN0RWxlbWVudCgpIG1ldGhvZCB3cmFwcyBjb250ZXh0IGluIGEge3ZhbHVlOiAuLi59IG9iamVjdC5cbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIHJlbW92ZSB0aGUgZmlyc3QgcGFydCBvZiB0aGUgcGF0aCAodGhlIFwidmFsdWVcIikgYmVmb3JlIGNvbnRpbnVpbmcuXG4gICAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7Ly8gU2ltcGxlIGNvbnRleHQgdmFsdWUgKG5vb3ApXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0KHV0aWxzW1wiY1wiIC8qIGRlbGV0ZVBhdGhJbk9iamVjdCAqL10pKGluc3RhbmNlLmNvbnRleHQsIHBhdGgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICAgICAgICAgIC8vIEZ1bmN0aW9uIGNvbXBvbmVudHMgdXNpbmcgbGVnYWN5IGNvbnRleHQgYXJlIG5vdCBlZGl0YWJsZVxuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZXJlJ3Mgbm8gaW5zdGFuY2Ugb24gd2hpY2ggdG8gY3JlYXRlIGEgY2xvbmVkLCBtdXRhdGVkIGNvbnRleHQuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2hvb2tzJzpcbiAgICAgICAgICBpZiAodHlwZW9mIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoKGZpYmVyLCBob29rSUQsIHBhdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3Byb3BzJzpcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgoZmliZXIsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBPYmplY3QoYmFja2VuZF91dGlsc1tcImJcIiAvKiBjb3B5V2l0aERlbGV0ZSAqL10pKGluc3RhbmNlLnByb3BzLCBwYXRoKTtcbiAgICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc3RhdGUnOlxuICAgICAgICAgIE9iamVjdCh1dGlsc1tcImNcIiAvKiBkZWxldGVQYXRoSW5PYmplY3QgKi9dKShpbnN0YW5jZS5zdGF0ZSwgcGF0aCk7XG4gICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5hbWVQYXRoKHR5cGUsIGlkLCBob29rSUQsIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICB2YXIgZmliZXIgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aEJ5SWQoaWQpO1xuXG4gICAgaWYgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdjb250ZXh0JzpcbiAgICAgICAgICAvLyBUbyBzaW1wbGlmeSBoeWRyYXRpb24gYW5kIGRpc3BsYXkgb2YgcHJpbWl0aXZlIGNvbnRleHQgdmFsdWVzIChlLmcuIG51bWJlciwgc3RyaW5nKVxuICAgICAgICAgIC8vIHRoZSBpbnNwZWN0RWxlbWVudCgpIG1ldGhvZCB3cmFwcyBjb250ZXh0IGluIGEge3ZhbHVlOiAuLi59IG9iamVjdC5cbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIHJlbW92ZSB0aGUgZmlyc3QgcGFydCBvZiB0aGUgcGF0aCAodGhlIFwidmFsdWVcIikgYmVmb3JlIGNvbnRpbnVpbmcuXG4gICAgICAgICAgb2xkUGF0aCA9IG9sZFBhdGguc2xpY2UoMSk7XG4gICAgICAgICAgbmV3UGF0aCA9IG5ld1BhdGguc2xpY2UoMSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgICAgaWYgKG9sZFBhdGgubGVuZ3RoID09PSAwKSB7Ly8gU2ltcGxlIGNvbnRleHQgdmFsdWUgKG5vb3ApXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0KHV0aWxzW1wiblwiIC8qIHJlbmFtZVBhdGhJbk9iamVjdCAqL10pKGluc3RhbmNlLmNvbnRleHQsIG9sZFBhdGgsIG5ld1BhdGgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICAgICAgICAgIC8vIEZ1bmN0aW9uIGNvbXBvbmVudHMgdXNpbmcgbGVnYWN5IGNvbnRleHQgYXJlIG5vdCBlZGl0YWJsZVxuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZXJlJ3Mgbm8gaW5zdGFuY2Ugb24gd2hpY2ggdG8gY3JlYXRlIGEgY2xvbmVkLCBtdXRhdGVkIGNvbnRleHQuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2hvb2tzJzpcbiAgICAgICAgICBpZiAodHlwZW9mIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoKGZpYmVyLCBob29rSUQsIG9sZFBhdGgsIG5ld1BhdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3Byb3BzJzpcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGgoZmliZXIsIG9sZFBhdGgsIG5ld1BhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBPYmplY3QoYmFja2VuZF91dGlsc1tcImNcIiAvKiBjb3B5V2l0aFJlbmFtZSAqL10pKGluc3RhbmNlLnByb3BzLCBvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc3RhdGUnOlxuICAgICAgICAgIE9iamVjdCh1dGlsc1tcIm5cIiAvKiByZW5hbWVQYXRoSW5PYmplY3QgKi9dKShpbnN0YW5jZS5zdGF0ZSwgb2xkUGF0aCwgbmV3UGF0aCk7XG4gICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvdmVycmlkZVZhbHVlQXRQYXRoKHR5cGUsIGlkLCBob29rSUQsIHBhdGgsIHZhbHVlKSB7XG4gICAgdmFyIGZpYmVyID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGhCeUlkKGlkKTtcblxuICAgIGlmIChmaWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnY29udGV4dCc6XG4gICAgICAgICAgLy8gVG8gc2ltcGxpZnkgaHlkcmF0aW9uIGFuZCBkaXNwbGF5IG9mIHByaW1pdGl2ZSBjb250ZXh0IHZhbHVlcyAoZS5nLiBudW1iZXIsIHN0cmluZylcbiAgICAgICAgICAvLyB0aGUgaW5zcGVjdEVsZW1lbnQoKSBtZXRob2Qgd3JhcHMgY29udGV4dCBpbiBhIHt2YWx1ZTogLi4ufSBvYmplY3QuXG4gICAgICAgICAgLy8gV2UgbmVlZCB0byByZW1vdmUgdGhlIGZpcnN0IHBhcnQgb2YgdGhlIHBhdGggKHRoZSBcInZhbHVlXCIpIGJlZm9yZSBjb250aW51aW5nLlxuICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDEpO1xuXG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBjb250ZXh0IHZhbHVlXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuY29udGV4dCA9IHZhbHVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIE9iamVjdCh1dGlsc1tcIm9cIiAvKiBzZXRJbk9iamVjdCAqL10pKGluc3RhbmNlLmNvbnRleHQsIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICAgICAgICAvLyBGdW5jdGlvbiBjb21wb25lbnRzIHVzaW5nIGxlZ2FjeSBjb250ZXh0IGFyZSBub3QgZWRpdGFibGVcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGVyZSdzIG5vIGluc3RhbmNlIG9uIHdoaWNoIHRvIGNyZWF0ZSBhIGNsb25lZCwgbXV0YXRlZCBjb250ZXh0LlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdob29rcyc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBvdmVycmlkZUhvb2tTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3ZlcnJpZGVIb29rU3RhdGUoZmliZXIsIGhvb2tJRCwgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3Byb3BzJzpcbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgICAgZmliZXIucGVuZGluZ1Byb3BzID0gT2JqZWN0KGJhY2tlbmRfdXRpbHNbXCJkXCIgLyogY29weVdpdGhTZXQgKi9dKShpbnN0YW5jZS5wcm9wcywgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvdmVycmlkZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVQcm9wcyhmaWJlciwgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc3RhdGUnOlxuICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgICAgICBPYmplY3QodXRpbHNbXCJvXCIgLyogc2V0SW5PYmplY3QgKi9dKShpbnN0YW5jZS5zdGF0ZSwgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhID0gbnVsbDtcbiAgdmFyIGRpc3BsYXlOYW1lc0J5Um9vdElEID0gbnVsbDtcbiAgdmFyIGlkVG9Db250ZXh0c01hcCA9IG51bGw7XG4gIHZhciBpbml0aWFsVHJlZUJhc2VEdXJhdGlvbnNNYXAgPSBudWxsO1xuICB2YXIgaW5pdGlhbElEVG9Sb290TWFwID0gbnVsbDtcbiAgdmFyIGlzUHJvZmlsaW5nID0gZmFsc2U7XG4gIHZhciBwcm9maWxpbmdTdGFydFRpbWUgPSAwO1xuICB2YXIgcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zID0gZmFsc2U7XG4gIHZhciByb290VG9Db21taXRQcm9maWxpbmdNZXRhZGF0YU1hcCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gZ2V0UHJvZmlsaW5nRGF0YSgpIHtcbiAgICB2YXIgZGF0YUZvclJvb3RzID0gW107XG5cbiAgICBpZiAocm9vdFRvQ29tbWl0UHJvZmlsaW5nTWV0YWRhdGFNYXAgPT09IG51bGwpIHtcbiAgICAgIHRocm93IEVycm9yKCdnZXRQcm9maWxpbmdEYXRhKCkgY2FsbGVkIGJlZm9yZSBhbnkgcHJvZmlsaW5nIGRhdGEgd2FzIHJlY29yZGVkJyk7XG4gICAgfVxuXG4gICAgcm9vdFRvQ29tbWl0UHJvZmlsaW5nTWV0YWRhdGFNYXAuZm9yRWFjaChmdW5jdGlvbiAoY29tbWl0UHJvZmlsaW5nTWV0YWRhdGEsIHJvb3RJRCkge1xuICAgICAgdmFyIGNvbW1pdERhdGEgPSBbXTtcbiAgICAgIHZhciBpbml0aWFsVHJlZUJhc2VEdXJhdGlvbnMgPSBbXTtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lc0J5Um9vdElEICE9PSBudWxsICYmIGRpc3BsYXlOYW1lc0J5Um9vdElELmdldChyb290SUQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKGluaXRpYWxUcmVlQmFzZUR1cmF0aW9uc01hcCAhPSBudWxsKSB7XG4gICAgICAgIGluaXRpYWxUcmVlQmFzZUR1cmF0aW9uc01hcC5mb3JFYWNoKGZ1bmN0aW9uICh0cmVlQmFzZUR1cmF0aW9uLCBpZCkge1xuICAgICAgICAgIGlmIChpbml0aWFsSURUb1Jvb3RNYXAgIT0gbnVsbCAmJiBpbml0aWFsSURUb1Jvb3RNYXAuZ2V0KGlkKSA9PT0gcm9vdElEKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGNvbnZlcnQgbWlsbGlzZWNvbmRzIHRvIG1pY3Jvc2Vjb25kcyBpbiB0aGlzIGNhc2UsXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBwcm9maWxpbmcgc3VtbWFyeSBpcyBKU09OIHNlcmlhbGl6ZWQuXG4gICAgICAgICAgICBpbml0aWFsVHJlZUJhc2VEdXJhdGlvbnMucHVzaChbaWQsIHRyZWVCYXNlRHVyYXRpb25dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb21taXRQcm9maWxpbmdNZXRhZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChjb21taXRQcm9maWxpbmdEYXRhLCBjb21taXRJbmRleCkge1xuICAgICAgICB2YXIgY2hhbmdlRGVzY3JpcHRpb25zID0gY29tbWl0UHJvZmlsaW5nRGF0YS5jaGFuZ2VEZXNjcmlwdGlvbnMsXG4gICAgICAgICAgICBkdXJhdGlvbnMgPSBjb21taXRQcm9maWxpbmdEYXRhLmR1cmF0aW9ucyxcbiAgICAgICAgICAgIGVmZmVjdER1cmF0aW9uID0gY29tbWl0UHJvZmlsaW5nRGF0YS5lZmZlY3REdXJhdGlvbixcbiAgICAgICAgICAgIG1heEFjdHVhbER1cmF0aW9uID0gY29tbWl0UHJvZmlsaW5nRGF0YS5tYXhBY3R1YWxEdXJhdGlvbixcbiAgICAgICAgICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IGNvbW1pdFByb2ZpbGluZ0RhdGEucGFzc2l2ZUVmZmVjdER1cmF0aW9uLFxuICAgICAgICAgICAgcHJpb3JpdHlMZXZlbCA9IGNvbW1pdFByb2ZpbGluZ0RhdGEucHJpb3JpdHlMZXZlbCxcbiAgICAgICAgICAgIGNvbW1pdFRpbWUgPSBjb21taXRQcm9maWxpbmdEYXRhLmNvbW1pdFRpbWUsXG4gICAgICAgICAgICB1cGRhdGVycyA9IGNvbW1pdFByb2ZpbGluZ0RhdGEudXBkYXRlcnM7XG4gICAgICAgIHZhciBmaWJlckFjdHVhbER1cmF0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgZmliZXJTZWxmRHVyYXRpb25zID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkdXJhdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICB2YXIgZmliZXJJRCA9IGR1cmF0aW9uc1tpXTtcbiAgICAgICAgICBmaWJlckFjdHVhbER1cmF0aW9ucy5wdXNoKFtmaWJlcklELCBkdXJhdGlvbnNbaSArIDFdXSk7XG4gICAgICAgICAgZmliZXJTZWxmRHVyYXRpb25zLnB1c2goW2ZpYmVySUQsIGR1cmF0aW9uc1tpICsgMl1dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbW1pdERhdGEucHVzaCh7XG4gICAgICAgICAgY2hhbmdlRGVzY3JpcHRpb25zOiBjaGFuZ2VEZXNjcmlwdGlvbnMgIT09IG51bGwgPyBBcnJheS5mcm9tKGNoYW5nZURlc2NyaXB0aW9ucy5lbnRyaWVzKCkpIDogbnVsbCxcbiAgICAgICAgICBkdXJhdGlvbjogbWF4QWN0dWFsRHVyYXRpb24sXG4gICAgICAgICAgZWZmZWN0RHVyYXRpb246IGVmZmVjdER1cmF0aW9uLFxuICAgICAgICAgIGZpYmVyQWN0dWFsRHVyYXRpb25zOiBmaWJlckFjdHVhbER1cmF0aW9ucyxcbiAgICAgICAgICBmaWJlclNlbGZEdXJhdGlvbnM6IGZpYmVyU2VsZkR1cmF0aW9ucyxcbiAgICAgICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb246IHBhc3NpdmVFZmZlY3REdXJhdGlvbixcbiAgICAgICAgICBwcmlvcml0eUxldmVsOiBwcmlvcml0eUxldmVsLFxuICAgICAgICAgIHRpbWVzdGFtcDogY29tbWl0VGltZSxcbiAgICAgICAgICB1cGRhdGVyczogdXBkYXRlcnNcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGRhdGFGb3JSb290cy5wdXNoKHtcbiAgICAgICAgY29tbWl0RGF0YTogY29tbWl0RGF0YSxcbiAgICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICBpbml0aWFsVHJlZUJhc2VEdXJhdGlvbnM6IGluaXRpYWxUcmVlQmFzZUR1cmF0aW9ucyxcbiAgICAgICAgcm9vdElEOiByb290SURcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciB0aW1lbGluZURhdGEgPSBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBnZXRUaW1lbGluZURhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBjdXJyZW50VGltZWxpbmVEYXRhID0gZ2V0VGltZWxpbmVEYXRhKCk7XG5cbiAgICAgIGlmIChjdXJyZW50VGltZWxpbmVEYXRhKSB7XG4gICAgICAgIHZhciBiYXRjaFVJRFRvTWVhc3VyZXNNYXAgPSBjdXJyZW50VGltZWxpbmVEYXRhLmJhdGNoVUlEVG9NZWFzdXJlc01hcCxcbiAgICAgICAgICAgIGludGVybmFsTW9kdWxlU291cmNlVG9SYW5nZXMgPSBjdXJyZW50VGltZWxpbmVEYXRhLmludGVybmFsTW9kdWxlU291cmNlVG9SYW5nZXMsXG4gICAgICAgICAgICBsYW5lVG9MYWJlbE1hcCA9IGN1cnJlbnRUaW1lbGluZURhdGEubGFuZVRvTGFiZWxNYXAsXG4gICAgICAgICAgICBsYW5lVG9SZWFjdE1lYXN1cmVNYXAgPSBjdXJyZW50VGltZWxpbmVEYXRhLmxhbmVUb1JlYWN0TWVhc3VyZU1hcCxcbiAgICAgICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoY3VycmVudFRpbWVsaW5lRGF0YSwgW1wiYmF0Y2hVSURUb01lYXN1cmVzTWFwXCIsIFwiaW50ZXJuYWxNb2R1bGVTb3VyY2VUb1Jhbmdlc1wiLCBcImxhbmVUb0xhYmVsTWFwXCIsIFwibGFuZVRvUmVhY3RNZWFzdXJlTWFwXCJdKTtcblxuICAgICAgICB0aW1lbGluZURhdGEgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlc3QpLCB7fSwge1xuICAgICAgICAgIC8vIE1vc3Qgb2YgdGhlIGRhdGEgaXMgc2FmZSB0byBwYXJzZSBhcy1pcyxcbiAgICAgICAgICAvLyBidXQgd2UgbmVlZCB0byBjb252ZXJ0IHRoZSBuZXN0ZWQgQXJyYXlzIGJhY2sgdG8gTWFwcy5cbiAgICAgICAgICAvLyBNb3N0IG9mIHRoZSBkYXRhIGlzIHNhZmUgdG8gc2VyaWFsaXplIGFzLWlzLFxuICAgICAgICAgIC8vIGJ1dCB3ZSBuZWVkIHRvIGNvbnZlcnQgdGhlIE1hcHMgdG8gbmVzdGVkIEFycmF5cy5cbiAgICAgICAgICBiYXRjaFVJRFRvTWVhc3VyZXNLZXlWYWx1ZUFycmF5OiBBcnJheS5mcm9tKGJhdGNoVUlEVG9NZWFzdXJlc01hcC5lbnRyaWVzKCkpLFxuICAgICAgICAgIGludGVybmFsTW9kdWxlU291cmNlVG9SYW5nZXM6IEFycmF5LmZyb20oaW50ZXJuYWxNb2R1bGVTb3VyY2VUb1Jhbmdlcy5lbnRyaWVzKCkpLFxuICAgICAgICAgIGxhbmVUb0xhYmVsS2V5VmFsdWVBcnJheTogQXJyYXkuZnJvbShsYW5lVG9MYWJlbE1hcC5lbnRyaWVzKCkpLFxuICAgICAgICAgIGxhbmVUb1JlYWN0TWVhc3VyZUtleVZhbHVlQXJyYXk6IEFycmF5LmZyb20obGFuZVRvUmVhY3RNZWFzdXJlTWFwLmVudHJpZXMoKSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGFGb3JSb290czogZGF0YUZvclJvb3RzLFxuICAgICAgcmVuZGVyZXJJRDogcmVuZGVyZXJJRCxcbiAgICAgIHRpbWVsaW5lRGF0YTogdGltZWxpbmVEYXRhXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0UHJvZmlsaW5nKHNob3VsZFJlY29yZENoYW5nZURlc2NyaXB0aW9ucykge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlY29yZENoYW5nZURlc2NyaXB0aW9ucyA9IHNob3VsZFJlY29yZENoYW5nZURlc2NyaXB0aW9uczsgLy8gQ2FwdHVyZSBpbml0aWFsIHZhbHVlcyBhcyBvZiB0aGUgdGltZSBwcm9maWxpbmcgc3RhcnRzLlxuICAgIC8vIEl0J3MgaW1wb3J0YW50IHdlIHNuYXBzaG90IGJvdGggdGhlIGR1cmF0aW9ucyBhbmQgdGhlIGlkLXRvLXJvb3QgbWFwLFxuICAgIC8vIHNpbmNlIGVpdGhlciBvZiB0aGVzZSBtYXkgY2hhbmdlIGR1cmluZyB0aGUgcHJvZmlsaW5nIHNlc3Npb25cbiAgICAvLyAoZS5nLiB3aGVuIGEgZmliZXIgaXMgcmUtcmVuZGVyZWQgb3Igd2hlbiBhIGZpYmVyIGdldHMgcmVtb3ZlZCkuXG5cbiAgICBkaXNwbGF5TmFtZXNCeVJvb3RJRCA9IG5ldyBNYXAoKTtcbiAgICBpbml0aWFsVHJlZUJhc2VEdXJhdGlvbnNNYXAgPSBuZXcgTWFwKGlkVG9UcmVlQmFzZUR1cmF0aW9uTWFwKTtcbiAgICBpbml0aWFsSURUb1Jvb3RNYXAgPSBuZXcgTWFwKGlkVG9Sb290TWFwKTtcbiAgICBpZFRvQ29udGV4dHNNYXAgPSBuZXcgTWFwKCk7XG4gICAgaG9vay5nZXRGaWJlclJvb3RzKHJlbmRlcmVySUQpLmZvckVhY2goZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgIHZhciByb290SUQgPSBnZXRGaWJlcklEVGhyb3dzKHJvb3QuY3VycmVudCk7XG4gICAgICBkaXNwbGF5TmFtZXNCeVJvb3RJRC5zZXQocm9vdElELCBnZXREaXNwbGF5TmFtZUZvclJvb3Qocm9vdC5jdXJyZW50KSk7XG5cbiAgICAgIGlmIChzaG91bGRSZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMpIHtcbiAgICAgICAgLy8gUmVjb3JkIGFsbCBjb250ZXh0cyBhdCB0aGUgdGltZSBwcm9maWxpbmcgaXMgc3RhcnRlZC5cbiAgICAgICAgLy8gRmliZXJzIG9ubHkgc3RvcmUgdGhlIGN1cnJlbnQgY29udGV4dCB2YWx1ZSxcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byB0cmFjayB0aGVtIHNlcGFyYXRlbHkgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIGNoYW5nZWQga2V5cy5cbiAgICAgICAgY3Jhd2xUb0luaXRpYWxpemVDb250ZXh0c01hcChyb290LmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlzUHJvZmlsaW5nID0gdHJ1ZTtcbiAgICBwcm9maWxpbmdTdGFydFRpbWUgPSByZW5kZXJlcl9nZXRDdXJyZW50VGltZSgpO1xuICAgIHJvb3RUb0NvbW1pdFByb2ZpbGluZ01ldGFkYXRhTWFwID0gbmV3IE1hcCgpO1xuXG4gICAgaWYgKHRvZ2dsZVByb2ZpbGluZ1N0YXR1cyAhPT0gbnVsbCkge1xuICAgICAgdG9nZ2xlUHJvZmlsaW5nU3RhdHVzKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0b3BQcm9maWxpbmcoKSB7XG4gICAgaXNQcm9maWxpbmcgPSBmYWxzZTtcbiAgICByZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMgPSBmYWxzZTtcblxuICAgIGlmICh0b2dnbGVQcm9maWxpbmdTdGF0dXMgIT09IG51bGwpIHtcbiAgICAgIHRvZ2dsZVByb2ZpbGluZ1N0YXR1cyhmYWxzZSk7XG4gICAgfVxuICB9IC8vIEF1dG9tYXRpY2FsbHkgc3RhcnQgcHJvZmlsaW5nIHNvIHRoYXQgd2UgZG9uJ3QgbWlzcyB0aW1pbmcgaW5mbyBmcm9tIGluaXRpYWwgXCJtb3VudFwiLlxuXG5cbiAgaWYgKE9iamVjdChzdG9yYWdlW1wiY1wiIC8qIHNlc3Npb25TdG9yYWdlR2V0SXRlbSAqL10pKGNvbnN0YW50c1tcImtcIiAvKiBTRVNTSU9OX1NUT1JBR0VfUkVMT0FEX0FORF9QUk9GSUxFX0tFWSAqL10pID09PSAndHJ1ZScpIHtcbiAgICBzdGFydFByb2ZpbGluZyhPYmplY3Qoc3RvcmFnZVtcImNcIiAvKiBzZXNzaW9uU3RvcmFnZUdldEl0ZW0gKi9dKShjb25zdGFudHNbXCJqXCIgLyogU0VTU0lPTl9TVE9SQUdFX1JFQ09SRF9DSEFOR0VfREVTQ1JJUFRJT05TX0tFWSAqL10pID09PSAndHJ1ZScpO1xuICB9IC8vIFJlYWN0IHdpbGwgc3dpdGNoIGJldHdlZW4gdGhlc2UgaW1wbGVtZW50YXRpb25zIGRlcGVuZGluZyBvbiB3aGV0aGVyXG4gIC8vIHdlIGhhdmUgYW55IG1hbnVhbGx5IHN1c3BlbmRlZC9lcnJvcmVkLW91dCBGaWJlcnMgb3Igbm90LlxuXG5cbiAgZnVuY3Rpb24gc2hvdWxkRXJyb3JGaWJlckFsd2F5c051bGwoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gTWFwIG9mIGlkIGFuZCBpdHMgZm9yY2UgZXJyb3Igc3RhdHVzOiB0cnVlIChlcnJvciksIGZhbHNlICh0b2dnbGVkIG9mZiksXG4gIC8vIG51bGwgKGRvIG5vdGhpbmcpXG5cblxuICB2YXIgZm9yY2VFcnJvckZvckZpYmVySURzID0gbmV3IE1hcCgpO1xuXG4gIGZ1bmN0aW9uIHNob3VsZEVycm9yRmliZXJBY2NvcmRpbmdUb01hcChmaWJlcikge1xuICAgIGlmICh0eXBlb2Ygc2V0RXJyb3JIYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIG92ZXJyaWRlRXJyb3IoKSB0byBub3QgZ2V0IGNhbGxlZCBmb3IgZWFybGllciBSZWFjdCB2ZXJzaW9ucy4nKTtcbiAgICB9XG5cbiAgICB2YXIgaWQgPSBnZXRGaWJlcklEVW5zYWZlKGZpYmVyKTtcblxuICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHN0YXR1cyA9IG51bGw7XG5cbiAgICBpZiAoZm9yY2VFcnJvckZvckZpYmVySURzLmhhcyhpZCkpIHtcbiAgICAgIHN0YXR1cyA9IGZvcmNlRXJyb3JGb3JGaWJlcklEcy5nZXQoaWQpO1xuXG4gICAgICBpZiAoc3RhdHVzID09PSBmYWxzZSkge1xuICAgICAgICAvLyBUUklDS1kgb3ZlcnJpZGVFcnJvciBhZGRzIGVudHJpZXMgdG8gdGhpcyBNYXAsXG4gICAgICAgIC8vIHNvIGlkZWFsbHkgaXQgd291bGQgYmUgdGhlIG1ldGhvZCB0aGF0IGNsZWFycyB0aGVtIHRvbyxcbiAgICAgICAgLy8gYnV0IHRoYXQgd291bGQgYnJlYWsgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIGZlYXR1cmUsXG4gICAgICAgIC8vIHNpbmNlIERldlRvb2xzIG5lZWRzIHRvIHRlbGwgUmVhY3QgdG8gYWN0IGRpZmZlcmVudGx5IHRoYW4gaXQgbm9ybWFsbHkgd291bGRcbiAgICAgICAgLy8gKGRvbid0IGp1c3QgcmUtcmVuZGVyIHRoZSBmYWlsZWQgYm91bmRhcnksIGJ1dCByZXNldCBpdHMgZXJyb3JlZCBzdGF0ZSB0b28pLlxuICAgICAgICAvLyBTbyB3ZSBjYW4gb25seSBjbGVhciBpdCBhZnRlciB0ZWxsaW5nIFJlYWN0IHRvIHJlc2V0IHRoZSBzdGF0ZS5cbiAgICAgICAgLy8gVGVjaG5pY2FsbHkgdGhpcyBpcyBwcmVtYXR1cmUgYW5kIHdlIHNob3VsZCBzY2hlZHVsZSBpdCBmb3IgbGF0ZXIsXG4gICAgICAgIC8vIHNpbmNlIHRoZSByZW5kZXIgY291bGQgYWx3YXlzIGZhaWwgd2l0aG91dCBjb21taXR0aW5nIHRoZSB1cGRhdGVkIGVycm9yIGJvdW5kYXJ5LFxuICAgICAgICAvLyBidXQgc2luY2UgdGhpcyBpcyBhIERFVi1vbmx5IGZlYXR1cmUsIHRoZSBzaW1wbGljaXR5IGlzIHdvcnRoIHRoZSB0cmFkZSBvZmYuXG4gICAgICAgIGZvcmNlRXJyb3JGb3JGaWJlcklEcy5kZWxldGUoaWQpO1xuXG4gICAgICAgIGlmIChmb3JjZUVycm9yRm9yRmliZXJJRHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIC8vIExhc3Qgb3ZlcnJpZGUgaXMgZ29uZS4gU3dpdGNoIFJlYWN0IGJhY2sgdG8gZmFzdCBwYXRoLlxuICAgICAgICAgIHNldEVycm9ySGFuZGxlcihzaG91bGRFcnJvckZpYmVyQWx3YXlzTnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdHVzO1xuICB9XG5cbiAgZnVuY3Rpb24gb3ZlcnJpZGVFcnJvcihpZCwgZm9yY2VFcnJvcikge1xuICAgIGlmICh0eXBlb2Ygc2V0RXJyb3JIYW5kbGVyICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBzY2hlZHVsZVVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBvdmVycmlkZUVycm9yKCkgdG8gbm90IGdldCBjYWxsZWQgZm9yIGVhcmxpZXIgUmVhY3QgdmVyc2lvbnMuJyk7XG4gICAgfVxuXG4gICAgZm9yY2VFcnJvckZvckZpYmVySURzLnNldChpZCwgZm9yY2VFcnJvcik7XG5cbiAgICBpZiAoZm9yY2VFcnJvckZvckZpYmVySURzLnNpemUgPT09IDEpIHtcbiAgICAgIC8vIEZpcnN0IG92ZXJyaWRlIGlzIGFkZGVkLiBTd2l0Y2ggUmVhY3QgdG8gc2xvd2VyIHBhdGguXG4gICAgICBzZXRFcnJvckhhbmRsZXIoc2hvdWxkRXJyb3JGaWJlckFjY29yZGluZ1RvTWFwKTtcbiAgICB9XG5cbiAgICB2YXIgZmliZXIgPSBpZFRvQXJiaXRyYXJ5RmliZXJNYXAuZ2V0KGlkKTtcblxuICAgIGlmIChmaWJlciAhPSBudWxsKSB7XG4gICAgICBzY2hlZHVsZVVwZGF0ZShmaWJlcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkU3VzcGVuZEZpYmVyQWx3YXlzRmFsc2UoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGZvcmNlRmFsbGJhY2tGb3JTdXNwZW5zZUlEcyA9IG5ldyBTZXQoKTtcblxuICBmdW5jdGlvbiBzaG91bGRTdXNwZW5kRmliZXJBY2NvcmRpbmdUb1NldChmaWJlcikge1xuICAgIHZhciBtYXliZUlEID0gZ2V0RmliZXJJRFVuc2FmZShmaWJlcik7XG4gICAgcmV0dXJuIG1heWJlSUQgIT09IG51bGwgJiYgZm9yY2VGYWxsYmFja0ZvclN1c3BlbnNlSURzLmhhcyhtYXliZUlEKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG92ZXJyaWRlU3VzcGVuc2UoaWQsIGZvcmNlRmFsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHNldFN1c3BlbnNlSGFuZGxlciAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygc2NoZWR1bGVVcGRhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgb3ZlcnJpZGVTdXNwZW5zZSgpIHRvIG5vdCBnZXQgY2FsbGVkIGZvciBlYXJsaWVyIFJlYWN0IHZlcnNpb25zLicpO1xuICAgIH1cblxuICAgIGlmIChmb3JjZUZhbGxiYWNrKSB7XG4gICAgICBmb3JjZUZhbGxiYWNrRm9yU3VzcGVuc2VJRHMuYWRkKGlkKTtcblxuICAgICAgaWYgKGZvcmNlRmFsbGJhY2tGb3JTdXNwZW5zZUlEcy5zaXplID09PSAxKSB7XG4gICAgICAgIC8vIEZpcnN0IG92ZXJyaWRlIGlzIGFkZGVkLiBTd2l0Y2ggUmVhY3QgdG8gc2xvd2VyIHBhdGguXG4gICAgICAgIHNldFN1c3BlbnNlSGFuZGxlcihzaG91bGRTdXNwZW5kRmliZXJBY2NvcmRpbmdUb1NldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcmNlRmFsbGJhY2tGb3JTdXNwZW5zZUlEcy5kZWxldGUoaWQpO1xuXG4gICAgICBpZiAoZm9yY2VGYWxsYmFja0ZvclN1c3BlbnNlSURzLnNpemUgPT09IDApIHtcbiAgICAgICAgLy8gTGFzdCBvdmVycmlkZSBpcyBnb25lLiBTd2l0Y2ggUmVhY3QgYmFjayB0byBmYXN0IHBhdGguXG4gICAgICAgIHNldFN1c3BlbnNlSGFuZGxlcihzaG91bGRTdXNwZW5kRmliZXJBbHdheXNGYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZpYmVyID0gaWRUb0FyYml0cmFyeUZpYmVyTWFwLmdldChpZCk7XG5cbiAgICBpZiAoZmliZXIgIT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVVcGRhdGUoZmliZXIpO1xuICAgIH1cbiAgfSAvLyBSZW1lbWJlciBpZiB3ZSdyZSB0cnlpbmcgdG8gcmVzdG9yZSB0aGUgc2VsZWN0aW9uIGFmdGVyIHJlbG9hZC5cbiAgLy8gSW4gdGhhdCBjYXNlLCB3ZSdsbCBkbyBzb21lIGV4dHJhIGNoZWNrcyBmb3IgbWF0Y2hpbmcgbW91bnRzLlxuXG5cbiAgdmFyIHRyYWNrZWRQYXRoID0gbnVsbDtcbiAgdmFyIHRyYWNrZWRQYXRoTWF0Y2hGaWJlciA9IG51bGw7XG4gIHZhciB0cmFja2VkUGF0aE1hdGNoRGVwdGggPSAtMTtcbiAgdmFyIG1pZ2h0QmVPblRyYWNrZWRQYXRoID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gc2V0VHJhY2tlZFBhdGgocGF0aCkge1xuICAgIGlmIChwYXRoID09PSBudWxsKSB7XG4gICAgICB0cmFja2VkUGF0aE1hdGNoRmliZXIgPSBudWxsO1xuICAgICAgdHJhY2tlZFBhdGhNYXRjaERlcHRoID0gLTE7XG4gICAgICBtaWdodEJlT25UcmFja2VkUGF0aCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRyYWNrZWRQYXRoID0gcGF0aDtcbiAgfSAvLyBXZSBjYWxsIHRoaXMgYmVmb3JlIHRyYXZlcnNpbmcgYSBuZXcgbW91bnQuXG4gIC8vIEl0IHJlbWVtYmVycyB3aGV0aGVyIHRoaXMgRmliZXIgaXMgdGhlIG5leHQgYmVzdCBtYXRjaCBmb3IgdHJhY2tlZCBwYXRoLlxuICAvLyBUaGUgcmV0dXJuIHZhbHVlIHNpZ25hbHMgd2hldGhlciB3ZSBzaG91bGQga2VlcCBtYXRjaGluZyBzaWJsaW5ncyBvciBub3QuXG5cblxuICBmdW5jdGlvbiB1cGRhdGVUcmFja2VkUGF0aFN0YXRlQmVmb3JlTW91bnQoZmliZXIpIHtcbiAgICBpZiAodHJhY2tlZFBhdGggPT09IG51bGwgfHwgIW1pZ2h0QmVPblRyYWNrZWRQYXRoKSB7XG4gICAgICAvLyBGYXN0IHBhdGg6IHRoZXJlJ3Mgbm90aGluZyB0byB0cmFjayBzbyBkbyBub3RoaW5nIGFuZCBpZ25vcmUgc2libGluZ3MuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHJldHVybkZpYmVyID0gZmliZXIucmV0dXJuO1xuICAgIHZhciByZXR1cm5BbHRlcm5hdGUgPSByZXR1cm5GaWJlciAhPT0gbnVsbCA/IHJldHVybkZpYmVyLmFsdGVybmF0ZSA6IG51bGw7IC8vIEJ5IG5vdyB3ZSBrbm93IHRoZXJlJ3Mgc29tZSBzZWxlY3Rpb24gdG8gcmVzdG9yZSwgYW5kIHRoaXMgaXMgYSBuZXcgRmliZXIuXG4gICAgLy8gSXMgdGhpcyBuZXdseSBtb3VudGVkIEZpYmVyIGEgZGlyZWN0IGNoaWxkIG9mIHRoZSBjdXJyZW50IGJlc3QgbWF0Y2g/XG4gICAgLy8gKFRoaXMgd2lsbCBhbHNvIGJlIHRydWUgZm9yIG5ldyByb290cyBpZiB3ZSBoYXZlbid0IG1hdGNoZWQgYW55dGhpbmcgeWV0LilcblxuICAgIGlmICh0cmFja2VkUGF0aE1hdGNoRmliZXIgPT09IHJldHVybkZpYmVyIHx8IHRyYWNrZWRQYXRoTWF0Y2hGaWJlciA9PT0gcmV0dXJuQWx0ZXJuYXRlICYmIHJldHVybkFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gSXMgdGhpcyB0aGUgbmV4dCBGaWJlciB3ZSBzaG91bGQgc2VsZWN0PyBMZXQncyBjb21wYXJlIHRoZSBmcmFtZXMuXG4gICAgICB2YXIgYWN0dWFsRnJhbWUgPSBnZXRQYXRoRnJhbWUoZmliZXIpOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuICAgICAgdmFyIGV4cGVjdGVkRnJhbWUgPSB0cmFja2VkUGF0aFt0cmFja2VkUGF0aE1hdGNoRGVwdGggKyAxXTtcblxuICAgICAgaWYgKGV4cGVjdGVkRnJhbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIHNlZSBhIGZyYW1lIGF0IHRoZSBuZXh0IGRlcHRoLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWN0dWFsRnJhbWUuaW5kZXggPT09IGV4cGVjdGVkRnJhbWUuaW5kZXggJiYgYWN0dWFsRnJhbWUua2V5ID09PSBleHBlY3RlZEZyYW1lLmtleSAmJiBhY3R1YWxGcmFtZS5kaXNwbGF5TmFtZSA9PT0gZXhwZWN0ZWRGcmFtZS5kaXNwbGF5TmFtZSkge1xuICAgICAgICAvLyBXZSBoYXZlIG91ciBuZXh0IG1hdGNoLlxuICAgICAgICB0cmFja2VkUGF0aE1hdGNoRmliZXIgPSBmaWJlcjtcbiAgICAgICAgdHJhY2tlZFBhdGhNYXRjaERlcHRoKys7IC8vIEFyZSB3ZSBvdXQgb2YgZnJhbWVzIHRvIG1hdGNoP1xuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuICAgICAgICBpZiAodHJhY2tlZFBhdGhNYXRjaERlcHRoID09PSB0cmFja2VkUGF0aC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgLy8gVGhlcmUncyBub3RoaW5nIHRoYXQgY2FuIHBvc3NpYmx5IG1hdGNoIGFmdGVyd2FyZHMuXG4gICAgICAgICAgLy8gRG9uJ3QgY2hlY2sgdGhlIGNoaWxkcmVuLlxuICAgICAgICAgIG1pZ2h0QmVPblRyYWNrZWRQYXRoID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ2hlY2sgdGhlIGNoaWxkcmVuLCBhcyB0aGV5IG1pZ2h0IHJldmVhbCB0aGUgbmV4dCBtYXRjaC5cbiAgICAgICAgICBtaWdodEJlT25UcmFja2VkUGF0aCA9IHRydWU7XG4gICAgICAgIH0gLy8gSW4gZWl0aGVyIGNhc2UsIHNpbmNlIHdlIGhhdmUgYSBtYXRjaCwgd2UgZG9uJ3QgbmVlZFxuICAgICAgICAvLyB0byBjaGVjayB0aGUgc2libGluZ3MuIFRoZXknbGwgbmV2ZXIgbWF0Y2guXG5cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSAvLyBUaGlzIEZpYmVyJ3MgcGFyZW50IGlzIG9uIHRoZSBwYXRoLCBidXQgdGhpcyBGaWJlciBpdHNlbGYgaXNuJ3QuXG4gICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIGNoZWNrIGl0cyBjaGlsZHJlbi0tdGhleSB3b24ndCBiZSBvbiB0aGUgcGF0aCBlaXRoZXIuXG5cblxuICAgIG1pZ2h0QmVPblRyYWNrZWRQYXRoID0gZmFsc2U7IC8vIEhvd2V2ZXIsIG9uZSBvZiBpdHMgc2libGluZ3MgbWF5IGJlIG9uIHRoZSBwYXRoIHNvIGtlZXAgc2VhcmNoaW5nLlxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVUcmFja2VkUGF0aFN0YXRlQWZ0ZXJNb3VudChtaWdodFNpYmxpbmdzQmVPblRyYWNrZWRQYXRoKSB7XG4gICAgLy8gdXBkYXRlVHJhY2tlZFBhdGhTdGF0ZUJlZm9yZU1vdW50KCkgdG9sZCB1cyB3aGV0aGVyIHRvIG1hdGNoIHNpYmxpbmdzLlxuICAgIC8vIE5vdyB0aGF0IHdlJ3JlIGVudGVyaW5nIHNpYmxpbmdzLCBsZXQncyB1c2UgdGhhdCBpbmZvcm1hdGlvbi5cbiAgICBtaWdodEJlT25UcmFja2VkUGF0aCA9IG1pZ2h0U2libGluZ3NCZU9uVHJhY2tlZFBhdGg7XG4gIH0gLy8gUm9vdHMgZG9uJ3QgaGF2ZSBhIHJlYWwgcGVyc2lzdGVudCBpZGVudGl0eS5cbiAgLy8gQSByb290J3MgXCJwc2V1ZG8ga2V5XCIgaXMgXCJjaGlsZERpc3BsYXlOYW1lOmluZGV4V2l0aFRoYXROYW1lXCIuXG4gIC8vIEZvciBleGFtcGxlLCBcIkFwcDowXCIgb3IsIGluIGNhc2Ugb2Ygc2ltaWxhciByb290cywgXCJTdG9yeTowXCIsIFwiU3Rvcnk6MVwiLCBldGMuXG4gIC8vIFdlIHdpbGwgdXNlIHRoaXMgdG8gdHJ5IHRvIGRpc2FtYmlndWF0ZSByb290cyB3aGVuIHJlc3RvcmluZyBzZWxlY3Rpb24gYmV0d2VlbiByZWxvYWRzLlxuXG5cbiAgdmFyIHJvb3RQc2V1ZG9LZXlzID0gbmV3IE1hcCgpO1xuICB2YXIgcm9vdERpc3BsYXlOYW1lQ291bnRlciA9IG5ldyBNYXAoKTtcblxuICBmdW5jdGlvbiBzZXRSb290UHNldWRvS2V5KGlkLCBmaWJlcikge1xuICAgIHZhciBuYW1lID0gZ2V0RGlzcGxheU5hbWVGb3JSb290KGZpYmVyKTtcbiAgICB2YXIgY291bnRlciA9IHJvb3REaXNwbGF5TmFtZUNvdW50ZXIuZ2V0KG5hbWUpIHx8IDA7XG4gICAgcm9vdERpc3BsYXlOYW1lQ291bnRlci5zZXQobmFtZSwgY291bnRlciArIDEpO1xuICAgIHZhciBwc2V1ZG9LZXkgPSBcIlwiLmNvbmNhdChuYW1lLCBcIjpcIikuY29uY2F0KGNvdW50ZXIpO1xuICAgIHJvb3RQc2V1ZG9LZXlzLnNldChpZCwgcHNldWRvS2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVJvb3RQc2V1ZG9LZXkoaWQpIHtcbiAgICB2YXIgcHNldWRvS2V5ID0gcm9vdFBzZXVkb0tleXMuZ2V0KGlkKTtcblxuICAgIGlmIChwc2V1ZG9LZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCByb290IHBzZXVkbyBrZXkgdG8gYmUga25vd24uJyk7XG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBwc2V1ZG9LZXkuc2xpY2UoMCwgcHNldWRvS2V5Lmxhc3RJbmRleE9mKCc6JykpO1xuICAgIHZhciBjb3VudGVyID0gcm9vdERpc3BsYXlOYW1lQ291bnRlci5nZXQobmFtZSk7XG5cbiAgICBpZiAoY291bnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGNvdW50ZXIgdG8gYmUga25vd24uJyk7XG4gICAgfVxuXG4gICAgaWYgKGNvdW50ZXIgPiAxKSB7XG4gICAgICByb290RGlzcGxheU5hbWVDb3VudGVyLnNldChuYW1lLCBjb3VudGVyIC0gMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3REaXNwbGF5TmFtZUNvdW50ZXIuZGVsZXRlKG5hbWUpO1xuICAgIH1cblxuICAgIHJvb3RQc2V1ZG9LZXlzLmRlbGV0ZShpZCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREaXNwbGF5TmFtZUZvclJvb3QoZmliZXIpIHtcbiAgICB2YXIgcHJlZmVycmVkRGlzcGxheU5hbWUgPSBudWxsO1xuICAgIHZhciBmYWxsYmFja0Rpc3BsYXlOYW1lID0gbnVsbDtcbiAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDsgLy8gR28gYXQgbW9zdCB0aHJlZSBsZXZlbHMgZGVlcCBpbnRvIGRpcmVjdCBjaGlsZHJlblxuICAgIC8vIHdoaWxlIHNlYXJjaGluZyBmb3IgYSBjaGlsZCB0aGF0IGhhcyBhIGRpc3BsYXlOYW1lLlxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgIGlmIChjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihjaGlsZCk7XG5cbiAgICAgIGlmIChkaXNwbGF5TmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBQcmVmZXIgZGlzcGxheSBuYW1lcyB0aGF0IHdlIGdldCBmcm9tIHVzZXItZGVmaW5lZCBjb21wb25lbnRzLlxuICAgICAgICAvLyBXZSB3YW50IHRvIGF2b2lkIHVzaW5nIGUuZy4gJ1N1c3BlbnNlJyB1bmxlc3Mgd2UgZmluZCBub3RoaW5nIGVsc2UuXG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIFRoZXJlJ3MgYSBmZXcgdXNlci1kZWZpbmVkIHRhZ3MsIGJ1dCB3ZSdsbCBwcmVmZXIgdGhlIG9uZXNcbiAgICAgICAgICAvLyB0aGF0IGFyZSB1c3VhbGx5IGV4cGxpY2l0bHkgbmFtZWQgKGZ1bmN0aW9uIG9yIGNsYXNzIGNvbXBvbmVudHMpLlxuICAgICAgICAgIHByZWZlcnJlZERpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZmFsbGJhY2tEaXNwbGF5TmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGZhbGxiYWNrRGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocHJlZmVycmVkRGlzcGxheU5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuY2hpbGQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZlcnJlZERpc3BsYXlOYW1lIHx8IGZhbGxiYWNrRGlzcGxheU5hbWUgfHwgJ0Fub255bW91cyc7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXRoRnJhbWUoZmliZXIpIHtcbiAgICB2YXIga2V5ID0gZmliZXIua2V5O1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpO1xuICAgIHZhciBpbmRleCA9IGZpYmVyLmluZGV4O1xuXG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIC8vIFJvb3RzIGRvbid0IGhhdmUgYSByZWFsIGRpc3BsYXlOYW1lLCBpbmRleCwgb3Iga2V5LlxuICAgICAgICAvLyBJbnN0ZWFkLCB3ZSdsbCB1c2UgdGhlIHBzZXVkbyBrZXkgKGNoaWxkRGlzcGxheU5hbWU6aW5kZXhXaXRoVGhhdE5hbWUpLlxuICAgICAgICB2YXIgaWQgPSBnZXRGaWJlcklEVGhyb3dzKGZpYmVyKTtcbiAgICAgICAgdmFyIHBzZXVkb0tleSA9IHJvb3RQc2V1ZG9LZXlzLmdldChpZCk7XG5cbiAgICAgICAgaWYgKHBzZXVkb0tleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBtb3VudGVkIHJvb3QgdG8gaGF2ZSBrbm93biBwc2V1ZG8ga2V5LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlzcGxheU5hbWUgPSBwc2V1ZG9LZXk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIGRpc3BsYXlOYW1lID0gZmliZXIudHlwZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIGluZGV4OiBpbmRleFxuICAgIH07XG4gIH0gLy8gUHJvZHVjZXMgYSBzZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gdGhhdCBkb2VzIGEgYmVzdCBlZmZvcnRcbiAgLy8gb2YgaWRlbnRpZnlpbmcgYSBwYXJ0aWN1bGFyIEZpYmVyIGJldHdlZW4gcGFnZSByZWxvYWRzLlxuICAvLyBUaGUgcmV0dXJuIHBhdGggd2lsbCBjb250YWluIEZpYmVycyB0aGF0IGFyZSBcImludmlzaWJsZVwiIHRvIHRoZSBzdG9yZVxuICAvLyBiZWNhdXNlIHRoZWlyIGtleXMgYW5kIGluZGV4ZXMgYXJlIGltcG9ydGFudCB0byByZXN0b3JpbmcgdGhlIHNlbGVjdGlvbi5cblxuXG4gIGZ1bmN0aW9uIGdldFBhdGhGb3JFbGVtZW50KGlkKSB7XG4gICAgdmFyIGZpYmVyID0gaWRUb0FyYml0cmFyeUZpYmVyTWFwLmdldChpZCk7XG5cbiAgICBpZiAoZmliZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGtleVBhdGggPSBbXTtcblxuICAgIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAga2V5UGF0aC5wdXNoKGdldFBhdGhGcmFtZShmaWJlcikpOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuICAgICAgZmliZXIgPSBmaWJlci5yZXR1cm47XG4gICAgfVxuXG4gICAga2V5UGF0aC5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIGtleVBhdGg7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRCZXN0TWF0Y2hGb3JUcmFja2VkUGF0aCgpIHtcbiAgICBpZiAodHJhY2tlZFBhdGggPT09IG51bGwpIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gbWF0Y2guXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodHJhY2tlZFBhdGhNYXRjaEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBXZSBkaWRuJ3QgZmluZCBhbnl0aGluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gRmluZCB0aGUgY2xvc2VzdCBGaWJlciBzdG9yZSBpcyBhd2FyZSBvZi5cblxuXG4gICAgdmFyIGZpYmVyID0gdHJhY2tlZFBhdGhNYXRjaEZpYmVyO1xuXG4gICAgd2hpbGUgKGZpYmVyICE9PSBudWxsICYmIHNob3VsZEZpbHRlckZpYmVyKGZpYmVyKSkge1xuICAgICAgZmliZXIgPSBmaWJlci5yZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGdldEZpYmVySURUaHJvd3MoZmliZXIpLFxuICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICBpc0Z1bGxNYXRjaDogdHJhY2tlZFBhdGhNYXRjaERlcHRoID09PSB0cmFja2VkUGF0aC5sZW5ndGggLSAxXG4gICAgfTtcbiAgfVxuXG4gIHZhciBmb3JtYXRQcmlvcml0eUxldmVsID0gZnVuY3Rpb24gZm9ybWF0UHJpb3JpdHlMZXZlbChwcmlvcml0eUxldmVsKSB7XG4gICAgaWYgKHByaW9yaXR5TGV2ZWwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgICAgIHJldHVybiAnSW1tZWRpYXRlJztcblxuICAgICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICAgICAgcmV0dXJuICdVc2VyLUJsb2NraW5nJztcblxuICAgICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICAgICAgcmV0dXJuICdOb3JtYWwnO1xuXG4gICAgICBjYXNlIExvd1ByaW9yaXR5OlxuICAgICAgICByZXR1cm4gJ0xvdyc7XG5cbiAgICAgIGNhc2UgSWRsZVByaW9yaXR5OlxuICAgICAgICByZXR1cm4gJ0lkbGUnO1xuXG4gICAgICBjYXNlIE5vUHJpb3JpdHk6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gJ1Vua25vd24nO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBzZXRUcmFjZVVwZGF0ZXNFbmFibGVkKGlzRW5hYmxlZCkge1xuICAgIHRyYWNlVXBkYXRlc0VuYWJsZWQgPSBpc0VuYWJsZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNsZWFudXA6IGNsZWFudXAsXG4gICAgY2xlYXJFcnJvcnNBbmRXYXJuaW5nczogY2xlYXJFcnJvcnNBbmRXYXJuaW5ncyxcbiAgICBjbGVhckVycm9yc0ZvckZpYmVySUQ6IGNsZWFyRXJyb3JzRm9yRmliZXJJRCxcbiAgICBjbGVhcldhcm5pbmdzRm9yRmliZXJJRDogY2xlYXJXYXJuaW5nc0ZvckZpYmVySUQsXG4gICAgZ2V0U2VyaWFsaXplZEVsZW1lbnRWYWx1ZUJ5UGF0aDogZ2V0U2VyaWFsaXplZEVsZW1lbnRWYWx1ZUJ5UGF0aCxcbiAgICBkZWxldGVQYXRoOiBkZWxldGVQYXRoLFxuICAgIGZpbmROYXRpdmVOb2Rlc0ZvckZpYmVySUQ6IGZpbmROYXRpdmVOb2Rlc0ZvckZpYmVySUQsXG4gICAgZmx1c2hJbml0aWFsT3BlcmF0aW9uczogZmx1c2hJbml0aWFsT3BlcmF0aW9ucyxcbiAgICBnZXRCZXN0TWF0Y2hGb3JUcmFja2VkUGF0aDogZ2V0QmVzdE1hdGNoRm9yVHJhY2tlZFBhdGgsXG4gICAgZ2V0RGlzcGxheU5hbWVGb3JGaWJlcklEOiBnZXREaXNwbGF5TmFtZUZvckZpYmVySUQsXG4gICAgZ2V0RmliZXJGb3JOYXRpdmU6IGdldEZpYmVyRm9yTmF0aXZlLFxuICAgIGdldEZpYmVySURGb3JOYXRpdmU6IGdldEZpYmVySURGb3JOYXRpdmUsXG4gICAgZ2V0SW5zdGFuY2VBbmRTdHlsZTogZ2V0SW5zdGFuY2VBbmRTdHlsZSxcbiAgICBnZXRPd25lcnNMaXN0OiBnZXRPd25lcnNMaXN0LFxuICAgIGdldFBhdGhGb3JFbGVtZW50OiBnZXRQYXRoRm9yRWxlbWVudCxcbiAgICBnZXRQcm9maWxpbmdEYXRhOiBnZXRQcm9maWxpbmdEYXRhLFxuICAgIGhhbmRsZUNvbW1pdEZpYmVyUm9vdDogaGFuZGxlQ29tbWl0RmliZXJSb290LFxuICAgIGhhbmRsZUNvbW1pdEZpYmVyVW5tb3VudDogaGFuZGxlQ29tbWl0RmliZXJVbm1vdW50LFxuICAgIGhhbmRsZVBvc3RDb21taXRGaWJlclJvb3Q6IGhhbmRsZVBvc3RDb21taXRGaWJlclJvb3QsXG4gICAgaW5zcGVjdEVsZW1lbnQ6IGluc3BlY3RFbGVtZW50LFxuICAgIGxvZ0VsZW1lbnRUb0NvbnNvbGU6IGxvZ0VsZW1lbnRUb0NvbnNvbGUsXG4gICAgcGF0Y2hDb25zb2xlRm9yU3RyaWN0TW9kZTogYmFja2VuZF9jb25zb2xlW1wiZFwiIC8qIHBhdGNoRm9yU3RyaWN0TW9kZSAqL10sXG4gICAgcHJlcGFyZVZpZXdBdHRyaWJ1dGVTb3VyY2U6IHByZXBhcmVWaWV3QXR0cmlidXRlU291cmNlLFxuICAgIHByZXBhcmVWaWV3RWxlbWVudFNvdXJjZTogcHJlcGFyZVZpZXdFbGVtZW50U291cmNlLFxuICAgIG92ZXJyaWRlRXJyb3I6IG92ZXJyaWRlRXJyb3IsXG4gICAgb3ZlcnJpZGVTdXNwZW5zZTogb3ZlcnJpZGVTdXNwZW5zZSxcbiAgICBvdmVycmlkZVZhbHVlQXRQYXRoOiBvdmVycmlkZVZhbHVlQXRQYXRoLFxuICAgIHJlbmFtZVBhdGg6IHJlbmFtZVBhdGgsXG4gICAgcmVuZGVyZXI6IHJlbmRlcmVyLFxuICAgIHNldFRyYWNlVXBkYXRlc0VuYWJsZWQ6IHNldFRyYWNlVXBkYXRlc0VuYWJsZWQsXG4gICAgc2V0VHJhY2tlZFBhdGg6IHNldFRyYWNrZWRQYXRoLFxuICAgIHN0YXJ0UHJvZmlsaW5nOiBzdGFydFByb2ZpbGluZyxcbiAgICBzdG9wUHJvZmlsaW5nOiBzdG9wUHJvZmlsaW5nLFxuICAgIHN0b3JlQXNHbG9iYWw6IHN0b3JlQXNHbG9iYWwsXG4gICAgdW5wYXRjaENvbnNvbGVGb3JTdHJpY3RNb2RlOiBiYWNrZW5kX2NvbnNvbGVbXCJmXCIgLyogdW5wYXRjaEZvclN0cmljdE1vZGUgKi9dLFxuICAgIHVwZGF0ZUNvbXBvbmVudEZpbHRlcnM6IHVwZGF0ZUNvbXBvbmVudEZpbHRlcnNcbiAgfTtcbn1cblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gZGVzY3JpYmVGaWJlcjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJiXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Q7IH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMuanNcbnZhciBSZWFjdFN5bWJvbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvRGV2VG9vbHNDb25zb2xlUGF0Y2hpbmcuanNcbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cbi8vIFRoaXMgaXMgYSBEZXZUb29scyBmb3JrIG9mIHNoYXJlZC9Db25zb2xlUGF0Y2hpbmdEZXYuXG4vLyBUaGUgc2hhcmVkIGNvbnNvbGUgcGF0Y2hpbmcgY29kZSBpcyBERVYtb25seS5cbi8vIFdlIGNhbid0IHVzZSBpdCBzaW5jZSBEZXZUb29scyBvbmx5IHNoaXBzIHByb2R1Y3Rpb24gYnVpbGRzLlxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgdmFyIHByb3BzID0ge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgaW5mbzogcHJvcHMsXG4gICAgICBsb2c6IHByb3BzLFxuICAgICAgd2FybjogcHJvcHMsXG4gICAgICBlcnJvcjogcHJvcHMsXG4gICAgICBncm91cDogcHJvcHMsXG4gICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICBncm91cEVuZDogcHJvcHNcbiAgICB9KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICB9XG5cbiAgZGlzYWJsZWREZXB0aCsrO1xufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICBkaXNhYmxlZERlcHRoLS07XG5cbiAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB2YXIgcHJvcHMgPSB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICBsb2c6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xuICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgfSksXG4gICAgICBpbmZvOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwge30sIHtcbiAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICB9KSxcbiAgICAgIHdhcm46IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xuICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgIH0pLFxuICAgICAgZXJyb3I6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xuICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICB9KSxcbiAgICAgIGdyb3VwOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwge30sIHtcbiAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgfSksXG4gICAgICBncm91cENvbGxhcHNlZDogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgIH0pLFxuICAgICAgZ3JvdXBFbmQ6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xuICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICB9KVxuICAgIH0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gIH1cblxuICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICBjb25zb2xlLmVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL0RldlRvb2xzQ29tcG9uZW50U3RhY2tGcmFtZS5qc1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cbi8vIFRoaXMgaXMgYSBEZXZUb29scyBmb3JrIG9mIFJlYWN0Q29tcG9uZW50U3RhY2tGcmFtZS5cbi8vIFRoaXMgZm9yayBlbmFibGVzIERldlRvb2xzIHRvIHVzZSB0aGUgc2FtZSBcIm5hdGl2ZVwiIGNvbXBvbmVudCBzdGFjayBmb3JtYXQsXG4vLyB3aGlsZSBzdGlsbCBtYWludGFpbmluZyBzdXBwb3J0IGZvciBtdWx0aXBsZSByZW5kZXJlciB2ZXJzaW9uc1xuLy8gKHdoaWNoIHVzZSBkaWZmZXJlbnQgdmFsdWVzIGZvciBSZWFjdFR5cGVPZldvcmspLlxuIC8vIFRoZSBzaGFyZWQgY29uc29sZSBwYXRjaGluZyBjb2RlIGlzIERFVi1vbmx5LlxuLy8gV2UgY2FuJ3QgdXNlIGl0IHNpbmNlIERldlRvb2xzIG9ubHkgc2hpcHMgcHJvZHVjdGlvbiBidWlsZHMuXG5cblxudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIG93bmVyRm4pIHtcbiAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgIHRyeSB7XG4gICAgICB0aHJvdyBFcnJvcigpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICB9XG4gIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG5pZiAoZmFsc2UpIHsgdmFyIFBvc3NpYmx5V2Vha01hcDsgfVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QsIGN1cnJlbnREaXNwYXRjaGVyUmVmKSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoZmFsc2UpIHsgdmFyIGZyYW1lOyB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgcmVlbnRyeSA9IHRydWU7IC8vIE92ZXJyaWRlIHRoZSBkaXNwYXRjaGVyIHNvIGVmZmVjdHMgc2NoZWR1bGVkIGJ5IHRoaXMgc2hhbGxvdyByZW5kZXIgYXJlIHRocm93biBhd2F5LlxuICAvL1xuICAvLyBOb3RlIHRoYXQgdW5saWtlIHRoZSBjb2RlIHRoaXMgd2FzIGZvcmtlZCBmcm9tIChpbiBSZWFjdENvbXBvbmVudFN0YWNrRnJhbWUpXG4gIC8vIERldlRvb2xzIHNob3VsZCBvdmVycmlkZSB0aGUgZGlzcGF0Y2hlciBldmVuIHdoZW4gRGV2VG9vbHMgaXMgY29tcGlsZWQgaW4gcHJvZHVjdGlvbiBtb2RlLFxuICAvLyBiZWNhdXNlIHRoZSBhcHAgaXRzZWxmIG1heSBiZSBpbiBkZXZlbG9wbWVudCBtb2RlIGFuZCBsb2cgZXJyb3JzL3dhcm5pbmdzLlxuXG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXIgPSBjdXJyZW50RGlzcGF0Y2hlclJlZi5jdXJyZW50O1xuICBjdXJyZW50RGlzcGF0Y2hlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgZGlzYWJsZUxvZ3MoKTtcblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiBGYWtlKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICgodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihSZWZsZWN0KSkgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTtcblxuICAgICAgICAgICAgICAgIGlmIChmYWxzZSkge30gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICAgIGN1cnJlbnREaXNwYXRjaGVyUmVmLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgcmVlbmFibGVMb2dzKCk7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAgaWYgKGZhbHNlKSB7fVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlQ2xhc3NDb21wb25lbnRGcmFtZShjdG9yLCBvd25lckZuLCBjdXJyZW50RGlzcGF0Y2hlclJlZikge1xuICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShjdG9yLCB0cnVlLCBjdXJyZW50RGlzcGF0Y2hlclJlZik7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIG93bmVyRm4sIGN1cnJlbnREaXNwYXRjaGVyUmVmKSB7XG4gIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSwgY3VycmVudERpc3BhdGNoZXJSZWYpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4sIGN1cnJlbnREaXNwYXRjaGVyUmVmKSB7XG4gIGlmICh0cnVlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSwgY3VycmVudERpc3BhdGNoZXJSZWYpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlLCBvd25lckZuKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUmVhY3RTeW1ib2xzW1wid1wiIC8qIFNVU1BFTlNFX05VTUJFUiAqL106XG4gICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJ4XCIgLyogU1VTUEVOU0VfU1lNQk9MX1NUUklORyAqL106XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJywgb3duZXJGbik7XG5cbiAgICBjYXNlIFJlYWN0U3ltYm9sc1tcInVcIiAvKiBTVVNQRU5TRV9MSVNUX05VTUJFUiAqL106XG4gICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJ2XCIgLyogU1VTUEVOU0VfTElTVF9TWU1CT0xfU1RSSU5HICovXTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jywgb3duZXJGbik7XG4gIH1cblxuICBpZiAoX3R5cGVvZih0eXBlKSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUmVhY3RTeW1ib2xzW1wiZlwiIC8qIEZPUldBUkRfUkVGX05VTUJFUiAqL106XG4gICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcImdcIiAvKiBGT1JXQVJEX1JFRl9TWU1CT0xfU1RSSU5HICovXTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlciwgb3duZXJGbiwgY3VycmVudERpc3BhdGNoZXJSZWYpO1xuXG4gICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcImpcIiAvKiBNRU1PX05VTUJFUiAqL106XG4gICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcImtcIiAvKiBNRU1PX1NZTUJPTF9TVFJJTkcgKi9dOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgb3duZXJGbiwgY3VycmVudERpc3BhdGNoZXJSZWYpO1xuXG4gICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcImhcIiAvKiBMQVpZX05VTUJFUiAqL106XG4gICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcImlcIiAvKiBMQVpZX1NZTUJPTF9TVFJJTkcgKi9dOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgb3duZXJGbiwgY3VycmVudERpc3BhdGNoZXJSZWYpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvRGV2VG9vbHNGaWJlckNvbXBvbmVudFN0YWNrLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cbi8vIFRoaXMgaXMgYSBEZXZUb29scyBmb3JrIG9mIFJlYWN0RmliZXJDb21wb25lbnRTdGFjay5cbi8vIFRoaXMgZm9yayBlbmFibGVzIERldlRvb2xzIHRvIHVzZSB0aGUgc2FtZSBcIm5hdGl2ZVwiIGNvbXBvbmVudCBzdGFjayBmb3JtYXQsXG4vLyB3aGlsZSBzdGlsbCBtYWludGFpbmluZyBzdXBwb3J0IGZvciBtdWx0aXBsZSByZW5kZXJlciB2ZXJzaW9uc1xuLy8gKHdoaWNoIHVzZSBkaWZmZXJlbnQgdmFsdWVzIGZvciBSZWFjdFR5cGVPZldvcmspLlxuXG5mdW5jdGlvbiBkZXNjcmliZUZpYmVyKHdvcmtUYWdNYXAsIHdvcmtJblByb2dyZXNzLCBjdXJyZW50RGlzcGF0Y2hlclJlZikge1xuICB2YXIgSG9zdENvbXBvbmVudCA9IHdvcmtUYWdNYXAuSG9zdENvbXBvbmVudCxcbiAgICAgIExhenlDb21wb25lbnQgPSB3b3JrVGFnTWFwLkxhenlDb21wb25lbnQsXG4gICAgICBTdXNwZW5zZUNvbXBvbmVudCA9IHdvcmtUYWdNYXAuU3VzcGVuc2VDb21wb25lbnQsXG4gICAgICBTdXNwZW5zZUxpc3RDb21wb25lbnQgPSB3b3JrVGFnTWFwLlN1c3BlbnNlTGlzdENvbXBvbmVudCxcbiAgICAgIEZ1bmN0aW9uQ29tcG9uZW50ID0gd29ya1RhZ01hcC5GdW5jdGlvbkNvbXBvbmVudCxcbiAgICAgIEluZGV0ZXJtaW5hdGVDb21wb25lbnQgPSB3b3JrVGFnTWFwLkluZGV0ZXJtaW5hdGVDb21wb25lbnQsXG4gICAgICBTaW1wbGVNZW1vQ29tcG9uZW50ID0gd29ya1RhZ01hcC5TaW1wbGVNZW1vQ29tcG9uZW50LFxuICAgICAgRm9yd2FyZFJlZiA9IHdvcmtUYWdNYXAuRm9yd2FyZFJlZixcbiAgICAgIENsYXNzQ29tcG9uZW50ID0gd29ya1RhZ01hcC5DbGFzc0NvbXBvbmVudDtcbiAgdmFyIG93bmVyID0gIGZhbHNlID8gdW5kZWZpbmVkIDogbnVsbDtcblxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlLCBvd25lcik7XG5cbiAgICBjYXNlIExhenlDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ0xhenknLCBvd25lcik7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScsIG93bmVyKTtcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnLCBvd25lcik7XG5cbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHdvcmtJblByb2dyZXNzLnR5cGUsIG93bmVyLCBjdXJyZW50RGlzcGF0Y2hlclJlZik7XG5cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHdvcmtJblByb2dyZXNzLnR5cGUucmVuZGVyLCBvd25lciwgY3VycmVudERpc3BhdGNoZXJSZWYpO1xuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUod29ya0luUHJvZ3Jlc3MudHlwZSwgb3duZXIsIGN1cnJlbnREaXNwYXRjaGVyUmVmKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCh3b3JrVGFnTWFwLCB3b3JrSW5Qcm9ncmVzcywgY3VycmVudERpc3BhdGNoZXJSZWYpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgICBkbyB7XG4gICAgICBpbmZvICs9IGRlc2NyaWJlRmliZXIod29ya1RhZ01hcCwgbm9kZSwgY3VycmVudERpc3BhdGNoZXJSZWYpOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSB3ZSBiYWlsIG91dCB3aGVuIHdlIGdldCBhIG51bGxcblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH0gd2hpbGUgKG5vZGUpO1xuXG4gICAgcmV0dXJuIGluZm87XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICByZXR1cm4gJ1xcbkVycm9yIGdlbmVyYXRpbmcgc3RhY2s6ICcgKyB4Lm1lc3NhZ2UgKyAnXFxuJyArIHguc3RhY2s7XG4gIH1cbn1cblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBSRUFDVF9FTEVNRU5UX1RZUEUgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBSRUFDVF9QT1JUQUxfVFlQRSAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IFJFQUNUX0ZSQUdNRU5UX1RZUEUgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgUkVBQ1RfUFJPRklMRVJfVFlQRSAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IFJFQUNUX1BST1ZJREVSX1RZUEUgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBSRUFDVF9DT05URVhUX1RZUEUgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IFJFQUNUX1NVU1BFTlNFX1RZUEUgKi9cbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBSRUFDVF9NRU1PX1RZUEUgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBSRUFDVF9MQVpZX1RZUEUgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBSRUFDVF9TQ09QRV9UWVBFICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBSRUFDVF9PRkZTQ1JFRU5fVFlQRSAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IFJFQUNUX0NBQ0hFX1RZUEUgKi9cbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJiXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUkVBQ1RfVFJBQ0lOR19NQVJLRVJfVFlQRTsgfSk7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfREVGQVVMVF9WQUxVRV9OT1RfTE9BREVEICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTCAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IGdldEl0ZXJhdG9yRm4gKi9cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc2VydmVyX2NvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKTtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbnZhciBSRUFDVF9DQUNIRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY2FjaGUnKTtcbnZhciBSRUFDVF9UUkFDSU5HX01BUktFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QudHJhY2luZ19tYXJrZXInKTtcbnZhciBSRUFDVF9TRVJWRVJfQ09OVEVYVF9ERUZBVUxUX1ZBTFVFX05PVF9MT0FERUQgPSBTeW1ib2wuZm9yKCdyZWFjdC5kZWZhdWx0X3ZhbHVlJyk7XG52YXIgUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTCA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWwnKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgX3R5cGVvZihtYXliZUl0ZXJhYmxlKSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxudmFyIGc7IC8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5cbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufSgpO1xuXG50cnkge1xuICAvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcbiAgZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcbiAgLy8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcbiAgaWYgKCh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yod2luZG93KSkgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59IC8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuIC8vIEEgbGlua2VkIGxpc3QgdG8ga2VlcCB0cmFjayBvZiByZWNlbnRseS11c2VkLW5lc3NcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgWWFsbGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG52YXIgTUFYID0gU3ltYm9sKCdtYXgnKTtcbnZhciBMRU5HVEggPSBTeW1ib2woJ2xlbmd0aCcpO1xudmFyIExFTkdUSF9DQUxDVUxBVE9SID0gU3ltYm9sKCdsZW5ndGhDYWxjdWxhdG9yJyk7XG52YXIgQUxMT1dfU1RBTEUgPSBTeW1ib2woJ2FsbG93U3RhbGUnKTtcbnZhciBNQVhfQUdFID0gU3ltYm9sKCdtYXhBZ2UnKTtcbnZhciBESVNQT1NFID0gU3ltYm9sKCdkaXNwb3NlJyk7XG52YXIgTk9fRElTUE9TRV9PTl9TRVQgPSBTeW1ib2woJ25vRGlzcG9zZU9uU2V0Jyk7XG52YXIgTFJVX0xJU1QgPSBTeW1ib2woJ2xydUxpc3QnKTtcbnZhciBDQUNIRSA9IFN5bWJvbCgnY2FjaGUnKTtcbnZhciBVUERBVEVfQUdFX09OX0dFVCA9IFN5bWJvbCgndXBkYXRlQWdlT25HZXQnKTtcblxudmFyIG5haXZlTGVuZ3RoID0gZnVuY3Rpb24gbmFpdmVMZW5ndGgoKSB7XG4gIHJldHVybiAxO1xufTsgLy8gbHJ1TGlzdCBpcyBhIHlhbGxpc3Qgd2hlcmUgdGhlIGhlYWQgaXMgdGhlIHlvdW5nZXN0XG4vLyBpdGVtLCBhbmQgdGhlIHRhaWwgaXMgdGhlIG9sZGVzdC4gIHRoZSBsaXN0IGNvbnRhaW5zIHRoZSBIaXRcbi8vIG9iamVjdHMgYXMgdGhlIGVudHJpZXMuXG4vLyBFYWNoIEhpdCBvYmplY3QgaGFzIGEgcmVmZXJlbmNlIHRvIGl0cyBZYWxsaXN0Lk5vZGUuICBUaGlzXG4vLyBuZXZlciBjaGFuZ2VzLlxuLy9cbi8vIGNhY2hlIGlzIGEgTWFwIChvciBQc2V1ZG9NYXApIHRoYXQgbWF0Y2hlcyB0aGUga2V5cyB0b1xuLy8gdGhlIFlhbGxpc3QuTm9kZSBvYmplY3QuXG5cblxudmFyIExSVUNhY2hlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTFJVQ2FjaGUob3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMUlVDYWNoZSk7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSBvcHRpb25zID0ge1xuICAgICAgbWF4OiBvcHRpb25zXG4gICAgfTtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5tYXggJiYgKHR5cGVvZiBvcHRpb25zLm1heCAhPT0gJ251bWJlcicgfHwgb3B0aW9ucy5tYXggPCAwKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJyk7IC8vIEtpbmQgb2Ygd2VpcmQgdG8gaGF2ZSBhIGRlZmF1bHQgbWF4IG9mIEluZmluaXR5LCBidXQgb2ggd2VsbC5cblxuICAgIHZhciBtYXggPSB0aGlzW01BWF0gPSBvcHRpb25zLm1heCB8fCBJbmZpbml0eTtcbiAgICB2YXIgbGMgPSBvcHRpb25zLmxlbmd0aCB8fCBuYWl2ZUxlbmd0aDtcbiAgICB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSA9IHR5cGVvZiBsYyAhPT0gJ2Z1bmN0aW9uJyA/IG5haXZlTGVuZ3RoIDogbGM7XG4gICAgdGhpc1tBTExPV19TVEFMRV0gPSBvcHRpb25zLnN0YWxlIHx8IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLm1heEFnZSAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhBZ2UgIT09ICdudW1iZXInKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhBZ2UgbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIHRoaXNbTUFYX0FHRV0gPSBvcHRpb25zLm1heEFnZSB8fCAwO1xuICAgIHRoaXNbRElTUE9TRV0gPSBvcHRpb25zLmRpc3Bvc2U7XG4gICAgdGhpc1tOT19ESVNQT1NFX09OX1NFVF0gPSBvcHRpb25zLm5vRGlzcG9zZU9uU2V0IHx8IGZhbHNlO1xuICAgIHRoaXNbVVBEQVRFX0FHRV9PTl9HRVRdID0gb3B0aW9ucy51cGRhdGVBZ2VPbkdldCB8fCBmYWxzZTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH0gLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBtYXggY2hhbmdlcy5cblxuXG4gIF9jcmVhdGVDbGFzcyhMUlVDYWNoZSwgW3tcbiAgICBrZXk6IFwicmZvckVhY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmZvckVhY2goZm4sIHRoaXNwKSB7XG4gICAgICB0aGlzcCA9IHRoaXNwIHx8IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIHdhbGtlciA9IHRoaXNbTFJVX0xJU1RdLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICAgICAgdmFyIHByZXYgPSB3YWxrZXIucHJldjtcbiAgICAgICAgZm9yRWFjaFN0ZXAodGhpcywgZm4sIHdhbGtlciwgdGhpc3ApO1xuICAgICAgICB3YWxrZXIgPSBwcmV2O1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JFYWNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2goZm4sIHRoaXNwKSB7XG4gICAgICB0aGlzcCA9IHRoaXNwIHx8IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIHdhbGtlciA9IHRoaXNbTFJVX0xJU1RdLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICAgICAgdmFyIG5leHQgPSB3YWxrZXIubmV4dDtcbiAgICAgICAgZm9yRWFjaFN0ZXAodGhpcywgZm4sIHdhbGtlciwgdGhpc3ApO1xuICAgICAgICB3YWxrZXIgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJrZXlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0udG9BcnJheSgpLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gay5rZXk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXS50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrLnZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXNbRElTUE9TRV0gJiYgdGhpc1tMUlVfTElTVF0gJiYgdGhpc1tMUlVfTElTVF0ubGVuZ3RoKSB7XG4gICAgICAgIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goZnVuY3Rpb24gKGhpdCkge1xuICAgICAgICAgIHJldHVybiBfdGhpc1tESVNQT1NFXShoaXQua2V5LCBoaXQudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpc1tDQUNIRV0gPSBuZXcgTWFwKCk7IC8vIGhhc2ggb2YgaXRlbXMgYnkga2V5XG5cbiAgICAgIHRoaXNbTFJVX0xJU1RdID0gbmV3IFlhbGxpc3QoKTsgLy8gbGlzdCBvZiBpdGVtcyBpbiBvcmRlciBvZiB1c2UgcmVjZW5jeVxuXG4gICAgICB0aGlzW0xFTkdUSF0gPSAwOyAvLyBsZW5ndGggb2YgaXRlbXMgaW4gdGhlIGxpc3RcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHVtcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkdW1wKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXS5tYXAoZnVuY3Rpb24gKGhpdCkge1xuICAgICAgICByZXR1cm4gaXNTdGFsZShfdGhpczIsIGhpdCkgPyBmYWxzZSA6IHtcbiAgICAgICAgICBrOiBoaXQua2V5LFxuICAgICAgICAgIHY6IGhpdC52YWx1ZSxcbiAgICAgICAgICBlOiBoaXQubm93ICsgKGhpdC5tYXhBZ2UgfHwgMClcbiAgICAgICAgfTtcbiAgICAgIH0pLnRvQXJyYXkoKS5maWx0ZXIoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgcmV0dXJuIGg7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHVtcExydVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkdW1wTHJ1KCkge1xuICAgICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUsIG1heEFnZSkge1xuICAgICAgbWF4QWdlID0gbWF4QWdlIHx8IHRoaXNbTUFYX0FHRV07XG4gICAgICBpZiAobWF4QWdlICYmIHR5cGVvZiBtYXhBZ2UgIT09ICdudW1iZXInKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhBZ2UgbXVzdCBiZSBhIG51bWJlcicpO1xuICAgICAgdmFyIG5vdyA9IG1heEFnZSA/IERhdGUubm93KCkgOiAwO1xuICAgICAgdmFyIGxlbiA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKHZhbHVlLCBrZXkpO1xuXG4gICAgICBpZiAodGhpc1tDQUNIRV0uaGFzKGtleSkpIHtcbiAgICAgICAgaWYgKGxlbiA+IHRoaXNbTUFYXSkge1xuICAgICAgICAgIF9kZWwodGhpcywgdGhpc1tDQUNIRV0uZ2V0KGtleSkpO1xuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzW0NBQ0hFXS5nZXQoa2V5KTtcbiAgICAgICAgdmFyIGl0ZW0gPSBub2RlLnZhbHVlOyAvLyBkaXNwb3NlIG9mIHRoZSBvbGQgb25lIGJlZm9yZSBvdmVyd3JpdGluZ1xuICAgICAgICAvLyBzcGxpdCBvdXQgaW50byAyIGlmcyBmb3IgYmV0dGVyIGNvdmVyYWdlIHRyYWNraW5nXG5cbiAgICAgICAgaWYgKHRoaXNbRElTUE9TRV0pIHtcbiAgICAgICAgICBpZiAoIXRoaXNbTk9fRElTUE9TRV9PTl9TRVRdKSB0aGlzW0RJU1BPU0VdKGtleSwgaXRlbS52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpdGVtLm5vdyA9IG5vdztcbiAgICAgICAgaXRlbS5tYXhBZ2UgPSBtYXhBZ2U7XG4gICAgICAgIGl0ZW0udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpc1tMRU5HVEhdICs9IGxlbiAtIGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpdGVtLmxlbmd0aCA9IGxlbjtcbiAgICAgICAgdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgdHJpbSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBoaXQgPSBuZXcgRW50cnkoa2V5LCB2YWx1ZSwgbGVuLCBub3csIG1heEFnZSk7IC8vIG92ZXJzaXplZCBvYmplY3RzIGZhbGwgb3V0IG9mIGNhY2hlIGF1dG9tYXRpY2FsbHkuXG5cbiAgICAgIGlmIChoaXQubGVuZ3RoID4gdGhpc1tNQVhdKSB7XG4gICAgICAgIGlmICh0aGlzW0RJU1BPU0VdKSB0aGlzW0RJU1BPU0VdKGtleSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXNbTEVOR1RIXSArPSBoaXQubGVuZ3RoO1xuICAgICAgdGhpc1tMUlVfTElTVF0udW5zaGlmdChoaXQpO1xuICAgICAgdGhpc1tDQUNIRV0uc2V0KGtleSwgdGhpc1tMUlVfTElTVF0uaGVhZCk7XG4gICAgICB0cmltKHRoaXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICBpZiAoIXRoaXNbQ0FDSEVdLmhhcyhrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgaGl0ID0gdGhpc1tDQUNIRV0uZ2V0KGtleSkudmFsdWU7XG4gICAgICByZXR1cm4gIWlzU3RhbGUodGhpcywgaGl0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgIHJldHVybiBfZ2V0KHRoaXMsIGtleSwgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBlZWtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGVlayhrZXkpIHtcbiAgICAgIHJldHVybiBfZ2V0KHRoaXMsIGtleSwgZmFsc2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9wKCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzW0xSVV9MSVNUXS50YWlsO1xuICAgICAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDtcblxuICAgICAgX2RlbCh0aGlzLCBub2RlKTtcblxuICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWwoa2V5KSB7XG4gICAgICBfZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKGFycikge1xuICAgICAgLy8gcmVzZXQgdGhlIGNhY2hlXG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTsgLy8gQSBwcmV2aW91cyBzZXJpYWxpemVkIGNhY2hlIGhhcyB0aGUgbW9zdCByZWNlbnQgaXRlbXMgZmlyc3RcblxuICAgICAgZm9yICh2YXIgbCA9IGFyci5sZW5ndGggLSAxOyBsID49IDA7IGwtLSkge1xuICAgICAgICB2YXIgaGl0ID0gYXJyW2xdO1xuICAgICAgICB2YXIgZXhwaXJlc0F0ID0gaGl0LmUgfHwgMDtcbiAgICAgICAgaWYgKGV4cGlyZXNBdCA9PT0gMCkgLy8gdGhlIGl0ZW0gd2FzIGNyZWF0ZWQgd2l0aG91dCBleHBpcmF0aW9uIGluIGEgbm9uIGFnZWQgY2FjaGVcbiAgICAgICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYpO2Vsc2Uge1xuICAgICAgICAgIHZhciBtYXhBZ2UgPSBleHBpcmVzQXQgLSBub3c7IC8vIGRvbnQgYWRkIGFscmVhZHkgZXhwaXJlZCBpdGVtc1xuXG4gICAgICAgICAgaWYgKG1heEFnZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudiwgbWF4QWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJ1bmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJ1bmUoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpc1tDQUNIRV0uZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4gX2dldChfdGhpczMsIGtleSwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1heFwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG1MKSB7XG4gICAgICBpZiAodHlwZW9mIG1MICE9PSAnbnVtYmVyJyB8fCBtTCA8IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpO1xuICAgICAgdGhpc1tNQVhdID0gbUwgfHwgSW5maW5pdHk7XG4gICAgICB0cmltKHRoaXMpO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1tNQVhdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbGxvd1N0YWxlXCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoYWxsb3dTdGFsZSkge1xuICAgICAgdGhpc1tBTExPV19TVEFMRV0gPSAhIWFsbG93U3RhbGU7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzW0FMTE9XX1NUQUxFXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF4QWdlXCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobUEpIHtcbiAgICAgIGlmICh0eXBlb2YgbUEgIT09ICdudW1iZXInKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhBZ2UgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKTtcbiAgICAgIHRoaXNbTUFYX0FHRV0gPSBtQTtcbiAgICAgIHRyaW0odGhpcyk7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzW01BWF9BR0VdO1xuICAgIH0gLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBsZW5ndGhDYWxjdWxhdG9yIGNoYW5nZXMuXG5cbiAgfSwge1xuICAgIGtleTogXCJsZW5ndGhDYWxjdWxhdG9yXCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobEMpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBpZiAodHlwZW9mIGxDICE9PSAnZnVuY3Rpb24nKSBsQyA9IG5haXZlTGVuZ3RoO1xuXG4gICAgICBpZiAobEMgIT09IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKSB7XG4gICAgICAgIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdID0gbEM7XG4gICAgICAgIHRoaXNbTEVOR1RIXSA9IDA7XG4gICAgICAgIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goZnVuY3Rpb24gKGhpdCkge1xuICAgICAgICAgIGhpdC5sZW5ndGggPSBfdGhpczRbTEVOR1RIX0NBTENVTEFUT1JdKGhpdC52YWx1ZSwgaGl0LmtleSk7XG4gICAgICAgICAgX3RoaXM0W0xFTkdUSF0gKz0gaGl0Lmxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRyaW0odGhpcyk7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGVuZ3RoXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1tMRU5HVEhdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpdGVtQ291bnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXS5sZW5ndGg7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExSVUNhY2hlO1xufSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIF9nZXQoc2VsZiwga2V5LCBkb1VzZSkge1xuICB2YXIgbm9kZSA9IHNlbGZbQ0FDSEVdLmdldChrZXkpO1xuXG4gIGlmIChub2RlKSB7XG4gICAgdmFyIGhpdCA9IG5vZGUudmFsdWU7XG5cbiAgICBpZiAoaXNTdGFsZShzZWxmLCBoaXQpKSB7XG4gICAgICBfZGVsKHNlbGYsIG5vZGUpO1xuXG4gICAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZG9Vc2UpIHtcbiAgICAgICAgaWYgKHNlbGZbVVBEQVRFX0FHRV9PTl9HRVRdKSBub2RlLnZhbHVlLm5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHNlbGZbTFJVX0xJU1RdLnVuc2hpZnROb2RlKG5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoaXQudmFsdWU7XG4gIH1cbn07XG5cbnZhciBpc1N0YWxlID0gZnVuY3Rpb24gaXNTdGFsZShzZWxmLCBoaXQpIHtcbiAgaWYgKCFoaXQgfHwgIWhpdC5tYXhBZ2UgJiYgIXNlbGZbTUFYX0FHRV0pIHJldHVybiBmYWxzZTtcbiAgdmFyIGRpZmYgPSBEYXRlLm5vdygpIC0gaGl0Lm5vdztcbiAgcmV0dXJuIGhpdC5tYXhBZ2UgPyBkaWZmID4gaGl0Lm1heEFnZSA6IHNlbGZbTUFYX0FHRV0gJiYgZGlmZiA+IHNlbGZbTUFYX0FHRV07XG59O1xuXG52YXIgdHJpbSA9IGZ1bmN0aW9uIHRyaW0oc2VsZikge1xuICBpZiAoc2VsZltMRU5HVEhdID4gc2VsZltNQVhdKSB7XG4gICAgZm9yICh2YXIgd2Fsa2VyID0gc2VsZltMUlVfTElTVF0udGFpbDsgc2VsZltMRU5HVEhdID4gc2VsZltNQVhdICYmIHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICAgIC8vIFdlIGtub3cgdGhhdCB3ZSdyZSBhYm91dCB0byBkZWxldGUgdGhpcyBvbmUsIGFuZCBhbHNvXG4gICAgICAvLyB3aGF0IHRoZSBuZXh0IGxlYXN0IHJlY2VudGx5IHVzZWQga2V5IHdpbGwgYmUsIHNvIGp1c3RcbiAgICAgIC8vIGdvIGFoZWFkIGFuZCBzZXQgaXQgbm93LlxuICAgICAgdmFyIHByZXYgPSB3YWxrZXIucHJldjtcblxuICAgICAgX2RlbChzZWxmLCB3YWxrZXIpO1xuXG4gICAgICB3YWxrZXIgPSBwcmV2O1xuICAgIH1cbiAgfVxufTtcblxudmFyIF9kZWwgPSBmdW5jdGlvbiBfZGVsKHNlbGYsIG5vZGUpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICB2YXIgaGl0ID0gbm9kZS52YWx1ZTtcbiAgICBpZiAoc2VsZltESVNQT1NFXSkgc2VsZltESVNQT1NFXShoaXQua2V5LCBoaXQudmFsdWUpO1xuICAgIHNlbGZbTEVOR1RIXSAtPSBoaXQubGVuZ3RoO1xuICAgIHNlbGZbQ0FDSEVdLmRlbGV0ZShoaXQua2V5KTtcbiAgICBzZWxmW0xSVV9MSVNUXS5yZW1vdmVOb2RlKG5vZGUpO1xuICB9XG59O1xuXG52YXIgRW50cnkgPSBmdW5jdGlvbiBFbnRyeShrZXksIHZhbHVlLCBsZW5ndGgsIG5vdywgbWF4QWdlKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbnRyeSk7XG5cbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gIHRoaXMubm93ID0gbm93O1xuICB0aGlzLm1heEFnZSA9IG1heEFnZSB8fCAwO1xufTtcblxudmFyIGZvckVhY2hTdGVwID0gZnVuY3Rpb24gZm9yRWFjaFN0ZXAoc2VsZiwgZm4sIG5vZGUsIHRoaXNwKSB7XG4gIHZhciBoaXQgPSBub2RlLnZhbHVlO1xuXG4gIGlmIChpc1N0YWxlKHNlbGYsIGhpdCkpIHtcbiAgICBfZGVsKHNlbGYsIG5vZGUpO1xuXG4gICAgaWYgKCFzZWxmW0FMTE9XX1NUQUxFXSkgaGl0ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKGhpdCkgZm4uY2FsbCh0aGlzcCwgaGl0LnZhbHVlLCBoaXQua2V5LCBzZWxmKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGU7XG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuaWYgKHRydWUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcbn0gZWxzZSB7fVxuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9OyAvLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICB9XG59KSgpO1xuXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gIH0gLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcblxuXG4gIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICB9IC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcblxuXG4gIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0cnkge1xuICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRyYWluaW5nID0gZmFsc2U7XG5cbiAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgfVxuXG4gIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICBkcmFpblF1ZXVlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgaWYgKGRyYWluaW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gIGRyYWluaW5nID0gdHJ1ZTtcbiAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcblxuICB3aGlsZSAobGVuKSB7XG4gICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgcXVldWUgPSBbXTtcblxuICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gIH1cblxuICBjdXJyZW50UXVldWUgPSBudWxsO1xuICBkcmFpbmluZyA9IGZhbHNlO1xuICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICB9XG5cbiAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcblxuICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gIH1cbn07IC8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcblxuXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgdGhpcy5mdW4gPSBmdW47XG4gIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cblxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5cbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gW107XG59O1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICcvJztcbn07XG5cbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gMDtcbn07XG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBZYWxsaXN0O1xuWWFsbGlzdC5Ob2RlID0gTm9kZTtcbllhbGxpc3QuY3JlYXRlID0gWWFsbGlzdDtcblxuZnVuY3Rpb24gWWFsbGlzdChsaXN0KSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIShzZWxmIGluc3RhbmNlb2YgWWFsbGlzdCkpIHtcbiAgICBzZWxmID0gbmV3IFlhbGxpc3QoKTtcbiAgfVxuXG4gIHNlbGYudGFpbCA9IG51bGw7XG4gIHNlbGYuaGVhZCA9IG51bGw7XG4gIHNlbGYubGVuZ3RoID0gMDtcblxuICBpZiAobGlzdCAmJiB0eXBlb2YgbGlzdC5mb3JFYWNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBzZWxmLnB1c2goaXRlbSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHNlbGYucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZW1vdmVOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUubGlzdCAhPT0gdGhpcykge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVtb3Zpbmcgbm9kZSB3aGljaCBkb2VzIG5vdCBiZWxvbmcgdG8gdGhpcyBsaXN0Jyk7XG4gIH1cblxuICB2YXIgbmV4dCA9IG5vZGUubmV4dDtcbiAgdmFyIHByZXYgPSBub2RlLnByZXY7XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSBwcmV2O1xuICB9XG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSBuZXh0O1xuICB9XG5cbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5leHQ7XG4gIH1cblxuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gcHJldjtcbiAgfVxuXG4gIG5vZGUubGlzdC5sZW5ndGgtLTtcbiAgbm9kZS5uZXh0ID0gbnVsbDtcbiAgbm9kZS5wcmV2ID0gbnVsbDtcbiAgbm9kZS5saXN0ID0gbnVsbDtcbiAgcmV0dXJuIG5leHQ7XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS51bnNoaWZ0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSk7XG4gIH1cblxuICB2YXIgaGVhZCA9IHRoaXMuaGVhZDtcbiAgbm9kZS5saXN0ID0gdGhpcztcbiAgbm9kZS5uZXh0ID0gaGVhZDtcblxuICBpZiAoaGVhZCkge1xuICAgIGhlYWQucHJldiA9IG5vZGU7XG4gIH1cblxuICB0aGlzLmhlYWQgPSBub2RlO1xuXG4gIGlmICghdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gbm9kZTtcbiAgfVxuXG4gIHRoaXMubGVuZ3RoKys7XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSk7XG4gIH1cblxuICB2YXIgdGFpbCA9IHRoaXMudGFpbDtcbiAgbm9kZS5saXN0ID0gdGhpcztcbiAgbm9kZS5wcmV2ID0gdGFpbDtcblxuICBpZiAodGFpbCkge1xuICAgIHRhaWwubmV4dCA9IG5vZGU7XG4gIH1cblxuICB0aGlzLnRhaWwgPSBub2RlO1xuXG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkID0gbm9kZTtcbiAgfVxuXG4gIHRoaXMubGVuZ3RoKys7XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwdXNoKHRoaXMsIGFyZ3VtZW50c1tpXSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5sZW5ndGg7XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB1bnNoaWZ0KHRoaXMsIGFyZ3VtZW50c1tpXSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5sZW5ndGg7XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy50YWlsKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLnRhaWwudmFsdWU7XG4gIHRoaXMudGFpbCA9IHRoaXMudGFpbC5wcmV2O1xuXG4gIGlmICh0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwubmV4dCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMubGVuZ3RoLS07XG4gIHJldHVybiByZXM7XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIHJlcyA9IHRoaXMuaGVhZC52YWx1ZTtcbiAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG5cbiAgaWYgKHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZC5wcmV2ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5sZW5ndGgtLTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbllhbGxpc3QucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpcztcblxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLmhlYWQsIGkgPSAwOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgaSwgdGhpcyk7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHQ7XG4gIH1cbn07XG5cbllhbGxpc3QucHJvdG90eXBlLmZvckVhY2hSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXM7XG5cbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy50YWlsLCBpID0gdGhpcy5sZW5ndGggLSAxOyB3YWxrZXIgIT09IG51bGw7IGktLSkge1xuICAgIGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgaSwgdGhpcyk7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXY7XG4gIH1cbn07XG5cbllhbGxpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuKSB7XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgbjsgaSsrKSB7XG4gICAgLy8gYWJvcnQgb3V0IG9mIHRoZSBsaXN0IGVhcmx5IGlmIHdlIGhpdCBhIGN5Y2xlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHQ7XG4gIH1cblxuICBpZiAoaSA9PT0gbiAmJiB3YWxrZXIgIT09IG51bGwpIHtcbiAgICByZXR1cm4gd2Fsa2VyLnZhbHVlO1xuICB9XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXRSZXZlcnNlID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldjtcbiAgfVxuXG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWU7XG4gIH1cbn07XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzO1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKTtcblxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKTtcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dDtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXBSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXM7XG4gIHZhciByZXMgPSBuZXcgWWFsbGlzdCgpO1xuXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHJlcy5wdXNoKGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgdGhpcykpO1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2O1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbllhbGxpc3QucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbCkge1xuICB2YXIgYWNjO1xuICB2YXIgd2Fsa2VyID0gdGhpcy5oZWFkO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIGFjYyA9IGluaXRpYWw7XG4gIH0gZWxzZSBpZiAodGhpcy5oZWFkKSB7XG4gICAgd2Fsa2VyID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgYWNjID0gdGhpcy5oZWFkLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBsaXN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpO1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0O1xuICB9XG5cbiAgcmV0dXJuIGFjYztcbn07XG5cbllhbGxpc3QucHJvdG90eXBlLnJlZHVjZVJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWwpIHtcbiAgdmFyIGFjYztcbiAgdmFyIHdhbGtlciA9IHRoaXMudGFpbDtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsO1xuICB9IGVsc2UgaWYgKHRoaXMudGFpbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbC5wcmV2O1xuICAgIGFjYyA9IHRoaXMudGFpbC52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpO1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2O1xuICB9XG5cbiAgcmV0dXJuIGFjYztcbn07XG5cbllhbGxpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYXJyW2ldID0gd2Fsa2VyLnZhbHVlO1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0O1xuICB9XG5cbiAgcmV0dXJuIGFycjtcbn07XG5cbllhbGxpc3QucHJvdG90eXBlLnRvQXJyYXlSZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFycltpXSA9IHdhbGtlci52YWx1ZTtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldjtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICB0byA9IHRvIHx8IHRoaXMubGVuZ3RoO1xuXG4gIGlmICh0byA8IDApIHtcbiAgICB0byArPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGZyb20gPSBmcm9tIHx8IDA7XG5cbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSArPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIHZhciByZXQgPSBuZXcgWWFsbGlzdCgpO1xuXG4gIGlmICh0byA8IGZyb20gfHwgdG8gPCAwKSB7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gPSAwO1xuICB9XG5cbiAgaWYgKHRvID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0byA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBmcm9tOyBpKyspIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dDtcbiAgfVxuXG4gIGZvciAoOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IHRvOyBpKyssIHdhbGtlciA9IHdhbGtlci5uZXh0KSB7XG4gICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS5zbGljZVJldmVyc2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aDtcblxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBmcm9tID0gZnJvbSB8fCAwO1xuXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKTtcblxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMDtcbiAgfVxuXG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IHRvOyBpLS0pIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldjtcbiAgfVxuXG4gIGZvciAoOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IGZyb207IGktLSwgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbllhbGxpc3QucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZGVsZXRlQ291bnRcbi8qLCAuLi5ub2RlcyAqL1xuKSB7XG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aCAtIDE7XG4gIH1cblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aCArIHN0YXJ0O1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBzdGFydDsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHQ7XG4gIH1cblxuICB2YXIgcmV0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAmJiBpIDwgZGVsZXRlQ291bnQ7IGkrKykge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSk7XG4gICAgd2Fsa2VyID0gdGhpcy5yZW1vdmVOb2RlKHdhbGtlcik7XG4gIH1cblxuICBpZiAod2Fsa2VyID09PSBudWxsKSB7XG4gICAgd2Fsa2VyID0gdGhpcy50YWlsO1xuICB9XG5cbiAgaWYgKHdhbGtlciAhPT0gdGhpcy5oZWFkICYmIHdhbGtlciAhPT0gdGhpcy50YWlsKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXY7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHdhbGtlciA9IGluc2VydCh0aGlzLCB3YWxrZXIsIGFyZ3VtZW50c1tpXSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuWWFsbGlzdC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQgPSB0aGlzLmhlYWQ7XG4gIHZhciB0YWlsID0gdGhpcy50YWlsO1xuXG4gIGZvciAodmFyIHdhbGtlciA9IGhlYWQ7IHdhbGtlciAhPT0gbnVsbDsgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICB2YXIgcCA9IHdhbGtlci5wcmV2O1xuICAgIHdhbGtlci5wcmV2ID0gd2Fsa2VyLm5leHQ7XG4gICAgd2Fsa2VyLm5leHQgPSBwO1xuICB9XG5cbiAgdGhpcy5oZWFkID0gdGFpbDtcbiAgdGhpcy50YWlsID0gaGVhZDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBpbnNlcnQoc2VsZiwgbm9kZSwgdmFsdWUpIHtcbiAgdmFyIGluc2VydGVkID0gbm9kZSA9PT0gc2VsZi5oZWFkID8gbmV3IE5vZGUodmFsdWUsIG51bGwsIG5vZGUsIHNlbGYpIDogbmV3IE5vZGUodmFsdWUsIG5vZGUsIG5vZGUubmV4dCwgc2VsZik7XG5cbiAgaWYgKGluc2VydGVkLm5leHQgPT09IG51bGwpIHtcbiAgICBzZWxmLnRhaWwgPSBpbnNlcnRlZDtcbiAgfVxuXG4gIGlmIChpbnNlcnRlZC5wcmV2ID09PSBudWxsKSB7XG4gICAgc2VsZi5oZWFkID0gaW5zZXJ0ZWQ7XG4gIH1cblxuICBzZWxmLmxlbmd0aCsrO1xuICByZXR1cm4gaW5zZXJ0ZWQ7XG59XG5cbmZ1bmN0aW9uIHB1c2goc2VsZiwgaXRlbSkge1xuICBzZWxmLnRhaWwgPSBuZXcgTm9kZShpdGVtLCBzZWxmLnRhaWwsIG51bGwsIHNlbGYpO1xuXG4gIGlmICghc2VsZi5oZWFkKSB7XG4gICAgc2VsZi5oZWFkID0gc2VsZi50YWlsO1xuICB9XG5cbiAgc2VsZi5sZW5ndGgrKztcbn1cblxuZnVuY3Rpb24gdW5zaGlmdChzZWxmLCBpdGVtKSB7XG4gIHNlbGYuaGVhZCA9IG5ldyBOb2RlKGl0ZW0sIG51bGwsIHNlbGYuaGVhZCwgc2VsZik7XG5cbiAgaWYgKCFzZWxmLnRhaWwpIHtcbiAgICBzZWxmLnRhaWwgPSBzZWxmLmhlYWQ7XG4gIH1cblxuICBzZWxmLmxlbmd0aCsrO1xufVxuXG5mdW5jdGlvbiBOb2RlKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBOb2RlKSkge1xuICAgIHJldHVybiBuZXcgTm9kZSh2YWx1ZSwgcHJldiwgbmV4dCwgbGlzdCk7XG4gIH1cblxuICB0aGlzLmxpc3QgPSBsaXN0O1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSB0aGlzO1xuICAgIHRoaXMucHJldiA9IHByZXY7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgfVxuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5wcmV2ID0gdGhpcztcbiAgICB0aGlzLm5leHQgPSBuZXh0O1xuICB9IGVsc2Uge1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG4gIH1cbn1cblxudHJ5IHtcbiAgLy8gYWRkIGlmIHN1cHBvcnQgZm9yIFN5bWJvbC5pdGVyYXRvciBpcyBwcmVzZW50XG4gIF9fd2VicGFja19yZXF1aXJlX18oMjEpKFlhbGxpc3QpO1xufSBjYXRjaCAoZXIpIHt9XG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoWWFsbGlzdCkge1xuICBZYWxsaXN0LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgdmFyIHdhbGtlcjtcbiAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB3YWxrZXIgPSB0aGlzLmhlYWQ7XG5cbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBpZiAoIXdhbGtlcikge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIHdhbGtlci52YWx1ZTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHdhbGtlciA9IHdhbGtlci5uZXh0O1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gIH0pO1xufTtcblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxudmFyIGIgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSxcbiAgICBjID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICBkID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICAgIGUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgZiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSxcbiAgICBnID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpLFxuICAgIGggPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICBrID0gU3ltYm9sLmZvcihcInJlYWN0LnNlcnZlcl9jb250ZXh0XCIpLFxuICAgIGwgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgbSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSxcbiAgICBuID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgcCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgIHEgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSxcbiAgICB0ID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKSxcbiAgICB1ID0gU3ltYm9sLmZvcihcInJlYWN0LmNhY2hlXCIpLFxuICAgIHYgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKTtcblxuZnVuY3Rpb24gdyhhKSB7XG4gIGlmIChcIm9iamVjdFwiID09PSBfdHlwZW9mKGEpICYmIG51bGwgIT09IGEpIHtcbiAgICB2YXIgciA9IGEuJCR0eXBlb2Y7XG5cbiAgICBzd2l0Y2ggKHIpIHtcbiAgICAgIGNhc2UgYjpcbiAgICAgICAgc3dpdGNoIChhID0gYS50eXBlLCBhKSB7XG4gICAgICAgICAgY2FzZSBkOlxuICAgICAgICAgIGNhc2UgZjpcbiAgICAgICAgICBjYXNlIGU6XG4gICAgICAgICAgY2FzZSBtOlxuICAgICAgICAgIGNhc2UgbjpcbiAgICAgICAgICAgIHJldHVybiBhO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHN3aXRjaCAoYSA9IGEgJiYgYS4kJHR5cGVvZiwgYSkge1xuICAgICAgICAgICAgICBjYXNlIGs6XG4gICAgICAgICAgICAgIGNhc2UgaDpcbiAgICAgICAgICAgICAgY2FzZSBsOlxuICAgICAgICAgICAgICBjYXNlIHE6XG4gICAgICAgICAgICAgIGNhc2UgcDpcbiAgICAgICAgICAgICAgY2FzZSBnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIGM6XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLkNvbnRleHRDb25zdW1lciA9IGg7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IGc7XG5leHBvcnRzLkVsZW1lbnQgPSBiO1xuZXhwb3J0cy5Gb3J3YXJkUmVmID0gbDtcbmV4cG9ydHMuRnJhZ21lbnQgPSBkO1xuZXhwb3J0cy5MYXp5ID0gcTtcbmV4cG9ydHMuTWVtbyA9IHA7XG5leHBvcnRzLlBvcnRhbCA9IGM7XG5leHBvcnRzLlByb2ZpbGVyID0gZjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IGU7XG5leHBvcnRzLlN1c3BlbnNlID0gbTtcbmV4cG9ydHMuU3VzcGVuc2VMaXN0ID0gbjtcblxuZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICExO1xufTtcblxuZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gITE7XG59O1xuXG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIHcoYSkgPT09IGg7XG59O1xuXG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIHcoYSkgPT09IGc7XG59O1xuXG5leHBvcnRzLmlzRWxlbWVudCA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBcIm9iamVjdFwiID09PSBfdHlwZW9mKGEpICYmIG51bGwgIT09IGEgJiYgYS4kJHR5cGVvZiA9PT0gYjtcbn07XG5cbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIHcoYSkgPT09IGw7XG59O1xuXG5leHBvcnRzLmlzRnJhZ21lbnQgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gdyhhKSA9PT0gZDtcbn07XG5cbmV4cG9ydHMuaXNMYXp5ID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIHcoYSkgPT09IHE7XG59O1xuXG5leHBvcnRzLmlzTWVtbyA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiB3KGEpID09PSBwO1xufTtcblxuZXhwb3J0cy5pc1BvcnRhbCA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiB3KGEpID09PSBjO1xufTtcblxuZXhwb3J0cy5pc1Byb2ZpbGVyID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIHcoYSkgPT09IGY7XG59O1xuXG5leHBvcnRzLmlzU3RyaWN0TW9kZSA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiB3KGEpID09PSBlO1xufTtcblxuZXhwb3J0cy5pc1N1c3BlbnNlID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIHcoYSkgPT09IG07XG59O1xuXG5leHBvcnRzLmlzU3VzcGVuc2VMaXN0ID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIHcoYSkgPT09IG47XG59O1xuXG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBcInN0cmluZ1wiID09PSB0eXBlb2YgYSB8fCBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBhIHx8IGEgPT09IGQgfHwgYSA9PT0gZiB8fCBhID09PSBlIHx8IGEgPT09IG0gfHwgYSA9PT0gbiB8fCBhID09PSB0IHx8IGEgPT09IHUgfHwgXCJvYmplY3RcIiA9PT0gX3R5cGVvZihhKSAmJiBudWxsICE9PSBhICYmIChhLiQkdHlwZW9mID09PSBxIHx8IGEuJCR0eXBlb2YgPT09IHAgfHwgYS4kJHR5cGVvZiA9PT0gZyB8fCBhLiQkdHlwZW9mID09PSBoIHx8IGEuJCR0eXBlb2YgPT09IGwgfHwgYS4kJHR5cGVvZiA9PT0gdiB8fCB2b2lkIDAgIT09IGEuZ2V0TW9kdWxlSWQpID8gITAgOiAhMTtcbn07XG5cbmV4cG9ydHMudHlwZU9mID0gdztcblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWRlYnVnLXRvb2xzLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxudmFyIGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KSxcbiAgICBwID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNiksXG4gICAgcSA9IE9iamVjdC5hc3NpZ24sXG4gICAgdyA9IHAuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQsXG4gICAgeCA9IFtdLFxuICAgIHkgPSBudWxsO1xuXG5mdW5jdGlvbiB6KCkge1xuICBpZiAobnVsbCA9PT0geSkge1xuICAgIHZhciBhID0gbmV3IE1hcCgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIEEudXNlQ29udGV4dCh7XG4gICAgICAgIF9jdXJyZW50VmFsdWU6IG51bGxcbiAgICAgIH0pLCBBLnVzZVN0YXRlKG51bGwpLCBBLnVzZVJlZHVjZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9LCBudWxsKSwgQS51c2VSZWYobnVsbCksIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIEEudXNlQ2FjaGVSZWZyZXNoICYmIEEudXNlQ2FjaGVSZWZyZXNoKCksIEEudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHt9KSwgQS51c2VJbnNlcnRpb25FZmZlY3QoZnVuY3Rpb24gKCkge30pLCBBLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7fSksIEEudXNlSW1wZXJhdGl2ZUhhbmRsZSh2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KSwgQS51c2VEZWJ1Z1ZhbHVlKG51bGwpLCBBLnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHt9KSwgQS51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdmFyIGIgPSB4O1xuICAgICAgeCA9IFtdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGUgPSAwOyBlIDwgYi5sZW5ndGg7IGUrKykge1xuICAgICAgdmFyIGcgPSBiW2VdO1xuICAgICAgYS5zZXQoZy5wcmltaXRpdmUsIGgucGFyc2UoZy5zdGFja0Vycm9yKSk7XG4gICAgfVxuXG4gICAgeSA9IGE7XG4gIH1cblxuICByZXR1cm4geTtcbn1cblxudmFyIEIgPSBudWxsO1xuXG5mdW5jdGlvbiBDKCkge1xuICB2YXIgYSA9IEI7XG4gIG51bGwgIT09IGEgJiYgKEIgPSBhLm5leHQpO1xuICByZXR1cm4gYTtcbn1cblxudmFyIEEgPSB7XG4gIHJlYWRDb250ZXh0OiBmdW5jdGlvbiByZWFkQ29udGV4dChhKSB7XG4gICAgcmV0dXJuIGEuX2N1cnJlbnRWYWx1ZTtcbiAgfSxcbiAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiB1c2VDYWNoZVJlZnJlc2goKSB7XG4gICAgdmFyIGEgPSBDKCk7XG4gICAgeC5wdXNoKHtcbiAgICAgIHByaW1pdGl2ZTogXCJDYWNoZVJlZnJlc2hcIixcbiAgICAgIHN0YWNrRXJyb3I6IEVycm9yKCksXG4gICAgICB2YWx1ZTogbnVsbCAhPT0gYSA/IGEubWVtb2l6ZWRTdGF0ZSA6IGZ1bmN0aW9uICgpIHt9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICB9LFxuICB1c2VDYWxsYmFjazogZnVuY3Rpb24gdXNlQ2FsbGJhY2soYSkge1xuICAgIHZhciBiID0gQygpO1xuICAgIHgucHVzaCh7XG4gICAgICBwcmltaXRpdmU6IFwiQ2FsbGJhY2tcIixcbiAgICAgIHN0YWNrRXJyb3I6IEVycm9yKCksXG4gICAgICB2YWx1ZTogbnVsbCAhPT0gYiA/IGIubWVtb2l6ZWRTdGF0ZVswXSA6IGFcbiAgICB9KTtcbiAgICByZXR1cm4gYTtcbiAgfSxcbiAgdXNlQ29udGV4dDogZnVuY3Rpb24gdXNlQ29udGV4dChhKSB7XG4gICAgeC5wdXNoKHtcbiAgICAgIHByaW1pdGl2ZTogXCJDb250ZXh0XCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IGEuX2N1cnJlbnRWYWx1ZVxuICAgIH0pO1xuICAgIHJldHVybiBhLl9jdXJyZW50VmFsdWU7XG4gIH0sXG4gIHVzZUVmZmVjdDogZnVuY3Rpb24gdXNlRWZmZWN0KGEpIHtcbiAgICBDKCk7XG4gICAgeC5wdXNoKHtcbiAgICAgIHByaW1pdGl2ZTogXCJFZmZlY3RcIixcbiAgICAgIHN0YWNrRXJyb3I6IEVycm9yKCksXG4gICAgICB2YWx1ZTogYVxuICAgIH0pO1xuICB9LFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKGEpIHtcbiAgICBDKCk7XG4gICAgdmFyIGIgPSB2b2lkIDA7XG4gICAgbnVsbCAhPT0gYSAmJiBcIm9iamVjdFwiID09PSBfdHlwZW9mKGEpICYmIChiID0gYS5jdXJyZW50KTtcbiAgICB4LnB1c2goe1xuICAgICAgcHJpbWl0aXZlOiBcIkltcGVyYXRpdmVIYW5kbGVcIixcbiAgICAgIHN0YWNrRXJyb3I6IEVycm9yKCksXG4gICAgICB2YWx1ZTogYlxuICAgIH0pO1xuICB9LFxuICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKGEsIGIpIHtcbiAgICB4LnB1c2goe1xuICAgICAgcHJpbWl0aXZlOiBcIkRlYnVnVmFsdWVcIixcbiAgICAgIHN0YWNrRXJyb3I6IEVycm9yKCksXG4gICAgICB2YWx1ZTogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYiA/IGIoYSkgOiBhXG4gICAgfSk7XG4gIH0sXG4gIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gdXNlTGF5b3V0RWZmZWN0KGEpIHtcbiAgICBDKCk7XG4gICAgeC5wdXNoKHtcbiAgICAgIHByaW1pdGl2ZTogXCJMYXlvdXRFZmZlY3RcIixcbiAgICAgIHN0YWNrRXJyb3I6IEVycm9yKCksXG4gICAgICB2YWx1ZTogYVxuICAgIH0pO1xuICB9LFxuICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIHVzZUluc2VydGlvbkVmZmVjdChhKSB7XG4gICAgQygpO1xuICAgIHgucHVzaCh7XG4gICAgICBwcmltaXRpdmU6IFwiSW5zZXJ0aW9uRWZmZWN0XCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IGFcbiAgICB9KTtcbiAgfSxcbiAgdXNlTWVtbzogZnVuY3Rpb24gdXNlTWVtbyhhKSB7XG4gICAgdmFyIGIgPSBDKCk7XG4gICAgYSA9IG51bGwgIT09IGIgPyBiLm1lbW9pemVkU3RhdGVbMF0gOiBhKCk7XG4gICAgeC5wdXNoKHtcbiAgICAgIHByaW1pdGl2ZTogXCJNZW1vXCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IGFcbiAgICB9KTtcbiAgICByZXR1cm4gYTtcbiAgfSxcbiAgdXNlUmVkdWNlcjogZnVuY3Rpb24gdXNlUmVkdWNlcihhLCBiLCBlKSB7XG4gICAgYSA9IEMoKTtcbiAgICBiID0gbnVsbCAhPT0gYSA/IGEubWVtb2l6ZWRTdGF0ZSA6IHZvaWQgMCAhPT0gZSA/IGUoYikgOiBiO1xuICAgIHgucHVzaCh7XG4gICAgICBwcmltaXRpdmU6IFwiUmVkdWNlclwiLFxuICAgICAgc3RhY2tFcnJvcjogRXJyb3IoKSxcbiAgICAgIHZhbHVlOiBiXG4gICAgfSk7XG4gICAgcmV0dXJuIFtiLCBmdW5jdGlvbiAoKSB7fV07XG4gIH0sXG4gIHVzZVJlZjogZnVuY3Rpb24gdXNlUmVmKGEpIHtcbiAgICB2YXIgYiA9IEMoKTtcbiAgICBhID0gbnVsbCAhPT0gYiA/IGIubWVtb2l6ZWRTdGF0ZSA6IHtcbiAgICAgIGN1cnJlbnQ6IGFcbiAgICB9O1xuICAgIHgucHVzaCh7XG4gICAgICBwcmltaXRpdmU6IFwiUmVmXCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IGEuY3VycmVudFxuICAgIH0pO1xuICAgIHJldHVybiBhO1xuICB9LFxuICB1c2VTdGF0ZTogZnVuY3Rpb24gdXNlU3RhdGUoYSkge1xuICAgIHZhciBiID0gQygpO1xuICAgIGEgPSBudWxsICE9PSBiID8gYi5tZW1vaXplZFN0YXRlIDogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYSA/IGEoKSA6IGE7XG4gICAgeC5wdXNoKHtcbiAgICAgIHByaW1pdGl2ZTogXCJTdGF0ZVwiLFxuICAgICAgc3RhY2tFcnJvcjogRXJyb3IoKSxcbiAgICAgIHZhbHVlOiBhXG4gICAgfSk7XG4gICAgcmV0dXJuIFthLCBmdW5jdGlvbiAoKSB7fV07XG4gIH0sXG4gIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uIHVzZVRyYW5zaXRpb24oKSB7XG4gICAgQygpO1xuICAgIEMoKTtcbiAgICB4LnB1c2goe1xuICAgICAgcHJpbWl0aXZlOiBcIlRyYW5zaXRpb25cIixcbiAgICAgIHN0YWNrRXJyb3I6IEVycm9yKCksXG4gICAgICB2YWx1ZTogdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIFshMSwgZnVuY3Rpb24gKCkge31dO1xuICB9LFxuICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiB1c2VNdXRhYmxlU291cmNlKGEsIGIpIHtcbiAgICBDKCk7XG4gICAgQygpO1xuICAgIEMoKTtcbiAgICBDKCk7XG4gICAgYSA9IGIoYS5fc291cmNlKTtcbiAgICB4LnB1c2goe1xuICAgICAgcHJpbWl0aXZlOiBcIk11dGFibGVTb3VyY2VcIixcbiAgICAgIHN0YWNrRXJyb3I6IEVycm9yKCksXG4gICAgICB2YWx1ZTogYVxuICAgIH0pO1xuICAgIHJldHVybiBhO1xuICB9LFxuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoYSwgYikge1xuICAgIEMoKTtcbiAgICBDKCk7XG4gICAgYSA9IGIoKTtcbiAgICB4LnB1c2goe1xuICAgICAgcHJpbWl0aXZlOiBcIlN5bmNFeHRlcm5hbFN0b3JlXCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IGFcbiAgICB9KTtcbiAgICByZXR1cm4gYTtcbiAgfSxcbiAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gdXNlRGVmZXJyZWRWYWx1ZShhKSB7XG4gICAgdmFyIGIgPSBDKCk7XG4gICAgeC5wdXNoKHtcbiAgICAgIHByaW1pdGl2ZTogXCJEZWZlcnJlZFZhbHVlXCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IG51bGwgIT09IGIgPyBiLm1lbW9pemVkU3RhdGUgOiBhXG4gICAgfSk7XG4gICAgcmV0dXJuIGE7XG4gIH0sXG4gIHVzZUlkOiBmdW5jdGlvbiB1c2VJZCgpIHtcbiAgICB2YXIgYSA9IEMoKTtcbiAgICBhID0gbnVsbCAhPT0gYSA/IGEubWVtb2l6ZWRTdGF0ZSA6IFwiXCI7XG4gICAgeC5wdXNoKHtcbiAgICAgIHByaW1pdGl2ZTogXCJJZFwiLFxuICAgICAgc3RhY2tFcnJvcjogRXJyb3IoKSxcbiAgICAgIHZhbHVlOiBhXG4gICAgfSk7XG4gICAgcmV0dXJuIGE7XG4gIH1cbn0sXG4gICAgRCA9IHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoYSwgYikge1xuICAgIGlmIChhLmhhc093blByb3BlcnR5KGIpKSByZXR1cm4gYVtiXTtcbiAgICBhID0gRXJyb3IoXCJNaXNzaW5nIG1ldGhvZCBpbiBEaXNwYXRjaGVyOiBcIiArIGIpO1xuICAgIGEubmFtZSA9IFwiUmVhY3REZWJ1Z1Rvb2xzVW5zdXBwb3J0ZWRIb29rRXJyb3JcIjtcbiAgICB0aHJvdyBhO1xuICB9XG59LFxuICAgIEUgPSBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgUHJveHkgPyBBIDogbmV3IFByb3h5KEEsIEQpLFxuICAgIEYgPSAwO1xuXG5mdW5jdGlvbiBHKGEsIGIsIGUpIHtcbiAgdmFyIGcgPSBiW2VdLnNvdXJjZSxcbiAgICAgIGMgPSAwO1xuXG4gIGE6IGZvciAoOyBjIDwgYS5sZW5ndGg7IGMrKykge1xuICAgIGlmIChhW2NdLnNvdXJjZSA9PT0gZykge1xuICAgICAgZm9yICh2YXIgayA9IGUgKyAxLCByID0gYyArIDE7IGsgPCBiLmxlbmd0aCAmJiByIDwgYS5sZW5ndGg7IGsrKywgcisrKSB7XG4gICAgICAgIGlmIChhW3JdLnNvdXJjZSAhPT0gYltrXS5zb3VyY2UpIGNvbnRpbnVlIGE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gSChhLCBiKSB7XG4gIGlmICghYSkgcmV0dXJuICExO1xuICBiID0gXCJ1c2VcIiArIGI7XG4gIHJldHVybiBhLmxlbmd0aCA8IGIubGVuZ3RoID8gITEgOiBhLmxhc3RJbmRleE9mKGIpID09PSBhLmxlbmd0aCAtIGIubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBJKGEsIGIsIGUpIHtcbiAgZm9yICh2YXIgZyA9IFtdLCBjID0gbnVsbCwgayA9IGcsIHIgPSAwLCB0ID0gW10sIHYgPSAwOyB2IDwgYi5sZW5ndGg7IHYrKykge1xuICAgIHZhciB1ID0gYlt2XTtcbiAgICB2YXIgZCA9IGE7XG4gICAgdmFyIGwgPSBoLnBhcnNlKHUuc3RhY2tFcnJvcik7XG5cbiAgICBiOiB7XG4gICAgICB2YXIgbSA9IGwsXG4gICAgICAgICAgbiA9IEcobSwgZCwgRik7XG4gICAgICBpZiAoLTEgIT09IG4pIGQgPSBuO2Vsc2Uge1xuICAgICAgICBmb3IgKHZhciBmID0gMDsgZiA8IGQubGVuZ3RoICYmIDUgPiBmOyBmKyspIHtcbiAgICAgICAgICBpZiAobiA9IEcobSwgZCwgZiksIC0xICE9PSBuKSB7XG4gICAgICAgICAgICBGID0gZjtcbiAgICAgICAgICAgIGQgPSBuO1xuICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkID0gLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYjoge1xuICAgICAgbSA9IGw7XG4gICAgICBuID0geigpLmdldCh1LnByaW1pdGl2ZSk7XG4gICAgICBpZiAodm9pZCAwICE9PSBuKSBmb3IgKGYgPSAwOyBmIDwgbi5sZW5ndGggJiYgZiA8IG0ubGVuZ3RoOyBmKyspIHtcbiAgICAgICAgaWYgKG5bZl0uc291cmNlICE9PSBtW2ZdLnNvdXJjZSkge1xuICAgICAgICAgIGYgPCBtLmxlbmd0aCAtIDEgJiYgSChtW2ZdLmZ1bmN0aW9uTmFtZSwgdS5wcmltaXRpdmUpICYmIGYrKztcbiAgICAgICAgICBmIDwgbS5sZW5ndGggLSAxICYmIEgobVtmXS5mdW5jdGlvbk5hbWUsIHUucHJpbWl0aXZlKSAmJiBmKys7XG4gICAgICAgICAgbSA9IGY7XG4gICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbSA9IC0xO1xuICAgIH1cblxuICAgIGwgPSAtMSA9PT0gZCB8fCAtMSA9PT0gbSB8fCAyID4gZCAtIG0gPyBudWxsIDogbC5zbGljZShtLCBkIC0gMSk7XG5cbiAgICBpZiAobnVsbCAhPT0gbCkge1xuICAgICAgZCA9IDA7XG5cbiAgICAgIGlmIChudWxsICE9PSBjKSB7XG4gICAgICAgIGZvciAoOyBkIDwgbC5sZW5ndGggJiYgZCA8IGMubGVuZ3RoICYmIGxbbC5sZW5ndGggLSBkIC0gMV0uc291cmNlID09PSBjW2MubGVuZ3RoIC0gZCAtIDFdLnNvdXJjZTspIHtcbiAgICAgICAgICBkKys7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGMgPSBjLmxlbmd0aCAtIDE7IGMgPiBkOyBjLS0pIHtcbiAgICAgICAgICBrID0gdC5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGMgPSBsLmxlbmd0aCAtIGQgLSAxOyAxIDw9IGM7IGMtLSkge1xuICAgICAgICBkID0gW10sIG0gPSBsW2NdLCAobiA9IGxbYyAtIDFdLmZ1bmN0aW9uTmFtZSkgPyAoZiA9IG4ubGFzdEluZGV4T2YoXCIuXCIpLCAtMSA9PT0gZiAmJiAoZiA9IDApLCBcInVzZVwiID09PSBuLnNsaWNlKGYsIGYgKyAzKSAmJiAoZiArPSAzKSwgbiA9IG4uc2xpY2UoZikpIDogbiA9IFwiXCIsIG4gPSB7XG4gICAgICAgICAgaWQ6IG51bGwsXG4gICAgICAgICAgaXNTdGF0ZUVkaXRhYmxlOiAhMSxcbiAgICAgICAgICBuYW1lOiBuLFxuICAgICAgICAgIHZhbHVlOiB2b2lkIDAsXG4gICAgICAgICAgc3ViSG9va3M6IGRcbiAgICAgICAgfSwgZSAmJiAobi5ob29rU291cmNlID0ge1xuICAgICAgICAgIGxpbmVOdW1iZXI6IG0ubGluZU51bWJlcixcbiAgICAgICAgICBjb2x1bW5OdW1iZXI6IG0uY29sdW1uTnVtYmVyLFxuICAgICAgICAgIGZ1bmN0aW9uTmFtZTogbS5mdW5jdGlvbk5hbWUsXG4gICAgICAgICAgZmlsZU5hbWU6IG0uZmlsZU5hbWVcbiAgICAgICAgfSksIGsucHVzaChuKSwgdC5wdXNoKGspLCBrID0gZDtcbiAgICAgIH1cblxuICAgICAgYyA9IGw7XG4gICAgfVxuXG4gICAgZCA9IHUucHJpbWl0aXZlO1xuICAgIHUgPSB7XG4gICAgICBpZDogXCJDb250ZXh0XCIgPT09IGQgfHwgXCJEZWJ1Z1ZhbHVlXCIgPT09IGQgPyBudWxsIDogcisrLFxuICAgICAgaXNTdGF0ZUVkaXRhYmxlOiBcIlJlZHVjZXJcIiA9PT0gZCB8fCBcIlN0YXRlXCIgPT09IGQsXG4gICAgICBuYW1lOiBkLFxuICAgICAgdmFsdWU6IHUudmFsdWUsXG4gICAgICBzdWJIb29rczogW11cbiAgICB9O1xuICAgIGUgJiYgKGQgPSB7XG4gICAgICBsaW5lTnVtYmVyOiBudWxsLFxuICAgICAgZnVuY3Rpb25OYW1lOiBudWxsLFxuICAgICAgZmlsZU5hbWU6IG51bGwsXG4gICAgICBjb2x1bW5OdW1iZXI6IG51bGxcbiAgICB9LCBsICYmIDEgPD0gbC5sZW5ndGggJiYgKGwgPSBsWzBdLCBkLmxpbmVOdW1iZXIgPSBsLmxpbmVOdW1iZXIsIGQuZnVuY3Rpb25OYW1lID0gbC5mdW5jdGlvbk5hbWUsIGQuZmlsZU5hbWUgPSBsLmZpbGVOYW1lLCBkLmNvbHVtbk51bWJlciA9IGwuY29sdW1uTnVtYmVyKSwgdS5ob29rU291cmNlID0gZCk7XG4gICAgay5wdXNoKHUpO1xuICB9XG5cbiAgSihnLCBudWxsKTtcbiAgcmV0dXJuIGc7XG59XG5cbmZ1bmN0aW9uIEooYSwgYikge1xuICBmb3IgKHZhciBlID0gW10sIGcgPSAwOyBnIDwgYS5sZW5ndGg7IGcrKykge1xuICAgIHZhciBjID0gYVtnXTtcbiAgICBcIkRlYnVnVmFsdWVcIiA9PT0gYy5uYW1lICYmIDAgPT09IGMuc3ViSG9va3MubGVuZ3RoID8gKGEuc3BsaWNlKGcsIDEpLCBnLS0sIGUucHVzaChjKSkgOiBKKGMuc3ViSG9va3MsIGMpO1xuICB9XG5cbiAgbnVsbCAhPT0gYiAmJiAoMSA9PT0gZS5sZW5ndGggPyBiLnZhbHVlID0gZVswXS52YWx1ZSA6IDEgPCBlLmxlbmd0aCAmJiAoYi52YWx1ZSA9IGUubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsudmFsdWU7XG4gIH0pKSk7XG59XG5cbmZ1bmN0aW9uIEsoYSkge1xuICBpZiAoYSBpbnN0YW5jZW9mIEVycm9yICYmIFwiUmVhY3REZWJ1Z1Rvb2xzVW5zdXBwb3J0ZWRIb29rRXJyb3JcIiA9PT0gYS5uYW1lKSB0aHJvdyBhO1xuICB2YXIgYiA9IEVycm9yKFwiRXJyb3IgcmVuZGVyaW5nIGluc3BlY3RlZCBjb21wb25lbnRcIiwge1xuICAgIGNhdXNlOiBhXG4gIH0pO1xuICBiLm5hbWUgPSBcIlJlYWN0RGVidWdUb29sc1JlbmRlckVycm9yXCI7XG4gIGIuY2F1c2UgPSBhO1xuICB0aHJvdyBiO1xufVxuXG5mdW5jdGlvbiBMKGEsIGIsIGUpIHtcbiAgdmFyIGcgPSAzIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1szXSA/IGFyZ3VtZW50c1szXSA6ICExO1xuICBudWxsID09IGUgJiYgKGUgPSB3LlJlYWN0Q3VycmVudERpc3BhdGNoZXIpO1xuICB2YXIgYyA9IGUuY3VycmVudDtcbiAgZS5jdXJyZW50ID0gRTtcblxuICB0cnkge1xuICAgIHZhciBrID0gRXJyb3IoKTtcbiAgICBhKGIpO1xuICB9IGNhdGNoICh0KSB7XG4gICAgSyh0KTtcbiAgfSBmaW5hbGx5IHtcbiAgICB2YXIgciA9IHg7XG4gICAgeCA9IFtdO1xuICAgIGUuY3VycmVudCA9IGM7XG4gIH1cblxuICBjID0gaC5wYXJzZShrKTtcbiAgcmV0dXJuIEkoYywgciwgZyk7XG59XG5cbmZ1bmN0aW9uIE0oYSkge1xuICBhLmZvckVhY2goZnVuY3Rpb24gKGIsIGUpIHtcbiAgICByZXR1cm4gZS5fY3VycmVudFZhbHVlID0gYjtcbiAgfSk7XG59XG5cbmV4cG9ydHMuaW5zcGVjdEhvb2tzID0gTDtcblxuZXhwb3J0cy5pbnNwZWN0SG9va3NPZkZpYmVyID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgdmFyIGUgPSAyIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6ICExO1xuICBudWxsID09IGIgJiYgKGIgPSB3LlJlYWN0Q3VycmVudERpc3BhdGNoZXIpO1xuICBpZiAoMCAhPT0gYS50YWcgJiYgMTUgIT09IGEudGFnICYmIDExICE9PSBhLnRhZykgdGhyb3cgRXJyb3IoXCJVbmtub3duIEZpYmVyLiBOZWVkcyB0byBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudCB0byBpbnNwZWN0IGhvb2tzLlwiKTtcbiAgeigpO1xuICB2YXIgZyA9IGEudHlwZSxcbiAgICAgIGMgPSBhLm1lbW9pemVkUHJvcHM7XG5cbiAgaWYgKGcgIT09IGEuZWxlbWVudFR5cGUgJiYgZyAmJiBnLmRlZmF1bHRQcm9wcykge1xuICAgIGMgPSBxKHt9LCBjKTtcbiAgICB2YXIgayA9IGcuZGVmYXVsdFByb3BzO1xuXG4gICAgZm9yIChyIGluIGspIHtcbiAgICAgIHZvaWQgMCA9PT0gY1tyXSAmJiAoY1tyXSA9IGtbcl0pO1xuICAgIH1cbiAgfVxuXG4gIEIgPSBhLm1lbW9pemVkU3RhdGU7XG4gIHZhciByID0gbmV3IE1hcCgpO1xuXG4gIHRyeSB7XG4gICAgZm9yIChrID0gYTsgazspIHtcbiAgICAgIGlmICgxMCA9PT0gay50YWcpIHtcbiAgICAgICAgdmFyIHQgPSBrLnR5cGUuX2NvbnRleHQ7XG4gICAgICAgIHIuaGFzKHQpIHx8IChyLnNldCh0LCB0Ll9jdXJyZW50VmFsdWUpLCB0Ll9jdXJyZW50VmFsdWUgPSBrLm1lbW9pemVkUHJvcHMudmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBrID0gay5yZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKDExID09PSBhLnRhZykge1xuICAgICAgdmFyIHYgPSBnLnJlbmRlcjtcbiAgICAgIGcgPSBjO1xuICAgICAgdmFyIHUgPSBhLnJlZjtcbiAgICAgIHQgPSBiO1xuICAgICAgdmFyIGQgPSB0LmN1cnJlbnQ7XG4gICAgICB0LmN1cnJlbnQgPSBFO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbCA9IEVycm9yKCk7XG4gICAgICAgIHYoZywgdSk7XG4gICAgICB9IGNhdGNoIChmKSB7XG4gICAgICAgIEsoZik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB2YXIgbSA9IHg7XG4gICAgICAgIHggPSBbXTtcbiAgICAgICAgdC5jdXJyZW50ID0gZDtcbiAgICAgIH1cblxuICAgICAgdmFyIG4gPSBoLnBhcnNlKGwpO1xuICAgICAgcmV0dXJuIEkobiwgbSwgZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEwoZywgYywgYiwgZSk7XG4gIH0gZmluYWxseSB7XG4gICAgQiA9IG51bGwsIE0ocik7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187ZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgJ3VzZSBzdHJpY3QnOyAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsIFJoaW5vLCBhbmQgYnJvd3NlcnMuXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICBpZiAodHJ1ZSkge1xuICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KV0sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRcdChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuICB9IGVsc2Uge31cbn0pKHRoaXMsIGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIoU3RhY2tGcmFtZSkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIEZJUkVGT1hfU0FGQVJJX1NUQUNLX1JFR0VYUCA9IC8oXnxAKVxcUys6XFxkKy87XG4gIHZhciBDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQID0gL15cXHMqYXQgLiooXFxTKzpcXGQrfFxcKG5hdGl2ZVxcKSkvbTtcbiAgdmFyIFNBRkFSSV9OQVRJVkVfQ09ERV9SRUdFWFAgPSAvXihldmFsQCk/KFxcW25hdGl2ZSBjb2RlXSk/JC87XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gRXJyb3Igb2JqZWN0LCBleHRyYWN0IHRoZSBtb3N0IGluZm9ybWF0aW9uIGZyb20gaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gb2YgU3RhY2tGcmFtZXNcbiAgICAgKi9cbiAgICBwYXJzZTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2UoZXJyb3IpIHtcbiAgICAgIGlmICh0eXBlb2YgZXJyb3Iuc3RhY2t0cmFjZSAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGVycm9yWydvcGVyYSNzb3VyY2Vsb2MnXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYShlcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yLnN0YWNrICYmIGVycm9yLnN0YWNrLm1hdGNoKENIUk9NRV9JRV9TVEFDS19SRUdFWFApKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVjhPcklFKGVycm9yKTtcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3Iuc3RhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGRk9yU2FmYXJpKGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIGdpdmVuIEVycm9yIG9iamVjdCcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gU2VwYXJhdGUgbGluZSBhbmQgY29sdW1uIG51bWJlcnMgZnJvbSBhIHN0cmluZyBvZiB0aGUgZm9ybTogKFVSSTpMaW5lOkNvbHVtbilcbiAgICBleHRyYWN0TG9jYXRpb246IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJGV4dHJhY3RMb2NhdGlvbih1cmxMaWtlKSB7XG4gICAgICAvLyBGYWlsLWZhc3QgYnV0IHJldHVybiBsb2NhdGlvbnMgbGlrZSBcIihuYXRpdmUpXCJcbiAgICAgIGlmICh1cmxMaWtlLmluZGV4T2YoJzonKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFt1cmxMaWtlXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZ0V4cCA9IC8oLis/KSg/OjooXFxkKykpPyg/OjooXFxkKykpPyQvO1xuICAgICAgdmFyIHBhcnRzID0gcmVnRXhwLmV4ZWModXJsTGlrZS5yZXBsYWNlKC9bKCldL2csICcnKSk7XG4gICAgICByZXR1cm4gW3BhcnRzWzFdLCBwYXJ0c1syXSB8fCB1bmRlZmluZWQsIHBhcnRzWzNdIHx8IHVuZGVmaW5lZF07XG4gICAgfSxcbiAgICBwYXJzZVY4T3JJRTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VWOE9ySUUoZXJyb3IpIHtcbiAgICAgIHZhciBmaWx0ZXJlZCA9IGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKS5maWx0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgcmV0dXJuICEhbGluZS5tYXRjaChDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgcmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICBpZiAobGluZS5pbmRleE9mKCcoZXZhbCAnKSA+IC0xKSB7XG4gICAgICAgICAgLy8gVGhyb3cgYXdheSBldmFsIGluZm9ybWF0aW9uIHVudGlsIHdlIGltcGxlbWVudCBzdGFja3RyYWNlLmpzL3N0YWNrZnJhbWUjOFxuICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoL2V2YWwgY29kZS9nLCAnZXZhbCcpLnJlcGxhY2UoLyhcXChldmFsIGF0IFteKCldKil8KFxcKSwuKiQpL2csICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzYW5pdGl6ZWRMaW5lID0gbGluZS5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXChldmFsIGNvZGUvZywgJygnKTsgLy8gY2FwdHVyZSBhbmQgcHJlc2V2ZSB0aGUgcGFyZW50aGVzaXplZCBsb2NhdGlvbiBcIigvZm9vL215IGJhci5qczoxMjo4NylcIiBpblxuICAgICAgICAvLyBjYXNlIGl0IGhhcyBzcGFjZXMgaW4gaXQsIGFzIHRoZSBzdHJpbmcgaXMgc3BsaXQgb24gXFxzKyBsYXRlciBvblxuXG4gICAgICAgIHZhciBsb2NhdGlvbiA9IHNhbml0aXplZExpbmUubWF0Y2goLyAoXFwoKC4rKTooXFxkKyk6KFxcZCspXFwpJCkvKTsgLy8gcmVtb3ZlIHRoZSBwYXJlbnRoZXNpemVkIGxvY2F0aW9uIGZyb20gdGhlIGxpbmUsIGlmIGl0IHdhcyBtYXRjaGVkXG5cbiAgICAgICAgc2FuaXRpemVkTGluZSA9IGxvY2F0aW9uID8gc2FuaXRpemVkTGluZS5yZXBsYWNlKGxvY2F0aW9uWzBdLCAnJykgOiBzYW5pdGl6ZWRMaW5lO1xuICAgICAgICB2YXIgdG9rZW5zID0gc2FuaXRpemVkTGluZS5zcGxpdCgvXFxzKy8pLnNsaWNlKDEpOyAvLyBpZiBhIGxvY2F0aW9uIHdhcyBtYXRjaGVkLCBwYXNzIGl0IHRvIGV4dHJhY3RMb2NhdGlvbigpIG90aGVyd2lzZSBwb3AgdGhlIGxhc3QgdG9rZW5cblxuICAgICAgICB2YXIgbG9jYXRpb25QYXJ0cyA9IHRoaXMuZXh0cmFjdExvY2F0aW9uKGxvY2F0aW9uID8gbG9jYXRpb25bMV0gOiB0b2tlbnMucG9wKCkpO1xuICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gdG9rZW5zLmpvaW4oJyAnKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBmaWxlTmFtZSA9IFsnZXZhbCcsICc8YW5vbnltb3VzPiddLmluZGV4T2YobG9jYXRpb25QYXJ0c1swXSkgPiAtMSA/IHVuZGVmaW5lZCA6IGxvY2F0aW9uUGFydHNbMF07XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgZmlsZU5hbWU6IGZpbGVOYW1lLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IGxvY2F0aW9uUGFydHNbMV0sXG4gICAgICAgICAgY29sdW1uTnVtYmVyOiBsb2NhdGlvblBhcnRzWzJdLFxuICAgICAgICAgIHNvdXJjZTogbGluZVxuICAgICAgICB9KTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG4gICAgcGFyc2VGRk9yU2FmYXJpOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZUZGT3JTYWZhcmkoZXJyb3IpIHtcbiAgICAgIHZhciBmaWx0ZXJlZCA9IGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKS5maWx0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgcmV0dXJuICFsaW5lLm1hdGNoKFNBRkFSSV9OQVRJVkVfQ09ERV9SRUdFWFApO1xuICAgICAgfSwgdGhpcyk7XG4gICAgICByZXR1cm4gZmlsdGVyZWQubWFwKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIC8vIFRocm93IGF3YXkgZXZhbCBpbmZvcm1hdGlvbiB1bnRpbCB3ZSBpbXBsZW1lbnQgc3RhY2t0cmFjZS5qcy9zdGFja2ZyYW1lIzhcbiAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignID4gZXZhbCcpID4gLTEpIHtcbiAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC8gbGluZSAoXFxkKykoPzogPiBldmFsIGxpbmUgXFxkKykqID4gZXZhbDpcXGQrOlxcZCsvZywgJzokMScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignQCcpID09PSAtMSAmJiBsaW5lLmluZGV4T2YoJzonKSA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBTYWZhcmkgZXZhbCBmcmFtZXMgb25seSBoYXZlIGZ1bmN0aW9uIG5hbWVzIGFuZCBub3RoaW5nIGVsc2VcbiAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBsaW5lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZVJlZ2V4ID0gLygoLipcIi4rXCJbXkBdKik/W15AXSopKD86QCkvO1xuICAgICAgICAgIHZhciBtYXRjaGVzID0gbGluZS5tYXRjaChmdW5jdGlvbk5hbWVSZWdleCk7XG4gICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IG1hdGNoZXMgJiYgbWF0Y2hlc1sxXSA/IG1hdGNoZXNbMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbihsaW5lLnJlcGxhY2UoZnVuY3Rpb25OYW1lUmVnZXgsICcnKSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgZmlsZU5hbWU6IGxvY2F0aW9uUGFydHNbMF0sXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsb2NhdGlvblBhcnRzWzFdLFxuICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBsb2NhdGlvblBhcnRzWzJdLFxuICAgICAgICAgICAgc291cmNlOiBsaW5lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG4gICAgcGFyc2VPcGVyYTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYShlKSB7XG4gICAgICBpZiAoIWUuc3RhY2t0cmFjZSB8fCBlLm1lc3NhZ2UuaW5kZXhPZignXFxuJykgPiAtMSAmJiBlLm1lc3NhZ2Uuc3BsaXQoJ1xcbicpLmxlbmd0aCA+IGUuc3RhY2t0cmFjZS5zcGxpdCgnXFxuJykubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmE5KGUpO1xuICAgICAgfSBlbHNlIGlmICghZS5zdGFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhMTAoZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhMTEoZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYXJzZU9wZXJhOTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTkoZSkge1xuICAgICAgdmFyIGxpbmVSRSA9IC9MaW5lIChcXGQrKS4qc2NyaXB0ICg/OmluICk/KFxcUyspL2k7XG4gICAgICB2YXIgbGluZXMgPSBlLm1lc3NhZ2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMiwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gbGluZVJFLmV4ZWMobGluZXNbaV0pO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgIGZpbGVOYW1lOiBtYXRjaFsyXSxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IG1hdGNoWzFdLFxuICAgICAgICAgICAgc291cmNlOiBsaW5lc1tpXVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgcGFyc2VPcGVyYTEwOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZU9wZXJhMTAoZSkge1xuICAgICAgdmFyIGxpbmVSRSA9IC9MaW5lIChcXGQrKS4qc2NyaXB0ICg/OmluICk/KFxcUyspKD86OiBJbiBmdW5jdGlvbiAoXFxTKykpPyQvaTtcbiAgICAgIHZhciBsaW5lcyA9IGUuc3RhY2t0cmFjZS5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lUkUuZXhlYyhsaW5lc1tpXSk7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBtYXRjaFszXSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBmaWxlTmFtZTogbWF0Y2hbMl0sXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBtYXRjaFsxXSxcbiAgICAgICAgICAgIHNvdXJjZTogbGluZXNbaV1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIC8vIE9wZXJhIDEwLjY1KyBFcnJvci5zdGFjayB2ZXJ5IHNpbWlsYXIgdG8gRkYvU2FmYXJpXG4gICAgcGFyc2VPcGVyYTExOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZU9wZXJhMTEoZXJyb3IpIHtcbiAgICAgIHZhciBmaWx0ZXJlZCA9IGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKS5maWx0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgcmV0dXJuICEhbGluZS5tYXRjaChGSVJFRk9YX1NBRkFSSV9TVEFDS19SRUdFWFApICYmICFsaW5lLm1hdGNoKC9eRXJyb3IgY3JlYXRlZCBhdC8pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgICByZXR1cm4gZmlsdGVyZWQubWFwKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSBsaW5lLnNwbGl0KCdAJyk7XG4gICAgICAgIHZhciBsb2NhdGlvblBhcnRzID0gdGhpcy5leHRyYWN0TG9jYXRpb24odG9rZW5zLnBvcCgpKTtcbiAgICAgICAgdmFyIGZ1bmN0aW9uQ2FsbCA9IHRva2Vucy5zaGlmdCgpIHx8ICcnO1xuICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb25DYWxsLnJlcGxhY2UoLzxhbm9ueW1vdXMgZnVuY3Rpb24oOiAoXFx3KykpPz4vLCAnJDInKS5yZXBsYWNlKC9cXChbXildKlxcKS9nLCAnJykgfHwgdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYXJnc1JhdztcblxuICAgICAgICBpZiAoZnVuY3Rpb25DYWxsLm1hdGNoKC9cXCgoW14pXSopXFwpLykpIHtcbiAgICAgICAgICBhcmdzUmF3ID0gZnVuY3Rpb25DYWxsLnJlcGxhY2UoL15bXihdK1xcKChbXildKilcXCkkLywgJyQxJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXJncyA9IGFyZ3NSYXcgPT09IHVuZGVmaW5lZCB8fCBhcmdzUmF3ID09PSAnW2FyZ3VtZW50cyBub3QgYXZhaWxhYmxlXScgPyB1bmRlZmluZWQgOiBhcmdzUmF3LnNwbGl0KCcsJyk7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgICBmaWxlTmFtZTogbG9jYXRpb25QYXJ0c1swXSxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBsb2NhdGlvblBhcnRzWzFdLFxuICAgICAgICAgIGNvbHVtbk51bWJlcjogbG9jYXRpb25QYXJ0c1syXSxcbiAgICAgICAgICBzb3VyY2U6IGxpbmVcbiAgICAgICAgfSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH07XG59KTtcblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCc7IC8vIFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbiAoVU1EKSB0byBzdXBwb3J0IEFNRCwgQ29tbW9uSlMvTm9kZS5qcywgUmhpbm8sIGFuZCBicm93c2Vycy5cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gIGlmICh0cnVlKSB7XG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW10sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRcdChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuICB9IGVsc2Uge31cbn0pKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF9pc051bWJlcihuKSB7XG4gICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jYXBpdGFsaXplKHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldHRlcihwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzW3BdO1xuICAgIH07XG4gIH1cblxuICB2YXIgYm9vbGVhblByb3BzID0gWydpc0NvbnN0cnVjdG9yJywgJ2lzRXZhbCcsICdpc05hdGl2ZScsICdpc1RvcGxldmVsJ107XG4gIHZhciBudW1lcmljUHJvcHMgPSBbJ2NvbHVtbk51bWJlcicsICdsaW5lTnVtYmVyJ107XG4gIHZhciBzdHJpbmdQcm9wcyA9IFsnZmlsZU5hbWUnLCAnZnVuY3Rpb25OYW1lJywgJ3NvdXJjZSddO1xuICB2YXIgYXJyYXlQcm9wcyA9IFsnYXJncyddO1xuICB2YXIgcHJvcHMgPSBib29sZWFuUHJvcHMuY29uY2F0KG51bWVyaWNQcm9wcywgc3RyaW5nUHJvcHMsIGFycmF5UHJvcHMpO1xuXG4gIGZ1bmN0aW9uIFN0YWNrRnJhbWUob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvYmpbcHJvcHNbaV1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpc1snc2V0JyArIF9jYXBpdGFsaXplKHByb3BzW2ldKV0ob2JqW3Byb3BzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgU3RhY2tGcmFtZS5wcm90b3R5cGUgPSB7XG4gICAgZ2V0QXJnczogZnVuY3Rpb24gZ2V0QXJncygpIHtcbiAgICAgIHJldHVybiB0aGlzLmFyZ3M7XG4gICAgfSxcbiAgICBzZXRBcmdzOiBmdW5jdGlvbiBzZXRBcmdzKHYpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJncyBtdXN0IGJlIGFuIEFycmF5Jyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXJncyA9IHY7XG4gICAgfSxcbiAgICBnZXRFdmFsT3JpZ2luOiBmdW5jdGlvbiBnZXRFdmFsT3JpZ2luKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXZhbE9yaWdpbjtcbiAgICB9LFxuICAgIHNldEV2YWxPcmlnaW46IGZ1bmN0aW9uIHNldEV2YWxPcmlnaW4odikge1xuICAgICAgaWYgKHYgaW5zdGFuY2VvZiBTdGFja0ZyYW1lKSB7XG4gICAgICAgIHRoaXMuZXZhbE9yaWdpbiA9IHY7XG4gICAgICB9IGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgdGhpcy5ldmFsT3JpZ2luID0gbmV3IFN0YWNrRnJhbWUodik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFdmFsIE9yaWdpbiBtdXN0IGJlIGFuIE9iamVjdCBvciBTdGFja0ZyYW1lJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSB0aGlzLmdldEZpbGVOYW1lKCkgfHwgJyc7XG4gICAgICB2YXIgbGluZU51bWJlciA9IHRoaXMuZ2V0TGluZU51bWJlcigpIHx8ICcnO1xuICAgICAgdmFyIGNvbHVtbk51bWJlciA9IHRoaXMuZ2V0Q29sdW1uTnVtYmVyKCkgfHwgJyc7XG4gICAgICB2YXIgZnVuY3Rpb25OYW1lID0gdGhpcy5nZXRGdW5jdGlvbk5hbWUoKSB8fCAnJztcblxuICAgICAgaWYgKHRoaXMuZ2V0SXNFdmFsKCkpIHtcbiAgICAgICAgaWYgKGZpbGVOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuICdbZXZhbF0gKCcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnOicgKyBjb2x1bW5OdW1iZXIgKyAnKSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ1tldmFsXTonICsgbGluZU51bWJlciArICc6JyArIGNvbHVtbk51bWJlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb25OYW1lICsgJyAoJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICc6JyArIGNvbHVtbk51bWJlciArICcpJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICc6JyArIGNvbHVtbk51bWJlcjtcbiAgICB9XG4gIH07XG5cbiAgU3RhY2tGcmFtZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gU3RhY2tGcmFtZSQkZnJvbVN0cmluZyhzdHIpIHtcbiAgICB2YXIgYXJnc1N0YXJ0SW5kZXggPSBzdHIuaW5kZXhPZignKCcpO1xuICAgIHZhciBhcmdzRW5kSW5kZXggPSBzdHIubGFzdEluZGV4T2YoJyknKTtcbiAgICB2YXIgZnVuY3Rpb25OYW1lID0gc3RyLnN1YnN0cmluZygwLCBhcmdzU3RhcnRJbmRleCk7XG4gICAgdmFyIGFyZ3MgPSBzdHIuc3Vic3RyaW5nKGFyZ3NTdGFydEluZGV4ICsgMSwgYXJnc0VuZEluZGV4KS5zcGxpdCgnLCcpO1xuICAgIHZhciBsb2NhdGlvblN0cmluZyA9IHN0ci5zdWJzdHJpbmcoYXJnc0VuZEluZGV4ICsgMSk7XG5cbiAgICBpZiAobG9jYXRpb25TdHJpbmcuaW5kZXhPZignQCcpID09PSAwKSB7XG4gICAgICB2YXIgcGFydHMgPSAvQCguKz8pKD86OihcXGQrKSk/KD86OihcXGQrKSk/JC8uZXhlYyhsb2NhdGlvblN0cmluZywgJycpO1xuICAgICAgdmFyIGZpbGVOYW1lID0gcGFydHNbMV07XG4gICAgICB2YXIgbGluZU51bWJlciA9IHBhcnRzWzJdO1xuICAgICAgdmFyIGNvbHVtbk51bWJlciA9IHBhcnRzWzNdO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICBmdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgIGFyZ3M6IGFyZ3MgfHwgdW5kZWZpbmVkLFxuICAgICAgZmlsZU5hbWU6IGZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogbGluZU51bWJlciB8fCB1bmRlZmluZWQsXG4gICAgICBjb2x1bW5OdW1iZXI6IGNvbHVtbk51bWJlciB8fCB1bmRlZmluZWRcbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2xlYW5Qcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydnZXQnICsgX2NhcGl0YWxpemUoYm9vbGVhblByb3BzW2ldKV0gPSBfZ2V0dGVyKGJvb2xlYW5Qcm9wc1tpXSk7XG5cbiAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnc2V0JyArIF9jYXBpdGFsaXplKGJvb2xlYW5Qcm9wc1tpXSldID0gZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgICB0aGlzW3BdID0gQm9vbGVhbih2KTtcbiAgICAgIH07XG4gICAgfShib29sZWFuUHJvcHNbaV0pO1xuICB9XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1lcmljUHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnZ2V0JyArIF9jYXBpdGFsaXplKG51bWVyaWNQcm9wc1tqXSldID0gX2dldHRlcihudW1lcmljUHJvcHNbal0pO1xuXG4gICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ3NldCcgKyBfY2FwaXRhbGl6ZShudW1lcmljUHJvcHNbal0pXSA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKCFfaXNOdW1iZXIodikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHAgKyAnIG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbcF0gPSBOdW1iZXIodik7XG4gICAgICB9O1xuICAgIH0obnVtZXJpY1Byb3BzW2pdKTtcbiAgfVxuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc3RyaW5nUHJvcHMubGVuZ3RoOyBrKyspIHtcbiAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnZ2V0JyArIF9jYXBpdGFsaXplKHN0cmluZ1Byb3BzW2tdKV0gPSBfZ2V0dGVyKHN0cmluZ1Byb3BzW2tdKTtcblxuICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydzZXQnICsgX2NhcGl0YWxpemUoc3RyaW5nUHJvcHNba10pXSA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdGhpc1twXSA9IFN0cmluZyh2KTtcbiAgICAgIH07XG4gICAgfShzdHJpbmdQcm9wc1trXSk7XG4gIH1cblxuICByZXR1cm4gU3RhY2tGcmFtZTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmlmICh0cnVlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG59IGVsc2Uge31cblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxudmFyIGwgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSxcbiAgICBuID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICBwID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICAgIHEgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgciA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSxcbiAgICB0ID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpLFxuICAgIHUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICB2ID0gU3ltYm9sLmZvcihcInJlYWN0LnNlcnZlcl9jb250ZXh0XCIpLFxuICAgIHcgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgeCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSxcbiAgICB5ID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgeiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgIEEgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSxcbiAgICBhYSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5kZWJ1Z190cmFjZV9tb2RlXCIpLFxuICAgIGJhID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKSxcbiAgICBjYSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jYWNoZVwiKSxcbiAgICBCID0gU3ltYm9sLmZvcihcInJlYWN0LmRlZmF1bHRfdmFsdWVcIiksXG4gICAgQyA9IFN5bWJvbC5pdGVyYXRvcjtcblxuZnVuY3Rpb24gZGEoYSkge1xuICBpZiAobnVsbCA9PT0gYSB8fCBcIm9iamVjdFwiICE9PSBfdHlwZW9mKGEpKSByZXR1cm4gbnVsbDtcbiAgYSA9IEMgJiYgYVtDXSB8fCBhW1wiQEBpdGVyYXRvclwiXTtcbiAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGEgPyBhIDogbnVsbDtcbn1cblxudmFyIEQgPSB7XG4gIGlzTW91bnRlZDogZnVuY3Rpb24gaXNNb3VudGVkKCkge1xuICAgIHJldHVybiAhMTtcbiAgfSxcbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiBlbnF1ZXVlRm9yY2VVcGRhdGUoKSB7fSxcbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gZW5xdWV1ZVJlcGxhY2VTdGF0ZSgpIHt9LFxuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIGVucXVldWVTZXRTdGF0ZSgpIHt9XG59LFxuICAgIEUgPSBPYmplY3QuYXNzaWduLFxuICAgIEYgPSB7fTtcblxuZnVuY3Rpb24gRyhhLCBiLCBjKSB7XG4gIHRoaXMucHJvcHMgPSBhO1xuICB0aGlzLmNvbnRleHQgPSBiO1xuICB0aGlzLnJlZnMgPSBGO1xuICB0aGlzLnVwZGF0ZXIgPSBjIHx8IEQ7XG59XG5cbkcucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuRy5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAoYSwgYikge1xuICBpZiAoXCJvYmplY3RcIiAhPT0gX3R5cGVvZihhKSAmJiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBhICYmIG51bGwgIT0gYSkgdGhyb3cgRXJyb3IoXCJzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy5cIik7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgYSwgYiwgXCJzZXRTdGF0ZVwiKTtcbn07XG5cbkcucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGEpIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBhLCBcImZvcmNlVXBkYXRlXCIpO1xufTtcblxuZnVuY3Rpb24gSCgpIHt9XG5cbkgucHJvdG90eXBlID0gRy5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIEkoYSwgYiwgYykge1xuICB0aGlzLnByb3BzID0gYTtcbiAgdGhpcy5jb250ZXh0ID0gYjtcbiAgdGhpcy5yZWZzID0gRjtcbiAgdGhpcy51cGRhdGVyID0gYyB8fCBEO1xufVxuXG52YXIgSiA9IEkucHJvdG90eXBlID0gbmV3IEgoKTtcbkouY29uc3RydWN0b3IgPSBJO1xuRShKLCBHLnByb3RvdHlwZSk7XG5KLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gITA7XG52YXIgSyA9IEFycmF5LmlzQXJyYXksXG4gICAgTCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgTSA9IHtcbiAgY3VycmVudDogbnVsbFxufSxcbiAgICBOID0ge1xuICBrZXk6ICEwLFxuICByZWY6ICEwLFxuICBfX3NlbGY6ICEwLFxuICBfX3NvdXJjZTogITBcbn07XG5cbmZ1bmN0aW9uIE8oYSwgYiwgYykge1xuICB2YXIgZCxcbiAgICAgIGUgPSB7fSxcbiAgICAgIGYgPSBudWxsLFxuICAgICAgZyA9IG51bGw7XG4gIGlmIChudWxsICE9IGIpIGZvciAoZCBpbiB2b2lkIDAgIT09IGIucmVmICYmIChnID0gYi5yZWYpLCB2b2lkIDAgIT09IGIua2V5ICYmIChmID0gXCJcIiArIGIua2V5KSwgYikge1xuICAgIEwuY2FsbChiLCBkKSAmJiAhTi5oYXNPd25Qcm9wZXJ0eShkKSAmJiAoZVtkXSA9IGJbZF0pO1xuICB9XG4gIHZhciBoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmICgxID09PSBoKSBlLmNoaWxkcmVuID0gYztlbHNlIGlmICgxIDwgaCkge1xuICAgIGZvciAodmFyIGsgPSBBcnJheShoKSwgbSA9IDA7IG0gPCBoOyBtKyspIHtcbiAgICAgIGtbbV0gPSBhcmd1bWVudHNbbSArIDJdO1xuICAgIH1cblxuICAgIGUuY2hpbGRyZW4gPSBrO1xuICB9XG4gIGlmIChhICYmIGEuZGVmYXVsdFByb3BzKSBmb3IgKGQgaW4gaCA9IGEuZGVmYXVsdFByb3BzLCBoKSB7XG4gICAgdm9pZCAwID09PSBlW2RdICYmIChlW2RdID0gaFtkXSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogbCxcbiAgICB0eXBlOiBhLFxuICAgIGtleTogZixcbiAgICByZWY6IGcsXG4gICAgcHJvcHM6IGUsXG4gICAgX293bmVyOiBNLmN1cnJlbnRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZWEoYSwgYikge1xuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBsLFxuICAgIHR5cGU6IGEudHlwZSxcbiAgICBrZXk6IGIsXG4gICAgcmVmOiBhLnJlZixcbiAgICBwcm9wczogYS5wcm9wcyxcbiAgICBfb3duZXI6IGEuX293bmVyXG4gIH07XG59XG5cbmZ1bmN0aW9uIFAoYSkge1xuICByZXR1cm4gXCJvYmplY3RcIiA9PT0gX3R5cGVvZihhKSAmJiBudWxsICE9PSBhICYmIGEuJCR0eXBlb2YgPT09IGw7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZShhKSB7XG4gIHZhciBiID0ge1xuICAgIFwiPVwiOiBcIj0wXCIsXG4gICAgXCI6XCI6IFwiPTJcIlxuICB9O1xuICByZXR1cm4gXCIkXCIgKyBhLnJlcGxhY2UoL1s9Ol0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gYltjXTtcbiAgfSk7XG59XG5cbnZhciBRID0gL1xcLysvZztcblxuZnVuY3Rpb24gUihhLCBiKSB7XG4gIHJldHVybiBcIm9iamVjdFwiID09PSBfdHlwZW9mKGEpICYmIG51bGwgIT09IGEgJiYgbnVsbCAhPSBhLmtleSA/IGVzY2FwZShcIlwiICsgYS5rZXkpIDogYi50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIFMoYSwgYiwgYywgZCwgZSkge1xuICB2YXIgZiA9IF90eXBlb2YoYSk7XG5cbiAgaWYgKFwidW5kZWZpbmVkXCIgPT09IGYgfHwgXCJib29sZWFuXCIgPT09IGYpIGEgPSBudWxsO1xuICB2YXIgZyA9ICExO1xuICBpZiAobnVsbCA9PT0gYSkgZyA9ICEwO2Vsc2Ugc3dpdGNoIChmKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGcgPSAhMDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgc3dpdGNoIChhLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgbDpcbiAgICAgICAgY2FzZSBuOlxuICAgICAgICAgIGcgPSAhMDtcbiAgICAgIH1cblxuICB9XG4gIGlmIChnKSByZXR1cm4gZyA9IGEsIGUgPSBlKGcpLCBhID0gXCJcIiA9PT0gZCA/IFwiLlwiICsgUihnLCAwKSA6IGQsIEsoZSkgPyAoYyA9IFwiXCIsIG51bGwgIT0gYSAmJiAoYyA9IGEucmVwbGFjZShRLCBcIiQmL1wiKSArIFwiL1wiKSwgUyhlLCBiLCBjLCBcIlwiLCBmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBtO1xuICB9KSkgOiBudWxsICE9IGUgJiYgKFAoZSkgJiYgKGUgPSBlYShlLCBjICsgKCFlLmtleSB8fCBnICYmIGcua2V5ID09PSBlLmtleSA/IFwiXCIgOiAoXCJcIiArIGUua2V5KS5yZXBsYWNlKFEsIFwiJCYvXCIpICsgXCIvXCIpICsgYSkpLCBiLnB1c2goZSkpLCAxO1xuICBnID0gMDtcbiAgZCA9IFwiXCIgPT09IGQgPyBcIi5cIiA6IGQgKyBcIjpcIjtcbiAgaWYgKEsoYSkpIGZvciAodmFyIGggPSAwOyBoIDwgYS5sZW5ndGg7IGgrKykge1xuICAgIGYgPSBhW2hdO1xuICAgIHZhciBrID0gZCArIFIoZiwgaCk7XG4gICAgZyArPSBTKGYsIGIsIGMsIGssIGUpO1xuICB9IGVsc2UgaWYgKGsgPSBkYShhKSwgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaykgZm9yIChhID0gay5jYWxsKGEpLCBoID0gMDsgIShmID0gYS5uZXh0KCkpLmRvbmU7KSB7XG4gICAgZiA9IGYudmFsdWUsIGsgPSBkICsgUihmLCBoKyspLCBnICs9IFMoZiwgYiwgYywgaywgZSk7XG4gIH0gZWxzZSBpZiAoXCJvYmplY3RcIiA9PT0gZikgdGhyb3cgYiA9IFN0cmluZyhhKSwgRXJyb3IoXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKFwiW29iamVjdCBPYmplY3RdXCIgPT09IGIgPyBcIm9iamVjdCB3aXRoIGtleXMge1wiICsgT2JqZWN0LmtleXMoYSkuam9pbihcIiwgXCIpICsgXCJ9XCIgOiBiKSArIFwiKS4gSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSBpbnN0ZWFkLlwiKTtcbiAgcmV0dXJuIGc7XG59XG5cbmZ1bmN0aW9uIFQoYSwgYiwgYykge1xuICBpZiAobnVsbCA9PSBhKSByZXR1cm4gYTtcbiAgdmFyIGQgPSBbXSxcbiAgICAgIGUgPSAwO1xuICBTKGEsIGQsIFwiXCIsIFwiXCIsIGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGIuY2FsbChjLCBmLCBlKyspO1xuICB9KTtcbiAgcmV0dXJuIGQ7XG59XG5cbmZ1bmN0aW9uIGZhKGEpIHtcbiAgaWYgKC0xID09PSBhLl9zdGF0dXMpIHtcbiAgICB2YXIgYiA9IGEuX3Jlc3VsdDtcbiAgICBiID0gYigpO1xuICAgIGIudGhlbihmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKDAgPT09IGEuX3N0YXR1cyB8fCAtMSA9PT0gYS5fc3RhdHVzKSBhLl9zdGF0dXMgPSAxLCBhLl9yZXN1bHQgPSBjO1xuICAgIH0sIGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoMCA9PT0gYS5fc3RhdHVzIHx8IC0xID09PSBhLl9zdGF0dXMpIGEuX3N0YXR1cyA9IDIsIGEuX3Jlc3VsdCA9IGM7XG4gICAgfSk7XG4gICAgLTEgPT09IGEuX3N0YXR1cyAmJiAoYS5fc3RhdHVzID0gMCwgYS5fcmVzdWx0ID0gYik7XG4gIH1cblxuICBpZiAoMSA9PT0gYS5fc3RhdHVzKSByZXR1cm4gYS5fcmVzdWx0LmRlZmF1bHQ7XG4gIHRocm93IGEuX3Jlc3VsdDtcbn1cblxudmFyIFUgPSB7XG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbmZ1bmN0aW9uIGhhKCkge1xuICByZXR1cm4gbmV3IFdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gVigpIHtcbiAgcmV0dXJuIHtcbiAgICBzOiAwLFxuICAgIHY6IHZvaWQgMCxcbiAgICBvOiBudWxsLFxuICAgIHA6IG51bGxcbiAgfTtcbn1cblxudmFyIFcgPSB7XG4gIGN1cnJlbnQ6IG51bGxcbn0sXG4gICAgWCA9IHtcbiAgdHJhbnNpdGlvbjogbnVsbFxufSxcbiAgICBZID0ge1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiBXLFxuICBSZWFjdEN1cnJlbnRDYWNoZTogVSxcbiAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWc6IFgsXG4gIFJlYWN0Q3VycmVudE93bmVyOiBNLFxuICBDb250ZXh0UmVnaXN0cnk6IHt9XG59LFxuICAgIFogPSBZLkNvbnRleHRSZWdpc3RyeTtcbmV4cG9ydHMuQ2hpbGRyZW4gPSB7XG4gIG1hcDogVCxcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChhLCBiLCBjKSB7XG4gICAgVChhLCBmdW5jdGlvbiAoKSB7XG4gICAgICBiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwgYyk7XG4gIH0sXG4gIGNvdW50OiBmdW5jdGlvbiBjb3VudChhKSB7XG4gICAgdmFyIGIgPSAwO1xuICAgIFQoYSwgZnVuY3Rpb24gKCkge1xuICAgICAgYisrO1xuICAgIH0pO1xuICAgIHJldHVybiBiO1xuICB9LFxuICB0b0FycmF5OiBmdW5jdGlvbiB0b0FycmF5KGEpIHtcbiAgICByZXR1cm4gVChhLCBmdW5jdGlvbiAoYikge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSkgfHwgW107XG4gIH0sXG4gIG9ubHk6IGZ1bmN0aW9uIG9ubHkoYSkge1xuICAgIGlmICghUChhKSkgdGhyb3cgRXJyb3IoXCJSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC5cIik7XG4gICAgcmV0dXJuIGE7XG4gIH1cbn07XG5leHBvcnRzLkNvbXBvbmVudCA9IEc7XG5leHBvcnRzLkZyYWdtZW50ID0gcDtcbmV4cG9ydHMuUHJvZmlsZXIgPSByO1xuZXhwb3J0cy5QdXJlQ29tcG9uZW50ID0gSTtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IHE7XG5leHBvcnRzLlN1c3BlbnNlID0geDtcbmV4cG9ydHMuU3VzcGVuc2VMaXN0ID0geTtcbmV4cG9ydHMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSBZO1xuXG5leHBvcnRzLmNhY2hlID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYiA9IFUuY3VycmVudDtcbiAgICBpZiAoIWIpIHJldHVybiBhLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgdmFyIGMgPSBiLmdldENhY2hlRm9yVHlwZShoYSk7XG4gICAgYiA9IGMuZ2V0KGEpO1xuICAgIHZvaWQgMCA9PT0gYiAmJiAoYiA9IFYoKSwgYy5zZXQoYSwgYikpO1xuICAgIGMgPSAwO1xuXG4gICAgZm9yICh2YXIgZCA9IGFyZ3VtZW50cy5sZW5ndGg7IGMgPCBkOyBjKyspIHtcbiAgICAgIHZhciBlID0gYXJndW1lbnRzW2NdO1xuXG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZSB8fCBcIm9iamVjdFwiID09PSBfdHlwZW9mKGUpICYmIG51bGwgIT09IGUpIHtcbiAgICAgICAgdmFyIGYgPSBiLm87XG4gICAgICAgIG51bGwgPT09IGYgJiYgKGIubyA9IGYgPSBuZXcgV2Vha01hcCgpKTtcbiAgICAgICAgYiA9IGYuZ2V0KGUpO1xuICAgICAgICB2b2lkIDAgPT09IGIgJiYgKGIgPSBWKCksIGYuc2V0KGUsIGIpKTtcbiAgICAgIH0gZWxzZSBmID0gYi5wLCBudWxsID09PSBmICYmIChiLnAgPSBmID0gbmV3IE1hcCgpKSwgYiA9IGYuZ2V0KGUpLCB2b2lkIDAgPT09IGIgJiYgKGIgPSBWKCksIGYuc2V0KGUsIGIpKTtcbiAgICB9XG5cbiAgICBpZiAoMSA9PT0gYi5zKSByZXR1cm4gYi52O1xuICAgIGlmICgyID09PSBiLnMpIHRocm93IGIudjtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgZyA9IGEuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIGMgPSBiO1xuICAgICAgYy5zID0gMTtcbiAgICAgIHJldHVybiBjLnYgPSBnO1xuICAgIH0gY2F0Y2ggKGgpIHtcbiAgICAgIHRocm93IGcgPSBiLCBnLnMgPSAyLCBnLnYgPSBoLCBoO1xuICAgIH1cbiAgfTtcbn07XG5cbmV4cG9ydHMuY2xvbmVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgaWYgKG51bGwgPT09IGEgfHwgdm9pZCAwID09PSBhKSB0aHJvdyBFcnJvcihcIlJlYWN0LmNsb25lRWxlbWVudCguLi4pOiBUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkIFwiICsgYSArIFwiLlwiKTtcbiAgdmFyIGQgPSBFKHt9LCBhLnByb3BzKSxcbiAgICAgIGUgPSBhLmtleSxcbiAgICAgIGYgPSBhLnJlZixcbiAgICAgIGcgPSBhLl9vd25lcjtcblxuICBpZiAobnVsbCAhPSBiKSB7XG4gICAgdm9pZCAwICE9PSBiLnJlZiAmJiAoZiA9IGIucmVmLCBnID0gTS5jdXJyZW50KTtcbiAgICB2b2lkIDAgIT09IGIua2V5ICYmIChlID0gXCJcIiArIGIua2V5KTtcbiAgICBpZiAoYS50eXBlICYmIGEudHlwZS5kZWZhdWx0UHJvcHMpIHZhciBoID0gYS50eXBlLmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAoayBpbiBiKSB7XG4gICAgICBMLmNhbGwoYiwgaykgJiYgIU4uaGFzT3duUHJvcGVydHkoaykgJiYgKGRba10gPSB2b2lkIDAgPT09IGJba10gJiYgdm9pZCAwICE9PSBoID8gaFtrXSA6IGJba10pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBrID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmICgxID09PSBrKSBkLmNoaWxkcmVuID0gYztlbHNlIGlmICgxIDwgaykge1xuICAgIGggPSBBcnJheShrKTtcblxuICAgIGZvciAodmFyIG0gPSAwOyBtIDwgazsgbSsrKSB7XG4gICAgICBoW21dID0gYXJndW1lbnRzW20gKyAyXTtcbiAgICB9XG5cbiAgICBkLmNoaWxkcmVuID0gaDtcbiAgfVxuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBsLFxuICAgIHR5cGU6IGEudHlwZSxcbiAgICBrZXk6IGUsXG4gICAgcmVmOiBmLFxuICAgIHByb3BzOiBkLFxuICAgIF9vd25lcjogZ1xuICB9O1xufTtcblxuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24gKGEpIHtcbiAgYSA9IHtcbiAgICAkJHR5cGVvZjogdSxcbiAgICBfY3VycmVudFZhbHVlOiBhLFxuICAgIF9jdXJyZW50VmFsdWUyOiBhLFxuICAgIF90aHJlYWRDb3VudDogMCxcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBDb25zdW1lcjogbnVsbCxcbiAgICBfZGVmYXVsdFZhbHVlOiBudWxsLFxuICAgIF9nbG9iYWxOYW1lOiBudWxsXG4gIH07XG4gIGEuUHJvdmlkZXIgPSB7XG4gICAgJCR0eXBlb2Y6IHQsXG4gICAgX2NvbnRleHQ6IGFcbiAgfTtcbiAgcmV0dXJuIGEuQ29uc3VtZXIgPSBhO1xufTtcblxuZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gTztcblxuZXhwb3J0cy5jcmVhdGVGYWN0b3J5ID0gZnVuY3Rpb24gKGEpIHtcbiAgdmFyIGIgPSBPLmJpbmQobnVsbCwgYSk7XG4gIGIudHlwZSA9IGE7XG4gIHJldHVybiBiO1xufTtcblxuZXhwb3J0cy5jcmVhdGVSZWYgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgY3VycmVudDogbnVsbFxuICB9O1xufTtcblxuZXhwb3J0cy5jcmVhdGVTZXJ2ZXJDb250ZXh0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgdmFyIGMgPSAhMDtcblxuICBpZiAoIVpbYV0pIHtcbiAgICBjID0gITE7XG4gICAgdmFyIGQgPSB7XG4gICAgICAkJHR5cGVvZjogdixcbiAgICAgIF9jdXJyZW50VmFsdWU6IGIsXG4gICAgICBfY3VycmVudFZhbHVlMjogYixcbiAgICAgIF9kZWZhdWx0VmFsdWU6IGIsXG4gICAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgICBQcm92aWRlcjogbnVsbCxcbiAgICAgIENvbnN1bWVyOiBudWxsLFxuICAgICAgX2dsb2JhbE5hbWU6IGFcbiAgICB9O1xuICAgIGQuUHJvdmlkZXIgPSB7XG4gICAgICAkJHR5cGVvZjogdCxcbiAgICAgIF9jb250ZXh0OiBkXG4gICAgfTtcbiAgICBaW2FdID0gZDtcbiAgfVxuXG4gIGQgPSBaW2FdO1xuICBpZiAoZC5fZGVmYXVsdFZhbHVlID09PSBCKSBkLl9kZWZhdWx0VmFsdWUgPSBiLCBkLl9jdXJyZW50VmFsdWUgPT09IEIgJiYgKGQuX2N1cnJlbnRWYWx1ZSA9IGIpLCBkLl9jdXJyZW50VmFsdWUyID09PSBCICYmIChkLl9jdXJyZW50VmFsdWUyID0gYik7ZWxzZSBpZiAoYykgdGhyb3cgRXJyb3IoXCJTZXJ2ZXJDb250ZXh0OiBcIiArIGEgKyBcIiBhbHJlYWR5IGRlZmluZWRcIik7XG4gIHJldHVybiBkO1xufTtcblxuZXhwb3J0cy5leHBlcmltZW50YWxfdXNlRWZmZWN0RXZlbnQgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gVy5jdXJyZW50LnVzZUVmZmVjdEV2ZW50KGEpO1xufTtcblxuZXhwb3J0cy5mb3J3YXJkUmVmID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogdyxcbiAgICByZW5kZXI6IGFcbiAgfTtcbn07XG5cbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnQgPSBQO1xuXG5leHBvcnRzLmxhenkgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBBLFxuICAgIF9wYXlsb2FkOiB7XG4gICAgICBfc3RhdHVzOiAtMSxcbiAgICAgIF9yZXN1bHQ6IGFcbiAgICB9LFxuICAgIF9pbml0OiBmYVxuICB9O1xufTtcblxuZXhwb3J0cy5tZW1vID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogeixcbiAgICB0eXBlOiBhLFxuICAgIGNvbXBhcmU6IHZvaWQgMCA9PT0gYiA/IG51bGwgOiBiXG4gIH07XG59O1xuXG5leHBvcnRzLnN0YXJ0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChhKSB7XG4gIHZhciBiID0gWC50cmFuc2l0aW9uO1xuICBYLnRyYW5zaXRpb24gPSB7fTtcblxuICB0cnkge1xuICAgIGEoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBYLnRyYW5zaXRpb24gPSBiO1xuICB9XG59O1xuXG5leHBvcnRzLnVuc3RhYmxlX0NhY2hlID0gY2E7XG5leHBvcnRzLnVuc3RhYmxlX0RlYnVnVHJhY2luZ01vZGUgPSBhYTtcbmV4cG9ydHMudW5zdGFibGVfT2Zmc2NyZWVuID0gYmE7XG5cbmV4cG9ydHMudW5zdGFibGVfYWN0ID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBFcnJvcihcImFjdCguLi4pIGlzIG5vdCBzdXBwb3J0ZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMgb2YgUmVhY3QuXCIpO1xufTtcblxuZXhwb3J0cy51bnN0YWJsZV9nZXRDYWNoZUZvclR5cGUgPSBmdW5jdGlvbiAoYSkge1xuICB2YXIgYiA9IFUuY3VycmVudDtcbiAgcmV0dXJuIGIgPyBiLmdldENhY2hlRm9yVHlwZShhKSA6IGEoKTtcbn07XG5cbmV4cG9ydHMudW5zdGFibGVfZ2V0Q2FjaGVTaWduYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhID0gVS5jdXJyZW50O1xuICByZXR1cm4gYSA/IGEuZ2V0Q2FjaGVTaWduYWwoKSA6IChhID0gbmV3IEFib3J0Q29udHJvbGxlcigpLCBhLmFib3J0KEVycm9yKFwiVGhpcyBDYWNoZVNpZ25hbCB3YXMgcmVxdWVzdGVkIG91dHNpZGUgUmVhY3Qgd2hpY2ggbWVhbnMgdGhhdCBpdCBpcyBpbW1lZGlhdGVseSBhYm9ydGVkLlwiKSksIGEuc2lnbmFsKTtcbn07XG5cbmV4cG9ydHMudW5zdGFibGVfdXNlQ2FjaGVSZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gVy5jdXJyZW50LnVzZUNhY2hlUmVmcmVzaCgpO1xufTtcblxuZXhwb3J0cy51bnN0YWJsZV91c2VNZW1vQ2FjaGUgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gVy5jdXJyZW50LnVzZU1lbW9DYWNoZShhKTtcbn07XG5cbmV4cG9ydHMudXNlID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIFcuY3VycmVudC51c2UoYSk7XG59O1xuXG5leHBvcnRzLnVzZUNhbGxiYWNrID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgcmV0dXJuIFcuY3VycmVudC51c2VDYWxsYmFjayhhLCBiKTtcbn07XG5cbmV4cG9ydHMudXNlQ29udGV4dCA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBXLmN1cnJlbnQudXNlQ29udGV4dChhKTtcbn07XG5cbmV4cG9ydHMudXNlRGVidWdWYWx1ZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG5leHBvcnRzLnVzZURlZmVycmVkVmFsdWUgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gVy5jdXJyZW50LnVzZURlZmVycmVkVmFsdWUoYSk7XG59O1xuXG5leHBvcnRzLnVzZUVmZmVjdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHJldHVybiBXLmN1cnJlbnQudXNlRWZmZWN0KGEsIGIpO1xufTtcblxuZXhwb3J0cy51c2VJZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFcuY3VycmVudC51c2VJZCgpO1xufTtcblxuZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgcmV0dXJuIFcuY3VycmVudC51c2VJbXBlcmF0aXZlSGFuZGxlKGEsIGIsIGMpO1xufTtcblxuZXhwb3J0cy51c2VJbnNlcnRpb25FZmZlY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICByZXR1cm4gVy5jdXJyZW50LnVzZUluc2VydGlvbkVmZmVjdChhLCBiKTtcbn07XG5cbmV4cG9ydHMudXNlTGF5b3V0RWZmZWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgcmV0dXJuIFcuY3VycmVudC51c2VMYXlvdXRFZmZlY3QoYSwgYik7XG59O1xuXG5leHBvcnRzLnVzZU1lbW8gPSBmdW5jdGlvbiAoYSwgYikge1xuICByZXR1cm4gVy5jdXJyZW50LnVzZU1lbW8oYSwgYik7XG59O1xuXG5leHBvcnRzLnVzZVJlZHVjZXIgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICByZXR1cm4gVy5jdXJyZW50LnVzZVJlZHVjZXIoYSwgYiwgYyk7XG59O1xuXG5leHBvcnRzLnVzZVJlZiA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBXLmN1cnJlbnQudXNlUmVmKGEpO1xufTtcblxuZXhwb3J0cy51c2VTdGF0ZSA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBXLmN1cnJlbnQudXNlU3RhdGUoYSk7XG59O1xuXG5leHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgcmV0dXJuIFcuY3VycmVudC51c2VTeW5jRXh0ZXJuYWxTdG9yZShhLCBiLCBjKTtcbn07XG5cbmV4cG9ydHMudXNlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFcuY3VycmVudC51c2VUcmFuc2l0aW9uKCk7XG59O1xuXG5leHBvcnRzLnZlcnNpb24gPSBcIjE4LjMuMC1leHBlcmltZW50YWwtN2Y4YzUwMWY2LTIwMjMwNDIwXCI7XG5cbi8qKiovIH0pLFxuLyogMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY29ubmVjdFRvRGV2VG9vbHNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGNvbm5lY3RUb0RldlRvb2xzOyB9KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9ldmVudHMuanNcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG52YXIgRXZlbnRFbWl0dGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudEVtaXR0ZXIpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibGlzdGVuZXJzTWFwXCIsIG5ldyBNYXAoKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRXZlbnRFbWl0dGVyLCBbe1xuICAgIGtleTogXCJhZGRMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc01hcC5nZXQoZXZlbnQpO1xuXG4gICAgICBpZiAobGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNNYXAuc2V0KGV2ZW50LCBbbGlzdGVuZXJdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVtaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdChldmVudCkge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzTWFwLmdldChldmVudCk7XG5cbiAgICAgIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIC8vIE5vIG5lZWQgdG8gY2xvbmUgb3IgdHJ5L2NhdGNoXG4gICAgICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzWzBdO1xuICAgICAgICAgIGxpc3RlbmVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkaWRUaHJvdyA9IGZhbHNlO1xuICAgICAgICAgIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICAgICAgdmFyIGNsb25lZExpc3RlbmVycyA9IEFycmF5LmZyb20obGlzdGVuZXJzKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgX2xpc3RlbmVyID0gY2xvbmVkTGlzdGVuZXJzW2ldO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBfbGlzdGVuZXIuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBpZiAoY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkaWRUaHJvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkaWRUaHJvdykge1xuICAgICAgICAgICAgdGhyb3cgY2F1Z2h0RXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUFsbExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyc01hcC5jbGVhcigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc01hcC5nZXQoZXZlbnQpO1xuXG4gICAgICBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuXG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRXZlbnRFbWl0dGVyO1xufSgpO1xuXG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogL1VzZXJzL2hveHkvcmVwb3MvcmVhY3Qvbm9kZV9tb2R1bGVzL2xvZGFzaC50aHJvdHRsZS9pbmRleC5qc1xudmFyIGxvZGFzaF90aHJvdHRsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xudmFyIGxvZGFzaF90aHJvdHRsZV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihsb2Rhc2hfdGhyb3R0bGUpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvY29uc3RhbnRzLmpzXG52YXIgY29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL3N0b3JhZ2UuanNcbnZhciBzdG9yYWdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogL1VzZXJzL2hveHkvcmVwb3MvcmVhY3Qvbm9kZV9tb2R1bGVzL21lbW9pemUtb25lL2VzbS9pbmRleC5qc1xudmFyIHNpbXBsZUlzRXF1YWwgPSBmdW5jdGlvbiBzaW1wbGVJc0VxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBlc20gPSAoZnVuY3Rpb24gKHJlc3VsdEZuKSB7XG4gIHZhciBpc0VxdWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBzaW1wbGVJc0VxdWFsO1xuICB2YXIgbGFzdFRoaXMgPSB2b2lkIDA7XG4gIHZhciBsYXN0QXJncyA9IFtdO1xuICB2YXIgbGFzdFJlc3VsdCA9IHZvaWQgMDtcbiAgdmFyIGNhbGxlZE9uY2UgPSBmYWxzZTtcblxuICB2YXIgaXNOZXdBcmdFcXVhbFRvTGFzdCA9IGZ1bmN0aW9uIGlzTmV3QXJnRXF1YWxUb0xhc3QobmV3QXJnLCBpbmRleCkge1xuICAgIHJldHVybiBpc0VxdWFsKG5ld0FyZywgbGFzdEFyZ3NbaW5kZXhdKTtcbiAgfTtcblxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24gcmVzdWx0KCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBuZXdBcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBuZXdBcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChjYWxsZWRPbmNlICYmIGxhc3RUaGlzID09PSB0aGlzICYmIG5ld0FyZ3MubGVuZ3RoID09PSBsYXN0QXJncy5sZW5ndGggJiYgbmV3QXJncy5ldmVyeShpc05ld0FyZ0VxdWFsVG9MYXN0KSkge1xuICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgfVxuXG4gICAgY2FsbGVkT25jZSA9IHRydWU7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RBcmdzID0gbmV3QXJncztcbiAgICBsYXN0UmVzdWx0ID0gcmVzdWx0Rm4uYXBwbHkodGhpcywgbmV3QXJncyk7XG4gICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3ZpZXdzL3V0aWxzLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cbi8vIEdldCB0aGUgd2luZG93IG9iamVjdCBmb3IgdGhlIGRvY3VtZW50IHRoYXQgYSBub2RlIGJlbG9uZ3MgdG8sXG4vLyBvciByZXR1cm4gbnVsbCBpZiBpdCBjYW5ub3QgYmUgZm91bmQgKG5vZGUgbm90IGF0dGFjaGVkIHRvIERPTSxcbi8vIGV0YykuXG5mdW5jdGlvbiBnZXRPd25lcldpbmRvdyhub2RlKSB7XG4gIGlmICghbm9kZS5vd25lckRvY3VtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xufSAvLyBHZXQgdGhlIGlmcmFtZSBjb250YWluaW5nIGEgbm9kZSwgb3IgcmV0dXJuIG51bGwgaWYgaXQgY2Fubm90XG4vLyBiZSBmb3VuZCAobm9kZSBub3Qgd2l0aGluIGlmcmFtZSwgZXRjKS5cblxuZnVuY3Rpb24gZ2V0T3duZXJJZnJhbWUobm9kZSkge1xuICB2YXIgbm9kZVdpbmRvdyA9IGdldE93bmVyV2luZG93KG5vZGUpO1xuXG4gIGlmIChub2RlV2luZG93KSB7XG4gICAgcmV0dXJuIG5vZGVXaW5kb3cuZnJhbWVFbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIEdldCBhIGJvdW5kaW5nIGNsaWVudCByZWN0IGZvciBhIG5vZGUsIHdpdGggYW5cbi8vIG9mZnNldCBhZGRlZCB0byBjb21wZW5zYXRlIGZvciBpdHMgYm9yZGVyLlxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3RXaXRoQm9yZGVyT2Zmc2V0KG5vZGUpIHtcbiAgdmFyIGRpbWVuc2lvbnMgPSBnZXRFbGVtZW50RGltZW5zaW9ucyhub2RlKTtcbiAgcmV0dXJuIG1lcmdlUmVjdE9mZnNldHMoW25vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHtcbiAgICB0b3A6IGRpbWVuc2lvbnMuYm9yZGVyVG9wLFxuICAgIGxlZnQ6IGRpbWVuc2lvbnMuYm9yZGVyTGVmdCxcbiAgICBib3R0b206IGRpbWVuc2lvbnMuYm9yZGVyQm90dG9tLFxuICAgIHJpZ2h0OiBkaW1lbnNpb25zLmJvcmRlclJpZ2h0LFxuICAgIC8vIFRoaXMgd2lkdGggYW5kIGhlaWdodCB3b24ndCBnZXQgdXNlZCBieSBtZXJnZVJlY3RPZmZzZXRzIChzaW5jZSB0aGlzXG4gICAgLy8gaXMgbm90IHRoZSBmaXJzdCByZWN0IGluIHRoZSBhcnJheSksIGJ1dCB3ZSBzZXQgdGhlbSBzbyB0aGF0IHRoaXNcbiAgICAvLyBvYmplY3QgdHlwZSBjaGVja3MgYXMgYSBDbGllbnRSZWN0LlxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9XSk7XG59IC8vIEFkZCB0b2dldGhlciB0aGUgdG9wLCBsZWZ0LCBib3R0b20sIGFuZCByaWdodCBwcm9wZXJ0aWVzIG9mXG4vLyBlYWNoIENsaWVudFJlY3QsIGJ1dCBrZWVwIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBmaXJzdCBvbmUuXG5cbmZ1bmN0aW9uIG1lcmdlUmVjdE9mZnNldHMocmVjdHMpIHtcbiAgcmV0dXJuIHJlY3RzLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXNSZWN0LCByZWN0KSB7XG4gICAgaWYgKHByZXZpb3VzUmVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBwcmV2aW91c1JlY3QudG9wICsgcmVjdC50b3AsXG4gICAgICBsZWZ0OiBwcmV2aW91c1JlY3QubGVmdCArIHJlY3QubGVmdCxcbiAgICAgIHdpZHRoOiBwcmV2aW91c1JlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQ6IHByZXZpb3VzUmVjdC5oZWlnaHQsXG4gICAgICBib3R0b206IHByZXZpb3VzUmVjdC5ib3R0b20gKyByZWN0LmJvdHRvbSxcbiAgICAgIHJpZ2h0OiBwcmV2aW91c1JlY3QucmlnaHQgKyByZWN0LnJpZ2h0XG4gICAgfTtcbiAgfSk7XG59IC8vIENhbGN1bGF0ZSBhIGJvdW5kaW5nQ2xpZW50UmVjdCBmb3IgYSBub2RlIHJlbGF0aXZlIHRvIGJvdW5kYXJ5V2luZG93LFxuLy8gdGFraW5nIGludG8gYWNjb3VudCBhbnkgb2Zmc2V0cyBjYXVzZWQgYnkgaW50ZXJtZWRpYXRlIGlmcmFtZXMuXG5cbmZ1bmN0aW9uIGdldE5lc3RlZEJvdW5kaW5nQ2xpZW50UmVjdChub2RlLCBib3VuZGFyeVdpbmRvdykge1xuICB2YXIgb3duZXJJZnJhbWUgPSBnZXRPd25lcklmcmFtZShub2RlKTtcblxuICBpZiAob3duZXJJZnJhbWUgJiYgb3duZXJJZnJhbWUgIT09IGJvdW5kYXJ5V2luZG93KSB7XG4gICAgdmFyIHJlY3RzID0gW25vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCldO1xuICAgIHZhciBjdXJyZW50SWZyYW1lID0gb3duZXJJZnJhbWU7XG4gICAgdmFyIG9ubHlPbmVNb3JlID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoY3VycmVudElmcmFtZSkge1xuICAgICAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3RXaXRoQm9yZGVyT2Zmc2V0KGN1cnJlbnRJZnJhbWUpO1xuICAgICAgcmVjdHMucHVzaChyZWN0KTtcbiAgICAgIGN1cnJlbnRJZnJhbWUgPSBnZXRPd25lcklmcmFtZShjdXJyZW50SWZyYW1lKTtcblxuICAgICAgaWYgKG9ubHlPbmVNb3JlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBXZSBkb24ndCB3YW50IHRvIGNhbGN1bGF0ZSBpZnJhbWUgb2Zmc2V0cyB1cHdhcmRzIGJleW9uZFxuICAgICAgLy8gdGhlIGlmcmFtZSBjb250YWluaW5nIHRoZSBib3VuZGFyeVdpbmRvdywgYnV0IHdlXG4gICAgICAvLyBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBib3VuZGFyeVdpbmRvdy5cblxuXG4gICAgICBpZiAoY3VycmVudElmcmFtZSAmJiBnZXRPd25lcldpbmRvdyhjdXJyZW50SWZyYW1lKSA9PT0gYm91bmRhcnlXaW5kb3cpIHtcbiAgICAgICAgb25seU9uZU1vcmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtZXJnZVJlY3RPZmZzZXRzKHJlY3RzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RWxlbWVudERpbWVuc2lvbnMoZG9tRWxlbWVudCkge1xuICB2YXIgY2FsY3VsYXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tRWxlbWVudCk7XG4gIHJldHVybiB7XG4gICAgYm9yZGVyTGVmdDogcGFyc2VJbnQoY2FsY3VsYXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aCwgMTApLFxuICAgIGJvcmRlclJpZ2h0OiBwYXJzZUludChjYWxjdWxhdGVkU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCwgMTApLFxuICAgIGJvcmRlclRvcDogcGFyc2VJbnQoY2FsY3VsYXRlZFN0eWxlLmJvcmRlclRvcFdpZHRoLCAxMCksXG4gICAgYm9yZGVyQm90dG9tOiBwYXJzZUludChjYWxjdWxhdGVkU3R5bGUuYm9yZGVyQm90dG9tV2lkdGgsIDEwKSxcbiAgICBtYXJnaW5MZWZ0OiBwYXJzZUludChjYWxjdWxhdGVkU3R5bGUubWFyZ2luTGVmdCwgMTApLFxuICAgIG1hcmdpblJpZ2h0OiBwYXJzZUludChjYWxjdWxhdGVkU3R5bGUubWFyZ2luUmlnaHQsIDEwKSxcbiAgICBtYXJnaW5Ub3A6IHBhcnNlSW50KGNhbGN1bGF0ZWRTdHlsZS5tYXJnaW5Ub3AsIDEwKSxcbiAgICBtYXJnaW5Cb3R0b206IHBhcnNlSW50KGNhbGN1bGF0ZWRTdHlsZS5tYXJnaW5Cb3R0b20sIDEwKSxcbiAgICBwYWRkaW5nTGVmdDogcGFyc2VJbnQoY2FsY3VsYXRlZFN0eWxlLnBhZGRpbmdMZWZ0LCAxMCksXG4gICAgcGFkZGluZ1JpZ2h0OiBwYXJzZUludChjYWxjdWxhdGVkU3R5bGUucGFkZGluZ1JpZ2h0LCAxMCksXG4gICAgcGFkZGluZ1RvcDogcGFyc2VJbnQoY2FsY3VsYXRlZFN0eWxlLnBhZGRpbmdUb3AsIDEwKSxcbiAgICBwYWRkaW5nQm90dG9tOiBwYXJzZUludChjYWxjdWxhdGVkU3R5bGUucGFkZGluZ0JvdHRvbSwgMTApXG4gIH07XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvdmlld3MvSGlnaGxpZ2h0ZXIvT3ZlcmxheS5qc1xuZnVuY3Rpb24gT3ZlcmxheV9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIE92ZXJsYXlfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIE92ZXJsYXlfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBPdmVybGF5X2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBPdmVybGF5X2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG52YXIgT3ZlcmxheV9hc3NpZ24gPSBPYmplY3QuYXNzaWduOyAvLyBOb3RlIHRoYXQgdGhlIE92ZXJsYXkgY29tcG9uZW50cyBhcmUgbm90IGFmZmVjdGVkIGJ5IHRoZSBhY3RpdmUgVGhlbWUsXG4vLyBiZWNhdXNlIHRoZXkgaGlnaGxpZ2h0IGVsZW1lbnRzIGluIHRoZSBtYWluIENocm9tZSB3aW5kb3cgKG91dHNpZGUgb2YgZGV2dG9vbHMpLlxuLy8gVGhlIGNvbG9ycyBiZWxvdyB3ZXJlIGNob3NlbiB0byByb3VnaGx5IG1hdGNoIHRob3NlIHVzZWQgYnkgQ2hyb21lIGRldnRvb2xzLlxuXG52YXIgT3ZlcmxheVJlY3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPdmVybGF5UmVjdChkb2MsIGNvbnRhaW5lcikge1xuICAgIE92ZXJsYXlfY2xhc3NDYWxsQ2hlY2sodGhpcywgT3ZlcmxheVJlY3QpO1xuXG4gICAgdGhpcy5ub2RlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuYm9yZGVyID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMucGFkZGluZyA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmNvbnRlbnQgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5ib3JkZXIuc3R5bGUuYm9yZGVyQ29sb3IgPSBvdmVybGF5U3R5bGVzLmJvcmRlcjtcbiAgICB0aGlzLnBhZGRpbmcuc3R5bGUuYm9yZGVyQ29sb3IgPSBvdmVybGF5U3R5bGVzLnBhZGRpbmc7XG4gICAgdGhpcy5jb250ZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG92ZXJsYXlTdHlsZXMuYmFja2dyb3VuZDtcbiAgICBPdmVybGF5X2Fzc2lnbih0aGlzLm5vZGUuc3R5bGUsIHtcbiAgICAgIGJvcmRlckNvbG9yOiBvdmVybGF5U3R5bGVzLm1hcmdpbixcbiAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnXG4gICAgfSk7XG4gICAgdGhpcy5ub2RlLnN0eWxlLnpJbmRleCA9ICcxMDAwMDAwMCc7XG4gICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMuYm9yZGVyKTtcbiAgICB0aGlzLmJvcmRlci5hcHBlbmRDaGlsZCh0aGlzLnBhZGRpbmcpO1xuICAgIHRoaXMucGFkZGluZy5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnQpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpO1xuICB9XG5cbiAgT3ZlcmxheV9jcmVhdGVDbGFzcyhPdmVybGF5UmVjdCwgW3tcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIGlmICh0aGlzLm5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGJveCwgZGltcykge1xuICAgICAgYm94V3JhcChkaW1zLCAnbWFyZ2luJywgdGhpcy5ub2RlKTtcbiAgICAgIGJveFdyYXAoZGltcywgJ2JvcmRlcicsIHRoaXMuYm9yZGVyKTtcbiAgICAgIGJveFdyYXAoZGltcywgJ3BhZGRpbmcnLCB0aGlzLnBhZGRpbmcpO1xuICAgICAgT3ZlcmxheV9hc3NpZ24odGhpcy5jb250ZW50LnN0eWxlLCB7XG4gICAgICAgIGhlaWdodDogYm94LmhlaWdodCAtIGRpbXMuYm9yZGVyVG9wIC0gZGltcy5ib3JkZXJCb3R0b20gLSBkaW1zLnBhZGRpbmdUb3AgLSBkaW1zLnBhZGRpbmdCb3R0b20gKyAncHgnLFxuICAgICAgICB3aWR0aDogYm94LndpZHRoIC0gZGltcy5ib3JkZXJMZWZ0IC0gZGltcy5ib3JkZXJSaWdodCAtIGRpbXMucGFkZGluZ0xlZnQgLSBkaW1zLnBhZGRpbmdSaWdodCArICdweCdcbiAgICAgIH0pO1xuICAgICAgT3ZlcmxheV9hc3NpZ24odGhpcy5ub2RlLnN0eWxlLCB7XG4gICAgICAgIHRvcDogYm94LnRvcCAtIGRpbXMubWFyZ2luVG9wICsgJ3B4JyxcbiAgICAgICAgbGVmdDogYm94LmxlZnQgLSBkaW1zLm1hcmdpbkxlZnQgKyAncHgnXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gT3ZlcmxheVJlY3Q7XG59KCk7XG5cbnZhciBPdmVybGF5VGlwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT3ZlcmxheVRpcChkb2MsIGNvbnRhaW5lcikge1xuICAgIE92ZXJsYXlfY2xhc3NDYWxsQ2hlY2sodGhpcywgT3ZlcmxheVRpcCk7XG5cbiAgICB0aGlzLnRpcCA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBPdmVybGF5X2Fzc2lnbih0aGlzLnRpcC5zdHlsZSwge1xuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgZmxleEZsb3c6ICdyb3cgbm93cmFwJyxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJyMzMzM3NDAnLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMnB4JyxcbiAgICAgIGZvbnRGYW1pbHk6ICdcIlNGTW9uby1SZWd1bGFyXCIsIENvbnNvbGFzLCBcIkxpYmVyYXRpb24gTW9ub1wiLCBNZW5sbywgQ291cmllciwgbW9ub3NwYWNlJyxcbiAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgIHBhZGRpbmc6ICczcHggNXB4JyxcbiAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgZm9udFNpemU6ICcxMnB4JyxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnXG4gICAgfSk7XG4gICAgdGhpcy5uYW1lU3BhbiA9IGRvYy5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgdGhpcy50aXAuYXBwZW5kQ2hpbGQodGhpcy5uYW1lU3Bhbik7XG4gICAgT3ZlcmxheV9hc3NpZ24odGhpcy5uYW1lU3Bhbi5zdHlsZSwge1xuICAgICAgY29sb3I6ICcjZWU3OGU2JyxcbiAgICAgIGJvcmRlclJpZ2h0OiAnMXB4IHNvbGlkICNhYWFhYWEnLFxuICAgICAgcGFkZGluZ1JpZ2h0OiAnMC41cmVtJyxcbiAgICAgIG1hcmdpblJpZ2h0OiAnMC41cmVtJ1xuICAgIH0pO1xuICAgIHRoaXMuZGltU3BhbiA9IGRvYy5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgdGhpcy50aXAuYXBwZW5kQ2hpbGQodGhpcy5kaW1TcGFuKTtcbiAgICBPdmVybGF5X2Fzc2lnbih0aGlzLmRpbVNwYW4uc3R5bGUsIHtcbiAgICAgIGNvbG9yOiAnI2Q3ZDdkNydcbiAgICB9KTtcbiAgICB0aGlzLnRpcC5zdHlsZS56SW5kZXggPSAnMTAwMDAwMDAnO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnRpcCk7XG4gIH1cblxuICBPdmVybGF5X2NyZWF0ZUNsYXNzKE92ZXJsYXlUaXAsIFt7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICBpZiAodGhpcy50aXAucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLnRpcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMudGlwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVUZXh0KG5hbWUsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMubmFtZVNwYW4udGV4dENvbnRlbnQgPSBuYW1lO1xuICAgICAgdGhpcy5kaW1TcGFuLnRleHRDb250ZW50ID0gTWF0aC5yb3VuZCh3aWR0aCkgKyAncHggw5cgJyArIE1hdGgucm91bmQoaGVpZ2h0KSArICdweCc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKGRpbXMsIGJvdW5kcykge1xuICAgICAgdmFyIHRpcFJlY3QgPSB0aGlzLnRpcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciB0aXBQb3MgPSBmaW5kVGlwUG9zKGRpbXMsIGJvdW5kcywge1xuICAgICAgICB3aWR0aDogdGlwUmVjdC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aXBSZWN0LmhlaWdodFxuICAgICAgfSk7XG4gICAgICBPdmVybGF5X2Fzc2lnbih0aGlzLnRpcC5zdHlsZSwgdGlwUG9zLnN0eWxlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gT3ZlcmxheVRpcDtcbn0oKTtcblxudmFyIE92ZXJsYXlfT3ZlcmxheSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE92ZXJsYXkoYWdlbnQpIHtcbiAgICBPdmVybGF5X2NsYXNzQ2FsbENoZWNrKHRoaXMsIE92ZXJsYXkpO1xuXG4gICAgLy8gRmluZCB0aGUgcm9vdCB3aW5kb3csIGJlY2F1c2Ugb3ZlcmxheXMgYXJlIHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gaXQuXG4gICAgdmFyIGN1cnJlbnRXaW5kb3cgPSB3aW5kb3cuX19SRUFDVF9ERVZUT09MU19UQVJHRVRfV0lORE9XX18gfHwgd2luZG93O1xuICAgIHRoaXMud2luZG93ID0gY3VycmVudFdpbmRvdzsgLy8gV2hlbiBvcGVuZWQgaW4gc2hlbGxzL2RldiwgdGhlIHRvb2x0aXAgc2hvdWxkIGJlIGJvdW5kIGJ5IHRoZSBhcHAgaWZyYW1lLCBub3QgYnkgdGhlIHRvcG1vc3Qgd2luZG93LlxuXG4gICAgdmFyIHRpcEJvdW5kc1dpbmRvdyA9IHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX1RBUkdFVF9XSU5ET1dfXyB8fCB3aW5kb3c7XG4gICAgdGhpcy50aXBCb3VuZHNXaW5kb3cgPSB0aXBCb3VuZHNXaW5kb3c7XG4gICAgdmFyIGRvYyA9IGN1cnJlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gICAgdGhpcy5jb250YWluZXIgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5jb250YWluZXIuc3R5bGUuekluZGV4ID0gJzEwMDAwMDAwJztcbiAgICB0aGlzLnRpcCA9IG5ldyBPdmVybGF5VGlwKGRvYywgdGhpcy5jb250YWluZXIpO1xuICAgIHRoaXMucmVjdHMgPSBbXTtcbiAgICB0aGlzLmFnZW50ID0gYWdlbnQ7XG4gICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5jb250YWluZXIpO1xuICB9XG5cbiAgT3ZlcmxheV9jcmVhdGVDbGFzcyhPdmVybGF5LCBbe1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgdGhpcy50aXAucmVtb3ZlKCk7XG4gICAgICB0aGlzLnJlY3RzLmZvckVhY2goZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgcmVjdC5yZW1vdmUoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yZWN0cy5sZW5ndGggPSAwO1xuXG4gICAgICBpZiAodGhpcy5jb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zcGVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNwZWN0KG5vZGVzLCBuYW1lKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAvLyBXZSBjYW4ndCBnZXQgdGhlIHNpemUgb2YgdGV4dCBub2RlcyBvciBjb21tZW50IG5vZGVzLiBSZWFjdCBhcyBvZiB2MTVcbiAgICAgIC8vIGhlYXZpbHkgdXNlcyBjb21tZW50IG5vZGVzIHRvIGRlbGltaXQgdGV4dC5cbiAgICAgIHZhciBlbGVtZW50cyA9IG5vZGVzLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7XG4gICAgICB9KTtcblxuICAgICAgd2hpbGUgKHRoaXMucmVjdHMubGVuZ3RoID4gZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5yZWN0cy5wb3AoKTtcbiAgICAgICAgcmVjdC5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0aGlzLnJlY3RzLmxlbmd0aCA8IGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnJlY3RzLnB1c2gobmV3IE92ZXJsYXlSZWN0KHRoaXMud2luZG93LmRvY3VtZW50LCB0aGlzLmNvbnRhaW5lcikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3V0ZXJCb3ggPSB7XG4gICAgICAgIHRvcDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICByaWdodDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuICAgICAgICBib3R0b206IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICAgICAgbGVmdDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgICB9O1xuICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGJveCA9IGdldE5lc3RlZEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBfdGhpcy53aW5kb3cpO1xuICAgICAgICB2YXIgZGltcyA9IGdldEVsZW1lbnREaW1lbnNpb25zKGVsZW1lbnQpO1xuICAgICAgICBvdXRlckJveC50b3AgPSBNYXRoLm1pbihvdXRlckJveC50b3AsIGJveC50b3AgLSBkaW1zLm1hcmdpblRvcCk7XG4gICAgICAgIG91dGVyQm94LnJpZ2h0ID0gTWF0aC5tYXgob3V0ZXJCb3gucmlnaHQsIGJveC5sZWZ0ICsgYm94LndpZHRoICsgZGltcy5tYXJnaW5SaWdodCk7XG4gICAgICAgIG91dGVyQm94LmJvdHRvbSA9IE1hdGgubWF4KG91dGVyQm94LmJvdHRvbSwgYm94LnRvcCArIGJveC5oZWlnaHQgKyBkaW1zLm1hcmdpbkJvdHRvbSk7XG4gICAgICAgIG91dGVyQm94LmxlZnQgPSBNYXRoLm1pbihvdXRlckJveC5sZWZ0LCBib3gubGVmdCAtIGRpbXMubWFyZ2luTGVmdCk7XG4gICAgICAgIHZhciByZWN0ID0gX3RoaXMucmVjdHNbaW5kZXhdO1xuICAgICAgICByZWN0LnVwZGF0ZShib3gsIGRpbXMpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghbmFtZSkge1xuICAgICAgICBuYW1lID0gZWxlbWVudHNbMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIG5vZGUgPSBlbGVtZW50c1swXTtcbiAgICAgICAgdmFyIHJlbmRlcmVySW50ZXJmYWNlID0gdGhpcy5hZ2VudC5nZXRCZXN0TWF0Y2hpbmdSZW5kZXJlckludGVyZmFjZShub2RlKTtcblxuICAgICAgICBpZiAocmVuZGVyZXJJbnRlcmZhY2UpIHtcbiAgICAgICAgICB2YXIgaWQgPSByZW5kZXJlckludGVyZmFjZS5nZXRGaWJlcklERm9yTmF0aXZlKG5vZGUsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICB2YXIgb3duZXJOYW1lID0gcmVuZGVyZXJJbnRlcmZhY2UuZ2V0RGlzcGxheU5hbWVGb3JGaWJlcklEKGlkLCB0cnVlKTtcblxuICAgICAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgICAgICBuYW1lICs9ICcgKGluICcgKyBvd25lck5hbWUgKyAnKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGlwLnVwZGF0ZVRleHQobmFtZSwgb3V0ZXJCb3gucmlnaHQgLSBvdXRlckJveC5sZWZ0LCBvdXRlckJveC5ib3R0b20gLSBvdXRlckJveC50b3ApO1xuICAgICAgdmFyIHRpcEJvdW5kcyA9IGdldE5lc3RlZEJvdW5kaW5nQ2xpZW50UmVjdCh0aGlzLnRpcEJvdW5kc1dpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMud2luZG93KTtcbiAgICAgIHRoaXMudGlwLnVwZGF0ZVBvc2l0aW9uKHtcbiAgICAgICAgdG9wOiBvdXRlckJveC50b3AsXG4gICAgICAgIGxlZnQ6IG91dGVyQm94LmxlZnQsXG4gICAgICAgIGhlaWdodDogb3V0ZXJCb3guYm90dG9tIC0gb3V0ZXJCb3gudG9wLFxuICAgICAgICB3aWR0aDogb3V0ZXJCb3gucmlnaHQgLSBvdXRlckJveC5sZWZ0XG4gICAgICB9LCB7XG4gICAgICAgIHRvcDogdGlwQm91bmRzLnRvcCArIHRoaXMudGlwQm91bmRzV2luZG93LnNjcm9sbFksXG4gICAgICAgIGxlZnQ6IHRpcEJvdW5kcy5sZWZ0ICsgdGhpcy50aXBCb3VuZHNXaW5kb3cuc2Nyb2xsWCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLnRpcEJvdW5kc1dpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgICAgd2lkdGg6IHRoaXMudGlwQm91bmRzV2luZG93LmlubmVyV2lkdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPdmVybGF5O1xufSgpO1xuXG5cblxuZnVuY3Rpb24gZmluZFRpcFBvcyhkaW1zLCBib3VuZHMsIHRpcFNpemUpIHtcbiAgdmFyIHRpcEhlaWdodCA9IE1hdGgubWF4KHRpcFNpemUuaGVpZ2h0LCAyMCk7XG4gIHZhciB0aXBXaWR0aCA9IE1hdGgubWF4KHRpcFNpemUud2lkdGgsIDYwKTtcbiAgdmFyIG1hcmdpbiA9IDU7XG4gIHZhciB0b3A7XG5cbiAgaWYgKGRpbXMudG9wICsgZGltcy5oZWlnaHQgKyB0aXBIZWlnaHQgPD0gYm91bmRzLnRvcCArIGJvdW5kcy5oZWlnaHQpIHtcbiAgICBpZiAoZGltcy50b3AgKyBkaW1zLmhlaWdodCA8IGJvdW5kcy50b3AgKyAwKSB7XG4gICAgICB0b3AgPSBib3VuZHMudG9wICsgbWFyZ2luO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3AgPSBkaW1zLnRvcCArIGRpbXMuaGVpZ2h0ICsgbWFyZ2luO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkaW1zLnRvcCAtIHRpcEhlaWdodCA8PSBib3VuZHMudG9wICsgYm91bmRzLmhlaWdodCkge1xuICAgIGlmIChkaW1zLnRvcCAtIHRpcEhlaWdodCAtIG1hcmdpbiA8IGJvdW5kcy50b3AgKyBtYXJnaW4pIHtcbiAgICAgIHRvcCA9IGJvdW5kcy50b3AgKyBtYXJnaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcCA9IGRpbXMudG9wIC0gdGlwSGVpZ2h0IC0gbWFyZ2luO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0b3AgPSBib3VuZHMudG9wICsgYm91bmRzLmhlaWdodCAtIHRpcEhlaWdodCAtIG1hcmdpbjtcbiAgfVxuXG4gIHZhciBsZWZ0ID0gZGltcy5sZWZ0ICsgbWFyZ2luO1xuXG4gIGlmIChkaW1zLmxlZnQgPCBib3VuZHMubGVmdCkge1xuICAgIGxlZnQgPSBib3VuZHMubGVmdCArIG1hcmdpbjtcbiAgfVxuXG4gIGlmIChkaW1zLmxlZnQgKyB0aXBXaWR0aCA+IGJvdW5kcy5sZWZ0ICsgYm91bmRzLndpZHRoKSB7XG4gICAgbGVmdCA9IGJvdW5kcy5sZWZ0ICsgYm91bmRzLndpZHRoIC0gdGlwV2lkdGggLSBtYXJnaW47XG4gIH1cblxuICB0b3AgKz0gJ3B4JztcbiAgbGVmdCArPSAncHgnO1xuICByZXR1cm4ge1xuICAgIHN0eWxlOiB7XG4gICAgICB0b3A6IHRvcCxcbiAgICAgIGxlZnQ6IGxlZnRcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGJveFdyYXAoZGltcywgd2hhdCwgbm9kZSkge1xuICBPdmVybGF5X2Fzc2lnbihub2RlLnN0eWxlLCB7XG4gICAgYm9yZGVyVG9wV2lkdGg6IGRpbXNbd2hhdCArICdUb3AnXSArICdweCcsXG4gICAgYm9yZGVyTGVmdFdpZHRoOiBkaW1zW3doYXQgKyAnTGVmdCddICsgJ3B4JyxcbiAgICBib3JkZXJSaWdodFdpZHRoOiBkaW1zW3doYXQgKyAnUmlnaHQnXSArICdweCcsXG4gICAgYm9yZGVyQm90dG9tV2lkdGg6IGRpbXNbd2hhdCArICdCb3R0b20nXSArICdweCcsXG4gICAgYm9yZGVyU3R5bGU6ICdzb2xpZCdcbiAgfSk7XG59XG5cbnZhciBvdmVybGF5U3R5bGVzID0ge1xuICBiYWNrZ3JvdW5kOiAncmdiYSgxMjAsIDE3MCwgMjEwLCAwLjcpJyxcbiAgcGFkZGluZzogJ3JnYmEoNzcsIDIwMCwgMCwgMC4zKScsXG4gIG1hcmdpbjogJ3JnYmEoMjU1LCAxNTUsIDAsIDAuMyknLFxuICBib3JkZXI6ICdyZ2JhKDI1NSwgMjAwLCA1MCwgMC4zKSdcbn07XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvdmlld3MvSGlnaGxpZ2h0ZXIvSGlnaGxpZ2h0ZXIuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG52YXIgU0hPV19EVVJBVElPTiA9IDIwMDA7XG52YXIgdGltZW91dElEID0gbnVsbDtcbnZhciBvdmVybGF5ID0gbnVsbDtcbmZ1bmN0aW9uIGhpZGVPdmVybGF5KGFnZW50KSB7XG4gIGlmICh3aW5kb3cuZG9jdW1lbnQgPT0gbnVsbCkge1xuICAgIGFnZW50LmVtaXQoJ2hpZGVOYXRpdmVIaWdobGlnaHQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aW1lb3V0SUQgPSBudWxsO1xuXG4gIGlmIChvdmVybGF5ICE9PSBudWxsKSB7XG4gICAgb3ZlcmxheS5yZW1vdmUoKTtcbiAgICBvdmVybGF5ID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gc2hvd092ZXJsYXkoZWxlbWVudHMsIGNvbXBvbmVudE5hbWUsIGFnZW50LCBoaWRlQWZ0ZXJUaW1lb3V0KSB7XG4gIGlmICh3aW5kb3cuZG9jdW1lbnQgPT0gbnVsbCkge1xuICAgIGlmIChlbGVtZW50cyAhPSBudWxsICYmIGVsZW1lbnRzWzBdICE9IG51bGwpIHtcbiAgICAgIGFnZW50LmVtaXQoJ3Nob3dOYXRpdmVIaWdobGlnaHQnLCBlbGVtZW50c1swXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRpbWVvdXRJRCAhPT0gbnVsbCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICB9XG5cbiAgaWYgKGVsZW1lbnRzID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAob3ZlcmxheSA9PT0gbnVsbCkge1xuICAgIG92ZXJsYXkgPSBuZXcgT3ZlcmxheV9PdmVybGF5KGFnZW50KTtcbiAgfVxuXG4gIG92ZXJsYXkuaW5zcGVjdChlbGVtZW50cywgY29tcG9uZW50TmFtZSk7XG5cbiAgaWYgKGhpZGVBZnRlclRpbWVvdXQpIHtcbiAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBoaWRlT3ZlcmxheShhZ2VudCk7XG4gICAgfSwgU0hPV19EVVJBVElPTik7XG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC92aWV3cy9IaWdobGlnaHRlci9pbmRleC5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cblxuXG5cbi8vIFRoaXMgcGx1Zy1pbiBwcm92aWRlcyBpbi1wYWdlIGhpZ2hsaWdodGluZyBvZiB0aGUgc2VsZWN0ZWQgZWxlbWVudC5cbi8vIEl0IGlzIHVzZWQgYnkgdGhlIGJyb3dzZXIgZXh0ZW5zaW9uIGFuZCB0aGUgc3RhbmRhbG9uZSBEZXZUb29scyBzaGVsbCAod2hlbiBjb25uZWN0ZWQgdG8gYSBicm93c2VyKS5cbi8vIEl0IGlzIG5vdCBjdXJyZW50bHkgdGhlIG1lY2hhbmlzbSB1c2VkIHRvIGhpZ2hsaWdodCBSZWFjdCBOYXRpdmUgdmlld3MuXG4vLyBUaGF0IGlzIGRvbmUgYnkgdGhlIFJlYWN0IE5hdGl2ZSBJbnNwZWN0b3IgY29tcG9uZW50LlxudmFyIGlmcmFtZXNMaXN0ZW5pbmdUbyA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIHNldHVwSGlnaGxpZ2h0ZXIoYnJpZGdlLCBhZ2VudCkge1xuICBicmlkZ2UuYWRkTGlzdGVuZXIoJ2NsZWFyTmF0aXZlRWxlbWVudEhpZ2hsaWdodCcsIGNsZWFyTmF0aXZlRWxlbWVudEhpZ2hsaWdodCk7XG4gIGJyaWRnZS5hZGRMaXN0ZW5lcignaGlnaGxpZ2h0TmF0aXZlRWxlbWVudCcsIGhpZ2hsaWdodE5hdGl2ZUVsZW1lbnQpO1xuICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3NodXRkb3duJywgc3RvcEluc3BlY3RpbmdOYXRpdmUpO1xuICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3N0YXJ0SW5zcGVjdGluZ05hdGl2ZScsIHN0YXJ0SW5zcGVjdGluZ05hdGl2ZSk7XG4gIGJyaWRnZS5hZGRMaXN0ZW5lcignc3RvcEluc3BlY3RpbmdOYXRpdmUnLCBzdG9wSW5zcGVjdGluZ05hdGl2ZSk7XG5cbiAgZnVuY3Rpb24gc3RhcnRJbnNwZWN0aW5nTmF0aXZlKCkge1xuICAgIHJlZ2lzdGVyTGlzdGVuZXJzT25XaW5kb3cod2luZG93KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzT25XaW5kb3cod2luZG93KSB7XG4gICAgLy8gVGhpcyBwbHVnLWluIG1heSBydW4gaW4gbm9uLURPTSBlbnZpcm9ubWVudHMgKGUuZy4gUmVhY3QgTmF0aXZlKS5cbiAgICBpZiAod2luZG93ICYmIHR5cGVvZiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DbGljaywgdHJ1ZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Nb3VzZUV2ZW50LCB0cnVlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBvbk1vdXNlRXZlbnQsIHRydWUpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlRXZlbnQsIHRydWUpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgb25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm92ZXInLCBvblBvaW50ZXJPdmVyLCB0cnVlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBvblBvaW50ZXJVcCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFnZW50LmVtaXQoJ3N0YXJ0SW5zcGVjdGluZ05hdGl2ZScpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0b3BJbnNwZWN0aW5nTmF0aXZlKCkge1xuICAgIGhpZGVPdmVybGF5KGFnZW50KTtcbiAgICByZW1vdmVMaXN0ZW5lcnNPbldpbmRvdyh3aW5kb3cpO1xuICAgIGlmcmFtZXNMaXN0ZW5pbmdUby5mb3JFYWNoKGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXJzT25XaW5kb3coZnJhbWUuY29udGVudFdpbmRvdyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikgey8vIFRoaXMgY2FuIGVycm9yIHdoZW4gdGhlIGlmcmFtZSBpcyBvbiBhIGNyb3NzLW9yaWdpbi5cbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZnJhbWVzTGlzdGVuaW5nVG8gPSBuZXcgU2V0KCk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnNPbldpbmRvdyh3aW5kb3cpIHtcbiAgICAvLyBUaGlzIHBsdWctaW4gbWF5IHJ1biBpbiBub24tRE9NIGVudmlyb25tZW50cyAoZS5nLiBSZWFjdCBOYXRpdmUpLlxuICAgIGlmICh3aW5kb3cgJiYgdHlwZW9mIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkNsaWNrLCB0cnVlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbk1vdXNlRXZlbnQsIHRydWUpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIG9uTW91c2VFdmVudCwgdHJ1ZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VFdmVudCwgdHJ1ZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBvblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyb3ZlcicsIG9uUG9pbnRlck92ZXIsIHRydWUpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIG9uUG9pbnRlclVwLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWdlbnQuZW1pdCgnc3RvcEluc3BlY3RpbmdOYXRpdmUnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhck5hdGl2ZUVsZW1lbnRIaWdobGlnaHQoKSB7XG4gICAgaGlkZU92ZXJsYXkoYWdlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0TmF0aXZlRWxlbWVudChfcmVmKSB7XG4gICAgdmFyIGRpc3BsYXlOYW1lID0gX3JlZi5kaXNwbGF5TmFtZSxcbiAgICAgICAgaGlkZUFmdGVyVGltZW91dCA9IF9yZWYuaGlkZUFmdGVyVGltZW91dCxcbiAgICAgICAgaWQgPSBfcmVmLmlkLFxuICAgICAgICBvcGVuTmF0aXZlRWxlbWVudHNQYW5lbCA9IF9yZWYub3Blbk5hdGl2ZUVsZW1lbnRzUGFuZWwsXG4gICAgICAgIHJlbmRlcmVySUQgPSBfcmVmLnJlbmRlcmVySUQsXG4gICAgICAgIHNjcm9sbEludG9WaWV3ID0gX3JlZi5zY3JvbGxJbnRvVmlldztcbiAgICB2YXIgcmVuZGVyZXIgPSBhZ2VudC5yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG5cbiAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCByZW5kZXJlciBpZCBcXFwiXCIuY29uY2F0KHJlbmRlcmVySUQsIFwiXFxcIiBmb3IgZWxlbWVudCBcXFwiXCIpLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZXMgPSBudWxsO1xuXG4gICAgaWYgKHJlbmRlcmVyICE9IG51bGwpIHtcbiAgICAgIG5vZGVzID0gcmVuZGVyZXIuZmluZE5hdGl2ZU5vZGVzRm9yRmliZXJJRChpZCk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGVzICE9IG51bGwgJiYgbm9kZXNbMF0gIT0gbnVsbCkge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1swXTsgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuXG4gICAgICBpZiAoc2Nyb2xsSW50b1ZpZXcgJiYgdHlwZW9mIG5vZGUuc2Nyb2xsSW50b1ZpZXcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gSWYgdGhlIG5vZGUgaXNuJ3QgdmlzaWJsZSBzaG93IGl0IGJlZm9yZSBoaWdobGlnaHRpbmcgaXQuXG4gICAgICAgIC8vIFdlIG1heSB3YW50IHRvIHJlY29uc2lkZXIgdGhpczsgaXQgbWlnaHQgYmUgYSBsaXR0bGUgZGlzcnVwdGl2ZS5cbiAgICAgICAgbm9kZS5zY3JvbGxJbnRvVmlldyh7XG4gICAgICAgICAgYmxvY2s6ICduZWFyZXN0JyxcbiAgICAgICAgICBpbmxpbmU6ICduZWFyZXN0J1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc2hvd092ZXJsYXkobm9kZXMsIGRpc3BsYXlOYW1lLCBhZ2VudCwgaGlkZUFmdGVyVGltZW91dCk7XG5cbiAgICAgIGlmIChvcGVuTmF0aXZlRWxlbWVudHNQYW5lbCkge1xuICAgICAgICB3aW5kb3cuX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLiQwID0gbm9kZTtcbiAgICAgICAgYnJpZGdlLnNlbmQoJ3N5bmNTZWxlY3Rpb25Ub05hdGl2ZUVsZW1lbnRzUGFuZWwnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaGlkZU92ZXJsYXkoYWdlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHN0b3BJbnNwZWN0aW5nTmF0aXZlKCk7XG4gICAgYnJpZGdlLnNlbmQoJ3N0b3BJbnNwZWN0aW5nTmF0aXZlJywgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbk1vdXNlRXZlbnQoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Qb2ludGVyRG93bihldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgc2VsZWN0RmliZXJGb3JOb2RlKGV2ZW50LnRhcmdldCk7XG4gIH1cblxuICBmdW5jdGlvbiBvblBvaW50ZXJPdmVyKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgaWYgKHRhcmdldC50YWdOYW1lID09PSAnSUZSQU1FJykge1xuICAgICAgdmFyIGlmcmFtZSA9IHRhcmdldDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFpZnJhbWVzTGlzdGVuaW5nVG8uaGFzKGlmcmFtZSkpIHtcbiAgICAgICAgICB2YXIgX3dpbmRvdyA9IGlmcmFtZS5jb250ZW50V2luZG93O1xuICAgICAgICAgIHJlZ2lzdGVyTGlzdGVuZXJzT25XaW5kb3coX3dpbmRvdyk7XG4gICAgICAgICAgaWZyYW1lc0xpc3RlbmluZ1RvLmFkZChpZnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikgey8vIFRoaXMgY2FuIGVycm9yIHdoZW4gdGhlIGlmcmFtZSBpcyBvbiBhIGNyb3NzLW9yaWdpbi5cbiAgICAgIH1cbiAgICB9IC8vIERvbid0IHBhc3MgdGhlIG5hbWUgZXhwbGljaXRseS5cbiAgICAvLyBJdCB3aWxsIGJlIGluZmVycmVkIGZyb20gRE9NIHRhZyBhbmQgRmliZXIgb3duZXIuXG5cblxuICAgIHNob3dPdmVybGF5KFt0YXJnZXRdLCBudWxsLCBhZ2VudCwgZmFsc2UpO1xuICAgIHNlbGVjdEZpYmVyRm9yTm9kZSh0YXJnZXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Qb2ludGVyVXAoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgdmFyIHNlbGVjdEZpYmVyRm9yTm9kZSA9IGxvZGFzaF90aHJvdHRsZV9kZWZhdWx0KCkoZXNtKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIGlkID0gYWdlbnQuZ2V0SURGb3JOb2RlKG5vZGUpO1xuXG4gICAgaWYgKGlkICE9PSBudWxsKSB7XG4gICAgICBicmlkZ2Uuc2VuZCgnc2VsZWN0RmliZXInLCBpZCk7XG4gICAgfVxuICB9KSwgMjAwLCAvLyBEb24ndCBjaGFuZ2UgdGhlIHNlbGVjdGlvbiBpbiB0aGUgdmVyeSBmaXJzdCAyMDBtc1xuICAvLyBiZWNhdXNlIHRob3NlIGFyZSB1c3VhbGx5IHVuaW50ZW50aW9uYWwgYXMgeW91IGxpZnQgdGhlIGN1cnNvci5cbiAge1xuICAgIGxlYWRpbmc6IGZhbHNlXG4gIH0pO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3ZpZXdzL1RyYWNlVXBkYXRlcy9jYW52YXMuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xudmFyIE9VVExJTkVfQ09MT1IgPSAnI2YwZjBmMCc7IC8vIE5vdGUgdGhlc2UgY29sb3JzIGFyZSBpbiBzeW5jIHdpdGggRGV2VG9vbHMgUHJvZmlsZXIgY2hhcnQgY29sb3JzLlxuXG52YXIgQ09MT1JTID0gWycjMzdhZmE5JywgJyM2M2IxOWUnLCAnIzgwYjM5MycsICcjOTdiNDg4JywgJyNhYmI2N2QnLCAnI2JlYjc3MScsICcjY2ZiOTY1JywgJyNkZmJhNTcnLCAnI2VmYmI0OScsICcjZmViYzM4J107XG52YXIgY2FudmFzID0gbnVsbDtcbmZ1bmN0aW9uIGRyYXcobm9kZVRvRGF0YSwgYWdlbnQpIHtcbiAgaWYgKHdpbmRvdy5kb2N1bWVudCA9PSBudWxsKSB7XG4gICAgdmFyIG5vZGVzVG9EcmF3ID0gW107XG4gICAgaXRlcmF0ZU5vZGVzKG5vZGVUb0RhdGEsIGZ1bmN0aW9uIChfLCBjb2xvciwgbm9kZSkge1xuICAgICAgbm9kZXNUb0RyYXcucHVzaCh7XG4gICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgYWdlbnQuZW1pdCgnZHJhd1RyYWNlVXBkYXRlcycsIG5vZGVzVG9EcmF3KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY2FudmFzID09PSBudWxsKSB7XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgdmFyIGNhbnZhc0Zsb3cgPSBjYW52YXM7XG4gIGNhbnZhc0Zsb3cud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgY2FudmFzRmxvdy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gIHZhciBjb250ZXh0ID0gY2FudmFzRmxvdy5nZXRDb250ZXh0KCcyZCcpO1xuICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjYW52YXNGbG93LndpZHRoLCBjYW52YXNGbG93LmhlaWdodCk7XG4gIGl0ZXJhdGVOb2Rlcyhub2RlVG9EYXRhLCBmdW5jdGlvbiAocmVjdCwgY29sb3IpIHtcbiAgICBpZiAocmVjdCAhPT0gbnVsbCkge1xuICAgICAgZHJhd0JvcmRlcihjb250ZXh0LCByZWN0LCBjb2xvcik7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaXRlcmF0ZU5vZGVzKG5vZGVUb0RhdGEsIGV4ZWN1dGUpIHtcbiAgbm9kZVRvRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmLCBub2RlKSB7XG4gICAgdmFyIGNvdW50ID0gX3JlZi5jb3VudCxcbiAgICAgICAgcmVjdCA9IF9yZWYucmVjdDtcbiAgICB2YXIgY29sb3JJbmRleCA9IE1hdGgubWluKENPTE9SUy5sZW5ndGggLSAxLCBjb3VudCAtIDEpO1xuICAgIHZhciBjb2xvciA9IENPTE9SU1tjb2xvckluZGV4XTtcbiAgICBleGVjdXRlKHJlY3QsIGNvbG9yLCBub2RlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRyYXdCb3JkZXIoY29udGV4dCwgcmVjdCwgY29sb3IpIHtcbiAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0LFxuICAgICAgbGVmdCA9IHJlY3QubGVmdCxcbiAgICAgIHRvcCA9IHJlY3QudG9wLFxuICAgICAgd2lkdGggPSByZWN0LndpZHRoOyAvLyBvdXRsaW5lXG5cbiAgY29udGV4dC5saW5lV2lkdGggPSAxO1xuICBjb250ZXh0LnN0cm9rZVN0eWxlID0gT1VUTElORV9DT0xPUjtcbiAgY29udGV4dC5zdHJva2VSZWN0KGxlZnQgLSAxLCB0b3AgLSAxLCB3aWR0aCArIDIsIGhlaWdodCArIDIpOyAvLyBpbnNldFxuXG4gIGNvbnRleHQubGluZVdpZHRoID0gMTtcbiAgY29udGV4dC5zdHJva2VTdHlsZSA9IE9VVExJTkVfQ09MT1I7XG4gIGNvbnRleHQuc3Ryb2tlUmVjdChsZWZ0ICsgMSwgdG9wICsgMSwgd2lkdGggLSAxLCBoZWlnaHQgLSAxKTtcbiAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICBjb250ZXh0LnNldExpbmVEYXNoKFswXSk7IC8vIGJvcmRlclxuXG4gIGNvbnRleHQubGluZVdpZHRoID0gMTtcbiAgY29udGV4dC5zdHJva2VSZWN0KGxlZnQsIHRvcCwgd2lkdGggLSAxLCBoZWlnaHQgLSAxKTtcbiAgY29udGV4dC5zZXRMaW5lRGFzaChbMF0pO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95KGFnZW50KSB7XG4gIGlmICh3aW5kb3cuZG9jdW1lbnQgPT0gbnVsbCkge1xuICAgIGFnZW50LmVtaXQoJ2Rpc2FibGVUcmFjZVVwZGF0ZXMnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY2FudmFzICE9PSBudWxsKSB7XG4gICAgaWYgKGNhbnZhcy5wYXJlbnROb2RlICE9IG51bGwpIHtcbiAgICAgIGNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNhbnZhcyk7XG4gICAgfVxuXG4gICAgY2FudmFzID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICBjYW52YXMgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIGNhbnZhcy5zdHlsZS5jc3NUZXh0ID0gXCJcXG4gICAgeHgtYmFja2dyb3VuZC1jb2xvcjogcmVkO1xcbiAgICB4eC1vcGFjaXR5OiAwLjU7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIHRvcDogMDtcXG4gICAgei1pbmRleDogMTAwMDAwMDAwMDtcXG4gIFwiO1xuICB2YXIgcm9vdCA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHJvb3QuaW5zZXJ0QmVmb3JlKGNhbnZhcywgcm9vdC5maXJzdENoaWxkKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC92aWV3cy9UcmFjZVVwZGF0ZXMvaW5kZXguanNcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cblxuXG4vLyBIb3cgbG9uZyB0aGUgcmVjdCBzaG91bGQgYmUgc2hvd24gZm9yP1xudmFyIERJU1BMQVlfRFVSQVRJT04gPSAyNTA7IC8vIFdoYXQncyB0aGUgbG9uZ2VzdCB3ZSBhcmUgd2lsbGluZyB0byBzaG93IHRoZSBvdmVybGF5IGZvcj9cbi8vIFRoaXMgY2FuIGJlIGltcG9ydGFudCBpZiB3ZSdyZSBnZXR0aW5nIGEgZmx1cnJ5IG9mIGV2ZW50cyAoZS5nLiBzY3JvbGwgdXBkYXRlKS5cblxudmFyIE1BWF9ESVNQTEFZX0RVUkFUSU9OID0gMzAwMDsgLy8gSG93IGxvbmcgc2hvdWxkIGEgcmVjdCBiZSBjb25zaWRlcmVkIHZhbGlkIGZvcj9cblxudmFyIFJFTUVBU1VSRU1FTlRfQUZURVJfRFVSQVRJT04gPSAyNTA7IC8vIFNvbWUgZW52aXJvbm1lbnRzIChlLmcuIFJlYWN0IE5hdGl2ZSAvIEhlcm1lcykgZG9uJ3Qgc3VwcG9ydCB0aGUgcGVyZm9ybWFuY2UgQVBJIHlldC5cblxudmFyIGdldEN1cnJlbnRUaW1lID0gLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuKHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHBlcmZvcm1hbmNlKSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbicgPyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbn0gOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBEYXRlLm5vdygpO1xufTtcbnZhciBub2RlVG9EYXRhID0gbmV3IE1hcCgpO1xudmFyIFRyYWNlVXBkYXRlc19hZ2VudCA9IG51bGw7XG52YXIgZHJhd0FuaW1hdGlvbkZyYW1lSUQgPSBudWxsO1xudmFyIGlzRW5hYmxlZCA9IGZhbHNlO1xudmFyIHJlZHJhd1RpbWVvdXRJRCA9IG51bGw7XG5mdW5jdGlvbiBUcmFjZVVwZGF0ZXNfaW5pdGlhbGl6ZShpbmplY3RlZEFnZW50KSB7XG4gIFRyYWNlVXBkYXRlc19hZ2VudCA9IGluamVjdGVkQWdlbnQ7XG4gIFRyYWNlVXBkYXRlc19hZ2VudC5hZGRMaXN0ZW5lcigndHJhY2VVcGRhdGVzJywgdHJhY2VVcGRhdGVzKTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZUVuYWJsZWQodmFsdWUpIHtcbiAgaXNFbmFibGVkID0gdmFsdWU7XG5cbiAgaWYgKCFpc0VuYWJsZWQpIHtcbiAgICBub2RlVG9EYXRhLmNsZWFyKCk7XG5cbiAgICBpZiAoZHJhd0FuaW1hdGlvbkZyYW1lSUQgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGRyYXdBbmltYXRpb25GcmFtZUlEKTtcbiAgICAgIGRyYXdBbmltYXRpb25GcmFtZUlEID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAocmVkcmF3VGltZW91dElEICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQocmVkcmF3VGltZW91dElEKTtcbiAgICAgIHJlZHJhd1RpbWVvdXRJRCA9IG51bGw7XG4gICAgfVxuXG4gICAgZGVzdHJveShUcmFjZVVwZGF0ZXNfYWdlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyYWNlVXBkYXRlcyhub2Rlcykge1xuICBpZiAoIWlzRW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgZGF0YSA9IG5vZGVUb0RhdGEuZ2V0KG5vZGUpO1xuICAgIHZhciBub3cgPSBnZXRDdXJyZW50VGltZSgpO1xuICAgIHZhciBsYXN0TWVhc3VyZWRBdCA9IGRhdGEgIT0gbnVsbCA/IGRhdGEubGFzdE1lYXN1cmVkQXQgOiAwO1xuICAgIHZhciByZWN0ID0gZGF0YSAhPSBudWxsID8gZGF0YS5yZWN0IDogbnVsbDtcblxuICAgIGlmIChyZWN0ID09PSBudWxsIHx8IGxhc3RNZWFzdXJlZEF0ICsgUkVNRUFTVVJFTUVOVF9BRlRFUl9EVVJBVElPTiA8IG5vdykge1xuICAgICAgbGFzdE1lYXN1cmVkQXQgPSBub3c7XG4gICAgICByZWN0ID0gbWVhc3VyZU5vZGUobm9kZSk7XG4gICAgfVxuXG4gICAgbm9kZVRvRGF0YS5zZXQobm9kZSwge1xuICAgICAgY291bnQ6IGRhdGEgIT0gbnVsbCA/IGRhdGEuY291bnQgKyAxIDogMSxcbiAgICAgIGV4cGlyYXRpb25UaW1lOiBkYXRhICE9IG51bGwgPyBNYXRoLm1pbihub3cgKyBNQVhfRElTUExBWV9EVVJBVElPTiwgZGF0YS5leHBpcmF0aW9uVGltZSArIERJU1BMQVlfRFVSQVRJT04pIDogbm93ICsgRElTUExBWV9EVVJBVElPTixcbiAgICAgIGxhc3RNZWFzdXJlZEF0OiBsYXN0TWVhc3VyZWRBdCxcbiAgICAgIHJlY3Q6IHJlY3RcbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKHJlZHJhd1RpbWVvdXRJRCAhPT0gbnVsbCkge1xuICAgIGNsZWFyVGltZW91dChyZWRyYXdUaW1lb3V0SUQpO1xuICAgIHJlZHJhd1RpbWVvdXRJRCA9IG51bGw7XG4gIH1cblxuICBpZiAoZHJhd0FuaW1hdGlvbkZyYW1lSUQgPT09IG51bGwpIHtcbiAgICBkcmF3QW5pbWF0aW9uRnJhbWVJRCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShwcmVwYXJlVG9EcmF3KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9EcmF3KCkge1xuICBkcmF3QW5pbWF0aW9uRnJhbWVJRCA9IG51bGw7XG4gIHJlZHJhd1RpbWVvdXRJRCA9IG51bGw7XG4gIHZhciBub3cgPSBnZXRDdXJyZW50VGltZSgpO1xuICB2YXIgZWFybGllc3RFeHBpcmF0aW9uID0gTnVtYmVyLk1BWF9WQUxVRTsgLy8gUmVtb3ZlIGFueSBpdGVtcyB0aGF0IGhhdmUgYWxyZWFkeSBleHBpcmVkLlxuXG4gIG5vZGVUb0RhdGEuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSwgbm9kZSkge1xuICAgIGlmIChkYXRhLmV4cGlyYXRpb25UaW1lIDwgbm93KSB7XG4gICAgICBub2RlVG9EYXRhLmRlbGV0ZShub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWFybGllc3RFeHBpcmF0aW9uID0gTWF0aC5taW4oZWFybGllc3RFeHBpcmF0aW9uLCBkYXRhLmV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH0pO1xuICBkcmF3KG5vZGVUb0RhdGEsIFRyYWNlVXBkYXRlc19hZ2VudCk7XG5cbiAgaWYgKGVhcmxpZXN0RXhwaXJhdGlvbiAhPT0gTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgIHJlZHJhd1RpbWVvdXRJRCA9IHNldFRpbWVvdXQocHJlcGFyZVRvRHJhdywgZWFybGllc3RFeHBpcmF0aW9uIC0gbm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtZWFzdXJlTm9kZShub2RlKSB7XG4gIGlmICghbm9kZSB8fCB0eXBlb2Ygbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBjdXJyZW50V2luZG93ID0gd2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfVEFSR0VUX1dJTkRPV19fIHx8IHdpbmRvdztcbiAgcmV0dXJuIGdldE5lc3RlZEJvdW5kaW5nQ2xpZW50UmVjdChub2RlLCBjdXJyZW50V2luZG93KTtcbn1cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2NvbnNvbGUuanNcbnZhciBiYWNrZW5kX2NvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JyaWRnZS5qc1xuZnVuY3Rpb24gYnJpZGdlX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgYnJpZGdlX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBicmlkZ2VfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIGJyaWRnZV90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIGJyaWRnZV9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIGJyaWRnZV9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gYnJpZGdlX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgYnJpZGdlX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBicmlkZ2VfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoYnJpZGdlX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIGJyaWRnZV9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG52YXIgQkFUQ0hfRFVSQVRJT04gPSAxMDA7IC8vIFRoaXMgbWVzc2FnZSBzcGVjaWZpZXMgdGhlIHZlcnNpb24gb2YgdGhlIERldlRvb2xzIHByb3RvY29sIGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgdGhlIGJhY2tlbmQsXG4vLyBhcyB3ZWxsIGFzIHRoZSBlYXJsaWVzdCBOUE0gdmVyc2lvbiAoZS5nLiBcIjQuMTMuMFwiKSB0aGF0IHByb3RvY29sIGlzIHN1cHBvcnRlZCBieSBvbiB0aGUgZnJvbnRlbmQuXG4vLyBUaGlzIGVuYWJsZXMgYW4gb2xkZXIgZnJvbnRlbmQgdG8gZGlzcGxheSBhbiB1cGdyYWRlIG1lc3NhZ2UgdG8gdXNlcnMgZm9yIGEgbmV3ZXIsIHVuc3VwcG9ydGVkIGJhY2tlbmQuXG5cbi8vIEJ1bXAgcHJvdG9jb2wgdmVyc2lvbiB3aGVuZXZlciBhIGJhY2t3YXJkcyBicmVha2luZyBjaGFuZ2UgaXMgbWFkZVxuLy8gaW4gdGhlIG1lc3NhZ2VzIHNlbnQgYmV0d2VlbiBCYWNrZW5kQnJpZGdlIGFuZCBGcm9udGVuZEJyaWRnZS5cbi8vIFRoaXMgbWFwcGluZyBpcyBlbWJlZGRlZCBpbiBib3RoIGZyb250ZW5kIGFuZCBiYWNrZW5kIGJ1aWxkcy5cbi8vXG4vLyBUaGUgYmFja2VuZCBwcm90b2NvbCB3aWxsIGFsd2F5cyBiZSB0aGUgbGF0ZXN0IGVudHJ5IGluIHRoZSBCUklER0VfUFJPVE9DT0wgYXJyYXkuXG4vL1xuLy8gV2hlbiBhbiBvbGRlciBmcm9udGVuZCBjb25uZWN0cyB0byBhIG5ld2VyIGJhY2tlbmQsXG4vLyB0aGUgYmFja2VuZCBjYW4gc2VuZCB0aGUgbWluTnBtVmVyc2lvbiBhbmQgdGhlIGZyb250ZW5kIGNhbiBkaXNwbGF5IGFuIE5QTSB1cGdyYWRlIHByb21wdC5cbi8vXG4vLyBXaGVuIGEgbmV3ZXIgZnJvbnRlbmQgY29ubmVjdHMgd2l0aCBhbiBvbGRlciBwcm90b2NvbCB2ZXJzaW9uLFxuLy8gdGhlIGZyb250ZW5kIGNhbiB1c2UgdGhlIGVtYmVkZGVkIG1pbk5wbVZlcnNpb24vbWF4TnBtVmVyc2lvbiB2YWx1ZXMgdG8gZGlzcGxheSBhIGRvd25ncmFkZSBwcm9tcHQuXG52YXIgQlJJREdFX1BST1RPQ09MID0gWy8vIFRoaXMgdmVyc2lvbiB0ZWNobmljYWxseSBuZXZlciBleGlzdGVkLFxuLy8gYnV0IGEgYmFja3dhcmRzIGJyZWFraW5nIGNoYW5nZSB3YXMgYWRkZWQgaW4gNC4xMSxcbi8vIHNvIHRoZSBzYWZlc3QgZ3Vlc3MgdG8gZG93bmdyYWRlIHRoZSBmcm9udGVuZCB3b3VsZCBiZSB0byB2ZXJzaW9uIDQuMTAuXG57XG4gIHZlcnNpb246IDAsXG4gIG1pbk5wbVZlcnNpb246ICdcIjw0LjExLjBcIicsXG4gIG1heE5wbVZlcnNpb246ICdcIjw0LjExLjBcIidcbn0sIC8vIFZlcnNpb25zIDQuMTEueCDigJMgNC4xMi54IGNvbnRhaW5lZCB0aGUgYmFja3dhcmRzIGJyZWFraW5nIGNoYW5nZSxcbi8vIGJ1dCB3ZSBkaWRuJ3QgYWRkIHRoZSBcImZpeFwiIG9mIGNoZWNraW5nIHRoZSBwcm90b2NvbCB2ZXJzaW9uIHVudGlsIDQuMTMsXG4vLyBzbyB3ZSBkb24ndCByZWNvbW1lbmQgZG93bmdyYWRpbmcgdG8gNC4xMSBvciA0LjEyLlxue1xuICB2ZXJzaW9uOiAxLFxuICBtaW5OcG1WZXJzaW9uOiAnNC4xMy4wJyxcbiAgbWF4TnBtVmVyc2lvbjogJzQuMjEuMCdcbn0sIC8vIFZlcnNpb24gMiBhZGRzIGEgU3RyaWN0TW9kZS1lbmFibGVkIGFuZCBzdXBwb3J0cy1TdHJpY3RNb2RlIGJpdHMgdG8gYWRkLXJvb3Qgb3BlcmF0aW9uLlxue1xuICB2ZXJzaW9uOiAyLFxuICBtaW5OcG1WZXJzaW9uOiAnNC4yMi4wJyxcbiAgbWF4TnBtVmVyc2lvbjogbnVsbFxufV07XG52YXIgY3VycmVudEJyaWRnZVByb3RvY29sID0gQlJJREdFX1BST1RPQ09MW0JSSURHRV9QUk9UT0NPTC5sZW5ndGggLSAxXTtcblxudmFyIEJyaWRnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICBfaW5oZXJpdHMoQnJpZGdlLCBfRXZlbnRFbWl0dGVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEJyaWRnZSk7XG5cbiAgZnVuY3Rpb24gQnJpZGdlKHdhbGwpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBicmlkZ2VfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnJpZGdlKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG5cbiAgICBicmlkZ2VfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX2lzU2h1dGRvd25cIiwgZmFsc2UpO1xuXG4gICAgYnJpZGdlX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9tZXNzYWdlUXVldWVcIiwgW10pO1xuXG4gICAgYnJpZGdlX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl90aW1lb3V0SURcIiwgbnVsbCk7XG5cbiAgICBicmlkZ2VfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX3dhbGxVbmxpc3RlblwiLCBudWxsKTtcblxuICAgIGJyaWRnZV9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfZmx1c2hcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVGhpcyBtZXRob2QgaXMgdXNlZCBhZnRlciB0aGUgYnJpZGdlIGlzIG1hcmtlZCBhcyBkZXN0cm95ZWQgaW4gc2h1dGRvd24gc2VxdWVuY2UsXG4gICAgICAvLyBzbyB3ZSBkbyBub3QgYmFpbCBvdXQgaWYgdGhlIGJyaWRnZSBtYXJrZWQgYXMgZGVzdHJveWVkLlxuICAgICAgLy8gSXQgaXMgYSBwcml2YXRlIG1ldGhvZCB0aGF0IHRoZSBicmlkZ2UgZW5zdXJlcyBpcyBvbmx5IGNhbGxlZCBhdCB0aGUgcmlnaHQgdGltZXMuXG4gICAgICBpZiAoX3RoaXMuX3RpbWVvdXRJRCAhPT0gbnVsbCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMuX3RpbWVvdXRJRCk7XG4gICAgICAgIF90aGlzLl90aW1lb3V0SUQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMuX21lc3NhZ2VRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5fbWVzc2FnZVF1ZXVlLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgdmFyIF90aGlzJF93YWxsO1xuXG4gICAgICAgICAgKF90aGlzJF93YWxsID0gX3RoaXMuX3dhbGwpLnNlbmQuYXBwbHkoX3RoaXMkX3dhbGwsIFtfdGhpcy5fbWVzc2FnZVF1ZXVlW2ldXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KF90aGlzLl9tZXNzYWdlUXVldWVbaSArIDFdKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuX21lc3NhZ2VRdWV1ZS5sZW5ndGggPSAwOyAvLyBDaGVjayBhZ2FpbiBmb3IgcXVldWVkIG1lc3NhZ2VzIGluIEJBVENIX0RVUkFUSU9OIG1zLiBUaGlzIHdpbGwga2VlcFxuICAgICAgICAvLyBmbHVzaGluZyBpbiBhIGxvb3AgYXMgbG9uZyBhcyBtZXNzYWdlcyBjb250aW51ZSB0byBiZSBhZGRlZC4gT25jZSBub1xuICAgICAgICAvLyBtb3JlIGFyZSwgdGhlIHRpbWVyIGV4cGlyZXMuXG5cbiAgICAgICAgX3RoaXMuX3RpbWVvdXRJRCA9IHNldFRpbWVvdXQoX3RoaXMuX2ZsdXNoLCBCQVRDSF9EVVJBVElPTik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBicmlkZ2VfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib3ZlcnJpZGVWYWx1ZUF0UGF0aFwiLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIGlkID0gX3JlZi5pZCxcbiAgICAgICAgICBwYXRoID0gX3JlZi5wYXRoLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmLnJlbmRlcmVySUQsXG4gICAgICAgICAgdHlwZSA9IF9yZWYudHlwZSxcbiAgICAgICAgICB2YWx1ZSA9IF9yZWYudmFsdWU7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdjb250ZXh0JzpcbiAgICAgICAgICBfdGhpcy5zZW5kKCdvdmVycmlkZUNvbnRleHQnLCB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgcmVuZGVyZXJJRDogcmVuZGVyZXJJRCxcbiAgICAgICAgICAgIHdhc0ZvcndhcmRlZDogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaG9va3MnOlxuICAgICAgICAgIF90aGlzLnNlbmQoJ292ZXJyaWRlSG9va1N0YXRlJywge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySUQsXG4gICAgICAgICAgICB3YXNGb3J3YXJkZWQ6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3Byb3BzJzpcbiAgICAgICAgICBfdGhpcy5zZW5kKCdvdmVycmlkZVByb3BzJywge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySUQsXG4gICAgICAgICAgICB3YXNGb3J3YXJkZWQ6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3N0YXRlJzpcbiAgICAgICAgICBfdGhpcy5zZW5kKCdvdmVycmlkZVN0YXRlJywge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySUQsXG4gICAgICAgICAgICB3YXNGb3J3YXJkZWQ6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX3RoaXMuX3dhbGwgPSB3YWxsO1xuICAgIF90aGlzLl93YWxsVW5saXN0ZW4gPSB3YWxsLmxpc3RlbihmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgaWYgKG1lc3NhZ2UgJiYgbWVzc2FnZS5ldmVudCkge1xuICAgICAgICBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKS5lbWl0KG1lc3NhZ2UuZXZlbnQsIG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICB9XG4gICAgfSkgfHwgbnVsbDsgLy8gVGVtcG9yYXJpbHkgc3VwcG9ydCBvbGRlciBzdGFuZGFsb25lIGZyb250LWVuZHMgc2VuZGluZyBjb21tYW5kcyB0byBuZXdlciBlbWJlZGRlZCBiYWNrZW5kcy5cbiAgICAvLyBXZSBkbyB0aGlzIGJlY2F1c2UgUmVhY3QgTmF0aXZlIGVtYmVkcyB0aGUgUmVhY3QgRGV2VG9vbHMgYmFja2VuZCxcbiAgICAvLyBidXQgY2Fubm90IGNvbnRyb2wgd2hpY2ggdmVyc2lvbiBvZiB0aGUgZnJvbnRlbmQgdXNlcnMgdXNlLlxuXG4gICAgX3RoaXMuYWRkTGlzdGVuZXIoJ292ZXJyaWRlVmFsdWVBdFBhdGgnLCBfdGhpcy5vdmVycmlkZVZhbHVlQXRQYXRoKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfSAvLyBMaXN0ZW5pbmcgZGlyZWN0bHkgdG8gdGhlIHdhbGwgaXNuJ3QgYWR2aXNlZC5cbiAgLy8gSXQgY2FuIGJlIHVzZWQgdG8gbGlzdGVuIGZvciBsZWdhY3kgKHYzKSBtZXNzYWdlcyAoc2luY2UgdGhleSB1c2UgYSBkaWZmZXJlbnQgZm9ybWF0KS5cblxuXG4gIGJyaWRnZV9jcmVhdGVDbGFzcyhCcmlkZ2UsIFt7XG4gICAga2V5OiBcInNlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZChldmVudCkge1xuICAgICAgaWYgKHRoaXMuX2lzU2h1dGRvd24pIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiQ2Fubm90IHNlbmQgbWVzc2FnZSBcXFwiXCIuY29uY2F0KGV2ZW50LCBcIlxcXCIgdGhyb3VnaCBhIEJyaWRnZSB0aGF0IGhhcyBiZWVuIHNodXRkb3duLlwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gV2hlbiB3ZSByZWNlaXZlIGEgbWVzc2FnZTpcbiAgICAgIC8vIC0gd2UgYWRkIGl0IHRvIG91ciBxdWV1ZSBvZiBtZXNzYWdlcyB0byBiZSBzZW50XG4gICAgICAvLyAtIGlmIHRoZXJlIGhhc24ndCBiZWVuIGEgbWVzc2FnZSByZWNlbnRseSwgd2Ugc2V0IGEgdGltZXIgZm9yIDAgbXMgaW5cbiAgICAgIC8vICAgdGhlIGZ1dHVyZSwgYWxsb3dpbmcgYWxsIG1lc3NhZ2VzIGNyZWF0ZWQgaW4gdGhlIHNhbWUgdGljayB0byBiZSBzZW50XG4gICAgICAvLyAgIHRvZ2V0aGVyXG4gICAgICAvLyAtIGlmIHRoZXJlICpoYXMqIGJlZW4gYSBtZXNzYWdlIGZsdXNoZWQgaW4gdGhlIGxhc3QgQkFUQ0hfRFVSQVRJT04gbXNcbiAgICAgIC8vICAgKG9yIHdlJ3JlIHdhaXRpbmcgZm9yIG91ciBzZXRUaW1lb3V0LTAgdG8gZmlyZSksIHRoZW4gX3RpbWVvdXRJRCB3aWxsXG4gICAgICAvLyAgIGJlIHNldCwgYW5kIHdlJ2xsIHNpbXBseSBhZGQgdG8gdGhlIHF1ZXVlIGFuZCB3YWl0IGZvciB0aGF0XG5cblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBheWxvYWQgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBwYXlsb2FkW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbWVzc2FnZVF1ZXVlLnB1c2goZXZlbnQsIHBheWxvYWQpO1xuXG4gICAgICBpZiAoIXRoaXMuX3RpbWVvdXRJRCkge1xuICAgICAgICB0aGlzLl90aW1lb3V0SUQgPSBzZXRUaW1lb3V0KHRoaXMuX2ZsdXNoLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2h1dGRvd25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2h1dGRvd24oKSB7XG4gICAgICBpZiAodGhpcy5faXNTaHV0ZG93bikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0JyaWRnZSB3YXMgYWxyZWFkeSBzaHV0ZG93bi4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBRdWV1ZSB0aGUgc2h1dGRvd24gb3V0Z29pbmcgbWVzc2FnZSBmb3Igc3Vic2NyaWJlcnMuXG5cblxuICAgICAgdGhpcy5zZW5kKCdzaHV0ZG93bicpOyAvLyBNYXJrIHRoaXMgYnJpZGdlIGFzIGRlc3Ryb3llZCwgaS5lLiBkaXNhYmxlIGl0cyBwdWJsaWMgQVBJLlxuXG4gICAgICB0aGlzLl9pc1NodXRkb3duID0gdHJ1ZTsgLy8gRGlzYWJsZSB0aGUgQVBJIGluaGVyaXRlZCBmcm9tIEV2ZW50RW1pdHRlciB0aGF0IGNhbiBhZGQgbW9yZSBsaXN0ZW5lcnMgYW5kIHNlbmQgbW9yZSBtZXNzYWdlcy5cbiAgICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBUaGlzIHByb3BlcnR5IGlzIG5vdCB3cml0YWJsZS5cblxuICAgICAgdGhpcy5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHt9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gVGhpcyBwcm9wZXJ0eSBpcyBub3Qgd3JpdGFibGUuXG5cblxuICAgICAgdGhpcy5lbWl0ID0gZnVuY3Rpb24gKCkge307IC8vIE5PVEU6IFRoZXJlJ3MgYWxzbyBFdmVudEVtaXR0ZXIgQVBJIGxpa2UgYG9uYCBhbmQgYHByZXBlbmRMaXN0ZW5lcmAgdGhhdCB3ZSBkaWRuJ3QgYWRkIHRvIG91ciBGbG93IHR5cGUgb2YgRXZlbnRFbWl0dGVyLlxuICAgICAgLy8gVW5zdWJzY3JpYmUgdGhpcyBicmlkZ2UgaW5jb21pbmcgbWVzc2FnZSBsaXN0ZW5lcnMgdG8gYmUgc3VyZSwgYW5kIHNvIHRoZXkgZG9uJ3QgaGF2ZSB0byBkbyB0aGF0LlxuXG5cbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7IC8vIFN0b3AgYWNjZXB0aW5nIGFuZCBlbWl0dGluZyBpbmNvbWluZyBtZXNzYWdlcyBmcm9tIHRoZSB3YWxsLlxuXG4gICAgICB2YXIgd2FsbFVubGlzdGVuID0gdGhpcy5fd2FsbFVubGlzdGVuO1xuXG4gICAgICBpZiAod2FsbFVubGlzdGVuKSB7XG4gICAgICAgIHdhbGxVbmxpc3RlbigpO1xuICAgICAgfSAvLyBTeW5jaHJvbm91c2x5IGZsdXNoIGFsbCBxdWV1ZWQgb3V0Z29pbmcgbWVzc2FnZXMuXG4gICAgICAvLyBBdCB0aGlzIHN0ZXAgdGhlIHN1YnNjcmliZXJzJyBjb2RlIG1heSBydW4gaW4gdGhpcyBjYWxsIHN0YWNrLlxuXG5cbiAgICAgIGRvIHtcbiAgICAgICAgdGhpcy5fZmx1c2goKTtcbiAgICAgIH0gd2hpbGUgKHRoaXMuX21lc3NhZ2VRdWV1ZS5sZW5ndGgpOyAvLyBNYWtlIHN1cmUgb25jZSBhZ2FpbiB0aGF0IHRoZXJlIGlzIG5vIGRhbmdsaW5nIHRpbWVyLlxuXG5cbiAgICAgIGlmICh0aGlzLl90aW1lb3V0SUQgIT09IG51bGwpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRJRCk7XG4gICAgICAgIHRoaXMuX3RpbWVvdXRJRCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndhbGxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93YWxsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCcmlkZ2U7XG59KEV2ZW50RW1pdHRlcik7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY19icmlkZ2UgPSAoQnJpZGdlKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3V0aWxzLmpzICsgMSBtb2R1bGVzXG52YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvYWdlbnQuanNcbmZ1bmN0aW9uIGFnZW50X3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgYWdlbnRfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IGFnZW50X3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBhZ2VudF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBhZ2VudF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIGFnZW50X2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBhZ2VudF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGFnZW50X2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBhZ2VudF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBhZ2VudF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBhZ2VudF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gYWdlbnRfc2V0UHJvdG90eXBlT2YobywgcCkgeyBhZ2VudF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gYWdlbnRfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gYWdlbnRfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGFnZW50X2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IGFnZW50X2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBhZ2VudF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gYWdlbnRfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIGFnZW50X3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoYWdlbnRfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gYWdlbnRfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIGFnZW50X2dldFByb3RvdHlwZU9mKG8pIHsgYWdlbnRfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gYWdlbnRfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gYWdlbnRfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGFnZW50X2RlYnVnID0gZnVuY3Rpb24gZGVidWcobWV0aG9kTmFtZSkge1xuICBpZiAoY29uc3RhbnRzW1wic1wiIC8qIF9fREVCVUdfXyAqL10pIHtcbiAgICB2YXIgX2NvbnNvbGU7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICAoX2NvbnNvbGUgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUsIFtcIiVjQWdlbnQgJWNcIi5jb25jYXQobWV0aG9kTmFtZSksICdjb2xvcjogcHVycGxlOyBmb250LXdlaWdodDogYm9sZDsnLCAnZm9udC13ZWlnaHQ6IGJvbGQ7J10uY29uY2F0KGFyZ3MpKTtcbiAgfVxufTtcblxudmFyIGFnZW50X0FnZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gIGFnZW50X2luaGVyaXRzKEFnZW50LCBfRXZlbnRFbWl0dGVyKTtcblxuICB2YXIgX3N1cGVyID0gYWdlbnRfY3JlYXRlU3VwZXIoQWdlbnQpO1xuXG4gIGZ1bmN0aW9uIEFnZW50KGJyaWRnZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGFnZW50X2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFnZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9pc1Byb2ZpbGluZ1wiLCBmYWxzZSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9yZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnNcIiwgZmFsc2UpO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfcmVuZGVyZXJJbnRlcmZhY2VzXCIsIHt9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX3BlcnNpc3RlZFNlbGVjdGlvblwiLCBudWxsKTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX3BlcnNpc3RlZFNlbGVjdGlvbk1hdGNoXCIsIG51bGwpO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfdHJhY2VVcGRhdGVzRW5hYmxlZFwiLCBmYWxzZSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImNsZWFyRXJyb3JzQW5kV2FybmluZ3NcIiwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciByZW5kZXJlcklEID0gX3JlZi5yZW5kZXJlcklEO1xuICAgICAgdmFyIHJlbmRlcmVyID0gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcblxuICAgICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCByZW5kZXJlciBpZCBcXFwiXCIuY29uY2F0KHJlbmRlcmVySUQsIFwiXFxcIlwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJlci5jbGVhckVycm9yc0FuZFdhcm5pbmdzKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImNsZWFyRXJyb3JzRm9yRmliZXJJRFwiLCBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgIHZhciBpZCA9IF9yZWYyLmlkLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmMi5yZW5kZXJlcklEO1xuICAgICAgdmFyIHJlbmRlcmVyID0gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcblxuICAgICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCByZW5kZXJlciBpZCBcXFwiXCIuY29uY2F0KHJlbmRlcmVySUQsIFwiXFxcIlwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJlci5jbGVhckVycm9yc0ZvckZpYmVySUQoaWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjbGVhcldhcm5pbmdzRm9yRmliZXJJRFwiLCBmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgIHZhciBpZCA9IF9yZWYzLmlkLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmMy5yZW5kZXJlcklEO1xuICAgICAgdmFyIHJlbmRlcmVyID0gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcblxuICAgICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCByZW5kZXJlciBpZCBcXFwiXCIuY29uY2F0KHJlbmRlcmVySUQsIFwiXFxcIlwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJlci5jbGVhcldhcm5pbmdzRm9yRmliZXJJRChpZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImNvcHlFbGVtZW50UGF0aFwiLCBmdW5jdGlvbiAoX3JlZjQpIHtcbiAgICAgIHZhciBpZCA9IF9yZWY0LmlkLFxuICAgICAgICAgIHBhdGggPSBfcmVmNC5wYXRoLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmNC5yZW5kZXJlcklEO1xuICAgICAgdmFyIHJlbmRlcmVyID0gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcblxuICAgICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCByZW5kZXJlciBpZCBcXFwiXCIuY29uY2F0KHJlbmRlcmVySUQsIFwiXFxcIiBmb3IgZWxlbWVudCBcXFwiXCIpLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlbmRlcmVyLmdldFNlcmlhbGl6ZWRFbGVtZW50VmFsdWVCeVBhdGgoaWQsIHBhdGgpO1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgX3RoaXMuX2JyaWRnZS5zZW5kKCdzYXZlVG9DbGlwYm9hcmQnLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiVW5hYmxlIHRvIG9idGFpbiBzZXJpYWxpemVkIHZhbHVlIGZvciBlbGVtZW50IFxcXCJcIi5jb25jYXQoaWQsIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiZGVsZXRlUGF0aFwiLCBmdW5jdGlvbiAoX3JlZjUpIHtcbiAgICAgIHZhciBob29rSUQgPSBfcmVmNS5ob29rSUQsXG4gICAgICAgICAgaWQgPSBfcmVmNS5pZCxcbiAgICAgICAgICBwYXRoID0gX3JlZjUucGF0aCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjUucmVuZGVyZXJJRCxcbiAgICAgICAgICB0eXBlID0gX3JlZjUudHlwZTtcbiAgICAgIHZhciByZW5kZXJlciA9IF90aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG5cbiAgICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgcmVuZGVyZXIgaWQgXFxcIlwiLmNvbmNhdChyZW5kZXJlcklELCBcIlxcXCIgZm9yIGVsZW1lbnQgXFxcIlwiKS5jb25jYXQoaWQsIFwiXFxcIlwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJlci5kZWxldGVQYXRoKHR5cGUsIGlkLCBob29rSUQsIHBhdGgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJnZXRCYWNrZW5kVmVyc2lvblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmVyc2lvbiA9IFwiNC4yNy42LTdmOGM1MDFmNlwiO1xuXG4gICAgICBpZiAodmVyc2lvbikge1xuICAgICAgICBfdGhpcy5fYnJpZGdlLnNlbmQoJ2JhY2tlbmRWZXJzaW9uJywgdmVyc2lvbik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImdldEJyaWRnZVByb3RvY29sXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLl9icmlkZ2Uuc2VuZCgnYnJpZGdlUHJvdG9jb2wnLCBjdXJyZW50QnJpZGdlUHJvdG9jb2wpO1xuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJnZXRQcm9maWxpbmdEYXRhXCIsIGZ1bmN0aW9uIChfcmVmNikge1xuICAgICAgdmFyIHJlbmRlcmVySUQgPSBfcmVmNi5yZW5kZXJlcklEO1xuICAgICAgdmFyIHJlbmRlcmVyID0gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcblxuICAgICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCByZW5kZXJlciBpZCBcXFwiXCIuY29uY2F0KHJlbmRlcmVySUQsIFwiXFxcIlwiKSk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLl9icmlkZ2Uuc2VuZCgncHJvZmlsaW5nRGF0YScsIHJlbmRlcmVyLmdldFByb2ZpbGluZ0RhdGEoKSk7XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImdldFByb2ZpbGluZ1N0YXR1c1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5fYnJpZGdlLnNlbmQoJ3Byb2ZpbGluZ1N0YXR1cycsIF90aGlzLl9pc1Byb2ZpbGluZyk7XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImdldE93bmVyc0xpc3RcIiwgZnVuY3Rpb24gKF9yZWY3KSB7XG4gICAgICB2YXIgaWQgPSBfcmVmNy5pZCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjcucmVuZGVyZXJJRDtcbiAgICAgIHZhciByZW5kZXJlciA9IF90aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG5cbiAgICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgcmVuZGVyZXIgaWQgXFxcIlwiLmNvbmNhdChyZW5kZXJlcklELCBcIlxcXCIgZm9yIGVsZW1lbnQgXFxcIlwiKS5jb25jYXQoaWQsIFwiXFxcIlwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3duZXJzID0gcmVuZGVyZXIuZ2V0T3duZXJzTGlzdChpZCk7XG5cbiAgICAgICAgX3RoaXMuX2JyaWRnZS5zZW5kKCdvd25lcnNMaXN0Jywge1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBvd25lcnM6IG93bmVyc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaW5zcGVjdEVsZW1lbnRcIiwgZnVuY3Rpb24gKF9yZWY4KSB7XG4gICAgICB2YXIgZm9yY2VGdWxsRGF0YSA9IF9yZWY4LmZvcmNlRnVsbERhdGEsXG4gICAgICAgICAgaWQgPSBfcmVmOC5pZCxcbiAgICAgICAgICBwYXRoID0gX3JlZjgucGF0aCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjgucmVuZGVyZXJJRCxcbiAgICAgICAgICByZXF1ZXN0SUQgPSBfcmVmOC5yZXF1ZXN0SUQ7XG4gICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuXG4gICAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHJlbmRlcmVyIGlkIFxcXCJcIi5jb25jYXQocmVuZGVyZXJJRCwgXCJcXFwiIGZvciBlbGVtZW50IFxcXCJcIikuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuX2JyaWRnZS5zZW5kKCdpbnNwZWN0ZWRFbGVtZW50JywgcmVuZGVyZXIuaW5zcGVjdEVsZW1lbnQocmVxdWVzdElELCBpZCwgcGF0aCwgZm9yY2VGdWxsRGF0YSkpOyAvLyBXaGVuIHVzZXIgc2VsZWN0cyBhbiBlbGVtZW50LCBzdG9wIHRyeWluZyB0byByZXN0b3JlIHRoZSBzZWxlY3Rpb24sXG4gICAgICAgIC8vIGFuZCBpbnN0ZWFkIHJlbWVtYmVyIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBmb3IgdGhlIG5leHQgcmVsb2FkLlxuXG5cbiAgICAgICAgaWYgKF90aGlzLl9wZXJzaXN0ZWRTZWxlY3Rpb25NYXRjaCA9PT0gbnVsbCB8fCBfdGhpcy5fcGVyc2lzdGVkU2VsZWN0aW9uTWF0Y2guaWQgIT09IGlkKSB7XG4gICAgICAgICAgX3RoaXMuX3BlcnNpc3RlZFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgX3RoaXMuX3BlcnNpc3RlZFNlbGVjdGlvbk1hdGNoID0gbnVsbDtcbiAgICAgICAgICByZW5kZXJlci5zZXRUcmFja2VkUGF0aChudWxsKTtcblxuICAgICAgICAgIF90aGlzLl90aHJvdHRsZWRQZXJzaXN0U2VsZWN0aW9uKHJlbmRlcmVySUQsIGlkKTtcbiAgICAgICAgfSAvLyBUT0RPOiBJZiB0aGVyZSB3YXMgYSB3YXkgdG8gY2hhbmdlIHRoZSBzZWxlY3RlZCBET00gZWxlbWVudFxuICAgICAgICAvLyBpbiBuYXRpdmUgRWxlbWVudHMgdGFiIHdpdGhvdXQgZm9yY2luZyBhIHN3aXRjaCB0byBpdCwgd2UnZCBkbyBpdCBoZXJlLlxuICAgICAgICAvLyBGb3Igbm93LCBpdCBkb2Vzbid0IHNlZW0gbGlrZSB0aGVyZSBpcyBhIHdheSB0byBkbyB0aGF0OlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYnZhdWdobi9yZWFjdC1kZXZ0b29scy1leHBlcmltZW50YWwvaXNzdWVzLzEwMlxuICAgICAgICAvLyAoU2V0dGluZyAkMCBkb2Vzbid0IHdvcmssIGFuZCBjYWxsaW5nIGluc3BlY3QoKSBzd2l0Y2hlcyB0aGUgdGFiLilcblxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJsb2dFbGVtZW50VG9Db25zb2xlXCIsIGZ1bmN0aW9uIChfcmVmOSkge1xuICAgICAgdmFyIGlkID0gX3JlZjkuaWQsXG4gICAgICAgICAgcmVuZGVyZXJJRCA9IF9yZWY5LnJlbmRlcmVySUQ7XG4gICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuXG4gICAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHJlbmRlcmVyIGlkIFxcXCJcIi5jb25jYXQocmVuZGVyZXJJRCwgXCJcXFwiIGZvciBlbGVtZW50IFxcXCJcIikuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIubG9nRWxlbWVudFRvQ29uc29sZShpZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm92ZXJyaWRlRXJyb3JcIiwgZnVuY3Rpb24gKF9yZWYxMCkge1xuICAgICAgdmFyIGlkID0gX3JlZjEwLmlkLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmMTAucmVuZGVyZXJJRCxcbiAgICAgICAgICBmb3JjZUVycm9yID0gX3JlZjEwLmZvcmNlRXJyb3I7XG4gICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuXG4gICAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHJlbmRlcmVyIGlkIFxcXCJcIi5jb25jYXQocmVuZGVyZXJJRCwgXCJcXFwiIGZvciBlbGVtZW50IFxcXCJcIikuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIub3ZlcnJpZGVFcnJvcihpZCwgZm9yY2VFcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm92ZXJyaWRlU3VzcGVuc2VcIiwgZnVuY3Rpb24gKF9yZWYxMSkge1xuICAgICAgdmFyIGlkID0gX3JlZjExLmlkLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmMTEucmVuZGVyZXJJRCxcbiAgICAgICAgICBmb3JjZUZhbGxiYWNrID0gX3JlZjExLmZvcmNlRmFsbGJhY2s7XG4gICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuXG4gICAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHJlbmRlcmVyIGlkIFxcXCJcIi5jb25jYXQocmVuZGVyZXJJRCwgXCJcXFwiIGZvciBlbGVtZW50IFxcXCJcIikuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIub3ZlcnJpZGVTdXNwZW5zZShpZCwgZm9yY2VGYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm92ZXJyaWRlVmFsdWVBdFBhdGhcIiwgZnVuY3Rpb24gKF9yZWYxMikge1xuICAgICAgdmFyIGhvb2tJRCA9IF9yZWYxMi5ob29rSUQsXG4gICAgICAgICAgaWQgPSBfcmVmMTIuaWQsXG4gICAgICAgICAgcGF0aCA9IF9yZWYxMi5wYXRoLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmMTIucmVuZGVyZXJJRCxcbiAgICAgICAgICB0eXBlID0gX3JlZjEyLnR5cGUsXG4gICAgICAgICAgdmFsdWUgPSBfcmVmMTIudmFsdWU7XG4gICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuXG4gICAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHJlbmRlcmVyIGlkIFxcXCJcIi5jb25jYXQocmVuZGVyZXJJRCwgXCJcXFwiIGZvciBlbGVtZW50IFxcXCJcIikuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIub3ZlcnJpZGVWYWx1ZUF0UGF0aCh0eXBlLCBpZCwgaG9va0lELCBwYXRoLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm92ZXJyaWRlQ29udGV4dFwiLCBmdW5jdGlvbiAoX3JlZjEzKSB7XG4gICAgICB2YXIgaWQgPSBfcmVmMTMuaWQsXG4gICAgICAgICAgcGF0aCA9IF9yZWYxMy5wYXRoLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmMTMucmVuZGVyZXJJRCxcbiAgICAgICAgICB3YXNGb3J3YXJkZWQgPSBfcmVmMTMud2FzRm9yd2FyZGVkLFxuICAgICAgICAgIHZhbHVlID0gX3JlZjEzLnZhbHVlO1xuXG4gICAgICAvLyBEb24ndCBmb3J3YXJkIGEgbWVzc2FnZSB0aGF0J3MgYWxyZWFkeSBiZWVuIGZvcndhcmRlZCBieSB0aGUgZnJvbnQtZW5kIEJyaWRnZS5cbiAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byBwcm9jZXNzIHRoZSBvdmVycmlkZSBjb21tYW5kIG9uY2UhXG4gICAgICBpZiAoIXdhc0ZvcndhcmRlZCkge1xuICAgICAgICBfdGhpcy5vdmVycmlkZVZhbHVlQXRQYXRoKHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICByZW5kZXJlcklEOiByZW5kZXJlcklELFxuICAgICAgICAgIHR5cGU6ICdjb250ZXh0JyxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm92ZXJyaWRlSG9va1N0YXRlXCIsIGZ1bmN0aW9uIChfcmVmMTQpIHtcbiAgICAgIHZhciBpZCA9IF9yZWYxNC5pZCxcbiAgICAgICAgICBob29rSUQgPSBfcmVmMTQuaG9va0lELFxuICAgICAgICAgIHBhdGggPSBfcmVmMTQucGF0aCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjE0LnJlbmRlcmVySUQsXG4gICAgICAgICAgd2FzRm9yd2FyZGVkID0gX3JlZjE0Lndhc0ZvcndhcmRlZCxcbiAgICAgICAgICB2YWx1ZSA9IF9yZWYxNC52YWx1ZTtcblxuICAgICAgLy8gRG9uJ3QgZm9yd2FyZCBhIG1lc3NhZ2UgdGhhdCdzIGFscmVhZHkgYmVlbiBmb3J3YXJkZWQgYnkgdGhlIGZyb250LWVuZCBCcmlkZ2UuXG4gICAgICAvLyBXZSBvbmx5IG5lZWQgdG8gcHJvY2VzcyB0aGUgb3ZlcnJpZGUgY29tbWFuZCBvbmNlIVxuICAgICAgaWYgKCF3YXNGb3J3YXJkZWQpIHtcbiAgICAgICAgX3RoaXMub3ZlcnJpZGVWYWx1ZUF0UGF0aCh7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgcmVuZGVyZXJJRDogcmVuZGVyZXJJRCxcbiAgICAgICAgICB0eXBlOiAnaG9va3MnLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib3ZlcnJpZGVQcm9wc1wiLCBmdW5jdGlvbiAoX3JlZjE1KSB7XG4gICAgICB2YXIgaWQgPSBfcmVmMTUuaWQsXG4gICAgICAgICAgcGF0aCA9IF9yZWYxNS5wYXRoLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmMTUucmVuZGVyZXJJRCxcbiAgICAgICAgICB3YXNGb3J3YXJkZWQgPSBfcmVmMTUud2FzRm9yd2FyZGVkLFxuICAgICAgICAgIHZhbHVlID0gX3JlZjE1LnZhbHVlO1xuXG4gICAgICAvLyBEb24ndCBmb3J3YXJkIGEgbWVzc2FnZSB0aGF0J3MgYWxyZWFkeSBiZWVuIGZvcndhcmRlZCBieSB0aGUgZnJvbnQtZW5kIEJyaWRnZS5cbiAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byBwcm9jZXNzIHRoZSBvdmVycmlkZSBjb21tYW5kIG9uY2UhXG4gICAgICBpZiAoIXdhc0ZvcndhcmRlZCkge1xuICAgICAgICBfdGhpcy5vdmVycmlkZVZhbHVlQXRQYXRoKHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICByZW5kZXJlcklEOiByZW5kZXJlcklELFxuICAgICAgICAgIHR5cGU6ICdwcm9wcycsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvdmVycmlkZVN0YXRlXCIsIGZ1bmN0aW9uIChfcmVmMTYpIHtcbiAgICAgIHZhciBpZCA9IF9yZWYxNi5pZCxcbiAgICAgICAgICBwYXRoID0gX3JlZjE2LnBhdGgsXG4gICAgICAgICAgcmVuZGVyZXJJRCA9IF9yZWYxNi5yZW5kZXJlcklELFxuICAgICAgICAgIHdhc0ZvcndhcmRlZCA9IF9yZWYxNi53YXNGb3J3YXJkZWQsXG4gICAgICAgICAgdmFsdWUgPSBfcmVmMTYudmFsdWU7XG5cbiAgICAgIC8vIERvbid0IGZvcndhcmQgYSBtZXNzYWdlIHRoYXQncyBhbHJlYWR5IGJlZW4gZm9yd2FyZGVkIGJ5IHRoZSBmcm9udC1lbmQgQnJpZGdlLlxuICAgICAgLy8gV2Ugb25seSBuZWVkIHRvIHByb2Nlc3MgdGhlIG92ZXJyaWRlIGNvbW1hbmQgb25jZSFcbiAgICAgIGlmICghd2FzRm9yd2FyZGVkKSB7XG4gICAgICAgIF90aGlzLm92ZXJyaWRlVmFsdWVBdFBhdGgoe1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySUQsXG4gICAgICAgICAgdHlwZTogJ3N0YXRlJyxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInJlbG9hZEFuZFByb2ZpbGVcIiwgZnVuY3Rpb24gKHJlY29yZENoYW5nZURlc2NyaXB0aW9ucykge1xuICAgICAgT2JqZWN0KHN0b3JhZ2VbXCJlXCIgLyogc2Vzc2lvblN0b3JhZ2VTZXRJdGVtICovXSkoY29uc3RhbnRzW1wia1wiIC8qIFNFU1NJT05fU1RPUkFHRV9SRUxPQURfQU5EX1BST0ZJTEVfS0VZICovXSwgJ3RydWUnKTtcbiAgICAgIE9iamVjdChzdG9yYWdlW1wiZVwiIC8qIHNlc3Npb25TdG9yYWdlU2V0SXRlbSAqL10pKGNvbnN0YW50c1tcImpcIiAvKiBTRVNTSU9OX1NUT1JBR0VfUkVDT1JEX0NIQU5HRV9ERVNDUklQVElPTlNfS0VZICovXSwgcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zID8gJ3RydWUnIDogJ2ZhbHNlJyk7IC8vIFRoaXMgY29kZSBwYXRoIHNob3VsZCBvbmx5IGJlIGhpdCBpZiB0aGUgc2hlbGwgaGFzIGV4cGxpY2l0bHkgdG9sZCB0aGUgU3RvcmUgdGhhdCBpdCBzdXBwb3J0cyBwcm9maWxpbmcuXG4gICAgICAvLyBJbiB0aGF0IGNhc2UsIHRoZSBzaGVsbCBtdXN0IGFsc28gbGlzdGVuIGZvciB0aGlzIHNwZWNpZmljIG1lc3NhZ2UgdG8ga25vdyB3aGVuIGl0IG5lZWRzIHRvIHJlbG9hZCB0aGUgYXBwLlxuICAgICAgLy8gVGhlIGFnZW50IGNhbid0IGRvIHRoaXMgaW4gYSB3YXkgdGhhdCBpcyByZW5kZXJlciBhZ25vc3RpYy5cblxuICAgICAgX3RoaXMuX2JyaWRnZS5zZW5kKCdyZWxvYWRBcHBGb3JQcm9maWxpbmcnKTtcbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwicmVuYW1lUGF0aFwiLCBmdW5jdGlvbiAoX3JlZjE3KSB7XG4gICAgICB2YXIgaG9va0lEID0gX3JlZjE3Lmhvb2tJRCxcbiAgICAgICAgICBpZCA9IF9yZWYxNy5pZCxcbiAgICAgICAgICBuZXdQYXRoID0gX3JlZjE3Lm5ld1BhdGgsXG4gICAgICAgICAgb2xkUGF0aCA9IF9yZWYxNy5vbGRQYXRoLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmMTcucmVuZGVyZXJJRCxcbiAgICAgICAgICB0eXBlID0gX3JlZjE3LnR5cGU7XG4gICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuXG4gICAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHJlbmRlcmVyIGlkIFxcXCJcIi5jb25jYXQocmVuZGVyZXJJRCwgXCJcXFwiIGZvciBlbGVtZW50IFxcXCJcIikuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIucmVuYW1lUGF0aCh0eXBlLCBpZCwgaG9va0lELCBvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2V0VHJhY2VVcGRhdGVzRW5hYmxlZFwiLCBmdW5jdGlvbiAodHJhY2VVcGRhdGVzRW5hYmxlZCkge1xuICAgICAgX3RoaXMuX3RyYWNlVXBkYXRlc0VuYWJsZWQgPSB0cmFjZVVwZGF0ZXNFbmFibGVkO1xuICAgICAgdG9nZ2xlRW5hYmxlZCh0cmFjZVVwZGF0ZXNFbmFibGVkKTtcblxuICAgICAgZm9yICh2YXIgcmVuZGVyZXJJRCBpbiBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IF90aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG4gICAgICAgIHJlbmRlcmVyLnNldFRyYWNlVXBkYXRlc0VuYWJsZWQodHJhY2VVcGRhdGVzRW5hYmxlZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInN5bmNTZWxlY3Rpb25Gcm9tTmF0aXZlRWxlbWVudHNQYW5lbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gd2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy4kMDtcblxuICAgICAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2VsZWN0Tm9kZSh0YXJnZXQpO1xuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzaHV0ZG93blwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBDbGVhbiB1cCB0aGUgb3ZlcmxheSBpZiB2aXNpYmxlLCBhbmQgYXNzb2NpYXRlZCBldmVudHMuXG4gICAgICBfdGhpcy5lbWl0KCdzaHV0ZG93bicpO1xuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzdGFydFByb2ZpbGluZ1wiLCBmdW5jdGlvbiAocmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zKSB7XG4gICAgICBfdGhpcy5fcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zID0gcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zO1xuICAgICAgX3RoaXMuX2lzUHJvZmlsaW5nID0gdHJ1ZTtcblxuICAgICAgZm9yICh2YXIgcmVuZGVyZXJJRCBpbiBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IF90aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG4gICAgICAgIHJlbmRlcmVyLnN0YXJ0UHJvZmlsaW5nKHJlY29yZENoYW5nZURlc2NyaXB0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLl9icmlkZ2Uuc2VuZCgncHJvZmlsaW5nU3RhdHVzJywgX3RoaXMuX2lzUHJvZmlsaW5nKTtcbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic3RvcFByb2ZpbGluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5faXNQcm9maWxpbmcgPSBmYWxzZTtcbiAgICAgIF90aGlzLl9yZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgcmVuZGVyZXJJRCBpbiBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IF90aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG4gICAgICAgIHJlbmRlcmVyLnN0b3BQcm9maWxpbmcoKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuX2JyaWRnZS5zZW5kKCdwcm9maWxpbmdTdGF0dXMnLCBfdGhpcy5faXNQcm9maWxpbmcpO1xuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzdG9wSW5zcGVjdGluZ05hdGl2ZVwiLCBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICAgIF90aGlzLl9icmlkZ2Uuc2VuZCgnc3RvcEluc3BlY3RpbmdOYXRpdmUnLCBzZWxlY3RlZCk7XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInN0b3JlQXNHbG9iYWxcIiwgZnVuY3Rpb24gKF9yZWYxOCkge1xuICAgICAgdmFyIGNvdW50ID0gX3JlZjE4LmNvdW50LFxuICAgICAgICAgIGlkID0gX3JlZjE4LmlkLFxuICAgICAgICAgIHBhdGggPSBfcmVmMTgucGF0aCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjE4LnJlbmRlcmVySUQ7XG4gICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuXG4gICAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHJlbmRlcmVyIGlkIFxcXCJcIi5jb25jYXQocmVuZGVyZXJJRCwgXCJcXFwiIGZvciBlbGVtZW50IFxcXCJcIikuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIuc3RvcmVBc0dsb2JhbChpZCwgcGF0aCwgY291bnQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ1cGRhdGVDb25zb2xlUGF0Y2hTZXR0aW5nc1wiLCBmdW5jdGlvbiAoX3JlZjE5KSB7XG4gICAgICB2YXIgYXBwZW5kQ29tcG9uZW50U3RhY2sgPSBfcmVmMTkuYXBwZW5kQ29tcG9uZW50U3RhY2ssXG4gICAgICAgICAgYnJlYWtPbkNvbnNvbGVFcnJvcnMgPSBfcmVmMTkuYnJlYWtPbkNvbnNvbGVFcnJvcnMsXG4gICAgICAgICAgc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzID0gX3JlZjE5LnNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycyxcbiAgICAgICAgICBoaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGUgPSBfcmVmMTkuaGlkZUNvbnNvbGVMb2dzSW5TdHJpY3RNb2RlLFxuICAgICAgICAgIGJyb3dzZXJUaGVtZSA9IF9yZWYxOS5icm93c2VyVGhlbWU7XG4gICAgICAvLyBJZiB0aGUgZnJvbnRlbmQgcHJlZmVyZW5jZXMgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gb3IgaW4gdGhlIGNhc2Ugb2YgUmVhY3QgTmF0aXZlLSBpZiB0aGUgYmFja2VuZCBpcyBqdXN0IGZpbmRpbmcgb3V0IHRoZSBwcmVmZXJlbmNlcy1cbiAgICAgIC8vIHRoZW4gcmVpbnN0YWxsIHRoZSBjb25zb2xlIG92ZXJyaWRlcy5cbiAgICAgIC8vIEl0J3Mgc2FmZSB0byBjYWxsIGBwYXRjaENvbnNvbGVgIG11bHRpcGxlIHRpbWVzLlxuICAgICAgT2JqZWN0KGJhY2tlbmRfY29uc29sZVtcImJcIiAvKiBwYXRjaCAqL10pKHtcbiAgICAgICAgYXBwZW5kQ29tcG9uZW50U3RhY2s6IGFwcGVuZENvbXBvbmVudFN0YWNrLFxuICAgICAgICBicmVha09uQ29uc29sZUVycm9yczogYnJlYWtPbkNvbnNvbGVFcnJvcnMsXG4gICAgICAgIHNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9yczogc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzLFxuICAgICAgICBoaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGU6IGhpZGVDb25zb2xlTG9nc0luU3RyaWN0TW9kZSxcbiAgICAgICAgYnJvd3NlclRoZW1lOiBicm93c2VyVGhlbWVcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ1cGRhdGVDb21wb25lbnRGaWx0ZXJzXCIsIGZ1bmN0aW9uIChjb21wb25lbnRGaWx0ZXJzKSB7XG4gICAgICBmb3IgKHZhciByZW5kZXJlcklEIGluIF90aGlzLl9yZW5kZXJlckludGVyZmFjZXMpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcbiAgICAgICAgcmVuZGVyZXIudXBkYXRlQ29tcG9uZW50RmlsdGVycyhjb21wb25lbnRGaWx0ZXJzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwidmlld0F0dHJpYnV0ZVNvdXJjZVwiLCBmdW5jdGlvbiAoX3JlZjIwKSB7XG4gICAgICB2YXIgaWQgPSBfcmVmMjAuaWQsXG4gICAgICAgICAgcGF0aCA9IF9yZWYyMC5wYXRoLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmMjAucmVuZGVyZXJJRDtcbiAgICAgIHZhciByZW5kZXJlciA9IF90aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG5cbiAgICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgcmVuZGVyZXIgaWQgXFxcIlwiLmNvbmNhdChyZW5kZXJlcklELCBcIlxcXCIgZm9yIGVsZW1lbnQgXFxcIlwiKS5jb25jYXQoaWQsIFwiXFxcIlwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJlci5wcmVwYXJlVmlld0F0dHJpYnV0ZVNvdXJjZShpZCwgcGF0aCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInZpZXdFbGVtZW50U291cmNlXCIsIGZ1bmN0aW9uIChfcmVmMjEpIHtcbiAgICAgIHZhciBpZCA9IF9yZWYyMS5pZCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjIxLnJlbmRlcmVySUQ7XG4gICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuXG4gICAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHJlbmRlcmVyIGlkIFxcXCJcIi5jb25jYXQocmVuZGVyZXJJRCwgXCJcXFwiIGZvciBlbGVtZW50IFxcXCJcIikuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIucHJlcGFyZVZpZXdFbGVtZW50U291cmNlKGlkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25UcmFjZVVwZGF0ZXNcIiwgZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICBfdGhpcy5lbWl0KCd0cmFjZVVwZGF0ZXMnLCBub2Rlcyk7XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uRmFzdFJlZnJlc2hTY2hlZHVsZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNvbnN0YW50c1tcInNcIiAvKiBfX0RFQlVHX18gKi9dKSB7XG4gICAgICAgIGFnZW50X2RlYnVnKCdvbkZhc3RSZWZyZXNoU2NoZWR1bGVkJyk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLl9icmlkZ2Uuc2VuZCgnZmFzdFJlZnJlc2hTY2hlZHVsZWQnKTtcbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25Ib29rT3BlcmF0aW9uc1wiLCBmdW5jdGlvbiAob3BlcmF0aW9ucykge1xuICAgICAgaWYgKGNvbnN0YW50c1tcInNcIiAvKiBfX0RFQlVHX18gKi9dKSB7XG4gICAgICAgIGFnZW50X2RlYnVnKCdvbkhvb2tPcGVyYXRpb25zJywgXCIoXCIuY29uY2F0KG9wZXJhdGlvbnMubGVuZ3RoLCBcIikgW1wiKS5jb25jYXQob3BlcmF0aW9ucy5qb2luKCcsICcpLCBcIl1cIikpO1xuICAgICAgfSAvLyBUT0RPOlxuICAgICAgLy8gVGhlIGNocm9tZS5ydW50aW1lIGRvZXMgbm90IGN1cnJlbnRseSBzdXBwb3J0IHRyYW5zZmVyYWJsZXM7IGl0IGZvcmNlcyBKU09OIHNlcmlhbGl6YXRpb24uXG4gICAgICAvLyBTZWUgYnVnIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTkyNzEzNFxuICAgICAgLy9cbiAgICAgIC8vIFJlZ2FyZGluZyB0cmFuc2ZlcmFibGVzLCB0aGUgcG9zdE1lc3NhZ2UgZG9jIHN0YXRlczpcbiAgICAgIC8vIElmIHRoZSBvd25lcnNoaXAgb2YgYW4gb2JqZWN0IGlzIHRyYW5zZmVycmVkLCBpdCBiZWNvbWVzIHVudXNhYmxlIChuZXV0ZXJlZClcbiAgICAgIC8vIGluIHRoZSBjb250ZXh0IGl0IHdhcyBzZW50IGZyb20gYW5kIGJlY29tZXMgYXZhaWxhYmxlIG9ubHkgdG8gdGhlIHdvcmtlciBpdCB3YXMgc2VudCB0by5cbiAgICAgIC8vXG4gICAgICAvLyBFdmVuIHRob3VnaCBDaHJvbWUgaXMgZXZlbnR1YWxseSBKU09OIHNlcmlhbGl6aW5nIHRoZSBhcnJheSBidWZmZXIsXG4gICAgICAvLyB1c2luZyB0aGUgdHJhbnNmZXJhYmxlIGFwcHJvYWNoIGFsc28gc29tZXRpbWVzIGNhdXNlcyBpdCB0byB0aHJvdzpcbiAgICAgIC8vICAgRE9NRXhjZXB0aW9uOiBGYWlsZWQgdG8gZXhlY3V0ZSAncG9zdE1lc3NhZ2UnIG9uICdXaW5kb3cnOiBBcnJheUJ1ZmZlciBhdCBpbmRleCAwIGlzIGFscmVhZHkgbmV1dGVyZWQuXG4gICAgICAvL1xuICAgICAgLy8gU2VlIGJ1ZyBodHRwczovL2dpdGh1Yi5jb20vYnZhdWdobi9yZWFjdC1kZXZ0b29scy1leHBlcmltZW50YWwvaXNzdWVzLzI1XG4gICAgICAvL1xuICAgICAgLy8gVGhlIFN0b3JlIGhhcyBhIGZhbGxiYWNrIGluIHBsYWNlIHRoYXQgcGFyc2VzIHRoZSBtZXNzYWdlIGFzIEpTT04gaWYgdGhlIHR5cGUgaXNuJ3QgYW4gYXJyYXkuXG4gICAgICAvLyBGb3Igbm93IHRoZSBzaW1wbGVzdCBmaXggc2VlbXMgdG8gYmUgdG8gbm90IHRyYW5zZmVyIHRoZSBhcnJheS5cbiAgICAgIC8vIFRoaXMgd2lsbCBuZWdhdGl2ZWx5IGltcGFjdCBwZXJmb3JtYW5jZSBvbiBGaXJlZm94IHNvIGl0J3MgdW5mb3J0dW5hdGUsXG4gICAgICAvLyBidXQgdW50aWwgd2UncmUgYWJsZSB0byBmaXggdGhlIENocm9tZSBlcnJvciBtZW50aW9uZWQgYWJvdmUsIGl0IHNlZW1zIG5lY2Vzc2FyeS5cbiAgICAgIC8vXG4gICAgICAvLyB0aGlzLl9icmlkZ2Uuc2VuZCgnb3BlcmF0aW9ucycsIG9wZXJhdGlvbnMsIFtvcGVyYXRpb25zLmJ1ZmZlcl0pO1xuXG5cbiAgICAgIF90aGlzLl9icmlkZ2Uuc2VuZCgnb3BlcmF0aW9ucycsIG9wZXJhdGlvbnMpO1xuXG4gICAgICBpZiAoX3RoaXMuX3BlcnNpc3RlZFNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcmVuZGVyZXJJRCA9IG9wZXJhdGlvbnNbMF07XG5cbiAgICAgICAgaWYgKF90aGlzLl9wZXJzaXN0ZWRTZWxlY3Rpb24ucmVuZGVyZXJJRCA9PT0gcmVuZGVyZXJJRCkge1xuICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGNhbiBzZWxlY3QgYSBkZWVwZXIgbWF0Y2ggZm9yIHRoZSBwZXJzaXN0ZWQgc2VsZWN0aW9uLlxuICAgICAgICAgIHZhciByZW5kZXJlciA9IF90aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG5cbiAgICAgICAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCByZW5kZXJlciBpZCBcXFwiXCIuY29uY2F0KHJlbmRlcmVySUQsIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmV2TWF0Y2ggPSBfdGhpcy5fcGVyc2lzdGVkU2VsZWN0aW9uTWF0Y2g7XG4gICAgICAgICAgICB2YXIgbmV4dE1hdGNoID0gcmVuZGVyZXIuZ2V0QmVzdE1hdGNoRm9yVHJhY2tlZFBhdGgoKTtcbiAgICAgICAgICAgIF90aGlzLl9wZXJzaXN0ZWRTZWxlY3Rpb25NYXRjaCA9IG5leHRNYXRjaDtcbiAgICAgICAgICAgIHZhciBwcmV2TWF0Y2hJRCA9IHByZXZNYXRjaCAhPT0gbnVsbCA/IHByZXZNYXRjaC5pZCA6IG51bGw7XG4gICAgICAgICAgICB2YXIgbmV4dE1hdGNoSUQgPSBuZXh0TWF0Y2ggIT09IG51bGwgPyBuZXh0TWF0Y2guaWQgOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAocHJldk1hdGNoSUQgIT09IG5leHRNYXRjaElEKSB7XG4gICAgICAgICAgICAgIGlmIChuZXh0TWF0Y2hJRCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG1vdmVkIGZvcndhcmQsIHVubG9ja2luZyBhIGRlZXBlciBub2RlLlxuICAgICAgICAgICAgICAgIF90aGlzLl9icmlkZ2Uuc2VuZCgnc2VsZWN0RmliZXInLCBuZXh0TWF0Y2hJRCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5leHRNYXRjaCAhPT0gbnVsbCAmJiBuZXh0TWF0Y2guaXNGdWxsTWF0Y2gpIHtcbiAgICAgICAgICAgICAgLy8gV2UndmUganVzdCB1bmxvY2tlZCB0aGUgaW5uZXJtb3N0IHNlbGVjdGVkIG5vZGUuXG4gICAgICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gcG9pbnQgdHJhY2tpbmcgaXQgZnVydGhlci5cbiAgICAgICAgICAgICAgX3RoaXMuX3BlcnNpc3RlZFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIF90aGlzLl9wZXJzaXN0ZWRTZWxlY3Rpb25NYXRjaCA9IG51bGw7XG4gICAgICAgICAgICAgIHJlbmRlcmVyLnNldFRyYWNrZWRQYXRoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfdGhyb3R0bGVkUGVyc2lzdFNlbGVjdGlvblwiLCBsb2Rhc2hfdGhyb3R0bGVfZGVmYXVsdCgpKGZ1bmN0aW9uIChyZW5kZXJlcklELCBpZCkge1xuICAgICAgLy8gVGhpcyBpcyB0aHJvdHRsZWQsIHNvIGJvdGggcmVuZGVyZXIgYW5kIHNlbGVjdGVkIElEXG4gICAgICAvLyBtaWdodCBub3QgYmUgYXZhaWxhYmxlIGJ5IHRoZSB0aW1lIHdlIHJlYWQgdGhlbS5cbiAgICAgIC8vIFRoaXMgaXMgd2h5IHdlIG5lZWQgdGhlIGRlZmVuc2l2ZSBjaGVja3MgaGVyZS5cbiAgICAgIHZhciByZW5kZXJlciA9IF90aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG4gICAgICB2YXIgcGF0aCA9IHJlbmRlcmVyICE9IG51bGwgPyByZW5kZXJlci5nZXRQYXRoRm9yRWxlbWVudChpZCkgOiBudWxsO1xuXG4gICAgICBpZiAocGF0aCAhPT0gbnVsbCkge1xuICAgICAgICBPYmplY3Qoc3RvcmFnZVtcImVcIiAvKiBzZXNzaW9uU3RvcmFnZVNldEl0ZW0gKi9dKShjb25zdGFudHNbXCJpXCIgLyogU0VTU0lPTl9TVE9SQUdFX0xBU1RfU0VMRUNUSU9OX0tFWSAqL10sIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICByZW5kZXJlcklEOiByZW5kZXJlcklELFxuICAgICAgICAgIHBhdGg6IHBhdGhcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT2JqZWN0KHN0b3JhZ2VbXCJkXCIgLyogc2Vzc2lvblN0b3JhZ2VSZW1vdmVJdGVtICovXSkoY29uc3RhbnRzW1wiaVwiIC8qIFNFU1NJT05fU1RPUkFHRV9MQVNUX1NFTEVDVElPTl9LRVkgKi9dKTtcbiAgICAgIH1cbiAgICB9LCAxMDAwKSk7XG5cbiAgICBpZiAoT2JqZWN0KHN0b3JhZ2VbXCJjXCIgLyogc2Vzc2lvblN0b3JhZ2VHZXRJdGVtICovXSkoY29uc3RhbnRzW1wia1wiIC8qIFNFU1NJT05fU1RPUkFHRV9SRUxPQURfQU5EX1BST0ZJTEVfS0VZICovXSkgPT09ICd0cnVlJykge1xuICAgICAgX3RoaXMuX3JlY29yZENoYW5nZURlc2NyaXB0aW9ucyA9IE9iamVjdChzdG9yYWdlW1wiY1wiIC8qIHNlc3Npb25TdG9yYWdlR2V0SXRlbSAqL10pKGNvbnN0YW50c1tcImpcIiAvKiBTRVNTSU9OX1NUT1JBR0VfUkVDT1JEX0NIQU5HRV9ERVNDUklQVElPTlNfS0VZICovXSkgPT09ICd0cnVlJztcbiAgICAgIF90aGlzLl9pc1Byb2ZpbGluZyA9IHRydWU7XG4gICAgICBPYmplY3Qoc3RvcmFnZVtcImRcIiAvKiBzZXNzaW9uU3RvcmFnZVJlbW92ZUl0ZW0gKi9dKShjb25zdGFudHNbXCJqXCIgLyogU0VTU0lPTl9TVE9SQUdFX1JFQ09SRF9DSEFOR0VfREVTQ1JJUFRJT05TX0tFWSAqL10pO1xuICAgICAgT2JqZWN0KHN0b3JhZ2VbXCJkXCIgLyogc2Vzc2lvblN0b3JhZ2VSZW1vdmVJdGVtICovXSkoY29uc3RhbnRzW1wia1wiIC8qIFNFU1NJT05fU1RPUkFHRV9SRUxPQURfQU5EX1BST0ZJTEVfS0VZICovXSk7XG4gICAgfVxuXG4gICAgdmFyIHBlcnNpc3RlZFNlbGVjdGlvblN0cmluZyA9IE9iamVjdChzdG9yYWdlW1wiY1wiIC8qIHNlc3Npb25TdG9yYWdlR2V0SXRlbSAqL10pKGNvbnN0YW50c1tcImlcIiAvKiBTRVNTSU9OX1NUT1JBR0VfTEFTVF9TRUxFQ1RJT05fS0VZICovXSk7XG5cbiAgICBpZiAocGVyc2lzdGVkU2VsZWN0aW9uU3RyaW5nICE9IG51bGwpIHtcbiAgICAgIF90aGlzLl9wZXJzaXN0ZWRTZWxlY3Rpb24gPSBKU09OLnBhcnNlKHBlcnNpc3RlZFNlbGVjdGlvblN0cmluZyk7XG4gICAgfVxuXG4gICAgX3RoaXMuX2JyaWRnZSA9IGJyaWRnZTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ2NsZWFyRXJyb3JzQW5kV2FybmluZ3MnLCBfdGhpcy5jbGVhckVycm9yc0FuZFdhcm5pbmdzKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ2NsZWFyRXJyb3JzRm9yRmliZXJJRCcsIF90aGlzLmNsZWFyRXJyb3JzRm9yRmliZXJJRCk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdjbGVhcldhcm5pbmdzRm9yRmliZXJJRCcsIF90aGlzLmNsZWFyV2FybmluZ3NGb3JGaWJlcklEKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ2NvcHlFbGVtZW50UGF0aCcsIF90aGlzLmNvcHlFbGVtZW50UGF0aCk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdkZWxldGVQYXRoJywgX3RoaXMuZGVsZXRlUGF0aCk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdnZXRCYWNrZW5kVmVyc2lvbicsIF90aGlzLmdldEJhY2tlbmRWZXJzaW9uKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ2dldEJyaWRnZVByb3RvY29sJywgX3RoaXMuZ2V0QnJpZGdlUHJvdG9jb2wpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignZ2V0UHJvZmlsaW5nRGF0YScsIF90aGlzLmdldFByb2ZpbGluZ0RhdGEpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignZ2V0UHJvZmlsaW5nU3RhdHVzJywgX3RoaXMuZ2V0UHJvZmlsaW5nU3RhdHVzKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ2dldE93bmVyc0xpc3QnLCBfdGhpcy5nZXRPd25lcnNMaXN0KTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ2luc3BlY3RFbGVtZW50JywgX3RoaXMuaW5zcGVjdEVsZW1lbnQpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignbG9nRWxlbWVudFRvQ29uc29sZScsIF90aGlzLmxvZ0VsZW1lbnRUb0NvbnNvbGUpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignb3ZlcnJpZGVFcnJvcicsIF90aGlzLm92ZXJyaWRlRXJyb3IpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignb3ZlcnJpZGVTdXNwZW5zZScsIF90aGlzLm92ZXJyaWRlU3VzcGVuc2UpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignb3ZlcnJpZGVWYWx1ZUF0UGF0aCcsIF90aGlzLm92ZXJyaWRlVmFsdWVBdFBhdGgpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcigncmVsb2FkQW5kUHJvZmlsZScsIF90aGlzLnJlbG9hZEFuZFByb2ZpbGUpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcigncmVuYW1lUGF0aCcsIF90aGlzLnJlbmFtZVBhdGgpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignc2V0VHJhY2VVcGRhdGVzRW5hYmxlZCcsIF90aGlzLnNldFRyYWNlVXBkYXRlc0VuYWJsZWQpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignc3RhcnRQcm9maWxpbmcnLCBfdGhpcy5zdGFydFByb2ZpbGluZyk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdzdG9wUHJvZmlsaW5nJywgX3RoaXMuc3RvcFByb2ZpbGluZyk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdzdG9yZUFzR2xvYmFsJywgX3RoaXMuc3RvcmVBc0dsb2JhbCk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdzeW5jU2VsZWN0aW9uRnJvbU5hdGl2ZUVsZW1lbnRzUGFuZWwnLCBfdGhpcy5zeW5jU2VsZWN0aW9uRnJvbU5hdGl2ZUVsZW1lbnRzUGFuZWwpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignc2h1dGRvd24nLCBfdGhpcy5zaHV0ZG93bik7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCd1cGRhdGVDb25zb2xlUGF0Y2hTZXR0aW5ncycsIF90aGlzLnVwZGF0ZUNvbnNvbGVQYXRjaFNldHRpbmdzKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3VwZGF0ZUNvbXBvbmVudEZpbHRlcnMnLCBfdGhpcy51cGRhdGVDb21wb25lbnRGaWx0ZXJzKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3ZpZXdBdHRyaWJ1dGVTb3VyY2UnLCBfdGhpcy52aWV3QXR0cmlidXRlU291cmNlKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3ZpZXdFbGVtZW50U291cmNlJywgX3RoaXMudmlld0VsZW1lbnRTb3VyY2UpOyAvLyBUZW1wb3JhcmlseSBzdXBwb3J0IG9sZGVyIHN0YW5kYWxvbmUgZnJvbnQtZW5kcyBzZW5kaW5nIGNvbW1hbmRzIHRvIG5ld2VyIGVtYmVkZGVkIGJhY2tlbmRzLlxuICAgIC8vIFdlIGRvIHRoaXMgYmVjYXVzZSBSZWFjdCBOYXRpdmUgZW1iZWRzIHRoZSBSZWFjdCBEZXZUb29scyBiYWNrZW5kLFxuICAgIC8vIGJ1dCBjYW5ub3QgY29udHJvbCB3aGljaCB2ZXJzaW9uIG9mIHRoZSBmcm9udGVuZCB1c2VycyB1c2UuXG5cbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ292ZXJyaWRlQ29udGV4dCcsIF90aGlzLm92ZXJyaWRlQ29udGV4dCk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdvdmVycmlkZUhvb2tTdGF0ZScsIF90aGlzLm92ZXJyaWRlSG9va1N0YXRlKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ292ZXJyaWRlUHJvcHMnLCBfdGhpcy5vdmVycmlkZVByb3BzKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ292ZXJyaWRlU3RhdGUnLCBfdGhpcy5vdmVycmlkZVN0YXRlKTtcblxuICAgIGlmIChfdGhpcy5faXNQcm9maWxpbmcpIHtcbiAgICAgIGJyaWRnZS5zZW5kKCdwcm9maWxpbmdTdGF0dXMnLCB0cnVlKTtcbiAgICB9IC8vIFNlbmQgdGhlIEJyaWRnZSBwcm90b2NvbCBhbmQgYmFja2VuZCB2ZXJzaW9ucywgYWZ0ZXIgaW5pdGlhbGl6YXRpb24sIGluIGNhc2UgdGhlIGZyb250ZW5kIGhhcyBhbHJlYWR5IHJlcXVlc3RlZCBpdC5cbiAgICAvLyBUaGUgU3RvcmUgbWF5IGJlIGluc3RhbnRpYXRlZCBiZW9yZSB0aGUgYWdlbnQuXG5cblxuICAgIHZhciBfdmVyc2lvbiA9IFwiNC4yNy42LTdmOGM1MDFmNlwiO1xuXG4gICAgaWYgKF92ZXJzaW9uKSB7XG4gICAgICBfdGhpcy5fYnJpZGdlLnNlbmQoJ2JhY2tlbmRWZXJzaW9uJywgX3ZlcnNpb24pO1xuICAgIH1cblxuICAgIF90aGlzLl9icmlkZ2Uuc2VuZCgnYnJpZGdlUHJvdG9jb2wnLCBjdXJyZW50QnJpZGdlUHJvdG9jb2wpOyAvLyBOb3RpZnkgdGhlIGZyb250ZW5kIGlmIHRoZSBiYWNrZW5kIHN1cHBvcnRzIHRoZSBTdG9yYWdlIEFQSSAoZS5nLiBsb2NhbFN0b3JhZ2UpLlxuICAgIC8vIElmIG5vdCwgZmVhdHVyZXMgbGlrZSByZWxvYWQtYW5kLXByb2ZpbGUgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgYW5kIG11c3QgYmUgZGlzYWJsZWQuXG5cblxuICAgIHZhciBpc0JhY2tlbmRTdG9yYWdlQVBJU3VwcG9ydGVkID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3Rlc3QnKTtcbiAgICAgIGlzQmFja2VuZFN0b3JhZ2VBUElTdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuXG4gICAgYnJpZGdlLnNlbmQoJ2lzQmFja2VuZFN0b3JhZ2VBUElTdXBwb3J0ZWQnLCBpc0JhY2tlbmRTdG9yYWdlQVBJU3VwcG9ydGVkKTtcbiAgICBicmlkZ2Uuc2VuZCgnaXNTeW5jaHJvbm91c1hIUlN1cHBvcnRlZCcsIE9iamVjdCh1dGlsc1tcImtcIiAvKiBpc1N5bmNocm9ub3VzWEhSU3VwcG9ydGVkICovXSkoKSk7XG4gICAgc2V0dXBIaWdobGlnaHRlcihicmlkZ2UsIGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIFRyYWNlVXBkYXRlc19pbml0aWFsaXplKGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIGFnZW50X2NyZWF0ZUNsYXNzKEFnZW50LCBbe1xuICAgIGtleTogXCJnZXRJbnN0YW5jZUFuZFN0eWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluc3RhbmNlQW5kU3R5bGUoX3JlZjIyKSB7XG4gICAgICB2YXIgaWQgPSBfcmVmMjIuaWQsXG4gICAgICAgICAgcmVuZGVyZXJJRCA9IF9yZWYyMi5yZW5kZXJlcklEO1xuICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuXG4gICAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHJlbmRlcmVyIGlkIFxcXCJcIi5jb25jYXQocmVuZGVyZXJJRCwgXCJcXFwiXCIpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZW5kZXJlci5nZXRJbnN0YW5jZUFuZFN0eWxlKGlkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmVzdE1hdGNoaW5nUmVuZGVyZXJJbnRlcmZhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmVzdE1hdGNoaW5nUmVuZGVyZXJJbnRlcmZhY2Uobm9kZSkge1xuICAgICAgdmFyIGJlc3RNYXRjaCA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIHJlbmRlcmVySUQgaW4gdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcbiAgICAgICAgdmFyIGZpYmVyID0gcmVuZGVyZXIuZ2V0RmliZXJGb3JOYXRpdmUobm9kZSk7XG5cbiAgICAgICAgaWYgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgZmliZXIuc3RhdGVOb2RlIGlzIG1hdGNoaW5nIHRoZSBvcmlnaW5hbCBob3N0SW5zdGFuY2VcbiAgICAgICAgICBpZiAoZmliZXIuc3RhdGVOb2RlID09PSBub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyZXI7XG4gICAgICAgICAgfSBlbHNlIGlmIChiZXN0TWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIGJlc3RNYXRjaCA9IHJlbmRlcmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBpZiBhbiBleGFjdCBtYXRjaCBpcyBub3QgZm91bmQsIHJldHVybiB0aGUgZmlyc3QgdmFsaWQgcmVuZGVyZXIgYXMgZmFsbGJhY2tcblxuXG4gICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRJREZvck5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SURGb3JOb2RlKG5vZGUpIHtcbiAgICAgIHZhciByZW5kZXJlckludGVyZmFjZSA9IHRoaXMuZ2V0QmVzdE1hdGNoaW5nUmVuZGVyZXJJbnRlcmZhY2Uobm9kZSk7XG5cbiAgICAgIGlmIChyZW5kZXJlckludGVyZmFjZSAhPSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHJlbmRlcmVySW50ZXJmYWNlLmdldEZpYmVySURGb3JOYXRpdmUobm9kZSwgdHJ1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU29tZSBvbGQgUmVhY3QgdmVyc2lvbnMgbWlnaHQgdGhyb3cgaWYgdGhleSBjYW4ndCBmaW5kIGEgbWF0Y2guXG4gICAgICAgICAgLy8gSWYgc28gd2Ugc2hvdWxkIGlnbm9yZSBpdC4uLlxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3ROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdE5vZGUodGFyZ2V0KSB7XG4gICAgICB2YXIgaWQgPSB0aGlzLmdldElERm9yTm9kZSh0YXJnZXQpO1xuXG4gICAgICBpZiAoaWQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fYnJpZGdlLnNlbmQoJ3NlbGVjdEZpYmVyJywgaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRSZW5kZXJlckludGVyZmFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRSZW5kZXJlckludGVyZmFjZShyZW5kZXJlcklELCByZW5kZXJlckludGVyZmFjZSkge1xuICAgICAgdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdID0gcmVuZGVyZXJJbnRlcmZhY2U7XG5cbiAgICAgIGlmICh0aGlzLl9pc1Byb2ZpbGluZykge1xuICAgICAgICByZW5kZXJlckludGVyZmFjZS5zdGFydFByb2ZpbGluZyh0aGlzLl9yZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICByZW5kZXJlckludGVyZmFjZS5zZXRUcmFjZVVwZGF0ZXNFbmFibGVkKHRoaXMuX3RyYWNlVXBkYXRlc0VuYWJsZWQpOyAvLyBXaGVuIHRoZSByZW5kZXJlciBpcyBhdHRhY2hlZCwgd2UgbmVlZCB0byB0ZWxsIGl0IHdoZXRoZXJcbiAgICAgIC8vIHdlIHJlbWVtYmVyIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24gdGhhdCB3ZSdkIGxpa2UgdG8gcmVzdG9yZS5cbiAgICAgIC8vIEl0J2xsIHN0YXJ0IHRyYWNraW5nIG1vdW50cyBmb3IgbWF0Y2hlcyB0byB0aGUgbGFzdCBzZWxlY3Rpb24gcGF0aC5cblxuICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuX3BlcnNpc3RlZFNlbGVjdGlvbjtcblxuICAgICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCAmJiBzZWxlY3Rpb24ucmVuZGVyZXJJRCA9PT0gcmVuZGVyZXJJRCkge1xuICAgICAgICByZW5kZXJlckludGVyZmFjZS5zZXRUcmFja2VkUGF0aChzZWxlY3Rpb24ucGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uVW5zdXBwb3J0ZWRSZW5kZXJlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblVuc3VwcG9ydGVkUmVuZGVyZXIocmVuZGVyZXJJRCkge1xuICAgICAgdGhpcy5fYnJpZGdlLnNlbmQoJ3Vuc3VwcG9ydGVkUmVuZGVyZXJWZXJzaW9uJywgcmVuZGVyZXJJRCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlcmVySW50ZXJmYWNlc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVySW50ZXJmYWNlcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQWdlbnQ7XG59KEV2ZW50RW1pdHRlcik7XG5cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9ob29rLmpzXG5mdW5jdGlvbiBob29rX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgaG9va190eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgaG9va190eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gaG9va190eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBob29rX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gaG9va19hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGhvb2tfaXRlcmFibGVUb0FycmF5KGFycikgfHwgaG9va191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IGhvb2tfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBob29rX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBob29rX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gaG9va19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gaG9va19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gaG9va19pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBob29rX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gaG9va19hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gaG9va19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vKipcbiAqIEluc3RhbGwgdGhlIGhvb2sgb24gd2luZG93LCB3aGljaCBpcyBhbiBldmVudCBlbWl0dGVyLlxuICogTm90ZTogdGhpcyBnbG9iYWwgaG9vayBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gaXMgYSBkZSBmYWN0byBwdWJsaWMgQVBJLlxuICogSXQncyBlc3BlY2lhbGx5IGltcG9ydGFudCB0byBhdm9pZCBjcmVhdGluZyBkaXJlY3QgZGVwZW5kZW5jeSBvbiB0aGUgRGV2VG9vbHMgQmFja2VuZC5cbiAqIFRoYXQncyB3aHkgd2Ugc3RpbGwgaW5saW5lIHRoZSB3aG9sZSBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uLFxuICogdGhlIHN0cmluZyBmb3JtYXQgaW1wbGVtZW50YXRpb24sIGFuZCBwYXJ0IG9mIHRoZSBjb25zb2xlIGltcGxlbWVudGF0aW9uIGhlcmUuXG4gKlxuICogXG4gKi9cbmZ1bmN0aW9uIGluc3RhbGxIb29rKHRhcmdldCkge1xuICBpZiAodGFyZ2V0Lmhhc093blByb3BlcnR5KCdfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18nKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHRhcmdldENvbnNvbGUgPSBjb25zb2xlO1xuICB2YXIgdGFyZ2V0Q29uc29sZU1ldGhvZHMgPSB7fTtcblxuICBmb3IgKHZhciBtZXRob2QgaW4gY29uc29sZSkge1xuICAgIHRhcmdldENvbnNvbGVNZXRob2RzW21ldGhvZF0gPSBjb25zb2xlW21ldGhvZF07XG4gIH1cblxuICBmdW5jdGlvbiBkYW5nZXJvdXNfc2V0VGFyZ2V0Q29uc29sZUZvclRlc3RpbmcodGFyZ2V0Q29uc29sZUZvclRlc3RpbmcpIHtcbiAgICB0YXJnZXRDb25zb2xlID0gdGFyZ2V0Q29uc29sZUZvclRlc3Rpbmc7XG4gICAgdGFyZ2V0Q29uc29sZU1ldGhvZHMgPSB7fTtcblxuICAgIGZvciAodmFyIF9tZXRob2QgaW4gdGFyZ2V0Q29uc29sZSkge1xuICAgICAgdGFyZ2V0Q29uc29sZU1ldGhvZHNbX21ldGhvZF0gPSBjb25zb2xlW19tZXRob2RdO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRldGVjdFJlYWN0QnVpbGRUeXBlKHJlbmRlcmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgcmVuZGVyZXIudmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gUmVhY3QgRE9NIEZpYmVyICgxNispXG4gICAgICAgIGlmIChyZW5kZXJlci5idW5kbGVUeXBlID4gMCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgbm90IGEgcHJvZHVjdGlvbiBidWlsZC5cbiAgICAgICAgICAvLyBXZSBhcmUgY3VycmVudGx5IG9ubHkgdXNpbmcgMCAoUFJPRCkgYW5kIDEgKERFVilcbiAgICAgICAgICAvLyBidXQgbWlnaHQgYWRkIDIgKFBST0ZJTEUpIGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgcmV0dXJuICdkZXZlbG9wbWVudCc7XG4gICAgICAgIH0gLy8gUmVhY3QgMTYgdXNlcyBmbGF0IGJ1bmRsZXMuIElmIHdlIHJlcG9ydCB0aGUgYnVuZGxlIGFzIHByb2R1Y3Rpb25cbiAgICAgICAgLy8gdmVyc2lvbiwgaXQgbWVhbnMgd2UgYWxzbyBtaW5pZmllZCBhbmQgZW52aWZpZWQgaXQgb3Vyc2VsdmVzLlxuXG5cbiAgICAgICAgcmV0dXJuICdwcm9kdWN0aW9uJzsgLy8gTm90ZTogVGhlcmUgaXMgc3RpbGwgYSByaXNrIHRoYXQgdGhlIENvbW1vbkpTIGVudHJ5IHBvaW50IGhhcyBub3RcbiAgICAgICAgLy8gYmVlbiBlbnZpZmllZCBvciB1Z2xpZmllZC4gSW4gdGhpcyBjYXNlIHRoZSB1c2VyIHdvdWxkIGhhdmUgKmJvdGgqXG4gICAgICAgIC8vIGRldmVsb3BtZW50IGFuZCBwcm9kdWN0aW9uIGJ1bmRsZSwgYnV0IG9ubHkgdGhlIHByb2Qgb25lIHdvdWxkIHJ1bi5cbiAgICAgICAgLy8gVGhpcyB3b3VsZCBiZSByZWFsbHkgYmFkLiBXZSBoYXZlIGEgc2VwYXJhdGUgY2hlY2sgZm9yIHRoaXMgYmVjYXVzZVxuICAgICAgICAvLyBpdCBoYXBwZW5zICpvdXRzaWRlKiBvZiB0aGUgcmVuZGVyZXIgaW5qZWN0aW9uLiBTZWUgYGNoZWNrRENFYCBiZWxvdy5cbiAgICAgIH0gLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuXG5cbiAgICAgIHZhciBfdG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICAgIGlmIChyZW5kZXJlci5Nb3VudCAmJiByZW5kZXJlci5Nb3VudC5fcmVuZGVyTmV3Um9vdENvbXBvbmVudCkge1xuICAgICAgICAvLyBSZWFjdCBET00gU3RhY2tcbiAgICAgICAgdmFyIHJlbmRlclJvb3RDb2RlID0gX3RvU3RyaW5nLmNhbGwocmVuZGVyZXIuTW91bnQuX3JlbmRlck5ld1Jvb3RDb21wb25lbnQpOyAvLyBGaWx0ZXIgb3V0IGJhZCByZXN1bHRzIChpZiB0aGF0IGlzIGV2ZW4gcG9zc2libGUpOlxuXG5cbiAgICAgICAgaWYgKHJlbmRlclJvb3RDb2RlLmluZGV4T2YoJ2Z1bmN0aW9uJykgIT09IDApIHtcbiAgICAgICAgICAvLyBIb3BlIGZvciB0aGUgYmVzdCBpZiB3ZSdyZSBub3Qgc3VyZS5cbiAgICAgICAgICByZXR1cm4gJ3Byb2R1Y3Rpb24nO1xuICAgICAgICB9IC8vIENoZWNrIGZvciBSZWFjdCBET00gU3RhY2sgPCAxNS4xLjAgaW4gZGV2ZWxvcG1lbnQuXG4gICAgICAgIC8vIElmIGl0IGNvbnRhaW5zIFwic3RvcmVkTWVhc3VyZVwiIGNhbGwsIGl0J3Mgd3JhcHBlZCBpbiBSZWFjdFBlcmYgKERFViBvbmx5KS5cbiAgICAgICAgLy8gVGhpcyB3b3VsZCBiZSB0cnVlIGV2ZW4gaWYgaXQncyBtaW5pZmllZCwgYXMgbWV0aG9kIG5hbWUgc3RpbGwgbWF0Y2hlcy5cblxuXG4gICAgICAgIGlmIChyZW5kZXJSb290Q29kZS5pbmRleE9mKCdzdG9yZWRNZWFzdXJlJykgIT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuICdkZXZlbG9wbWVudCc7XG4gICAgICAgIH0gLy8gRm9yIG90aGVyIHZlcnNpb25zIChhbmQgY29uZmlndXJhdGlvbnMpIGl0J3Mgbm90IHNvIGVhc3kuXG4gICAgICAgIC8vIExldCdzIHF1aWNrbHkgZXhjbHVkZSBwcm9wZXIgcHJvZHVjdGlvbiBidWlsZHMuXG4gICAgICAgIC8vIElmIGl0IGNvbnRhaW5zIGEgd2FybmluZyBtZXNzYWdlLCBpdCdzIGVpdGhlciBhIERFViBidWlsZCxcbiAgICAgICAgLy8gb3IgYW4gUFJPRCBidWlsZCB3aXRob3V0IHByb3BlciBkZWFkIGNvZGUgZWxpbWluYXRpb24uXG5cblxuICAgICAgICBpZiAocmVuZGVyUm9vdENvZGUuaW5kZXhPZignc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbicpICE9PSAtMSkge1xuICAgICAgICAgIC8vIE5vdyBob3cgZG8gd2UgdGVsbCBhIERFViBidWlsZCBmcm9tIGEgYmFkIFBST0QgYnVpbGQ/XG4gICAgICAgICAgLy8gSWYgd2Ugc2VlIE5PREVfRU5WLCB3ZSdyZSBnb2luZyB0byBhc3N1bWUgdGhpcyBpcyBhIGRldiBidWlsZFxuICAgICAgICAgIC8vIGJlY2F1c2UgbW9zdCBsaWtlbHkgaXQgaXMgcmVmZXJyaW5nIHRvIGFuIGVtcHR5IHNoaW0uXG4gICAgICAgICAgaWYgKHJlbmRlclJvb3RDb2RlLmluZGV4T2YoJ05PREVfRU5WJykgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2RldmVsb3BtZW50JztcbiAgICAgICAgICB9IC8vIElmIHdlIHNlZSBcImRldmVsb3BtZW50XCIsIHdlJ3JlIGRlYWxpbmcgd2l0aCBhbiBlbnZpZmllZCBERVYgYnVpbGRcbiAgICAgICAgICAvLyAoc3VjaCBhcyB0aGUgb2ZmaWNpYWwgUmVhY3QgREVWIFVNRCkuXG5cblxuICAgICAgICAgIGlmIChyZW5kZXJSb290Q29kZS5pbmRleE9mKCdkZXZlbG9wbWVudCcpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuICdkZXZlbG9wbWVudCc7XG4gICAgICAgICAgfSAvLyBJJ3ZlIHNlZW4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyBiZWluZyBzbWFydGx5XG4gICAgICAgICAgLy8gcmVwbGFjZWQgYnkgYHRydWVgIGluIERFViBieSBXZWJwYWNrLiBJIGRvbid0IGtub3cgaG93IHRoYXRcbiAgICAgICAgICAvLyB3b3JrcyBidXQgd2UgY2FuIHNhZmVseSBndWFyZCBhZ2FpbnN0IGl0IGJlY2F1c2UgYHRydWVgIHdhc1xuICAgICAgICAgIC8vIG5ldmVyIHVzZWQgaW4gdGhlIGZ1bmN0aW9uIHNvdXJjZSBzaW5jZSBpdCB3YXMgd3JpdHRlbi5cblxuXG4gICAgICAgICAgaWYgKHJlbmRlclJvb3RDb2RlLmluZGV4T2YoJ3RydWUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAnZGV2ZWxvcG1lbnQnO1xuICAgICAgICAgIH0gLy8gQnkgbm93IGVpdGhlciBpdCBpcyBhIHByb2R1Y3Rpb24gYnVpbGQgdGhhdCBoYXMgbm90IGJlZW4gbWluaWZpZWQsXG4gICAgICAgICAgLy8gb3IgKHdvcnNlKSB0aGlzIGlzIGEgbWluaWZpZWQgZGV2ZWxvcG1lbnQgYnVpbGQgdXNpbmcgbm9uLXN0YW5kYXJkXG4gICAgICAgICAgLy8gZW52aXJvbm1lbnQgKGUuZy4gXCJzdGFnaW5nXCIpLiBXZSdyZSBnb2luZyB0byBsb29rIGF0IHdoZXRoZXJcbiAgICAgICAgICAvLyB0aGUgZnVuY3Rpb24gYXJndW1lbnQgbmFtZSBpcyBtYW5nbGVkOlxuXG5cbiAgICAgICAgICBpZiAoIC8vIDAuMTMgdG8gMTVcbiAgICAgICAgICByZW5kZXJSb290Q29kZS5pbmRleE9mKCduZXh0RWxlbWVudCcpICE9PSAtMSB8fCAvLyAwLjEyXG4gICAgICAgICAgcmVuZGVyUm9vdENvZGUuaW5kZXhPZignbmV4dENvbXBvbmVudCcpICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gV2UgY2FuJ3QgYmUgY2VydGFpbiB3aGV0aGVyIHRoaXMgaXMgYSBkZXZlbG9wbWVudCBidWlsZCBvciBub3QsXG4gICAgICAgICAgICAvLyBidXQgaXQgaXMgZGVmaW5pdGVseSB1bm1pbmlmaWVkLlxuICAgICAgICAgICAgcmV0dXJuICd1bm1pbmlmaWVkJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBsaWtlbHkgYSBtaW5pZmllZCBkZXZlbG9wbWVudCBidWlsZC5cbiAgICAgICAgICAgIHJldHVybiAnZGV2ZWxvcG1lbnQnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBCeSBub3cgd2Uga25vdyB0aGF0IGl0J3MgZW52aWZpZWQgYW5kIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3b3JrZWQsXG4gICAgICAgIC8vIGJ1dCB3aGF0IGlmIGl0J3Mgc3RpbGwgbm90IG1pbmlmaWVkPyAoSXMgdGhpcyBldmVuIHBvc3NpYmxlPylcbiAgICAgICAgLy8gTGV0J3MgY2hlY2sgbWF0Y2hlcyBmb3IgdGhlIGZpcnN0IGFyZ3VtZW50IG5hbWUuXG5cblxuICAgICAgICBpZiAoIC8vIDAuMTMgdG8gMTVcbiAgICAgICAgcmVuZGVyUm9vdENvZGUuaW5kZXhPZignbmV4dEVsZW1lbnQnKSAhPT0gLTEgfHwgLy8gMC4xMlxuICAgICAgICByZW5kZXJSb290Q29kZS5pbmRleE9mKCduZXh0Q29tcG9uZW50JykgIT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuICd1bm1pbmlmaWVkJztcbiAgICAgICAgfSAvLyBTZWVtcyBsaWtlIHdlJ3JlIHVzaW5nIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24uXG4gICAgICAgIC8vIEhvd2V2ZXIsIHRoZSBicmFuY2ggYWJvdmUgaXMgU3RhY2stb25seSBzbyB0aGlzIGlzIDE1IG9yIGVhcmxpZXIuXG5cblxuICAgICAgICByZXR1cm4gJ291dGRhdGVkJztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHsvLyBXZWlyZCBlbnZpcm9ubWVudHMgbWF5IGV4aXN0LlxuICAgICAgLy8gVGhpcyBjb2RlIG5lZWRzIGEgaGlnaGVyIGZhdWx0IHRvbGVyYW5jZVxuICAgICAgLy8gYmVjYXVzZSBpdCBydW5zIGV2ZW4gd2l0aCBjbG9zZWQgRGV2VG9vbHMuXG4gICAgICAvLyBUT0RPOiBzaG91bGQgd2UgY2F0Y2ggZXJyb3JzIGluIGFsbCBpbmplY3RlZCBjb2RlLCBhbmQgbm90IGp1c3QgdGhpcyBwYXJ0P1xuICAgIH1cblxuICAgIHJldHVybiAncHJvZHVjdGlvbic7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0RDRShmbikge1xuICAgIC8vIFRoaXMgcnVucyBmb3IgcHJvZHVjdGlvbiB2ZXJzaW9ucyBvZiBSZWFjdC5cbiAgICAvLyBOZWVkcyB0byBiZSBzdXBlciBzYWZlLlxuICAgIHRyeSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gICAgICB2YXIgX3RvU3RyaW5nMiA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxuICAgICAgdmFyIGNvZGUgPSBfdG9TdHJpbmcyLmNhbGwoZm4pOyAvLyBUaGlzIGlzIGEgc3RyaW5nIGVtYmVkZGVkIGluIHRoZSBwYXNzZWQgZnVuY3Rpb24gdW5kZXIgREVWLW9ubHlcbiAgICAgIC8vIGNvbmRpdGlvbi4gSG93ZXZlciB0aGUgZnVuY3Rpb24gZXhlY3V0ZXMgb25seSBpbiBQUk9ELiBUaGVyZWZvcmUsXG4gICAgICAvLyBpZiB3ZSBzZWUgaXQsIGRlYWQgY29kZSBlbGltaW5hdGlvbiBkaWQgbm90IHdvcmsuXG5cblxuICAgICAgaWYgKGNvZGUuaW5kZXhPZignXl9eJykgPiAtMSkge1xuICAgICAgICAvLyBSZW1lbWJlciB0byByZXBvcnQgZHVyaW5nIG5leHQgaW5qZWN0aW9uLlxuICAgICAgICBoYXNEZXRlY3RlZEJhZERDRSA9IHRydWU7IC8vIEJvbnVzOiB0aHJvdyBhbiBleGNlcHRpb24gaG9waW5nIHRoYXQgaXQgZ2V0cyBwaWNrZWQgdXAgYnkgYSByZXBvcnRpbmcgc3lzdGVtLlxuICAgICAgICAvLyBOb3Qgc3luY2hyb25vdXNseSBzbyB0aGF0IGl0IGRvZXNuJ3QgYnJlYWsgdGhlIGNhbGxpbmcgY29kZS5cblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IGlzIHJ1bm5pbmcgaW4gcHJvZHVjdGlvbiBtb2RlLCBidXQgZGVhZCBjb2RlICcgKyAnZWxpbWluYXRpb24gaGFzIG5vdCBiZWVuIGFwcGxpZWQuIFJlYWQgaG93IHRvIGNvcnJlY3RseSAnICsgJ2NvbmZpZ3VyZSBSZWFjdCBmb3IgcHJvZHVjdGlvbjogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcGVyZi11c2UtcHJvZHVjdGlvbi1idWlsZCcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHt9XG4gIH0gLy8gTk9URTogS0VFUCBJTiBTWU5DIHdpdGggc3JjL2JhY2tlbmQvdXRpbHMuanNcblxuXG4gIGZ1bmN0aW9uIGZvcm1hdFdpdGhTdHlsZXMoaW5wdXRBcmdzLCBzdHlsZSkge1xuICAgIGlmIChpbnB1dEFyZ3MgPT09IHVuZGVmaW5lZCB8fCBpbnB1dEFyZ3MgPT09IG51bGwgfHwgaW5wdXRBcmdzLmxlbmd0aCA9PT0gMCB8fCAvLyBNYXRjaGVzIGFueSBvZiAlYyBidXQgbm90ICUlY1xuICAgIHR5cGVvZiBpbnB1dEFyZ3NbMF0gPT09ICdzdHJpbmcnICYmIGlucHV0QXJnc1swXS5tYXRjaCgvKFteJV18XikoJWMpL2cpIHx8IHN0eWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBpbnB1dEFyZ3M7XG4gICAgfSAvLyBNYXRjaGVzIGFueSBvZiAlKG98T3xkfGl8c3xmKSwgYnV0IG5vdCAlJShvfE98ZHxpfHN8ZilcblxuXG4gICAgdmFyIFJFR0VYUCA9IC8oW14lXXxeKSgoJSUpKikoJShbb09kaXNmXSkpL2c7XG5cbiAgICBpZiAodHlwZW9mIGlucHV0QXJnc1swXSA9PT0gJ3N0cmluZycgJiYgaW5wdXRBcmdzWzBdLm1hdGNoKFJFR0VYUCkpIHtcbiAgICAgIHJldHVybiBbXCIlY1wiLmNvbmNhdChpbnB1dEFyZ3NbMF0pLCBzdHlsZV0uY29uY2F0KGhvb2tfdG9Db25zdW1hYmxlQXJyYXkoaW5wdXRBcmdzLnNsaWNlKDEpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmaXJzdEFyZyA9IGlucHV0QXJncy5yZWR1Y2UoZnVuY3Rpb24gKGZvcm1hdFN0ciwgZWxlbSwgaSkge1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBmb3JtYXRTdHIgKz0gJyAnO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChob29rX3R5cGVvZihlbGVtKSkge1xuICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRTdHIgKz0gJyVzJztcblxuICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGluZyA9IE51bWJlci5pc0ludGVnZXIoZWxlbSkgPyAnJWknIDogJyVmJztcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRTdHIgKz0gZm9ybWF0dGluZztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0U3RyICs9ICclbyc7XG4gICAgICAgIH1cbiAgICAgIH0sICclYycpO1xuICAgICAgcmV0dXJuIFtmaXJzdEFyZywgc3R5bGVdLmNvbmNhdChob29rX3RvQ29uc3VtYWJsZUFycmF5KGlucHV0QXJncykpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bnBhdGNoRm4gPSBudWxsOyAvLyBOT1RFOiBLRUVQIElOIFNZTkMgd2l0aCBzcmMvYmFja2VuZC9jb25zb2xlLmpzOnBhdGNoRm9yU3RyaWN0TW9kZVxuICAvLyBUaGlzIGZ1bmN0aW9uIGhpZGVzIG9yIGRpbXMgY29uc29sZSBsb2dzIGR1cmluZyB0aGUgaW5pdGlhbCBkb3VibGUgcmVuZGVyZXJcbiAgLy8gaW4gU3RyaWN0IE1vZGUuIFdlIG5lZWQgdGhpcyBmdW5jdGlvbiBiZWNhdXNlIGR1cmluZyBpbml0aWFsIHJlbmRlcixcbiAgLy8gUmVhY3QgYW5kIERldlRvb2xzIGFyZSBjb25uZWN0aW5nIGFuZCB0aGUgcmVuZGVyZXIgaW50ZXJmYWNlIGlzbid0IGF2YWlhYmxlXG4gIC8vIGFuZCB3ZSB3YW50IHRvIGJlIGFibGUgdG8gaGF2ZSBjb25zaXN0ZW50IGxvZ2dpbmcgYmVoYXZpb3IgZm9yIGRvdWJsZSBsb2dzXG4gIC8vIGR1cmluZyB0aGUgaW5pdGlhbCByZW5kZXJlci5cblxuICBmdW5jdGlvbiBwYXRjaENvbnNvbGVGb3JJbml0aWFsUmVuZGVySW5TdHJpY3RNb2RlKF9yZWYpIHtcbiAgICB2YXIgaGlkZUNvbnNvbGVMb2dzSW5TdHJpY3RNb2RlID0gX3JlZi5oaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGUsXG4gICAgICAgIGJyb3dzZXJUaGVtZSA9IF9yZWYuYnJvd3NlclRoZW1lO1xuICAgIHZhciBvdmVycmlkZUNvbnNvbGVNZXRob2RzID0gWydlcnJvcicsICdncm91cCcsICdncm91cENvbGxhcHNlZCcsICdpbmZvJywgJ2xvZycsICd0cmFjZScsICd3YXJuJ107XG5cbiAgICBpZiAodW5wYXRjaEZuICE9PSBudWxsKSB7XG4gICAgICAvLyBEb24ndCBwYXRjaCB0d2ljZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3JpZ2luYWxDb25zb2xlTWV0aG9kcyA9IHt9O1xuXG4gICAgdW5wYXRjaEZuID0gZnVuY3Rpb24gdW5wYXRjaEZuKCkge1xuICAgICAgZm9yICh2YXIgX21ldGhvZDIgaW4gb3JpZ2luYWxDb25zb2xlTWV0aG9kcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRhcmdldENvbnNvbGVbX21ldGhvZDJdID0gb3JpZ2luYWxDb25zb2xlTWV0aG9kc1tfbWV0aG9kMl07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuICAgICAgfVxuICAgIH07XG5cbiAgICBvdmVycmlkZUNvbnNvbGVNZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG9yaWdpbmFsTWV0aG9kID0gb3JpZ2luYWxDb25zb2xlTWV0aG9kc1ttZXRob2RdID0gdGFyZ2V0Q29uc29sZVttZXRob2RdLl9fUkVBQ1RfREVWVE9PTFNfU1RSSUNUX01PREVfT1JJR0lOQUxfTUVUSE9EX18gPyB0YXJnZXRDb25zb2xlW21ldGhvZF0uX19SRUFDVF9ERVZUT09MU19TVFJJQ1RfTU9ERV9PUklHSU5BTF9NRVRIT0RfXyA6IHRhcmdldENvbnNvbGVbbWV0aG9kXTtcblxuICAgICAgICB2YXIgb3ZlcnJpZGVNZXRob2QgPSBmdW5jdGlvbiBvdmVycmlkZU1ldGhvZCgpIHtcbiAgICAgICAgICBpZiAoIWhpZGVDb25zb2xlTG9nc0luU3RyaWN0TW9kZSkge1xuICAgICAgICAgICAgLy8gRGltIHRoZSB0ZXh0IGNvbG9yIG9mIHRoZSBkb3VibGUgbG9ncyBpZiB3ZSdyZSBub3RcbiAgICAgICAgICAgIC8vIGhpZGluZyB0aGVtLlxuICAgICAgICAgICAgdmFyIGNvbG9yO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgICBjYXNlICd3YXJuJzpcbiAgICAgICAgICAgICAgICBjb2xvciA9IGJyb3dzZXJUaGVtZSA9PT0gJ2xpZ2h0JyA/IFwicmdiYSgyNTAsIDE4MCwgNTAsIDAuNzUpXCIgOiBcInJnYmEoMjUwLCAxODAsIDUwLCAwLjUpXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgICAgIGNvbG9yID0gYnJvd3NlclRoZW1lID09PSAnbGlnaHQnID8gXCJyZ2JhKDI1MCwgMTIzLCAxMzAsIDAuNzUpXCIgOiBcInJnYmEoMjUwLCAxMjMsIDEzMCwgMC41KVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgJ2xvZyc6XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29sb3IgPSBicm93c2VyVGhlbWUgPT09ICdsaWdodCcgPyBcInJnYmEoMTI1LCAxMjUsIDEyNSwgMC43NSlcIiA6IFwicmdiYSgxMjUsIDEyNSwgMTI1LCAwLjUpXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb3JpZ2luYWxNZXRob2QuYXBwbHkodm9pZCAwLCBob29rX3RvQ29uc3VtYWJsZUFycmF5KGZvcm1hdFdpdGhTdHlsZXMoYXJncywgXCJjb2xvcjogXCIuY29uY2F0KGNvbG9yKSkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCdDb25zb2xlIGNvbG9yIGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIG92ZXJyaWRlTWV0aG9kLl9fUkVBQ1RfREVWVE9PTFNfU1RSSUNUX01PREVfT1JJR0lOQUxfTUVUSE9EX18gPSBvcmlnaW5hbE1ldGhvZDtcbiAgICAgICAgb3JpZ2luYWxNZXRob2QuX19SRUFDVF9ERVZUT09MU19TVFJJQ1RfTU9ERV9PVkVSUklERV9NRVRIT0RfXyA9IG92ZXJyaWRlTWV0aG9kO1xuICAgICAgICB0YXJnZXRDb25zb2xlW21ldGhvZF0gPSBvdmVycmlkZU1ldGhvZDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuICAgIH0pO1xuICB9IC8vIE5PVEU6IEtFRVAgSU4gU1lOQyB3aXRoIHNyYy9iYWNrZW5kL2NvbnNvbGUuanM6dW5wYXRjaEZvclN0cmljdE1vZGVcblxuXG4gIGZ1bmN0aW9uIHVucGF0Y2hDb25zb2xlRm9ySW5pdGlhbFJlbmRlckluU3RyaWN0TW9kZSgpIHtcbiAgICBpZiAodW5wYXRjaEZuICE9PSBudWxsKSB7XG4gICAgICB1bnBhdGNoRm4oKTtcbiAgICAgIHVucGF0Y2hGbiA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVpZENvdW50ZXIgPSAwO1xuXG4gIGZ1bmN0aW9uIGluamVjdChyZW5kZXJlcikge1xuICAgIHZhciBpZCA9ICsrdWlkQ291bnRlcjtcbiAgICByZW5kZXJlcnMuc2V0KGlkLCByZW5kZXJlcik7XG4gICAgdmFyIHJlYWN0QnVpbGRUeXBlID0gaGFzRGV0ZWN0ZWRCYWREQ0UgPyAnZGVhZGNvZGUnIDogZGV0ZWN0UmVhY3RCdWlsZFR5cGUocmVuZGVyZXIpOyAvLyBQYXRjaGluZyB0aGUgY29uc29sZSBlbmFibGVzIERldlRvb2xzIHRvIGRvIGEgZmV3IHVzZWZ1bCB0aGluZ3M6XG4gICAgLy8gKiBBcHBlbmQgY29tcG9uZW50IHN0YWNrcyB0byB3YXJuaW5ncyBhbmQgZXJyb3IgbWVzc2FnZXNcbiAgICAvLyAqIERpc2FibGluZyBvciBtYXJraW5nIGxvZ3MgZHVyaW5nIGEgZG91YmxlIHJlbmRlciBpbiBTdHJpY3QgTW9kZVxuICAgIC8vICogRGlzYWJsZSBsb2dnaW5nIGR1cmluZyByZS1yZW5kZXJzIHRvIGluc3BlY3QgaG9va3MgKHNlZSBpbnNwZWN0SG9va3NPZkZpYmVyKVxuICAgIC8vXG4gICAgLy8gQWxsb3cgcGF0Y2hpbmcgY29uc29sZSBlYXJseSAoZHVyaW5nIGluamVjdGlvbikgdG9cbiAgICAvLyBwcm92aWRlIGRldmVsb3BlcnMgd2l0aCBjb21wb25lbnRzIHN0YWNrcyBldmVuIGlmIHRoZXkgZG9uJ3QgcnVuIERldlRvb2xzLlxuXG4gICAgaWYgKHRhcmdldC5oYXNPd25Qcm9wZXJ0eSgnX19SRUFDVF9ERVZUT09MU19DT05TT0xFX0ZVTkNUSU9OU19fJykpIHtcbiAgICAgIHZhciBfdGFyZ2V0JF9fUkVBQ1RfREVWVE8gPSB0YXJnZXQuX19SRUFDVF9ERVZUT09MU19DT05TT0xFX0ZVTkNUSU9OU19fLFxuICAgICAgICAgIHJlZ2lzdGVyUmVuZGVyZXJXaXRoQ29uc29sZSA9IF90YXJnZXQkX19SRUFDVF9ERVZUTy5yZWdpc3RlclJlbmRlcmVyV2l0aENvbnNvbGUsXG4gICAgICAgICAgcGF0Y2hDb25zb2xlVXNpbmdXaW5kb3dWYWx1ZXMgPSBfdGFyZ2V0JF9fUkVBQ1RfREVWVE8ucGF0Y2hDb25zb2xlVXNpbmdXaW5kb3dWYWx1ZXM7XG5cbiAgICAgIGlmICh0eXBlb2YgcmVnaXN0ZXJSZW5kZXJlcldpdGhDb25zb2xlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwYXRjaENvbnNvbGVVc2luZ1dpbmRvd1ZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZWdpc3RlclJlbmRlcmVyV2l0aENvbnNvbGUocmVuZGVyZXIpO1xuICAgICAgICBwYXRjaENvbnNvbGVVc2luZ1dpbmRvd1ZhbHVlcygpO1xuICAgICAgfVxuICAgIH0gLy8gSWYgd2UgaGF2ZSBqdXN0IHJlbG9hZGVkIHRvIHByb2ZpbGUsIHdlIG5lZWQgdG8gaW5qZWN0IHRoZSByZW5kZXJlciBpbnRlcmZhY2UgYmVmb3JlIHRoZSBhcHAgbG9hZHMuXG4gICAgLy8gT3RoZXJ3aXNlIHRoZSByZW5kZXJlciB3b24ndCB5ZXQgZXhpc3QgYW5kIHdlIGNhbiBza2lwIHRoaXMgc3RlcC5cblxuXG4gICAgdmFyIGF0dGFjaCA9IHRhcmdldC5fX1JFQUNUX0RFVlRPT0xTX0FUVEFDSF9fO1xuXG4gICAgaWYgKHR5cGVvZiBhdHRhY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciByZW5kZXJlckludGVyZmFjZSA9IGF0dGFjaChob29rLCBpZCwgcmVuZGVyZXIsIHRhcmdldCk7XG4gICAgICBob29rLnJlbmRlcmVySW50ZXJmYWNlcy5zZXQoaWQsIHJlbmRlcmVySW50ZXJmYWNlKTtcbiAgICB9XG5cbiAgICBob29rLmVtaXQoJ3JlbmRlcmVyJywge1xuICAgICAgaWQ6IGlkLFxuICAgICAgcmVuZGVyZXI6IHJlbmRlcmVyLFxuICAgICAgcmVhY3RCdWlsZFR5cGU6IHJlYWN0QnVpbGRUeXBlXG4gICAgfSk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG5cbiAgdmFyIGhhc0RldGVjdGVkQmFkRENFID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gc3ViKGV2ZW50LCBmbikge1xuICAgIGhvb2sub24oZXZlbnQsIGZuKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGhvb2sub2ZmKGV2ZW50LCBmbik7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uKGV2ZW50LCBmbikge1xuICAgIGlmICghbGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xuICAgIH1cblxuICAgIGxpc3RlbmVyc1tldmVudF0ucHVzaChmbik7XG4gIH1cblxuICBmdW5jdGlvbiBvZmYoZXZlbnQsIGZuKSB7XG4gICAgaWYgKCFsaXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gbGlzdGVuZXJzW2V2ZW50XS5pbmRleE9mKGZuKTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGxpc3RlbmVyc1tldmVudF0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG5cbiAgICBpZiAoIWxpc3RlbmVyc1tldmVudF0ubGVuZ3RoKSB7XG4gICAgICBkZWxldGUgbGlzdGVuZXJzW2V2ZW50XTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbWl0KGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKGxpc3RlbmVyc1tldmVudF0pIHtcbiAgICAgIGxpc3RlbmVyc1tldmVudF0ubWFwKGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4oZGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGaWJlclJvb3RzKHJlbmRlcmVySUQpIHtcbiAgICB2YXIgcm9vdHMgPSBmaWJlclJvb3RzO1xuXG4gICAgaWYgKCFyb290c1tyZW5kZXJlcklEXSkge1xuICAgICAgcm9vdHNbcmVuZGVyZXJJRF0gPSBuZXcgU2V0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvb3RzW3JlbmRlcmVySURdO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZmliZXIpIHtcbiAgICB2YXIgcmVuZGVyZXJJbnRlcmZhY2UgPSByZW5kZXJlckludGVyZmFjZXMuZ2V0KHJlbmRlcmVySUQpO1xuXG4gICAgaWYgKHJlbmRlcmVySW50ZXJmYWNlICE9IG51bGwpIHtcbiAgICAgIHJlbmRlcmVySW50ZXJmYWNlLmhhbmRsZUNvbW1pdEZpYmVyVW5tb3VudChmaWJlcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Db21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCwgcHJpb3JpdHlMZXZlbCkge1xuICAgIHZhciBtb3VudGVkUm9vdHMgPSBob29rLmdldEZpYmVyUm9vdHMocmVuZGVyZXJJRCk7XG4gICAgdmFyIGN1cnJlbnQgPSByb290LmN1cnJlbnQ7XG4gICAgdmFyIGlzS25vd25Sb290ID0gbW91bnRlZFJvb3RzLmhhcyhyb290KTtcbiAgICB2YXIgaXNVbm1vdW50aW5nID0gY3VycmVudC5tZW1vaXplZFN0YXRlID09IG51bGwgfHwgY3VycmVudC5tZW1vaXplZFN0YXRlLmVsZW1lbnQgPT0gbnVsbDsgLy8gS2VlcCB0cmFjayBvZiBtb3VudGVkIHJvb3RzIHNvIHdlIGNhbiBoeWRyYXRlIHdoZW4gRGV2VG9vbHMgY29ubmVjdC5cblxuICAgIGlmICghaXNLbm93blJvb3QgJiYgIWlzVW5tb3VudGluZykge1xuICAgICAgbW91bnRlZFJvb3RzLmFkZChyb290KTtcbiAgICB9IGVsc2UgaWYgKGlzS25vd25Sb290ICYmIGlzVW5tb3VudGluZykge1xuICAgICAgbW91bnRlZFJvb3RzLmRlbGV0ZShyb290KTtcbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyZXJJbnRlcmZhY2UgPSByZW5kZXJlckludGVyZmFjZXMuZ2V0KHJlbmRlcmVySUQpO1xuXG4gICAgaWYgKHJlbmRlcmVySW50ZXJmYWNlICE9IG51bGwpIHtcbiAgICAgIHJlbmRlcmVySW50ZXJmYWNlLmhhbmRsZUNvbW1pdEZpYmVyUm9vdChyb290LCBwcmlvcml0eUxldmVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblBvc3RDb21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCkge1xuICAgIHZhciByZW5kZXJlckludGVyZmFjZSA9IHJlbmRlcmVySW50ZXJmYWNlcy5nZXQocmVuZGVyZXJJRCk7XG5cbiAgICBpZiAocmVuZGVyZXJJbnRlcmZhY2UgIT0gbnVsbCkge1xuICAgICAgcmVuZGVyZXJJbnRlcmZhY2UuaGFuZGxlUG9zdENvbW1pdEZpYmVyUm9vdChyb290KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRTdHJpY3RNb2RlKHJlbmRlcmVySUQsIGlzU3RyaWN0TW9kZSkge1xuICAgIHZhciByZW5kZXJlckludGVyZmFjZSA9IHJlbmRlcmVySW50ZXJmYWNlcy5nZXQocmVuZGVyZXJJRCk7XG5cbiAgICBpZiAocmVuZGVyZXJJbnRlcmZhY2UgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzU3RyaWN0TW9kZSkge1xuICAgICAgICByZW5kZXJlckludGVyZmFjZS5wYXRjaENvbnNvbGVGb3JTdHJpY3RNb2RlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJlckludGVyZmFjZS51bnBhdGNoQ29uc29sZUZvclN0cmljdE1vZGUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gZHVyaW5nIGluaXRpYWwgcmVuZGVyIGluIHRoZSBleHRlbnNpb24gYmVmb3JlIERldlRvb2xzXG4gICAgICAvLyBmaW5pc2hlcyBpdHMgaGFuZHNoYWtlIHdpdGggdGhlIGluamVjdGVkIHJlbmRlcmVyXG4gICAgICBpZiAoaXNTdHJpY3RNb2RlKSB7XG4gICAgICAgIHZhciBoaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGUgPSB3aW5kb3cuX19SRUFDVF9ERVZUT09MU19ISURFX0NPTlNPTEVfTE9HU19JTl9TVFJJQ1RfTU9ERV9fID09PSB0cnVlO1xuICAgICAgICB2YXIgYnJvd3NlclRoZW1lID0gd2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfQlJPV1NFUl9USEVNRV9fO1xuICAgICAgICBwYXRjaENvbnNvbGVGb3JJbml0aWFsUmVuZGVySW5TdHJpY3RNb2RlKHtcbiAgICAgICAgICBoaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGU6IGhpZGVDb25zb2xlTG9nc0luU3RyaWN0TW9kZSxcbiAgICAgICAgICBicm93c2VyVGhlbWU6IGJyb3dzZXJUaGVtZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVucGF0Y2hDb25zb2xlRm9ySW5pdGlhbFJlbmRlckluU3RyaWN0TW9kZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBvcGVuTW9kdWxlUmFuZ2VzU3RhY2sgPSBbXTtcbiAgdmFyIG1vZHVsZVJhbmdlcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGdldFRvcFN0YWNrRnJhbWVTdHJpbmcoZXJyb3IpIHtcbiAgICB2YXIgZnJhbWVzID0gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgIHZhciBmcmFtZSA9IGZyYW1lcy5sZW5ndGggPiAxID8gZnJhbWVzWzFdIDogbnVsbDtcbiAgICByZXR1cm4gZnJhbWU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJbnRlcm5hbE1vZHVsZVJhbmdlcygpIHtcbiAgICByZXR1cm4gbW9kdWxlUmFuZ2VzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KGVycm9yKSB7XG4gICAgdmFyIHN0YXJ0U3RhY2tGcmFtZSA9IGdldFRvcFN0YWNrRnJhbWVTdHJpbmcoZXJyb3IpO1xuXG4gICAgaWYgKHN0YXJ0U3RhY2tGcmFtZSAhPT0gbnVsbCkge1xuICAgICAgb3Blbk1vZHVsZVJhbmdlc1N0YWNrLnB1c2goc3RhcnRTdGFja0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChlcnJvcikge1xuICAgIGlmIChvcGVuTW9kdWxlUmFuZ2VzU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHN0YXJ0U3RhY2tGcmFtZSA9IG9wZW5Nb2R1bGVSYW5nZXNTdGFjay5wb3AoKTtcbiAgICAgIHZhciBzdG9wU3RhY2tGcmFtZSA9IGdldFRvcFN0YWNrRnJhbWVTdHJpbmcoZXJyb3IpO1xuXG4gICAgICBpZiAoc3RvcFN0YWNrRnJhbWUgIT09IG51bGwpIHtcbiAgICAgICAgbW9kdWxlUmFuZ2VzLnB1c2goW3N0YXJ0U3RhY2tGcmFtZSwgc3RvcFN0YWNrRnJhbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gVE9ETzogTW9yZSBtZWFuaW5nZnVsIG5hbWVzIGZvciBcInJlbmRlcmVySW50ZXJmYWNlc1wiIGFuZCBcInJlbmRlcmVyc1wiLlxuXG5cbiAgdmFyIGZpYmVyUm9vdHMgPSB7fTtcbiAgdmFyIHJlbmRlcmVySW50ZXJmYWNlcyA9IG5ldyBNYXAoKTtcbiAgdmFyIGxpc3RlbmVycyA9IHt9O1xuICB2YXIgcmVuZGVyZXJzID0gbmV3IE1hcCgpO1xuICB2YXIgYmFja2VuZHMgPSBuZXcgTWFwKCk7XG4gIHZhciBob29rID0ge1xuICAgIHJlbmRlcmVySW50ZXJmYWNlczogcmVuZGVyZXJJbnRlcmZhY2VzLFxuICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxuICAgIGJhY2tlbmRzOiBiYWNrZW5kcyxcbiAgICAvLyBGYXN0IFJlZnJlc2ggZm9yIHdlYiByZWxpZXMgb24gdGhpcy5cbiAgICByZW5kZXJlcnM6IHJlbmRlcmVycyxcbiAgICBlbWl0OiBlbWl0LFxuICAgIGdldEZpYmVyUm9vdHM6IGdldEZpYmVyUm9vdHMsXG4gICAgaW5qZWN0OiBpbmplY3QsXG4gICAgb246IG9uLFxuICAgIG9mZjogb2ZmLFxuICAgIHN1Yjogc3ViLFxuICAgIC8vIFRoaXMgaXMgYSBsZWdhY3kgZmxhZy5cbiAgICAvLyBSZWFjdCB2MTYgY2hlY2tzIHRoZSBob29rIGZvciB0aGlzIHRvIGVuc3VyZSBEZXZUb29scyBpcyBuZXcgZW5vdWdoLlxuICAgIHN1cHBvcnRzRmliZXI6IHRydWUsXG4gICAgLy8gUmVhY3QgY2FsbHMgdGhlc2UgbWV0aG9kcy5cbiAgICBjaGVja0RDRTogY2hlY2tEQ0UsXG4gICAgb25Db21taXRGaWJlclVubW91bnQ6IG9uQ29tbWl0RmliZXJVbm1vdW50LFxuICAgIG9uQ29tbWl0RmliZXJSb290OiBvbkNvbW1pdEZpYmVyUm9vdCxcbiAgICBvblBvc3RDb21taXRGaWJlclJvb3Q6IG9uUG9zdENvbW1pdEZpYmVyUm9vdCxcbiAgICBzZXRTdHJpY3RNb2RlOiBzZXRTdHJpY3RNb2RlLFxuICAgIC8vIFNjaGVkdWxlIFByb2ZpbGVyIHJ1bnRpbWUgaGVscGVycy5cbiAgICAvLyBUaGVzZSBpbnRlcm5hbCBSZWFjdCBtb2R1bGVzIHRvIHJlcG9ydCB0aGVpciBvd24gYm91bmRhcmllc1xuICAgIC8vIHdoaWNoIGluIHR1cm4gZW5hYmxlcyB0aGUgcHJvZmlsZXIgdG8gZGltIG9yIGZpbHRlciBpbnRlcm5hbCBmcmFtZXMuXG4gICAgZ2V0SW50ZXJuYWxNb2R1bGVSYW5nZXM6IGdldEludGVybmFsTW9kdWxlUmFuZ2VzLFxuICAgIHJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydDogcmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0LFxuICAgIHJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wOiByZWdpc3RlckludGVybmFsTW9kdWxlU3RvcFxuICB9O1xuXG4gIGlmIChmYWxzZSkge31cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCAnX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fJywge1xuICAgIC8vIFRoaXMgcHJvcGVydHkgbmVlZHMgdG8gYmUgY29uZmlndXJhYmxlIGZvciB0aGUgdGVzdCBlbnZpcm9ubWVudCxcbiAgICAvLyBlbHNlIHdlIHdvbid0IGJlIGFibGUgdG8gZGVsZXRlIGFuZCByZWNyZWF0ZSBpdCBiZXR3ZWVuIHRlc3RzLlxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gaG9vaztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaG9vaztcbn1cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3JlbmRlcmVyLmpzICsgNiBtb2R1bGVzXG52YXIgYmFja2VuZF9yZW5kZXJlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvdHlwZXMuanNcbnZhciB0eXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy91dGlscy5qc1xudmFyIHNyY191dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9sZWdhY3kvdXRpbHMuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuZnVuY3Rpb24gZGVjb3JhdGUob2JqZWN0LCBhdHRyLCBmbikge1xuICB2YXIgb2xkID0gb2JqZWN0W2F0dHJdOyAvLyAkRmxvd0ZpeE1lW21pc3NpbmctdGhpcy1hbm5vdF0gd2VicGFjayBjb25maWcgbmVlZHMgdG8gYmUgdXBkYXRlZCB0byBhbGxvdyBgdGhpc2AgdHlwZSBhbm5vdGF0aW9uc1xuXG4gIG9iamVjdFthdHRyXSA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIG9sZCwgYXJndW1lbnRzKTtcbiAgfTtcblxuICByZXR1cm4gb2xkO1xufVxuZnVuY3Rpb24gZGVjb3JhdGVNYW55KHNvdXJjZSwgZm5zKSB7XG4gIHZhciBvbGRzID0ge307XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBmbnMpIHtcbiAgICBvbGRzW25hbWVdID0gZGVjb3JhdGUoc291cmNlLCBuYW1lLCBmbnNbbmFtZV0pO1xuICB9XG5cbiAgcmV0dXJuIG9sZHM7XG59XG5mdW5jdGlvbiByZXN0b3JlTWFueShzb3VyY2UsIG9sZHMpIHtcbiAgZm9yICh2YXIgbmFtZSBpbiBvbGRzKSB7XG4gICAgc291cmNlW25hbWVdID0gb2xkc1tuYW1lXTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW21pc3NpbmctdGhpcy1hbm5vdF0gd2VicGFjayBjb25maWcgbmVlZHMgdG8gYmUgdXBkYXRlZCB0byBhbGxvdyBgdGhpc2AgdHlwZSBhbm5vdGF0aW9uc1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZShpbnN0YW5jZSkge1xuICBpZiAodHlwZW9mIGluc3RhbmNlLmZvcmNlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgfSBlbHNlIGlmIChpbnN0YW5jZS51cGRhdGVyICE9IG51bGwgJiYgdHlwZW9mIGluc3RhbmNlLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgZnVuY3Rpb24gKCkge30sICdmb3JjZVVwZGF0ZScpO1xuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvbGVnYWN5L3JlbmRlcmVyLmpzXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZW5kZXJlcl9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiByZW5kZXJlcl9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIHJlbmRlcmVyX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgcmVuZGVyZXJfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IHJlbmRlcmVyX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiByZW5kZXJlcl90eXBlb2Yob2JqKTsgfVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gZ2V0RGF0YShpbnRlcm5hbEluc3RhbmNlKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG51bGw7XG4gIHZhciBrZXkgPSBudWxsOyAvLyAhPSB1c2VkIGRlbGliZXJhdGVseSBoZXJlIHRvIGNhdGNoIHVuZGVmaW5lZCBhbmQgbnVsbFxuXG4gIGlmIChpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAhPSBudWxsKSB7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LmtleSkge1xuICAgICAga2V5ID0gU3RyaW5nKGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LmtleSk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRUeXBlID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlb2YgZWxlbWVudFR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBkaXNwbGF5TmFtZSA9IGVsZW1lbnRUeXBlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnRUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkaXNwbGF5TmFtZSA9IE9iamVjdChzcmNfdXRpbHNbXCJoXCIgLyogZ2V0RGlzcGxheU5hbWUgKi9dKShlbGVtZW50VHlwZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAga2V5OiBrZXlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudFR5cGUoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAvLyAhPSB1c2VkIGRlbGliZXJhdGVseSBoZXJlIHRvIGNhdGNoIHVuZGVmaW5lZCBhbmQgbnVsbFxuICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgIT0gbnVsbCkge1xuICAgIHZhciBlbGVtZW50VHlwZSA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZW9mIGVsZW1lbnRUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgcHVibGljSW5zdGFuY2UgPSBpbnRlcm5hbEluc3RhbmNlLmdldFB1YmxpY0luc3RhbmNlKCk7XG5cbiAgICAgIGlmIChwdWJsaWNJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHlwZXNbXCJlXCIgLyogRWxlbWVudFR5cGVDbGFzcyAqL107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHlwZXNbXCJoXCIgLyogRWxlbWVudFR5cGVGdW5jdGlvbiAqL107XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudFR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdHlwZXNbXCJpXCIgLyogRWxlbWVudFR5cGVIb3N0Q29tcG9uZW50ICovXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHlwZXNbXCJrXCIgLyogRWxlbWVudFR5cGVPdGhlck9yVW5rbm93biAqL107XG59XG5cbmZ1bmN0aW9uIGdldENoaWxkcmVuKGludGVybmFsSW5zdGFuY2UpIHtcbiAgdmFyIGNoaWxkcmVuID0gW107IC8vIElmIHRoZSBwYXJlbnQgaXMgYSBuYXRpdmUgbm9kZSB3aXRob3V0IHJlbmRlcmVkIGNoaWxkcmVuLCBidXQgd2l0aFxuICAvLyBtdWx0aXBsZSBzdHJpbmcgY2hpbGRyZW4sIHRoZW4gdGhlIGBlbGVtZW50YCB0aGF0IGdldHMgcGFzc2VkIGluIGhlcmUgaXNcbiAgLy8gYSBwbGFpbiB2YWx1ZSAtLSBhIHN0cmluZyBvciBudW1iZXIuXG5cbiAgaWYgKHJlbmRlcmVyX3R5cGVvZihpbnRlcm5hbEluc3RhbmNlKSAhPT0gJ29iamVjdCcpIHsvLyBObyBjaGlsZHJlblxuICB9IGVsc2UgaWYgKGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50ID09PSBudWxsIHx8IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50ID09PSBmYWxzZSkgey8vIE5vIGNoaWxkcmVuXG4gIH0gZWxzZSBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQpIHtcbiAgICB2YXIgY2hpbGQgPSBpbnRlcm5hbEluc3RhbmNlLl9yZW5kZXJlZENvbXBvbmVudDtcblxuICAgIGlmIChnZXRFbGVtZW50VHlwZShjaGlsZCkgIT09IHR5cGVzW1wia1wiIC8qIEVsZW1lbnRUeXBlT3RoZXJPclVua25vd24gKi9dKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcmVuZGVyZWRDaGlsZHJlbikge1xuICAgIHZhciByZW5kZXJlZENoaWxkcmVuID0gaW50ZXJuYWxJbnN0YW5jZS5fcmVuZGVyZWRDaGlsZHJlbjtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gcmVuZGVyZWRDaGlsZHJlbikge1xuICAgICAgdmFyIF9jaGlsZCA9IHJlbmRlcmVkQ2hpbGRyZW5bbmFtZV07XG5cbiAgICAgIGlmIChnZXRFbGVtZW50VHlwZShfY2hpbGQpICE9PSB0eXBlc1tcImtcIiAvKiBFbGVtZW50VHlwZU90aGVyT3JVbmtub3duICovXSkge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKF9jaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIE5vdGU6IHdlIHNraXAgdGhlIGNhc2Ugd2hlcmUgY2hpbGRyZW4gYXJlIGp1c3Qgc3RyaW5ncyBvciBudW1iZXJzXG4gIC8vIGJlY2F1c2UgdGhlIG5ldyBEZXZUb29scyBza2lwcyBvdmVyIGhvc3QgdGV4dCBub2RlcyBhbnl3YXkuXG5cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGF0dGFjaChob29rLCByZW5kZXJlcklELCByZW5kZXJlciwgZ2xvYmFsKSB7XG4gIHZhciBpZFRvSW50ZXJuYWxJbnN0YW5jZU1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIGludGVybmFsSW5zdGFuY2VUb0lETWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgdmFyIGludGVybmFsSW5zdGFuY2VUb1Jvb3RJRE1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gIHZhciBnZXRJbnRlcm5hbElERm9yTmF0aXZlID0gbnVsbDtcbiAgdmFyIGZpbmROYXRpdmVOb2RlRm9ySW50ZXJuYWxJRDtcblxuICB2YXIgZ2V0RmliZXJGb3JOYXRpdmUgPSBmdW5jdGlvbiBnZXRGaWJlckZvck5hdGl2ZShub2RlKSB7XG4gICAgLy8gTm90IGltcGxlbWVudGVkLlxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIGlmIChyZW5kZXJlci5Db21wb25lbnRUcmVlKSB7XG4gICAgZ2V0SW50ZXJuYWxJREZvck5hdGl2ZSA9IGZ1bmN0aW9uIGdldEludGVybmFsSURGb3JOYXRpdmUobm9kZSwgZmluZE5lYXJlc3RVbmZpbHRlcmVkQW5jZXN0b3IpIHtcbiAgICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gcmVuZGVyZXIuQ29tcG9uZW50VHJlZS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShub2RlKTtcbiAgICAgIHJldHVybiBpbnRlcm5hbEluc3RhbmNlVG9JRE1hcC5nZXQoaW50ZXJuYWxJbnN0YW5jZSkgfHwgbnVsbDtcbiAgICB9O1xuXG4gICAgZmluZE5hdGl2ZU5vZGVGb3JJbnRlcm5hbElEID0gZnVuY3Rpb24gZmluZE5hdGl2ZU5vZGVGb3JJbnRlcm5hbElEKGlkKSB7XG4gICAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGlkVG9JbnRlcm5hbEluc3RhbmNlTWFwLmdldChpZCk7XG4gICAgICByZXR1cm4gcmVuZGVyZXIuQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGludGVybmFsSW5zdGFuY2UpO1xuICAgIH07XG5cbiAgICBnZXRGaWJlckZvck5hdGl2ZSA9IGZ1bmN0aW9uIGdldEZpYmVyRm9yTmF0aXZlKG5vZGUpIHtcbiAgICAgIHJldHVybiByZW5kZXJlci5Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5vZGUpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAocmVuZGVyZXIuTW91bnQuZ2V0SUQgJiYgcmVuZGVyZXIuTW91bnQuZ2V0Tm9kZSkge1xuICAgIGdldEludGVybmFsSURGb3JOYXRpdmUgPSBmdW5jdGlvbiBnZXRJbnRlcm5hbElERm9yTmF0aXZlKG5vZGUsIGZpbmROZWFyZXN0VW5maWx0ZXJlZEFuY2VzdG9yKSB7XG4gICAgICAvLyBOb3QgaW1wbGVtZW50ZWQuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgZmluZE5hdGl2ZU5vZGVGb3JJbnRlcm5hbElEID0gZnVuY3Rpb24gZmluZE5hdGl2ZU5vZGVGb3JJbnRlcm5hbElEKGlkKSB7XG4gICAgICAvLyBOb3QgaW1wbGVtZW50ZWQuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWVGb3JGaWJlcklEKGlkKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBpZFRvSW50ZXJuYWxJbnN0YW5jZU1hcC5nZXQoaWQpO1xuICAgIHJldHVybiBpbnRlcm5hbEluc3RhbmNlID8gZ2V0RGF0YShpbnRlcm5hbEluc3RhbmNlKS5kaXNwbGF5TmFtZSA6IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJRChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgaWYgKHJlbmRlcmVyX3R5cGVvZihpbnRlcm5hbEluc3RhbmNlKSAhPT0gJ29iamVjdCcgfHwgaW50ZXJuYWxJbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGludGVybmFsIGluc3RhbmNlOiAnICsgaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlVG9JRE1hcC5oYXMoaW50ZXJuYWxJbnN0YW5jZSkpIHtcbiAgICAgIHZhciBfaWQgPSBPYmplY3Qoc3JjX3V0aWxzW1wia1wiIC8qIGdldFVJRCAqL10pKCk7XG5cbiAgICAgIGludGVybmFsSW5zdGFuY2VUb0lETWFwLnNldChpbnRlcm5hbEluc3RhbmNlLCBfaWQpO1xuICAgICAgaWRUb0ludGVybmFsSW5zdGFuY2VNYXAuc2V0KF9pZCwgaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFsSW5zdGFuY2VUb0lETWFwLmdldChpbnRlcm5hbEluc3RhbmNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFyZUVxdWFsQXJyYXlzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gVGhpcyBpcyBzaGFyZWQgbXV0YWJsZSBzdGF0ZSB0aGF0IGxldHMgdXMga2VlcCB0cmFjayBvZiB3aGVyZSB3ZSBhcmUuXG5cblxuICB2YXIgcGFyZW50SURTdGFjayA9IFtdO1xuICB2YXIgb2xkUmVjb25jaWxlck1ldGhvZHMgPSBudWxsO1xuXG4gIGlmIChyZW5kZXJlci5SZWNvbmNpbGVyKSB7XG4gICAgLy8gUmVhY3QgMTVcbiAgICBvbGRSZWNvbmNpbGVyTWV0aG9kcyA9IGRlY29yYXRlTWFueShyZW5kZXJlci5SZWNvbmNpbGVyLCB7XG4gICAgICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gbW91bnRDb21wb25lbnQoZm4sIGFyZ3MpIHtcbiAgICAgICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgaG9zdENvbnRhaW5lckluZm8gPSBhcmdzWzNdO1xuXG4gICAgICAgIGlmIChnZXRFbGVtZW50VHlwZShpbnRlcm5hbEluc3RhbmNlKSA9PT0gdHlwZXNbXCJrXCIgLyogRWxlbWVudFR5cGVPdGhlck9yVW5rbm93biAqL10pIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lW29iamVjdC10aGlzLXJlZmVyZW5jZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChob3N0Q29udGFpbmVySW5mby5fdG9wTGV2ZWxXcmFwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBTU1JcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lW29iamVjdC10aGlzLXJlZmVyZW5jZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpZCA9IGdldElEKGludGVybmFsSW5zdGFuY2UpOyAvLyBQdXNoIHRoZSBvcGVyYXRpb24uXG5cbiAgICAgICAgdmFyIHBhcmVudElEID0gcGFyZW50SURTdGFjay5sZW5ndGggPiAwID8gcGFyZW50SURTdGFja1twYXJlbnRJRFN0YWNrLmxlbmd0aCAtIDFdIDogMDtcbiAgICAgICAgcmVjb3JkTW91bnQoaW50ZXJuYWxJbnN0YW5jZSwgaWQsIHBhcmVudElEKTtcbiAgICAgICAgcGFyZW50SURTdGFjay5wdXNoKGlkKTsgLy8gUmVtZW1iZXIgdGhlIHJvb3QuXG5cbiAgICAgICAgaW50ZXJuYWxJbnN0YW5jZVRvUm9vdElETWFwLnNldChpbnRlcm5hbEluc3RhbmNlLCBnZXRJRChob3N0Q29udGFpbmVySW5mby5fdG9wTGV2ZWxXcmFwcGVyKSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lW29iamVjdC10aGlzLXJlZmVyZW5jZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICBwYXJlbnRJRFN0YWNrLnBvcCgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgICBwYXJlbnRJRFN0YWNrID0gW107XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChwYXJlbnRJRFN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIHJvb3RJRCA9IGludGVybmFsSW5zdGFuY2VUb1Jvb3RJRE1hcC5nZXQoaW50ZXJuYWxJbnN0YW5jZSk7XG5cbiAgICAgICAgICAgIGlmIChyb290SUQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgcm9vdCBJRC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmx1c2hQZW5kaW5nRXZlbnRzKHJvb3RJRCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5OiBmdW5jdGlvbiBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkoZm4sIGFyZ3MpIHtcbiAgICAgICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBhcmdzWzBdO1xuXG4gICAgICAgIGlmIChnZXRFbGVtZW50VHlwZShpbnRlcm5hbEluc3RhbmNlKSA9PT0gdHlwZXNbXCJrXCIgLyogRWxlbWVudFR5cGVPdGhlck9yVW5rbm93biAqL10pIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lW29iamVjdC10aGlzLXJlZmVyZW5jZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpZCA9IGdldElEKGludGVybmFsSW5zdGFuY2UpO1xuICAgICAgICBwYXJlbnRJRFN0YWNrLnB1c2goaWQpO1xuICAgICAgICB2YXIgcHJldkNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oaW50ZXJuYWxJbnN0YW5jZSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lW29iamVjdC10aGlzLXJlZmVyZW5jZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICB2YXIgbmV4dENoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oaW50ZXJuYWxJbnN0YW5jZSk7XG5cbiAgICAgICAgICBpZiAoIWFyZUVxdWFsQXJyYXlzKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuKSkge1xuICAgICAgICAgICAgLy8gUHVzaCB0aGUgb3BlcmF0aW9uXG4gICAgICAgICAgICByZWNvcmRSZW9yZGVyKGludGVybmFsSW5zdGFuY2UsIGlkLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmVudElEU3RhY2sucG9wKCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICAgIHBhcmVudElEU3RhY2sgPSBbXTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKHBhcmVudElEU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgcm9vdElEID0gaW50ZXJuYWxJbnN0YW5jZVRvUm9vdElETWFwLmdldChpbnRlcm5hbEluc3RhbmNlKTtcblxuICAgICAgICAgICAgaWYgKHJvb3RJRCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCByb290IElELicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmbHVzaFBlbmRpbmdFdmVudHMocm9vdElEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiByZWNlaXZlQ29tcG9uZW50KGZuLCBhcmdzKSB7XG4gICAgICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gYXJnc1swXTtcblxuICAgICAgICBpZiAoZ2V0RWxlbWVudFR5cGUoaW50ZXJuYWxJbnN0YW5jZSkgPT09IHR5cGVzW1wia1wiIC8qIEVsZW1lbnRUeXBlT3RoZXJPclVua25vd24gKi9dKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVtvYmplY3QtdGhpcy1yZWZlcmVuY2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaWQgPSBnZXRJRChpbnRlcm5hbEluc3RhbmNlKTtcbiAgICAgICAgcGFyZW50SURTdGFjay5wdXNoKGlkKTtcbiAgICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IGdldENoaWxkcmVuKGludGVybmFsSW5zdGFuY2UpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVtvYmplY3QtdGhpcy1yZWZlcmVuY2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IGdldENoaWxkcmVuKGludGVybmFsSW5zdGFuY2UpO1xuXG4gICAgICAgICAgaWYgKCFhcmVFcXVhbEFycmF5cyhwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbikpIHtcbiAgICAgICAgICAgIC8vIFB1c2ggdGhlIG9wZXJhdGlvblxuICAgICAgICAgICAgcmVjb3JkUmVvcmRlcihpbnRlcm5hbEluc3RhbmNlLCBpZCwgbmV4dENoaWxkcmVuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJlbnRJRFN0YWNrLnBvcCgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgICBwYXJlbnRJRFN0YWNrID0gW107XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChwYXJlbnRJRFN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIHJvb3RJRCA9IGludGVybmFsSW5zdGFuY2VUb1Jvb3RJRE1hcC5nZXQoaW50ZXJuYWxJbnN0YW5jZSk7XG5cbiAgICAgICAgICAgIGlmIChyb290SUQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgcm9vdCBJRC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmx1c2hQZW5kaW5nRXZlbnRzKHJvb3RJRCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudChmbiwgYXJncykge1xuICAgICAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGFyZ3NbMF07XG5cbiAgICAgICAgaWYgKGdldEVsZW1lbnRUeXBlKGludGVybmFsSW5zdGFuY2UpID09PSB0eXBlc1tcImtcIiAvKiBFbGVtZW50VHlwZU90aGVyT3JVbmtub3duICovXSkge1xuICAgICAgICAgIC8vICRGbG93Rml4TWVbb2JqZWN0LXRoaXMtcmVmZXJlbmNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlkID0gZ2V0SUQoaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgICAgIHBhcmVudElEU3RhY2sucHVzaChpZCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lW29iamVjdC10aGlzLXJlZmVyZW5jZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICBwYXJlbnRJRFN0YWNrLnBvcCgpOyAvLyBQdXNoIHRoZSBvcGVyYXRpb24uXG5cbiAgICAgICAgICByZWNvcmRVbm1vdW50KGludGVybmFsSW5zdGFuY2UsIGlkKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgICAgcGFyZW50SURTdGFjayA9IFtdO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAocGFyZW50SURTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHZhciByb290SUQgPSBpbnRlcm5hbEluc3RhbmNlVG9Sb290SURNYXAuZ2V0KGludGVybmFsSW5zdGFuY2UpO1xuXG4gICAgICAgICAgICBpZiAocm9vdElEID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIHJvb3QgSUQuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZsdXNoUGVuZGluZ0V2ZW50cyhyb290SUQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBpZiAob2xkUmVjb25jaWxlck1ldGhvZHMgIT09IG51bGwpIHtcbiAgICAgIGlmIChyZW5kZXJlci5Db21wb25lbnQpIHtcbiAgICAgICAgcmVzdG9yZU1hbnkocmVuZGVyZXIuQ29tcG9uZW50Lk1peGluLCBvbGRSZWNvbmNpbGVyTWV0aG9kcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN0b3JlTWFueShyZW5kZXJlci5SZWNvbmNpbGVyLCBvbGRSZWNvbmNpbGVyTWV0aG9kcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb2xkUmVjb25jaWxlck1ldGhvZHMgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkTW91bnQoaW50ZXJuYWxJbnN0YW5jZSwgaWQsIHBhcmVudElEKSB7XG4gICAgdmFyIGlzUm9vdCA9IHBhcmVudElEID09PSAwO1xuXG4gICAgaWYgKGNvbnN0YW50c1tcInNcIiAvKiBfX0RFQlVHX18gKi9dKSB7XG4gICAgICBjb25zb2xlLmxvZygnJWNyZWNvcmRNb3VudCgpJywgJ2NvbG9yOiBncmVlbjsgZm9udC13ZWlnaHQ6IGJvbGQ7JywgaWQsIGdldERhdGEoaW50ZXJuYWxJbnN0YW5jZSkuZGlzcGxheU5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgIC8vIFRPRE8gSXMgdGhpcyByaWdodD8gRm9yIGFsbCB2ZXJzaW9ucz9cbiAgICAgIHZhciBoYXNPd25lck1ldGFkYXRhID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgIT0gbnVsbCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIgIT0gbnVsbDtcbiAgICAgIHB1c2hPcGVyYXRpb24oY29uc3RhbnRzW1wibFwiIC8qIFRSRUVfT1BFUkFUSU9OX0FERCAqL10pO1xuICAgICAgcHVzaE9wZXJhdGlvbihpZCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKHR5cGVzW1wibVwiIC8qIEVsZW1lbnRUeXBlUm9vdCAqL10pO1xuICAgICAgcHVzaE9wZXJhdGlvbigwKTsgLy8gU3RyaWN0TW9kZSBjb21wbGlhbnQ/XG5cbiAgICAgIHB1c2hPcGVyYXRpb24oMCk7IC8vIFByb2ZpbGluZyBmbGFnXG5cbiAgICAgIHB1c2hPcGVyYXRpb24oMCk7IC8vIFN0cmljdE1vZGUgc3VwcG9ydGVkP1xuXG4gICAgICBwdXNoT3BlcmF0aW9uKGhhc093bmVyTWV0YWRhdGEgPyAxIDogMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0eXBlID0gZ2V0RWxlbWVudFR5cGUoaW50ZXJuYWxJbnN0YW5jZSk7XG5cbiAgICAgIHZhciBfZ2V0RGF0YSA9IGdldERhdGEoaW50ZXJuYWxJbnN0YW5jZSksXG4gICAgICAgICAgZGlzcGxheU5hbWUgPSBfZ2V0RGF0YS5kaXNwbGF5TmFtZSxcbiAgICAgICAgICBrZXkgPSBfZ2V0RGF0YS5rZXk7XG5cbiAgICAgIHZhciBvd25lcklEID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgIT0gbnVsbCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIgIT0gbnVsbCA/IGdldElEKGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcikgOiAwO1xuICAgICAgdmFyIGRpc3BsYXlOYW1lU3RyaW5nSUQgPSBnZXRTdHJpbmdJRChkaXNwbGF5TmFtZSk7XG4gICAgICB2YXIga2V5U3RyaW5nSUQgPSBnZXRTdHJpbmdJRChrZXkpO1xuICAgICAgcHVzaE9wZXJhdGlvbihjb25zdGFudHNbXCJsXCIgLyogVFJFRV9PUEVSQVRJT05fQUREICovXSk7XG4gICAgICBwdXNoT3BlcmF0aW9uKGlkKTtcbiAgICAgIHB1c2hPcGVyYXRpb24odHlwZSk7XG4gICAgICBwdXNoT3BlcmF0aW9uKHBhcmVudElEKTtcbiAgICAgIHB1c2hPcGVyYXRpb24ob3duZXJJRCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKGRpc3BsYXlOYW1lU3RyaW5nSUQpO1xuICAgICAgcHVzaE9wZXJhdGlvbihrZXlTdHJpbmdJRCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkUmVvcmRlcihpbnRlcm5hbEluc3RhbmNlLCBpZCwgbmV4dENoaWxkcmVuKSB7XG4gICAgcHVzaE9wZXJhdGlvbihjb25zdGFudHNbXCJvXCIgLyogVFJFRV9PUEVSQVRJT05fUkVPUkRFUl9DSElMRFJFTiAqL10pO1xuICAgIHB1c2hPcGVyYXRpb24oaWQpO1xuICAgIHZhciBuZXh0Q2hpbGRJRHMgPSBuZXh0Q2hpbGRyZW4ubWFwKGdldElEKTtcbiAgICBwdXNoT3BlcmF0aW9uKG5leHRDaGlsZElEcy5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXh0Q2hpbGRJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHB1c2hPcGVyYXRpb24obmV4dENoaWxkSURzW2ldKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmRVbm1vdW50KGludGVybmFsSW5zdGFuY2UsIGlkKSB7XG4gICAgcGVuZGluZ1VubW91bnRlZElEcy5wdXNoKGlkKTtcbiAgICBpZFRvSW50ZXJuYWxJbnN0YW5jZU1hcC5kZWxldGUoaWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3Jhd2xBbmRSZWNvcmRJbml0aWFsTW91bnRzKGlkLCBwYXJlbnRJRCwgcm9vdElEKSB7XG4gICAgaWYgKGNvbnN0YW50c1tcInNcIiAvKiBfX0RFQlVHX18gKi9dKSB7XG4gICAgICBjb25zb2xlLmdyb3VwKCdjcmF3bEFuZFJlY29yZEluaXRpYWxNb3VudHMoKSBpZDonLCBpZCk7XG4gICAgfVxuXG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBpZFRvSW50ZXJuYWxJbnN0YW5jZU1hcC5nZXQoaWQpO1xuXG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZVRvUm9vdElETWFwLnNldChpbnRlcm5hbEluc3RhbmNlLCByb290SUQpO1xuICAgICAgcmVjb3JkTW91bnQoaW50ZXJuYWxJbnN0YW5jZSwgaWQsIHBhcmVudElEKTtcbiAgICAgIGdldENoaWxkcmVuKGludGVybmFsSW5zdGFuY2UpLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBjcmF3bEFuZFJlY29yZEluaXRpYWxNb3VudHMoZ2V0SUQoY2hpbGQpLCBpZCwgcm9vdElEKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChjb25zdGFudHNbXCJzXCIgLyogX19ERUJVR19fICovXSkge1xuICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoSW5pdGlhbE9wZXJhdGlvbnMoKSB7XG4gICAgLy8gQ3Jhd2wgcm9vdHMgdGhvdWdoIGFuZCByZWdpc3RlciBhbnkgbm9kZXMgdGhhdCBtb3VudGVkIGJlZm9yZSB3ZSB3ZXJlIGluamVjdGVkLlxuICAgIHZhciByb290cyA9IHJlbmRlcmVyLk1vdW50Ll9pbnN0YW5jZXNCeVJlYWN0Um9vdElEIHx8IHJlbmRlcmVyLk1vdW50Ll9pbnN0YW5jZXNCeUNvbnRhaW5lcklEO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHJvb3RzKSB7XG4gICAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IHJvb3RzW2tleV07XG5cbiAgICAgIHZhciBfaWQyID0gZ2V0SUQoaW50ZXJuYWxJbnN0YW5jZSk7XG5cbiAgICAgIGNyYXdsQW5kUmVjb3JkSW5pdGlhbE1vdW50cyhfaWQyLCAwLCBfaWQyKTtcbiAgICAgIGZsdXNoUGVuZGluZ0V2ZW50cyhfaWQyKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGVuZGluZ09wZXJhdGlvbnMgPSBbXTtcbiAgdmFyIHBlbmRpbmdTdHJpbmdUYWJsZSA9IG5ldyBNYXAoKTtcbiAgdmFyIHBlbmRpbmdVbm1vdW50ZWRJRHMgPSBbXTtcbiAgdmFyIHBlbmRpbmdTdHJpbmdUYWJsZUxlbmd0aCA9IDA7XG4gIHZhciBwZW5kaW5nVW5tb3VudGVkUm9vdElEID0gbnVsbDtcblxuICBmdW5jdGlvbiBmbHVzaFBlbmRpbmdFdmVudHMocm9vdElEKSB7XG4gICAgaWYgKHBlbmRpbmdPcGVyYXRpb25zLmxlbmd0aCA9PT0gMCAmJiBwZW5kaW5nVW5tb3VudGVkSURzLmxlbmd0aCA9PT0gMCAmJiBwZW5kaW5nVW5tb3VudGVkUm9vdElEID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG51bVVubW91bnRJRHMgPSBwZW5kaW5nVW5tb3VudGVkSURzLmxlbmd0aCArIChwZW5kaW5nVW5tb3VudGVkUm9vdElEID09PSBudWxsID8gMCA6IDEpO1xuICAgIHZhciBvcGVyYXRpb25zID0gbmV3IEFycmF5KCAvLyBJZGVudGlmeSB3aGljaCByZW5kZXJlciB0aGlzIHVwZGF0ZSBpcyBjb21pbmcgZnJvbS5cbiAgICAyICsgLy8gW3JlbmRlcmVySUQsIHJvb3RGaWJlcklEXVxuICAgIC8vIEhvdyBiaWcgaXMgdGhlIHN0cmluZyB0YWJsZT9cbiAgICAxICsgLy8gW3N0cmluZ1RhYmxlTGVuZ3RoXVxuICAgIC8vIFRoZW4gZ29lcyB0aGUgYWN0dWFsIHN0cmluZyB0YWJsZS5cbiAgICBwZW5kaW5nU3RyaW5nVGFibGVMZW5ndGggKyAoIC8vIEFsbCB1bm1vdW50cyBhcmUgYmF0Y2hlZCBpbiBhIHNpbmdsZSBtZXNzYWdlLlxuICAgIC8vIFtUUkVFX09QRVJBVElPTl9SRU1PVkUsIHJlbW92ZWRJRExlbmd0aCwgLi4uaWRzXVxuICAgIG51bVVubW91bnRJRHMgPiAwID8gMiArIG51bVVubW91bnRJRHMgOiAwKSArIC8vIE1vdW50IG9wZXJhdGlvbnNcbiAgICBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGgpOyAvLyBJZGVudGlmeSB3aGljaCByZW5kZXJlciB0aGlzIHVwZGF0ZSBpcyBjb21pbmcgZnJvbS5cbiAgICAvLyBUaGlzIGVuYWJsZXMgcm9vdHMgdG8gYmUgbWFwcGVkIHRvIHJlbmRlcmVycyxcbiAgICAvLyBXaGljaCBpbiB0dXJuIGVuYWJsZXMgZmliZXIgcHJvcGVyYXRpb25zLCBzdGF0ZXMsIGFuZCBob29rcyB0byBiZSBpbnNwZWN0ZWQuXG5cbiAgICB2YXIgaSA9IDA7XG4gICAgb3BlcmF0aW9uc1tpKytdID0gcmVuZGVyZXJJRDtcbiAgICBvcGVyYXRpb25zW2krK10gPSByb290SUQ7IC8vIE5vdyBmaWxsIGluIHRoZSBzdHJpbmcgdGFibGUuXG4gICAgLy8gW3N0cmluZ1RhYmxlTGVuZ3RoLCBzdHIxTGVuZ3RoLCAuLi5zdHIxLCBzdHIyTGVuZ3RoLCAuLi5zdHIyLCAuLi5dXG5cbiAgICBvcGVyYXRpb25zW2krK10gPSBwZW5kaW5nU3RyaW5nVGFibGVMZW5ndGg7XG4gICAgcGVuZGluZ1N0cmluZ1RhYmxlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIG9wZXJhdGlvbnNbaSsrXSA9IGtleS5sZW5ndGg7XG4gICAgICB2YXIgZW5jb2RlZEtleSA9IE9iamVjdChzcmNfdXRpbHNbXCJwXCIgLyogdXRmRW5jb2RlU3RyaW5nICovXSkoa2V5KTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbmNvZGVkS2V5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG9wZXJhdGlvbnNbaSArIGpdID0gZW5jb2RlZEtleVtqXTtcbiAgICAgIH1cblxuICAgICAgaSArPSBrZXkubGVuZ3RoO1xuICAgIH0pO1xuXG4gICAgaWYgKG51bVVubW91bnRJRHMgPiAwKSB7XG4gICAgICAvLyBBbGwgdW5tb3VudHMgZXhjZXB0IHJvb3RzIGFyZSBiYXRjaGVkIGluIGEgc2luZ2xlIG1lc3NhZ2UuXG4gICAgICBvcGVyYXRpb25zW2krK10gPSBjb25zdGFudHNbXCJtXCIgLyogVFJFRV9PUEVSQVRJT05fUkVNT1ZFICovXTsgLy8gVGhlIGZpcnN0IG51bWJlciBpcyBob3cgbWFueSB1bm1vdW50ZWQgSURzIHdlJ3JlIGdvbm5hIHNlbmQuXG5cbiAgICAgIG9wZXJhdGlvbnNbaSsrXSA9IG51bVVubW91bnRJRHM7IC8vIEZpbGwgaW4gdGhlIHVubW91bnRzXG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGVuZGluZ1VubW91bnRlZElEcy5sZW5ndGg7IGorKykge1xuICAgICAgICBvcGVyYXRpb25zW2krK10gPSBwZW5kaW5nVW5tb3VudGVkSURzW2pdO1xuICAgICAgfSAvLyBUaGUgcm9vdCBJRCBzaG91bGQgYWx3YXlzIGJlIHVubW91bnRlZCBsYXN0LlxuXG5cbiAgICAgIGlmIChwZW5kaW5nVW5tb3VudGVkUm9vdElEICE9PSBudWxsKSB7XG4gICAgICAgIG9wZXJhdGlvbnNbaV0gPSBwZW5kaW5nVW5tb3VudGVkUm9vdElEO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfSAvLyBGaWxsIGluIHRoZSByZXN0IG9mIHRoZSBvcGVyYXRpb25zLlxuXG5cbiAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgcGVuZGluZ09wZXJhdGlvbnMubGVuZ3RoOyBfaisrKSB7XG4gICAgICBvcGVyYXRpb25zW2kgKyBfal0gPSBwZW5kaW5nT3BlcmF0aW9uc1tfal07XG4gICAgfVxuXG4gICAgaSArPSBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGg7XG5cbiAgICBpZiAoY29uc3RhbnRzW1wic1wiIC8qIF9fREVCVUdfXyAqL10pIHtcbiAgICAgIE9iamVjdChzcmNfdXRpbHNbXCJtXCIgLyogcHJpbnRPcGVyYXRpb25zQXJyYXkgKi9dKShvcGVyYXRpb25zKTtcbiAgICB9IC8vIElmIHdlJ3ZlIGFscmVhZHkgY29ubmVjdGVkIHRvIHRoZSBmcm9udGVuZCwganVzdCBwYXNzIHRoZSBvcGVyYXRpb25zIHRocm91Z2guXG5cblxuICAgIGhvb2suZW1pdCgnb3BlcmF0aW9ucycsIG9wZXJhdGlvbnMpO1xuICAgIHBlbmRpbmdPcGVyYXRpb25zLmxlbmd0aCA9IDA7XG4gICAgcGVuZGluZ1VubW91bnRlZElEcyA9IFtdO1xuICAgIHBlbmRpbmdVbm1vdW50ZWRSb290SUQgPSBudWxsO1xuICAgIHBlbmRpbmdTdHJpbmdUYWJsZS5jbGVhcigpO1xuICAgIHBlbmRpbmdTdHJpbmdUYWJsZUxlbmd0aCA9IDA7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoT3BlcmF0aW9uKG9wKSB7XG4gICAgaWYgKGZhbHNlKSB7fVxuXG4gICAgcGVuZGluZ09wZXJhdGlvbnMucHVzaChvcCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTdHJpbmdJRChzdHIpIHtcbiAgICBpZiAoc3RyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgZXhpc3RpbmdJRCA9IHBlbmRpbmdTdHJpbmdUYWJsZS5nZXQoc3RyKTtcblxuICAgIGlmIChleGlzdGluZ0lEICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBleGlzdGluZ0lEO1xuICAgIH1cblxuICAgIHZhciBzdHJpbmdJRCA9IHBlbmRpbmdTdHJpbmdUYWJsZS5zaXplICsgMTtcbiAgICBwZW5kaW5nU3RyaW5nVGFibGUuc2V0KHN0ciwgc3RyaW5nSUQpOyAvLyBUaGUgc3RyaW5nIHRhYmxlIHRvdGFsIGxlbmd0aCBuZWVkcyB0byBhY2NvdW50XG4gICAgLy8gYm90aCBmb3IgdGhlIHN0cmluZyBsZW5ndGgsIGFuZCBmb3IgdGhlIGFycmF5IGl0ZW1cbiAgICAvLyB0aGF0IGNvbnRhaW5zIHRoZSBsZW5ndGggaXRzZWxmLiBIZW5jZSArIDEuXG5cbiAgICBwZW5kaW5nU3RyaW5nVGFibGVMZW5ndGggKz0gc3RyLmxlbmd0aCArIDE7XG4gICAgcmV0dXJuIHN0cmluZ0lEO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRseUluc3BlY3RlZEVsZW1lbnRJRCA9IG51bGw7XG4gIHZhciBjdXJyZW50bHlJbnNwZWN0ZWRQYXRocyA9IHt9OyAvLyBUcmFjayB0aGUgaW50ZXJzZWN0aW9uIG9mIGN1cnJlbnRseSBpbnNwZWN0ZWQgcGF0aHMsXG4gIC8vIHNvIHRoYXQgd2UgY2FuIHNlbmQgdGhlaXIgZGF0YSBhbG9uZyBpZiB0aGUgZWxlbWVudCBpcyByZS1yZW5kZXJlZC5cblxuICBmdW5jdGlvbiBtZXJnZUluc3BlY3RlZFBhdGhzKHBhdGgpIHtcbiAgICB2YXIgY3VycmVudCA9IGN1cnJlbnRseUluc3BlY3RlZFBhdGhzO1xuICAgIHBhdGguZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoIWN1cnJlbnRba2V5XSkge1xuICAgICAgICBjdXJyZW50W2tleV0gPSB7fTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudCA9IGN1cnJlbnRba2V5XTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUlzUGF0aEFsbG93ZWQoa2V5KSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBoZWxwcyBwcmV2ZW50IHByZXZpb3VzbHktaW5zcGVjdGVkIHBhdGhzIGZyb20gYmVpbmcgZGVoeWRyYXRlZCBpbiB1cGRhdGVzLlxuICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IHRvIGF2b2lkIGEgYmFkIHVzZXIgZXhwZXJpZW5jZSB3aGVyZSBleHBhbmRlZCB0b2dnbGVzIGNvbGxhcHNlIG9uIHVwZGF0ZS5cbiAgICByZXR1cm4gZnVuY3Rpb24gaXNQYXRoQWxsb3dlZChwYXRoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGN1cnJlbnRseUluc3BlY3RlZFBhdGhzW2tleV07XG5cbiAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwYXRoW2ldXTtcblxuICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfSAvLyBGYXN0IHBhdGggcHJvcHMgbG9va3VwIGZvciBSZWFjdCBOYXRpdmUgc3R5bGUgZWRpdG9yLlxuXG5cbiAgZnVuY3Rpb24gZ2V0SW5zdGFuY2VBbmRTdHlsZShpZCkge1xuICAgIHZhciBpbnN0YW5jZSA9IG51bGw7XG4gICAgdmFyIHN0eWxlID0gbnVsbDtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGlkVG9JbnRlcm5hbEluc3RhbmNlTWFwLmdldChpZCk7XG5cbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICBpbnN0YW5jZSA9IGludGVybmFsSW5zdGFuY2UuX2luc3RhbmNlIHx8IG51bGw7XG4gICAgICB2YXIgZWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuXG4gICAgICBpZiAoZWxlbWVudCAhPSBudWxsICYmIGVsZW1lbnQucHJvcHMgIT0gbnVsbCkge1xuICAgICAgICBzdHlsZSA9IGVsZW1lbnQucHJvcHMuc3R5bGUgfHwgbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgc3R5bGU6IHN0eWxlXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGVkRWxlbWVudChpZCkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gaWRUb0ludGVybmFsSW5zdGFuY2VNYXAuZ2V0KGlkKTtcblxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlID09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIGluc3RhbmNlIHdpdGggaWQgXFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGdldEVsZW1lbnRUeXBlKGludGVybmFsSW5zdGFuY2UpKSB7XG4gICAgICBjYXNlIHR5cGVzW1wiZVwiIC8qIEVsZW1lbnRUeXBlQ2xhc3MgKi9dOlxuICAgICAgICBnbG9iYWwuJHIgPSBpbnRlcm5hbEluc3RhbmNlLl9pbnN0YW5jZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgdHlwZXNbXCJoXCIgLyogRWxlbWVudFR5cGVGdW5jdGlvbiAqL106XG4gICAgICAgIHZhciBlbGVtZW50ID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIGVsZW1lbnQgd2l0aCBpZCBcXFwiXCIuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsb2JhbC4kciA9IHtcbiAgICAgICAgICBwcm9wczogZWxlbWVudC5wcm9wcyxcbiAgICAgICAgICB0eXBlOiBlbGVtZW50LnR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGdsb2JhbC4kciA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0b3JlQXNHbG9iYWwoaWQsIHBhdGgsIGNvdW50KSB7XG4gICAgdmFyIGluc3BlY3RlZEVsZW1lbnQgPSBpbnNwZWN0RWxlbWVudFJhdyhpZCk7XG5cbiAgICBpZiAoaW5zcGVjdGVkRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHZhbHVlID0gT2JqZWN0KHNyY191dGlsc1tcImpcIiAvKiBnZXRJbk9iamVjdCAqL10pKGluc3BlY3RlZEVsZW1lbnQsIHBhdGgpO1xuICAgICAgdmFyIGtleSA9IFwiJHJlYWN0VGVtcFwiLmNvbmNhdChjb3VudCk7XG4gICAgICB3aW5kb3dba2V5XSA9IHZhbHVlO1xuICAgICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTZXJpYWxpemVkRWxlbWVudFZhbHVlQnlQYXRoKGlkLCBwYXRoKSB7XG4gICAgdmFyIGluc3BlY3RlZEVsZW1lbnQgPSBpbnNwZWN0RWxlbWVudFJhdyhpZCk7XG5cbiAgICBpZiAoaW5zcGVjdGVkRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHZhbHVlVG9Db3B5ID0gT2JqZWN0KHNyY191dGlsc1tcImpcIiAvKiBnZXRJbk9iamVjdCAqL10pKGluc3BlY3RlZEVsZW1lbnQsIHBhdGgpO1xuICAgICAgcmV0dXJuIE9iamVjdCh1dGlsc1tcImxcIiAvKiBzZXJpYWxpemVUb1N0cmluZyAqL10pKHZhbHVlVG9Db3B5KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnNwZWN0RWxlbWVudChyZXF1ZXN0SUQsIGlkLCBwYXRoLCBmb3JjZUZ1bGxEYXRhKSB7XG4gICAgaWYgKGZvcmNlRnVsbERhdGEgfHwgY3VycmVudGx5SW5zcGVjdGVkRWxlbWVudElEICE9PSBpZCkge1xuICAgICAgY3VycmVudGx5SW5zcGVjdGVkRWxlbWVudElEID0gaWQ7XG4gICAgICBjdXJyZW50bHlJbnNwZWN0ZWRQYXRocyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBpbnNwZWN0ZWRFbGVtZW50ID0gaW5zcGVjdEVsZW1lbnRSYXcoaWQpO1xuXG4gICAgaWYgKGluc3BlY3RlZEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgcmVzcG9uc2VJRDogcmVxdWVzdElELFxuICAgICAgICB0eXBlOiAnbm90LWZvdW5kJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAocGF0aCAhPT0gbnVsbCkge1xuICAgICAgbWVyZ2VJbnNwZWN0ZWRQYXRocyhwYXRoKTtcbiAgICB9IC8vIEFueSB0aW1lIGFuIGluc3BlY3RlZCBlbGVtZW50IGhhcyBhbiB1cGRhdGUsXG4gICAgLy8gd2Ugc2hvdWxkIHVwZGF0ZSB0aGUgc2VsZWN0ZWQgJHIgdmFsdWUgYXMgd2VsLlxuICAgIC8vIERvIHRoaXMgYmVmb3JlIGRlaHlkcmF0aW9uIChjbGVhbkZvckJyaWRnZSkuXG5cblxuICAgIHVwZGF0ZVNlbGVjdGVkRWxlbWVudChpZCk7XG4gICAgaW5zcGVjdGVkRWxlbWVudC5jb250ZXh0ID0gT2JqZWN0KHV0aWxzW1wiYVwiIC8qIGNsZWFuRm9yQnJpZGdlICovXSkoaW5zcGVjdGVkRWxlbWVudC5jb250ZXh0LCBjcmVhdGVJc1BhdGhBbGxvd2VkKCdjb250ZXh0JykpO1xuICAgIGluc3BlY3RlZEVsZW1lbnQucHJvcHMgPSBPYmplY3QodXRpbHNbXCJhXCIgLyogY2xlYW5Gb3JCcmlkZ2UgKi9dKShpbnNwZWN0ZWRFbGVtZW50LnByb3BzLCBjcmVhdGVJc1BhdGhBbGxvd2VkKCdwcm9wcycpKTtcbiAgICBpbnNwZWN0ZWRFbGVtZW50LnN0YXRlID0gT2JqZWN0KHV0aWxzW1wiYVwiIC8qIGNsZWFuRm9yQnJpZGdlICovXSkoaW5zcGVjdGVkRWxlbWVudC5zdGF0ZSwgY3JlYXRlSXNQYXRoQWxsb3dlZCgnc3RhdGUnKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHJlc3BvbnNlSUQ6IHJlcXVlc3RJRCxcbiAgICAgIHR5cGU6ICdmdWxsLWRhdGEnLFxuICAgICAgdmFsdWU6IGluc3BlY3RlZEVsZW1lbnRcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zcGVjdEVsZW1lbnRSYXcoaWQpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGlkVG9JbnRlcm5hbEluc3RhbmNlTWFwLmdldChpZCk7XG5cbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgX2dldERhdGEyID0gZ2V0RGF0YShpbnRlcm5hbEluc3RhbmNlKSxcbiAgICAgICAgZGlzcGxheU5hbWUgPSBfZ2V0RGF0YTIuZGlzcGxheU5hbWUsXG4gICAgICAgIGtleSA9IF9nZXREYXRhMi5rZXk7XG5cbiAgICB2YXIgdHlwZSA9IGdldEVsZW1lbnRUeXBlKGludGVybmFsSW5zdGFuY2UpO1xuICAgIHZhciBjb250ZXh0ID0gbnVsbDtcbiAgICB2YXIgb3duZXJzID0gbnVsbDtcbiAgICB2YXIgcHJvcHMgPSBudWxsO1xuICAgIHZhciBzdGF0ZSA9IG51bGw7XG4gICAgdmFyIHNvdXJjZSA9IG51bGw7XG4gICAgdmFyIGVsZW1lbnQgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcblxuICAgIGlmIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICBwcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gICAgICBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2UgIT0gbnVsbCA/IGVsZW1lbnQuX3NvdXJjZSA6IG51bGw7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIG93bmVycyA9IFtdO1xuXG4gICAgICAgIHdoaWxlIChvd25lciAhPSBudWxsKSB7XG4gICAgICAgICAgb3duZXJzLnB1c2goe1xuICAgICAgICAgICAgZGlzcGxheU5hbWU6IGdldERhdGEob3duZXIpLmRpc3BsYXlOYW1lIHx8ICdVbmtub3duJyxcbiAgICAgICAgICAgIGlkOiBnZXRJRChvd25lciksXG4gICAgICAgICAgICBrZXk6IGVsZW1lbnQua2V5LFxuICAgICAgICAgICAgdHlwZTogZ2V0RWxlbWVudFR5cGUob3duZXIpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAob3duZXIuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICBvd25lciA9IG93bmVyLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHB1YmxpY0luc3RhbmNlID0gaW50ZXJuYWxJbnN0YW5jZS5faW5zdGFuY2U7XG5cbiAgICBpZiAocHVibGljSW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgY29udGV4dCA9IHB1YmxpY0luc3RhbmNlLmNvbnRleHQgfHwgbnVsbDtcbiAgICAgIHN0YXRlID0gcHVibGljSW5zdGFuY2Uuc3RhdGUgfHwgbnVsbDtcbiAgICB9IC8vIE5vdCBpbXBsZW1lbnRlZFxuXG5cbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIHdhcm5pbmdzID0gW107XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIC8vIERvZXMgdGhlIGN1cnJlbnQgcmVuZGVyZXIgc3VwcG9ydCBlZGl0YWJsZSBob29rcyBhbmQgZnVuY3Rpb24gcHJvcHM/XG4gICAgICBjYW5FZGl0SG9va3M6IGZhbHNlLFxuICAgICAgY2FuRWRpdEZ1bmN0aW9uUHJvcHM6IGZhbHNlLFxuICAgICAgLy8gRG9lcyB0aGUgY3VycmVudCByZW5kZXJlciBzdXBwb3J0IGFkdmFuY2VkIGVkaXRpbmcgaW50ZXJmYWNlP1xuICAgICAgY2FuRWRpdEhvb2tzQW5kRGVsZXRlUGF0aHM6IGZhbHNlLFxuICAgICAgY2FuRWRpdEhvb2tzQW5kUmVuYW1lUGF0aHM6IGZhbHNlLFxuICAgICAgY2FuRWRpdEZ1bmN0aW9uUHJvcHNEZWxldGVQYXRoczogZmFsc2UsXG4gICAgICBjYW5FZGl0RnVuY3Rpb25Qcm9wc1JlbmFtZVBhdGhzOiBmYWxzZSxcbiAgICAgIC8vIFRvZ2dsZSBlcnJvciBib3VuZGFyeSBkaWQgbm90IGV4aXN0IGluIGxlZ2FjeSB2ZXJzaW9uc1xuICAgICAgY2FuVG9nZ2xlRXJyb3I6IGZhbHNlLFxuICAgICAgaXNFcnJvcmVkOiBmYWxzZSxcbiAgICAgIHRhcmdldEVycm9yQm91bmRhcnlJRDogbnVsbCxcbiAgICAgIC8vIFN1c3BlbnNlIGRpZCBub3QgZXhpc3QgaW4gbGVnYWN5IHZlcnNpb25zXG4gICAgICBjYW5Ub2dnbGVTdXNwZW5zZTogZmFsc2UsXG4gICAgICAvLyBDYW4gdmlldyBjb21wb25lbnQgc291cmNlIGxvY2F0aW9uLlxuICAgICAgY2FuVmlld1NvdXJjZTogdHlwZSA9PT0gdHlwZXNbXCJlXCIgLyogRWxlbWVudFR5cGVDbGFzcyAqL10gfHwgdHlwZSA9PT0gdHlwZXNbXCJoXCIgLyogRWxlbWVudFR5cGVGdW5jdGlvbiAqL10sXG4gICAgICAvLyBPbmx5IGxlZ2FjeSBjb250ZXh0IGV4aXN0cyBpbiBsZWdhY3kgdmVyc2lvbnMuXG4gICAgICBoYXNMZWdhY3lDb250ZXh0OiB0cnVlLFxuICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGtleToga2V5ICE9IG51bGwgPyBrZXkgOiBudWxsLFxuICAgICAgLy8gSW5zcGVjdGFibGUgcHJvcGVydGllcy5cbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBob29rczogbnVsbCxcbiAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIGVycm9yczogZXJyb3JzLFxuICAgICAgd2FybmluZ3M6IHdhcm5pbmdzLFxuICAgICAgLy8gTGlzdCBvZiBvd25lcnNcbiAgICAgIG93bmVyczogb3duZXJzLFxuICAgICAgLy8gTG9jYXRpb24gb2YgY29tcG9uZW50IGluIHNvdXJjZSBjb2RlLlxuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICByb290VHlwZTogbnVsbCxcbiAgICAgIHJlbmRlcmVyUGFja2FnZU5hbWU6IG51bGwsXG4gICAgICByZW5kZXJlclZlcnNpb246IG51bGwsXG4gICAgICBwbHVnaW5zOiB7XG4gICAgICAgIHN0eWxleDogbnVsbFxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBsb2dFbGVtZW50VG9Db25zb2xlKGlkKSB7XG4gICAgdmFyIHJlc3VsdCA9IGluc3BlY3RFbGVtZW50UmF3KGlkKTtcblxuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIGVsZW1lbnQgd2l0aCBpZCBcXFwiXCIuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdXBwb3J0c0dyb3VwID0gdHlwZW9mIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQgPT09ICdmdW5jdGlvbic7XG5cbiAgICBpZiAoc3VwcG9ydHNHcm91cCkge1xuICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChcIltDbGljayB0byBleHBhbmRdICVjPFwiLmNvbmNhdChyZXN1bHQuZGlzcGxheU5hbWUgfHwgJ0NvbXBvbmVudCcsIFwiIC8+XCIpLCAvLyAtLWRvbS10YWctbmFtZS1jb2xvciBpcyB0aGUgQ1NTIHZhcmlhYmxlIENocm9tZSBzdHlsZXMgSFRNTCBlbGVtZW50cyB3aXRoIGluIHRoZSBjb25zb2xlLlxuICAgICAgJ2NvbG9yOiB2YXIoLS1kb20tdGFnLW5hbWUtY29sb3IpOyBmb250LXdlaWdodDogbm9ybWFsOycpO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQucHJvcHMgIT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdQcm9wczonLCByZXN1bHQucHJvcHMpO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQuc3RhdGUgIT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdTdGF0ZTonLCByZXN1bHQuc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQuY29udGV4dCAhPT0gbnVsbCkge1xuICAgICAgY29uc29sZS5sb2coJ0NvbnRleHQ6JywgcmVzdWx0LmNvbnRleHQpO1xuICAgIH1cblxuICAgIHZhciBuYXRpdmVOb2RlID0gZmluZE5hdGl2ZU5vZGVGb3JJbnRlcm5hbElEKGlkKTtcblxuICAgIGlmIChuYXRpdmVOb2RlICE9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmxvZygnTm9kZTonLCBuYXRpdmVOb2RlKTtcbiAgICB9XG5cbiAgICBpZiAod2luZG93LmNocm9tZSB8fCAvZmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdSaWdodC1jbGljayBhbnkgdmFsdWUgdG8gc2F2ZSBpdCBhcyBhIGdsb2JhbCB2YXJpYWJsZSBmb3IgZnVydGhlciBpbnNwZWN0aW9uLicpO1xuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c0dyb3VwKSB7XG4gICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVZpZXdBdHRyaWJ1dGVTb3VyY2UoaWQsIHBhdGgpIHtcbiAgICB2YXIgaW5zcGVjdGVkRWxlbWVudCA9IGluc3BlY3RFbGVtZW50UmF3KGlkKTtcblxuICAgIGlmIChpbnNwZWN0ZWRFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICB3aW5kb3cuJGF0dHJpYnV0ZSA9IE9iamVjdChzcmNfdXRpbHNbXCJqXCIgLyogZ2V0SW5PYmplY3QgKi9dKShpbnNwZWN0ZWRFbGVtZW50LCBwYXRoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlVmlld0VsZW1lbnRTb3VyY2UoaWQpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGlkVG9JbnRlcm5hbEluc3RhbmNlTWFwLmdldChpZCk7XG5cbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZmluZCBpbnN0YW5jZSB3aXRoIGlkIFxcXCJcIi5jb25jYXQoaWQsIFwiXFxcIlwiKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIGVsZW1lbnQgd2l0aCBpZCBcXFwiXCIuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdsb2JhbC4kdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVBhdGgodHlwZSwgaWQsIGhvb2tJRCwgcGF0aCkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gaWRUb0ludGVybmFsSW5zdGFuY2VNYXAuZ2V0KGlkKTtcblxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgIHZhciBwdWJsaWNJbnN0YW5jZSA9IGludGVybmFsSW5zdGFuY2UuX2luc3RhbmNlO1xuXG4gICAgICBpZiAocHVibGljSW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdjb250ZXh0JzpcbiAgICAgICAgICAgIE9iamVjdChzcmNfdXRpbHNbXCJjXCIgLyogZGVsZXRlUGF0aEluT2JqZWN0ICovXSkocHVibGljSW5zdGFuY2UuY29udGV4dCwgcGF0aCk7XG4gICAgICAgICAgICBmb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2hvb2tzJzpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSG9va3Mgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyJyk7XG5cbiAgICAgICAgICBjYXNlICdwcm9wcyc6XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuICAgICAgICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVsZW1lbnQpLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wczogT2JqZWN0KHV0aWxzW1wiYlwiIC8qIGNvcHlXaXRoRGVsZXRlICovXSkoZWxlbWVudC5wcm9wcywgcGF0aClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yY2VVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzdGF0ZSc6XG4gICAgICAgICAgICBPYmplY3Qoc3JjX3V0aWxzW1wiY1wiIC8qIGRlbGV0ZVBhdGhJbk9iamVjdCAqL10pKHB1YmxpY0luc3RhbmNlLnN0YXRlLCBwYXRoKTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuYW1lUGF0aCh0eXBlLCBpZCwgaG9va0lELCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBpZFRvSW50ZXJuYWxJbnN0YW5jZU1hcC5nZXQoaWQpO1xuXG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgdmFyIHB1YmxpY0luc3RhbmNlID0gaW50ZXJuYWxJbnN0YW5jZS5faW5zdGFuY2U7XG5cbiAgICAgIGlmIChwdWJsaWNJbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2NvbnRleHQnOlxuICAgICAgICAgICAgT2JqZWN0KHNyY191dGlsc1tcIm5cIiAvKiByZW5hbWVQYXRoSW5PYmplY3QgKi9dKShwdWJsaWNJbnN0YW5jZS5jb250ZXh0LCBvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaG9va3MnOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIb29rcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXInKTtcblxuICAgICAgICAgIGNhc2UgJ3Byb3BzJzpcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZWxlbWVudCksIHt9LCB7XG4gICAgICAgICAgICAgIHByb3BzOiBPYmplY3QodXRpbHNbXCJjXCIgLyogY29weVdpdGhSZW5hbWUgKi9dKShlbGVtZW50LnByb3BzLCBvbGRQYXRoLCBuZXdQYXRoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3N0YXRlJzpcbiAgICAgICAgICAgIE9iamVjdChzcmNfdXRpbHNbXCJuXCIgLyogcmVuYW1lUGF0aEluT2JqZWN0ICovXSkocHVibGljSW5zdGFuY2Uuc3RhdGUsIG9sZFBhdGgsIG5ld1BhdGgpO1xuICAgICAgICAgICAgZm9yY2VVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvdmVycmlkZVZhbHVlQXRQYXRoKHR5cGUsIGlkLCBob29rSUQsIHBhdGgsIHZhbHVlKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBpZFRvSW50ZXJuYWxJbnN0YW5jZU1hcC5nZXQoaWQpO1xuXG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgdmFyIHB1YmxpY0luc3RhbmNlID0gaW50ZXJuYWxJbnN0YW5jZS5faW5zdGFuY2U7XG5cbiAgICAgIGlmIChwdWJsaWNJbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2NvbnRleHQnOlxuICAgICAgICAgICAgT2JqZWN0KHNyY191dGlsc1tcIm9cIiAvKiBzZXRJbk9iamVjdCAqL10pKHB1YmxpY0luc3RhbmNlLmNvbnRleHQsIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaG9va3MnOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIb29rcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXInKTtcblxuICAgICAgICAgIGNhc2UgJ3Byb3BzJzpcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZWxlbWVudCksIHt9LCB7XG4gICAgICAgICAgICAgIHByb3BzOiBPYmplY3QodXRpbHNbXCJkXCIgLyogY29weVdpdGhTZXQgKi9dKShlbGVtZW50LnByb3BzLCBwYXRoLCB2YWx1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yY2VVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzdGF0ZSc6XG4gICAgICAgICAgICBPYmplY3Qoc3JjX3V0aWxzW1wib1wiIC8qIHNldEluT2JqZWN0ICovXSkocHVibGljSW5zdGFuY2Uuc3RhdGUsIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIHYxNisgb25seSBmZWF0dXJlc1xuXG5cbiAgdmFyIGdldFByb2ZpbGluZ0RhdGEgPSBmdW5jdGlvbiBnZXRQcm9maWxpbmdEYXRhKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2V0UHJvZmlsaW5nRGF0YSBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXInKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlQ29tbWl0RmliZXJSb290ID0gZnVuY3Rpb24gaGFuZGxlQ29tbWl0RmliZXJSb290KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaGFuZGxlQ29tbWl0RmliZXJSb290IG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlcicpO1xuICB9O1xuXG4gIHZhciBoYW5kbGVDb21taXRGaWJlclVubW91bnQgPSBmdW5jdGlvbiBoYW5kbGVDb21taXRGaWJlclVubW91bnQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdoYW5kbGVDb21taXRGaWJlclVubW91bnQgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyJyk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvc3RDb21taXRGaWJlclJvb3QgPSBmdW5jdGlvbiBoYW5kbGVQb3N0Q29tbWl0RmliZXJSb290KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaGFuZGxlUG9zdENvbW1pdEZpYmVyUm9vdCBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXInKTtcbiAgfTtcblxuICB2YXIgb3ZlcnJpZGVFcnJvciA9IGZ1bmN0aW9uIG92ZXJyaWRlRXJyb3IoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvdmVycmlkZUVycm9yIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlcicpO1xuICB9O1xuXG4gIHZhciBvdmVycmlkZVN1c3BlbnNlID0gZnVuY3Rpb24gb3ZlcnJpZGVTdXNwZW5zZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ292ZXJyaWRlU3VzcGVuc2Ugbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyJyk7XG4gIH07XG5cbiAgdmFyIHN0YXJ0UHJvZmlsaW5nID0gZnVuY3Rpb24gc3RhcnRQcm9maWxpbmcoKSB7Ly8gRG8gbm90IHRocm93LCBzaW5jZSB0aGlzIHdvdWxkIGJyZWFrIGEgbXVsdGktcm9vdCBzY2VuYXJpbyB3aGVyZSB2MTUgYW5kIHYxNiB3ZXJlIGJvdGggcHJlc2VudC5cbiAgfTtcblxuICB2YXIgc3RvcFByb2ZpbGluZyA9IGZ1bmN0aW9uIHN0b3BQcm9maWxpbmcoKSB7Ly8gRG8gbm90IHRocm93LCBzaW5jZSB0aGlzIHdvdWxkIGJyZWFrIGEgbXVsdGktcm9vdCBzY2VuYXJpbyB3aGVyZSB2MTUgYW5kIHYxNiB3ZXJlIGJvdGggcHJlc2VudC5cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRCZXN0TWF0Y2hGb3JUcmFja2VkUGF0aCgpIHtcbiAgICAvLyBOb3QgaW1wbGVtZW50ZWQuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXRoRm9yRWxlbWVudChpZCkge1xuICAgIC8vIE5vdCBpbXBsZW1lbnRlZC5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudEZpbHRlcnMoY29tcG9uZW50RmlsdGVycykgey8vIE5vdCBpbXBsZW1lbnRlZC5cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFRyYWNlVXBkYXRlc0VuYWJsZWQoZW5hYmxlZCkgey8vIE5vdCBpbXBsZW1lbnRlZC5cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFRyYWNrZWRQYXRoKHBhdGgpIHsvLyBOb3QgaW1wbGVtZW50ZWQuXG4gIH1cblxuICBmdW5jdGlvbiBnZXRPd25lcnNMaXN0KGlkKSB7XG4gICAgLy8gTm90IGltcGxlbWVudGVkLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJFcnJvcnNBbmRXYXJuaW5ncygpIHsvLyBOb3QgaW1wbGVtZW50ZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyRXJyb3JzRm9yRmliZXJJRChpZCkgey8vIE5vdCBpbXBsZW1lbnRlZFxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJXYXJuaW5nc0ZvckZpYmVySUQoaWQpIHsvLyBOb3QgaW1wbGVtZW50ZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoQ29uc29sZUZvclN0cmljdE1vZGUoKSB7fVxuXG4gIGZ1bmN0aW9uIHVucGF0Y2hDb25zb2xlRm9yU3RyaWN0TW9kZSgpIHt9XG5cbiAgcmV0dXJuIHtcbiAgICBjbGVhckVycm9yc0FuZFdhcm5pbmdzOiBjbGVhckVycm9yc0FuZFdhcm5pbmdzLFxuICAgIGNsZWFyRXJyb3JzRm9yRmliZXJJRDogY2xlYXJFcnJvcnNGb3JGaWJlcklELFxuICAgIGNsZWFyV2FybmluZ3NGb3JGaWJlcklEOiBjbGVhcldhcm5pbmdzRm9yRmliZXJJRCxcbiAgICBjbGVhbnVwOiBjbGVhbnVwLFxuICAgIGdldFNlcmlhbGl6ZWRFbGVtZW50VmFsdWVCeVBhdGg6IGdldFNlcmlhbGl6ZWRFbGVtZW50VmFsdWVCeVBhdGgsXG4gICAgZGVsZXRlUGF0aDogZGVsZXRlUGF0aCxcbiAgICBmbHVzaEluaXRpYWxPcGVyYXRpb25zOiBmbHVzaEluaXRpYWxPcGVyYXRpb25zLFxuICAgIGdldEJlc3RNYXRjaEZvclRyYWNrZWRQYXRoOiBnZXRCZXN0TWF0Y2hGb3JUcmFja2VkUGF0aCxcbiAgICBnZXREaXNwbGF5TmFtZUZvckZpYmVySUQ6IGdldERpc3BsYXlOYW1lRm9yRmliZXJJRCxcbiAgICBnZXRGaWJlckZvck5hdGl2ZTogZ2V0RmliZXJGb3JOYXRpdmUsXG4gICAgZ2V0RmliZXJJREZvck5hdGl2ZTogZ2V0SW50ZXJuYWxJREZvck5hdGl2ZSxcbiAgICBnZXRJbnN0YW5jZUFuZFN0eWxlOiBnZXRJbnN0YW5jZUFuZFN0eWxlLFxuICAgIGZpbmROYXRpdmVOb2Rlc0ZvckZpYmVySUQ6IGZ1bmN0aW9uIGZpbmROYXRpdmVOb2Rlc0ZvckZpYmVySUQoaWQpIHtcbiAgICAgIHZhciBuYXRpdmVOb2RlID0gZmluZE5hdGl2ZU5vZGVGb3JJbnRlcm5hbElEKGlkKTtcbiAgICAgIHJldHVybiBuYXRpdmVOb2RlID09IG51bGwgPyBudWxsIDogW25hdGl2ZU5vZGVdO1xuICAgIH0sXG4gICAgZ2V0T3duZXJzTGlzdDogZ2V0T3duZXJzTGlzdCxcbiAgICBnZXRQYXRoRm9yRWxlbWVudDogZ2V0UGF0aEZvckVsZW1lbnQsXG4gICAgZ2V0UHJvZmlsaW5nRGF0YTogZ2V0UHJvZmlsaW5nRGF0YSxcbiAgICBoYW5kbGVDb21taXRGaWJlclJvb3Q6IGhhbmRsZUNvbW1pdEZpYmVyUm9vdCxcbiAgICBoYW5kbGVDb21taXRGaWJlclVubW91bnQ6IGhhbmRsZUNvbW1pdEZpYmVyVW5tb3VudCxcbiAgICBoYW5kbGVQb3N0Q29tbWl0RmliZXJSb290OiBoYW5kbGVQb3N0Q29tbWl0RmliZXJSb290LFxuICAgIGluc3BlY3RFbGVtZW50OiBpbnNwZWN0RWxlbWVudCxcbiAgICBsb2dFbGVtZW50VG9Db25zb2xlOiBsb2dFbGVtZW50VG9Db25zb2xlLFxuICAgIG92ZXJyaWRlRXJyb3I6IG92ZXJyaWRlRXJyb3IsXG4gICAgb3ZlcnJpZGVTdXNwZW5zZTogb3ZlcnJpZGVTdXNwZW5zZSxcbiAgICBvdmVycmlkZVZhbHVlQXRQYXRoOiBvdmVycmlkZVZhbHVlQXRQYXRoLFxuICAgIHJlbmFtZVBhdGg6IHJlbmFtZVBhdGgsXG4gICAgcGF0Y2hDb25zb2xlRm9yU3RyaWN0TW9kZTogcGF0Y2hDb25zb2xlRm9yU3RyaWN0TW9kZSxcbiAgICBwcmVwYXJlVmlld0F0dHJpYnV0ZVNvdXJjZTogcHJlcGFyZVZpZXdBdHRyaWJ1dGVTb3VyY2UsXG4gICAgcHJlcGFyZVZpZXdFbGVtZW50U291cmNlOiBwcmVwYXJlVmlld0VsZW1lbnRTb3VyY2UsXG4gICAgcmVuZGVyZXI6IHJlbmRlcmVyLFxuICAgIHNldFRyYWNlVXBkYXRlc0VuYWJsZWQ6IHNldFRyYWNlVXBkYXRlc0VuYWJsZWQsXG4gICAgc2V0VHJhY2tlZFBhdGg6IHNldFRyYWNrZWRQYXRoLFxuICAgIHN0YXJ0UHJvZmlsaW5nOiBzdGFydFByb2ZpbGluZyxcbiAgICBzdG9wUHJvZmlsaW5nOiBzdG9wUHJvZmlsaW5nLFxuICAgIHN0b3JlQXNHbG9iYWw6IHN0b3JlQXNHbG9iYWwsXG4gICAgdW5wYXRjaENvbnNvbGVGb3JTdHJpY3RNb2RlOiB1bnBhdGNoQ29uc29sZUZvclN0cmljdE1vZGUsXG4gICAgdXBkYXRlQ29tcG9uZW50RmlsdGVyczogdXBkYXRlQ29tcG9uZW50RmlsdGVyc1xuICB9O1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2luZGV4LmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuXG5cblxuXG4vLyB0aGlzIGlzIHRoZSBiYWNrZW5kIHRoYXQgaXMgY29tcGFjdGlibGUgd2l0aCBhbGwgb2xkZXIgUmVhY3QgdmVyc2lvbnNcbmZ1bmN0aW9uIGlzTWF0Y2hpbmdSZW5kZXIodmVyc2lvbikge1xuICByZXR1cm4gIU9iamVjdCh1dGlsc1tcImpcIiAvKiBoYXNBc3NpZ25lZEJhY2tlbmQgKi9dKSh2ZXJzaW9uKTtcbn1cblxuZnVuY3Rpb24gaW5pdEJhY2tlbmQoaG9vaywgYWdlbnQsIGdsb2JhbCkge1xuICBpZiAoaG9vayA9PSBudWxsKSB7XG4gICAgLy8gRGV2VG9vbHMgZGlkbid0IGdldCBpbmplY3RlZCBpbnRvIHRoaXMgcGFnZSAobWF5YmUgYidjIG9mIHRoZSBjb250ZW50VHlwZSkuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICB9XG5cbiAgdmFyIHN1YnMgPSBbaG9vay5zdWIoJ3JlbmRlcmVyLWF0dGFjaGVkJywgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgaWQgPSBfcmVmLmlkLFxuICAgICAgICByZW5kZXJlciA9IF9yZWYucmVuZGVyZXIsXG4gICAgICAgIHJlbmRlcmVySW50ZXJmYWNlID0gX3JlZi5yZW5kZXJlckludGVyZmFjZTtcbiAgICBhZ2VudC5zZXRSZW5kZXJlckludGVyZmFjZShpZCwgcmVuZGVyZXJJbnRlcmZhY2UpOyAvLyBOb3cgdGhhdCB0aGUgU3RvcmUgYW5kIHRoZSByZW5kZXJlciBpbnRlcmZhY2UgYXJlIGNvbm5lY3RlZCxcbiAgICAvLyBpdCdzIHRpbWUgdG8gZmx1c2ggdGhlIHBlbmRpbmcgb3BlcmF0aW9uIGNvZGVzIHRvIHRoZSBmcm9udGVuZC5cblxuICAgIHJlbmRlcmVySW50ZXJmYWNlLmZsdXNoSW5pdGlhbE9wZXJhdGlvbnMoKTtcbiAgfSksIGhvb2suc3ViKCd1bnN1cHBvcnRlZC1yZW5kZXJlci12ZXJzaW9uJywgZnVuY3Rpb24gKGlkKSB7XG4gICAgYWdlbnQub25VbnN1cHBvcnRlZFJlbmRlcmVyKGlkKTtcbiAgfSksIGhvb2suc3ViKCdmYXN0UmVmcmVzaFNjaGVkdWxlZCcsIGFnZW50Lm9uRmFzdFJlZnJlc2hTY2hlZHVsZWQpLCBob29rLnN1Yignb3BlcmF0aW9ucycsIGFnZW50Lm9uSG9va09wZXJhdGlvbnMpLCBob29rLnN1YigndHJhY2VVcGRhdGVzJywgYWdlbnQub25UcmFjZVVwZGF0ZXMpIC8vIFRPRE8gQWRkIGFkZGl0aW9uYWwgc3Vic2NyaXB0aW9ucyByZXF1aXJlZCBmb3IgcHJvZmlsaW5nIG1vZGVcbiAgXTtcblxuICB2YXIgYXR0YWNoUmVuZGVyZXIgPSBmdW5jdGlvbiBhdHRhY2hSZW5kZXJlcihpZCwgcmVuZGVyZXIpIHtcbiAgICAvLyBza2lwIGlmIGFscmVhZHkgYXR0YWNoZWRcbiAgICBpZiAocmVuZGVyZXIuYXR0YWNoZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG9ubHkgYXR0YWNoIGlmIHRoZSByZW5kZXJlciBpcyBjb21wYXRpYmxlIHdpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgYmFja2VuZFxuXG5cbiAgICBpZiAoIWlzTWF0Y2hpbmdSZW5kZXIocmVuZGVyZXIucmVjb25jaWxlclZlcnNpb24gfHwgcmVuZGVyZXIudmVyc2lvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyZXJJbnRlcmZhY2UgPSBob29rLnJlbmRlcmVySW50ZXJmYWNlcy5nZXQoaWQpOyAvLyBJbmplY3QgYW55IG5vdC15ZXQtaW5qZWN0ZWQgcmVuZGVyZXJzIChpZiB3ZSBkaWRuJ3QgcmVsb2FkLWFuZC1wcm9maWxlKVxuXG4gICAgaWYgKHJlbmRlcmVySW50ZXJmYWNlID09IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVuZGVyZXIuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gcmVhY3QtcmVjb25jaWxlciB2MTYrXG4gICAgICAgIHJlbmRlcmVySW50ZXJmYWNlID0gT2JqZWN0KGJhY2tlbmRfcmVuZGVyZXJbXCJhXCIgLyogYXR0YWNoICovXSkoaG9vaywgaWQsIHJlbmRlcmVyLCBnbG9iYWwpO1xuICAgICAgfSBlbHNlIGlmIChyZW5kZXJlci5Db21wb25lbnRUcmVlKSB7XG4gICAgICAgIC8vIHJlYWN0LWRvbSB2MTVcbiAgICAgICAgcmVuZGVyZXJJbnRlcmZhY2UgPSBhdHRhY2goaG9vaywgaWQsIHJlbmRlcmVyLCBnbG9iYWwpO1xuICAgICAgfSBlbHNlIHsvLyBPbGRlciByZWFjdC1kb20gb3Igb3RoZXIgdW5zdXBwb3J0ZWQgcmVuZGVyZXIgdmVyc2lvblxuICAgICAgfVxuXG4gICAgICBpZiAocmVuZGVyZXJJbnRlcmZhY2UgIT0gbnVsbCkge1xuICAgICAgICBob29rLnJlbmRlcmVySW50ZXJmYWNlcy5zZXQoaWQsIHJlbmRlcmVySW50ZXJmYWNlKTtcbiAgICAgIH1cbiAgICB9IC8vIE5vdGlmeSB0aGUgRGV2VG9vbHMgZnJvbnRlbmQgYWJvdXQgbmV3IHJlbmRlcmVycy5cbiAgICAvLyBUaGlzIGluY2x1ZGVzIGFueSB0aGF0IHdlcmUgYXR0YWNoZWQgZWFybHkgKHZpYSBfX1JFQUNUX0RFVlRPT0xTX0FUVEFDSF9fKS5cblxuXG4gICAgaWYgKHJlbmRlcmVySW50ZXJmYWNlICE9IG51bGwpIHtcbiAgICAgIGhvb2suZW1pdCgncmVuZGVyZXItYXR0YWNoZWQnLCB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgcmVuZGVyZXI6IHJlbmRlcmVyLFxuICAgICAgICByZW5kZXJlckludGVyZmFjZTogcmVuZGVyZXJJbnRlcmZhY2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBob29rLmVtaXQoJ3Vuc3VwcG9ydGVkLXJlbmRlcmVyLXZlcnNpb24nLCBpZCk7XG4gICAgfVxuXG4gICAgcmVuZGVyZXIuYXR0YWNoZWQgPSB0cnVlO1xuICB9OyAvLyBDb25uZWN0IHJlbmRlcmVycyB0aGF0IGhhdmUgYWxyZWFkeSBpbmplY3RlZCB0aGVtc2VsdmVzLlxuXG5cbiAgaG9vay5yZW5kZXJlcnMuZm9yRWFjaChmdW5jdGlvbiAocmVuZGVyZXIsIGlkKSB7XG4gICAgYXR0YWNoUmVuZGVyZXIoaWQsIHJlbmRlcmVyKTtcbiAgfSk7IC8vIENvbm5lY3QgYW55IG5ldyByZW5kZXJlcnMgdGhhdCBpbmplY3RlZCB0aGVtc2VsdmVzLlxuXG4gIHN1YnMucHVzaChob29rLnN1YigncmVuZGVyZXInLCBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgaWQgPSBfcmVmMi5pZCxcbiAgICAgICAgcmVuZGVyZXIgPSBfcmVmMi5yZW5kZXJlcjtcbiAgICBhdHRhY2hSZW5kZXJlcihpZCwgcmVuZGVyZXIpO1xuICB9KSk7XG4gIGhvb2suZW1pdCgncmVhY3QtZGV2dG9vbHMnLCBhZ2VudCk7XG4gIGhvb2sucmVhY3REZXZ0b29sc0FnZW50ID0gYWdlbnQ7XG5cbiAgdmFyIG9uQWdlbnRTaHV0ZG93biA9IGZ1bmN0aW9uIG9uQWdlbnRTaHV0ZG93bigpIHtcbiAgICBzdWJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9KTtcbiAgICBob29rLnJlbmRlcmVySW50ZXJmYWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZW5kZXJlckludGVyZmFjZSkge1xuICAgICAgcmVuZGVyZXJJbnRlcmZhY2UuY2xlYW51cCgpO1xuICAgIH0pO1xuICAgIGhvb2sucmVhY3REZXZ0b29sc0FnZW50ID0gbnVsbDtcbiAgfTtcblxuICBhZ2VudC5hZGRMaXN0ZW5lcignc2h1dGRvd24nLCBvbkFnZW50U2h1dGRvd24pO1xuICBzdWJzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIGFnZW50LnJlbW92ZUxpc3RlbmVyKCdzaHV0ZG93bicsIG9uQWdlbnRTaHV0ZG93bik7XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHN1YnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH0pO1xuICB9O1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL05hdGl2ZVN0eWxlRWRpdG9yL3Jlc29sdmVCb3hTdHlsZS5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbi8qKlxuICogVGhpcyBtaXJyb3JzIHJlYWN0LW5hdGl2ZS9MaWJyYXJpZXMvSW5zcGVjdG9yL3Jlc29sdmVCb3hTdHlsZS5qcyAoYnV0IHdpdGhvdXQgUlRMIHN1cHBvcnQpLlxuICpcbiAqIFJlc29sdmUgYSBzdHlsZSBwcm9wZXJ0eSBpbnRvIGl0J3MgY29tcG9uZW50IHBhcnRzLCBlLmcuXG4gKlxuICogcmVzb2x2ZUJveFN0eWxlKCdtYXJnaW4nLCB7bWFyZ2luOiA1LCBtYXJnaW5Cb3R0b206IDEwfSlcbiAqIC0+IHt0b3A6IDUsIGxlZnQ6IDUsIHJpZ2h0OiA1LCBib3R0b206IDEwfVxuICovXG5mdW5jdGlvbiByZXNvbHZlQm94U3R5bGUocHJlZml4LCBzdHlsZSkge1xuICB2YXIgaGFzUGFydHMgPSBmYWxzZTtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMCxcbiAgICByaWdodDogMCxcbiAgICB0b3A6IDBcbiAgfTtcbiAgdmFyIHN0eWxlRm9yQWxsID0gc3R5bGVbcHJlZml4XTtcblxuICBpZiAoc3R5bGVGb3JBbGwgIT0gbnVsbCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mb3Itb2YtbG9vcHMvbm8tZm9yLW9mLWxvb3BzXG4gICAgZm9yICh2YXIgX2kgPSAwLCBfT2JqZWN0JGtleXMgPSBPYmplY3Qua2V5cyhyZXN1bHQpOyBfaSA8IF9PYmplY3Qka2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBrZXkgPSBfT2JqZWN0JGtleXNbX2ldO1xuICAgICAgcmVzdWx0W2tleV0gPSBzdHlsZUZvckFsbDtcbiAgICB9XG5cbiAgICBoYXNQYXJ0cyA9IHRydWU7XG4gIH1cblxuICB2YXIgc3R5bGVGb3JIb3Jpem9udGFsID0gc3R5bGVbcHJlZml4ICsgJ0hvcml6b250YWwnXTtcblxuICBpZiAoc3R5bGVGb3JIb3Jpem9udGFsICE9IG51bGwpIHtcbiAgICByZXN1bHQubGVmdCA9IHN0eWxlRm9ySG9yaXpvbnRhbDtcbiAgICByZXN1bHQucmlnaHQgPSBzdHlsZUZvckhvcml6b250YWw7XG4gICAgaGFzUGFydHMgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBzdHlsZUZvckxlZnQgPSBzdHlsZVtwcmVmaXggKyAnTGVmdCddO1xuXG4gICAgaWYgKHN0eWxlRm9yTGVmdCAhPSBudWxsKSB7XG4gICAgICByZXN1bHQubGVmdCA9IHN0eWxlRm9yTGVmdDtcbiAgICAgIGhhc1BhcnRzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGVGb3JSaWdodCA9IHN0eWxlW3ByZWZpeCArICdSaWdodCddO1xuXG4gICAgaWYgKHN0eWxlRm9yUmlnaHQgIT0gbnVsbCkge1xuICAgICAgcmVzdWx0LnJpZ2h0ID0gc3R5bGVGb3JSaWdodDtcbiAgICAgIGhhc1BhcnRzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGVGb3JFbmQgPSBzdHlsZVtwcmVmaXggKyAnRW5kJ107XG5cbiAgICBpZiAoc3R5bGVGb3JFbmQgIT0gbnVsbCkge1xuICAgICAgLy8gVE9ETyBSVEwgc3VwcG9ydFxuICAgICAgcmVzdWx0LnJpZ2h0ID0gc3R5bGVGb3JFbmQ7XG4gICAgICBoYXNQYXJ0cyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlRm9yU3RhcnQgPSBzdHlsZVtwcmVmaXggKyAnU3RhcnQnXTtcblxuICAgIGlmIChzdHlsZUZvclN0YXJ0ICE9IG51bGwpIHtcbiAgICAgIC8vIFRPRE8gUlRMIHN1cHBvcnRcbiAgICAgIHJlc3VsdC5sZWZ0ID0gc3R5bGVGb3JTdGFydDtcbiAgICAgIGhhc1BhcnRzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3R5bGVGb3JWZXJ0aWNhbCA9IHN0eWxlW3ByZWZpeCArICdWZXJ0aWNhbCddO1xuXG4gIGlmIChzdHlsZUZvclZlcnRpY2FsICE9IG51bGwpIHtcbiAgICByZXN1bHQuYm90dG9tID0gc3R5bGVGb3JWZXJ0aWNhbDtcbiAgICByZXN1bHQudG9wID0gc3R5bGVGb3JWZXJ0aWNhbDtcbiAgICBoYXNQYXJ0cyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0eWxlRm9yQm90dG9tID0gc3R5bGVbcHJlZml4ICsgJ0JvdHRvbSddO1xuXG4gICAgaWYgKHN0eWxlRm9yQm90dG9tICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdC5ib3R0b20gPSBzdHlsZUZvckJvdHRvbTtcbiAgICAgIGhhc1BhcnRzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGVGb3JUb3AgPSBzdHlsZVtwcmVmaXggKyAnVG9wJ107XG5cbiAgICBpZiAoc3R5bGVGb3JUb3AgIT0gbnVsbCkge1xuICAgICAgcmVzdWx0LnRvcCA9IHN0eWxlRm9yVG9wO1xuICAgICAgaGFzUGFydHMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoYXNQYXJ0cyA/IHJlc3VsdCA6IG51bGw7XG59XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvaXNBcnJheS5qc1xudmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvTmF0aXZlU3R5bGVFZGl0b3Ivc2V0dXBOYXRpdmVTdHlsZUVkaXRvci5qc1xuZnVuY3Rpb24gc2V0dXBOYXRpdmVTdHlsZUVkaXRvcl90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IHNldHVwTmF0aXZlU3R5bGVFZGl0b3JfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IHNldHVwTmF0aXZlU3R5bGVFZGl0b3JfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIHNldHVwTmF0aXZlU3R5bGVFZGl0b3JfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gc2V0dXBOYXRpdmVTdHlsZUVkaXRvcl9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5cblxuZnVuY3Rpb24gc2V0dXBOYXRpdmVTdHlsZUVkaXRvcihicmlkZ2UsIGFnZW50LCByZXNvbHZlTmF0aXZlU3R5bGUsIHZhbGlkQXR0cmlidXRlcykge1xuICBicmlkZ2UuYWRkTGlzdGVuZXIoJ05hdGl2ZVN0eWxlRWRpdG9yX21lYXN1cmUnLCBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBpZCA9IF9yZWYuaWQsXG4gICAgICAgIHJlbmRlcmVySUQgPSBfcmVmLnJlbmRlcmVySUQ7XG4gICAgbWVhc3VyZVN0eWxlKGFnZW50LCBicmlkZ2UsIHJlc29sdmVOYXRpdmVTdHlsZSwgaWQsIHJlbmRlcmVySUQpO1xuICB9KTtcbiAgYnJpZGdlLmFkZExpc3RlbmVyKCdOYXRpdmVTdHlsZUVkaXRvcl9yZW5hbWVBdHRyaWJ1dGUnLCBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgaWQgPSBfcmVmMi5pZCxcbiAgICAgICAgcmVuZGVyZXJJRCA9IF9yZWYyLnJlbmRlcmVySUQsXG4gICAgICAgIG9sZE5hbWUgPSBfcmVmMi5vbGROYW1lLFxuICAgICAgICBuZXdOYW1lID0gX3JlZjIubmV3TmFtZSxcbiAgICAgICAgdmFsdWUgPSBfcmVmMi52YWx1ZTtcbiAgICByZW5hbWVTdHlsZShhZ2VudCwgaWQsIHJlbmRlcmVySUQsIG9sZE5hbWUsIG5ld05hbWUsIHZhbHVlKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBtZWFzdXJlU3R5bGUoYWdlbnQsIGJyaWRnZSwgcmVzb2x2ZU5hdGl2ZVN0eWxlLCBpZCwgcmVuZGVyZXJJRCk7XG4gICAgfSk7XG4gIH0pO1xuICBicmlkZ2UuYWRkTGlzdGVuZXIoJ05hdGl2ZVN0eWxlRWRpdG9yX3NldFZhbHVlJywgZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgdmFyIGlkID0gX3JlZjMuaWQsXG4gICAgICAgIHJlbmRlcmVySUQgPSBfcmVmMy5yZW5kZXJlcklELFxuICAgICAgICBuYW1lID0gX3JlZjMubmFtZSxcbiAgICAgICAgdmFsdWUgPSBfcmVmMy52YWx1ZTtcbiAgICBzZXRTdHlsZShhZ2VudCwgaWQsIHJlbmRlcmVySUQsIG5hbWUsIHZhbHVlKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBtZWFzdXJlU3R5bGUoYWdlbnQsIGJyaWRnZSwgcmVzb2x2ZU5hdGl2ZVN0eWxlLCBpZCwgcmVuZGVyZXJJRCk7XG4gICAgfSk7XG4gIH0pO1xuICBicmlkZ2Uuc2VuZCgnaXNOYXRpdmVTdHlsZUVkaXRvclN1cHBvcnRlZCcsIHtcbiAgICBpc1N1cHBvcnRlZDogdHJ1ZSxcbiAgICB2YWxpZEF0dHJpYnV0ZXM6IHZhbGlkQXR0cmlidXRlc1xuICB9KTtcbn1cbnZhciBFTVBUWV9CT1hfU1RZTEUgPSB7XG4gIHRvcDogMCxcbiAgbGVmdDogMCxcbiAgcmlnaHQ6IDAsXG4gIGJvdHRvbTogMFxufTtcbnZhciBjb21wb25lbnRJRFRvU3R5bGVPdmVycmlkZXMgPSBuZXcgTWFwKCk7XG5cbmZ1bmN0aW9uIG1lYXN1cmVTdHlsZShhZ2VudCwgYnJpZGdlLCByZXNvbHZlTmF0aXZlU3R5bGUsIGlkLCByZW5kZXJlcklEKSB7XG4gIHZhciBkYXRhID0gYWdlbnQuZ2V0SW5zdGFuY2VBbmRTdHlsZSh7XG4gICAgaWQ6IGlkLFxuICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySURcbiAgfSk7XG5cbiAgaWYgKCFkYXRhIHx8ICFkYXRhLnN0eWxlKSB7XG4gICAgYnJpZGdlLnNlbmQoJ05hdGl2ZVN0eWxlRWRpdG9yX3N0eWxlQW5kTGF5b3V0Jywge1xuICAgICAgaWQ6IGlkLFxuICAgICAgbGF5b3V0OiBudWxsLFxuICAgICAgc3R5bGU6IG51bGxcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSBkYXRhLmluc3RhbmNlLFxuICAgICAgc3R5bGUgPSBkYXRhLnN0eWxlO1xuICB2YXIgcmVzb2x2ZWRTdHlsZSA9IHJlc29sdmVOYXRpdmVTdHlsZShzdHlsZSk7IC8vIElmIGl0J3MgYSBob3N0IGNvbXBvbmVudCB3ZSBlZGl0ZWQgYmVmb3JlLCBhbWVuZCBzdHlsZXMuXG5cbiAgdmFyIHN0eWxlT3ZlcnJpZGVzID0gY29tcG9uZW50SURUb1N0eWxlT3ZlcnJpZGVzLmdldChpZCk7XG5cbiAgaWYgKHN0eWxlT3ZlcnJpZGVzICE9IG51bGwpIHtcbiAgICByZXNvbHZlZFN0eWxlID0gT2JqZWN0LmFzc2lnbih7fSwgcmVzb2x2ZWRTdHlsZSwgc3R5bGVPdmVycmlkZXMpO1xuICB9XG5cbiAgaWYgKCFpbnN0YW5jZSB8fCB0eXBlb2YgaW5zdGFuY2UubWVhc3VyZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGJyaWRnZS5zZW5kKCdOYXRpdmVTdHlsZUVkaXRvcl9zdHlsZUFuZExheW91dCcsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGxheW91dDogbnVsbCxcbiAgICAgIHN0eWxlOiByZXNvbHZlZFN0eWxlIHx8IG51bGxcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpbnN0YW5jZS5tZWFzdXJlKGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBsZWZ0LCB0b3ApIHtcbiAgICAvLyBSTiBBbmRyb2lkIHNvbWV0aW1lcyByZXR1cm5zIHVuZGVmaW5lZCBoZXJlLiBEb24ndCBzZW5kIG1lYXN1cmVtZW50cyBpbiB0aGlzIGNhc2UuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2poZW4wNDA5L3JlYWN0LW5hdGl2ZS1kZWJ1Z2dlci9pc3N1ZXMvODQjaXNzdWVjb21tZW50LTMwNDYxMTgxN1xuICAgIGlmICh0eXBlb2YgeCAhPT0gJ251bWJlcicpIHtcbiAgICAgIGJyaWRnZS5zZW5kKCdOYXRpdmVTdHlsZUVkaXRvcl9zdHlsZUFuZExheW91dCcsIHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBsYXlvdXQ6IG51bGwsXG4gICAgICAgIHN0eWxlOiByZXNvbHZlZFN0eWxlIHx8IG51bGxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtYXJnaW4gPSByZXNvbHZlZFN0eWxlICE9IG51bGwgJiYgcmVzb2x2ZUJveFN0eWxlKCdtYXJnaW4nLCByZXNvbHZlZFN0eWxlKSB8fCBFTVBUWV9CT1hfU1RZTEU7XG4gICAgdmFyIHBhZGRpbmcgPSByZXNvbHZlZFN0eWxlICE9IG51bGwgJiYgcmVzb2x2ZUJveFN0eWxlKCdwYWRkaW5nJywgcmVzb2x2ZWRTdHlsZSkgfHwgRU1QVFlfQk9YX1NUWUxFO1xuICAgIGJyaWRnZS5zZW5kKCdOYXRpdmVTdHlsZUVkaXRvcl9zdHlsZUFuZExheW91dCcsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGxheW91dDoge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgbWFyZ2luOiBtYXJnaW4sXG4gICAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICAgIH0sXG4gICAgICBzdHlsZTogcmVzb2x2ZWRTdHlsZSB8fCBudWxsXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzaGFsbG93Q2xvbmUob2JqZWN0KSB7XG4gIHZhciBjbG9uZWQgPSB7fTtcblxuICBmb3IgKHZhciBuIGluIG9iamVjdCkge1xuICAgIGNsb25lZFtuXSA9IG9iamVjdFtuXTtcbiAgfVxuXG4gIHJldHVybiBjbG9uZWQ7XG59XG5cbmZ1bmN0aW9uIHJlbmFtZVN0eWxlKGFnZW50LCBpZCwgcmVuZGVyZXJJRCwgb2xkTmFtZSwgbmV3TmFtZSwgdmFsdWUpIHtcbiAgdmFyIF9yZWY0O1xuXG4gIHZhciBkYXRhID0gYWdlbnQuZ2V0SW5zdGFuY2VBbmRTdHlsZSh7XG4gICAgaWQ6IGlkLFxuICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySURcbiAgfSk7XG5cbiAgaWYgKCFkYXRhIHx8ICFkYXRhLnN0eWxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gZGF0YS5pbnN0YW5jZSxcbiAgICAgIHN0eWxlID0gZGF0YS5zdHlsZTtcbiAgdmFyIG5ld1N0eWxlID0gbmV3TmFtZSA/IChfcmVmNCA9IHt9LCBzZXR1cE5hdGl2ZVN0eWxlRWRpdG9yX2RlZmluZVByb3BlcnR5KF9yZWY0LCBvbGROYW1lLCB1bmRlZmluZWQpLCBzZXR1cE5hdGl2ZVN0eWxlRWRpdG9yX2RlZmluZVByb3BlcnR5KF9yZWY0LCBuZXdOYW1lLCB2YWx1ZSksIF9yZWY0KSA6IHNldHVwTmF0aXZlU3R5bGVFZGl0b3JfZGVmaW5lUHJvcGVydHkoe30sIG9sZE5hbWUsIHVuZGVmaW5lZCk7XG4gIHZhciBjdXN0b21TdHlsZTsgLy8gVE9ETyBJdCB3b3VsZCBiZSBuaWNlIGlmIHRoZSByZW5kZXJlciBpbnRlcmZhY2UgYWJzdHJhY3RlZCB0aGlzIGF3YXkgc29tZWhvdy5cblxuICBpZiAoaW5zdGFuY2UgIT09IG51bGwgJiYgdHlwZW9mIGluc3RhbmNlLnNldE5hdGl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gSW4gdGhlIGNhc2Ugb2YgYSBob3N0IGNvbXBvbmVudCwgd2UgbmVlZCB0byB1c2Ugc2V0TmF0aXZlUHJvcHMoKS5cbiAgICAvLyBSZW1lbWJlciB0byBcImNvcnJlY3RcIiByZXNvbHZlZCBzdHlsZXMgd2hlbiB3ZSByZWFkIHRoZW0gbmV4dCB0aW1lLlxuICAgIHZhciBzdHlsZU92ZXJyaWRlcyA9IGNvbXBvbmVudElEVG9TdHlsZU92ZXJyaWRlcy5nZXQoaWQpO1xuXG4gICAgaWYgKCFzdHlsZU92ZXJyaWRlcykge1xuICAgICAgY29tcG9uZW50SURUb1N0eWxlT3ZlcnJpZGVzLnNldChpZCwgbmV3U3R5bGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3QuYXNzaWduKHN0eWxlT3ZlcnJpZGVzLCBuZXdTdHlsZSk7XG4gICAgfSAvLyBUT0RPIEZhYnJpYyBkb2VzIG5vdCBzdXBwb3J0IHNldE5hdGl2ZVByb3BzOyBjaGF0IHdpdGggU2ViYXN0aWFuIG9yIEVsaVxuXG5cbiAgICBpbnN0YW5jZS5zZXROYXRpdmVQcm9wcyh7XG4gICAgICBzdHlsZTogbmV3U3R5bGVcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChPYmplY3QoaXNBcnJheVtcImFcIiAvKiBkZWZhdWx0ICovXSkoc3R5bGUpKSB7XG4gICAgdmFyIGxhc3RJbmRleCA9IHN0eWxlLmxlbmd0aCAtIDE7XG5cbiAgICBpZiAoc2V0dXBOYXRpdmVTdHlsZUVkaXRvcl90eXBlb2Yoc3R5bGVbbGFzdEluZGV4XSkgPT09ICdvYmplY3QnICYmICFPYmplY3QoaXNBcnJheVtcImFcIiAvKiBkZWZhdWx0ICovXSkoc3R5bGVbbGFzdEluZGV4XSkpIHtcbiAgICAgIGN1c3RvbVN0eWxlID0gc2hhbGxvd0Nsb25lKHN0eWxlW2xhc3RJbmRleF0pO1xuICAgICAgZGVsZXRlIGN1c3RvbVN0eWxlW29sZE5hbWVdO1xuXG4gICAgICBpZiAobmV3TmFtZSkge1xuICAgICAgICBjdXN0b21TdHlsZVtuZXdOYW1lXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VzdG9tU3R5bGVbb2xkTmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGFnZW50Lm92ZXJyaWRlVmFsdWVBdFBhdGgoe1xuICAgICAgICB0eXBlOiAncHJvcHMnLFxuICAgICAgICBpZDogaWQsXG4gICAgICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySUQsXG4gICAgICAgIHBhdGg6IFsnc3R5bGUnLCBsYXN0SW5kZXhdLFxuICAgICAgICB2YWx1ZTogY3VzdG9tU3R5bGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZ2VudC5vdmVycmlkZVZhbHVlQXRQYXRoKHtcbiAgICAgICAgdHlwZTogJ3Byb3BzJyxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICByZW5kZXJlcklEOiByZW5kZXJlcklELFxuICAgICAgICBwYXRoOiBbJ3N0eWxlJ10sXG4gICAgICAgIHZhbHVlOiBzdHlsZS5jb25jYXQoW25ld1N0eWxlXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzZXR1cE5hdGl2ZVN0eWxlRWRpdG9yX3R5cGVvZihzdHlsZSkgPT09ICdvYmplY3QnKSB7XG4gICAgY3VzdG9tU3R5bGUgPSBzaGFsbG93Q2xvbmUoc3R5bGUpO1xuICAgIGRlbGV0ZSBjdXN0b21TdHlsZVtvbGROYW1lXTtcblxuICAgIGlmIChuZXdOYW1lKSB7XG4gICAgICBjdXN0b21TdHlsZVtuZXdOYW1lXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXN0b21TdHlsZVtvbGROYW1lXSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBhZ2VudC5vdmVycmlkZVZhbHVlQXRQYXRoKHtcbiAgICAgIHR5cGU6ICdwcm9wcycsXG4gICAgICBpZDogaWQsXG4gICAgICByZW5kZXJlcklEOiByZW5kZXJlcklELFxuICAgICAgcGF0aDogWydzdHlsZSddLFxuICAgICAgdmFsdWU6IGN1c3RvbVN0eWxlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYWdlbnQub3ZlcnJpZGVWYWx1ZUF0UGF0aCh7XG4gICAgICB0eXBlOiAncHJvcHMnLFxuICAgICAgaWQ6IGlkLFxuICAgICAgcmVuZGVyZXJJRDogcmVuZGVyZXJJRCxcbiAgICAgIHBhdGg6IFsnc3R5bGUnXSxcbiAgICAgIHZhbHVlOiBbc3R5bGUsIG5ld1N0eWxlXVxuICAgIH0pO1xuICB9XG5cbiAgYWdlbnQuZW1pdCgnaGlkZU5hdGl2ZUhpZ2hsaWdodCcpO1xufVxuXG5mdW5jdGlvbiBzZXRTdHlsZShhZ2VudCwgaWQsIHJlbmRlcmVySUQsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gYWdlbnQuZ2V0SW5zdGFuY2VBbmRTdHlsZSh7XG4gICAgaWQ6IGlkLFxuICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySURcbiAgfSk7XG5cbiAgaWYgKCFkYXRhIHx8ICFkYXRhLnN0eWxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gZGF0YS5pbnN0YW5jZSxcbiAgICAgIHN0eWxlID0gZGF0YS5zdHlsZTtcblxuICB2YXIgbmV3U3R5bGUgPSBzZXR1cE5hdGl2ZVN0eWxlRWRpdG9yX2RlZmluZVByb3BlcnR5KHt9LCBuYW1lLCB2YWx1ZSk7IC8vIFRPRE8gSXQgd291bGQgYmUgbmljZSBpZiB0aGUgcmVuZGVyZXIgaW50ZXJmYWNlIGFic3RyYWN0ZWQgdGhpcyBhd2F5IHNvbWVob3cuXG5cblxuICBpZiAoaW5zdGFuY2UgIT09IG51bGwgJiYgdHlwZW9mIGluc3RhbmNlLnNldE5hdGl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gSW4gdGhlIGNhc2Ugb2YgYSBob3N0IGNvbXBvbmVudCwgd2UgbmVlZCB0byB1c2Ugc2V0TmF0aXZlUHJvcHMoKS5cbiAgICAvLyBSZW1lbWJlciB0byBcImNvcnJlY3RcIiByZXNvbHZlZCBzdHlsZXMgd2hlbiB3ZSByZWFkIHRoZW0gbmV4dCB0aW1lLlxuICAgIHZhciBzdHlsZU92ZXJyaWRlcyA9IGNvbXBvbmVudElEVG9TdHlsZU92ZXJyaWRlcy5nZXQoaWQpO1xuXG4gICAgaWYgKCFzdHlsZU92ZXJyaWRlcykge1xuICAgICAgY29tcG9uZW50SURUb1N0eWxlT3ZlcnJpZGVzLnNldChpZCwgbmV3U3R5bGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3QuYXNzaWduKHN0eWxlT3ZlcnJpZGVzLCBuZXdTdHlsZSk7XG4gICAgfSAvLyBUT0RPIEZhYnJpYyBkb2VzIG5vdCBzdXBwb3J0IHNldE5hdGl2ZVByb3BzOyBjaGF0IHdpdGggU2ViYXN0aWFuIG9yIEVsaVxuXG5cbiAgICBpbnN0YW5jZS5zZXROYXRpdmVQcm9wcyh7XG4gICAgICBzdHlsZTogbmV3U3R5bGVcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChPYmplY3QoaXNBcnJheVtcImFcIiAvKiBkZWZhdWx0ICovXSkoc3R5bGUpKSB7XG4gICAgdmFyIGxhc3RMZW5ndGggPSBzdHlsZS5sZW5ndGggLSAxO1xuXG4gICAgaWYgKHNldHVwTmF0aXZlU3R5bGVFZGl0b3JfdHlwZW9mKHN0eWxlW2xhc3RMZW5ndGhdKSA9PT0gJ29iamVjdCcgJiYgIU9iamVjdChpc0FycmF5W1wiYVwiIC8qIGRlZmF1bHQgKi9dKShzdHlsZVtsYXN0TGVuZ3RoXSkpIHtcbiAgICAgIGFnZW50Lm92ZXJyaWRlVmFsdWVBdFBhdGgoe1xuICAgICAgICB0eXBlOiAncHJvcHMnLFxuICAgICAgICBpZDogaWQsXG4gICAgICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySUQsXG4gICAgICAgIHBhdGg6IFsnc3R5bGUnLCBsYXN0TGVuZ3RoLCBuYW1lXSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWdlbnQub3ZlcnJpZGVWYWx1ZUF0UGF0aCh7XG4gICAgICAgIHR5cGU6ICdwcm9wcycsXG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgcmVuZGVyZXJJRDogcmVuZGVyZXJJRCxcbiAgICAgICAgcGF0aDogWydzdHlsZSddLFxuICAgICAgICB2YWx1ZTogc3R5bGUuY29uY2F0KFtuZXdTdHlsZV0pXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYWdlbnQub3ZlcnJpZGVWYWx1ZUF0UGF0aCh7XG4gICAgICB0eXBlOiAncHJvcHMnLFxuICAgICAgaWQ6IGlkLFxuICAgICAgcmVuZGVyZXJJRDogcmVuZGVyZXJJRCxcbiAgICAgIHBhdGg6IFsnc3R5bGUnXSxcbiAgICAgIHZhbHVlOiBbc3R5bGUsIG5ld1N0eWxlXVxuICAgIH0pO1xuICB9XG5cbiAgYWdlbnQuZW1pdCgnaGlkZU5hdGl2ZUhpZ2hsaWdodCcpO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY2FjaGVkU2V0dGluZ3MuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuIC8vIE5vdGU6IGFsbCBrZXlzIHNob3VsZCBiZSBvcHRpb25hbCBpbiB0aGlzIHR5cGUsIGJlY2F1c2UgdXNlcnMgY2FuIHVzZSBuZXdlclxuLy8gdmVyc2lvbnMgb2YgUmVhY3QgRGV2VG9vbHMgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBSZWFjdCBOYXRpdmUsIGFuZCB0aGUgb2JqZWN0XG4vLyBwcm92aWRlZCBieSBSZWFjdCBOYXRpdmUgbWF5IG5vdCBpbmNsdWRlIGFsbCBvZiB0aGlzIHR5cGUncyBmaWVsZHMuXG5cbmZ1bmN0aW9uIGluaXRpYWxpemVVc2luZ0NhY2hlZFNldHRpbmdzKGRldlRvb2xzU2V0dGluZ3NNYW5hZ2VyKSB7XG4gIGluaXRpYWxpemVDb25zb2xlUGF0Y2hTZXR0aW5ncyhkZXZUb29sc1NldHRpbmdzTWFuYWdlcik7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVDb25zb2xlUGF0Y2hTZXR0aW5ncyhkZXZUb29sc1NldHRpbmdzTWFuYWdlcikge1xuICBpZiAoZGV2VG9vbHNTZXR0aW5nc01hbmFnZXIuZ2V0Q29uc29sZVBhdGNoU2V0dGluZ3MgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb25zb2xlUGF0Y2hTZXR0aW5nc1N0cmluZyA9IGRldlRvb2xzU2V0dGluZ3NNYW5hZ2VyLmdldENvbnNvbGVQYXRjaFNldHRpbmdzKCk7XG5cbiAgaWYgKGNvbnNvbGVQYXRjaFNldHRpbmdzU3RyaW5nID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFyc2VkQ29uc29sZVBhdGNoU2V0dGluZ3MgPSBwYXJzZUNvbnNvbGVQYXRjaFNldHRpbmdzKGNvbnNvbGVQYXRjaFNldHRpbmdzU3RyaW5nKTtcblxuICBpZiAocGFyc2VkQ29uc29sZVBhdGNoU2V0dGluZ3MgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIE9iamVjdChiYWNrZW5kX2NvbnNvbGVbXCJnXCIgLyogd3JpdGVDb25zb2xlUGF0Y2hTZXR0aW5nc1RvV2luZG93ICovXSkocGFyc2VkQ29uc29sZVBhdGNoU2V0dGluZ3MpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNvbnNvbGVQYXRjaFNldHRpbmdzKGNvbnNvbGVQYXRjaFNldHRpbmdzU3RyaW5nKSB7XG4gIHZhciBfY2FzdEJvb2wsIF9jYXN0Qm9vbDIsIF9jYXN0Qm9vbDMsIF9jYXN0Qm9vbDQsIF9jYXN0QnJvd3NlclRoZW1lO1xuXG4gIHZhciBwYXJzZWRWYWx1ZSA9IEpTT04ucGFyc2UoY29uc29sZVBhdGNoU2V0dGluZ3NTdHJpbmcgIT09IG51bGwgJiYgY29uc29sZVBhdGNoU2V0dGluZ3NTdHJpbmcgIT09IHZvaWQgMCA/IGNvbnNvbGVQYXRjaFNldHRpbmdzU3RyaW5nIDogJ3t9Jyk7XG4gIHZhciBhcHBlbmRDb21wb25lbnRTdGFjayA9IHBhcnNlZFZhbHVlLmFwcGVuZENvbXBvbmVudFN0YWNrLFxuICAgICAgYnJlYWtPbkNvbnNvbGVFcnJvcnMgPSBwYXJzZWRWYWx1ZS5icmVha09uQ29uc29sZUVycm9ycyxcbiAgICAgIHNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycyA9IHBhcnNlZFZhbHVlLnNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycyxcbiAgICAgIGhpZGVDb25zb2xlTG9nc0luU3RyaWN0TW9kZSA9IHBhcnNlZFZhbHVlLmhpZGVDb25zb2xlTG9nc0luU3RyaWN0TW9kZSxcbiAgICAgIGJyb3dzZXJUaGVtZSA9IHBhcnNlZFZhbHVlLmJyb3dzZXJUaGVtZTtcbiAgcmV0dXJuIHtcbiAgICBhcHBlbmRDb21wb25lbnRTdGFjazogKF9jYXN0Qm9vbCA9IE9iamVjdChzcmNfdXRpbHNbXCJhXCIgLyogY2FzdEJvb2wgKi9dKShhcHBlbmRDb21wb25lbnRTdGFjaykpICE9PSBudWxsICYmIF9jYXN0Qm9vbCAhPT0gdm9pZCAwID8gX2Nhc3RCb29sIDogdHJ1ZSxcbiAgICBicmVha09uQ29uc29sZUVycm9yczogKF9jYXN0Qm9vbDIgPSBPYmplY3Qoc3JjX3V0aWxzW1wiYVwiIC8qIGNhc3RCb29sICovXSkoYnJlYWtPbkNvbnNvbGVFcnJvcnMpKSAhPT0gbnVsbCAmJiBfY2FzdEJvb2wyICE9PSB2b2lkIDAgPyBfY2FzdEJvb2wyIDogZmFsc2UsXG4gICAgc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzOiAoX2Nhc3RCb29sMyA9IE9iamVjdChzcmNfdXRpbHNbXCJhXCIgLyogY2FzdEJvb2wgKi9dKShzaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnMpKSAhPT0gbnVsbCAmJiBfY2FzdEJvb2wzICE9PSB2b2lkIDAgPyBfY2FzdEJvb2wzIDogdHJ1ZSxcbiAgICBoaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGU6IChfY2FzdEJvb2w0ID0gT2JqZWN0KHNyY191dGlsc1tcImFcIiAvKiBjYXN0Qm9vbCAqL10pKGhpZGVDb25zb2xlTG9nc0luU3RyaWN0TW9kZSkpICE9PSBudWxsICYmIF9jYXN0Qm9vbDQgIT09IHZvaWQgMCA/IF9jYXN0Qm9vbDQgOiBmYWxzZSxcbiAgICBicm93c2VyVGhlbWU6IChfY2FzdEJyb3dzZXJUaGVtZSA9IE9iamVjdChzcmNfdXRpbHNbXCJiXCIgLyogY2FzdEJyb3dzZXJUaGVtZSAqL10pKGJyb3dzZXJUaGVtZSkpICE9PSBudWxsICYmIF9jYXN0QnJvd3NlclRoZW1lICE9PSB2b2lkIDAgPyBfY2FzdEJyb3dzZXJUaGVtZSA6ICdkYXJrJ1xuICB9O1xufVxuXG5mdW5jdGlvbiBjYWNoZUNvbnNvbGVQYXRjaFNldHRpbmdzKGRldlRvb2xzU2V0dGluZ3NNYW5hZ2VyLCB2YWx1ZSkge1xuICBpZiAoZGV2VG9vbHNTZXR0aW5nc01hbmFnZXIuc2V0Q29uc29sZVBhdGNoU2V0dGluZ3MgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRldlRvb2xzU2V0dGluZ3NNYW5hZ2VyLnNldENvbnNvbGVQYXRjaFNldHRpbmdzKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9iYWNrZW5kLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuXG5cblxuXG5cblxuXG5cbi8vIEluc3RhbGwgYSBnbG9iYWwgdmFyaWFibGUgdG8gYWxsb3cgcGF0Y2hpbmcgY29uc29sZSBlYXJseSAoZHVyaW5nIGluamVjdGlvbikuXG4vLyBUaGlzIHByb3ZpZGVzIFJlYWN0IE5hdGl2ZSBkZXZlbG9wZXJzIHdpdGggY29tcG9uZW50cyBzdGFja3MgZXZlbiBpZiB0aGV5IGRvbid0IHJ1biBEZXZUb29scy5cbk9iamVjdChiYWNrZW5kX2NvbnNvbGVbXCJhXCIgLyogaW5zdGFsbENvbnNvbGVGdW5jdGlvbnNUb1dpbmRvdyAqL10pKCk7XG5pbnN0YWxsSG9vayh3aW5kb3cpO1xudmFyIGJhY2tlbmRfaG9vayA9IHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG52YXIgc2F2ZWRDb21wb25lbnRGaWx0ZXJzID0gT2JqZWN0KHNyY191dGlsc1tcImdcIiAvKiBnZXREZWZhdWx0Q29tcG9uZW50RmlsdGVycyAqL10pKCk7XG5cbmZ1bmN0aW9uIGJhY2tlbmRfZGVidWcobWV0aG9kTmFtZSkge1xuICBpZiAoY29uc3RhbnRzW1wic1wiIC8qIF9fREVCVUdfXyAqL10pIHtcbiAgICB2YXIgX2NvbnNvbGU7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICAoX2NvbnNvbGUgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUsIFtcIiVjW2NvcmUvYmFja2VuZF0gJWNcIi5jb25jYXQobWV0aG9kTmFtZSksICdjb2xvcjogdGVhbDsgZm9udC13ZWlnaHQ6IGJvbGQ7JywgJ2ZvbnQtd2VpZ2h0OiBib2xkOyddLmNvbmNhdChhcmdzKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29ubmVjdFRvRGV2VG9vbHMob3B0aW9ucykge1xuICBpZiAoYmFja2VuZF9ob29rID09IG51bGwpIHtcbiAgICAvLyBEZXZUb29scyBkaWRuJ3QgZ2V0IGluamVjdGVkIGludG8gdGhpcyBwYWdlIChtYXliZSBiJ2Mgb2YgdGhlIGNvbnRlbnRUeXBlKS5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgX3JlZiA9IG9wdGlvbnMgfHwge30sXG4gICAgICBfcmVmJGhvc3QgPSBfcmVmLmhvc3QsXG4gICAgICBob3N0ID0gX3JlZiRob3N0ID09PSB2b2lkIDAgPyAnbG9jYWxob3N0JyA6IF9yZWYkaG9zdCxcbiAgICAgIG5hdGl2ZVN0eWxlRWRpdG9yVmFsaWRBdHRyaWJ1dGVzID0gX3JlZi5uYXRpdmVTdHlsZUVkaXRvclZhbGlkQXR0cmlidXRlcyxcbiAgICAgIF9yZWYkdXNlSHR0cHMgPSBfcmVmLnVzZUh0dHBzLFxuICAgICAgdXNlSHR0cHMgPSBfcmVmJHVzZUh0dHBzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkdXNlSHR0cHMsXG4gICAgICBfcmVmJHBvcnQgPSBfcmVmLnBvcnQsXG4gICAgICBwb3J0ID0gX3JlZiRwb3J0ID09PSB2b2lkIDAgPyA4MDk3IDogX3JlZiRwb3J0LFxuICAgICAgd2Vic29ja2V0ID0gX3JlZi53ZWJzb2NrZXQsXG4gICAgICBfcmVmJHJlc29sdmVSTlN0eWxlID0gX3JlZi5yZXNvbHZlUk5TdHlsZSxcbiAgICAgIHJlc29sdmVSTlN0eWxlID0gX3JlZiRyZXNvbHZlUk5TdHlsZSA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYkcmVzb2x2ZVJOU3R5bGUsXG4gICAgICBfcmVmJHJldHJ5Q29ubmVjdGlvbkQgPSBfcmVmLnJldHJ5Q29ubmVjdGlvbkRlbGF5LFxuICAgICAgcmV0cnlDb25uZWN0aW9uRGVsYXkgPSBfcmVmJHJldHJ5Q29ubmVjdGlvbkQgPT09IHZvaWQgMCA/IDIwMDAgOiBfcmVmJHJldHJ5Q29ubmVjdGlvbkQsXG4gICAgICBfcmVmJGlzQXBwQWN0aXZlID0gX3JlZi5pc0FwcEFjdGl2ZSxcbiAgICAgIGlzQXBwQWN0aXZlID0gX3JlZiRpc0FwcEFjdGl2ZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IDogX3JlZiRpc0FwcEFjdGl2ZSxcbiAgICAgIGRldlRvb2xzU2V0dGluZ3NNYW5hZ2VyID0gX3JlZi5kZXZUb29sc1NldHRpbmdzTWFuYWdlcjtcblxuICB2YXIgcHJvdG9jb2wgPSB1c2VIdHRwcyA/ICd3c3MnIDogJ3dzJztcbiAgdmFyIHJldHJ5VGltZW91dElEID0gbnVsbDtcblxuICBmdW5jdGlvbiBzY2hlZHVsZVJldHJ5KCkge1xuICAgIGlmIChyZXRyeVRpbWVvdXRJRCA9PT0gbnVsbCkge1xuICAgICAgLy8gVHdvIHNlY29uZHMgYmVjYXVzZSBSTiBoYWQgaXNzdWVzIHdpdGggcXVpY2sgcmV0cmllcy5cbiAgICAgIHJldHJ5VGltZW91dElEID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0VG9EZXZUb29scyhvcHRpb25zKTtcbiAgICAgIH0sIHJldHJ5Q29ubmVjdGlvbkRlbGF5KTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGV2VG9vbHNTZXR0aW5nc01hbmFnZXIgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICBpbml0aWFsaXplVXNpbmdDYWNoZWRTZXR0aW5ncyhkZXZUb29sc1NldHRpbmdzTWFuYWdlcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSWYgd2UgY2FsbCBhIG1ldGhvZCBvbiBkZXZUb29sc1NldHRpbmdzTWFuYWdlciB0aGF0IHRocm93cywgb3IgaWZcbiAgICAgIC8vIGlzIGludmFsaWQgZGF0YSByZWFkIG91dCwgZG9uJ3QgdGhyb3cgYW5kIGRvbid0IGludGVycnVwdCBpbml0aWFsaXphdGlvblxuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWlzQXBwQWN0aXZlKCkpIHtcbiAgICAvLyBJZiB0aGUgYXBwIGlzIGluIGJhY2tncm91bmQsIG1heWJlIHJldHJ5IGxhdGVyLlxuICAgIC8vIERvbid0IGFjdHVhbGx5IGF0dGVtcHQgdG8gY29ubmVjdCB1bnRpbCB3ZSdyZSBpbiBmb3JlZ3JvdW5kLlxuICAgIHNjaGVkdWxlUmV0cnkoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYnJpZGdlID0gbnVsbDtcbiAgdmFyIG1lc3NhZ2VMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIHVyaSA9IHByb3RvY29sICsgJzovLycgKyBob3N0ICsgJzonICsgcG9ydDsgLy8gSWYgZXhpc3Rpbmcgd2Vic29ja2V0IGlzIHBhc3NlZCwgdXNlIGl0LlxuICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSB0byBzdXBwb3J0IG91ciBjdXN0b20gaW50ZWdyYXRpb25zLlxuICAvLyBTZWUgRDYyNTE3NDQuXG5cbiAgdmFyIHdzID0gd2Vic29ja2V0ID8gd2Vic29ja2V0IDogbmV3IHdpbmRvdy5XZWJTb2NrZXQodXJpKTtcbiAgd3Mub25jbG9zZSA9IGhhbmRsZUNsb3NlO1xuICB3cy5vbmVycm9yID0gaGFuZGxlRmFpbGVkO1xuICB3cy5vbm1lc3NhZ2UgPSBoYW5kbGVNZXNzYWdlO1xuXG4gIHdzLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBicmlkZ2UgPSBuZXcgc3JjX2JyaWRnZSh7XG4gICAgICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3Rlbihmbikge1xuICAgICAgICBtZXNzYWdlTGlzdGVuZXJzLnB1c2goZm4pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpbmRleCA9IG1lc3NhZ2VMaXN0ZW5lcnMuaW5kZXhPZihmbik7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgbWVzc2FnZUxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBzZW5kOiBmdW5jdGlvbiBzZW5kKGV2ZW50LCBwYXlsb2FkLCB0cmFuc2ZlcmFibGUpIHtcbiAgICAgICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLk9QRU4pIHtcbiAgICAgICAgICBpZiAoY29uc3RhbnRzW1wic1wiIC8qIF9fREVCVUdfXyAqL10pIHtcbiAgICAgICAgICAgIGJhY2tlbmRfZGVidWcoJ3dhbGwuc2VuZCgpJywgZXZlbnQsIHBheWxvYWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdzLnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY29uc3RhbnRzW1wic1wiIC8qIF9fREVCVUdfXyAqL10pIHtcbiAgICAgICAgICAgIGJhY2tlbmRfZGVidWcoJ3dhbGwuc2VuZCgpJywgJ1NodXR0aW5nIGRvd24gYnJpZGdlIGJlY2F1c2Ugb2YgY2xvc2VkIFdlYlNvY2tldCBjb25uZWN0aW9uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGJyaWRnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYnJpZGdlLnNodXRkb3duKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2NoZWR1bGVSZXRyeSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCd1cGRhdGVDb21wb25lbnRGaWx0ZXJzJywgZnVuY3Rpb24gKGNvbXBvbmVudEZpbHRlcnMpIHtcbiAgICAgIC8vIFNhdmUgZmlsdGVyIGNoYW5nZXMgaW4gbWVtb3J5LCBpbiBjYXNlIERldlRvb2xzIGlzIHJlbG9hZGVkLlxuICAgICAgLy8gSW4gdGhhdCBjYXNlLCB0aGUgcmVuZGVyZXIgd2lsbCBhbHJlYWR5IGJlIHVzaW5nIHRoZSB1cGRhdGVkIHZhbHVlcy5cbiAgICAgIC8vIFdlJ2xsIGxvc2UgdGhlc2UgaW4gYmV0d2VlbiBiYWNrZW5kIHJlbG9hZHMgYnV0IHRoYXQgY2FuJ3QgYmUgaGVscGVkLlxuICAgICAgc2F2ZWRDb21wb25lbnRGaWx0ZXJzID0gY29tcG9uZW50RmlsdGVycztcbiAgICB9KTtcblxuICAgIGlmIChkZXZUb29sc1NldHRpbmdzTWFuYWdlciAhPSBudWxsICYmIGJyaWRnZSAhPSBudWxsKSB7XG4gICAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3VwZGF0ZUNvbnNvbGVQYXRjaFNldHRpbmdzJywgZnVuY3Rpb24gKGNvbnNvbGVQYXRjaFNldHRpbmdzKSB7XG4gICAgICAgIHJldHVybiBjYWNoZUNvbnNvbGVQYXRjaFNldHRpbmdzKGRldlRvb2xzU2V0dGluZ3NNYW5hZ2VyLCBjb25zb2xlUGF0Y2hTZXR0aW5ncyk7XG4gICAgICB9KTtcbiAgICB9IC8vIFRoZSByZW5kZXJlciBpbnRlcmZhY2UgZG9lc24ndCByZWFkIHNhdmVkIGNvbXBvbmVudCBmaWx0ZXJzIGRpcmVjdGx5LFxuICAgIC8vIGJlY2F1c2UgdGhleSBhcmUgZ2VuZXJhbGx5IHN0b3JlZCBpbiBsb2NhbFN0b3JhZ2Ugd2l0aGluIHRoZSBjb250ZXh0IG9mIHRoZSBleHRlbnNpb24uXG4gICAgLy8gQmVjYXVzZSBvZiB0aGlzIGl0IHJlbGllcyBvbiB0aGUgZXh0ZW5zaW9uIHRvIHBhc3MgZmlsdGVycy5cbiAgICAvLyBJbiB0aGUgY2FzZSBvZiB0aGUgc3RhbmRhbG9uZSBEZXZUb29scyBiZWluZyB1c2VkIHdpdGggYSB3ZWJzaXRlLFxuICAgIC8vIHNhdmVkIGZpbHRlcnMgYXJlIGluamVjdGVkIGFsb25nIHdpdGggdGhlIGJhY2tlbmQgc2NyaXB0IHRhZyBzbyB3ZSBzaG91bGRuJ3Qgb3ZlcnJpZGUgdGhlbSBoZXJlLlxuICAgIC8vIFRoaXMgaW5qZWN0aW9uIHN0cmF0ZWd5IGRvZXNuJ3Qgd29yayBmb3IgUmVhY3QgTmF0aXZlIHRob3VnaC5cbiAgICAvLyBJZGVhbGx5IHRoZSBiYWNrZW5kIHdvdWxkIHNhdmUgdGhlIGZpbHRlcnMgaXRzZWxmLCBidXQgUk4gZG9lc24ndCBwcm92aWRlIGEgc3luYyBzdG9yYWdlIHNvbHV0aW9uLlxuICAgIC8vIFNvIGZvciBub3cgd2UganVzdCBmYWxsIGJhY2sgdG8gdXNpbmcgdGhlIGRlZmF1bHQgZmlsdGVycy4uLlxuXG5cbiAgICBpZiAod2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfQ09NUE9ORU5UX0ZJTFRFUlNfXyA9PSBudWxsKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgIGJyaWRnZS5zZW5kKCdvdmVycmlkZUNvbXBvbmVudEZpbHRlcnMnLCBzYXZlZENvbXBvbmVudEZpbHRlcnMpO1xuICAgIH0gLy8gVE9ETyAobnBtLXBhY2thZ2VzKSBXYXJuIGlmIFwiaXNCYWNrZW5kU3RvcmFnZUFQSVN1cHBvcnRlZFwiXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICB2YXIgYWdlbnQgPSBuZXcgYWdlbnRfQWdlbnQoYnJpZGdlKTtcbiAgICBhZ2VudC5hZGRMaXN0ZW5lcignc2h1dGRvd24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBJZiB3ZSByZWNlaXZlZCAnc2h1dGRvd24nIGZyb20gYGFnZW50YCwgd2UgYXNzdW1lIHRoZSBgYnJpZGdlYCBpcyBhbHJlYWR5IHNodXR0aW5nIGRvd24sXG4gICAgICAvLyBhbmQgdGhhdCBjYXVzZWQgdGhlICdzaHV0ZG93bicgZXZlbnQgb24gdGhlIGBhZ2VudGAsIHNvIHdlIGRvbid0IG5lZWQgdG8gY2FsbCBgYnJpZGdlLnNodXRkb3duKClgIGhlcmUuXG4gICAgICBiYWNrZW5kX2hvb2suZW1pdCgnc2h1dGRvd24nKTtcbiAgICB9KTtcbiAgICBpbml0QmFja2VuZChiYWNrZW5kX2hvb2ssIGFnZW50LCB3aW5kb3cpOyAvLyBTZXR1cCBSZWFjdCBOYXRpdmUgc3R5bGUgZWRpdG9yIGlmIHRoZSBlbnZpcm9ubWVudCBzdXBwb3J0cyBpdC5cblxuICAgIGlmIChyZXNvbHZlUk5TdHlsZSAhPSBudWxsIHx8IGJhY2tlbmRfaG9vay5yZXNvbHZlUk5TdHlsZSAhPSBudWxsKSB7XG4gICAgICBzZXR1cE5hdGl2ZVN0eWxlRWRpdG9yKCAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICBicmlkZ2UsIGFnZW50LCByZXNvbHZlUk5TdHlsZSB8fCBiYWNrZW5kX2hvb2sucmVzb2x2ZVJOU3R5bGUsIG5hdGl2ZVN0eWxlRWRpdG9yVmFsaWRBdHRyaWJ1dGVzIHx8IGJhY2tlbmRfaG9vay5uYXRpdmVTdHlsZUVkaXRvclZhbGlkQXR0cmlidXRlcyB8fCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIGxpc3RlbiB0byBkZXRlY3QgaWYgdGhlIGVudmlyb25tZW50IGxhdGVyIHN1cHBvcnRzIGl0LlxuICAgICAgLy8gRm9yIGV4YW1wbGUsIEZsaXBwZXIgZG9lcyBub3QgZWFnZXJseSBpbmplY3QgdGhlc2UgdmFsdWVzLlxuICAgICAgLy8gSW5zdGVhZCBpdCByZWxpZXMgb24gdGhlIFJlYWN0IE5hdGl2ZSBJbnNwZWN0b3IgdG8gbGF6aWx5IGluamVjdCB0aGVtLlxuICAgICAgdmFyIGxhenlSZXNvbHZlUk5TdHlsZTtcbiAgICAgIHZhciBsYXp5TmF0aXZlU3R5bGVFZGl0b3JWYWxpZEF0dHJpYnV0ZXM7XG5cbiAgICAgIHZhciBpbml0QWZ0ZXJUaWNrID0gZnVuY3Rpb24gaW5pdEFmdGVyVGljaygpIHtcbiAgICAgICAgaWYgKGJyaWRnZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHNldHVwTmF0aXZlU3R5bGVFZGl0b3IoYnJpZGdlLCBhZ2VudCwgbGF6eVJlc29sdmVSTlN0eWxlLCBsYXp5TmF0aXZlU3R5bGVFZGl0b3JWYWxpZEF0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoIWJhY2tlbmRfaG9vay5oYXNPd25Qcm9wZXJ0eSgncmVzb2x2ZVJOU3R5bGUnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYmFja2VuZF9ob29rLCAncmVzb2x2ZVJOU3R5bGUnLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbGF6eVJlc29sdmVSTlN0eWxlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIGxhenlSZXNvbHZlUk5TdHlsZSA9IHZhbHVlO1xuICAgICAgICAgICAgaW5pdEFmdGVyVGljaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghYmFja2VuZF9ob29rLmhhc093blByb3BlcnR5KCduYXRpdmVTdHlsZUVkaXRvclZhbGlkQXR0cmlidXRlcycpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiYWNrZW5kX2hvb2ssICduYXRpdmVTdHlsZUVkaXRvclZhbGlkQXR0cmlidXRlcycsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXp5TmF0aXZlU3R5bGVFZGl0b3JWYWxpZEF0dHJpYnV0ZXM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgbGF6eU5hdGl2ZVN0eWxlRWRpdG9yVmFsaWRBdHRyaWJ1dGVzID0gdmFsdWU7XG4gICAgICAgICAgICBpbml0QWZ0ZXJUaWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ2xvc2UoKSB7XG4gICAgaWYgKGNvbnN0YW50c1tcInNcIiAvKiBfX0RFQlVHX18gKi9dKSB7XG4gICAgICBiYWNrZW5kX2RlYnVnKCdXZWJTb2NrZXQub25jbG9zZScpO1xuICAgIH1cblxuICAgIGlmIChicmlkZ2UgIT09IG51bGwpIHtcbiAgICAgIGJyaWRnZS5lbWl0KCdzaHV0ZG93bicpO1xuICAgIH1cblxuICAgIHNjaGVkdWxlUmV0cnkoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUZhaWxlZCgpIHtcbiAgICBpZiAoY29uc3RhbnRzW1wic1wiIC8qIF9fREVCVUdfXyAqL10pIHtcbiAgICAgIGJhY2tlbmRfZGVidWcoJ1dlYlNvY2tldC5vbmVycm9yJyk7XG4gICAgfVxuXG4gICAgc2NoZWR1bGVSZXRyeSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldmVudCkge1xuICAgIHZhciBkYXRhO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgZXZlbnQuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG5cbiAgICAgICAgaWYgKGNvbnN0YW50c1tcInNcIiAvKiBfX0RFQlVHX18gKi9dKSB7XG4gICAgICAgICAgYmFja2VuZF9kZWJ1ZygnV2ViU29ja2V0Lm9ubWVzc2FnZScsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tSZWFjdCBEZXZUb29sc10gRmFpbGVkIHRvIHBhcnNlIEpTT046ICcgKyBldmVudC5kYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtZXNzYWdlTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmbihkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIGpzYyBkb2Vzbid0IHBsYXkgc28gd2VsbCB3aXRoIHRyYWNlYmFja3MgdGhhdCBnbyBpbnRvIGV2YWwnZCBjb2RlLFxuICAgICAgICAvLyBzbyB0aGUgc3RhY2sgdHJhY2UgaGVyZSB3aWxsIHN0b3AgYXQgdGhlIGAoMCxldmFsKSgpYCBjYWxsLiBHZXR0aW5nIHRoZVxuICAgICAgICAvLyBtZXNzYWdlIHRoYXQgY2F1c2VkIHRoZSBlcnJvciBpcyB0aGUgYmVzdCB3ZSBjYW4gZG8gZm9yIG5vdy5cbiAgICAgICAgY29uc29sZS5sb2coJ1tSZWFjdCBEZXZUb29sc10gRXJyb3IgY2FsbGluZyBsaXN0ZW5lcicsIGRhdGEpO1xuICAgICAgICBjb25zb2xlLmxvZygnZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tlbmQuanMubWFwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuY29uc3Qge2Nvbm5lY3RUb0RldlRvb2xzfSA9IHJlcXVpcmUoJ3JlYWN0LWRldnRvb2xzLWNvcmUvYmFja2VuZCcpO1xuXG4vLyBDb25uZWN0IGltbWVkaWF0ZWx5IHdpdGggZGVmYXVsdCBvcHRpb25zLlxuLy8gSWYgeW91IG5lZWQgbW9yZSBjb250cm9sLCB1c2UgYHJlYWN0LWRldnRvb2xzLWNvcmVgIGRpcmVjdGx5IGluc3RlYWQgb2YgYHJlYWN0LWRldnRvb2xzYC5cbmNvbm5lY3RUb0RldlRvb2xzKCk7XG4iXSwicHJlRXhpc3RpbmdDb21tZW50IjoiLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIn0=
